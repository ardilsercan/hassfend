/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_codemirror_commands_dist_index_js";
export const ids = ["vendors-node_modules_codemirror_commands_dist_index_js"];
export const modules = {

/***/ "./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n  let {\n      state\n    } = target,\n    line = state.doc.lineAt(state.selection.main.from),\n    config = getConfig(target.state, line.from);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let tr = f(option, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* CommentOption.Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* CommentOption.Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);\nfunction getConfig(state, pos) {\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, {\n  open,\n  close\n}, from, to) {\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n    spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n  let startText, endText;\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n  let startSpace = /^\\s*/.exec(startText)[0].length,\n    endSpace = /\\s*$/.exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n  return null;\n}\nfunction selectedLineRanges(state) {\n  let ranges = [];\n  for (let r of state.selection.ranges) {\n    let fromLine = state.doc.lineAt(r.from);\n    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({\n      from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n      to: toLine.to\n    });\n  }\n  return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n  if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {\n    return {\n      changes: state.changes(ranges.map((range, i) => {\n        if (comments[i]) return [];\n        return [{\n          from: range.from,\n          insert: tokens[i].open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + tokens[i].close\n        }];\n      }))\n    };\n  } else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {\n    let changes = [];\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i],\n        {\n          open,\n          close\n        } = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n    return {\n      changes\n    };\n  }\n  return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n  let lines = [];\n  let prevLine = -1;\n  for (let {\n    from,\n    to\n  } of ranges) {\n    let startI = lines.length,\n      minIndent = 1e9;\n    let token = getConfig(state, from).line;\n    if (!token) continue;\n    for (let pos = from; pos <= to;) {\n      let line = state.doc.lineAt(pos);\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let indent = /^\\s*/.exec(line.text)[0].length;\n        let empty = indent == line.length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          empty,\n          single: false\n        });\n      }\n      pos = line.to + 1;\n    }\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n  if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n    let changes = [];\n    for (let {\n      line,\n      token,\n      indent,\n      empty,\n      single\n    } of lines) if (single || !empty) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n    for (let {\n      line,\n      comment,\n      token\n    } of lines) if (comment >= 0) {\n      let from = line.from + comment,\n        to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n    return {\n      changes\n    };\n  }\n  return null;\n}\nconst fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n      minDepth: 100,\n      newGroupDelay: 500,\n      joinToEvent: (_t, isAdjacent) => isAdjacent\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min,\n      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)\n    });\n  }\n});\nconst historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n  create() {\n    return HistoryState.empty;\n  },\n  update(state, tr) {\n    let config = tr.state.facet(historyConfig);\n    let fromHist = tr.annotation(fromHistory);\n    if (fromHist) {\n      let item = HistEvent.fromTransaction(tr, fromHist.selection),\n        from = fromHist.side;\n      let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);\n    }\n    let isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    let event = HistEvent.fromTransaction(tr);\n    let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time),\n      userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config, tr);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n  toJSON(value) {\n    return {\n      done: value.done.map(e => e.toJSON()),\n      undone: value.undone.map(e => e.toJSON())\n    };\n  },\n  fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n  return [historyField_, historyConfig.of(config), _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    beforeinput(e, view) {\n      let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n      if (!command) return false;\n      e.preventDefault();\n      return command(view);\n    }\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n  return function ({\n    state,\n    dispatch\n  }) {\n    if (!selection && state.readOnly) return false;\n    let historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    let tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);\nfunction depth(side) {\n  return function (state) {\n    let histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* BranchName.Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* BranchName.Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n  constructor(\n  // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes,\n  // The effects associated with this event\n  effects,\n  // Accumulated mapping (from addToHistory==false) that should be\n  // applied to events below this one.\n  mapped,\n  // The selection before this event\n  startSelection,\n  // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n  setSelAfter(after) {\n    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n  }\n  toJSON() {\n    var _a, _b, _c;\n    return {\n      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n      selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n    };\n  }\n  static fromJSON(json) {\n    return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n  }\n  // This does not check `addToHistory` and such, it assumes the\n  // transaction needs to be converted to an item. Returns null when\n  // there are no changes or effects in the transaction.\n  static fromTransaction(tr, selection) {\n    let effects = none;\n    for (let invert of tr.startState.facet(invertedEffects)) {\n      let result = invert(tr);\n      if (result.length) effects = effects.concat(result);\n    }\n    if (!effects.length && tr.changes.empty) return null;\n    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n  }\n  static selection(selections) {\n    return new HistEvent(undefined, none, undefined, undefined, selections);\n  }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  let newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\nfunction isAdjacent(a, b) {\n  let ranges = [],\n    isAdjacent = false;\n  a.iterChangedRanges((f, t) => ranges.push(f, t));\n  b.iterChangedRanges((_f, _t, f, t) => {\n    for (let i = 0; i < ranges.length;) {\n      let from = ranges[i++],\n        to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    let lastEvent = branch[branch.length - 1];\n    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n  let last = branch[branch.length - 1];\n  let newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  let length = branch.length,\n    selections = none;\n  while (length) {\n    let event = mapEvent(branch[length - 1], mapping, selections);\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      let result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n  // Change-less events don't store mappings (they are always the last event in a branch)\n  if (!event.changes) return HistEvent.selection(selections);\n  let mappedChanges = event.changes.map(mapping),\n    before = mapping.mapDesc(event.changes, true);\n  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n  constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n  isolate() {\n    return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n  }\n  addChanges(event, time, userEvent, config, tr) {\n    let done = this.done,\n      lastEvent = done[done.length - 1];\n    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) ||\n    // For compose (but not compose.start) events, always join with previous event\n    userEvent == \"input.type.compose\")) {\n      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n    } else {\n      done = updateBranch(done, done.length, config.minDepth, event);\n    }\n    return new HistoryState(done, none, time, userEvent);\n  }\n  addSelection(selection, time, userEvent, newGroupDelay) {\n    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n  }\n  addMapping(mapping) {\n    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n  }\n  pop(side, state, onlySelection) {\n    let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;\n    if (branch.length == 0) return null;\n    let event = branch[branch.length - 1],\n      selection = event.selectionsAfter[0] || state.selection;\n    if (onlySelection && event.selectionsAfter.length) {\n      return state.update({\n        selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n        annotations: fromHistory.of({\n          side,\n          rest: popSelection(branch),\n          selection\n        }),\n        userEvent: side == 0 /* BranchName.Done */ ? \"select.undo\" : \"select.redo\",\n        scrollIntoView: true\n      });\n    } else if (!event.changes) {\n      return null;\n    } else {\n      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n      if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n      return state.update({\n        changes: event.changes,\n        selection: event.startSelection,\n        effects: event.effects,\n        annotations: fromHistory.of({\n          side,\n          rest,\n          selection\n        }),\n        filter: false,\n        userEvent: side == 0 /* BranchName.Done */ ? \"undo\" : \"redo\",\n        scrollIntoView: true\n      });\n    }\n  }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  linux: \"Ctrl-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\nfunction updateSel(sel, by) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n  return state.update({\n    selection,\n    scrollIntoView: true,\n    userEvent: \"select\"\n  });\n}\nfunction moveSel({\n  state,\n  dispatch\n}, how) {\n  let selection = updateSel(state.selection, how);\n  if (selection.eq(state.selection, true)) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\nfunction rangeEnd(range, forward) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n  return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/new Intl.Segmenter(undefined, {\n  granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n  let categorize = view.state.charCategorizer(range.from);\n  let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space,\n    pos = range.from,\n    steps = 0;\n  let done = false,\n    sawUpper = false,\n    sawLower = false;\n  let step = next => {\n    if (done) return false;\n    pos += forward ? next.length : -next.length;\n    let nextCat = categorize(next),\n      ahead;\n    if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n    if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n    if (cat != nextCat) return false;\n    if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n      if (next.toLowerCase() == next) {\n        if (!forward && sawUpper) return false;\n        sawLower = true;\n      } else if (sawLower) {\n        if (forward) return false;\n        done = true;\n      } else {\n        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n        sawUpper = true;\n      }\n    }\n    steps++;\n    return true;\n  };\n  let end = view.moveByChar(range, forward, start => {\n    step(start);\n    return step;\n  });\n  if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n    let from = Math.min(range.head, end.head),\n      to = Math.max(range.head, end.head);\n    let skipped = view.state.sliceDoc(from, to);\n    if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n      let segments = Array.from(segmenter.segment(skipped));\n      if (segments.length > 1) {\n        if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n      }\n    }\n  }\n  return end;\n}\nfunction cursorBySubword(view, forward) {\n  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n  if (node.type.prop(bracketProp)) return true;\n  let len = node.to - node.from;\n  return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n  let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n  let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n  // Scan forward through child nodes to see if there's an interesting\n  // node ahead.\n  for (let at = start.head;;) {\n    let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n    if (!next) break;\n    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;\n  }\n  let bracket = pos.type.prop(bracketProp),\n    match,\n    newPos;\n  if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n  return moveSel(view, range => {\n    if (!range.empty) return rangeEnd(range, forward);\n    let moved = view.moveVertically(range, forward);\n    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n  });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageInfo(view) {\n  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n  let marginTop = 0,\n    marginBottom = 0,\n    height;\n  if (selfScroll) {\n    for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)) {\n      let margins = source(view);\n      if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n      if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n    }\n    height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n  } else {\n    height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n  }\n  return {\n    marginTop,\n    marginBottom,\n    selfScroll,\n    height: Math.max(view.defaultLineHeight, height - 5)\n  };\n}\nfunction cursorByPage(view, forward) {\n  let page = pageInfo(view);\n  let {\n      state\n    } = view,\n    selection = updateSel(state.selection, range => {\n      return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n  if (selection.eq(state.selection)) return false;\n  let effect;\n  if (page.selfScroll) {\n    let startPos = view.coordsAtPos(state.selection.main.head);\n    let scrollRect = view.scrollDOM.getBoundingClientRect();\n    let scrollTop = scrollRect.top + page.marginTop,\n      scrollBottom = scrollRect.bottom - page.marginBottom;\n    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n      y: \"start\",\n      yMargin: startPos.top - scrollTop\n    });\n  }\n  view.dispatch(setSel(state, selection), {\n    effects: effect\n  });\n  return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n  let line = view.lineBlockAt(start.head),\n    moved = view.moveToLineBoundary(start, forward);\n  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n  if (!forward && moved.head == line.from && line.length) {\n    let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n    if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n  }\n  return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n  let found = false,\n    selection = updateSel(state.selection, range => {\n      let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n      if (!matching || !matching.end) return range;\n      found = true;\n      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n      return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n  if (!found) return false;\n  dispatch(setSel(state, selection));\n  return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({\n  state,\n  dispatch\n}) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n  let selection = updateSel(view.state.selection, range => {\n    let head = how(range);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n  });\n  if (selection.eq(view.state.selection)) return false;\n  view.dispatch(setSel(view.state, selection));\n  return true;\n}\nfunction selectByChar(view, forward) {\n  return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n  return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n  return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n  return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: 0\n  }));\n  return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.doc.length\n  }));\n  return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: 0\n  }));\n  return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({\n  state,\n  dispatch\n}) => {\n  dispatch(setSel(state, {\n    anchor: state.selection.main.anchor,\n    head: state.doc.length\n  }));\n  return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update({\n    selection: {\n      anchor: 0,\n      head: state.doc.length\n    },\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({\n  state,\n  dispatch\n}) => {\n  let ranges = selectedLineBlocks(state).map(({\n    from,\n    to\n  }) => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n  dispatch(state.update({\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n    userEvent: \"select\"\n  }));\n  return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({\n  state,\n  dispatch\n}) => {\n  let selection = updateSel(state.selection, range => {\n    var _a;\n    let stack = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveStack(range.from, 1);\n    for (let cur = stack; cur; cur = cur.next) {\n      let {\n        node\n      } = cur;\n      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n    }\n    return range;\n  });\n  dispatch(setSel(state, selection));\n  return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({\n  state,\n  dispatch\n}) => {\n  let cur = state.selection,\n    selection = null;\n  if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([cur.main]);else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)]);\n  if (!selection) return false;\n  dispatch(setSel(state, selection));\n  return true;\n};\nfunction deleteBy(target, by) {\n  if (target.state.readOnly) return false;\n  let event = \"delete.selection\",\n    {\n      state\n    } = target;\n  let changes = state.changeByRange(range => {\n    let {\n      from,\n      to\n    } = range;\n    if (from == to) {\n      let towards = by(range);\n      if (towards < from) {\n        event = \"delete.backward\";\n        towards = skipAtomic(target, towards, false);\n      } else if (towards > from) {\n        event = \"delete.forward\";\n        towards = skipAtomic(target, towards, true);\n      }\n      from = Math.min(from, towards);\n      to = Math.max(to, towards);\n    } else {\n      from = skipAtomic(target, from, false);\n      to = skipAtomic(target, to, true);\n    }\n    return from == to ? {\n      range\n    } : {\n      changes: {\n        from,\n        to\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n    };\n  });\n  if (changes.changes.empty) return false;\n  target.dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: event,\n    effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n  }));\n  return true;\n}\nfunction skipAtomic(target, pos, forward) {\n  if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map(f => f(target))) ranges.between(pos, pos, (from, to) => {\n    if (from < pos && to > pos) pos = forward ? to : from;\n  });\n  return pos;\n}\nconst deleteByChar = (target, forward) => deleteBy(target, range => {\n  let pos = range.from,\n    {\n      state\n    } = target,\n    line = state.doc.lineAt(pos),\n    before,\n    targetPos;\n  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n    if (before[before.length - 1] == \"\\t\") return pos - 1;\n    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize),\n      drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n    for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++) pos--;\n    targetPos = pos;\n  } else {\n    targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n  }\n  return targetPos;\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true);\nconst deleteByGroup = (target, forward) => deleteBy(target, range => {\n  let pos = range.head,\n    {\n      state\n    } = target,\n    line = state.doc.lineAt(pos);\n  let categorize = state.charCategorizer(pos);\n  for (let cat = null;;) {\n    if (pos == (forward ? line.to : line.from)) {\n      if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n      break;\n    }\n    let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n    let nextCat = categorize(nextChar);\n    if (cat != null && nextCat != cat) break;\n    if (nextChar != \" \" || pos != range.head) cat = nextCat;\n    pos = next;\n  }\n  return pos;\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, range => {\n  let lineEnd = view.lineBlockAt(range.head).to;\n  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, range => {\n  let lineStart = view.lineBlockAt(range.head).from;\n  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/\nconst deleteLineBoundaryBackward = view => deleteBy(view, range => {\n  let lineStart = view.moveToLineBoundary(range, false).head;\n  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/\nconst deleteLineBoundaryForward = view => deleteBy(view, range => {\n  let lineStart = view.moveToLineBoundary(range, true).head;\n  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = [];\n  for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n    iter.next();\n    if (iter.lineBreak || iter.done) {\n      let trailing = prev.search(/\\s+$/);\n      if (trailing > -1) changes.push({\n        from: pos - (prev.length - trailing),\n        to: pos\n      });\n      if (iter.done) break;\n      prev = \"\";\n    } else {\n      prev = iter.value;\n    }\n    pos += iter.value.length;\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    return {\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\"\", \"\"])\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n    };\n  });\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let changes = state.changeByRange(range => {\n    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n      range\n    };\n    let pos = range.from,\n      line = state.doc.lineAt(pos);\n    let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n    let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n    return {\n      changes: {\n        from,\n        to,\n        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n      },\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n    };\n  });\n  if (changes.changes.empty) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"move.character\"\n  }));\n  return true;\n};\nfunction selectedLineBlocks(state) {\n  let blocks = [],\n    upto = -1;\n  for (let range of state.selection.ranges) {\n    let startLine = state.doc.lineAt(range.from),\n      endLine = state.doc.lineAt(range.to);\n    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n    if (upto >= startLine.number) {\n      let prev = blocks[blocks.length - 1];\n      prev.to = endLine.to;\n      prev.ranges.push(range);\n    } else {\n      blocks.push({\n        from: startLine.from,\n        to: endLine.to,\n        ranges: [range]\n      });\n    }\n    upto = endLine.number + 1;\n  }\n  return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [],\n    ranges = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward ? block.to == state.doc.length : block.from == 0) continue;\n    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n    let size = nextLine.length + 1;\n    if (forward) {\n      changes.push({\n        from: block.to,\n        to: nextLine.to\n      }, {\n        from: block.from,\n        insert: nextLine.text + state.lineBreak\n      });\n      for (let r of block.ranges) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n    } else {\n      changes.push({\n        from: nextLine.from,\n        to: block.from\n      }, {\n        from: block.to,\n        insert: state.lineBreak + nextLine.text\n      });\n      for (let r of block.ranges) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n    }\n  }\n  if (!changes.length) return false;\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n    userEvent: \"move.line\"\n  }));\n  return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({\n  state,\n  dispatch\n}) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n  if (state.readOnly) return false;\n  let changes = [];\n  for (let block of selectedLineBlocks(state)) {\n    if (forward) changes.push({\n      from: block.from,\n      insert: state.doc.slice(block.from, block.to) + state.lineBreak\n    });else changes.push({\n      from: block.to,\n      insert: state.lineBreak + state.doc.slice(block.from, block.to)\n    });\n  }\n  dispatch(state.update({\n    changes,\n    scrollIntoView: true,\n    userEvent: \"input.copyline\"\n  }));\n  return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({\n  state,\n  dispatch\n}) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n  if (view.state.readOnly) return false;\n  let {\n      state\n    } = view,\n    changes = state.changes(selectedLineBlocks(state).map(({\n      from,\n      to\n    }) => {\n      if (from > 0) from--;else if (to < state.doc.length) to++;\n      return {\n        from,\n        to\n      };\n    }));\n  let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: true,\n    userEvent: \"delete.line\"\n  });\n  return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({\n  state,\n  dispatch\n}) => {\n  dispatch(state.update(state.replaceSelection(state.lineBreak), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\nfunction isBetweenBrackets(state, pos) {\n  if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n    from: pos,\n    to: pos\n  };\n  let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n  let before = context.childBefore(pos),\n    after = context.childAfter(pos),\n    closedBy;\n  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n    from: before.to,\n    to: after.from\n  };\n  return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n  return ({\n    state,\n    dispatch\n  }) => {\n    if (state.readOnly) return false;\n    let changes = state.changeByRange(range => {\n      let {\n          from,\n          to\n        } = range,\n        line = state.doc.lineAt(from);\n      let explode = !atEof && from == to && isBetweenBrackets(state, from);\n      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n      let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        simulateBreak: from,\n        simulateDoubleBreak: !!explode\n      });\n      let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n      if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n      while (to < line.to && /\\s/.test(line.text[to - line.from])) to++;\n      if (explode) ({\n        from,\n        to\n      } = explode);else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n      let insert = [\"\", (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)];\n      if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n      return {\n        changes: {\n          from,\n          to,\n          insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n      };\n    });\n    dispatch(state.update(changes, {\n      scrollIntoView: true,\n      userEvent: \"input\"\n    }));\n    return true;\n  };\n}\nfunction changeBySelectedLine(state, f) {\n  let atLine = -1;\n  return state.changeByRange(range => {\n    let changes = [];\n    for (let pos = range.from; pos <= range.to;) {\n      let line = state.doc.lineAt(pos);\n      if (line.number > atLine && (range.empty || range.to > line.from)) {\n        f(line, changes, range);\n        atLine = line.number;\n      }\n      pos = line.to + 1;\n    }\n    let changeSet = state.changes(changes);\n    return {\n      changes,\n      range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n    };\n  });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  let updated = Object.create(null);\n  let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n    overrideIndentation: start => {\n      let found = updated[start];\n      return found == null ? -1 : found;\n    }\n  });\n  let changes = changeBySelectedLine(state, (line, changes, range) => {\n    let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n    if (indent == null) return;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n    if (cur != norm || range.from < line.from + cur.length) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  });\n  if (!changes.changes.empty) dispatch(state.update(changes, {\n    userEvent: \"indent\"\n  }));\n  return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    changes.push({\n      from: line.from,\n      insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n    });\n  }), {\n    userEvent: \"input.indent\"\n  }));\n  return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({\n  state,\n  dispatch\n}) => {\n  if (state.readOnly) return false;\n  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n    let space = /^\\s*/.exec(line.text)[0];\n    if (!space) return;\n    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize),\n      keep = 0;\n    let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;\n    changes.push({\n      from: line.from + keep,\n      to: line.from + space.length,\n      insert: insert.slice(keep)\n    });\n  }), {\n    userEvent: \"delete.dedent\"\n  }));\n  return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({\n  state,\n  dispatch\n}) => {\n  if (state.selection.ranges.some(r => !r.empty)) return indentMore({\n    state,\n    dispatch\n  });\n  dispatch(state.update(state.replaceSelection(\"\\t\"), {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [{\n  key: \"Ctrl-b\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Ctrl-f\",\n  run: cursorCharRight,\n  shift: selectCharRight\n}, {\n  key: \"Ctrl-p\",\n  run: cursorLineUp,\n  shift: selectLineUp\n}, {\n  key: \"Ctrl-n\",\n  run: cursorLineDown,\n  shift: selectLineDown\n}, {\n  key: \"Ctrl-a\",\n  run: cursorLineStart,\n  shift: selectLineStart\n}, {\n  key: \"Ctrl-e\",\n  run: cursorLineEnd,\n  shift: selectLineEnd\n}, {\n  key: \"Ctrl-d\",\n  run: deleteCharForward\n}, {\n  key: \"Ctrl-h\",\n  run: deleteCharBackward\n}, {\n  key: \"Ctrl-k\",\n  run: deleteToLineEnd\n}, {\n  key: \"Ctrl-Alt-h\",\n  run: deleteGroupBackward\n}, {\n  key: \"Ctrl-o\",\n  run: splitLine\n}, {\n  key: \"Ctrl-t\",\n  run: transposeChars\n}, {\n  key: \"Ctrl-v\",\n  run: cursorPageDown\n}];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/\nconst standardKeymap = /*@__PURE__*/[{\n  key: \"ArrowLeft\",\n  run: cursorCharLeft,\n  shift: selectCharLeft,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowLeft\",\n  mac: \"Alt-ArrowLeft\",\n  run: cursorGroupLeft,\n  shift: selectGroupLeft,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowLeft\",\n  run: cursorLineBoundaryLeft,\n  shift: selectLineBoundaryLeft,\n  preventDefault: true\n}, {\n  key: \"ArrowRight\",\n  run: cursorCharRight,\n  shift: selectCharRight,\n  preventDefault: true\n}, {\n  key: \"Mod-ArrowRight\",\n  mac: \"Alt-ArrowRight\",\n  run: cursorGroupRight,\n  shift: selectGroupRight,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowRight\",\n  run: cursorLineBoundaryRight,\n  shift: selectLineBoundaryRight,\n  preventDefault: true\n}, {\n  key: \"ArrowUp\",\n  run: cursorLineUp,\n  shift: selectLineUp,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowUp\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  mac: \"Ctrl-ArrowUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"ArrowDown\",\n  run: cursorLineDown,\n  shift: selectLineDown,\n  preventDefault: true\n}, {\n  mac: \"Cmd-ArrowDown\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  mac: \"Ctrl-ArrowDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"PageUp\",\n  run: cursorPageUp,\n  shift: selectPageUp\n}, {\n  key: \"PageDown\",\n  run: cursorPageDown,\n  shift: selectPageDown\n}, {\n  key: \"Home\",\n  run: cursorLineBoundaryBackward,\n  shift: selectLineBoundaryBackward,\n  preventDefault: true\n}, {\n  key: \"Mod-Home\",\n  run: cursorDocStart,\n  shift: selectDocStart\n}, {\n  key: \"End\",\n  run: cursorLineBoundaryForward,\n  shift: selectLineBoundaryForward,\n  preventDefault: true\n}, {\n  key: \"Mod-End\",\n  run: cursorDocEnd,\n  shift: selectDocEnd\n}, {\n  key: \"Enter\",\n  run: insertNewlineAndIndent\n}, {\n  key: \"Mod-a\",\n  run: selectAll\n}, {\n  key: \"Backspace\",\n  run: deleteCharBackward,\n  shift: deleteCharBackward\n}, {\n  key: \"Delete\",\n  run: deleteCharForward\n}, {\n  key: \"Mod-Backspace\",\n  mac: \"Alt-Backspace\",\n  run: deleteGroupBackward\n}, {\n  key: \"Mod-Delete\",\n  mac: \"Alt-Delete\",\n  run: deleteGroupForward\n}, {\n  mac: \"Mod-Backspace\",\n  run: deleteLineBoundaryBackward\n}, {\n  mac: \"Mod-Delete\",\n  run: deleteLineBoundaryForward\n}].concat( /*@__PURE__*/emacsStyleKeymap.map(b => ({\n  mac: b.key,\n  run: b.run,\n  shift: b.shift\n})));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/\nconst defaultKeymap = /*@__PURE__*/[{\n  key: \"Alt-ArrowLeft\",\n  mac: \"Ctrl-ArrowLeft\",\n  run: cursorSyntaxLeft,\n  shift: selectSyntaxLeft\n}, {\n  key: \"Alt-ArrowRight\",\n  mac: \"Ctrl-ArrowRight\",\n  run: cursorSyntaxRight,\n  shift: selectSyntaxRight\n}, {\n  key: \"Alt-ArrowUp\",\n  run: moveLineUp\n}, {\n  key: \"Shift-Alt-ArrowUp\",\n  run: copyLineUp\n}, {\n  key: \"Alt-ArrowDown\",\n  run: moveLineDown\n}, {\n  key: \"Shift-Alt-ArrowDown\",\n  run: copyLineDown\n}, {\n  key: \"Escape\",\n  run: simplifySelection\n}, {\n  key: \"Mod-Enter\",\n  run: insertBlankLine\n}, {\n  key: \"Alt-l\",\n  mac: \"Ctrl-l\",\n  run: selectLine\n}, {\n  key: \"Mod-i\",\n  run: selectParentSyntax,\n  preventDefault: true\n}, {\n  key: \"Mod-[\",\n  run: indentLess\n}, {\n  key: \"Mod-]\",\n  run: indentMore\n}, {\n  key: \"Mod-Alt-\\\\\",\n  run: indentSelection\n}, {\n  key: \"Shift-Mod-k\",\n  run: deleteLine\n}, {\n  key: \"Shift-Mod-\\\\\",\n  run: cursorMatchingBracket\n}, {\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = {\n  key: \"Tab\",\n  run: indentMore,\n  shift: indentLess\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9jb21tYW5kcy9kaXN0L2luZGV4LmpzP2JmMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5ub3RhdGlvbiwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFRyYW5zYWN0aW9uLCBDaGFuZ2VTZXQsIENoYW5nZURlc2MsIEVkaXRvclNlbGVjdGlvbiwgU3RhdGVFZmZlY3QsIFRleHQsIGZpbmRDbHVzdGVyQnJlYWssIGNvdW50Q29sdW1uLCBDaGFyQ2F0ZWdvcnkgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3LCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEluZGVudENvbnRleHQsIGdldEluZGVudGF0aW9uLCBpbmRlbnRTdHJpbmcsIG1hdGNoQnJhY2tldHMsIHN5bnRheFRyZWUsIGdldEluZGVudFVuaXQsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCB1c2UgbGluZSBjb21tZW50c1xuaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGluZyBiYWNrIHRvIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUNvbW1lbnQgPSB0YXJnZXQgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pLCBjb25maWcgPSBnZXRDb25maWcodGFyZ2V0LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgIHJldHVybiBjb25maWcubGluZSA/IHRvZ2dsZUxpbmVDb21tZW50KHRhcmdldCkgOiBjb25maWcuYmxvY2sgPyB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUodGFyZ2V0KSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGNvbW1hbmQoZiwgb3B0aW9uKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gZihvcHRpb24sIHN0YXRlKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHRyKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuVGhlIGxpbmUgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVMaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAwIC8qIENvbW1lbnRPcHRpb24uVG9nZ2xlICovKTtcbi8qKlxuQ29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUxpbmVDb21tZW50LCAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyk7XG4vKipcblVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgbGluZSBjb21tZW50cy5cbiovXG5jb25zdCBsaW5lVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8pO1xuLyoqXG5Db21tZW50IG9yIHVuY29tbWVudCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmcgYmxvY2sgY29tbWVudHMuXG5UaGUgYmxvY2sgY29tbWVudCBzeW50YXggaXMgdGFrZW4gZnJvbSB0aGVcbltgY29tbWVudFRva2Vuc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja0NvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VCbG9ja0NvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cbiovXG5jb25zdCBibG9ja1VuY29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBsaW5lcyBhcm91bmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nXG5ibG9jayBjb21tZW50cy5cbiovXG5jb25zdCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUgPSAvKkBfX1BVUkVfXyovY29tbWFuZCgobywgcykgPT4gY2hhbmdlQmxvY2tDb21tZW50KG8sIHMsIHNlbGVjdGVkTGluZVJhbmdlcyhzKSksIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuZnVuY3Rpb24gZ2V0Q29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZGF0YSA9IHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY29tbWVudFRva2Vuc1wiLCBwb3MpO1xuICAgIHJldHVybiBkYXRhLmxlbmd0aCA/IGRhdGFbMF0gOiB7fTtcbn1cbmNvbnN0IFNlYXJjaE1hcmdpbiA9IDUwO1xuLyoqXG5EZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByYW5nZSBpcyBibG9jay1jb21tZW50ZWQgaW4gdGhlIGdpdmVuXG5zdGF0ZS5cbiovXG5mdW5jdGlvbiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB7IG9wZW4sIGNsb3NlIH0sIGZyb20sIHRvKSB7XG4gICAgbGV0IHRleHRCZWZvcmUgPSBzdGF0ZS5zbGljZURvYyhmcm9tIC0gU2VhcmNoTWFyZ2luLCBmcm9tKTtcbiAgICBsZXQgdGV4dEFmdGVyID0gc3RhdGUuc2xpY2VEb2ModG8sIHRvICsgU2VhcmNoTWFyZ2luKTtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSAvXFxzKiQvLmV4ZWModGV4dEJlZm9yZSlbMF0ubGVuZ3RoLCBzcGFjZUFmdGVyID0gL15cXHMqLy5leGVjKHRleHRBZnRlcilbMF0ubGVuZ3RoO1xuICAgIGxldCBiZWZvcmVPZmYgPSB0ZXh0QmVmb3JlLmxlbmd0aCAtIHNwYWNlQmVmb3JlO1xuICAgIGlmICh0ZXh0QmVmb3JlLnNsaWNlKGJlZm9yZU9mZiAtIG9wZW4ubGVuZ3RoLCBiZWZvcmVPZmYpID09IG9wZW4gJiZcbiAgICAgICAgdGV4dEFmdGVyLnNsaWNlKHNwYWNlQWZ0ZXIsIHNwYWNlQWZ0ZXIgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tIC0gc3BhY2VCZWZvcmUsIG1hcmdpbjogc3BhY2VCZWZvcmUgJiYgMSB9LFxuICAgICAgICAgICAgY2xvc2U6IHsgcG9zOiB0byArIHNwYWNlQWZ0ZXIsIG1hcmdpbjogc3BhY2VBZnRlciAmJiAxIH0gfTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0VGV4dCwgZW5kVGV4dDtcbiAgICBpZiAodG8gLSBmcm9tIDw9IDIgKiBTZWFyY2hNYXJnaW4pIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gZW5kVGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0VGV4dCA9IHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyBTZWFyY2hNYXJnaW4pO1xuICAgICAgICBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2ModG8gLSBTZWFyY2hNYXJnaW4sIHRvKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0U3BhY2UgPSAvXlxccyovLmV4ZWMoc3RhcnRUZXh0KVswXS5sZW5ndGgsIGVuZFNwYWNlID0gL1xccyokLy5leGVjKGVuZFRleHQpWzBdLmxlbmd0aDtcbiAgICBsZXQgZW5kT2ZmID0gZW5kVGV4dC5sZW5ndGggLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aDtcbiAgICBpZiAoc3RhcnRUZXh0LnNsaWNlKHN0YXJ0U3BhY2UsIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkgPT0gb3BlbiAmJlxuICAgICAgICBlbmRUZXh0LnNsaWNlKGVuZE9mZiwgZW5kT2ZmICsgY2xvc2UubGVuZ3RoKSA9PSBjbG9zZSkge1xuICAgICAgICByZXR1cm4geyBvcGVuOiB7IHBvczogZnJvbSArIHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3Qoc3RhcnRUZXh0LmNoYXJBdChzdGFydFNwYWNlICsgb3Blbi5sZW5ndGgpKSA/IDEgOiAwIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvIC0gZW5kU3BhY2UgLSBjbG9zZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAvXFxzLy50ZXN0KGVuZFRleHQuY2hhckF0KGVuZE9mZiAtIDEpKSA/IDEgOiAwIH0gfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVSYW5nZXMoc3RhdGUpIHtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tTGluZSA9IHN0YXRlLmRvYy5saW5lQXQoci5mcm9tKTtcbiAgICAgICAgbGV0IHRvTGluZSA9IHIudG8gPD0gZnJvbUxpbmUudG8gPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byk7XG4gICAgICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdLnRvID4gZnJvbUxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJhbmdlc1tsYXN0XS50byA9IHRvTGluZS50bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBmcm9tTGluZS5mcm9tICsgL15cXHMqLy5leGVjKGZyb21MaW5lLnRleHQpWzBdLmxlbmd0aCwgdG86IHRvTGluZS50byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGJsb2NrIGNvbW1lbnRzIGluXG4vLyBsYW5ndWFnZXMgdGhhdCBzdXBwb3J0IHRoZW0uXG5mdW5jdGlvbiBjaGFuZ2VCbG9ja0NvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCB0b2tlbnMgPSByYW5nZXMubWFwKHIgPT4gZ2V0Q29uZmlnKHN0YXRlLCByLmZyb20pLmJsb2NrKTtcbiAgICBpZiAoIXRva2Vucy5ldmVyeShjID0+IGMpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29tbWVudHMgPSByYW5nZXMubWFwKChyLCBpKSA9PiBmaW5kQmxvY2tDb21tZW50KHN0YXRlLCB0b2tlbnNbaV0sIHIuZnJvbSwgci50bykpO1xuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiAhY29tbWVudHMuZXZlcnkoYyA9PiBjKSkge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBzdGF0ZS5jaGFuZ2VzKHJhbmdlcy5tYXAoKHJhbmdlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IHJhbmdlLmZyb20sIGluc2VydDogdG9rZW5zW2ldLm9wZW4gKyBcIiBcIiB9LCB7IGZyb206IHJhbmdlLnRvLCBpbnNlcnQ6IFwiIFwiICsgdG9rZW5zW2ldLmNsb3NlIH1dO1xuICAgICAgICAgICAgfSkpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBjb21tZW50cy5zb21lKGMgPT4gYykpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbW1lbnQ7IGkgPCBjb21tZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID0gY29tbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV0sIHsgb3BlbiwgY2xvc2UgfSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogb3Blbi5wb3MgLSB0b2tlbi5vcGVuLmxlbmd0aCwgdG86IG9wZW4ucG9zICsgb3Blbi5tYXJnaW4gfSwgeyBmcm9tOiBjbG9zZS5wb3MgLSBjbG9zZS5tYXJnaW4sIHRvOiBjbG9zZS5wb3MgKyB0b2tlbi5jbG9zZS5sZW5ndGggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBsaW5lIGNvbW1lbnRzLlxuZnVuY3Rpb24gY2hhbmdlTGluZUNvbW1lbnQob3B0aW9uLCBzdGF0ZSwgcmFuZ2VzID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2TGluZSA9IC0xO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IGxpbmVzLmxlbmd0aCwgbWluSW5kZW50ID0gMWU5O1xuICAgICAgICBsZXQgdG9rZW4gPSBnZXRDb25maWcoc3RhdGUsIGZyb20pLmxpbmU7XG4gICAgICAgIGlmICghdG9rZW4pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gcHJldkxpbmUgJiYgKGZyb20gPT0gdG8gfHwgdG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgcHJldkxpbmUgPSBsaW5lLmZyb207XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgZW1wdHkgPSBpbmRlbnQgPT0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1lbnQgPSBsaW5lLnRleHQuc2xpY2UoaW5kZW50LCBpbmRlbnQgKyB0b2tlbi5sZW5ndGgpID09IHRva2VuID8gaW5kZW50IDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKGluZGVudCA8IGxpbmUudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgbWluSW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBtaW5JbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IGxpbmUsIGNvbW1lbnQsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbkluZGVudCA8IDFlOSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0uaW5kZW50IDwgbGluZXNbaV0ubGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0uaW5kZW50ID0gbWluSW5kZW50O1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IHN0YXJ0SSArIDEpXG4gICAgICAgICAgICBsaW5lc1tzdGFydEldLnNpbmdsZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb24gIT0gMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50IDwgMCAmJiAoIWwuZW1wdHkgfHwgbC5zaW5nbGUpKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIHRva2VuLCBpbmRlbnQsIGVtcHR5LCBzaW5nbGUgfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgIWVtcHR5KVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGluZGVudCwgaW5zZXJ0OiB0b2tlbiArIFwiIFwiIH0pO1xuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogY2hhbmdlU2V0LCBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5tYXAoY2hhbmdlU2V0LCAxKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA+PSAwKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGxpbmUsIGNvbW1lbnQsIHRva2VuIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoY29tbWVudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBsaW5lLmZyb20gKyBjb21tZW50LCB0byA9IGZyb20gKyB0b2tlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0gPT0gXCIgXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGZyb21IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGFubm90YXRpb24gdGhhdCB3aWxsIHByZXZlbnQgdGhhdCB0cmFuc2FjdGlvbiBmcm9tXG5iZWluZyBjb21iaW5lZCB3aXRoIG90aGVyIHRyYW5zYWN0aW9ucyBpbiB0aGUgdW5kbyBoaXN0b3J5LiBHaXZlblxuYFwiYmVmb3JlXCJgLCBpdCdsbCBwcmV2ZW50IG1lcmdpbmcgd2l0aCBwcmV2aW91cyB0cmFuc2FjdGlvbnMuIFdpdGhcbmBcImFmdGVyXCJgLCBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucyB3b24ndCBiZSBjb21iaW5lZCB3aXRoIHRoaXNcbm9uZS4gV2l0aCBgXCJmdWxsXCJgLCB0aGUgdHJhbnNhY3Rpb24gaXMgaXNvbGF0ZWQgb24gYm90aCBzaWRlcy5cbiovXG5jb25zdCBpc29sYXRlSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UaGlzIGZhY2V0IHByb3ZpZGVzIGEgd2F5IHRvIHJlZ2lzdGVyIGZ1bmN0aW9ucyB0aGF0LCBnaXZlbiBhXG50cmFuc2FjdGlvbiwgcHJvdmlkZSBhIHNldCBvZiBlZmZlY3RzIHRoYXQgdGhlIGhpc3Rvcnkgc2hvdWxkXG5zdG9yZSB3aGVuIGludmVydGluZyB0aGUgdHJhbnNhY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQgdG9cbmludGVncmF0ZSBzb21lIGtpbmRzIG9mIGVmZmVjdHMgaW4gdGhlIGhpc3RvcnksIHNvIHRoYXQgdGhleSBjYW5cbmJlIHVuZG9uZSAoYW5kIHJlZG9uZSBhZ2FpbikuXG4qL1xuY29uc3QgaW52ZXJ0ZWRFZmZlY3RzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaGlzdG9yeUNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogMTAwLFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogNTAwLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChfdCwgaXNBZGphY2VudCkgPT4gaXNBZGphY2VudCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWluRGVwdGg6IE1hdGgubWF4LFxuICAgICAgICAgICAgbmV3R3JvdXBEZWxheTogTWF0aC5taW4sXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKGEsIGIpID0+ICh0ciwgYWRqKSA9PiBhKHRyLCBhZGopIHx8IGIodHIsIGFkailcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBoaXN0b3J5RmllbGRfID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBIaXN0b3J5U3RhdGUuZW1wdHk7XG4gICAgfSxcbiAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChoaXN0b3J5Q29uZmlnKTtcbiAgICAgICAgbGV0IGZyb21IaXN0ID0gdHIuYW5ub3RhdGlvbihmcm9tSGlzdG9yeSk7XG4gICAgICAgIGlmIChmcm9tSGlzdCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyLCBmcm9tSGlzdC5zZWxlY3Rpb24pLCBmcm9tID0gZnJvbUhpc3Quc2lkZTtcbiAgICAgICAgICAgIGxldCBvdGhlciA9IGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBzdGF0ZS51bmRvbmUgOiBzdGF0ZS5kb25lO1xuICAgICAgICAgICAgaWYgKGl0ZW0pXG4gICAgICAgICAgICAgICAgb3RoZXIgPSB1cGRhdGVCcmFuY2gob3RoZXIsIG90aGVyLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvdGhlciA9IGFkZFNlbGVjdGlvbihvdGhlciwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IG90aGVyIDogZnJvbUhpc3QucmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzb2xhdGUgPSB0ci5hbm5vdGF0aW9uKGlzb2xhdGVIaXN0b3J5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImJlZm9yZVwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIGlmICh0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLmFkZFRvSGlzdG9yeSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuICF0ci5jaGFuZ2VzLmVtcHR5ID8gc3RhdGUuYWRkTWFwcGluZyh0ci5jaGFuZ2VzLmRlc2MpIDogc3RhdGU7XG4gICAgICAgIGxldCBldmVudCA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIpO1xuICAgICAgICBsZXQgdGltZSA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udGltZSksIHVzZXJFdmVudCA9IHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50KVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpO1xuICAgICAgICBlbHNlIGlmICh0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZFNlbGVjdGlvbih0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJhZnRlclwiKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5pc29sYXRlKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIHRvSlNPTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBkb25lOiB2YWx1ZS5kb25lLm1hcChlID0+IGUudG9KU09OKCkpLCB1bmRvbmU6IHZhbHVlLnVuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSB9O1xuICAgIH0sXG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShqc29uLmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTiksIGpzb24udW5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pKTtcbiAgICB9XG59KTtcbi8qKlxuQ3JlYXRlIGEgaGlzdG9yeSBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gY29uZmlndXJhdGlvbi5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgaGlzdG9yeUZpZWxkXyxcbiAgICAgICAgaGlzdG9yeUNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBFZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICAgICAgYmVmb3JlaW5wdXQoZSwgdmlldykge1xuICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBdO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdXNlZCB0byBzdG9yZSB0aGUgaGlzdG9yeSBkYXRhLiBTaG91bGQgcHJvYmFibHlcbm9ubHkgYmUgdXNlZCB3aGVuIHlvdSB3YW50IHRvXG5bc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgb3JcbltkZXNlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgc3RhdGUgb2JqZWN0cyBpbiBhIHdheVxudGhhdCBwcmVzZXJ2ZXMgaGlzdG9yeS5cbiovXG5jb25zdCBoaXN0b3J5RmllbGQgPSBoaXN0b3J5RmllbGRfO1xuZnVuY3Rpb24gY21kKHNpZGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkge1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiAmJiBzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGhpc3RvcnlTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0b3J5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGhpc3RvcnlTdGF0ZS5wb3Aoc2lkZSwgc3RhdGUsIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghdHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuVW5kbyBhIHNpbmdsZSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cFxud2FzIGF2YWlsYWJsZS5cbiovXG5jb25zdCB1bmRvID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgZmFsc2UpO1xuLyoqXG5SZWRvIGEgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXAgd2FzXG5hdmFpbGFibGUuXG4qL1xuY29uc3QgcmVkbyA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgdW5kb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgY2hhbmdlIG9yIHNlbGVjdGlvbiBjaGFuZ2UuXG4qL1xuY29uc3QgcmVkb1NlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9jbWQoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IGhpc3RTdGF0ZS5kb25lIDogaGlzdFN0YXRlLnVuZG9uZTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5sZW5ndGggLSAoYnJhbmNoLmxlbmd0aCAmJiAhYnJhbmNoWzBdLmNoYW5nZXMgPyAxIDogMCk7XG4gICAgfTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHVuZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyk7XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCByZWRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMSAvKiBCcmFuY2hOYW1lLlVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIFxuICAgIC8vIEFjY3VtdWxhdGVkIG1hcHBpbmcgKGZyb20gYWRkVG9IaXN0b3J5PT1mYWxzZSkgdGhhdCBzaG91bGQgYmVcbiAgICAvLyBhcHBsaWVkIHRvIGV2ZW50cyBiZWxvdyB0aGlzIG9uZS5cbiAgICBtYXBwZWQsIFxuICAgIC8vIFRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoaXMgZXZlbnRcbiAgICBzdGFydFNlbGVjdGlvbiwgXG4gICAgLy8gU3RvcmVzIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHRoaXMgZXZlbnQsIHRvIGJlIHVzZWQgZm9yXG4gICAgLy8gc2VsZWN0aW9uIHVuZG8vcmVkby5cbiAgICBzZWxlY3Rpb25zQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgdGhpcy5tYXBwZWQgPSBtYXBwZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBzdGFydFNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zQWZ0ZXIgPSBzZWxlY3Rpb25zQWZ0ZXI7XG4gICAgfVxuICAgIHNldFNlbEFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRoaXMuY2hhbmdlcywgdGhpcy5lZmZlY3RzLCB0aGlzLm1hcHBlZCwgdGhpcy5zdGFydFNlbGVjdGlvbiwgYWZ0ZXIpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogKF9hID0gdGhpcy5jaGFuZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKCksXG4gICAgICAgICAgICBtYXBwZWQ6IChfYiA9IHRoaXMubWFwcGVkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9KU09OKCksXG4gICAgICAgICAgICBzdGFydFNlbGVjdGlvbjogKF9jID0gdGhpcy5zdGFydFNlbGVjdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvSlNPTigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uc0FmdGVyOiB0aGlzLnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudChqc29uLmNoYW5nZXMgJiYgQ2hhbmdlU2V0LmZyb21KU09OKGpzb24uY2hhbmdlcyksIFtdLCBqc29uLm1hcHBlZCAmJiBDaGFuZ2VEZXNjLmZyb21KU09OKGpzb24ubWFwcGVkKSwganNvbi5zdGFydFNlbGVjdGlvbiAmJiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zdGFydFNlbGVjdGlvbiksIGpzb24uc2VsZWN0aW9uc0FmdGVyLm1hcChFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04pKTtcbiAgICB9XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjaGVjayBgYWRkVG9IaXN0b3J5YCBhbmQgc3VjaCwgaXQgYXNzdW1lcyB0aGVcbiAgICAvLyB0cmFuc2FjdGlvbiBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYW4gaXRlbS4gUmV0dXJucyBudWxsIHdoZW5cbiAgICAvLyB0aGVyZSBhcmUgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICBzdGF0aWMgZnJvbVRyYW5zYWN0aW9uKHRyLCBzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBub25lO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnQgb2YgdHIuc3RhcnRTdGF0ZS5mYWNldChpbnZlcnRlZEVmZmVjdHMpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaW52ZXJ0KHRyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMgPSBlZmZlY3RzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGggJiYgdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0ci5jaGFuZ2VzLmludmVydCh0ci5zdGFydFN0YXRlLmRvYyksIGVmZmVjdHMsIHVuZGVmaW5lZCwgc2VsZWN0aW9uIHx8IHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCBub25lKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGVjdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHVuZGVmaW5lZCwgbm9uZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHNlbGVjdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUJyYW5jaChicmFuY2gsIHRvLCBtYXhMZW4sIG5ld0V2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gdG8gKyAxID4gbWF4TGVuICsgMjAgPyB0byAtIG1heExlbiAtIDEgOiAwO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2Uoc3RhcnQsIHRvKTtcbiAgICBuZXdCcmFuY2gucHVzaChuZXdFdmVudCk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnQoYSwgYikge1xuICAgIGxldCByYW5nZXMgPSBbXSwgaXNBZGphY2VudCA9IGZhbHNlO1xuICAgIGEuaXRlckNoYW5nZWRSYW5nZXMoKGYsIHQpID0+IHJhbmdlcy5wdXNoKGYsIHQpKTtcbiAgICBiLml0ZXJDaGFuZ2VkUmFuZ2VzKChfZiwgX3QsIGYsIHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaSsrXSwgdG8gPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIGlmICh0ID49IGZyb20gJiYgZiA8PSB0bylcbiAgICAgICAgICAgICAgICBpc0FkamFjZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpc0FkamFjZW50O1xufVxuZnVuY3Rpb24gZXFTZWxlY3Rpb25TaGFwZShhLCBiKSB7XG4gICAgcmV0dXJuIGEucmFuZ2VzLmxlbmd0aCA9PSBiLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgYS5yYW5nZXMuZmlsdGVyKChyLCBpKSA9PiByLmVtcHR5ICE9IGIucmFuZ2VzW2ldLmVtcHR5KS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiBjb25jKGEsIGIpIHtcbiAgICByZXR1cm4gIWEubGVuZ3RoID8gYiA6ICFiLmxlbmd0aCA/IGEgOiBhLmNvbmNhdChiKTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IE1heFNlbGVjdGlvbnNQZXJFdmVudCA9IDIwMDtcbmZ1bmN0aW9uIGFkZFNlbGVjdGlvbihicmFuY2gsIHNlbGVjdGlvbikge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW0hpc3RFdmVudC5zZWxlY3Rpb24oW3NlbGVjdGlvbl0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0RXZlbnQgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgc2VscyA9IGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoTWF0aC5tYXgoMCwgbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSBNYXhTZWxlY3Rpb25zUGVyRXZlbnQpKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoICYmIHNlbHNbc2Vscy5sZW5ndGggLSAxXS5lcShzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICAgICAgc2Vscy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB1cGRhdGVCcmFuY2goYnJhbmNoLCBicmFuY2gubGVuZ3RoIC0gMSwgMWU5LCBsYXN0RXZlbnQuc2V0U2VsQWZ0ZXIoc2VscykpO1xuICAgIH1cbn1cbi8vIEFzc3VtZXMgdGhlIHRvcCBpdGVtIGhhcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb25BZnRlciB2YWx1ZXNcbmZ1bmN0aW9uIHBvcFNlbGVjdGlvbihicmFuY2gpIHtcbiAgICBsZXQgbGFzdCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZSgpO1xuICAgIG5ld0JyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0gPSBsYXN0LnNldFNlbEFmdGVyKGxhc3Quc2VsZWN0aW9uc0FmdGVyLnNsaWNlKDAsIGxhc3Quc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuLy8gQWRkIGEgbWFwcGluZyB0byB0aGUgdG9wIGV2ZW50IGluIHRoZSBnaXZlbiBicmFuY2guIElmIHRoaXMgbWFwc1xuLy8gYXdheSBhbGwgdGhlIGNoYW5nZXMgYW5kIGVmZmVjdHMgaW4gdGhhdCBpdGVtLCBkcm9wIGl0IGFuZFxuLy8gcHJvcGFnYXRlIHRoZSBtYXBwaW5nIHRvIHRoZSBuZXh0IGl0ZW0uXG5mdW5jdGlvbiBhZGRNYXBwaW5nVG9CcmFuY2goYnJhbmNoLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKVxuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIGxldCBsZW5ndGggPSBicmFuY2gubGVuZ3RoLCBzZWxlY3Rpb25zID0gbm9uZTtcbiAgICB3aGlsZSAobGVuZ3RoKSB7XG4gICAgICAgIGxldCBldmVudCA9IG1hcEV2ZW50KGJyYW5jaFtsZW5ndGggLSAxXSwgbWFwcGluZywgc2VsZWN0aW9ucyk7XG4gICAgICAgIGlmIChldmVudC5jaGFuZ2VzICYmICFldmVudC5jaGFuZ2VzLmVtcHR5IHx8IGV2ZW50LmVmZmVjdHMubGVuZ3RoKSB7IC8vIEV2ZW50IHN1cnZpdmVkIG1hcHBpbmdcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBicmFuY2guc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGggLSAxXSA9IGV2ZW50O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gRHJvcCB0aGlzIGV2ZW50LCBzaW5jZSB0aGVyZSdzIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBsZWZ0XG4gICAgICAgICAgICBtYXBwaW5nID0gZXZlbnQubWFwcGVkO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IFtIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpXSA6IG5vbmU7XG59XG5mdW5jdGlvbiBtYXBFdmVudChldmVudCwgbWFwcGluZywgZXh0cmFTZWxlY3Rpb25zKSB7XG4gICAgbGV0IHNlbGVjdGlvbnMgPSBjb25jKGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggPyBldmVudC5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy5tYXAobWFwcGluZykpIDogbm9uZSwgZXh0cmFTZWxlY3Rpb25zKTtcbiAgICAvLyBDaGFuZ2UtbGVzcyBldmVudHMgZG9uJ3Qgc3RvcmUgbWFwcGluZ3MgKHRoZXkgYXJlIGFsd2F5cyB0aGUgbGFzdCBldmVudCBpbiBhIGJyYW5jaClcbiAgICBpZiAoIWV2ZW50LmNoYW5nZXMpXG4gICAgICAgIHJldHVybiBIaXN0RXZlbnQuc2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIGxldCBtYXBwZWRDaGFuZ2VzID0gZXZlbnQuY2hhbmdlcy5tYXAobWFwcGluZyksIGJlZm9yZSA9IG1hcHBpbmcubWFwRGVzYyhldmVudC5jaGFuZ2VzLCB0cnVlKTtcbiAgICBsZXQgZnVsbE1hcHBpbmcgPSBldmVudC5tYXBwZWQgPyBldmVudC5tYXBwZWQuY29tcG9zZURlc2MoYmVmb3JlKSA6IGJlZm9yZTtcbiAgICByZXR1cm4gbmV3IEhpc3RFdmVudChtYXBwZWRDaGFuZ2VzLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGV2ZW50LmVmZmVjdHMsIG1hcHBpbmcpLCBmdWxsTWFwcGluZywgZXZlbnQuc3RhcnRTZWxlY3Rpb24ubWFwKGJlZm9yZSksIHNlbGVjdGlvbnMpO1xufVxuY29uc3Qgam9pbmFibGVVc2VyRXZlbnQgPSAvXihpbnB1dFxcLnR5cGV8ZGVsZXRlKSgkfFxcLikvO1xuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZUaW1lID0gMCwgcHJldlVzZXJFdmVudCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZVc2VyRXZlbnQgPSBwcmV2VXNlckV2ZW50O1xuICAgIH1cbiAgICBpc29sYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2VGltZSA/IG5ldyBIaXN0b3J5U3RhdGUodGhpcy5kb25lLCB0aGlzLnVuZG9uZSkgOiB0aGlzO1xuICAgIH1cbiAgICBhZGRDaGFuZ2VzKGV2ZW50LCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZywgdHIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmRvbmUsIGxhc3RFdmVudCA9IGRvbmVbZG9uZS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBsYXN0RXZlbnQuY2hhbmdlcyAmJiAhbGFzdEV2ZW50LmNoYW5nZXMuZW1wdHkgJiYgZXZlbnQuY2hhbmdlcyAmJlxuICAgICAgICAgICAgKCF1c2VyRXZlbnQgfHwgam9pbmFibGVVc2VyRXZlbnQudGVzdCh1c2VyRXZlbnQpKSAmJlxuICAgICAgICAgICAgKCghbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICB0aW1lIC0gdGhpcy5wcmV2VGltZSA8IGNvbmZpZy5uZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLmpvaW5Ub0V2ZW50KHRyLCBpc0FkamFjZW50KGxhc3RFdmVudC5jaGFuZ2VzLCBldmVudC5jaGFuZ2VzKSkpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgY29uZmlnLm1pbkRlcHRoLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgb25seVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlclswXSB8fCBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChvbmx5U2VsZWN0aW9uICYmIGV2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc2VsZWN0aW9uc0FmdGVyW2V2ZW50LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0OiBwb3BTZWxlY3Rpb24oYnJhbmNoKSwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IFwic2VsZWN0LnVuZG9cIiA6IFwic2VsZWN0LnJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV2ZW50LmNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3QgPSBicmFuY2gubGVuZ3RoID09IDEgPyBub25lIDogYnJhbmNoLnNsaWNlKDAsIGJyYW5jaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmIChldmVudC5tYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdCA9IGFkZE1hcHBpbmdUb0JyYW5jaChyZXN0LCBldmVudC5tYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogZXZlbnQuY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGV2ZW50LnN0YXJ0U2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGV2ZW50LmVmZmVjdHMsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGZyb21IaXN0b3J5Lm9mKHsgc2lkZSwgcmVzdCwgc2VsZWN0aW9uIH0pLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kbykuXG4tIE1vZC15IChNb2QtU2hpZnQteiBvbiBtYWNPUykgKyBDdHJsLVNoaWZ0LXogb24gTGludXg6IFtgcmVkb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkbykuXG4tIE1vZC11OiBbYHVuZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnJlZG9TZWxlY3Rpb24pLlxuKi9cbmNvbnN0IGhpc3RvcnlLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLXpcIiwgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC15XCIsIG1hYzogXCJNb2QtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBsaW51eDogXCJDdHJsLVNoaWZ0LXpcIiwgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC11XCIsIHJ1bjogdW5kb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBbHQtdVwiLCBtYWM6IFwiTW9kLVNoaWZ0LXVcIiwgcnVuOiByZWRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dO1xuXG5mdW5jdGlvbiB1cGRhdGVTZWwoc2VsLCBieSkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHNlbC5yYW5nZXMubWFwKGJ5KSwgc2VsLm1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb24sIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSk7XG59XG5mdW5jdGlvbiBtb3ZlU2VsKHsgc3RhdGUsIGRpc3BhdGNoIH0sIGhvdykge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCBob3cpO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uLCB0cnVlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkge1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZvcndhcmQgPyByYW5nZS50byA6IHJhbmdlLmZyb20pO1xufVxuZnVuY3Rpb24gY3Vyc29yQnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuZnVuY3Rpb24gbHRyQXRDdXJzb3Iodmlldykge1xuICAgIHJldHVybiB2aWV3LnRleHREaXJlY3Rpb25BdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpID09IERpcmVjdGlvbi5MVFI7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0ICh3aGljaCBpcyBiYWNrd2FyZCBpblxubGVmdC10by1yaWdodCB0ZXh0LCBmb3J3YXJkIGluIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckxlZnQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhclJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGN1cnNvckJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGxlZnQgYWNyb3NzIG9uZSBncm91cCBvZiB3b3JkIG9yXG5ub24td29yZCAoYnV0IGFsc28gbm9uLXNwYWNlKSBjaGFyYWN0ZXJzLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JHcm91cFJpZ2h0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmNvbnN0IHNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9IFwidW5kZWZpbmVkXCIgJiYgSW50bC5TZWdtZW50ZXIgP1xuICAgIC8qQF9fUFVSRV9fKi9uZXcgKEludGwuU2VnbWVudGVyKSh1bmRlZmluZWQsIHsgZ3JhbnVsYXJpdHk6IFwid29yZFwiIH0pIDogbnVsbDtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb20sIHN0ZXBzID0gMDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgIGlmIChuZXh0Q2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIG5leHQuY2hhckNvZGVBdCgwKSA8IDEyOCAmJiAvW1xcV19dLy50ZXN0KG5leHQpKVxuICAgICAgICAgICAgbmV4dENhdCA9IC0xOyAvLyBUcmVhdCB3b3JkIHB1bmN0dWF0aW9uIHNwZWNpYWxseVxuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwcysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBlbmQgPSB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50ZXIgJiYgY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIGVuZC5mcm9tID09IHJhbmdlLmZyb20gKyBzdGVwcyAqIChmb3J3YXJkID8gMSA6IC0xKSkge1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHJhbmdlLmhlYWQsIGVuZC5oZWFkKSwgdG8gPSBNYXRoLm1heChyYW5nZS5oZWFkLCBlbmQuaGVhZCk7XG4gICAgICAgIGxldCBza2lwcGVkID0gdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDEgJiYgL1tcXHU0RTAwLVxcdWZmZmZdLy50ZXN0KHNraXBwZWQpKSB7XG4gICAgICAgICAgICBsZXQgc2VnbWVudHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHNraXBwZWQpKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBzZWdtZW50c1sxXS5pbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZC5oZWFkICsgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUluZm8odmlldykge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IDwgdmlldy5zY3JvbGxET00uc2Nyb2xsSGVpZ2h0IC0gMjtcbiAgICBsZXQgbWFyZ2luVG9wID0gMCwgbWFyZ2luQm90dG9tID0gMCwgaGVpZ2h0O1xuICAgIGlmIChzZWxmU2Nyb2xsKSB7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5zID0gc291cmNlKHZpZXcpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3ApXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcCwgbWFyZ2luVG9wKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tKVxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20sIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIHNlbGZTY3JvbGwsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgaGVpZ2h0IC0gNSkgfTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC50b3AgKyBwYWdlLm1hcmdpblRvcCwgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gLSBwYWdlLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxCb3R0b20pXG4gICAgICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodmlldywgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbCh2aWV3LnN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgaGVhZCA9IGhvdyhyYW5nZSk7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkLmhlYWQsIGhlYWQuZ29hbENvbHVtbiwgaGVhZC5iaWRpTGV2ZWwgfHwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHZpZXcuc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VsZWN0QnlDaGFyKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSBsZWZ0LCB3aGlsZSBsZWF2aW5nXG50aGUgYW5jaG9yIGluIHBsYWNlLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhclJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZUJ5R3JvdXAocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIFtncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIHRvXG50aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RHcm91cExlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgIWx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RHcm91cFJpZ2h0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBmYWxzZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0U3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheExlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5TGluZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIHVwLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVVcCA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBzZWxlY3RMaW5lRG93biA9IHZpZXcgPT4gc2VsZWN0QnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gc2VsZWN0QnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2VJbmZvKHZpZXcpLmhlaWdodCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSB1cC5cbiovXG5jb25zdCBzZWxlY3RQYWdlVXAgPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0UGFnZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5UGFnZSh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBwcmV2aW91cyBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBmYWxzZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVN0YXJ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lRW5kID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiAwIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgZW50aXJlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogMCwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9LCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRXhwYW5kIHRoZSBzZWxlY3Rpb24gdG8gY292ZXIgZW50aXJlIGxpbmVzLlxuKi9cbmNvbnN0IHNlbGVjdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgTWF0aC5taW4odG8gKyAxLCBzdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMpLCB1c2VyRXZlbnQ6IFwic2VsZWN0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBuZXh0IHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGVcbnNlbGVjdGlvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaW5zb2ZhciBhcyB0aGUgbGFuZ3VhZ2Vcbltwcm92aWRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZSkgeW91IHVzZSBidWlsZHMgdXAgYSBmdWxsXG5zeW50YXggdHJlZS5cbiovXG5jb25zdCBzZWxlY3RQYXJlbnRTeW50YXggPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHN0YWNrID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIDEpO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSB9ID0gY3VyO1xuICAgICAgICAgICAgaWYgKCgobm9kZS5mcm9tIDwgcmFuZ2UuZnJvbSAmJiBub2RlLnRvID49IHJhbmdlLnRvKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnRvID4gcmFuZ2UudG8gJiYgbm9kZS5mcm9tIDw9IHJhbmdlLmZyb20pKSAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShub2RlLnRvLCBub2RlLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgbGV0IHRvd2FyZHMgPSBieShyYW5nZSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmJhY2t3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3dhcmRzID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBza2lwQXRvbWljKHRhcmdldCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICAgICAgdG8gPSBza2lwQXRvbWljKHRhcmdldCwgdG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRvID8geyByYW5nZSB9IDogeyBjaGFuZ2VzOiB7IGZyb20sIHRvIH0sIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIGZyb20gPCByYW5nZS5oZWFkID8gLTEgOiAxKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmVmb3JlLCB0YXJnZXRQb3M7XG4gICAgaWYgKCFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKCFmb3J3YXJkICYmIC9bXFx1ZmUwMC1cXHVmZTBmXS8udGVzdChsaW5lLnRleHQuc2xpY2UodGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBwb3MgLSBsaW5lLmZyb20pKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0YXJnZXRQb3MgLSBsaW5lLmZyb20sIGZhbHNlLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXJcbmJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnlDaGFyKHZpZXcsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgdHJ1ZSk7XG5jb25zdCBkZWxldGVCeUdyb3VwID0gKHRhcmdldCwgZm9yd2FyZCkgPT4gZGVsZXRlQnkodGFyZ2V0LCByYW5nZSA9PiB7XG4gICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGZvciAobGV0IGNhdCA9IG51bGw7Oykge1xuICAgICAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gcmFuZ2UuaGVhZCAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHBvcyArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmb3J3YXJkKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IG5leHRDaGFyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHBvcywgbmV4dCkgLSBsaW5lLmZyb20sIE1hdGgubWF4KHBvcywgbmV4dCkgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dENoYXIpO1xuICAgICAgICBpZiAoY2F0ICE9IG51bGwgJiYgbmV4dENhdCAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKG5leHRDaGFyICE9IFwiIFwiIHx8IHBvcyAhPSByYW5nZS5oZWFkKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBiYWNrd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0XG5bZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3Lm1vdmVCeUdyb3VwKSwgb25seSBza2lwcGluZyBncm91cHMgb2ZcbndoaXRlc3BhY2Ugd2hlbiB0aGV5IGNvbnNpc3Qgb2YgYSBzaW5nbGUgc3BhY2UuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBCYWNrd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciBmb3J3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHQgZ3JvdXAuXG4qL1xuY29uc3QgZGVsZXRlR3JvdXBGb3J3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCB0cnVlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgZW5kIG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZUVuZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lRW5kID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bztcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVFbmQgPyBsaW5lRW5kIDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBiZWZvcmUgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lU3RhcnQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZhbHNlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkID4gbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5tYXgoMCwgcmFuZ2UuaGVhZCAtIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA8IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSBhbGwgd2hpdGVzcGFjZSBkaXJlY3RseSBiZWZvcmUgYSBsaW5lIGVuZCBmcm9tIHRoZVxuZG9jdW1lbnQuXG4qL1xuY29uc3QgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDAsIHByZXYgPSBcIlwiLCBpdGVyID0gc3RhdGUuZG9jLml0ZXIoKTs7KSB7XG4gICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICBpZiAoaXRlci5saW5lQnJlYWsgfHwgaXRlci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgdHJhaWxpbmcgPSBwcmV2LnNlYXJjaCgvXFxzKyQvKTtcbiAgICAgICAgICAgIGlmICh0cmFpbGluZyA+IC0xKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcyAtIChwcmV2Lmxlbmd0aCAtIHRyYWlsaW5nKSwgdG86IHBvcyB9KTtcbiAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwcmV2ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBpdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBpdGVyLnZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHVzZXJFdmVudDogXCJkZWxldGVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIGVhY2ggc2VsZWN0aW9uIHJhbmdlIHdpdGggYSBsaW5lIGJyZWFrLCBsZWF2aW5nIHRoZSBjdXJzb3Jcbm9uIHRoZSBsaW5lIGJlZm9yZSB0aGUgYnJlYWsuXG4qL1xuY29uc3Qgc3BsaXRMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIlwiLCBcIlwiXSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20pIH07XG4gICAgfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkZsaXAgdGhlIGNoYXJhY3RlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3Vyc29yKHMpLlxuKi9cbmNvbnN0IHRyYW5zcG9zZUNoYXJzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5IHx8IHJhbmdlLmZyb20gPT0gMCB8fCByYW5nZS5mcm9tID09IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGZyb20gPSBwb3MgPT0gbGluZS5mcm9tID8gcG9zIC0gMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gcG9zID09IGxpbmUudG8gPyBwb3MgKyAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgdHJ1ZSkgKyBsaW5lLmZyb207XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKHBvcywgdG8pLmFwcGVuZChzdGF0ZS5kb2Muc2xpY2UoZnJvbSwgcG9zKSkgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcIm1vdmUuY2hhcmFjdGVyXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkge1xuICAgIGxldCBibG9ja3MgPSBbXSwgdXB0byA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSksIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKTtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiByYW5nZS50byA9PSBlbmRMaW5lLmZyb20pXG4gICAgICAgICAgICBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byAtIDEpO1xuICAgICAgICBpZiAodXB0byA+PSBzdGFydExpbmUubnVtYmVyKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGJsb2Nrc1tibG9ja3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2LnRvID0gZW5kTGluZS50bztcbiAgICAgICAgICAgIHByZXYucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBmcm9tOiBzdGFydExpbmUuZnJvbSwgdG86IGVuZExpbmUudG8sIHJhbmdlczogW3JhbmdlXSB9KTtcbiAgICAgICAgfVxuICAgICAgICB1cHRvID0gZW5kTGluZS5udW1iZXIgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tzO1xufVxuZnVuY3Rpb24gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZCA/IGJsb2NrLnRvID09IHN0YXRlLmRvYy5sZW5ndGggOiBibG9jay5mcm9tID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IG5leHRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmb3J3YXJkID8gYmxvY2sudG8gKyAxIDogYmxvY2suZnJvbSAtIDEpO1xuICAgICAgICBsZXQgc2l6ZSA9IG5leHRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgdG86IG5leHRMaW5lLnRvIH0sIHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBuZXh0TGluZS50ZXh0ICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuYW5jaG9yICsgc2l6ZSksIE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIHIuaGVhZCArIHNpemUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBuZXh0TGluZS5mcm9tLCB0bzogYmxvY2suZnJvbSB9LCB7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIG5leHRMaW5lLnRleHQgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5hbmNob3IgLSBzaXplLCByLmhlYWQgLSBzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbkluZGV4KSxcbiAgICAgICAgdXNlckV2ZW50OiBcIm1vdmUubGluZVwiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyB1cCBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3RlZCBsaW5lcyBkb3duIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuZnVuY3Rpb24gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmb3J3YXJkKSB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2suZnJvbSwgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pICsgc3RhdGUubGluZUJyZWFrIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBzdGF0ZS5kb2Muc2xpY2UoYmxvY2suZnJvbSwgYmxvY2sudG8pIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0LmNvcHlsaW5lXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSB0b3AgY29weS5cbiovXG5jb25zdCBjb3B5TGluZVVwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBjb3B5IG9mIHRoZSBzZWxlY3RlZCBsaW5lcy4gS2VlcCB0aGUgc2VsZWN0aW9uIGluIHRoZSBib3R0b20gY29weS5cbiovXG5jb25zdCBjb3B5TGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbi8qKlxuRGVsZXRlIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlcyhzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICB9KSk7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUpKS5tYXAoY2hhbmdlcyk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJkZWxldGUubGluZVwiIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKHN0YXRlLmxpbmVCcmVhayksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgcG9zKSB7XG4gICAgaWYgKC9cXChcXCl8XFxbXFxdfFxce1xcfS8udGVzdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MgKyAxKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IHBvcywgdG86IHBvcyB9O1xuICAgIGxldCBjb250ZXh0ID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyk7XG4gICAgbGV0IGJlZm9yZSA9IGNvbnRleHQuY2hpbGRCZWZvcmUocG9zKSwgYWZ0ZXIgPSBjb250ZXh0LmNoaWxkQWZ0ZXIocG9zKSwgY2xvc2VkQnk7XG4gICAgaWYgKGJlZm9yZSAmJiBhZnRlciAmJiBiZWZvcmUudG8gPD0gcG9zICYmIGFmdGVyLmZyb20gPj0gcG9zICYmXG4gICAgICAgIChjbG9zZWRCeSA9IGJlZm9yZS50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSAmJiBjbG9zZWRCeS5pbmRleE9mKGFmdGVyLm5hbWUpID4gLTEgJiZcbiAgICAgICAgc3RhdGUuZG9jLmxpbmVBdChiZWZvcmUudG8pLmZyb20gPT0gc3RhdGUuZG9jLmxpbmVBdChhZnRlci5mcm9tKS5mcm9tICYmXG4gICAgICAgICEvXFxTLy50ZXN0KHN0YXRlLnNsaWNlRG9jKGJlZm9yZS50bywgYWZ0ZXIuZnJvbSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBiZWZvcmUudG8sIHRvOiBhZnRlci5mcm9tIH07XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcblJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBhbmQgaW5kZW50IHRoZSBuZXdseSBjcmVhdGVkXG5saW5lKHMpLiBJZiB0aGUgY3VycmVudCBsaW5lIGNvbnNpc3RzIG9ubHkgb2Ygd2hpdGVzcGFjZSwgdGhpc1xud2lsbCBhbHNvIGRlbGV0ZSB0aGF0IHdoaXRlc3BhY2UuIFdoZW4gdGhlIGN1cnNvciBpcyBiZXR3ZWVuXG5tYXRjaGluZyBicmFja2V0cywgYW4gYWRkaXRpb25hbCBuZXdsaW5lIHdpbGwgYmUgaW5zZXJ0ZWQgYWZ0ZXJcbnRoZSBjdXJzb3IuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUFuZEluZGVudCA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgYmxhbmssIGluZGVudGVkIGxpbmUgYmVsb3cgdGhlIGN1cnJlbnQgbGluZS5cbiovXG5jb25zdCBpbnNlcnRCbGFua0xpbmUgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudCh0cnVlKTtcbmZ1bmN0aW9uIG5ld2xpbmVBbmRJbmRlbnQoYXRFb2YpIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGxldCBleHBsb2RlID0gIWF0RW9mICYmIGZyb20gPT0gdG8gJiYgaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGF0RW9mKVxuICAgICAgICAgICAgICAgIGZyb20gPSB0byA9ICh0byA8PSBsaW5lLnRvID8gbGluZSA6IHN0YXRlLmRvYy5saW5lQXQodG8pKS50bztcbiAgICAgICAgICAgIGxldCBjeCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IHNpbXVsYXRlQnJlYWs6IGZyb20sIHNpbXVsYXRlRG91YmxlQnJlYWs6ICEhZXhwbG9kZSB9KTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjeCwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gY291bnRDb2x1bW4oL15cXHMqLy5leGVjKHN0YXRlLmRvYy5saW5lQXQoZnJvbSkudGV4dClbMF0sIHN0YXRlLnRhYlNpemUpO1xuICAgICAgICAgICAgd2hpbGUgKHRvIDwgbGluZS50byAmJiAvXFxzLy50ZXN0KGxpbmUudGV4dFt0byAtIGxpbmUuZnJvbV0pKVxuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gZXhwbG9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID4gbGluZS5mcm9tICYmIGZyb20gPCBsaW5lLmZyb20gKyAxMDAgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0LnNsaWNlKDAsIGZyb20pKSlcbiAgICAgICAgICAgICAgICBmcm9tID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IFtcIlwiLCBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCldO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goaW5kZW50U3RyaW5nKHN0YXRlLCBjeC5saW5lSW5kZW50KGxpbmUuZnJvbSwgLTEpKSk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IFRleHQub2YoaW5zZXJ0KSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyAxICsgaW5zZXJ0WzFdLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgZikge1xuICAgIGxldCBhdExpbmUgPSAtMTtcbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHJhbmdlLmZyb207IHBvcyA8PSByYW5nZS50bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gYXRMaW5lICYmIChyYW5nZS5lbXB0eSB8fCByYW5nZS50byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBmKGxpbmUsIGNoYW5nZXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICBhdExpbmUgPSBsaW5lLm51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmFuY2hvciwgMSksIGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuaGVhZCwgMSkpIH07XG4gICAgfSk7XG59XG4vKipcbkF1dG8taW5kZW50IHRoZSBzZWxlY3RlZCBsaW5lcy4gVGhpcyB1c2VzIHRoZSBbaW5kZW50YXRpb24gc2VydmljZVxuZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkgYXMgc291cmNlIGZvciBhdXRvLWluZGVudFxuaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgaW5kZW50U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSB1cGRhdGVkW3N0YXJ0XTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCA9PSBudWxsID8gLTEgOiBmb3VuZDtcbiAgICAgICAgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcywgcmFuZ2UpID0+IHtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0gfHwgcmFuZ2UuZnJvbSA8IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyB1c2VyRXZlbnQ6IFwiaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQWRkIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gdG8gYWxsIHNlbGVjdGVkXG5saW5lcy5cbiovXG5jb25zdCBpbmRlbnRNb3JlID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0OiBzdGF0ZS5mYWNldChpbmRlbnRVbml0KSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuaW5kZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVtb3ZlIGEgW3VuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgb2YgaW5kZW50YXRpb24gZnJvbSBhbGxcbnNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IGluZGVudExlc3MgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGlmICghc3BhY2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihzcGFjZSwgc3RhdGUudGFiU2l6ZSksIGtlZXAgPSAwO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gaW5kZW50U3RyaW5nKHN0YXRlLCBNYXRoLm1heCgwLCBjb2wgLSBnZXRJbmRlbnRVbml0KHN0YXRlKSkpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IHNwYWNlLmxlbmd0aCAmJiBrZWVwIDwgaW5zZXJ0Lmxlbmd0aCAmJiBzcGFjZS5jaGFyQ29kZUF0KGtlZXApID09IGluc2VydC5jaGFyQ29kZUF0KGtlZXApKVxuICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBrZWVwLCB0bzogbGluZS5mcm9tICsgc3BhY2UubGVuZ3RoLCBpbnNlcnQ6IGluc2VydC5zbGljZShrZWVwKSB9KTtcbiAgICB9KSwgeyB1c2VyRXZlbnQ6IFwiZGVsZXRlLmRlZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkluc2VydCBhIHRhYiBjaGFyYWN0ZXIgYXQgdGhlIGN1cnNvciBvciwgaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkLFxudXNlIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgdG8gaW5kZW50IHRoZSBlbnRpcmVcbnNlbGVjdGlvbi5cbiovXG5jb25zdCBpbnNlcnRUYWIgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiAhci5lbXB0eSkpXG4gICAgICAgIHJldHVybiBpbmRlbnRNb3JlKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShzdGF0ZS5yZXBsYWNlU2VsZWN0aW9uKFwiXFx0XCIpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BcnJheSBvZiBrZXkgYmluZGluZ3MgY29udGFpbmluZyB0aGUgRW1hY3Mtc3R5bGUgYmluZGluZ3MgdGhhdCBhcmVcbmF2YWlsYWJsZSBvbiBtYWNPUyBieSBkZWZhdWx0LlxuXG4gLSBDdHJsLWI6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWY6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1wOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtbjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIEN0cmwtYTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWU6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZDogW2BkZWxldGVDaGFyRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckZvcndhcmQpXG4gLSBDdHJsLWg6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBDdHJsLWs6IFtgZGVsZXRlVG9MaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVUb0xpbmVFbmQpXG4gLSBDdHJsLUFsdC1oOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLW86IFtgc3BsaXRMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdExpbmUpXG4gLSBDdHJsLXQ6IFtgdHJhbnNwb3NlQ2hhcnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRyYW5zcG9zZUNoYXJzKVxuIC0gQ3RybC12OiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bilcbiAtIEFsdC12OiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKVxuKi9cbmNvbnN0IGVtYWNzU3R5bGVLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1iXCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJDdHJsLWZcIiwgcnVuOiBjdXJzb3JDaGFyUmlnaHQsIHNoaWZ0OiBzZWxlY3RDaGFyUmlnaHQgfSxcbiAgICB7IGtleTogXCJDdHJsLXBcIiwgcnVuOiBjdXJzb3JMaW5lVXAsIHNoaWZ0OiBzZWxlY3RMaW5lVXAgfSxcbiAgICB7IGtleTogXCJDdHJsLW5cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1hXCIsIHJ1bjogY3Vyc29yTGluZVN0YXJ0LCBzaGlmdDogc2VsZWN0TGluZVN0YXJ0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1lXCIsIHJ1bjogY3Vyc29yTGluZUVuZCwgc2hpZnQ6IHNlbGVjdExpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWRcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtaFwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwta1wiLCBydW46IGRlbGV0ZVRvTGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LWhcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1vXCIsIHJ1bjogc3BsaXRMaW5lIH0sXG4gICAgeyBrZXk6IFwiQ3RybC10XCIsIHJ1bjogdHJhbnNwb3NlQ2hhcnMgfSxcbiAgICB7IGtleTogXCJDdHJsLXZcIiwgcnVuOiBjdXJzb3JQYWdlRG93biB9LFxuXTtcbi8qKlxuQW4gYXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNsb3NlbHkgc3RpY2tpbmcgdG8gcGxhdGZvcm0tc3RhbmRhcmQgb3JcbndpZGVseSB1c2VkIGJpbmRpbmdzLiAoVGhpcyBpbmNsdWRlcyB0aGUgYmluZGluZ3MgZnJvbVxuW2BlbWFjc1N0eWxlS2V5bWFwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5lbWFjc1N0eWxlS2V5bWFwKSwgd2l0aCB0aGVpciBga2V5YFxucHJvcGVydHkgY2hhbmdlZCB0byBgbWFjYC4pXG5cbiAtIEFycm93TGVmdDogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEFycm93UmlnaHQ6IFtgY3Vyc29yQ2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyUmlnaHQpIChbYHNlbGVjdENoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhclJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0xlZnQgKEFsdC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSAoW2BzZWxlY3RHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dSaWdodCAoQWx0LUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvckdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwUmlnaHQpIChbYHNlbGVjdEdyb3VwUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdEdyb3VwUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dMZWZ0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93UmlnaHQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dVcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBBcnJvd0Rvd246IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dVcCAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBQYWdlVXA6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZURvd246IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKSAoW2BzZWxlY3RQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZURvd24pIHdpdGggU2hpZnQpXG4gLSBIb21lOiBbYGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gRW5kOiBbYGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUhvbWUgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtRW5kIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gRW50ZXI6IFtgaW5zZXJ0TmV3bGluZUFuZEluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0TmV3bGluZUFuZEluZGVudClcbiAtIEN0cmwtYSAoQ21kLWEgb24gbWFjT1MpOiBbYHNlbGVjdEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0QWxsKVxuIC0gQmFja3NwYWNlOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gRGVsZXRlOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtQmFja3NwYWNlIChBbHQtQmFja3NwYWNlIG9uIG1hY09TKTogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1EZWxldGUgKEFsdC1EZWxldGUgb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwRm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBGb3J3YXJkKVxuIC0gQ21kLUJhY2tzcGFjZSAobWFjT1MpOiBbYGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCkuXG4gLSBDbWQtRGVsZXRlIChtYWNPUyk6IFtgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCkuXG4qL1xuY29uc3Qgc3RhbmRhcmRLZXltYXAgPSAvKkBfX1BVUkVfXyovW1xuICAgIHsga2V5OiBcIkFycm93TGVmdFwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFycm93TGVmdFwiLCBtYWM6IFwiQWx0LUFycm93TGVmdFwiLCBydW46IGN1cnNvckdyb3VwTGVmdCwgc2hpZnQ6IHNlbGVjdEdyb3VwTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dSaWdodFwiLCBtYWM6IFwiQWx0LUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JHcm91cFJpZ2h0LCBzaGlmdDogc2VsZWN0R3JvdXBSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IG1hYzogXCJDbWQtQXJyb3dVcFwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93VXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JMaW5lRG93biwgc2hpZnQ6IHNlbGVjdExpbmVEb3duLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0Rvd25cIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IG1hYzogXCJDdHJsLUFycm93RG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiBjdXJzb3JQYWdlVXAsIHNoaWZ0OiBzZWxlY3RQYWdlVXAgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IGN1cnNvclBhZ2VEb3duLCBzaGlmdDogc2VsZWN0UGFnZURvd24gfSxcbiAgICB7IGtleTogXCJIb21lXCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtSG9tZVwiLCBydW46IGN1cnNvckRvY1N0YXJ0LCBzaGlmdDogc2VsZWN0RG9jU3RhcnQgfSxcbiAgICB7IGtleTogXCJFbmRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkLCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtRW5kXCIsIHJ1bjogY3Vyc29yRG9jRW5kLCBzaGlmdDogc2VsZWN0RG9jRW5kIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXG4gICAgeyBrZXk6IFwiTW9kLWFcIiwgcnVuOiBzZWxlY3RBbGwgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1CYWNrc3BhY2VcIiwgbWFjOiBcIkFsdC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLURlbGV0ZVwiLCBtYWM6IFwiQWx0LURlbGV0ZVwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1EZWxldGVcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDbWQtRW50ZXIgb24gbWFjT1MpOiBbYGluc2VydEJsYW5rTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0QmxhbmtMaW5lKVxuLSBBbHQtbCAoQ3RybC1sIG9uIG1hY09TKTogW2BzZWxlY3RMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lKVxuLSBDdHJsLWkgKENtZC1pIG9uIG1hY09TKTogW2BzZWxlY3RQYXJlbnRTeW50YXhgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhcmVudFN5bnRheClcbi0gQ3RybC1bIChDbWQtWyBvbiBtYWNPUyk6IFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcylcbi0gQ3RybC1dIChDbWQtXSBvbiBtYWNPUyk6IFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSlcbi0gQ3RybC1BbHQtXFxcXCAoQ21kLUFsdC1cXFxcIG9uIG1hY09TKTogW2BpbmRlbnRTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudFNlbGVjdGlvbilcbi0gU2hpZnQtQ3RybC1rIChTaGlmdC1DbWQtayBvbiBtYWNPUyk6IFtgZGVsZXRlTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZSlcbi0gU2hpZnQtQ3RybC1cXFxcIChTaGlmdC1DbWQtXFxcXCBvbiBtYWNPUyk6IFtgY3Vyc29yTWF0Y2hpbmdCcmFja2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQpXG4tIEN0cmwtLyAoQ21kLS8gb24gbWFjT1MpOiBbYHRvZ2dsZUNvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUNvbW1lbnQpLlxuLSBTaGlmdC1BbHQtYTogW2B0b2dnbGVCbG9ja0NvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUJsb2NrQ29tbWVudCkuXG4qL1xuY29uc3QgZGVmYXVsdEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQWx0LUFycm93TGVmdFwiLCBtYWM6IFwiQ3RybC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JTeW50YXhMZWZ0LCBzaGlmdDogc2VsZWN0U3ludGF4TGVmdCB9LFxuICAgIHsga2V5OiBcIkFsdC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJDdHJsLUFycm93UmlnaHRcIiwgcnVuOiBjdXJzb3JTeW50YXhSaWdodCwgc2hpZnQ6IHNlbGVjdFN5bnRheFJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93VXBcIiwgcnVuOiBtb3ZlTGluZVVwIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93VXBcIiwgcnVuOiBjb3B5TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93RG93blwiLCBydW46IG1vdmVMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIlNoaWZ0LUFsdC1BcnJvd0Rvd25cIiwgcnVuOiBjb3B5TGluZURvd24gfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBzaW1wbGlmeVNlbGVjdGlvbiB9LFxuICAgIHsga2V5OiBcIk1vZC1FbnRlclwiLCBydW46IGluc2VydEJsYW5rTGluZSB9LFxuICAgIHsga2V5OiBcIkFsdC1sXCIsIG1hYzogXCJDdHJsLWxcIiwgcnVuOiBzZWxlY3RMaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWlcIiwgcnVuOiBzZWxlY3RQYXJlbnRTeW50YXgsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLVtcIiwgcnVuOiBpbmRlbnRMZXNzIH0sXG4gICAgeyBrZXk6IFwiTW9kLV1cIiwgcnVuOiBpbmRlbnRNb3JlIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1cXFxcXCIsIHJ1bjogaW5kZW50U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLWtcIiwgcnVuOiBkZWxldGVMaW5lIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtTW9kLVxcXFxcIiwgcnVuOiBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgfSxcbiAgICB7IGtleTogXCJNb2QtL1wiLCBydW46IHRvZ2dsZUNvbW1lbnQgfSxcbiAgICB7IGtleTogXCJBbHQtQVwiLCBydW46IHRvZ2dsZUJsb2NrQ29tbWVudCB9XG5dLmNvbmNhdChzdGFuZGFyZEtleW1hcCk7XG4vKipcbkEgYmluZGluZyB0aGF0IGJpbmRzIFRhYiB0byBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIGFuZFxuU2hpZnQtVGFiIHRvIFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcykuXG5QbGVhc2Ugc2VlIHRoZSBbVGFiIGV4YW1wbGVdKC4uLy4uL2V4YW1wbGVzL3RhYi8pIGJlZm9yZSB1c2luZ1xudGhpcy5cbiovXG5jb25zdCBpbmRlbnRXaXRoVGFiID0geyBrZXk6IFwiVGFiXCIsIHJ1bjogaW5kZW50TW9yZSwgc2hpZnQ6IGluZGVudExlc3MgfTtcblxuZXhwb3J0IHsgYmxvY2tDb21tZW50LCBibG9ja1VuY29tbWVudCwgY29weUxpbmVEb3duLCBjb3B5TGluZVVwLCBjdXJzb3JDaGFyQmFja3dhcmQsIGN1cnNvckNoYXJGb3J3YXJkLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwTGVmdCwgY3Vyc29yR3JvdXBSaWdodCwgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIGN1cnNvckxpbmVCb3VuZGFyeUxlZnQsIGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0LCBjdXJzb3JMaW5lRG93biwgY3Vyc29yTGluZUVuZCwgY3Vyc29yTGluZVN0YXJ0LCBjdXJzb3JMaW5lVXAsIGN1cnNvck1hdGNoaW5nQnJhY2tldCwgY3Vyc29yUGFnZURvd24sIGN1cnNvclBhZ2VVcCwgY3Vyc29yU3Vid29yZEJhY2t3YXJkLCBjdXJzb3JTdWJ3b3JkRm9yd2FyZCwgY3Vyc29yU3ludGF4TGVmdCwgY3Vyc29yU3ludGF4UmlnaHQsIGRlZmF1bHRLZXltYXAsIGRlbGV0ZUNoYXJCYWNrd2FyZCwgZGVsZXRlQ2hhckZvcndhcmQsIGRlbGV0ZUdyb3VwQmFja3dhcmQsIGRlbGV0ZUdyb3VwRm9yd2FyZCwgZGVsZXRlTGluZSwgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQsIGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQsIGRlbGV0ZVRvTGluZUVuZCwgZGVsZXRlVG9MaW5lU3RhcnQsIGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSwgZW1hY3NTdHlsZUtleW1hcCwgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbmRlbnRMZXNzLCBpbmRlbnRNb3JlLCBpbmRlbnRTZWxlY3Rpb24sIGluZGVudFdpdGhUYWIsIGluc2VydEJsYW5rTGluZSwgaW5zZXJ0TmV3bGluZSwgaW5zZXJ0TmV3bGluZUFuZEluZGVudCwgaW5zZXJ0VGFiLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCBsaW5lQ29tbWVudCwgbGluZVVuY29tbWVudCwgbW92ZUxpbmVEb3duLCBtb3ZlTGluZVVwLCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHNlbGVjdEFsbCwgc2VsZWN0Q2hhckJhY2t3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZCwgc2VsZWN0Q2hhckxlZnQsIHNlbGVjdENoYXJSaWdodCwgc2VsZWN0RG9jRW5kLCBzZWxlY3REb2NTdGFydCwgc2VsZWN0R3JvdXBCYWNrd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0b2dnbGVCbG9ja0NvbW1lbnQsIHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSwgdG9nZ2xlQ29tbWVudCwgdG9nZ2xlTGluZUNvbW1lbnQsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\nfunction defineLanguageFacet(baseData) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: baseData ? values => values.concat(baseData) : undefined\n  });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/\nconst sublanguageProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/\nclass Language {\n  /**\n  Construct a language object. If you need to invoke this\n  directly, first define a data facet with\n  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n  to the language's outer syntax node.\n  */\n  constructor(\n  /**\n  The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n  used for this language.\n  */\n  data, parser, extraExtensions = [],\n  /**\n  A language name.\n  */\n  name = \"\") {\n    this.data = data;\n    this.name = name;\n    // Kludge to define EditorState.tree as a debugging helper,\n    // without the EditorState package actually knowing about\n    // languages and lezer trees.\n    if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n      get() {\n        return syntaxTree(this);\n      }\n    });\n    this.parser = parser;\n    this.extension = [language.of(this), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => {\n      let top = topNodeAt(state, pos, side),\n        data = top.type.prop(languageDataProp);\n      if (!data) return [];\n      let base = state.facet(data),\n        sub = top.type.prop(sublanguageProp);\n      if (sub) {\n        let innerNode = top.resolve(pos - top.from, side);\n        for (let sublang of sub) if (sublang.test(innerNode, state)) {\n          let data = state.facet(sublang.facet);\n          return sublang.type == \"replace\" ? data : data.concat(base);\n        }\n      }\n      return base;\n    })].concat(extraExtensions);\n  }\n  /**\n  Query whether this language is active at the given position.\n  */\n  isActiveAt(state, pos, side = -1) {\n    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n  }\n  /**\n  Find the document regions that were parsed using this language.\n  The returned regions will _include_ any nested languages rooted\n  in this language, when those exist.\n  */\n  findRegions(state) {\n    let lang = state.facet(language);\n    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{\n      from: 0,\n      to: state.doc.length\n    }];\n    if (!lang || !lang.allowsNesting) return [];\n    let result = [];\n    let explore = (tree, from) => {\n      if (tree.prop(languageDataProp) == this.data) {\n        result.push({\n          from,\n          to: from + tree.length\n        });\n        return;\n      }\n      let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n      if (mount) {\n        if (mount.tree.prop(languageDataProp) == this.data) {\n          if (mount.overlay) for (let r of mount.overlay) result.push({\n            from: r.from + from,\n            to: r.to + from\n          });else result.push({\n            from: from,\n            to: from + tree.length\n          });\n          return;\n        } else if (mount.overlay) {\n          let size = result.length;\n          explore(mount.tree, mount.overlay[0].from + from);\n          if (result.length > size) return;\n        }\n      }\n      for (let i = 0; i < tree.children.length; i++) {\n        let ch = tree.children[i];\n        if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n      }\n    };\n    explore(syntaxTree(state), 0);\n    return result;\n  }\n  /**\n  Indicates whether this language allows nested languages. The\n  default implementation returns true.\n  */\n  get allowsNesting() {\n    return true;\n  }\n}\n/**\n@internal\n*/\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n  let topLang = state.facet(language),\n    tree = syntaxTree(state).topNode;\n  if (!topLang || topLang.allowsNesting) {\n    for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers)) if (node.type.isTop) tree = node;\n  }\n  return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\nclass LRLanguage extends Language {\n  constructor(data, parser, name) {\n    super(data, parser, [], name);\n    this.parser = parser;\n  }\n  /**\n  Define a language from a parser.\n  */\n  static define(spec) {\n    let data = defineLanguageFacet(spec.languageData);\n    return new LRLanguage(data, spec.parser.configure({\n      props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n    }), spec.name);\n  }\n  /**\n  Create a new instance of this language with a reconfigured\n  version of its parser and optionally a new name.\n  */\n  configure(options, name) {\n    return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n  }\n  get allowsNesting() {\n    return this.parser.hasWrappers();\n  }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/\nfunction syntaxTree(state) {\n  let field = state.field(Language.state, false);\n  return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n  var _a;\n  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n  if (!parse) return null;\n  let oldVieport = parse.viewport;\n  parse.updateViewport({\n    from: 0,\n    to: upto\n  });\n  let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n  parse.updateViewport(oldVieport);\n  return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/\nfunction syntaxTreeAvailable(state, upto = state.doc.length) {\n  var _a;\n  return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/\nfunction forceParsing(view, upto = view.viewport.to, timeout = 100) {\n  let success = ensureSyntaxTree(view.state, upto, timeout);\n  if (success != syntaxTree(view.state)) view.dispatch({});\n  return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/\nfunction syntaxParserRunning(view) {\n  var _a;\n  return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/\nclass DocInput {\n  /**\n  Create an input object for the given document.\n  */\n  constructor(doc) {\n    this.doc = doc;\n    this.cursorPos = 0;\n    this.string = \"\";\n    this.cursor = doc.iter();\n  }\n  get length() {\n    return this.doc.length;\n  }\n  syncTo(pos) {\n    this.string = this.cursor.next(pos - this.cursorPos).value;\n    this.cursorPos = pos + this.string.length;\n    return this.cursorPos - this.string.length;\n  }\n  chunk(pos) {\n    this.syncTo(pos);\n    return this.string;\n  }\n  get lineChunks() {\n    return true;\n  }\n  read(from, to) {\n    let stringStart = this.cursorPos - this.string.length;\n    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);\n  }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\nclass ParseContext {\n  constructor(parser,\n  /**\n  The current editor state.\n  */\n  state,\n  /**\n  Tree fragments that can be reused by incremental re-parses.\n  */\n  fragments = [],\n  /**\n  @internal\n  */\n  tree,\n  /**\n  @internal\n  */\n  treeLen,\n  /**\n  The current editor viewport (or some overapproximation\n  thereof). Intended to be used for opportunistically avoiding\n  work (in which case\n  [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n  should be called to make sure the parser is restarted when the\n  skipped region becomes visible).\n  */\n  viewport,\n  /**\n  @internal\n  */\n  skipped,\n  /**\n  This is where skipping parsers can register a promise that,\n  when resolved, will schedule a new parse. It is cleared when\n  the parse worker picks up the promise. @internal\n  */\n  scheduleOn) {\n    this.parser = parser;\n    this.state = state;\n    this.fragments = fragments;\n    this.tree = tree;\n    this.treeLen = treeLen;\n    this.viewport = viewport;\n    this.skipped = skipped;\n    this.scheduleOn = scheduleOn;\n    this.parse = null;\n    /**\n    @internal\n    */\n    this.tempSkipped = [];\n  }\n  /**\n  @internal\n  */\n  static create(parser, state, viewport) {\n    return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n  }\n  startParse() {\n    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n  }\n  /**\n  @internal\n  */\n  work(until, upto) {\n    if (upto != null && upto >= this.state.doc.length) upto = undefined;\n    if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n      this.takeTree();\n      return true;\n    }\n    return this.withContext(() => {\n      var _a;\n      if (typeof until == \"number\") {\n        let endTime = Date.now() + until;\n        until = () => Date.now() > endTime;\n      }\n      if (!this.parse) this.parse = this.startParse();\n      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n      for (;;) {\n        let done = this.parse.advance();\n        if (done) {\n          this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n          this.tree = done;\n          this.parse = null;\n          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();else return true;\n        }\n        if (until()) return false;\n      }\n    });\n  }\n  /**\n  @internal\n  */\n  takeTree() {\n    let pos, tree;\n    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n      this.withContext(() => {\n        while (!(tree = this.parse.advance())) {}\n      });\n      this.treeLen = pos;\n      this.tree = tree;\n      this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n      this.parse = null;\n    }\n  }\n  withContext(f) {\n    let prev = currentContext;\n    currentContext = this;\n    try {\n      return f();\n    } finally {\n      currentContext = prev;\n    }\n  }\n  withoutTempSkipped(fragments) {\n    for (let r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);\n    return fragments;\n  }\n  /**\n  @internal\n  */\n  changes(changes, newState) {\n    let {\n      fragments,\n      tree,\n      treeLen,\n      viewport,\n      skipped\n    } = this;\n    this.takeTree();\n    if (!changes.empty) {\n      let ranges = [];\n      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({\n        fromA,\n        toA,\n        fromB,\n        toB\n      }));\n      fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n      tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n      treeLen = 0;\n      viewport = {\n        from: changes.mapPos(viewport.from, -1),\n        to: changes.mapPos(viewport.to, 1)\n      };\n      if (this.skipped.length) {\n        skipped = [];\n        for (let r of this.skipped) {\n          let from = changes.mapPos(r.from, 1),\n            to = changes.mapPos(r.to, -1);\n          if (from < to) skipped.push({\n            from,\n            to\n          });\n        }\n      }\n    }\n    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n  }\n  /**\n  @internal\n  */\n  updateViewport(viewport) {\n    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n    this.viewport = viewport;\n    let startLen = this.skipped.length;\n    for (let i = 0; i < this.skipped.length; i++) {\n      let {\n        from,\n        to\n      } = this.skipped[i];\n      if (from < viewport.to && to > viewport.from) {\n        this.fragments = cutFragments(this.fragments, from, to);\n        this.skipped.splice(i--, 1);\n      }\n    }\n    if (this.skipped.length >= startLen) return false;\n    this.reset();\n    return true;\n  }\n  /**\n  @internal\n  */\n  reset() {\n    if (this.parse) {\n      this.takeTree();\n      this.parse = null;\n    }\n  }\n  /**\n  Notify the parse scheduler that the given region was skipped\n  because it wasn't in view, and the parse should be restarted\n  when it comes into view.\n  */\n  skipUntilInView(from, to) {\n    this.skipped.push({\n      from,\n      to\n    });\n  }\n  /**\n  Returns a parser intended to be used as placeholder when\n  asynchronously loading a nested parser. It'll skip its input and\n  mark it as not-really-parsed, so that the next update will parse\n  it again.\n  \n  When `until` is given, a reparse will be scheduled when that\n  promise resolves.\n  */\n  static getSkippingParser(until) {\n    return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        let from = ranges[0].from,\n          to = ranges[ranges.length - 1].to;\n        let parser = {\n          parsedPos: from,\n          advance() {\n            let cx = currentContext;\n            if (cx) {\n              for (let r of ranges) cx.tempSkipped.push(r);\n              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n            }\n            this.parsedPos = to;\n            return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n          },\n          stoppedAt: null,\n          stopAt() {}\n        };\n        return parser;\n      }\n    }();\n  }\n  /**\n  @internal\n  */\n  isDone(upto) {\n    upto = Math.min(upto, this.state.doc.length);\n    let frags = this.fragments;\n    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n  }\n  /**\n  Get the context for the current parse, or `null` if no editor\n  parse is in progress.\n  */\n  static get() {\n    return currentContext;\n  }\n}\nfunction cutFragments(fragments, from, to) {\n  return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{\n    fromA: from,\n    toA: to,\n    fromB: from,\n    toB: to\n  }]);\n}\nclass LanguageState {\n  constructor(\n  // A mutable parse state that is used to preserve work done during\n  // the lifetime of a state when moving to the next state.\n  context) {\n    this.context = context;\n    this.tree = context.tree;\n  }\n  apply(tr) {\n    if (!tr.docChanged && this.tree == this.context.tree) return this;\n    let newCx = this.context.changes(tr.changes, tr.state);\n    // If the previous parse wasn't done, go forward only up to its\n    // end position or the end of the viewport, to avoid slowing down\n    // state updates with parse work beyond the viewport.\n    let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n    if (!newCx.work(20 /* Work.Apply */, upto)) newCx.takeTree();\n    return new LanguageState(newCx);\n  }\n  static init(state) {\n    let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);\n    let parseState = ParseContext.create(state.facet(language).parser, state, {\n      from: 0,\n      to: vpTo\n    });\n    if (!parseState.work(20 /* Work.Apply */, vpTo)) parseState.takeTree();\n    return new LanguageState(parseState);\n  }\n}\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create: LanguageState.init,\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(Language.setState)) return e.value;\n    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n    return value.apply(tr);\n  }\n});\nlet requestIdle = callback => {\n  let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);\n  return () => clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = callback => {\n  let idle = -1,\n    timeout = setTimeout(() => {\n      idle = requestIdleCallback(callback, {\n        timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */\n      });\n    }, 100 /* Work.MinPause */);\n  return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n  constructor(view) {\n    this.view = view;\n    this.working = null;\n    this.workScheduled = 0;\n    // End of the current time chunk\n    this.chunkEnd = -1;\n    // Milliseconds of budget left for this chunk\n    this.chunkBudget = -1;\n    this.work = this.work.bind(this);\n    this.scheduleWork();\n  }\n  update(update) {\n    let cx = this.view.state.field(Language.state).context;\n    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n    if (update.docChanged || update.selectionSet) {\n      if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */;\n      this.scheduleWork();\n    }\n    this.checkAsyncSchedule(cx);\n  }\n  scheduleWork() {\n    if (this.working) return;\n    let {\n        state\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n  }\n  work(deadline) {\n    this.working = null;\n    let now = Date.now();\n    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n      // Start a new chunk\n      this.chunkEnd = now + 30000 /* Work.ChunkTime */;\n      this.chunkBudget = 3000 /* Work.ChunkBudget */;\n    }\n    if (this.chunkBudget <= 0) return; // No more budget\n    let {\n        state,\n        viewport: {\n          to: vpTo\n        }\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */)) return;\n    let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);\n    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n    let done = field.context.work(() => {\n      return isInputPending && isInputPending() || Date.now() > endTime;\n    }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));\n    this.chunkBudget -= Date.now() - now;\n    if (done || this.chunkBudget <= 0) {\n      field.context.takeTree();\n      this.view.dispatch({\n        effects: Language.setState.of(new LanguageState(field.context))\n      });\n    }\n    if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n    this.checkAsyncSchedule(field.context);\n  }\n  checkAsyncSchedule(cx) {\n    if (cx.scheduleOn) {\n      this.workScheduled++;\n      cx.scheduleOn.then(() => this.scheduleWork()).catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(() => this.workScheduled--);\n      cx.scheduleOn = null;\n    }\n  }\n  destroy() {\n    if (this.working) this.working();\n  }\n  isWorking() {\n    return !!(this.working || this.workScheduled > 0);\n  }\n}, {\n  eventHandlers: {\n    focus() {\n      this.scheduleWork();\n    }\n  }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(languages) {\n    return languages.length ? languages[0] : null;\n  },\n  enables: language => [Language.state, parseWorker, _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {\n    let lang = state.facet(language);\n    return lang && lang.name ? {\n      \"data-language\": lang.name\n    } : {};\n  })]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\nclass LanguageSupport {\n  /**\n  Create a language support object.\n  */\n  constructor(\n  /**\n  The language object.\n  */\n  language,\n  /**\n  An optional set of supporting extensions. When nesting a\n  language in another language, the outer language is encouraged\n  to include the supporting extensions for its inner languages\n  in its own set of support extensions.\n  */\n  support = []) {\n    this.language = language;\n    this.support = support;\n    this.extension = [language, support];\n  }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\nclass LanguageDescription {\n  constructor(\n  /**\n  The name of this language.\n  */\n  name,\n  /**\n  Alternative names for the mode (lowercased, includes `this.name`).\n  */\n  alias,\n  /**\n  File extensions associated with this language.\n  */\n  extensions,\n  /**\n  Optional filename pattern that should be associated with this\n  language.\n  */\n  filename, loadFunc,\n  /**\n  If the language has been loaded, this will hold its value.\n  */\n  support = undefined) {\n    this.name = name;\n    this.alias = alias;\n    this.extensions = extensions;\n    this.filename = filename;\n    this.loadFunc = loadFunc;\n    this.support = support;\n    this.loading = null;\n  }\n  /**\n  Start loading the the language. Will return a promise that\n  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n  object when the language successfully loads.\n  */\n  load() {\n    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {\n      this.loading = null;\n      throw err;\n    }));\n  }\n  /**\n  Create a language description.\n  */\n  static of(spec) {\n    let {\n      load,\n      support\n    } = spec;\n    if (!load) {\n      if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n      load = () => Promise.resolve(support);\n    }\n    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n  }\n  /**\n  Look for a language in the given array of descriptions that\n  matches the filename. Will first match\n  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n  and return the first language that matches.\n  */\n  static matchFilename(descs, filename) {\n    for (let d of descs) if (d.filename && d.filename.test(filename)) return d;\n    let ext = /\\.([^.]+)$/.exec(filename);\n    if (ext) for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d;\n    return null;\n  }\n  /**\n  Look for a language whose name or alias matches the the given\n  name (case-insensitively). If `fuzzy` is true, and no direct\n  matchs is found, this'll also search for a language whose name\n  or alias occurs in the string (for names shorter than three\n  characters, only when surrounded by non-word characters).\n  */\n  static matchLanguageName(descs, name, fuzzy = true) {\n    name = name.toLowerCase();\n    for (let d of descs) if (d.alias.some(a => a == name)) return d;\n    if (fuzzy) for (let d of descs) for (let a of d.alias) {\n      let found = name.indexOf(a);\n      if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n    }\n    return null;\n  }\n}\n\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine: values => {\n    if (!values.length) return \"  \";\n    let unit = values[0];\n    if (!unit || /\\S/.test(unit) || Array.from(unit).some(e => e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n    return unit;\n  }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\nfunction getIndentUnit(state) {\n  let unit = state.facet(indentUnit);\n  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\nfunction indentString(state, cols) {\n  let result = \"\",\n    ts = state.tabSize,\n    ch = state.facet(indentUnit)[0];\n  if (ch == \"\\t\") {\n    while (cols >= ts) {\n      result += \"\\t\";\n      cols -= ts;\n    }\n    ch = \" \";\n  }\n  for (let i = 0; i < cols; i++) result += ch;\n  return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/\nfunction getIndentation(context, pos) {\n  if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n  for (let service of context.state.facet(indentService)) {\n    let result = service(context, pos);\n    if (result !== undefined) return result;\n  }\n  let tree = syntaxTree(context.state);\n  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/\nfunction indentRange(state, from, to) {\n  let updated = Object.create(null);\n  let context = new IndentContext(state, {\n    overrideIndentation: start => {\n      var _a;\n      return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n    }\n  });\n  let changes = [];\n  for (let pos = from; pos <= to;) {\n    let line = state.doc.lineAt(pos);\n    pos = line.to + 1;\n    let indent = getIndentation(context, line.from);\n    if (indent == null) continue;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = indentString(state, indent);\n    if (cur != norm) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  }\n  return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\nclass IndentContext {\n  /**\n  Create an indent context.\n  */\n  constructor(\n  /**\n  The editor state.\n  */\n  state,\n  /**\n  @internal\n  */\n  options = {}) {\n    this.state = state;\n    this.options = options;\n    this.unit = getIndentUnit(state);\n  }\n  /**\n  Get a description of the line at the given position, taking\n  [simulated line\n  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  into account. If there is such a break at `pos`, the `bias`\n  argument determines whether the part of the line line before or\n  after the break is used.\n  */\n  lineAt(pos, bias = 1) {\n    let line = this.state.doc.lineAt(pos);\n    let {\n      simulateBreak,\n      simulateDoubleBreak\n    } = this.options;\n    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n      if (simulateDoubleBreak && simulateBreak == pos) return {\n        text: \"\",\n        from: pos\n      };else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n        text: line.text.slice(simulateBreak - line.from),\n        from: simulateBreak\n      };else return {\n        text: line.text.slice(0, simulateBreak - line.from),\n        from: line.from\n      };\n    }\n    return line;\n  }\n  /**\n  Get the text directly after `pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  textAfterPos(pos, bias = 1) {\n    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n  }\n  /**\n  Find the column for the given position.\n  */\n  column(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let result = this.countColumn(text, pos - from);\n    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n    if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n    return result;\n  }\n  /**\n  Find the column position (taking tabs into account) of the given\n  position in the given string.\n  */\n  countColumn(line, pos = line.length) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n  }\n  /**\n  Find the indentation column of the line at the given point.\n  */\n  lineIndent(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let override = this.options.overrideIndentation;\n    if (override) {\n      let overriden = override(from);\n      if (overriden > -1) return overriden;\n    }\n    return this.countColumn(text, text.search(/\\S|$/));\n  }\n  /**\n  Returns the [simulated line\n  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  for this context, if any.\n  */\n  get simulatedBreak() {\n    return this.options.simulateBreak || null;\n  }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n  let stack = ast.resolveStack(pos);\n  let inner = stack.node.enterUnfinishedNodesBefore(pos);\n  if (inner != stack.node) {\n    let add = [];\n    for (let cur = inner; cur != stack.node; cur = cur.parent) add.push(cur);\n    for (let i = add.length - 1; i >= 0; i--) stack = {\n      node: add[i],\n      next: stack\n    };\n  }\n  return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n  for (let cur = stack; cur; cur = cur.next) {\n    let strategy = indentStrategy(cur.node);\n    if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n  }\n  return 0;\n}\nfunction ignoreClosed(cx) {\n  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n  let strategy = tree.type.prop(indentNodeProp);\n  if (strategy) return strategy;\n  let first = tree.firstChild,\n    close;\n  if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n    let last = tree.lastChild,\n      closed = last && close.indexOf(last.name) > -1;\n    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n  }\n  return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n  return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/\nclass TreeIndentContext extends IndentContext {\n  constructor(base,\n  /**\n  The position at which indentation is being computed.\n  */\n  pos,\n  /**\n  @internal\n  */\n  context) {\n    super(base.state, base.options);\n    this.base = base;\n    this.pos = pos;\n    this.context = context;\n  }\n  /**\n  The syntax tree node to which the indentation strategy\n  applies.\n  */\n  get node() {\n    return this.context.node;\n  }\n  /**\n  @internal\n  */\n  static create(base, pos, context) {\n    return new TreeIndentContext(base, pos, context);\n  }\n  /**\n  Get the text directly after `this.pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  get textAfter() {\n    return this.textAfterPos(this.pos);\n  }\n  /**\n  Get the indentation at the reference line for `this.node`, which\n  is the line on which it starts, unless there is a node that is\n  _not_ a parent of this node covering the start of that line. If\n  so, the line at the start of that node is tried, again skipping\n  on if it is covered by another such node.\n  */\n  get baseIndent() {\n    return this.baseIndentFor(this.node);\n  }\n  /**\n  Get the indentation for the reference line of the given node\n  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n  */\n  baseIndentFor(node) {\n    let line = this.state.doc.lineAt(node.from);\n    // Skip line starts that are covered by a sibling (or cousin, etc)\n    for (;;) {\n      let atBreak = node.resolve(line.from);\n      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;\n      if (isParent(atBreak, node)) break;\n      line = this.state.doc.lineAt(atBreak.from);\n    }\n    return this.lineIndent(line.from);\n  }\n  /**\n  Continue looking for indentations in the node's parent nodes,\n  and return the result of that.\n  */\n  continue() {\n    return indentFor(this.context.next, this.base, this.pos);\n  }\n}\nfunction isParent(parent, of) {\n  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;\n  return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n  let tree = context.node;\n  let openToken = tree.childAfter(tree.from),\n    last = tree.lastChild;\n  if (!openToken) return null;\n  let sim = context.options.simulateBreak;\n  let openLine = context.state.doc.lineAt(openToken.from);\n  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n  for (let pos = openToken.to;;) {\n    let next = tree.childAfter(pos);\n    if (!next || next == last) return null;\n    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n    pos = next.to;\n  }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\nfunction delimitedIndent({\n  closing,\n  align = true,\n  units = 1\n}) {\n  return context => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n  let after = context.textAfter,\n    space = after.match(/^\\s*/)[0].length;\n  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n  let aligned = align ? bracketedAligned(context) : null;\n  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n  return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\nconst flatIndent = context => context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\nfunction continuedIndent({\n  except,\n  units = 1\n} = {}) {\n  return context => {\n    let matchExcept = except && except.test(context.textAfter);\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n  };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\nfunction indentOnInput() {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {\n    if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n    let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n    if (!rules.length) return tr;\n    let doc = tr.newDoc,\n      {\n        head\n      } = tr.newSelection.main,\n      line = doc.lineAt(head);\n    if (head > line.from + DontIndentBeyond) return tr;\n    let lineStart = doc.sliceString(line.from, head);\n    if (!rules.some(r => r.test(lineStart))) return tr;\n    let {\n        state\n      } = tr,\n      last = -1,\n      changes = [];\n    for (let {\n      head\n    } of state.selection.ranges) {\n      let line = state.doc.lineAt(head);\n      if (line.from == last) continue;\n      last = line.from;\n      let indent = getIndentation(state, line.from);\n      if (indent == null) continue;\n      let cur = /^\\s*/.exec(line.text)[0];\n      let norm = indentString(state, indent);\n      if (cur != norm) changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n    return changes.length ? [tr, {\n      changes,\n      sequential: true\n    }] : tr;\n  });\n}\n\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\nfunction foldInside(node) {\n  let first = node.firstChild,\n    last = node.lastChild;\n  return first && first.to < last.from ? {\n    from: first.to,\n    to: last.type.isError ? node.to : last.from\n  } : null;\n}\nfunction syntaxFolding(state, start, end) {\n  let tree = syntaxTree(state);\n  if (tree.length < end) return null;\n  let stack = tree.resolveStack(end, 1);\n  let found = null;\n  for (let iter = stack; iter; iter = iter.next) {\n    let cur = iter.node;\n    if (cur.to <= end || cur.from > end) continue;\n    if (found && cur.from < start) break;\n    let prop = cur.type.prop(foldNodeProp);\n    if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n      let value = prop(cur, state);\n      if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n    }\n  }\n  return found;\n}\nfunction isUnfinished(node) {\n  let ch = node.lastChild;\n  return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\nfunction foldable(state, lineStart, lineEnd) {\n  for (let service of state.facet(foldService)) {\n    let result = service(state, lineStart, lineEnd);\n    if (result) return result;\n  }\n  return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1),\n    to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\nfunction selectedLines(view) {\n  let lines = [];\n  for (let {\n    head\n  } of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.lineBlockAt(head));\n  }\n  return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n        let {\n          preparePlaceholder\n        } = tr.state.facet(foldConfig);\n        let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n          widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n        });\n        folded = folded.update({\n          add: [widget.range(e.value.from, e.value.to)]\n        });\n      } else if (e.is(unfoldEffect)) {\n        folded = folded.update({\n          filter: (from, to) => e.value.from != from || e.value.to != to,\n          filterFrom: e.value.from,\n          filterTo: e.value.to\n        });\n      }\n    }\n    // Clear folded ranges that cover the selection head\n    if (tr.selection) {\n      let onSelection = false,\n        {\n          head\n        } = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n    return folded;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n  toJSON(folded, state) {\n    let ranges = [];\n    folded.between(0, state.doc.length, (from, to) => {\n      ranges.push(from, to);\n    });\n    return ranges;\n  },\n  fromJSON(value) {\n    if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n    let ranges = [];\n    for (let i = 0; i < value.length;) {\n      let from = value[i++],\n        to = value[i++];\n      if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n      ranges.push(foldWidget.range(from, to));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n  }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n  return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n  var _a;\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = foldable(view.state, line.from, line.to);\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n  return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n  let lineFrom = view.state.doc.lineAt(range.from).number,\n    lineTo = view.state.doc.lineAt(range.to).number;\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/\nconst foldAll = view => {\n  let {\n      state\n    } = view,\n    effects = [];\n  for (let pos = 0; pos < state.doc.length;) {\n    let line = view.lineBlockAt(pos),\n      range = foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n  }\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n  // Look backwards through line blocks until we find a foldable region that\n  // intersects with the line\n  for (let line = lineBlock;;) {\n    let foldableRegion = foldable(view.state, line.from, line.to);\n    if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n    if (!line.from) return null;\n    line = view.lineBlockAt(line.from - 1);\n  }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/\nconst toggleFold = view => {\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) {\n      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    } else {\n      let foldRange = foldableContainer(view, line);\n      if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n    }\n  }\n  if (effects.length > 0) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  preparePlaceholder: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n  }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme$1];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\nfunction widgetToDOM(view, prepared) {\n  let {\n      state\n    } = view,\n    conf = state.facet(foldConfig);\n  let onclick = event => {\n    let line = view.lineBlockAt(view.posAtDOM(event.target));\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) view.dispatch({\n      effects: unfoldEffect.of(folded)\n    });\n    event.preventDefault();\n  };\n  if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n  let element = document.createElement(\"span\");\n  element.textContent = conf.placeholderText;\n  element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n  element.title = state.phrase(\"unfold\");\n  element.className = \"cm-foldPlaceholder\";\n  element.onclick = onclick;\n  return element;\n}\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n  widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    toDOM(view) {\n      return widgetToDOM(view, null);\n    }\n  }()\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  eq(other) {\n    return this.value == other.value;\n  }\n  toDOM(view) {\n    return widgetToDOM(view, this.value);\n  }\n}\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\",\n  markerDOM: null,\n  domEventHandlers: {},\n  foldingChanged: () => false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n  toDOM(view) {\n    if (this.config.markerDOM) return this.config.markerDOM(this.open);\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true),\n    canUnfold = new FoldMarker(fullConfig, false);\n  let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = this.buildMarkers(view);\n    }\n    update(update) {\n      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n    }\n    buildMarkers(view) {\n      let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n      for (let line of view.viewportLineBlocks) {\n        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n        if (mark) builder.add(line.from, line.from, mark);\n      }\n      return builder.finish();\n    }\n  });\n  let {\n    domEventHandlers\n  } = fullConfig;\n  return [markers, (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n    class: \"cm-foldGutter\",\n    markers(view) {\n      var _a;\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n    },\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n    domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n      click: (view, line, event) => {\n        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n        return false;\n      }\n    })\n  }), codeFolding()];\n}\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter span\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\n\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/\nclass HighlightStyle {\n  constructor(\n  /**\n  The tag styles used to create this highlight style.\n  */\n  specs, options) {\n    this.specs = specs;\n    let modSpec;\n    function def(spec) {\n      let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n    const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n    const scopeOpt = options.scope;\n    this.scope = scopeOpt instanceof Language ? type => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? type => type == scopeOpt : undefined;\n    this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({\n      tag: style.tag,\n      class: style.class || def(Object.assign({}, style, {\n        tag: null\n      }))\n    })), {\n      all\n    }).style;\n    this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n    this.themeType = options.themeType;\n  }\n  /**\n  Create a highlighter style that associates the given styles to\n  the given tags. The specs must be objects that hold a style tag\n  or array of tags in their `tag` property, and either a single\n  `class` property providing a static CSS class (for highlighter\n  that rely on external styling), or a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  set of CSS properties (which define the styling for those tags).\n  \n  The CSS rules created for a highlighter will be emitted in the\n  order of the spec's properties. That means that for elements that\n  have multiple tags associated with them, styles defined further\n  down in the list will have a higher CSS precedence than styles\n  defined earlier.\n  */\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || {});\n  }\n}\nconst highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return values.length ? [values[0]] : null;\n  }\n});\nfunction getHighlighters(state) {\n  let main = state.facet(highlighterFacet);\n  return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/\nfunction syntaxHighlighting(highlighter, options) {\n  let ext = [treeHighlighter],\n    themeType;\n  if (highlighter instanceof HighlightStyle) {\n    if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n    themeType = highlighter.themeType;\n  }\n  if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));else if (themeType) ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {\n    return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [highlighter] : [];\n  }));else ext.push(highlighterFacet.of(highlighter));\n  return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/\nfunction highlightingFor(state, tags, scope) {\n  let highlighters = getHighlighters(state);\n  let result = null;\n  if (highlighters) for (let highlighter of highlighters) {\n    if (!highlighter.scope || scope && highlighter.scope(scope)) {\n      let cls = highlighter.style(tags);\n      if (cls) result = result ? result + \" \" + cls : cls;\n    }\n  }\n  return result;\n}\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlighters(view.state));\n  }\n  update(update) {\n    let tree = syntaxTree(update.state),\n      highlighters = getHighlighters(update.state);\n    let styleChange = highlighters != getHighlighters(update.startState);\n    if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {\n      this.decorations = this.decorations.map(update.changes);\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, highlighters);\n    }\n  }\n  buildDeco(view, highlighters) {\n    if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    for (let {\n      from,\n      to\n    } of view.visibleRanges) {\n      (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n          class: style\n        })));\n      }, from, to);\n    }\n    return builder.finish();\n  }\n}\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n  color: \"#404740\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n  textDecoration: \"line-through\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],\n  color: \"#e40\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],\n  color: \"#085\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  color: \"#167\"\n}, {\n  tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],\n  color: \"#256\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n  color: \"#940\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n  color: \"#f00\"\n}]);\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \"&.cm-focused .cm-matchingBracket\": {\n    backgroundColor: \"#328c8252\"\n  },\n  \"&.cm-focused .cm-nonmatchingBracket\": {\n    backgroundColor: \"#bb555544\"\n  }\n});\nconst DefaultScanDist = 10000,\n  DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist,\n      renderMatch: defaultRenderMatch\n    });\n  }\n});\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n  }),\n  nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n  });\nfunction defaultRenderMatch(match) {\n  let decorations = [];\n  let mark = match.matched ? matchingMark : nonmatchingMark;\n  decorations.push(mark.range(match.start.from, match.start.to));\n  if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n  return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/\nconst bracketMatchingHandle = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n  if (byProp) return byProp;\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n  return null;\n}\nfunction findHandle(node) {\n  let hasHandle = node.type.prop(bracketMatchingHandle);\n  return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist,\n    brackets = config.brackets || DefaultBrackets;\n  let tree = syntaxTree(state),\n    node = tree.resolveInner(pos, dir);\n  for (let cur = node; cur; cur = cur.parent) {\n    let matches = matchingNodes(cur.type, dir, brackets);\n    if (matches && cur.from < cur.to) {\n      let handle = findHandle(cur);\n      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n    }\n  }\n  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n  let parent = token.parent,\n    firstToken = {\n      from: handle.from,\n      to: handle.to\n    };\n  let depth = 0,\n    cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n        let endHandle = findHandle(cursor);\n        return {\n          start: firstToken,\n          end: endHandle ? {\n            from: endHandle.from,\n            to: endHandle.to\n          } : undefined,\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        if (depth == 0) {\n          let endHandle = findHandle(cursor);\n          return {\n            start: firstToken,\n            end: endHandle && endHandle.from < endHandle.to ? {\n              from: endHandle.from,\n              to: endHandle.to\n            } : undefined,\n            matched: false\n          };\n        }\n        depth--;\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n    depth = 0;\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n    if (dir > 0) distance += text.length;\n  }\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  let n = startValue;\n  for (let i = startIndex; i < end; i++) {\n    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;\n  }\n  return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n  /**\n  Create a stream.\n  */\n  constructor(\n  /**\n  The line.\n  */\n  string, tabSize,\n  /**\n  The current indent unit size.\n  */\n  indentUnit, overrideIndent) {\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    this.overrideIndent = overrideIndent;\n    /**\n    The current position on the line.\n    */\n    this.pos = 0;\n    /**\n    The start position of the current token.\n    */\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  /**\n  True if we are at the end of the line.\n  */\n  eol() {\n    return this.pos >= this.string.length;\n  }\n  /**\n  True if we are at the start of the line.\n  */\n  sol() {\n    return this.pos == 0;\n  }\n  /**\n  Get the next code unit after the current position, or undefined\n  if we're at the end of the line.\n  */\n  peek() {\n    return this.string.charAt(this.pos) || undefined;\n  }\n  /**\n  Read the next code unit and advance `this.pos`.\n  */\n  next() {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  }\n  /**\n  Match the next character against the given string, regular\n  expression, or predicate. Consume and return it if it matches.\n  */\n  eat(match) {\n    let ch = this.string.charAt(this.pos);\n    let ok;\n    if (typeof match == \"string\") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  }\n  /**\n  Continue matching characters that match the given string,\n  regular expression, or predicate function. Return true if any\n  characters were consumed.\n  */\n  eatWhile(match) {\n    let start = this.pos;\n    while (this.eat(match)) {}\n    return this.pos > start;\n  }\n  /**\n  Consume whitespace ahead of `this.pos`. Return true if any was\n  found.\n  */\n  eatSpace() {\n    let start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  }\n  /**\n  Move to the end of the line.\n  */\n  skipToEnd() {\n    this.pos = this.string.length;\n  }\n  /**\n  Move to directly before the given character, if found on the\n  current line.\n  */\n  skipTo(ch) {\n    let found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  }\n  /**\n  Move back `n` characters.\n  */\n  backUp(n) {\n    this.pos -= n;\n  }\n  /**\n  Get the column position at `this.pos`.\n  */\n  column() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue;\n  }\n  /**\n  Get the indentation column of the current line.\n  */\n  indentation() {\n    var _a;\n    return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n  }\n  /**\n  Match the input against the given string or regular expression\n  (which should start with a `^`). Return true or the regexp match\n  if it matches.\n  \n  Unless `consume` is set to `false`, this will move `this.pos`\n  past the matched text.\n  \n  When matching a string `caseInsensitive` can be set to true to\n  make the match case-insensitive.\n  */\n  match(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      let cased = str => caseInsensitive ? str.toLowerCase() : str;\n      let substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      } else return null;\n    } else {\n      let match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  }\n  /**\n  Get the current token.\n  */\n  current() {\n    return this.string.slice(this.start, this.pos);\n  }\n}\nfunction fullParser(spec) {\n  return {\n    name: spec.name || \"\",\n    token: spec.token,\n    blankLine: spec.blankLine || (() => {}),\n    startState: spec.startState || (() => true),\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || (() => null),\n    languageData: spec.languageData || {},\n    tokenTable: spec.tokenTable || noTokens\n  };\n}\nfunction defaultCopyState(state) {\n  if (typeof state != \"object\") return state;\n  let newState = {};\n  for (let prop in state) {\n    let val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n  return newState;\n}\nconst IndentedFrom = /*@__PURE__*/new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/\nclass StreamLanguage extends Language {\n  constructor(parser) {\n    let data = defineLanguageFacet(parser.languageData);\n    let p = fullParser(parser),\n      self;\n    let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        return new Parse(self, input, fragments, ranges);\n      }\n    }();\n    super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);\n    this.topNode = docID(data);\n    self = this;\n    this.streamParser = p;\n    this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n      perNode: true\n    });\n    this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n  }\n  /**\n  Define a stream language.\n  */\n  static define(spec) {\n    return new StreamLanguage(spec);\n  }\n  getIndent(cx, pos) {\n    let tree = syntaxTree(cx.state),\n      at = tree.resolve(pos);\n    while (at && at.type != this.topNode) at = at.parent;\n    if (!at) return null;\n    let from = undefined;\n    let {\n      overrideIndentation\n    } = cx.options;\n    if (overrideIndentation) {\n      from = IndentedFrom.get(cx.state);\n      if (from != null && from < pos - 1e4) from = undefined;\n    }\n    let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos),\n      statePos,\n      state;\n    if (start) {\n      state = start.state;\n      statePos = start.pos + 1;\n    } else {\n      state = this.streamParser.startState(cx.unit);\n      statePos = 0;\n    }\n    if (pos - statePos > 10000 /* C.MaxIndentScanDist */) return null;\n    while (statePos < pos) {\n      let line = cx.state.doc.lineAt(statePos),\n        end = Math.min(pos, line.to);\n      if (line.length) {\n        let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n        let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n        while (stream.pos < end - line.from) readToken(this.streamParser.token, stream, state);\n      } else {\n        this.streamParser.blankLine(state, cx.unit);\n      }\n      if (end == pos) break;\n      statePos = line.to + 1;\n    }\n    let line = cx.lineAt(pos);\n    if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n    return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n  }\n  get allowsNesting() {\n    return false;\n  }\n}\nfunction findState(lang, tree, off, startPos, before) {\n  let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let child = tree.children[i],\n      pos = off + tree.positions[i];\n    let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n  return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let pos = tree.positions[i],\n      child = tree.children[i],\n      inner;\n    if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n  return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n  for (let f of fragments) {\n    let from = f.from + (f.openStart ? 25 : 0),\n      to = f.to - (f.openEnd ? 25 : 0);\n    let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),\n      tree;\n    if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n      state: found.state,\n      tree\n    };\n  }\n  return {\n    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n    tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n  };\n}\nclass Parse {\n  constructor(lang, input, fragments, ranges) {\n    this.lang = lang;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.stoppedAt = null;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.rangeIndex = 0;\n    this.to = ranges[ranges.length - 1].to;\n    let context = ParseContext.get(),\n      from = ranges[0].from;\n    let {\n      state,\n      tree\n    } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n    this.state = state;\n    this.parsedPos = this.chunkStart = from + tree.length;\n    for (let i = 0; i < tree.children.length; i++) {\n      this.chunks.push(tree.children[i]);\n      this.chunkPos.push(tree.positions[i]);\n    }\n    if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */) {\n      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n      context.skipUntilInView(this.parsedPos, context.viewport.from);\n      this.parsedPos = context.viewport.from;\n    }\n    this.moveRangeIndex();\n  }\n  advance() {\n    let context = ParseContext.get();\n    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n    let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);\n    if (context) end = Math.min(end, context.viewport.to);\n    while (this.parsedPos < end) this.parseLine(context);\n    if (this.chunkStart < this.parsedPos) this.finishChunk();\n    if (this.parsedPos >= parseEnd) return this.finish();\n    if (context && this.parsedPos >= context.viewport.to) {\n      context.skipUntilInView(this.parsedPos, parseEnd);\n      return this.finish();\n    }\n    return null;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n  }\n  lineAfter(pos) {\n    let chunk = this.input.chunk(pos);\n    if (!this.input.lineChunks) {\n      let eol = chunk.indexOf(\"\\n\");\n      if (eol > -1) chunk = chunk.slice(0, eol);\n    } else if (chunk == \"\\n\") {\n      chunk = \"\";\n    }\n    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n  }\n  nextLine() {\n    let from = this.parsedPos,\n      line = this.lineAfter(from),\n      end = from + line.length;\n    for (let index = this.rangeIndex;;) {\n      let rangeEnd = this.ranges[index].to;\n      if (rangeEnd >= end) break;\n      line = line.slice(0, rangeEnd - (end - line.length));\n      index++;\n      if (index == this.ranges.length) break;\n      let rangeStart = this.ranges[index].from;\n      let after = this.lineAfter(rangeStart);\n      line += after;\n      end = rangeStart + after.length;\n    }\n    return {\n      line,\n      end\n    };\n  }\n  skipGapsTo(pos, offset, side) {\n    for (;;) {\n      let end = this.ranges[this.rangeIndex].to,\n        offPos = pos + offset;\n      if (side > 0 ? end > offPos : end >= offPos) break;\n      let start = this.ranges[++this.rangeIndex].from;\n      offset += start - end;\n    }\n    return offset;\n  }\n  moveRangeIndex() {\n    while (this.ranges[this.rangeIndex].to < this.parsedPos) this.rangeIndex++;\n  }\n  emitToken(id, from, to, size, offset) {\n    if (this.ranges.length > 1) {\n      offset = this.skipGapsTo(from, offset, 1);\n      from += offset;\n      let len0 = this.chunk.length;\n      offset = this.skipGapsTo(to, offset, -1);\n      to += offset;\n      size += this.chunk.length - len0;\n    }\n    this.chunk.push(id, from, to, size);\n    return offset;\n  }\n  parseLine(context) {\n    let {\n        line,\n        end\n      } = this.nextLine(),\n      offset = 0,\n      {\n        streamParser\n      } = this.lang;\n    let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n    if (stream.eol()) {\n      streamParser.blankLine(this.state, stream.indentUnit);\n    } else {\n      while (!stream.eol()) {\n        let token = readToken(streamParser.token, stream, this.state);\n        if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n        if (stream.start > 10000 /* C.MaxLineLength */) break;\n      }\n    }\n    this.parsedPos = end;\n    this.moveRangeIndex();\n    if (this.parsedPos < this.to) this.parsedPos++;\n  }\n  finishChunk() {\n    let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n      buffer: this.chunk,\n      start: this.chunkStart,\n      length: this.parsedPos - this.chunkStart,\n      nodeSet,\n      topID: 0,\n      maxBufferLength: 2048 /* C.ChunkSize */,\n      reused: this.chunkReused\n    });\n    tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n    this.chunks.push(tree);\n    this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.chunkStart = this.parsedPos;\n  }\n  finish() {\n    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n  }\n}\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n  for (let i = 0; i < 10; i++) {\n    let result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nconst nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/Object.create(null);\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"tagName\"], [\"attribute\", \"attributeName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]) defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n  constructor(extra) {\n    this.extra = extra;\n    this.table = Object.assign(Object.create(null), defaultTable);\n  }\n  resolve(tag) {\n    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n  }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n  let tags$1 = [];\n  for (let name of tagStr.split(\" \")) {\n    let found = [];\n    for (let part of name.split(\".\")) {\n      let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n      if (!value) {\n        warnForPart(part, `Unknown highlighting tag ${part}`);\n      } else if (typeof value == \"function\") {\n        if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);else found = found.map(value);\n      } else {\n        if (found.length) warnForPart(part, `Tag ${part} used as modifier`);else found = Array.isArray(value) ? value : [value];\n      }\n    }\n    for (let tag of found) tags$1.push(tag);\n  }\n  if (!tags$1.length) return 0;\n  let name = tagStr.replace(/ /g, \"_\"),\n    key = name + \" \" + tags$1.map(t => t.id);\n  let known = byTag[key];\n  if (known) return known.id;\n  let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name,\n    props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n      [name]: tags$1\n    })]\n  });\n  typeArray.push(type);\n  return type.id;\n}\nfunction docID(data) {\n  let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [languageDataProp.add(() => data)],\n    top: true\n  });\n  typeArray.push(type);\n  return type;\n}\nfunction buildForLine(line) {\n  return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n  for (let i = text.iter(); !i.next().done;) if (buildForLine(i.value)) return true;\n  return false;\n}\nfunction changeAddsRTL(change) {\n  let added = false;\n  change.iterChanges((fA, tA, fB, tB, ins) => {\n    if (!added && textHasRTL(ins)) added = true;\n  });\n  return added;\n}\nconst alwaysIsolate = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/\nfunction bidiIsolates(options = {}) {\n  let extensions = [isolateMarks];\n  if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n  return extensions;\n}\nconst isolateMarks = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n    this.hasRTL = !this.always && textHasRTL(view.state.doc);\n    this.tree = syntaxTree(view.state);\n    this.decorations = buildDeco(view, this.tree, this.always);\n  }\n  update(update) {\n    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n    if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n    if (!always && !this.hasRTL) return;\n    let tree = syntaxTree(update.state);\n    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n      this.tree = tree;\n      this.always = always;\n      this.decorations = buildDeco(update.view, tree, always);\n    }\n  }\n}, {\n  provide: plugin => {\n    function access(view) {\n      var _a, _b;\n      return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    return [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))];\n  }\n});\nfunction buildDeco(view, tree, always) {\n  let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n  let ranges = view.visibleRanges;\n  if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n  for (let {\n    from,\n    to\n  } of ranges) {\n    tree.iterate({\n      enter: node => {\n        let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n        if (iso) deco.add(node.from, node.to, marks[iso]);\n      },\n      from,\n      to\n    });\n  }\n  return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n  let cur = doc.iter(),\n    pos = 0,\n    result = [],\n    last = null;\n  for (let {\n    from,\n    to\n  } of ranges) {\n    if (from != pos) {\n      if (pos < from) cur.next(from - pos);\n      pos = from;\n    }\n    for (;;) {\n      let start = pos,\n        end = pos + cur.value.length;\n      if (!cur.lineBreak && buildForLine(cur.value)) {\n        if (last && last.to > start - 10) last.to = Math.min(to, end);else result.push(last = {\n          from: start,\n          to: Math.min(to, end)\n        });\n      }\n      if (pos >= to) break;\n      pos = end;\n      cur.next();\n    }\n  }\n  return result;\n}\nconst marks = {\n  rtl: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"rtl\"\n    },\n    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n  }),\n  ltr: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"ltr\"\n    },\n    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n  }),\n  auto: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"auto\"\n    },\n    bidiIsolate: null\n  })\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanM/ZDczZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCwgSXRlck1vZGUsIFRyZWUsIFRyZWVGcmFnbWVudCwgUGFyc2VyLCBOb2RlVHlwZSwgTm9kZVNldCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBFZGl0b3JTdGF0ZSwgY291bnRDb2x1bW4sIGNvbWJpbmVDb25maWcsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBWaWV3UGx1Z2luLCBsb2dFeGNlcHRpb24sIEVkaXRvclZpZXcsIERlY29yYXRpb24sIFdpZGdldFR5cGUsIGd1dHRlciwgR3V0dGVyTWFya2VyLCBEaXJlY3Rpb24gfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcblxudmFyIF9hO1xuLyoqXG5Ob2RlIHByb3Agc3RvcmVkIGluIGEgcGFyc2VyJ3MgdG9wIHN5bnRheCBub2RlIHRvIHByb3ZpZGUgdGhlXG5mYWNldCB0aGF0IHN0b3JlcyBsYW5ndWFnZS1zcGVjaWZpYyBkYXRhIGZvciB0aGF0IGxhbmd1YWdlLlxuKi9cbmNvbnN0IGxhbmd1YWdlRGF0YVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0byBkZWZpbmUgYSBmYWNldCAodG8gYmUgYWRkZWQgdG8gdGhlIHRvcCBzeW50YXhcbm5vZGUocykgZm9yIGEgbGFuZ3VhZ2UgdmlhXG5bYGxhbmd1YWdlRGF0YVByb3BgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApKSwgdGhhdCB3aWxsIGJlXG51c2VkIHRvIGFzc29jaWF0ZSBsYW5ndWFnZSBkYXRhIHdpdGggdGhlIGxhbmd1YWdlLiBZb3VcbnByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIHdoZW4gc3ViY2xhc3NpbmdcbltgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKS5cbiovXG5mdW5jdGlvbiBkZWZpbmVMYW5ndWFnZUZhY2V0KGJhc2VEYXRhKSB7XG4gICAgcmV0dXJuIEZhY2V0LmRlZmluZSh7XG4gICAgICAgIGNvbWJpbmU6IGJhc2VEYXRhID8gdmFsdWVzID0+IHZhbHVlcy5jb25jYXQoYmFzZURhdGEpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG4vKipcblN5bnRheCBub2RlIHByb3AgdXNlZCB0byByZWdpc3RlciBzdWJsYW5ndWFnZXMuIFNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHRvcCBsZXZlbCBub2RlIHR5cGUgZm9yIHRoZSBsYW5ndWFnZS5cbiovXG5jb25zdCBzdWJsYW5ndWFnZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbkEgbGFuZ3VhZ2Ugb2JqZWN0IG1hbmFnZXMgcGFyc2luZyBhbmQgcGVyLWxhbmd1YWdlXG5bbWV0YWRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLiBQYXJzZSBkYXRhIGlzXG5tYW5hZ2VkIGFzIGEgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0KSB0cmVlLiBUaGUgY2xhc3NcbmNhbiBiZSB1c2VkIGRpcmVjdGx5LCB2aWEgdGhlIFtgTFJMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTFJMYW5ndWFnZSlcbnN1YmNsYXNzIGZvciBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvKSBMUiBwYXJzZXJzLCBvclxudmlhIHRoZSBbYFN0cmVhbUxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1MYW5ndWFnZSkgc3ViY2xhc3NcbmZvciBzdHJlYW0gcGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbGFuZ3VhZ2Ugb2JqZWN0LiBJZiB5b3UgbmVlZCB0byBpbnZva2UgdGhpc1xuICAgIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgICBbYGRlZmluZUxhbmd1YWdlRmFjZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmRlZmluZUxhbmd1YWdlRmFjZXQpLCBhbmQgdGhlblxuICAgIGNvbmZpZ3VyZSB5b3VyIHBhcnNlciB0byBbYXR0YWNoXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlRGF0YVByb3ApIGl0XG4gICAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgW2xhbmd1YWdlIGRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIGZhY2V0XG4gICAgdXNlZCBmb3IgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGRhdGEsIHBhcnNlciwgZXh0cmFFeHRlbnNpb25zID0gW10sIFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2UgbmFtZS5cbiAgICAqL1xuICAgIG5hbWUgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIEtsdWRnZSB0byBkZWZpbmUgRWRpdG9yU3RhdGUudHJlZSBhcyBhIGRlYnVnZ2luZyBoZWxwZXIsXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIEVkaXRvclN0YXRlIHBhY2thZ2UgYWN0dWFsbHkga25vd2luZyBhYm91dFxuICAgICAgICAvLyBsYW5ndWFnZXMgYW5kIGxlemVyIHRyZWVzLlxuICAgICAgICBpZiAoIUVkaXRvclN0YXRlLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcInRyZWVcIikpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWRpdG9yU3RhdGUucHJvdG90eXBlLCBcInRyZWVcIiwgeyBnZXQoKSB7IHJldHVybiBzeW50YXhUcmVlKHRoaXMpOyB9IH0pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbXG4gICAgICAgICAgICBsYW5ndWFnZS5vZih0aGlzKSxcbiAgICAgICAgICAgIEVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YS5vZigoc3RhdGUsIHBvcywgc2lkZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSksIGRhdGEgPSB0b3AudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gc3RhdGUuZmFjZXQoZGF0YSksIHN1YiA9IHRvcC50eXBlLnByb3Aoc3VibGFuZ3VhZ2VQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lck5vZGUgPSB0b3AucmVzb2x2ZShwb3MgLSB0b3AuZnJvbSwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHN1Ymxhbmcgb2Ygc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmxhbmcudGVzdChpbm5lck5vZGUsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gc3RhdGUuZmFjZXQoc3VibGFuZy5mYWNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmxhbmcudHlwZSA9PSBcInJlcGxhY2VcIiA/IGRhdGEgOiBkYXRhLmNvbmNhdChiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICBdLmNvbmNhdChleHRyYUV4dGVuc2lvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgaXMgYWN0aXZlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGlzQWN0aXZlQXQoc3RhdGUsIHBvcywgc2lkZSA9IC0xKSB7XG4gICAgICAgIHJldHVybiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkudHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcmVnaW9ucyB0aGF0IHdlcmUgcGFyc2VkIHVzaW5nIHRoaXMgbGFuZ3VhZ2UuXG4gICAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gICAgaW4gdGhpcyBsYW5ndWFnZSwgd2hlbiB0aG9zZSBleGlzdC5cbiAgICAqL1xuICAgIGZpbmRSZWdpb25zKHN0YXRlKSB7XG4gICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICBpZiAoKGxhbmcgPT09IG51bGwgfHwgbGFuZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFuZy5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IHN0YXRlLmRvYy5sZW5ndGggfV07XG4gICAgICAgIGlmICghbGFuZyB8fCAhbGFuZy5hbGxvd3NOZXN0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBleHBsb3JlID0gKHRyZWUsIGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICh0cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtb3VudCA9IHRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgIGlmIChtb3VudCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VudC50cmVlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtb3VudC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogci5mcm9tICsgZnJvbSwgdG86IHIudG8gKyBmcm9tIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUobW91bnQudHJlZSwgbW91bnQub3ZlcmxheVswXS5mcm9tICsgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvcmUoY2gsIHRyZWUucG9zaXRpb25zW2ldICsgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV4cGxvcmUoc3ludGF4VHJlZShzdGF0ZSksIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGxhbmd1YWdlIGFsbG93cyBuZXN0ZWQgbGFuZ3VhZ2VzLiBUaGVcbiAgICBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdHJ1ZS5cbiAgICAqL1xuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5MYW5ndWFnZS5zZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmZ1bmN0aW9uIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHRvcExhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSksIHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS50b3BOb2RlO1xuICAgIGlmICghdG9wTGFuZyB8fCB0b3BMYW5nLmFsbG93c05lc3RpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRyZWU7IG5vZGU7IG5vZGUgPSBub2RlLmVudGVyKHBvcywgc2lkZSwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICB0cmVlID0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG4vKipcbkEgc3ViY2xhc3Mgb2YgW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGZvciB1c2Ugd2l0aCBMZXplclxuW0xSIHBhcnNlcnNdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjbHIuTFJQYXJzZXIpXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExSTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgcGFyc2VyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKGRhdGEsIHBhcnNlciwgW10sIG5hbWUpO1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQoc3BlYy5sYW5ndWFnZURhdGEpO1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UoZGF0YSwgc3BlYy5wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQodHlwZSA9PiB0eXBlLmlzVG9wID8gZGF0YSA6IHVuZGVmaW5lZCldXG4gICAgICAgIH0pLCBzcGVjLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBsYW5ndWFnZSB3aXRoIGEgcmVjb25maWd1cmVkXG4gICAgdmVyc2lvbiBvZiBpdHMgcGFyc2VyIGFuZCBvcHRpb25hbGx5IGEgbmV3IG5hbWUuXG4gICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9ucywgbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IExSTGFuZ3VhZ2UodGhpcy5kYXRhLCB0aGlzLnBhcnNlci5jb25maWd1cmUob3B0aW9ucyksIG5hbWUgfHwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0aGlzLnBhcnNlci5oYXNXcmFwcGVycygpOyB9XG59XG4vKipcbkdldCB0aGUgc3ludGF4IHRyZWUgZm9yIGEgc3RhdGUsIHdoaWNoIGlzIHRoZSBjdXJyZW50IChwb3NzaWJseVxuaW5jb21wbGV0ZSkgcGFyc2UgdHJlZSBvZiB0aGUgYWN0aXZlXG5bbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLCBvciB0aGUgZW1wdHkgdHJlZSBpZiB0aGVyZSBpcyBub1xubGFuZ3VhZ2UgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWUoc3RhdGUpIHtcbiAgICBsZXQgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBmaWVsZCA/IGZpZWxkLnRyZWUgOiBUcmVlLmVtcHR5O1xufVxuLyoqXG5UcnkgdG8gZ2V0IGEgcGFyc2UgdHJlZSB0aGF0IHNwYW5zIGF0IGxlYXN0IHVwIHRvIGB1cHRvYC4gVGhlXG5tZXRob2Qgd2lsbCBkbyBhdCBtb3N0IGB0aW1lb3V0YCBtaWxsaXNlY29uZHMgb2Ygd29yayB0byBwYXJzZVxudXAgdG8gdGhhdCBwb2ludCBpZiB0aGUgdHJlZSBpc24ndCBhbHJlYWR5IGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBlbnN1cmVTeW50YXhUcmVlKHN0YXRlLCB1cHRvLCB0aW1lb3V0ID0gNTApIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHBhcnNlID0gKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQ7XG4gICAgaWYgKCFwYXJzZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9sZFZpZXBvcnQgPSBwYXJzZS52aWV3cG9ydDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydCh7IGZyb206IDAsIHRvOiB1cHRvIH0pO1xuICAgIGxldCByZXN1bHQgPSBwYXJzZS5pc0RvbmUodXB0bykgfHwgcGFyc2Uud29yayh0aW1lb3V0LCB1cHRvKSA/IHBhcnNlLnRyZWUgOiBudWxsO1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KG9sZFZpZXBvcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcblF1ZXJpZXMgd2hldGhlciB0aGVyZSBpcyBhIGZ1bGwgc3ludGF4IHRyZWUgYXZhaWxhYmxlIHVwIHRvIHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIElmIHRoZXJlIGlzbid0LCB0aGUgYmFja2dyb3VuZCBwYXJzZVxucHJvY2VzcyBfbWlnaHRfIHN0aWxsIGJlIHdvcmtpbmcgYW5kIHVwZGF0ZSB0aGUgdHJlZSBmdXJ0aGVyLCBidXRcbnRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB0aGF04oCUdGhlIHBhcnNlciB3aWxsIFtzdG9wXG53b3JraW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFBhcnNlclJ1bm5pbmcpIHdoZW4gaXQgaGFzIHNwZW50IGFcbmNlcnRhaW4gYW1vdW50IG9mIHRpbWUgb3IgaGFzIG1vdmVkIGJleW9uZCB0aGUgdmlzaWJsZSB2aWV3cG9ydC5cbkFsd2F5cyByZXR1cm5zIGZhbHNlIGlmIG5vIGxhbmd1YWdlIGhhcyBiZWVuIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZUF2YWlsYWJsZShzdGF0ZSwgdXB0byA9IHN0YXRlLmRvYy5sZW5ndGgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dC5pc0RvbmUodXB0bykpIHx8IGZhbHNlO1xufVxuLyoqXG5Nb3ZlIHBhcnNpbmcgZm9yd2FyZCwgYW5kIHVwZGF0ZSB0aGUgZWRpdG9yIHN0YXRlIGFmdGVyd2FyZHMgdG9cbnJlZmxlY3QgdGhlIG5ldyB0cmVlLiBXaWxsIHdvcmsgZm9yIGF0IG1vc3QgYHRpbWVvdXRgXG5taWxsaXNlY29uZHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFyc2VyIG1hbmFnZWQgZ2V0IHRvIHRoZSBnaXZlblxucG9zaXRpb24gaW4gdGhhdCB0aW1lLlxuKi9cbmZ1bmN0aW9uIGZvcmNlUGFyc2luZyh2aWV3LCB1cHRvID0gdmlldy52aWV3cG9ydC50bywgdGltZW91dCA9IDEwMCkge1xuICAgIGxldCBzdWNjZXNzID0gZW5zdXJlU3ludGF4VHJlZSh2aWV3LnN0YXRlLCB1cHRvLCB0aW1lb3V0KTtcbiAgICBpZiAoc3VjY2VzcyAhPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHt9KTtcbiAgICByZXR1cm4gISFzdWNjZXNzO1xufVxuLyoqXG5UZWxscyB5b3Ugd2hldGhlciB0aGUgbGFuZ3VhZ2UgcGFyc2VyIGlzIHBsYW5uaW5nIHRvIGRvIG1vcmVcbnBhcnNpbmcgd29yayAoaW4gYSBgcmVxdWVzdElkbGVDYWxsYmFja2AgcHNldWRvLXRocmVhZCkgb3IgaGFzXG5zdG9wcGVkIHJ1bm5pbmcsIGVpdGhlciBiZWNhdXNlIGl0IHBhcnNlZCB0aGUgZW50aXJlIGRvY3VtZW50LFxuYmVjYXVzZSBpdCBzcGVudCB0b28gbXVjaCB0aW1lIGFuZCB3YXMgY3V0IG9mZiwgb3IgYmVjYXVzZSB0aGVyZVxuaXMgbm8gbGFuZ3VhZ2UgcGFyc2VyIGVuYWJsZWQuXG4qL1xuZnVuY3Rpb24gc3ludGF4UGFyc2VyUnVubmluZyh2aWV3KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4ocGFyc2VXb3JrZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNXb3JraW5nKCkpIHx8IGZhbHNlO1xufVxuLyoqXG5MZXplci1zdHlsZVxuW2BJbnB1dGBdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjY29tbW9uLklucHV0KVxub2JqZWN0IGZvciBhIFtgVGV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dCkgb2JqZWN0LlxuKi9cbmNsYXNzIERvY0lucHV0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gMDtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLmRvYy5sZW5ndGg7IH1cbiAgICBzeW5jVG8ocG9zKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gdGhpcy5jdXJzb3IubmV4dChwb3MgLSB0aGlzLmN1cnNvclBvcykudmFsdWU7XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zICsgdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGNodW5rKHBvcykge1xuICAgICAgICB0aGlzLnN5bmNUbyhwb3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHN0cmluZ1N0YXJ0ID0gdGhpcy5jdXJzb3JQb3MgLSB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChmcm9tIDwgc3RyaW5nU3RhcnQgfHwgdG8gPj0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSAtIHN0cmluZ1N0YXJ0LCB0byAtIHN0cmluZ1N0YXJ0KTtcbiAgICB9XG59XG5sZXQgY3VycmVudENvbnRleHQgPSBudWxsO1xuLyoqXG5BIHBhcnNlIGNvbnRleHQgcHJvdmlkZWQgdG8gcGFyc2VycyB3b3JraW5nIG9uIHRoZSBlZGl0b3IgY29udGVudC5cbiovXG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRyZWUgZnJhZ21lbnRzIHRoYXQgY2FuIGJlIHJldXNlZCBieSBpbmNyZW1lbnRhbCByZS1wYXJzZXMuXG4gICAgKi9cbiAgICBmcmFnbWVudHMgPSBbXSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWVMZW4sIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciB2aWV3cG9ydCAob3Igc29tZSBvdmVyYXBwcm94aW1hdGlvblxuICAgIHRoZXJlb2YpLiBJbnRlbmRlZCB0byBiZSB1c2VkIGZvciBvcHBvcnR1bmlzdGljYWxseSBhdm9pZGluZ1xuICAgIHdvcmsgKGluIHdoaWNoIGNhc2VcbiAgICBbYHNraXBVbnRpbEluVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuUGFyc2VDb250ZXh0LnNraXBVbnRpbEluVmlldylcbiAgICBzaG91bGQgYmUgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgcGFyc2VyIGlzIHJlc3RhcnRlZCB3aGVuIHRoZVxuICAgIHNraXBwZWQgcmVnaW9uIGJlY29tZXMgdmlzaWJsZSkuXG4gICAgKi9cbiAgICB2aWV3cG9ydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwcGVkLCBcbiAgICAvKipcbiAgICBUaGlzIGlzIHdoZXJlIHNraXBwaW5nIHBhcnNlcnMgY2FuIHJlZ2lzdGVyIGEgcHJvbWlzZSB0aGF0LFxuICAgIHdoZW4gcmVzb2x2ZWQsIHdpbGwgc2NoZWR1bGUgYSBuZXcgcGFyc2UuIEl0IGlzIGNsZWFyZWQgd2hlblxuICAgIHRoZSBwYXJzZSB3b3JrZXIgcGlja3MgdXAgdGhlIHByb21pc2UuIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NoZWR1bGVPbikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy50cmVlTGVuID0gdHJlZUxlbjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnNraXBwZWQgPSBza2lwcGVkO1xuICAgICAgICB0aGlzLnNjaGVkdWxlT24gPSBzY2hlZHVsZU9uO1xuICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlbXBTa2lwcGVkID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShwYXJzZXIsIHN0YXRlLCB2aWV3cG9ydCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dChwYXJzZXIsIHN0YXRlLCBbXSwgVHJlZS5lbXB0eSwgMCwgdmlld3BvcnQsIFtdLCBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyLnN0YXJ0UGFyc2UobmV3IERvY0lucHV0KHRoaXMuc3RhdGUuZG9jKSwgdGhpcy5mcmFnbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdvcmsodW50aWwsIHVwdG8pIHtcbiAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiB1cHRvID49IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHVwdG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnRyZWUgIT0gVHJlZS5lbXB0eSAmJiB0aGlzLmlzRG9uZSh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHVudGlsID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyB1bnRpbDtcbiAgICAgICAgICAgICAgICB1bnRpbCA9ICgpID0+IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiB1cHRvKSAmJlxuICAgICAgICAgICAgICAgIHVwdG8gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQodXB0byk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKGRvbmUsIHRoaXMuZnJhZ21lbnRzLCB0aGlzLnBhcnNlLnN0b3BwZWRBdCAhPSBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IChfYSA9IHRoaXMucGFyc2Uuc3RvcHBlZEF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IGRvbmU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmVlTGVuIDwgKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW50aWwoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0YWtlVHJlZSgpIHtcbiAgICAgICAgbGV0IHBvcywgdHJlZTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UgJiYgKHBvcyA9IHRoaXMucGFyc2UucGFyc2VkUG9zKSA+PSB0aGlzLnRyZWVMZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gcG9zKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgICAgICB0aGlzLndpdGhDb250ZXh0KCgpID0+IHsgd2hpbGUgKCEodHJlZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpKSkgeyB9IH0pO1xuICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gcG9zO1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgdHJ1ZSkpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aENvbnRleHQoZikge1xuICAgICAgICBsZXQgcHJldiA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICBjdXJyZW50Q29udGV4dCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhvdXRUZW1wU2tpcHBlZChmcmFnbWVudHMpIHtcbiAgICAgICAgZm9yIChsZXQgcjsgciA9IHRoaXMudGVtcFNraXBwZWQucG9wKCk7KVxuICAgICAgICAgICAgZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgci5mcm9tLCByLnRvKTtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGFuZ2VzKGNoYW5nZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGxldCB7IGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSA9PiByYW5nZXMucHVzaCh7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSkpO1xuICAgICAgICAgICAgZnJhZ21lbnRzID0gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB0cmVlID0gVHJlZS5lbXB0eTtcbiAgICAgICAgICAgIHRyZWVMZW4gPSAwO1xuICAgICAgICAgICAgdmlld3BvcnQgPSB7IGZyb206IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LmZyb20sIC0xKSwgdG86IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNraXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyhyLmZyb20sIDEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHIudG8sIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlQ29udGV4dCh0aGlzLnBhcnNlciwgbmV3U3RhdGUsIGZyYWdtZW50cywgdHJlZSwgdHJlZUxlbiwgdmlld3BvcnQsIHNraXBwZWQsIHRoaXMuc2NoZWR1bGVPbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdXBkYXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSB2aWV3cG9ydC5mcm9tICYmIHRoaXMudmlld3BvcnQudG8gPT0gdmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IHN0YXJ0TGVuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNraXBwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLnNraXBwZWRbaV07XG4gICAgICAgICAgICBpZiAoZnJvbSA8IHZpZXdwb3J0LnRvICYmIHRvID4gdmlld3BvcnQuZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gY3V0RnJhZ21lbnRzKHRoaXMuZnJhZ21lbnRzLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoID49IHN0YXJ0TGVuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gICAgYmVjYXVzZSBpdCB3YXNuJ3QgaW4gdmlldywgYW5kIHRoZSBwYXJzZSBzaG91bGQgYmUgcmVzdGFydGVkXG4gICAgd2hlbiBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBza2lwVW50aWxJblZpZXcoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5za2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHBhcnNlciBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIHBsYWNlaG9sZGVyIHdoZW5cbiAgICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gICAgbWFyayBpdCBhcyBub3QtcmVhbGx5LXBhcnNlZCwgc28gdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBwYXJzZVxuICAgIGl0IGFnYWluLlxuICAgIFxuICAgIFdoZW4gYHVudGlsYCBpcyBnaXZlbiwgYSByZXBhcnNlIHdpbGwgYmUgc2NoZWR1bGVkIHdoZW4gdGhhdFxuICAgIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0U2tpcHBpbmdQYXJzZXIodW50aWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1swXS5mcm9tLCB0byA9IHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0udG87XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUG9zOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gudGVtcFNraXBwZWQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW50aWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBjeC5zY2hlZHVsZU9uID8gUHJvbWlzZS5hbGwoW2N4LnNjaGVkdWxlT24sIHVudGlsXSkgOiB1bnRpbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCB0byAtIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkQXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdCgpIHsgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpc0RvbmUodXB0bykge1xuICAgICAgICB1cHRvID0gTWF0aC5taW4odXB0bywgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IGZyYWdzID0gdGhpcy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVMZW4gPj0gdXB0byAmJiBmcmFncy5sZW5ndGggJiYgZnJhZ3NbMF0uZnJvbSA9PSAwICYmIGZyYWdzWzBdLnRvID49IHVwdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgcGFyc2UsIG9yIGBudWxsYCBpZiBubyBlZGl0b3JcbiAgICBwYXJzZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQoKSB7IHJldHVybiBjdXJyZW50Q29udGV4dDsgfVxufVxuZnVuY3Rpb24gY3V0RnJhZ21lbnRzKGZyYWdtZW50cywgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gVHJlZUZyYWdtZW50LmFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIFt7IGZyb21BOiBmcm9tLCB0b0E6IHRvLCBmcm9tQjogZnJvbSwgdG9COiB0byB9XSk7XG59XG5jbGFzcyBMYW5ndWFnZVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBBIG11dGFibGUgcGFyc2Ugc3RhdGUgdGhhdCBpcyB1c2VkIHRvIHByZXNlcnZlIHdvcmsgZG9uZSBkdXJpbmdcbiAgICAvLyB0aGUgbGlmZXRpbWUgb2YgYSBzdGF0ZSB3aGVuIG1vdmluZyB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHJlZSA9IGNvbnRleHQudHJlZTtcbiAgICB9XG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmIHRoaXMudHJlZSA9PSB0aGlzLmNvbnRleHQudHJlZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgbmV3Q3ggPSB0aGlzLmNvbnRleHQuY2hhbmdlcyh0ci5jaGFuZ2VzLCB0ci5zdGF0ZSk7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBwYXJzZSB3YXNuJ3QgZG9uZSwgZ28gZm9yd2FyZCBvbmx5IHVwIHRvIGl0c1xuICAgICAgICAvLyBlbmQgcG9zaXRpb24gb3IgdGhlIGVuZCBvZiB0aGUgdmlld3BvcnQsIHRvIGF2b2lkIHNsb3dpbmcgZG93blxuICAgICAgICAvLyBzdGF0ZSB1cGRhdGVzIHdpdGggcGFyc2Ugd29yayBiZXlvbmQgdGhlIHZpZXdwb3J0LlxuICAgICAgICBsZXQgdXB0byA9IHRoaXMuY29udGV4dC50cmVlTGVuID09IHRyLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBNYXRoLm1heCh0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmNvbnRleHQudHJlZUxlbiksIG5ld0N4LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKCFuZXdDeC53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHVwdG8pKVxuICAgICAgICAgICAgbmV3Q3gudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKG5ld0N4KTtcbiAgICB9XG4gICAgc3RhdGljIGluaXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZwVG8gPSBNYXRoLm1pbigzMDAwIC8qIFdvcmsuSW5pdFZpZXdwb3J0ICovLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgbGV0IHBhcnNlU3RhdGUgPSBQYXJzZUNvbnRleHQuY3JlYXRlKHN0YXRlLmZhY2V0KGxhbmd1YWdlKS5wYXJzZXIsIHN0YXRlLCB7IGZyb206IDAsIHRvOiB2cFRvIH0pO1xuICAgICAgICBpZiAoIXBhcnNlU3RhdGUud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB2cFRvKSlcbiAgICAgICAgICAgIHBhcnNlU3RhdGUudGFrZVRyZWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN0YXRlKHBhcnNlU3RhdGUpO1xuICAgIH1cbn1cbkxhbmd1YWdlLnN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGU6IExhbmd1YWdlU3RhdGUuaW5pdCxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKExhbmd1YWdlLnNldFN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHRyLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSlcbiAgICAgICAgICAgIHJldHVybiBMYW5ndWFnZVN0YXRlLmluaXQodHIuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodHIpO1xuICAgIH1cbn0pO1xubGV0IHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKCksIDUwMCAvKiBXb3JrLk1heFBhdXNlICovKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcbmlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPSBcInVuZGVmaW5lZFwiKVxuICAgIHJlcXVlc3RJZGxlID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGxldCBpZGxlID0gLTEsIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlkbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKGNhbGxiYWNrLCB7IHRpbWVvdXQ6IDUwMCAvKiBXb3JrLk1heFBhdXNlICovIC0gMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8gfSk7XG4gICAgICAgIH0sIDEwMCAvKiBXb3JrLk1pblBhdXNlICovKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGlkbGUgPCAwID8gY2xlYXJUaW1lb3V0KHRpbWVvdXQpIDogY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGUpO1xuICAgIH07XG5jb25zdCBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAoKF9hID0gbmF2aWdhdG9yLnNjaGVkdWxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0lucHV0UGVuZGluZylcbiAgICA/ICgpID0+IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nKCkgOiBudWxsO1xuY29uc3QgcGFyc2VXb3JrZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3MgUGFyc2VXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIHRoZSBjdXJyZW50IHRpbWUgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0VuZCA9IC0xO1xuICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgYnVkZ2V0IGxlZnQgZm9yIHRoaXMgY2h1bmtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IC0xO1xuICAgICAgICB0aGlzLndvcmsgPSB0aGlzLndvcmsuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY3ggPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpLmNvbnRleHQ7XG4gICAgICAgIGlmIChjeC51cGRhdGVWaWV3cG9ydCh1cGRhdGUudmlldy52aWV3cG9ydCkgfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvID4gY3gudHJlZUxlbilcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3Lmhhc0ZvY3VzKVxuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgKz0gNTAgLyogV29yay5DaGFuZ2VCb251cyAqLztcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoY3gpO1xuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSAhPSBmaWVsZC5jb250ZXh0LnRyZWUgfHwgIWZpZWxkLmNvbnRleHQuaXNEb25lKHN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nID0gcmVxdWVzdElkbGUodGhpcy53b3JrKTtcbiAgICB9XG4gICAgd29yayhkZWFkbGluZSkge1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBub3cgJiYgKHRoaXMuY2h1bmtFbmQgPCAwIHx8IHRoaXMudmlldy5oYXNGb2N1cykpIHsgLy8gU3RhcnQgYSBuZXcgY2h1bmtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtFbmQgPSBub3cgKyAzMDAwMCAvKiBXb3JrLkNodW5rVGltZSAqLztcbiAgICAgICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAzMDAwIC8qIFdvcmsuQ2h1bmtCdWRnZXQgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTm8gbW9yZSBidWRnZXRcbiAgICAgICAgbGV0IHsgc3RhdGUsIHZpZXdwb3J0OiB7IHRvOiB2cFRvIH0gfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlID09IGZpZWxkLmNvbnRleHQudHJlZSAmJiBmaWVsZC5jb250ZXh0LmlzRG9uZSh2cFRvICsgMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIE1hdGgubWluKHRoaXMuY2h1bmtCdWRnZXQsIDEwMCAvKiBXb3JrLlNsaWNlICovLCBkZWFkbGluZSAmJiAhaXNJbnB1dFBlbmRpbmcgPyBNYXRoLm1heCgyNSAvKiBXb3JrLk1pblNsaWNlICovLCBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgLSA1KSA6IDFlOSk7XG4gICAgICAgIGxldCB2aWV3cG9ydEZpcnN0ID0gZmllbGQuY29udGV4dC50cmVlTGVuIDwgdnBUbyAmJiBzdGF0ZS5kb2MubGVuZ3RoID4gdnBUbyArIDEwMDA7XG4gICAgICAgIGxldCBkb25lID0gZmllbGQuY29udGV4dC53b3JrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpc0lucHV0UGVuZGluZyAmJiBpc0lucHV0UGVuZGluZygpIHx8IERhdGUubm93KCkgPiBlbmRUaW1lO1xuICAgICAgICB9LCB2cFRvICsgKHZpZXdwb3J0Rmlyc3QgPyAwIDogMTAwMDAwIC8qIFdvcmsuTWF4UGFyc2VBaGVhZCAqLykpO1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0IC09IERhdGUubm93KCkgLSBub3c7XG4gICAgICAgIGlmIChkb25lIHx8IHRoaXMuY2h1bmtCdWRnZXQgPD0gMCkge1xuICAgICAgICAgICAgZmllbGQuY29udGV4dC50YWtlVHJlZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogTGFuZ3VhZ2Uuc2V0U3RhdGUub2YobmV3IExhbmd1YWdlU3RhdGUoZmllbGQuY29udGV4dCkpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0ID4gMCAmJiAhKGRvbmUgJiYgIXZpZXdwb3J0Rmlyc3QpKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUoZmllbGQuY29udGV4dCk7XG4gICAgfVxuICAgIGNoZWNrQXN5bmNTY2hlZHVsZShjeCkge1xuICAgICAgICBpZiAoY3guc2NoZWR1bGVPbikge1xuICAgICAgICAgICAgdGhpcy53b3JrU2NoZWR1bGVkKys7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5zY2hlZHVsZVdvcmsoKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGVycikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy53b3JrU2NoZWR1bGVkLS0pO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHRoaXMud29ya2luZygpO1xuICAgIH1cbiAgICBpc1dvcmtpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHsgZm9jdXMoKSB7IHRoaXMuc2NoZWR1bGVXb3JrKCk7IH0gfVxufSk7XG4vKipcblRoZSBmYWNldCB1c2VkIHRvIGFzc29jaWF0ZSBhIGxhbmd1YWdlIHdpdGggYW4gZWRpdG9yIHN0YXRlLiBVc2VkXG5ieSBgTGFuZ3VhZ2VgIG9iamVjdCdzIGBleHRlbnNpb25gIHByb3BlcnR5IChzbyB5b3UgZG9uJ3QgbmVlZCB0b1xubWFudWFsbHkgd3JhcCB5b3VyIGxhbmd1YWdlcyBpbiB0aGlzKS4gQ2FuIGJlIHVzZWQgdG8gYWNjZXNzIHRoZVxuY3VycmVudCBsYW5ndWFnZSBvbiBhIHN0YXRlLlxuKi9cbmNvbnN0IGxhbmd1YWdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShsYW5ndWFnZXMpIHsgcmV0dXJuIGxhbmd1YWdlcy5sZW5ndGggPyBsYW5ndWFnZXNbMF0gOiBudWxsOyB9LFxuICAgIGVuYWJsZXM6IGxhbmd1YWdlID0+IFtcbiAgICAgICAgTGFuZ3VhZ2Uuc3RhdGUsXG4gICAgICAgIHBhcnNlV29ya2VyLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmNvbXB1dGUoW2xhbmd1YWdlXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgICAgICByZXR1cm4gbGFuZyAmJiBsYW5nLm5hbWUgPyB7IFwiZGF0YS1sYW5ndWFnZVwiOiBsYW5nLm5hbWUgfSA6IHt9O1xuICAgICAgICB9KVxuICAgIF1cbn0pO1xuLyoqXG5UaGlzIGNsYXNzIGJ1bmRsZXMgYSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIHdpdGggYW5cbm9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIExhbmd1YWdlIHBhY2thZ2VzIGFyZVxuZW5jb3VyYWdlZCB0byBleHBvcnQgYSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYVxuY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIHJldHVybnMgYSBgTGFuZ3VhZ2VTdXBwb3J0YCBpbnN0YW5jZSwgYXNcbnRoZSBtYWluIHdheSBmb3IgY2xpZW50IGNvZGUgdG8gdXNlIHRoZSBwYWNrYWdlLlxuKi9cbmNsYXNzIExhbmd1YWdlU3VwcG9ydCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2Ugc3VwcG9ydCBvYmplY3QuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgICovXG4gICAgbGFuZ3VhZ2UsIFxuICAgIC8qKlxuICAgIEFuIG9wdGlvbmFsIHNldCBvZiBzdXBwb3J0aW5nIGV4dGVuc2lvbnMuIFdoZW4gbmVzdGluZyBhXG4gICAgbGFuZ3VhZ2UgaW4gYW5vdGhlciBsYW5ndWFnZSwgdGhlIG91dGVyIGxhbmd1YWdlIGlzIGVuY291cmFnZWRcbiAgICB0byBpbmNsdWRlIHRoZSBzdXBwb3J0aW5nIGV4dGVuc2lvbnMgZm9yIGl0cyBpbm5lciBsYW5ndWFnZXNcbiAgICBpbiBpdHMgb3duIHNldCBvZiBzdXBwb3J0IGV4dGVuc2lvbnMuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gW10pIHtcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtsYW5ndWFnZSwgc3VwcG9ydF07XG4gICAgfVxufVxuLyoqXG5MYW5ndWFnZSBkZXNjcmlwdGlvbnMgYXJlIHVzZWQgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXQgbGFuZ3VhZ2VzXG5hbmQgdG8gZHluYW1pY2FsbHkgbG9hZCB0aGVtLiBUaGVpciBtYWluIHJvbGUgaXMgZmluZGluZyB0aGVcbmFwcHJvcHJpYXRlIGxhbmd1YWdlIGZvciBhIGZpbGVuYW1lIG9yIGR5bmFtaWNhbGx5IGxvYWRpbmcgbmVzdGVkXG5wYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBbHRlcm5hdGl2ZSBuYW1lcyBmb3IgdGhlIG1vZGUgKGxvd2VyY2FzZWQsIGluY2x1ZGVzIGB0aGlzLm5hbWVgKS5cbiAgICAqL1xuICAgIGFsaWFzLCBcbiAgICAvKipcbiAgICBGaWxlIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBleHRlbnNpb25zLCBcbiAgICAvKipcbiAgICBPcHRpb25hbCBmaWxlbmFtZSBwYXR0ZXJuIHRoYXQgc2hvdWxkIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBmaWxlbmFtZSwgbG9hZEZ1bmMsIFxuICAgIC8qKlxuICAgIElmIHRoZSBsYW5ndWFnZSBoYXMgYmVlbiBsb2FkZWQsIHRoaXMgd2lsbCBob2xkIGl0cyB2YWx1ZS5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMubG9hZEZ1bmMgPSBsb2FkRnVuYztcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgbG9hZGluZyB0aGUgdGhlIGxhbmd1YWdlLiBXaWxsIHJldHVybiBhIHByb21pc2UgdGhhdFxuICAgIHJlc29sdmVzIHRvIGEgW2BMYW5ndWFnZVN1cHBvcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlU3VwcG9ydClcbiAgICBvYmplY3Qgd2hlbiB0aGUgbGFuZ3VhZ2Ugc3VjY2Vzc2Z1bGx5IGxvYWRzLlxuICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZyB8fCAodGhpcy5sb2FkaW5nID0gdGhpcy5sb2FkRnVuYygpLnRoZW4oc3VwcG9ydCA9PiB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0LCBlcnIgPT4geyB0aGlzLmxvYWRpbmcgPSBudWxsOyB0aHJvdyBlcnI7IH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbGFuZ3VhZ2UgZGVzY3JpcHRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgb2Yoc3BlYykge1xuICAgICAgICBsZXQgeyBsb2FkLCBzdXBwb3J0IH0gPSBzcGVjO1xuICAgICAgICBpZiAoIWxvYWQpIHtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11c3QgcGFzcyBlaXRoZXIgJ2xvYWQnIG9yICdzdXBwb3J0JyB0byBMYW5ndWFnZURlc2NyaXB0aW9uLm9mXCIpO1xuICAgICAgICAgICAgbG9hZCA9ICgpID0+IFByb21pc2UucmVzb2x2ZShzdXBwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlRGVzY3JpcHRpb24oc3BlYy5uYW1lLCAoc3BlYy5hbGlhcyB8fCBbXSkuY29uY2F0KHNwZWMubmFtZSkubWFwKHMgPT4gcy50b0xvd2VyQ2FzZSgpKSwgc3BlYy5leHRlbnNpb25zIHx8IFtdLCBzcGVjLmZpbGVuYW1lLCBsb2FkLCBzdXBwb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVzY3JpcHRpb25zIHRoYXRcbiAgICBtYXRjaGVzIHRoZSBmaWxlbmFtZS4gV2lsbCBmaXJzdCBtYXRjaFxuICAgIFtgZmlsZW5hbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZmlsZW5hbWUpIHBhdHRlcm5zLFxuICAgIGFuZCB0aGVuIFtleHRlbnNpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlRGVzY3JpcHRpb24uZXh0ZW5zaW9ucyksXG4gICAgYW5kIHJldHVybiB0aGUgZmlyc3QgbGFuZ3VhZ2UgdGhhdCBtYXRjaGVzLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoRmlsZW5hbWUoZGVzY3MsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5maWxlbmFtZSAmJiBkLmZpbGVuYW1lLnRlc3QoZmlsZW5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBsZXQgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgaWYgKGQuZXh0ZW5zaW9ucy5pbmRleE9mKGV4dFsxXSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWUgb3IgYWxpYXMgbWF0Y2hlcyB0aGUgdGhlIGdpdmVuXG4gICAgbmFtZSAoY2FzZS1pbnNlbnNpdGl2ZWx5KS4gSWYgYGZ1enp5YCBpcyB0cnVlLCBhbmQgbm8gZGlyZWN0XG4gICAgbWF0Y2hzIGlzIGZvdW5kLCB0aGlzJ2xsIGFsc28gc2VhcmNoIGZvciBhIGxhbmd1YWdlIHdob3NlIG5hbWVcbiAgICBvciBhbGlhcyBvY2N1cnMgaW4gdGhlIHN0cmluZyAoZm9yIG5hbWVzIHNob3J0ZXIgdGhhbiB0aHJlZVxuICAgIGNoYXJhY3RlcnMsIG9ubHkgd2hlbiBzdXJyb3VuZGVkIGJ5IG5vbi13b3JkIGNoYXJhY3RlcnMpLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoTGFuZ3VhZ2VOYW1lKGRlc2NzLCBuYW1lLCBmdXp6eSA9IHRydWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmFsaWFzLnNvbWUoYSA9PiBhID09IG5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICBpZiAoZnV6enkpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgb2YgZC5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBuYW1lLmluZGV4T2YoYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xICYmIChhLmxlbmd0aCA+IDIgfHwgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCAtIDFdKSAmJiAhL1xcdy8udGVzdChuYW1lW2ZvdW5kICsgYS5sZW5ndGhdKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG5GYWNldCB0aGF0IGRlZmluZXMgYSB3YXkgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG5hcHByb3ByaWF0ZSBpbmRlbnRhdGlvbiBkZXB0aCwgYXMgYSBjb2x1bW4gbnVtYmVyIChzZWVcbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSwgYXQgdGhlIHN0YXJ0IG9mIGEgZ2l2ZW5cbmxpbmUuIEEgcmV0dXJuIHZhbHVlIG9mIGBudWxsYCBpbmRpY2F0ZXMgbm8gaW5kZW50YXRpb24gY2FuIGJlXG5kZXRlcm1pbmVkLCBhbmQgdGhlIGxpbmUgc2hvdWxkIGluaGVyaXQgdGhlIGluZGVudGF0aW9uIG9mIHRoZSBvbmVcbmFib3ZlIGl0LiBBIHJldHVybiB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBkZWZlcnMgdG8gdGhlIG5leHQgaW5kZW50XG5zZXJ2aWNlLlxuKi9cbmNvbnN0IGluZGVudFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IGZvciBvdmVycmlkaW5nIHRoZSB1bml0IGJ5IHdoaWNoIGluZGVudGF0aW9uIGhhcHBlbnMuIFNob3VsZFxuYmUgYSBzdHJpbmcgY29uc2lzdGluZyBlaXRoZXIgZW50aXJlbHkgb2YgdGhlIHNhbWUgd2hpdGVzcGFjZVxuY2hhcmFjdGVyLiBXaGVuIG5vdCBzZXQsIHRoaXMgZGVmYXVsdHMgdG8gMiBzcGFjZXMuXG4qL1xuY29uc3QgaW5kZW50VW5pdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB7XG4gICAgICAgIGlmICghdmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBcIiAgXCI7XG4gICAgICAgIGxldCB1bml0ID0gdmFsdWVzWzBdO1xuICAgICAgICBpZiAoIXVuaXQgfHwgL1xcUy8udGVzdCh1bml0KSB8fCBBcnJheS5mcm9tKHVuaXQpLnNvbWUoZSA9PiBlICE9IHVuaXRbMF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbMF0pKTtcbiAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxufSk7XG4vKipcblJldHVybiB0aGUgX2NvbHVtbiB3aWR0aF8gb2YgYW4gaW5kZW50IHVuaXQgaW4gdGhlIHN0YXRlLlxuRGV0ZXJtaW5lZCBieSB0aGUgW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KVxuZmFjZXQsIGFuZCBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIHdoZW4gdGhhdFxuY29udGFpbnMgdGFicy5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRVbml0KHN0YXRlKSB7XG4gICAgbGV0IHVuaXQgPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KTtcbiAgICByZXR1cm4gdW5pdC5jaGFyQ29kZUF0KDApID09IDkgPyBzdGF0ZS50YWJTaXplICogdW5pdC5sZW5ndGggOiB1bml0Lmxlbmd0aDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGluZGVudGF0aW9uIHN0cmluZyB0aGF0IGNvdmVycyBjb2x1bW5zIDAgdG8gYGNvbHNgLlxuV2lsbCB1c2UgdGFicyBmb3IgYXMgbXVjaCBvZiB0aGUgY29sdW1ucyBhcyBwb3NzaWJsZSB3aGVuIHRoZVxuW2BpbmRlbnRVbml0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBmYWNldCBjb250YWluc1xudGFicy5cbiovXG5mdW5jdGlvbiBpbmRlbnRTdHJpbmcoc3RhdGUsIGNvbHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIiwgdHMgPSBzdGF0ZS50YWJTaXplLCBjaCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpWzBdO1xuICAgIGlmIChjaCA9PSBcIlxcdFwiKSB7XG4gICAgICAgIHdoaWxlIChjb2xzID49IHRzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGNvbHMgLT0gdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBcIiBcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5HZXQgdGhlIGluZGVudGF0aW9uLCBhcyBhIGNvbHVtbiBudW1iZXIsIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbldpbGwgZmlyc3QgY29uc3VsdCBhbnkgW2luZGVudCBzZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKVxudGhhdCBhcmUgcmVnaXN0ZXJlZCwgYW5kIGlmIG5vbmUgb2YgdGhvc2UgcmV0dXJuIGFuIGluZGVudGF0aW9uLFxudGhpcyB3aWxsIGNoZWNrIHRoZSBzeW50YXggdHJlZSBmb3IgdGhlIFtpbmRlbnQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnROb2RlUHJvcCkgYW5kIHVzZSB0aGF0IGlmIGZvdW5kLiBSZXR1cm5zIGFcbm51bWJlciB3aGVuIGFuIGluZGVudGF0aW9uIGNvdWxkIGJlIGRldGVybWluZWQsIGFuZCBudWxsXG5vdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgcG9zKSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFZGl0b3JTdGF0ZSlcbiAgICAgICAgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2YgY29udGV4dC5zdGF0ZS5mYWNldChpbmRlbnRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShjb250ZXh0LCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSk7XG4gICAgcmV0dXJuIHRyZWUubGVuZ3RoID49IHBvcyA/IHN5bnRheEluZGVudGF0aW9uKGNvbnRleHQsIHRyZWUsIHBvcykgOiBudWxsO1xufVxuLyoqXG5DcmVhdGUgYSBjaGFuZ2Ugc2V0IHRoYXQgYXV0by1pbmRlbnRzIGFsbCBsaW5lcyB0b3VjaGVkIGJ5IHRoZVxuZ2l2ZW4gZG9jdW1lbnQgcmFuZ2UuXG4qL1xuZnVuY3Rpb24gaW5kZW50UmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB1cGRhdGVkW3N0YXJ0XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7IH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGNvbnRleHQsIGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xufVxuLyoqXG5JbmRlbnRhdGlvbiBjb250ZXh0cyBhcmUgdXNlZCB3aGVuIGNhbGxpbmcgW2luZGVudGF0aW9uXG5zZXJ2aWNlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKS4gVGhleSBwcm92aWRlIGhlbHBlciB1dGlsaXRpZXNcbnVzZWZ1bCBpbiBpbmRlbnRhdGlvbiBsb2dpYywgYW5kIGNhbiBzZWxlY3RpdmVseSBvdmVycmlkZSB0aGVcbmluZGVudGF0aW9uIHJlcG9ydGVkIGZvciBzb21lIGxpbmVzLlxuKi9cbmNsYXNzIEluZGVudENvbnRleHQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbmRlbnQgY29udGV4dC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVuaXQgPSBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgICBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgICBhcmd1bWVudCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnQgb2YgdGhlIGxpbmUgbGluZSBiZWZvcmUgb3JcbiAgICBhZnRlciB0aGUgYnJlYWsgaXMgdXNlZC5cbiAgICAqL1xuICAgIGxpbmVBdChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCB7IHNpbXVsYXRlQnJlYWssIHNpbXVsYXRlRG91YmxlQnJlYWsgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNpbXVsYXRlQnJlYWsgIT0gbnVsbCAmJiBzaW11bGF0ZUJyZWFrID49IGxpbmUuZnJvbSAmJiBzaW11bGF0ZUJyZWFrIDw9IGxpbmUudG8pIHtcbiAgICAgICAgICAgIGlmIChzaW11bGF0ZURvdWJsZUJyZWFrICYmIHNpbXVsYXRlQnJlYWsgPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IFwiXCIsIGZyb206IHBvcyB9O1xuICAgICAgICAgICAgZWxzZSBpZiAoYmlhcyA8IDAgPyBzaW11bGF0ZUJyZWFrIDwgcG9zIDogc2ltdWxhdGVCcmVhayA8PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBzaW11bGF0ZUJyZWFrIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogbGluZS50ZXh0LnNsaWNlKDAsIHNpbXVsYXRlQnJlYWsgLSBsaW5lLmZyb20pLCBmcm9tOiBsaW5lLmZyb20gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGBwb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgdGV4dEFmdGVyUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrICYmIHBvcyA9PSB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShwb3MgLSBmcm9tLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgMTAwIC0gZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvbHVtbihwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHBvcyAtIGZyb20pO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbiA/IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uKGZyb20pIDogLTE7XG4gICAgICAgIGlmIChvdmVycmlkZSA+IC0xKVxuICAgICAgICAgICAgcmVzdWx0ICs9IG92ZXJyaWRlIC0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgY291bnRDb2x1bW4obGluZSwgcG9zID0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q29sdW1uKGxpbmUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb2ludC5cbiAgICAqL1xuICAgIGxpbmVJbmRlbnQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbjtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVuID0gb3ZlcnJpZGUoZnJvbSk7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVuID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudENvbHVtbih0ZXh0LCB0ZXh0LnNlYXJjaCgvXFxTfCQvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgICAqL1xuICAgIGdldCBzaW11bGF0ZWRCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5BIHN5bnRheCB0cmVlIG5vZGUgcHJvcCB1c2VkIHRvIGFzc29jaWF0ZSBpbmRlbnRhdGlvbiBzdHJhdGVnaWVzXG53aXRoIG5vZGUgdHlwZXMuIFN1Y2ggYSBzdHJhdGVneSBpcyBhIGZ1bmN0aW9uIGZyb20gYW4gaW5kZW50YXRpb25cbmNvbnRleHQgdG8gYSBjb2x1bW4gbnVtYmVyIChzZWUgYWxzb1xuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpIG9yIG51bGwsIHdoZXJlIG51bGxcbmluZGljYXRlcyB0aGF0IG5vIGRlZmluaXRpdmUgaW5kZW50YXRpb24gY2FuIGJlIGRldGVybWluZWQuXG4qL1xuY29uc3QgaW5kZW50Tm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vLyBDb21wdXRlIHRoZSBpbmRlbnRhdGlvbiBmb3IgYSBnaXZlbiBwb3NpdGlvbiBmcm9tIHRoZSBzeW50YXggdHJlZS5cbmZ1bmN0aW9uIHN5bnRheEluZGVudGF0aW9uKGN4LCBhc3QsIHBvcykge1xuICAgIGxldCBzdGFjayA9IGFzdC5yZXNvbHZlU3RhY2socG9zKTtcbiAgICBsZXQgaW5uZXIgPSBzdGFjay5ub2RlLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyk7XG4gICAgaWYgKGlubmVyICE9IHN0YWNrLm5vZGUpIHtcbiAgICAgICAgbGV0IGFkZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyICE9IHN0YWNrLm5vZGU7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBhZGQucHVzaChjdXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgc3RhY2sgPSB7IG5vZGU6IGFkZFtpXSwgbmV4dDogc3RhY2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudEZvcihzdGFjaywgY3gsIHBvcyk7XG59XG5mdW5jdGlvbiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShjdXIubm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoY3gsIHBvcywgY3VyKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZClcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmZyb20gPCBsaW5lRW5kID8gb3BlblRva2VuIDogbnVsbDtcbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2soZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGl0ZXIgPSBzdGFjazsgaXRlcjsgaXRlciA9IGl0ZXIubmV4dCkge1xuICAgICAgICBsZXQgY3VyID0gaXRlci5ub2RlO1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGZvbGRlZCA9IGZvbGRlZC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMoZm9sZEVmZmVjdCkgJiYgIWZvbGRFeGlzdHMoZm9sZGVkLCBlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcHJlcGFyZVBsYWNlaG9sZGVyIH0gPSB0ci5zdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gIXByZXBhcmVQbGFjZWhvbGRlciA/IGZvbGRXaWRnZXQgOlxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG4vKipcbkdldCBhIFtyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGNvbnRhaW5pbmcgdGhlIGZvbGRlZCByYW5nZXNcbmluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBmb2xkZWRSYW5nZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XG59XG5mdW5jdGlvbiBmaW5kRm9sZChzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAoX2EgPSBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJldHdlZW4oZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxuICAgICAgICAgICAgZm91bmQgPSB7IGZyb20sIHRvIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZm9sZEV4aXN0cyhmb2xkZWQsIGZyb20sIHRvKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgZnJvbSwgKGEsIGIpID0+IHsgaWYgKGEgPT0gZnJvbSAmJiBiID09IHRvKVxuICAgICAgICBmb3VuZCA9IHRydWU7IH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlKHN0YXRlLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSwgZm9sZCA9IHRydWUpIHtcbiAgICBsZXQgbGluZUZyb20gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkubnVtYmVyLCBsaW5lVG8gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00odmlldywgcHJlcGFyZWQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrLCBwcmVwYXJlZCk7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgbnVsbCk7IH1cbiAgICB9IH0pO1xuY2xhc3MgUHJlcGFyZWRGb2xkV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB1cGRhdGUudmlldy52aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjNDA0NzQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGUobm9kZSkge1xuICAgIGxldCBoYXNIYW5kbGUgPSBub2RlLnR5cGUucHJvcChicmFja2V0TWF0Y2hpbmdIYW5kbGUpO1xuICAgIHJldHVybiBoYXNIYW5kbGUgPyBoYXNIYW5kbGUobm9kZS5ub2RlKSA6IG5vZGU7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZSA9IGZpbmRIYW5kbGUoY3VyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGRpciA+IDAgPyBwb3MgPj0gaGFuZGxlLmZyb20gJiYgcG9zIDwgaGFuZGxlLnRvIDogcG9zID4gaGFuZGxlLmZyb20gJiYgcG9zIDw9IGhhbmRsZS50bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIGhhbmRsZSwgbWF0Y2hlcywgYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIGhhbmRsZSwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogaGFuZGxlLmZyb20sIHRvOiBoYW5kbGUudG8gfTtcbiAgICBsZXQgZGVwdGggPSAwLCBjdXJzb3IgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY3Vyc29yKCk7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiBlbmRIYW5kbGUgPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEhhbmRsZSAmJiBlbmRIYW5kbGUuZnJvbSA8IGVuZEhhbmRsZS50byA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQsIG92ZXJyaWRlSW5kZW50KSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xuICAgICAgICB0aGlzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuICAgICAgICB0aGlzLm92ZXJyaWRlSW5kZW50ID0gb3ZlcnJpZGVJbmRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm92ZXJyaWRlSW5kZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbmNvbnN0IEluZGVudGVkRnJvbSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLyoqXG5BIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgY2xhc3MgYmFzZWQgb24gYSBDb2RlTWlycm9yXG41LXN0eWxlIFtzdHJlYW1pbmcgcGFyc2VyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbVBhcnNlcikuXG4qL1xuY2xhc3MgU3RyZWFtTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChwYXJzZXIubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgbGV0IHAgPSBmdWxsUGFyc2VyKHBhcnNlciksIHNlbGY7XG4gICAgICAgIGxldCBpbXBsID0gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2Uoc2VsZiwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoZGF0YSwgaW1wbCwgW2luZGVudFNlcnZpY2Uub2YoKGN4LCBwb3MpID0+IHRoaXMuZ2V0SW5kZW50KGN4LCBwb3MpKV0sIHBhcnNlci5uYW1lKTtcbiAgICAgICAgdGhpcy50b3BOb2RlID0gZG9jSUQoZGF0YSk7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcnNlciA9IHA7XG4gICAgICAgIHRoaXMuc3RhdGVBZnRlciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHsgcmV0dXJuIG5ldyBTdHJlYW1MYW5ndWFnZShzcGVjKTsgfVxuICAgIGdldEluZGVudChjeCwgcG9zKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjeC5zdGF0ZSksIGF0ID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHdoaWxlIChhdCAmJiBhdC50eXBlICE9IHRoaXMudG9wTm9kZSlcbiAgICAgICAgICAgIGF0ID0gYXQucGFyZW50O1xuICAgICAgICBpZiAoIWF0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeyBvdmVycmlkZUluZGVudGF0aW9uIH0gPSBjeC5vcHRpb25zO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgZnJvbSA9IEluZGVudGVkRnJvbS5nZXQoY3guc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tIDwgcG9zIC0gMWU0KVxuICAgICAgICAgICAgICAgIGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIHRyZWUsIDAsIGF0LmZyb20sIGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IHBvcyksIHN0YXRlUG9zLCBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBzdGFydC5wb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGN4LnVuaXQpO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgcG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihwb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChwb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiB0cmVlLnR5cGUgPT0gbGFuZy50b3BOb2RlKVxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBwb3MgPSB0cmVlLnBvc2l0aW9uc1tpXSwgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBpbm5lcjtcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgaWYgKCEoaW5uZXIgPSBjdXRUcmVlKGxhbmcsIGNoaWxkLCBmcm9tIC0gcG9zLCB0byAtIHBvcywgaW5zaWRlKSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4gIWluc2lkZSA/IGlubmVyXG4gICAgICAgICAgICAgICAgOiBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4uc2xpY2UoMCwgaSkuY29uY2F0KGlubmVyKSwgdHJlZS5wb3NpdGlvbnMuc2xpY2UoMCwgaSArIDEpLCBwb3MgKyBpbm5lci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBzdGFydFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBUcmVlLmVtcHR5IH07XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IobGFuZywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZyA9IGxhbmc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCksIGZyb20gPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgbGV0IHsgc3RhdGUsIHRyZWUgfSA9IGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgZnJvbSwgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRoaXMuY2h1bmtTdGFydCA9IGZyb20gKyB0cmVlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRyZWUucG9zaXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgY29udGV4dC52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocGFyc2VFbmQsIHRoaXMuY2h1bmtTdGFydCArIDIwNDggLyogQy5DaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUluZGV4KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50byA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogQy5NYXhMaW5lTGVuZ3RoICovKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGVuZDtcbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPCB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MrKztcbiAgICB9XG4gICAgZmluaXNoQ2h1bmsoKSB7XG4gICAgICAgIGxldCB0cmVlID0gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY2h1bmssXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLnBhcnNlZFBvcyAtIHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIG5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogMCxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG4vLyBDYWNoZSBvZiBub2RlIHR5cGVzIGJ5IG5hbWUgYW5kIHRhZ3NcbmNvbnN0IGJ5VGFnID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyQxID0gW107XG4gICAgZm9yIChsZXQgbmFtZSBvZiB0YWdTdHIuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIG5hbWUuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLm1hcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZm91bmQpXG4gICAgICAgICAgICB0YWdzJDEucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MkMS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCBrZXkgPSBuYW1lICsgXCIgXCIgKyB0YWdzJDEubWFwKHQgPT4gdC5pZCk7XG4gICAgbGV0IGtub3duID0gYnlUYWdba2V5XTtcbiAgICBpZiAoa25vd24pXG4gICAgICAgIHJldHVybiBrbm93bi5pZDtcbiAgICBsZXQgdHlwZSA9IGJ5VGFnW2tleV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZ3MkMSB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldLCB0b3A6IHRydWUgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9yTGluZShsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoIDw9IDQwOTYgJiYgL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLy50ZXN0KGxpbmUpO1xufVxuZnVuY3Rpb24gdGV4dEhhc1JUTCh0ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IHRleHQuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspXG4gICAgICAgIGlmIChidWlsZEZvckxpbmUoaS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGFuZ2VBZGRzUlRMKGNoYW5nZSkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGNoYW5nZS5pdGVyQ2hhbmdlcygoZkEsIHRBLCBmQiwgdEIsIGlucykgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkICYmIHRleHRIYXNSVEwoaW5zKSlcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRkZWQ7XG59XG5jb25zdCBhbHdheXNJc29sYXRlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpIH0pO1xuLyoqXG5NYWtlIHN1cmUgbm9kZXNcblttYXJrZWRdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1vbi5Ob2RlUHJvcF5pc29sYXRlKVxuYXMgaXNvbGF0aW5nIGZvciBiaWRpcmVjdGlvbmFsIHRleHQgYXJlIHJlbmRlcmVkIGluIGEgd2F5IHRoYXRcbmlzb2xhdGVzIHRoZW0gZnJvbSB0aGUgc3Vycm91bmRpbmcgdGV4dC5cbiovXG5mdW5jdGlvbiBiaWRpSXNvbGF0ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGV4dGVuc2lvbnMgPSBbaXNvbGF0ZU1hcmtzXTtcbiAgICBpZiAob3B0aW9ucy5hbHdheXNJc29sYXRlKVxuICAgICAgICBleHRlbnNpb25zLnB1c2goYWx3YXlzSXNvbGF0ZS5vZih0cnVlKSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG59XG5jb25zdCBpc29sYXRlTWFya3MgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5hbHdheXMgPSB2aWV3LnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNSVEwgPSAhdGhpcy5hbHdheXMgJiYgdGV4dEhhc1JUTCh2aWV3LnN0YXRlLmRvYyk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBidWlsZERlY28odmlldywgdGhpcy50cmVlLCB0aGlzLmFsd2F5cyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGFsd2F5cyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdXBkYXRlLnZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTCAmJiBjaGFuZ2VBZGRzUlRMKHVwZGF0ZS5jaGFuZ2VzKSlcbiAgICAgICAgICAgIHRoaXMuaGFzUlRMID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbHdheXMgJiYgIXRoaXMuaGFzUlRMKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGFsd2F5cyAhPSB0aGlzLmFsd2F5cyB8fCB0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5hbHdheXMgPSBhbHdheXM7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGREZWNvKHVwZGF0ZS52aWV3LCB0cmVlLCBhbHdheXMpO1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzcyh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNvcmF0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zLm9mKGFjY2VzcyksXG4gICAgICAgICAgICBQcmVjLmxvd2VzdChFZGl0b3JWaWV3LmJpZGlJc29sYXRlZFJhbmdlcy5vZihhY2Nlc3MpKV07XG4gICAgfVxufSk7XG5mdW5jdGlvbiBidWlsZERlY28odmlldywgdHJlZSwgYWx3YXlzKSB7XG4gICAgbGV0IGRlY28gPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgbGV0IHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAoIWFsd2F5cylcbiAgICAgICAgcmFuZ2VzID0gY2xpcFJUTExpbmVzKHJhbmdlcywgdmlldy5zdGF0ZS5kb2MpO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgdHJlZS5pdGVyYXRlKHtcbiAgICAgICAgICAgIGVudGVyOiBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNvID0gbm9kZS50eXBlLnByb3AoTm9kZVByb3AuaXNvbGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbylcbiAgICAgICAgICAgICAgICAgICAgZGVjby5hZGQobm9kZS5mcm9tLCBub2RlLnRvLCBtYXJrc1tpc29dKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tLCB0b1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY28uZmluaXNoKCk7XG59XG5mdW5jdGlvbiBjbGlwUlRMTGluZXMocmFuZ2VzLCBkb2MpIHtcbiAgICBsZXQgY3VyID0gZG9jLml0ZXIoKSwgcG9zID0gMCwgcmVzdWx0ID0gW10sIGxhc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgaWYgKGZyb20gIT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBjdXIubmV4dChmcm9tIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zLCBlbmQgPSBwb3MgKyBjdXIudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFjdXIubGluZUJyZWFrICYmIGJ1aWxkRm9yTGluZShjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IHN0YXJ0IC0gMTApXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudG8gPSBNYXRoLm1pbih0bywgZW5kKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QgPSB7IGZyb206IHN0YXJ0LCB0bzogTWF0aC5taW4odG8sIGVuZCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgbWFya3MgPSB7XG4gICAgcnRsOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwicnRsXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5SVEwgfSksXG4gICAgbHRyOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwibHRyXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5MVFIgfSksXG4gICAgYXV0bzogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImF1dG9cIiB9LCBiaWRpSXNvbGF0ZTogbnVsbCB9KVxufTtcblxuZXhwb3J0IHsgRG9jSW5wdXQsIEhpZ2hsaWdodFN0eWxlLCBJbmRlbnRDb250ZXh0LCBMUkxhbmd1YWdlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgTGFuZ3VhZ2VTdXBwb3J0LCBQYXJzZUNvbnRleHQsIFN0cmVhbUxhbmd1YWdlLCBTdHJpbmdTdHJlYW0sIFRyZWVJbmRlbnRDb250ZXh0LCBiaWRpSXNvbGF0ZXMsIGJyYWNrZXRNYXRjaGluZywgYnJhY2tldE1hdGNoaW5nSGFuZGxlLCBjb2RlRm9sZGluZywgY29udGludWVkSW5kZW50LCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIGRlbGltaXRlZEluZGVudCwgZW5zdXJlU3ludGF4VHJlZSwgZmxhdEluZGVudCwgZm9sZEFsbCwgZm9sZENvZGUsIGZvbGRFZmZlY3QsIGZvbGRHdXR0ZXIsIGZvbGRJbnNpZGUsIGZvbGRLZXltYXAsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRTdGF0ZSwgZm9sZGFibGUsIGZvbGRlZFJhbmdlcywgZm9yY2VQYXJzaW5nLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaGlnaGxpZ2h0aW5nRm9yLCBpbmRlbnROb2RlUHJvcCwgaW5kZW50T25JbnB1dCwgaW5kZW50UmFuZ2UsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIG1hdGNoQnJhY2tldHMsIHN1Ymxhbmd1YWdlUHJvcCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBzeW50YXhQYXJzZXJSdW5uaW5nLCBzeW50YXhUcmVlLCBzeW50YXhUcmVlQXZhaWxhYmxlLCB0b2dnbGVGb2xkLCB1bmZvbGRBbGwsIHVuZm9sZENvZGUsIHVuZm9sZEVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/\nclass Text {\n  /**\n  Get the line description around the given position.\n  */\n  lineAt(pos) {\n    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n    return this.lineInner(pos, false, 1, 0);\n  }\n  /**\n  Get the description for the given (1-based) line number.\n  */\n  line(n) {\n    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n    return this.lineInner(n, true, 1, 0);\n  }\n  /**\n  Replace a range of the text with the given content.\n  */\n  replace(from, to, text) {\n    [from, to] = clip(this, from, to);\n    let parts = [];\n    this.decompose(0, from, parts, 2 /* Open.To */);\n    if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\n    this.decompose(to, this.length, parts, 1 /* Open.From */);\n    return TextNode.from(parts, this.length - (to - from) + text.length);\n  }\n  /**\n  Append another document to this one.\n  */\n  append(other) {\n    return this.replace(this.length, this.length, other);\n  }\n  /**\n  Retrieve the text between the given points.\n  */\n  slice(from, to = this.length) {\n    [from, to] = clip(this, from, to);\n    let parts = [];\n    this.decompose(from, to, parts, 0);\n    return TextNode.from(parts, to - from);\n  }\n  /**\n  Test whether this text is equal to another instance.\n  */\n  eq(other) {\n    if (other == this) return true;\n    if (other.length != this.length || other.lines != this.lines) return false;\n    let start = this.scanIdentical(other, 1),\n      end = this.length - this.scanIdentical(other, -1);\n    let a = new RawTextCursor(this),\n      b = new RawTextCursor(other);\n    for (let skip = start, pos = start;;) {\n      a.next(skip);\n      b.next(skip);\n      skip = 0;\n      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n      pos += a.value.length;\n      if (a.done || pos >= end) return true;\n    }\n  }\n  /**\n  Iterate over the text. When `dir` is `-1`, iteration happens\n  from end to start. This will return lines and the breaks between\n  them as separate strings.\n  */\n  iter(dir = 1) {\n    return new RawTextCursor(this, dir);\n  }\n  /**\n  Iterate over a range of the text. When `from` > `to`, the\n  iterator will run in reverse.\n  */\n  iterRange(from, to = this.length) {\n    return new PartialTextCursor(this, from, to);\n  }\n  /**\n  Return a cursor that iterates over the given range of lines,\n  _without_ returning the line breaks between, and yielding empty\n  strings for empty lines.\n  \n  When `from` and `to` are given, they should be 1-based line numbers.\n  */\n  iterLines(from, to) {\n    let inner;\n    if (from == null) {\n      inner = this.iter();\n    } else {\n      if (to == null) to = this.lines + 1;\n      let start = this.line(from).from;\n      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n    }\n    return new LineCursor(inner);\n  }\n  /**\n  Return the document as a string, using newline characters to\n  separate lines.\n  */\n  toString() {\n    return this.sliceString(0);\n  }\n  /**\n  Convert the document to an array of lines (which can be\n  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n  */\n  toJSON() {\n    let lines = [];\n    this.flatten(lines);\n    return lines;\n  }\n  /**\n  @internal\n  */\n  constructor() {}\n  /**\n  Create a `Text` instance for the given array of lines.\n  */\n  static of(text) {\n    if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n    if (text.length == 1 && !text[0]) return Text.empty;\n    return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n  }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n  constructor(text, length = textLength(text)) {\n    super();\n    this.text = text;\n    this.length = length;\n  }\n  get lines() {\n    return this.text.length;\n  }\n  get children() {\n    return null;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let string = this.text[i],\n        end = offset + string.length;\n      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n      offset = end + 1;\n      line++;\n    }\n  }\n  decompose(from, to, target, open) {\n    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n    if (open & 1 /* Open.From */) {\n      let prev = target.pop();\n      let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n      if (joined.length <= 32 /* Tree.Branch */) {\n        target.push(new TextLeaf(joined, prev.length + text.length));\n      } else {\n        let mid = joined.length >> 1;\n        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n      }\n    } else {\n      target.push(text);\n    }\n  }\n  replace(from, to, text) {\n    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n    [from, to] = clip(this, from, to);\n    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n    let newLen = this.length + text.length - (to - from);\n    if (lines.length <= 32 /* Tree.Branch */) return new TextLeaf(lines, newLen);\n    return TextNode.from(TextLeaf.split(lines, []), newLen);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    [from, to] = clip(this, from, to);\n    let result = \"\";\n    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n      let line = this.text[i],\n        end = pos + line.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let line of this.text) target.push(line);\n  }\n  scanIdentical() {\n    return 0;\n  }\n  static split(text, target) {\n    let part = [],\n      len = -1;\n    for (let line of text) {\n      part.push(line);\n      len += line.length + 1;\n      if (part.length == 32 /* Tree.Branch */) {\n        target.push(new TextLeaf(part, len));\n        part = [];\n        len = -1;\n      }\n    }\n    if (len > -1) target.push(new TextLeaf(part, len));\n    return target;\n  }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n  constructor(children, length) {\n    super();\n    this.children = children;\n    this.length = length;\n    this.lines = 0;\n    for (let child of children) this.lines += child.lines;\n  }\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let child = this.children[i],\n        end = offset + child.length,\n        endLine = line + child.lines - 1;\n      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n      offset = end + 1;\n      line = endLine + 1;\n    }\n  }\n  decompose(from, to, target, open) {\n    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (from <= end && to >= pos) {\n        let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\n        if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);\n      }\n      pos = end + 1;\n    }\n  }\n  replace(from, to, text) {\n    [from, to] = clip(this, from, to);\n    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      // Fast path: if the change only affects one child and the\n      // child's size remains in the acceptable range, only update\n      // that child\n      if (from >= pos && to <= end) {\n        let updated = child.replace(from - pos, to - pos, text);\n        let totalLines = this.lines - child.lines + updated.lines;\n        if (updated.lines < totalLines >> 5 /* Tree.BranchShift */ - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */ + 1) {\n          let copy = this.children.slice();\n          copy[i] = updated;\n          return new TextNode(copy, this.length - (to - from) + text.length);\n        }\n        return super.replace(pos, end, updated);\n      }\n      pos = end + 1;\n    }\n    return super.replace(from, to, text);\n  }\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    [from, to] = clip(this, from, to);\n    let result = \"\";\n    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n      pos = end + 1;\n    }\n    return result;\n  }\n  flatten(target) {\n    for (let child of this.children) child.flatten(target);\n  }\n  scanIdentical(other, dir) {\n    if (!(other instanceof TextNode)) return 0;\n    let length = 0;\n    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];\n    for (;; iA += dir, iB += dir) {\n      if (iA == eA || iB == eB) return length;\n      let chA = this.children[iA],\n        chB = other.children[iB];\n      if (chA != chB) return length + chA.scanIdentical(chB, dir);\n      length += chA.length + 1;\n    }\n  }\n  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n    let lines = 0;\n    for (let ch of children) lines += ch.lines;\n    if (lines < 32 /* Tree.Branch */) {\n      let flat = [];\n      for (let ch of children) ch.flatten(flat);\n      return new TextLeaf(flat, length);\n    }\n    let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */),\n      maxChunk = chunk << 1,\n      minChunk = chunk >> 1;\n    let chunked = [],\n      currentLines = 0,\n      currentLen = -1,\n      currentChunk = [];\n    function add(child) {\n      let last;\n      if (child.lines > maxChunk && child instanceof TextNode) {\n        for (let node of child.children) add(node);\n      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n        flush();\n        chunked.push(child);\n      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */) {\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n      } else {\n        if (currentLines + child.lines > chunk) flush();\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk.push(child);\n      }\n    }\n    function flush() {\n      if (currentLines == 0) return;\n      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n      currentLen = -1;\n      currentLines = currentChunk.length = 0;\n    }\n    for (let child of children) add(child);\n    flush();\n    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n  }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n  let length = -1;\n  for (let line of text) length += line.length + 1;\n  return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n    let line = text[i],\n      end = pos + line.length;\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n    pos = end + 1;\n  }\n  return target;\n}\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n  constructor(text, dir = 1) {\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n  }\n  nextInner(skip, dir) {\n    this.done = this.lineBreak = false;\n    for (;;) {\n      let last = this.nodes.length - 1;\n      let top = this.nodes[last],\n        offsetValue = this.offsets[last],\n        offset = offsetValue >> 1;\n      let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n      if (offset == (dir > 0 ? size : 0)) {\n        if (last == 0) {\n          this.done = true;\n          this.value = \"\";\n          return this;\n        }\n        if (dir > 0) this.offsets[last - 1]++;\n        this.nodes.pop();\n        this.offsets.pop();\n      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n        this.offsets[last] += dir;\n        if (skip == 0) {\n          this.lineBreak = true;\n          this.value = \"\\n\";\n          return this;\n        }\n        skip--;\n      } else if (top instanceof TextLeaf) {\n        // Move to the next string\n        let next = top.text[offset + (dir < 0 ? -1 : 0)];\n        this.offsets[last] += dir;\n        if (next.length > Math.max(0, skip)) {\n          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n          return this;\n        }\n        skip -= next.length;\n      } else {\n        let next = top.children[offset + (dir < 0 ? -1 : 0)];\n        if (skip > next.length) {\n          skip -= next.length;\n          this.offsets[last] += dir;\n        } else {\n          if (dir < 0) this.offsets[last]--;\n          this.nodes.push(next);\n          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n        }\n      }\n    }\n  }\n  next(skip = 0) {\n    if (skip < 0) {\n      this.nextInner(-skip, -this.dir);\n      skip = this.value.length;\n    }\n    return this.nextInner(skip, this.dir);\n  }\n}\nclass PartialTextCursor {\n  constructor(text, start, end) {\n    this.value = \"\";\n    this.done = false;\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n    this.pos = start > end ? text.length : 0;\n    this.from = Math.min(start, end);\n    this.to = Math.max(start, end);\n  }\n  nextInner(skip, dir) {\n    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n      this.value = \"\";\n      this.done = true;\n      return this;\n    }\n    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n    if (skip > limit) skip = limit;\n    limit -= skip;\n    let {\n      value\n    } = this.cursor.next(skip);\n    this.pos += (value.length + skip) * dir;\n    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n    this.done = !this.value;\n    return this;\n  }\n  next(skip = 0) {\n    if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n    return this.nextInner(skip, this.cursor.dir);\n  }\n  get lineBreak() {\n    return this.cursor.lineBreak && this.value != \"\";\n  }\n}\nclass LineCursor {\n  constructor(inner) {\n    this.inner = inner;\n    this.afterBreak = true;\n    this.value = \"\";\n    this.done = false;\n  }\n  next(skip = 0) {\n    let {\n      done,\n      lineBreak,\n      value\n    } = this.inner.next(skip);\n    if (done && this.afterBreak) {\n      this.value = \"\";\n      this.afterBreak = false;\n    } else if (done) {\n      this.done = true;\n      this.value = \"\";\n    } else if (lineBreak) {\n      if (this.afterBreak) {\n        this.value = \"\";\n      } else {\n        this.afterBreak = true;\n        this.next();\n      }\n    } else {\n      this.value = value;\n      this.afterBreak = false;\n    }\n    return this;\n  }\n  get lineBreak() {\n    return false;\n  }\n}\nif (typeof Symbol != \"undefined\") {\n  Text.prototype[Symbol.iterator] = function () {\n    return this.iter();\n  };\n  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/\nclass Line {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The position of the start of the line.\n  */\n  from,\n  /**\n  The position at the end of the line (_before_ the line break,\n  or at the end of document for the last line).\n  */\n  to,\n  /**\n  This line's line number (1-based).\n  */\n  number,\n  /**\n  The line's content.\n  */\n  text) {\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  }\n  /**\n  The length of the line (not including any line break after it).\n  */\n  get length() {\n    return this.to - this.from;\n  }\n}\nfunction clip(text, from, to) {\n  from = Math.max(0, Math.min(text.length, from));\n  return [from, Math.max(from, Math.min(text.length, to))];\n}\n\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n  for (let i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;\n  return false;\n}\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n  if (pos == str.length) return pos;\n  // If pos is in the middle of a surrogate pair, move to its start\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  let prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n  while (pos < str.length) {\n    let next = codePointAt(str, pos);\n    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      let countBefore = 0,\n        i = pos - 2;\n      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n        countBefore++;\n        i -= 2;\n      }\n      if (countBefore % 2 == 0) break;else pos += 2;\n    } else {\n      break;\n    }\n  }\n  return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n  while (pos > 0) {\n    let found = nextClusterBreak(str, pos - 2, includeExtending);\n    if (found < pos) return found;\n    pos--;\n  }\n  return 0;\n}\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n  let code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  let code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/function (MapMode) {\n  /**\n  Map a position to a valid new position, even when its context\n  was deleted.\n  */\n  MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n  /**\n  Return null if deletion happens across the position.\n  */\n  MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n  /**\n  Return null if the character _before_ the position is deleted.\n  */\n  MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n  /**\n  Return null if the character _after_ the position is deleted.\n  */\n  MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n  return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n  // Sections are encoded as pairs of integers. The first is the\n  // length in the current document, and the second is -1 for\n  // unaffected sections, and the length of the replacement content\n  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n  // 0), and a replacement two positive numbers.\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  sections) {\n    this.sections = sections;\n  }\n  /**\n  The length of the document before the change.\n  */\n  get length() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i];\n    return result;\n  }\n  /**\n  The length of the document after the change.\n  */\n  get newLength() {\n    let result = 0;\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let ins = this.sections[i + 1];\n      result += ins < 0 ? this.sections[i] : ins;\n    }\n    return result;\n  }\n  /**\n  False when there are actual changes in this set.\n  */\n  get empty() {\n    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n  }\n  /**\n  Iterate over the unchanged parts left by these changes. `posA`\n  provides the position of the range in the old document, `posB`\n  the new position in the changed document.\n  */\n  iterGaps(f) {\n    for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      if (ins < 0) {\n        f(posA, posB, len);\n        posB += len;\n      } else {\n        posB += ins;\n      }\n      posA += len;\n    }\n  }\n  /**\n  Iterate over the ranges changed by these changes. (See\n  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n  variant that also provides you with the inserted text.)\n  `fromA`/`toA` provides the extent of the change in the starting\n  document, `fromB`/`toB` the extent of the replacement in the\n  changed document.\n  \n  When `individual` is true, adjacent changes (which are kept\n  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n  reported separately.\n  */\n  iterChangedRanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  /**\n  Get a description of the inverted form of these changes.\n  */\n  get invertedDesc() {\n    let sections = [];\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      if (ins < 0) sections.push(len, ins);else sections.push(ins, len);\n    }\n    return new ChangeDesc(sections);\n  }\n  /**\n  Compute the combined effect of applying another set of changes\n  after this one. The length of the document after this set should\n  match the length before `other`.\n  */\n  composeDesc(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other);\n  }\n  /**\n  Map this description, which should start with the same document\n  as `other`, over another set of changes, so that it can be\n  applied after it. When `before` is true, map as if the changes\n  in `other` happened before the ones in `this`.\n  */\n  mapDesc(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before);\n  }\n  mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n    let posA = 0,\n      posB = 0;\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++],\n        endA = posA + len;\n      if (ins < 0) {\n        if (endA > pos) return posB + (pos - posA);\n        posB += len;\n      } else {\n        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n        posB += ins;\n      }\n      posA = endA;\n    }\n    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n    return posB;\n  }\n  /**\n  Check whether these changes touch a given range. When one of the\n  changes entirely covers the range, the string `\"cover\"` is\n  returned.\n  */\n  touchesRange(from, to = from) {\n    for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++],\n        end = pos + len;\n      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n      pos = end;\n    }\n    return false;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let result = \"\";\n    for (let i = 0; i < this.sections.length;) {\n      let len = this.sections[i++],\n        ins = this.sections[i++];\n      result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n    }\n    return result;\n  }\n  /**\n  Serialize this change desc to a JSON-representable value.\n  */\n  toJSON() {\n    return this.sections;\n  }\n  /**\n  Create a change desc from its JSON representation (as produced\n  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n  */\n  static fromJSON(json) {\n    if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n    return new ChangeDesc(json);\n  }\n  /**\n  @internal\n  */\n  static create(sections) {\n    return new ChangeDesc(sections);\n  }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n  constructor(sections,\n  /**\n  @internal\n  */\n  inserted) {\n    super(sections);\n    this.inserted = inserted;\n  }\n  /**\n  Apply the changes to a document, returning the modified\n  document.\n  */\n  apply(doc) {\n    if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n    return doc;\n  }\n  mapDesc(other, before = false) {\n    return mapSet(this, other, before, true);\n  }\n  /**\n  Given the document as it existed _before_ the changes, return a\n  change set that represents the inverse of this set, which could\n  be used to go from the document created by the changes back to\n  the document as it existed before the changes.\n  */\n  invert(doc) {\n    let sections = this.sections.slice(),\n      inserted = [];\n    for (let i = 0, pos = 0; i < sections.length; i += 2) {\n      let len = sections[i],\n        ins = sections[i + 1];\n      if (ins >= 0) {\n        sections[i] = ins;\n        sections[i + 1] = len;\n        let index = i >> 1;\n        while (inserted.length < index) inserted.push(Text.empty);\n        inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n      }\n      pos += len;\n    }\n    return new ChangeSet(sections, inserted);\n  }\n  /**\n  Combine two subsequent change sets into a single set. `other`\n  must start in the document produced by `this`. If `this` goes\n  `docA` → `docB` and `other` represents `docB` → `docC`, the\n  returned value will represent the change `docA` → `docC`.\n  */\n  compose(other) {\n    return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n  }\n  /**\n  Given another change set starting in the same document, maps this\n  change set over the other, producing a new change set that can be\n  applied to the document produced by applying `other`. When\n  `before` is `true`, order changes as if `this` comes before\n  `other`, otherwise (the default) treat `other` as coming first.\n  \n  Given two changes `A` and `B`, `A.compose(B.map(A))` and\n  `B.compose(A.map(B, true))` will produce the same document. This\n  provides a basic form of [operational\n  transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n  and can be used for collaborative editing.\n  */\n  map(other, before = false) {\n    return other.empty ? this : mapSet(this, other, before, true);\n  }\n  /**\n  Iterate over the changed ranges in the document, calling `f` for\n  each, with the range in the original document (`fromA`-`toA`)\n  and the range that replaces it in the new document\n  (`fromB`-`toB`).\n  \n  When `individual` is true, adjacent changes are reported\n  separately.\n  */\n  iterChanges(f, individual = false) {\n    iterChanges(this, f, individual);\n  }\n  /**\n  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n  set.\n  */\n  get desc() {\n    return ChangeDesc.create(this.sections);\n  }\n  /**\n  @internal\n  */\n  filter(ranges) {\n    let resultSections = [],\n      resultInserted = [],\n      filteredSections = [];\n    let iter = new SectionIter(this);\n    done: for (let i = 0, pos = 0;;) {\n      let next = i == ranges.length ? 1e9 : ranges[i++];\n      while (pos < next || pos == next && iter.len == 0) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, next - pos);\n        addSection(filteredSections, len, -1);\n        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n        addSection(resultSections, len, ins);\n        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n        iter.forward(len);\n        pos += len;\n      }\n      let end = ranges[i++];\n      while (pos < end) {\n        if (iter.done) break done;\n        let len = Math.min(iter.len, end - pos);\n        addSection(resultSections, len, -1);\n        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n        iter.forward(len);\n        pos += len;\n      }\n    }\n    return {\n      changes: new ChangeSet(resultSections, resultInserted),\n      filtered: ChangeDesc.create(filteredSections)\n    };\n  }\n  /**\n  Serialize this change set to a JSON-representable value.\n  */\n  toJSON() {\n    let parts = [];\n    for (let i = 0; i < this.sections.length; i += 2) {\n      let len = this.sections[i],\n        ins = this.sections[i + 1];\n      if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n    }\n    return parts;\n  }\n  /**\n  Create a change set for the given changes, for a document of the\n  given length, using `lineSep` as line separator.\n  */\n  static of(changes, length, lineSep) {\n    let sections = [],\n      inserted = [],\n      pos = 0;\n    let total = null;\n    function flush(force = false) {\n      if (!force && !sections.length) return;\n      if (pos < length) addSection(sections, length - pos, -1);\n      let set = new ChangeSet(sections, inserted);\n      total = total ? total.compose(set.map(total)) : set;\n      sections = [];\n      inserted = [];\n      pos = 0;\n    }\n    function process(spec) {\n      if (Array.isArray(spec)) {\n        for (let sub of spec) process(sub);\n      } else if (spec instanceof ChangeSet) {\n        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n        flush();\n        total = total ? total.compose(spec.map(total)) : spec;\n      } else {\n        let {\n          from,\n          to = from,\n          insert\n        } = spec;\n        if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n        let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n        let insLen = insText.length;\n        if (from == to && insLen == 0) return;\n        if (from < pos) flush();\n        if (from > pos) addSection(sections, from - pos, -1);\n        addSection(sections, to - from, insLen);\n        addInsert(inserted, sections, insText);\n        pos = to;\n      }\n    }\n    process(changes);\n    flush(!total);\n    return total;\n  }\n  /**\n  Create an empty changeset of the given length.\n  */\n  static empty(length) {\n    return new ChangeSet(length ? [length, -1] : [], []);\n  }\n  /**\n  Create a changeset from its JSON representation (as produced by\n  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n  */\n  static fromJSON(json) {\n    if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n    let sections = [],\n      inserted = [];\n    for (let i = 0; i < json.length; i++) {\n      let part = json[i];\n      if (typeof part == \"number\") {\n        sections.push(part, -1);\n      } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n        throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n      } else if (part.length == 1) {\n        sections.push(part[0], 0);\n      } else {\n        while (inserted.length < i) inserted.push(Text.empty);\n        inserted[i] = Text.of(part.slice(1));\n        sections.push(part[0], inserted[i].length);\n      }\n    }\n    return new ChangeSet(sections, inserted);\n  }\n  /**\n  @internal\n  */\n  static createSet(sections, inserted) {\n    return new ChangeSet(sections, inserted);\n  }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n  if (len == 0 && ins <= 0) return;\n  let last = sections.length - 2;\n  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {\n    sections[last] += len;\n    sections[last + 1] += ins;\n  } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n  if (value.length == 0) return;\n  let index = sections.length - 2 >> 1;\n  if (index < values.length) {\n    values[values.length - 1] = values[values.length - 1].append(value);\n  } else {\n    while (values.length < index) values.push(Text.empty);\n    values.push(value);\n  }\n}\nfunction iterChanges(desc, f, individual) {\n  let inserted = desc.inserted;\n  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n    let len = desc.sections[i++],\n      ins = desc.sections[i++];\n    if (ins < 0) {\n      posA += len;\n      posB += len;\n    } else {\n      let endA = posA,\n        endB = posB,\n        text = Text.empty;\n      for (;;) {\n        endA += len;\n        endB += ins;\n        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n        len = desc.sections[i++];\n        ins = desc.sections[i++];\n      }\n      f(posA, endA, posB, endB, text);\n      posA = endA;\n      posB = endB;\n    }\n  }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n  // Produce a copy of setA that applies to the document after setB\n  // has been applied (assuming both start at the same document).\n  let sections = [],\n    insert = mkSet ? [] : null;\n  let a = new SectionIter(setA),\n    b = new SectionIter(setB);\n  // Iterate over both sets in parallel. inserted tracks, for changes\n  // in A that have to be processed piece-by-piece, whether their\n  // content has been inserted already, and refers to the section\n  // index.\n  for (let inserted = -1;;) {\n    if (a.ins == -1 && b.ins == -1) {\n      // Move across ranges skipped by both sets.\n      let len = Math.min(a.len, b.len);\n      addSection(sections, len, -1);\n      a.forward(len);\n      b.forward(len);\n    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n      // If there's a change in B that comes before the next change in\n      // A (ordered by start pos, then len, then before flag), skip\n      // that (and process any changes in A it covers).\n      let len = b.len;\n      addSection(sections, b.ins, -1);\n      while (len) {\n        let piece = Math.min(a.len, len);\n        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n          addSection(sections, 0, a.ins);\n          if (insert) addInsert(insert, sections, a.text);\n          inserted = a.i;\n        }\n        a.forward(piece);\n        len -= piece;\n      }\n      b.next();\n    } else if (a.ins >= 0) {\n      // Process the part of a change in A up to the start of the next\n      // non-deletion change in B (if overlapping).\n      let len = 0,\n        left = a.len;\n      while (left) {\n        if (b.ins == -1) {\n          let piece = Math.min(left, b.len);\n          len += piece;\n          left -= piece;\n          b.forward(piece);\n        } else if (b.ins == 0 && b.len < left) {\n          left -= b.len;\n          b.next();\n        } else {\n          break;\n        }\n      }\n      addSection(sections, len, inserted < a.i ? a.ins : 0);\n      if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n      inserted = a.i;\n      a.forward(a.len - left);\n    } else if (a.done && b.done) {\n      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n    } else {\n      throw new Error(\"Mismatched change set lengths\");\n    }\n  }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n  let sections = [];\n  let insert = mkSet ? [] : null;\n  let a = new SectionIter(setA),\n    b = new SectionIter(setB);\n  for (let open = false;;) {\n    if (a.done && b.done) {\n      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n    } else if (a.ins == 0) {\n      // Deletion in A\n      addSection(sections, a.len, 0, open);\n      a.next();\n    } else if (b.len == 0 && !b.done) {\n      // Insertion in B\n      addSection(sections, 0, b.ins, open);\n      if (insert) addInsert(insert, sections, b.text);\n      b.next();\n    } else if (a.done || b.done) {\n      throw new Error(\"Mismatched change set lengths\");\n    } else {\n      let len = Math.min(a.len2, b.len),\n        sectionLen = sections.length;\n      if (a.ins == -1) {\n        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n        addSection(sections, len, insB, open);\n        if (insert && insB) addInsert(insert, sections, b.text);\n      } else if (b.ins == -1) {\n        addSection(sections, a.off ? 0 : a.len, len, open);\n        if (insert) addInsert(insert, sections, a.textBit(len));\n      } else {\n        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n        if (insert && !b.off) addInsert(insert, sections, b.text);\n      }\n      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n      a.forward2(len);\n      b.forward(len);\n    }\n  }\n}\nclass SectionIter {\n  constructor(set) {\n    this.set = set;\n    this.i = 0;\n    this.next();\n  }\n  next() {\n    let {\n      sections\n    } = this.set;\n    if (this.i < sections.length) {\n      this.len = sections[this.i++];\n      this.ins = sections[this.i++];\n    } else {\n      this.len = 0;\n      this.ins = -2;\n    }\n    this.off = 0;\n  }\n  get done() {\n    return this.ins == -2;\n  }\n  get len2() {\n    return this.ins < 0 ? this.len : this.ins;\n  }\n  get text() {\n    let {\n        inserted\n      } = this.set,\n      index = this.i - 2 >> 1;\n    return index >= inserted.length ? Text.empty : inserted[index];\n  }\n  textBit(len) {\n    let {\n        inserted\n      } = this.set,\n      index = this.i - 2 >> 1;\n    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n  }\n  forward(len) {\n    if (len == this.len) this.next();else {\n      this.len -= len;\n      this.off += len;\n    }\n  }\n  forward2(len) {\n    if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {\n      this.ins -= len;\n      this.off += len;\n    }\n  }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n  constructor(\n  /**\n  The lower boundary of the range.\n  */\n  from,\n  /**\n  The upper boundary of the range.\n  */\n  to, flags) {\n    this.from = from;\n    this.to = to;\n    this.flags = flags;\n  }\n  /**\n  The anchor of the range—the side that doesn't move when you\n  extend it.\n  */\n  get anchor() {\n    return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from;\n  }\n  /**\n  The head of the range, which is moved when the range is\n  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n  */\n  get head() {\n    return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to;\n  }\n  /**\n  True when `anchor` and `head` are at the same position.\n  */\n  get empty() {\n    return this.from == this.to;\n  }\n  /**\n  If this is a cursor that is explicitly associated with the\n  character on one of its sides, this returns the side. -1 means\n  the character before its position, 1 the character after, and 0\n  means no association.\n  */\n  get assoc() {\n    return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0;\n  }\n  /**\n  The bidirectional text level associated with this cursor, if\n  any.\n  */\n  get bidiLevel() {\n    let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;\n    return level == 7 ? null : level;\n  }\n  /**\n  The goal column (stored vertical offset) associated with a\n  cursor. This is used to preserve the vertical position when\n  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n  lines of different length.\n  */\n  get goalColumn() {\n    let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;\n    return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;\n  }\n  /**\n  Map this range through a change, producing a valid range in the\n  updated document.\n  */\n  map(change, assoc = -1) {\n    let from, to;\n    if (this.empty) {\n      from = to = change.mapPos(this.from, assoc);\n    } else {\n      from = change.mapPos(this.from, 1);\n      to = change.mapPos(this.to, -1);\n    }\n    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n  }\n  /**\n  Extend this range to cover at least `from` to `to`.\n  */\n  extend(from, to = from) {\n    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n    return EditorSelection.range(this.anchor, head);\n  }\n  /**\n  Compare this range to another range.\n  */\n  eq(other, includeAssoc = false) {\n    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);\n  }\n  /**\n  Return a JSON-serializable object representing the range.\n  */\n  toJSON() {\n    return {\n      anchor: this.anchor,\n      head: this.head\n    };\n  }\n  /**\n  Convert a JSON representation of a range to a `SelectionRange`\n  instance.\n  */\n  static fromJSON(json) {\n    if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n    return EditorSelection.range(json.anchor, json.head);\n  }\n  /**\n  @internal\n  */\n  static create(from, to, flags) {\n    return new SelectionRange(from, to, flags);\n  }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n  constructor(\n  /**\n  The ranges in the selection, sorted by position. Ranges cannot\n  overlap (but they may touch, if they aren't empty).\n  */\n  ranges,\n  /**\n  The index of the _main_ range in the selection (which is\n  usually the range that was added last).\n  */\n  mainIndex) {\n    this.ranges = ranges;\n    this.mainIndex = mainIndex;\n  }\n  /**\n  Map a selection through a change. Used to adjust the selection\n  position for changes.\n  */\n  map(change, assoc = -1) {\n    if (change.empty) return this;\n    return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n  }\n  /**\n  Compare this selection to another selection. By default, ranges\n  are compared only by position. When `includeAssoc` is true,\n  cursor ranges must also have the same\n  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n  */\n  eq(other, includeAssoc = false) {\n    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n    for (let i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;\n    return true;\n  }\n  /**\n  Get the primary selection range. Usually, you should make sure\n  your code applies to _all_ ranges, by using methods like\n  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n  */\n  get main() {\n    return this.ranges[this.mainIndex];\n  }\n  /**\n  Make sure the selection only has one range. Returns a selection\n  holding only the main range from this selection.\n  */\n  asSingle() {\n    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\n  }\n  /**\n  Extend this selection with an extra range.\n  */\n  addRange(range, main = true) {\n    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n  }\n  /**\n  Replace a given range with another range, and then normalize the\n  selection to merge and sort ranges if necessary.\n  */\n  replaceRange(range, which = this.mainIndex) {\n    let ranges = this.ranges.slice();\n    ranges[which] = range;\n    return EditorSelection.create(ranges, this.mainIndex);\n  }\n  /**\n  Convert this selection to an object that can be serialized to\n  JSON.\n  */\n  toJSON() {\n    return {\n      ranges: this.ranges.map(r => r.toJSON()),\n      main: this.mainIndex\n    };\n  }\n  /**\n  Create a selection from a JSON representation.\n  */\n  static fromJSON(json) {\n    if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n    return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);\n  }\n  /**\n  Create a selection holding a single range.\n  */\n  static single(anchor, head = anchor) {\n    return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n  }\n  /**\n  Sort and merge the given set of ranges, creating a valid\n  selection.\n  */\n  static create(ranges, mainIndex = 0) {\n    if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n    for (let pos = 0, i = 0; i < ranges.length; i++) {\n      let range = ranges[i];\n      if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n      pos = range.to;\n    }\n    return new EditorSelection(ranges, mainIndex);\n  }\n  /**\n  Create a cursor selection range at the given position. You can\n  safely ignore the optional arguments in most situations.\n  */\n  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */);\n  }\n  /**\n  Create a selection range.\n  */\n  static range(anchor, head, goalColumn, bidiLevel) {\n    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */ | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n    return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);\n  }\n  /**\n  @internal\n  */\n  static normalized(ranges, mainIndex = 0) {\n    let main = ranges[mainIndex];\n    ranges.sort((a, b) => a.from - b.from);\n    mainIndex = ranges.indexOf(main);\n    for (let i = 1; i < ranges.length; i++) {\n      let range = ranges[i],\n        prev = ranges[i - 1];\n      if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n        let from = prev.from,\n          to = Math.max(range.to, prev.to);\n        if (i <= mainIndex) mainIndex--;\n        ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n      }\n    }\n    return new EditorSelection(ranges, mainIndex);\n  }\n}\nfunction checkSelection(selection, docLength) {\n  for (let range of selection.ranges) if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/\nclass Facet {\n  constructor(\n  /**\n  @internal\n  */\n  combine,\n  /**\n  @internal\n  */\n  compareInput,\n  /**\n  @internal\n  */\n  compare, isStatic, enables) {\n    this.combine = combine;\n    this.compareInput = compareInput;\n    this.compare = compare;\n    this.isStatic = isStatic;\n    /**\n    @internal\n    */\n    this.id = nextID++;\n    this.default = combine([]);\n    this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n  }\n  /**\n  Returns a facet reader for this facet, which can be used to\n  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n  */\n  get reader() {\n    return this;\n  }\n  /**\n  Define a new facet.\n  */\n  static define(config = {}) {\n    return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n  }\n  /**\n  Returns an extension that adds the given value to this facet.\n  */\n  of(value) {\n    return new FacetProvider([], this, 0 /* Provider.Static */, value);\n  }\n  /**\n  Create an extension that computes a value for the facet from a\n  state. You must take care to declare the parts of the state that\n  this value depends on, since your function is only called again\n  for a new state when one of those parts changed.\n  \n  In cases where your value depends only on a single field, you'll\n  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n  */\n  compute(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\n  }\n  /**\n  Create an extension that computes zero or more values for this\n  facet from a state.\n  */\n  computeN(deps, get) {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n    return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\n  }\n  from(field, get) {\n    if (!get) get = x => x;\n    return this.compute([field], state => get(state.field(field)));\n  }\n}\nfunction sameArray(a, b) {\n  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n  constructor(dependencies, facet, type, value) {\n    this.dependencies = dependencies;\n    this.facet = facet;\n    this.type = type;\n    this.value = value;\n    this.id = nextID++;\n  }\n  dynamicSlot(addresses) {\n    var _a;\n    let getter = this.value;\n    let compare = this.facet.compareInput;\n    let id = this.id,\n      idx = addresses[id] >> 1,\n      multi = this.type == 2 /* Provider.Multi */;\n    let depDoc = false,\n      depSel = false,\n      depAddrs = [];\n    for (let dep of this.dependencies) {\n      if (dep == \"doc\") depDoc = true;else if (dep == \"selection\") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n    }\n    return {\n      create(state) {\n        state.values[idx] = getter(state);\n        return 1 /* SlotStatus.Changed */;\n      },\n      update(state, tr) {\n        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n          let newVal = getter(state);\n          if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n            state.values[idx] = newVal;\n            return 1 /* SlotStatus.Changed */;\n          }\n        }\n        return 0;\n      },\n      reconfigure: (state, oldState) => {\n        let newVal,\n          oldAddr = oldState.config.address[id];\n        if (oldAddr != null) {\n          let oldVal = getAddr(oldState, oldAddr);\n          if (this.dependencies.every(dep => {\n            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n            state.values[idx] = oldVal;\n            return 0;\n          }\n        } else {\n          newVal = getter(state);\n        }\n        state.values[idx] = newVal;\n        return 1 /* SlotStatus.Changed */;\n      }\n    };\n  }\n}\nfunction compareArray(a, b, compare) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false;\n  return true;\n}\nfunction ensureAll(state, addrs) {\n  let changed = false;\n  for (let addr of addrs) if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */) changed = true;\n  return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n  let providerAddrs = providers.map(p => addresses[p.id]);\n  let providerTypes = providers.map(p => p.type);\n  let dynamic = providerAddrs.filter(p => !(p & 1));\n  let idx = addresses[facet.id] >> 1;\n  function get(state) {\n    let values = [];\n    for (let i = 0; i < providerAddrs.length; i++) {\n      let value = getAddr(state, providerAddrs[i]);\n      if (providerTypes[i] == 2 /* Provider.Multi */) for (let val of value) values.push(val);else values.push(value);\n    }\n    return facet.combine(values);\n  }\n  return {\n    create(state) {\n      for (let addr of providerAddrs) ensureAddr(state, addr);\n      state.values[idx] = get(state);\n      return 1 /* SlotStatus.Changed */;\n    },\n    update(state, tr) {\n      if (!ensureAll(state, dynamic)) return 0;\n      let value = get(state);\n      if (facet.compare(value, state.values[idx])) return 0;\n      state.values[idx] = value;\n      return 1 /* SlotStatus.Changed */;\n    },\n    reconfigure(state, oldState) {\n      let depChanged = ensureAll(state, providerAddrs);\n      let oldProviders = oldState.config.facets[facet.id],\n        oldValue = oldState.facet(facet);\n      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n        state.values[idx] = oldValue;\n        return 0;\n      }\n      let value = get(state);\n      if (facet.compare(value, oldValue)) {\n        state.values[idx] = oldValue;\n        return 0;\n      }\n      state.values[idx] = value;\n      return 1 /* SlotStatus.Changed */;\n    }\n  };\n}\nconst initField = /*@__PURE__*/Facet.define({\n  static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n  constructor(\n  /**\n  @internal\n  */\n  id, createF, updateF, compareF,\n  /**\n  @internal\n  */\n  spec) {\n    this.id = id;\n    this.createF = createF;\n    this.updateF = updateF;\n    this.compareF = compareF;\n    this.spec = spec;\n    /**\n    @internal\n    */\n    this.provides = undefined;\n  }\n  /**\n  Define a state field.\n  */\n  static define(config) {\n    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n    if (config.provide) field.provides = config.provide(field);\n    return field;\n  }\n  create(state) {\n    let init = state.facet(initField).find(i => i.field == this);\n    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n  }\n  /**\n  @internal\n  */\n  slot(addresses) {\n    let idx = addresses[this.id] >> 1;\n    return {\n      create: state => {\n        state.values[idx] = this.create(state);\n        return 1 /* SlotStatus.Changed */;\n      },\n      update: (state, tr) => {\n        let oldVal = state.values[idx];\n        let value = this.updateF(oldVal, tr);\n        if (this.compareF(oldVal, value)) return 0;\n        state.values[idx] = value;\n        return 1 /* SlotStatus.Changed */;\n      },\n      reconfigure: (state, oldState) => {\n        if (oldState.config.address[this.id] != null) {\n          state.values[idx] = oldState.field(this);\n          return 0;\n        }\n        state.values[idx] = this.create(state);\n        return 1 /* SlotStatus.Changed */;\n      }\n    };\n  }\n  /**\n  Returns an extension that enables this field and overrides the\n  way it is initialized. Can be useful when you need to provide a\n  non-default starting value for the field.\n  */\n  init(create) {\n    return [this, initField.of({\n      field: this,\n      create\n    })];\n  }\n  /**\n  State field instances can be used as\n  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n  given state.\n  */\n  get extension() {\n    return this;\n  }\n}\nconst Prec_ = {\n  lowest: 4,\n  low: 3,\n  default: 2,\n  high: 1,\n  highest: 0\n};\nfunction prec(value) {\n  return ext => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n  /**\n  The highest precedence level, for extensions that should end up\n  near the start of the precedence ordering.\n  */\n  highest: /*@__PURE__*/prec(Prec_.highest),\n  /**\n  A higher-than-default precedence, for extensions that should\n  come before those with default precedence.\n  */\n  high: /*@__PURE__*/prec(Prec_.high),\n  /**\n  The default precedence, which is also used for extensions\n  without an explicit precedence.\n  */\n  default: /*@__PURE__*/prec(Prec_.default),\n  /**\n  A lower-than-default precedence.\n  */\n  low: /*@__PURE__*/prec(Prec_.low),\n  /**\n  The lowest precedence level. Meant for things that should end up\n  near the end of the extension order.\n  */\n  lowest: /*@__PURE__*/prec(Prec_.lowest)\n};\nclass PrecExtension {\n  constructor(inner, prec) {\n    this.inner = inner;\n    this.prec = prec;\n  }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n  /**\n  Create an instance of this compartment to add to your [state\n  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n  */\n  of(ext) {\n    return new CompartmentInstance(this, ext);\n  }\n  /**\n  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n  reconfigures this compartment.\n  */\n  reconfigure(content) {\n    return Compartment.reconfigure.of({\n      compartment: this,\n      extension: content\n    });\n  }\n  /**\n  Get the current content of the compartment in the state, or\n  `undefined` if it isn't present.\n  */\n  get(state) {\n    return state.config.compartments.get(this);\n  }\n}\nclass CompartmentInstance {\n  constructor(compartment, inner) {\n    this.compartment = compartment;\n    this.inner = inner;\n  }\n}\nclass Configuration {\n  constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\n    this.base = base;\n    this.compartments = compartments;\n    this.dynamicSlots = dynamicSlots;\n    this.address = address;\n    this.staticValues = staticValues;\n    this.facets = facets;\n    this.statusTemplate = [];\n    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\n  }\n  staticFacet(facet) {\n    let addr = this.address[facet.id];\n    return addr == null ? facet.default : this.staticValues[addr >> 1];\n  }\n  static resolve(base, compartments, oldState) {\n    let fields = [];\n    let facets = Object.create(null);\n    let newCompartments = new Map();\n    for (let ext of flatten(base, compartments, newCompartments)) {\n      if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n    }\n    let address = Object.create(null);\n    let staticValues = [];\n    let dynamicSlots = [];\n    for (let field of fields) {\n      address[field.id] = dynamicSlots.length << 1;\n      dynamicSlots.push(a => field.slot(a));\n    }\n    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n    for (let id in facets) {\n      let providers = facets[id],\n        facet = providers[0].facet;\n      let oldProviders = oldFacets && oldFacets[id] || [];\n      if (providers.every(p => p.type == 0 /* Provider.Static */)) {\n        address[facet.id] = staticValues.length << 1 | 1;\n        if (sameArray(oldProviders, providers)) {\n          staticValues.push(oldState.facet(facet));\n        } else {\n          let value = facet.combine(providers.map(p => p.value));\n          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n        }\n      } else {\n        for (let p of providers) {\n          if (p.type == 0 /* Provider.Static */) {\n            address[p.id] = staticValues.length << 1 | 1;\n            staticValues.push(p.value);\n          } else {\n            address[p.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => p.dynamicSlot(a));\n          }\n        }\n        address[facet.id] = dynamicSlots.length << 1;\n        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n      }\n    }\n    let dynamic = dynamicSlots.map(f => f(address));\n    return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n  }\n}\nfunction flatten(extension, compartments, newCompartments) {\n  let result = [[], [], [], [], []];\n  let seen = new Map();\n  function inner(ext, prec) {\n    let known = seen.get(ext);\n    if (known != null) {\n      if (known <= prec) return;\n      let found = result[known].indexOf(ext);\n      if (found > -1) result[known].splice(found, 1);\n      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n    }\n    seen.set(ext, prec);\n    if (Array.isArray(ext)) {\n      for (let e of ext) inner(e, prec);\n    } else if (ext instanceof CompartmentInstance) {\n      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n      let content = compartments.get(ext.compartment) || ext.inner;\n      newCompartments.set(ext.compartment, content);\n      inner(content, prec);\n    } else if (ext instanceof PrecExtension) {\n      inner(ext.inner, ext.prec);\n    } else if (ext instanceof StateField) {\n      result[prec].push(ext);\n      if (ext.provides) inner(ext.provides, prec);\n    } else if (ext instanceof FacetProvider) {\n      result[prec].push(ext);\n      if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n    } else {\n      let content = ext.extension;\n      if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n      inner(content, prec);\n    }\n  }\n  inner(extension, Prec_.default);\n  return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n  if (addr & 1) return 2 /* SlotStatus.Computed */;\n  let idx = addr >> 1;\n  let status = state.status[idx];\n  if (status == 4 /* SlotStatus.Computing */) throw new Error(\"Cyclic dependency between fields and/or facets\");\n  if (status & 2 /* SlotStatus.Computed */) return status;\n  state.status[idx] = 4 /* SlotStatus.Computing */;\n  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n  return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n  combine: values => values.some(v => v),\n  static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : undefined,\n  static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The annotation type.\n  */\n  type,\n  /**\n  The value of this annotation.\n  */\n  value) {\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Define a new type of annotation.\n  */\n  static define() {\n    return new AnnotationType();\n  }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n  /**\n  Create an instance of this annotation.\n  */\n  of(value) {\n    return new Annotation(this, value);\n  }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n  /**\n  @internal\n  */\n  constructor(\n  // The `any` types in these function types are there to work\n  // around TypeScript issue #37631, where the type guard on\n  // `StateEffect.is` mysteriously stops working when these properly\n  // have type `Value`.\n  /**\n  @internal\n  */\n  map) {\n    this.map = map;\n  }\n  /**\n  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n  type.\n  */\n  of(value) {\n    return new StateEffect(this, value);\n  }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  type,\n  /**\n  The value of this effect.\n  */\n  value) {\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Map this effect through a position mapping. Will return\n  `undefined` when that ends up deleting the effect.\n  */\n  map(mapping) {\n    let mapped = this.type.map(this.value, mapping);\n    return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n  }\n  /**\n  Tells you whether this effect object is of a given\n  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n  */\n  is(type) {\n    return this.type == type;\n  }\n  /**\n  Define a new effect type. The type parameter indicates the type\n  of values that his effect holds. It should be a type that\n  doesn't include `undefined`, since that is used in\n  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n  removed.\n  */\n  static define(spec = {}) {\n    return new StateEffectType(spec.map || (v => v));\n  }\n  /**\n  Map an array of effects through a change set.\n  */\n  static mapEffects(effects, mapping) {\n    if (!effects.length) return effects;\n    let result = [];\n    for (let effect of effects) {\n      let mapped = effect.map(mapping);\n      if (mapped) result.push(mapped);\n    }\n    return result;\n  }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/\nclass Transaction {\n  constructor(\n  /**\n  The state from which the transaction starts.\n  */\n  startState,\n  /**\n  The document changes made by this transaction.\n  */\n  changes,\n  /**\n  The selection set by this transaction, or undefined if it\n  doesn't explicitly set a selection.\n  */\n  selection,\n  /**\n  The effects added to the transaction.\n  */\n  effects,\n  /**\n  @internal\n  */\n  annotations,\n  /**\n  Whether the selection should be scrolled into view after this\n  transaction is dispatched.\n  */\n  scrollIntoView) {\n    this.startState = startState;\n    this.changes = changes;\n    this.selection = selection;\n    this.effects = effects;\n    this.annotations = annotations;\n    this.scrollIntoView = scrollIntoView;\n    /**\n    @internal\n    */\n    this._doc = null;\n    /**\n    @internal\n    */\n    this._state = null;\n    if (selection) checkSelection(selection, changes.newLength);\n    if (!annotations.some(a => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n  }\n  /**\n  @internal\n  */\n  static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n  }\n  /**\n  The new document produced by the transaction. Contrary to\n  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n  force the entire new state to be computed right away, so it is\n  recommended that [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n  when they need to look at the new document.\n  */\n  get newDoc() {\n    return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n  }\n  /**\n  The new selection produced by the transaction. If\n  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n  current selection through the changes made by the transaction.\n  */\n  get newSelection() {\n    return this.selection || this.startState.selection.map(this.changes);\n  }\n  /**\n  The new state created by the transaction. Computed on demand\n  (but retained for subsequent access), so it is recommended not to\n  access it in [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n  */\n  get state() {\n    if (!this._state) this.startState.applyTransaction(this);\n    return this._state;\n  }\n  /**\n  Get the value of the given annotation type, if any.\n  */\n  annotation(type) {\n    for (let ann of this.annotations) if (ann.type == type) return ann.value;\n    return undefined;\n  }\n  /**\n  Indicates whether the transaction changed the document.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Indicates whether this transaction reconfigures the state\n  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n  with a top-level configuration\n  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n  */\n  get reconfigured() {\n    return this.startState.config != this.state.config;\n  }\n  /**\n  Returns true if the transaction has a [user\n  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n  or more specific than `event`. For example, if the transaction\n  has `\"select.pointer\"` as user event, `\"select\"` and\n  `\"select.pointer\"` will match it.\n  */\n  isUserEvent(event) {\n    let e = this.annotation(Transaction.userEvent);\n    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n  }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n  let result = [];\n  for (let iA = 0, iB = 0;;) {\n    let from, to;\n    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n      from = a[iA++];\n      to = a[iA++];\n    } else if (iB < b.length) {\n      from = b[iB++];\n      to = b[iB++];\n    } else return result;\n    if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;\n  }\n}\nfunction mergeTransaction(a, b, sequential) {\n  var _a;\n  let mapForA, mapForB, changes;\n  if (sequential) {\n    mapForA = b.changes;\n    mapForB = ChangeSet.empty(b.changes.length);\n    changes = a.changes.compose(b.changes);\n  } else {\n    mapForA = b.changes.map(a.changes);\n    mapForB = a.changes.mapDesc(b.changes, true);\n    changes = a.changes.compose(mapForA);\n  }\n  return {\n    changes,\n    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n    scrollIntoView: a.scrollIntoView || b.scrollIntoView\n  };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n  let sel = spec.selection,\n    annotations = asArray(spec.annotations);\n  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n  return {\n    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n    effects: asArray(spec.effects),\n    annotations,\n    scrollIntoView: !!spec.scrollIntoView\n  };\n}\nfunction resolveTransaction(state, specs, filter) {\n  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n  if (specs.length && specs[0].filter === false) filter = false;\n  for (let i = 1; i < specs.length; i++) {\n    if (specs[i].filter === false) filter = false;\n    let seq = !!specs[i].sequential;\n    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n  }\n  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n  return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n  let state = tr.startState;\n  // Change filters\n  let result = true;\n  for (let filter of state.facet(changeFilter)) {\n    let value = filter(tr);\n    if (value === false) {\n      result = false;\n      break;\n    }\n    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n  }\n  if (result !== true) {\n    let changes, back;\n    if (result === false) {\n      back = tr.changes.invertedDesc;\n      changes = ChangeSet.empty(state.doc.length);\n    } else {\n      let filtered = tr.changes.filter(result);\n      changes = filtered.changes;\n      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n    }\n    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n  }\n  // Transaction filters\n  let filters = state.facet(transactionFilter);\n  for (let i = filters.length - 1; i >= 0; i--) {\n    let filtered = filters[i](tr);\n    if (filtered instanceof Transaction) tr = filtered;else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];else tr = resolveTransaction(state, asArray(filtered), false);\n  }\n  return tr;\n}\nfunction extendTransaction(tr) {\n  let state = tr.startState,\n    extenders = state.facet(transactionExtender),\n    spec = tr;\n  for (let i = extenders.length - 1; i >= 0; i--) {\n    let extension = extenders[i](tr);\n    if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n  }\n  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n  return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/function (CharCategory) {\n  /**\n  Word characters.\n  */\n  CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n  /**\n  Whitespace.\n  */\n  CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n  /**\n  Anything else.\n  */\n  CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n  return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n  wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n  if (wordChar) return wordChar.test(str);\n  for (let i = 0; i < str.length; i++) {\n    let ch = str[i];\n    if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n  }\n  return false;\n}\nfunction makeCategorizer(wordChars) {\n  return char => {\n    if (!/\\S/.test(char)) return CharCategory.Space;\n    if (hasWordChar(char)) return CharCategory.Word;\n    for (let i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n    return CharCategory.Other;\n  };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n  constructor(\n  /**\n  @internal\n  */\n  config,\n  /**\n  The current document.\n  */\n  doc,\n  /**\n  The current selection.\n  */\n  selection,\n  /**\n  @internal\n  */\n  values, computeSlot, tr) {\n    this.config = config;\n    this.doc = doc;\n    this.selection = selection;\n    this.values = values;\n    this.status = config.statusTemplate.slice();\n    this.computeSlot = computeSlot;\n    // Fill in the computed state immediately, so that further queries\n    // for it made during the update return this state\n    if (tr) tr._state = this;\n    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);\n    this.computeSlot = null;\n  }\n  field(field, require = true) {\n    let addr = this.config.address[field.id];\n    if (addr == null) {\n      if (require) throw new RangeError(\"Field is not present in this state\");\n      return undefined;\n    }\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  /**\n  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n  can be passed. Unless\n  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n  are assumed to start in the _current_ document (not the document\n  produced by previous specs), and its\n  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n  to the document created by its _own_ changes. The resulting\n  transaction contains the combined effect of all the different\n  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n  specs take precedence over earlier ones.\n  */\n  update(...specs) {\n    return resolveTransaction(this, specs, true);\n  }\n  /**\n  @internal\n  */\n  applyTransaction(tr) {\n    let conf = this.config,\n      {\n        base,\n        compartments\n      } = conf;\n    for (let effect of tr.effects) {\n      if (effect.is(Compartment.reconfigure)) {\n        if (conf) {\n          compartments = new Map();\n          conf.compartments.forEach((val, key) => compartments.set(key, val));\n          conf = null;\n        }\n        compartments.set(effect.value.compartment, effect.value.extension);\n      } else if (effect.is(StateEffect.reconfigure)) {\n        conf = null;\n        base = effect.value;\n      } else if (effect.is(StateEffect.appendConfig)) {\n        conf = null;\n        base = asArray(base).concat(effect.value);\n      }\n    }\n    let startValues;\n    if (!conf) {\n      conf = Configuration.resolve(base, compartments, this);\n      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\n      startValues = intermediateState.values;\n    } else {\n      startValues = tr.startState.values.slice();\n    }\n    let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n    new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);\n  }\n  /**\n  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n  replaces every selection range with the given content.\n  */\n  replaceSelection(text) {\n    if (typeof text == \"string\") text = this.toText(text);\n    return this.changeByRange(range => ({\n      changes: {\n        from: range.from,\n        to: range.to,\n        insert: text\n      },\n      range: EditorSelection.cursor(range.from + text.length)\n    }));\n  }\n  /**\n  Create a set of changes and a new selection by running the given\n  function for each range in the active selection. The function\n  can return an optional set of changes (in the coordinate space\n  of the start document), plus an updated range (in the coordinate\n  space of the document produced by the call's own changes). This\n  method will merge all the changes and ranges into a single\n  changeset and selection, and return it as a [transaction\n  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n  */\n  changeByRange(f) {\n    let sel = this.selection;\n    let result1 = f(sel.ranges[0]);\n    let changes = this.changes(result1.changes),\n      ranges = [result1.range];\n    let effects = asArray(result1.effects);\n    for (let i = 1; i < sel.ranges.length; i++) {\n      let result = f(sel.ranges[i]);\n      let newChanges = this.changes(result.changes),\n        newMapped = newChanges.map(changes);\n      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);\n      let mapBy = changes.mapDesc(newChanges, true);\n      ranges.push(result.range.map(mapBy));\n      changes = changes.compose(newMapped);\n      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n    }\n    return {\n      changes,\n      selection: EditorSelection.create(ranges, sel.mainIndex),\n      effects\n    };\n  }\n  /**\n  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n  description, taking the state's document length and line\n  separator into account.\n  */\n  changes(spec = []) {\n    if (spec instanceof ChangeSet) return spec;\n    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n  }\n  /**\n  Using the state's [line\n  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n  */\n  toText(string) {\n    return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n  }\n  /**\n  Return the given range of the document as a string.\n  */\n  sliceDoc(from = 0, to = this.doc.length) {\n    return this.doc.sliceString(from, to, this.lineBreak);\n  }\n  /**\n  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n  */\n  facet(facet) {\n    let addr = this.config.address[facet.id];\n    if (addr == null) return facet.default;\n    ensureAddr(this, addr);\n    return getAddr(this, addr);\n  }\n  /**\n  Convert this state to a JSON-serializable object. When custom\n  fields should be serialized, you can pass them in as an object\n  mapping property names (in the resulting object, which should\n  not use `doc` or `selection`) to fields.\n  */\n  toJSON(fields) {\n    let result = {\n      doc: this.sliceDoc(),\n      selection: this.selection.toJSON()\n    };\n    if (fields) for (let prop in fields) {\n      let value = fields[prop];\n      if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n    }\n    return result;\n  }\n  /**\n  Deserialize a state from its JSON representation. When custom\n  fields should be deserialized, pass the same object you passed\n  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n  third argument.\n  */\n  static fromJSON(json, config = {}, fields) {\n    if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n    let fieldInit = [];\n    if (fields) for (let prop in fields) {\n      if (Object.prototype.hasOwnProperty.call(json, prop)) {\n        let field = fields[prop],\n          value = json[prop];\n        fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n      }\n    }\n    return EditorState.create({\n      doc: json.doc,\n      selection: EditorSelection.fromJSON(json.selection),\n      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n    });\n  }\n  /**\n  Create a new state. You'll usually only need this when\n  initializing an editor—updated states are created by applying\n  transactions.\n  */\n  static create(config = {}) {\n    let configuration = Configuration.resolve(config.extensions || [], new Map());\n    let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n    checkSelection(selection, doc.length);\n    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n    return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\n  }\n  /**\n  The size (in columns) of a tab in the document, determined by\n  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n  */\n  get tabSize() {\n    return this.facet(EditorState.tabSize);\n  }\n  /**\n  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n  string for this state.\n  */\n  get lineBreak() {\n    return this.facet(EditorState.lineSeparator) || \"\\n\";\n  }\n  /**\n  Returns true when the editor is\n  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n  */\n  get readOnly() {\n    return this.facet(readOnly);\n  }\n  /**\n  Look up a translation for the given phrase (via the\n  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n  original string if no translation is found.\n  \n  If additional arguments are passed, they will be inserted in\n  place of markers like `$1` (for the first value) and `$2`, etc.\n  A single `$` is equivalent to `$1`, and `$$` will produce a\n  literal dollar sign.\n  */\n  phrase(phrase, ...insert) {\n    for (let map of this.facet(EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n      phrase = map[phrase];\n      break;\n    }\n    if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\n      if (i == \"$\") return \"$\";\n      let n = +(i || 1);\n      return !n || n > insert.length ? m : insert[n - 1];\n    });\n    return phrase;\n  }\n  /**\n  Find the values for a given language data field, provided by the\n  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n  \n  Examples of language data fields are...\n  \n  - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n    comment syntax.\n  - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n    for providing language-specific completion sources.\n  - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n    characters that should be considered part of words in this\n    language.\n  - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n    bracket closing behavior.\n  */\n  languageDataAt(name, pos, side = -1) {\n    let values = [];\n    for (let provider of this.facet(languageData)) {\n      for (let result of provider(this, pos, side)) {\n        if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n      }\n    }\n    return values;\n  }\n  /**\n  Return a function that can categorize strings (expected to\n  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n  into one of:\n  \n   - Word (contains an alphanumeric character or a character\n     explicitly listed in the local language's `\"wordChars\"`\n     language data, which should be a string)\n   - Space (contains only whitespace)\n   - Other (anything else)\n  */\n  charCategorizer(at) {\n    return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n  }\n  /**\n  Find the word at the given position, meaning the range\n  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n  around it. If no word characters are adjacent to the position,\n  this returns null.\n  */\n  wordAt(pos) {\n    let {\n      text,\n      from,\n      length\n    } = this.doc.lineAt(pos);\n    let cat = this.charCategorizer(pos);\n    let start = pos - from,\n      end = pos - from;\n    while (start > 0) {\n      let prev = findClusterBreak(text, start, false);\n      if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n      start = prev;\n    }\n    while (end < length) {\n      let next = findClusterBreak(text, end);\n      if (cat(text.slice(end, next)) != CharCategory.Word) break;\n      end = next;\n    }\n    return start == end ? null : EditorSelection.range(start + from, end + from);\n  }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n  combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define({\n  compare(a, b) {\n    let kA = Object.keys(a),\n      kB = Object.keys(b);\n    return kA.length == kB.length && kA.every(k => a[k] == b[k]);\n  }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults,\n// Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n  let result = {};\n  for (let config of configs) for (let key of Object.keys(config)) {\n    let value = config[key],\n      current = result[key];\n    if (current === undefined) result[key] = value;else if (current === value || value === undefined) ; // No conflict\n    else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);else throw new Error(\"Config merge conflict for field \" + key);\n  }\n  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key];\n  return result;\n}\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n  /**\n  Compare this value with another value. Used when comparing\n  rangesets. The default implementation compares by identity.\n  Unless you are only creating a fixed number of unique instances\n  of your value type, it is a good idea to implement this\n  properly.\n  */\n  eq(other) {\n    return this == other;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n  */\n  range(from, to = from) {\n    return Range.create(from, to, this);\n  }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n  constructor(\n  /**\n  The range's start position.\n  */\n  from,\n  /**\n  Its end position.\n  */\n  to,\n  /**\n  The value associated with this range.\n  */\n  value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n  /**\n  @internal\n  */\n  static create(from, to, value) {\n    return new Range(from, to, value);\n  }\n}\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n  constructor(from, to, value,\n  // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n  get length() {\n    return this.to[this.to.length - 1];\n  }\n  // Find the index of the given position and side. Use the ranges'\n  // `from` pos when `end == false`, `to` when `end == true`.\n  findIndex(pos, side, end, startAt = 0) {\n    let arr = end ? this.to : this.from;\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid;else lo = mid + 1;\n    }\n  }\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n  map(offset, changes) {\n    let value = [],\n      from = [],\n      to = [],\n      newPos = -1,\n      maxPoint = -1;\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i],\n        curFrom = this.from[i] + offset,\n        curTo = this.to[i] + offset,\n        newFrom,\n        newTo;\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n        if (val.startSide != val.endSide) {\n          newTo = changes.mapPos(curFrom, val.endSide);\n          if (newTo < newFrom) continue;\n        }\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n  constructor(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk,\n  /**\n  @internal\n  */\n  nextLayer,\n  /**\n  @internal\n  */\n  maxPoint) {\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n  static create(chunkPos, chunk, nextLayer, maxPoint) {\n    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n  }\n  /**\n  @internal\n  */\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n  get size() {\n    if (this.isEmpty) return 0;\n    let size = this.nextLayer.size;\n    for (let chunk of this.chunk) size += chunk.value.length;\n    return size;\n  }\n  /**\n  @internal\n  */\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (Note: The type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n  update(updateSpec) {\n    let {\n      add = [],\n      sort = false,\n      filterFrom = 0,\n      filterTo = this.length\n    } = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add = add.slice().sort(cmpRange);\n    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0),\n      i = 0,\n      spill = [];\n    let builder = new RangeSetBuilder();\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n        }\n        cur.next();\n      }\n    }\n    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n  map(changes) {\n    if (changes.empty || this.isEmpty) return this;\n    let chunks = [],\n      chunkPos = [],\n      maxPoint = -1;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {\n          mapped,\n          pos\n        } = chunk.map(start, changes);\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n  between(from, to, f) {\n    if (this.isEmpty) return;\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n        chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n    this.nextLayer.between(from, to, f);\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n  iter(from = 0) {\n    return HeapCursor.from([this]).goto(from);\n  }\n  /**\n  @internal\n  */\n  get isEmpty() {\n    return this.nextLayer == this;\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n  static iter(sets, from = 0) {\n    return HeapCursor.from(sets).goto(from);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n  static compare(oldSets, newSets,\n  /**\n  This indicates how the underlying data changed between these\n  ranges, and is needed to synchronize the iteration.\n  */\n  textDiff, comparator,\n  /**\n  Can be used to ignore all non-point ranges, and points below\n  the given size. When -1, all ranges are compared.\n  */\n  minPointSize = -1) {\n    let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b, textDiff);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  /**\n  Compare the contents of two groups of range sets, returning true\n  if they are equivalent in the given range.\n  */\n  static eq(oldSets, newSets, from = 0, to) {\n    if (to == null) to = 1000000000 /* C.Far */ - 1;\n    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n    if (a.length != b.length) return false;\n    if (!a.length) return true;\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),\n      sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n    for (;;) {\n      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n      if (sideA.to > to) return true;\n      sideA.next();\n      sideB.next();\n    }\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n  of the iteration.\n  */\n  static spans(sets, from, to, iterator,\n  /**\n  When given and greater than -1, only points of at least this\n  size are taken into account.\n  */\n  minPointSize = -1) {\n    let cursor = new SpanCursor(sets, null, minPointSize).goto(from),\n      pos = from;\n    let openRanges = cursor.openStart;\n    for (;;) {\n      let curTo = Math.min(cursor.to, to);\n      if (cursor.point) {\n        let active = cursor.activeForPoint(cursor.to);\n        let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n        openRanges = Math.min(cursor.openEnd(curTo), active.length);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, openRanges);\n        openRanges = cursor.openEnd(curTo);\n      }\n      if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n      pos = cursor.to;\n      cursor.next();\n    }\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n  static of(ranges, sort = false) {\n    let build = new RangeSetBuilder();\n    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);\n    return build.finish();\n  }\n  /**\n  Join an array of range sets into a single set.\n  */\n  static join(sets) {\n    if (!sets.length) return RangeSet.empty;\n    let result = sets[sets.length - 1];\n    for (let i = sets.length - 2; i >= 0; i--) {\n      for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer) result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n    }\n    return result;\n  }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n    let cur = ranges[i];\n    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n    prev = cur;\n  }\n  return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/\nclass RangeSetBuilder {\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000 /* C.Far */;\n    this.lastTo = -1000000000 /* C.Far */;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  /**\n  @internal\n  */\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250 /* C.ChunkSize */) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  /**\n  @internal\n  */\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  /**\n  @internal\n  */\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null; // Make sure further `add` calls produce errors\n    return result;\n  }\n}\nfunction findSharedChunks(a, b, textDiff) {\n  let inA = new Map();\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n  let shared = new Set();\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) {\n    let known = inA.get(set.chunk[i]);\n    if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n  }\n  return shared;\n}\nclass LayerCursor {\n  constructor(layer, skip, minPoint, rank = 0) {\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n    if (this.chunkIndex < this.layer.chunk.length) {\n      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n    }\n    this.next();\n  }\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000 /* C.Far */;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex],\n          chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n        this.setRangeIndex(this.rangeIndex + 1);\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n  setRangeIndex(index) {\n    if (index == this.layer.chunk[this.chunkIndex].value.length) {\n      this.chunkIndex++;\n      if (this.skip) {\n        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n      }\n      this.rangeIndex = 0;\n    } else {\n      this.rangeIndex = index;\n    }\n  }\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n  }\n}\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n  static from(sets, skip = null, minPoint = -1) {\n    let heap = [];\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    for (let cur of this.heap) cur.goto(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000 /* C.Far */;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n}\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\nclass SpanCursor {\n  constructor(sets, skip, minPoint) {\n    this.minPoint = minPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1;\n    // A currently active point range, if any\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000 /* C.Far */;\n    this.endSide = 0;\n    // The amount of open active ranges at the start of the iterator.\n    // Not including points.\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n  goto(pos, side = -1000000000 /* C.Far */) {\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n    this.cursor.forward(pos, side);\n  }\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  addActive(trackOpen) {\n    let i = 0,\n      {\n        value,\n        to,\n        rank\n      } = this.cursor;\n    // Organize active marks by rank first, then by size\n    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0) i++;\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n  // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n  next() {\n    let from = this.to,\n      wasPoint = this.point;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null;\n    for (;;) {\n      let a = this.minActive;\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000 /* C.Far */;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n        if (!nextVal.point) {\n          // Opening a range\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n          // Ignore any non-empty points that end precisely at the end of the prev point\n          this.cursor.next();\n        } else {\n          // New point\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          this.cursor.next();\n          this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n    if (trackOpen) {\n      this.openStart = 0;\n      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--) this.openStart++;\n    }\n  }\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n    for (let i = this.active.length - 1; i >= 0; i--) {\n      if (this.activeRank[i] < this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n    }\n    return active.reverse();\n  }\n  openEnd(to) {\n    let open = 0;\n    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;\n    return open;\n  }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB,\n    dPos = startB - startA;\n  for (;;) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to,\n      clipEnd = Math.min(end, endB);\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  return true;\n}\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n  array.pop();\n}\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n  array[index] = value;\n}\nfunction findMinIndex(value, array) {\n  let found = -1,\n    foundPos = 1000000000 /* C.Far */;\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n  return found;\n}\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n  let n = 0;\n  for (let i = 0; i < to;) {\n    if (string.charCodeAt(i) == 9) {\n      n += tabSize - n % tabSize;\n      i++;\n    } else {\n      n++;\n      i = findClusterBreak(string, i);\n    }\n  }\n  return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n  for (let i = 0, n = 0;;) {\n    if (n >= col) return i;\n    if (i == string.length) break;\n    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n    i = findClusterBreak(string, i);\n  }\n  return strict === true ? -1 : string.length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzPzhjOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRvY3VtZW50cy4gQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKGZyb20sIHRvLCBwYXJ0cywgMCk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgMSksIGVuZCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAtMSk7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgYS5uZXh0KHNraXApO1xuICAgICAgICAgICAgYi5uZXh0KHNraXApO1xuICAgICAgICAgICAgc2tpcCA9IDA7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSB8fCBwb3MgPj0gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICAgIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICB0aGVtIGFzIHNlcGFyYXRlIHN0cmluZ3MuXG4gICAgKi9cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcbiAgICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAgICovXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBjdXJzb3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiByYW5nZSBvZiBsaW5lcyxcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcbiAgICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgICBcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxuICAgICovXG4gICAgaXRlckxpbmVzKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmxpbmUoZnJvbSkuZnJvbTtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyUmFuZ2Uoc3RhcnQsIE1hdGgubWF4KHN0YXJ0LCB0byA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogdG8gPD0gMSA/IDAgOiB0aGlzLmxpbmUodG8gLSAxKS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUN1cnNvcihpbm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcsIHVzaW5nIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgIHNlcGFyYXRlIGxpbmVzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5mbGF0dGVuKGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihmbGF0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IE1hdGgubWF4KDMyIC8qIFRyZWUuQnJhbmNoICovLCBsaW5lcyA+PiA1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rLmxlbmd0aCA9PSAxID8gY3VycmVudENodW5rWzBdIDogVGV4dE5vZGUuZnJvbShjdXJyZW50Q2h1bmssIGN1cnJlbnRMZW4pKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAtMTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNodW5rZWQubGVuZ3RoID09IDEgPyBjaHVua2VkWzBdIDogbmV3IFRleHROb2RlKGNodW5rZWQsIGxlbmd0aCk7XG4gICAgfVxufVxuVGV4dC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgVGV4dExlYWYoW1wiXCJdLCAwKTtcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xuICAgIGxldCBsZW5ndGggPSAtMTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMCwgZmlyc3QgPSB0cnVlOyBpIDwgdGV4dC5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoZnJvbSAtIHBvcyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGFwcGVuZFRleHQodGV4dCwgW1wiXCJdLCBmcm9tLCB0byk7XG59XG5jbGFzcyBSYXdUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBkaXIgPSAxKSB7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdGV4dF07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtkaXIgPiAwID8gMSA6ICh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyB0ZXh0LnRleHQubGVuZ3RoIDogdGV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDFdO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMubm9kZXNbbGFzdF0sIG9mZnNldFZhbHVlID0gdGhpcy5vZmZzZXRzW2xhc3RdLCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSA+PiAxO1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IChkaXIgPiAwID8gc2l6ZSA6IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdCAtIDFdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2Zmc2V0VmFsdWUgJiAxKSA9PSAoZGlyID4gMCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLnRleHRbb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IE1hdGgubWF4KDAsIHNraXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBza2lwID09IDAgPyBuZXh0IDogZGlyID4gMCA/IG5leHQuc2xpY2Uoc2tpcCkgOiBuZXh0LnNsaWNlKDAsIG5leHQubGVuZ3RoIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5bb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGRpciA+IDAgPyAxIDogKG5leHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IG5leHQudGV4dC5sZW5ndGggOiBuZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJbm5lcigtc2tpcCwgKC10aGlzLmRpcikpO1xuICAgICAgICAgICAgc2tpcCA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmRpcik7XG4gICAgfVxufVxuY2xhc3MgUGFydGlhbFRleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRleHQsIHN0YXJ0ID4gZW5kID8gLTEgOiAxKTtcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydCA+IGVuZCA/IHRleHQubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1heChzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHRoaXMucG9zIDw9IHRoaXMuZnJvbSA6IHRoaXMucG9zID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMCwgZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGxpbWl0ID0gZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy5mcm9tIDogdGhpcy50byAtIHRoaXMucG9zO1xuICAgICAgICBpZiAoc2tpcCA+IGxpbWl0KVxuICAgICAgICAgICAgc2tpcCA9IGxpbWl0O1xuICAgICAgICBsaW1pdCAtPSBza2lwO1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gdGhpcy5jdXJzb3IubmV4dChza2lwKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gKHZhbHVlLmxlbmd0aCArIHNraXApICogZGlyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUubGVuZ3RoIDw9IGxpbWl0ID8gdmFsdWUgOiBkaXIgPCAwID8gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gbGltaXQpIDogdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICB0aGlzLmRvbmUgPSAhdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWF4KHNraXAsIHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA+IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5taW4oc2tpcCwgdGhpcy50byAtIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuY3Vyc29yLmRpcik7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgJiYgdGhpcy52YWx1ZSAhPSBcIlwiOyB9XG59XG5jbGFzcyBMaW5lQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBsZXQgeyBkb25lLCBsaW5lQnJlYWssIHZhbHVlIH0gPSB0aGlzLmlubmVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmIChkb25lICYmIHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFRleHQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZXIoKTsgfTtcbiAgICBSYXdUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gUGFydGlhbFRleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBMaW5lQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbi8qKlxuVGhpcyB0eXBlIGRlc2NyaWJlcyBhIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBJdCBpcyBjcmVhdGVkXG5vbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dC5saW5lQXQpLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcbiAgICBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGlzIGxpbmUncyBsaW5lIG51bWJlciAoMS1iYXNlZCkuXG4gICAgKi9cbiAgICBudW1iZXIsIFxuICAgIC8qKlxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cbiAgICAqL1xuICAgIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTsgfVxufVxuZnVuY3Rpb24gY2xpcCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZyb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZnJvbSkpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5tYXgoZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHRvKSldO1xufVxuXG4vLyBDb21wcmVzc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHcmFwaGVtZV9DbHVzdGVyX0JyZWFrPUV4dGVuZFxuLy8gaW5mb3JtYXRpb24gZnJvbVxuLy8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvMTMuMC4wL3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dC5cbi8vIEVhY2ggcGFpciBvZiBlbGVtZW50cyByZXByZXNlbnRzIGEgcmFuZ2UsIGFzIGFuIG9mZmV0IGZyb20gdGhlXG4vLyBwcmV2aW91cyByYW5nZSBhbmQgYSBsZW5ndGguIE51bWJlcnMgYXJlIGluIGJhc2UtMzYsIHdpdGggdGhlIGVtcHR5XG4vLyBzdHJpbmcgYmVpbmcgYSBzaG9ydGhhbmQgZm9yIDEuXG5sZXQgZXh0ZW5kID0gLypAX19QVVJFX18qL1wibGMsMzQsN24sNyw3YiwxOSwsLCwyLCwyLCwsMjAsYiwxYyxsLGcsLDJ0LDcsMiw2LDIsMiwsNCx6LCx1LHIsMmosYiwxbSw5LDksLG8sNCwsOSwsMywsNSwxNywzLDNiLGYsLHcsMWosLCwsNCw4LDQsLDMsNyxhLDIsdCwsMW0sLCwsMiw0LDgsLDksLGEsMixxLCwyLDIsMWwsLDQsMiw0LDIsMiwzLDMsLHUsMiwzLCxiLDIsMWwsLDQsNSwsMiw0LCxrLDIsbSw2LCwsMW0sLCwyLCw0LDgsLDcsMyxhLDIsdSwsMW4sLCwsYywsOSwsMTQsLDMsLDFsLDMsNSwzLCw0LDcsMixiLDIsdCwsMW0sLDIsLDIsLDMsLDUsMiw3LDIsYiwyLHMsMiwxbCwyLCwsMiw0LDgsLDksLGEsMix0LCwyMCwsNCwsMiwzLCwsOCwsMjksLDIsNyxjLDgsMnEsLDIsOSxiLDYsMjIsMixyLCwsLCwsMWosZSwsNSwsMiw1LGIsLDEwLDksLDJ1LDQsLDYsLDIsMiwyLHAsMiw0LDMsZyw0LGQsLDIsMiw2LCxmLCxqaiwzLHFhLDMsdCwzLHQsMix1LDIsMXMsMiwsNyw4LCwyLGIsOSwsMTksMywzYiwyLHksLDNhLDMsNCwyLDksLDYsMyw2MywyLDIsLDFtLCwsNywsLCwsMiw4LDYsYSwyLCwxYyxoLDFyLDQsMWMsNywsLDUsLDE0LDksYywyLHcsNCwyLDIsLDMsMWssLCwyLDMsLCwzLDFtLDgsMiwyLDQ4LDMsLGQsLDcsNCwsNiwsMywyLDVpLDFtLCw1LGVrLCw1Zix4LDJkYSwzLDN4LCwybyx3LGZlLDYsMngsMixuOXcsNCwsYSx3LDIsMjgsMiw3aywsMywsNCwscCwyLDUsLDQ3LDIscSxpLGQsLDEyLDgscCxiLDFhLDMsMWMsLDIsNCwyLDIsMTMsLDF2LDYsMiwyLDIsMixjLCw4LCwxYiwsMWYsLCwzLDIsMiw1LDIsLCwxNiwyLDgsLDZtLCwyLCw0LCxmbjQsLGtoLGcsZyxnLGE2LDIsZ3QsLDZhLCw0NSw1LDFhZSwzLCwyLDUsNCwxNCwzLDQsLDRsLDIsZngsNCxhciwyLDQ5LGIsNHcsLDFpLGYsMWssMywxZCw0LDIsMiwxeCwzLDEwLDUsLDgsMXEsLGMsMiwxZyw5LGEsNCwyLCwybiwzLDIsLCwyLDYsLDRnLCwzLDgsbCwyLDFsLDIsLCwsLG0sLGUsNywzLDUsNWYsOCwyLDMsLCxuLCwyOSwsMiw2LCwsMiwsLDIsLDIsNmosLDIsNCw2LDIsLDIsciwyLDJkLDgsMiwsLDIsMnksLCwsMiw2LCwsMnQsMywyLDQsLDUsNzcsOSwsMiw2dCwsYSwyLCwsNCwsNDAsNCwyLDIsNCwsdyxhLDE0LDYsMiw0LDgsLDksNiwyLDMsMWEsZCwsMixiYSw3LCw2LCwsMmEsbSwyLDcsLDIsLDIsM2UsNiwzLCwsMiwsNywsLDIwLDIsMywsLCw5biwyLGYwYiw1LDFuLDcsdDQsLDFyLDQsMjksLGY1aywyLDQzcSwsLDMsNCw1LDgsOCwyLDcsdSw0LDQ0LDMsMWl6LDFqLDQsMWUsOCwsZSwsbSw1LCxmLDExcyw3LCxoLDIsNywsMiwsNSw3OSw3LGM1LDQsMTVzLDcsMzEsNywyNDAsNSxneDdrLDJvLDNrLDZvXCIuc3BsaXQoXCIsXCIpLm1hcChzID0+IHMgPyBwYXJzZUludChzLCAzNikgOiAxKTtcbi8vIENvbnZlcnQgb2Zmc2V0cyBpbnRvIGFic29sdXRlIHZhbHVlc1xuZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpKyspXG4gICAgZXh0ZW5kW2ldICs9IGV4dGVuZFtpIC0gMV07XG5mdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY29kZSkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZXh0ZW5kW2ldID4gY29kZSlcbiAgICAgICAgICAgIHJldHVybiBleHRlbmRbaSAtIDFdIDw9IGNvZGU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWdpb25hbEluZGljYXRvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHgxRjFFNiAmJiBjb2RlIDw9IDB4MUYxRkY7XG59XG5jb25zdCBaV0ogPSAweDIwMGQ7XG4vKipcblJldHVybnMgYSBuZXh0IGdyYXBoZW1lIGNsdXN0ZXIgYnJlYWsgX2FmdGVyXyAobm90IGVxdWFsIHRvKVxuYHBvc2AsIGlmIGBmb3J3YXJkYCBpcyB0cnVlLCBvciBiZWZvcmUgb3RoZXJ3aXNlLiBSZXR1cm5zIGBwb3NgXG5pdHNlbGYgaWYgbm8gZnVydGhlciBjbHVzdGVyIGJyZWFrIGlzIGF2YWlsYWJsZSBpbiB0aGUgc3RyaW5nLlxuTW92ZXMgYWNyb3NzIHN1cnJvZ2F0ZSBwYWlycywgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgKHdoZW5cbmBpbmNsdWRlRXh0ZW5kaW5nYCBpcyB0cnVlKSwgY2hhcmFjdGVycyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoXG5qb2luZXJzLCBhbmQgZmxhZyBlbW9qaS5cbiovXG5mdW5jdGlvbiBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgcG9zLCBmb3J3YXJkID0gdHJ1ZSwgaW5jbHVkZUV4dGVuZGluZyA9IHRydWUpIHtcbiAgICByZXR1cm4gKGZvcndhcmQgPyBuZXh0Q2x1c3RlckJyZWFrIDogcHJldkNsdXN0ZXJCcmVhaykoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpO1xufVxuZnVuY3Rpb24gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xuICAgIGlmIChwb3MgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAvLyBJZiBwb3MgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLCBtb3ZlIHRvIGl0cyBzdGFydFxuICAgIGlmIChwb3MgJiYgc3Vycm9nYXRlTG93KHN0ci5jaGFyQ29kZUF0KHBvcykpICYmIHN1cnJvZ2F0ZUhpZ2goc3RyLmNoYXJDb2RlQXQocG9zIC0gMSkpKVxuICAgICAgICBwb3MtLTtcbiAgICBsZXQgcHJldiA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICBwb3MgKz0gY29kZVBvaW50U2l6ZShwcmV2KTtcbiAgICB3aGlsZSAocG9zIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHByZXYgPT0gWldKIHx8IG5leHQgPT0gWldKIHx8IGluY2x1ZGVFeHRlbmRpbmcgJiYgaXNFeHRlbmRpbmdDaGFyKG5leHQpKSB7XG4gICAgICAgICAgICBwb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIHByZXYgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnaW9uYWxJbmRpY2F0b3IobmV4dCkpIHtcbiAgICAgICAgICAgIGxldCBjb3VudEJlZm9yZSA9IDAsIGkgPSBwb3MgLSAyO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGVQb2ludEF0KHN0ciwgaSkpKSB7XG4gICAgICAgICAgICAgICAgY291bnRCZWZvcmUrKztcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRCZWZvcmUgJSAyID09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gcHJldkNsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MgLSAyLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbiAgICAgICAgaWYgKGZvdW5kIDwgcG9zKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICBwb3MtLTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBzdXJyb2dhdGVMb3coY2gpIHsgcmV0dXJuIGNoID49IDB4REMwMCAmJiBjaCA8IDB4RTAwMDsgfVxuZnVuY3Rpb24gc3Vycm9nYXRlSGlnaChjaCkgeyByZXR1cm4gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwOyB9XG4vKipcbkZpbmQgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIGEgc3RyaW5nIChsaWtlIHRoZVxuW2Bjb2RlUG9pbnRBdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9jb2RlUG9pbnRBdClcbnN0cmluZyBtZXRob2QpLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0ciwgcG9zKSB7XG4gICAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUhpZ2goY29kZTApIHx8IHBvcyArIDEgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmICghc3Vycm9nYXRlTG93KGNvZGUxKSlcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMDtcbn1cbi8qKlxuR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XG5yZXNwcmVzZW50cyBpdCAobGlrZVxuW2BTdHJpbmcuZnJvbUNvZGVQb2ludGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9mcm9tQ29kZVBvaW50KSkuXG4qL1xuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDEwMjMpICsgMHhkYzAwKTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiBwb3NpdGlvbnMgYSBjaGFyYWN0ZXIgdGFrZXMgdXAgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuY29uc3QgRGVmYXVsdFNwbGl0ID0gL1xcclxcbj98XFxuLztcbi8qKlxuRGlzdGluZ3Vpc2hlcyBkaWZmZXJlbnQgd2F5cyBpbiB3aGljaCBwb3NpdGlvbnMgY2FuIGJlIG1hcHBlZC5cbiovXG52YXIgTWFwTW9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcE1vZGUpIHtcbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0byBhIHZhbGlkIG5ldyBwb3NpdGlvbiwgZXZlbiB3aGVuIGl0cyBjb250ZXh0XG4gICAgd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgZGVsZXRpb24gaGFwcGVucyBhY3Jvc3MgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tEZWxcIl0gPSAxXSA9IFwiVHJhY2tEZWxcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9iZWZvcmVfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tCZWZvcmVcIl0gPSAyXSA9IFwiVHJhY2tCZWZvcmVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9hZnRlcl8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0FmdGVyXCJdID0gM10gPSBcIlRyYWNrQWZ0ZXJcIjtcbnJldHVybiBNYXBNb2RlfSkoTWFwTW9kZSB8fCAoTWFwTW9kZSA9IHt9KSk7XG4vKipcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXG50aGF0IGRvZXNuJ3Qgc3RvcmUgdGhlIGluc2VydGVkIHRleHQuIEFzIHN1Y2gsIGl0IGNhbid0IGJlXG5hcHBsaWVkLCBidXQgaXMgY2hlYXBlciB0byBzdG9yZSBhbmQgbWFuaXB1bGF0ZS5cbiovXG5jbGFzcyBDaGFuZ2VEZXNjIHtcbiAgICAvLyBTZWN0aW9ucyBhcmUgZW5jb2RlZCBhcyBwYWlycyBvZiBpbnRlZ2Vycy4gVGhlIGZpcnN0IGlzIHRoZVxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXG4gICAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgICAvLyBvdGhlcndpc2UuIFNvIGFuIGluc2VydGlvbiB3b3VsZCBiZSAoMCwgbj4wKSwgYSBkZWxldGlvbiAobj4wLFxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zZWN0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBuZXdMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGYWxzZSB3aGVuIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBpbiB0aGlzIHNldC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMiAmJiB0aGlzLnNlY3Rpb25zWzFdIDwgMDsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXG4gICAgcHJvdmlkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSByYW5nZSBpbiB0aGUgb2xkIGRvY3VtZW50LCBgcG9zQmBcbiAgICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAgICovXG4gICAgaXRlckdhcHMoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGYocG9zQSwgcG9zQiwgbGVuKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gICAgW2BDaGFuZ2VTZXQuaXRlckNoYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC5pdGVyQ2hhbmdlcykgZm9yIGFcbiAgICB2YXJpYW50IHRoYXQgYWxzbyBwcm92aWRlcyB5b3Ugd2l0aCB0aGUgaW5zZXJ0ZWQgdGV4dC4pXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gICAgZG9jdW1lbnQsIGBmcm9tQmAvYHRvQmAgdGhlIGV4dGVudCBvZiB0aGUgcmVwbGFjZW1lbnQgaW4gdGhlXG4gICAgY2hhbmdlZCBkb2N1bWVudC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYG90aGVyYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYHRoaXNgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBNYXBNb2RlLlNpbXBsZSkge1xuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmRBID0gcG9zQSArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NCICsgKHBvcyAtIHBvc0EpO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPT0gTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0JlZm9yZSAmJiBwb3NBIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MgfHwgZW5kQSA9PSBwb3MgJiYgYXNzb2MgPCAwICYmICFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBwb3NBKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xuICAgICAgICByZXR1cm4gcG9zQjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGVzZSBjaGFuZ2VzIHRvdWNoIGEgZ2l2ZW4gcmFuZ2UuIFdoZW4gb25lIG9mIHRoZVxuICAgIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICAgIHJldHVybmVkLlxuICAgICovXG4gICAgdG91Y2hlc1JhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kID0gcG9zICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwICYmIHBvcyA8PSB0byAmJiBlbmQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgICBieSBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24ubGVuZ3RoICUgMiB8fCBqc29uLnNvbWUoYSA9PiB0eXBlb2YgYSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZURlc2NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHNlY3Rpb25zKSB7IHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7IH1cbn1cbi8qKlxuQSBjaGFuZ2Ugc2V0IHJlcHJlc2VudHMgYSBncm91cCBvZiBtb2RpZmljYXRpb25zIHRvIGEgZG9jdW1lbnQuIEl0XG5zdG9yZXMgdGhlIGRvY3VtZW50IGxlbmd0aCwgYW5kIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZG9jdW1lbnRzXG53aXRoIGV4YWN0bHkgdGhhdCBsZW5ndGguXG4qL1xuY2xhc3MgQ2hhbmdlU2V0IGV4dGVuZHMgQ2hhbmdlRGVzYyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluc2VydGVkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBjaGFuZ2VzIHRvIGEgZG9jdW1lbnQsIHJldHVybmluZyB0aGUgbW9kaWZpZWRcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgKGZyb21BLCB0b0EsIGZyb21CLCBfdG9CLCB0ZXh0KSA9PiBkb2MgPSBkb2MucmVwbGFjZShmcm9tQiwgZnJvbUIgKyAodG9BIC0gZnJvbUEpLCB0ZXh0KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXG4gICAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gICAgYmUgdXNlZCB0byBnbyBmcm9tIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IHRoZSBjaGFuZ2VzIGJhY2sgdG9cbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHNlY3Rpb25zW2ldLCBpbnMgPSBzZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpXSA9IGlucztcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpICsgMV0gPSBsZW47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tYmluZSB0d28gc3Vic2VxdWVudCBjaGFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC4gYG90aGVyYFxuICAgIG11c3Qgc3RhcnQgaW4gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGB0aGlzYC4gSWYgYHRoaXNgIGdvZXNcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgICByZXR1cm5lZCB2YWx1ZSB3aWxsIHJlcHJlc2VudCB0aGUgY2hhbmdlIGBkb2NBYCDihpIgYGRvY0NgLlxuICAgICovXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYW5vdGhlciBjaGFuZ2Ugc2V0IHN0YXJ0aW5nIGluIHRoZSBzYW1lIGRvY3VtZW50LCBtYXBzIHRoaXNcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxuICAgIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgICBgYmVmb3JlYCBpcyBgdHJ1ZWAsIG9yZGVyIGNoYW5nZXMgYXMgaWYgYHRoaXNgIGNvbWVzIGJlZm9yZVxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxuICAgIFxuICAgIEdpdmVuIHR3byBjaGFuZ2VzIGBBYCBhbmQgYEJgLCBgQS5jb21wb3NlKEIubWFwKEEpKWAgYW5kXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xuICAgIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgICB0cmFuc2Zvcm1hdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0aW9uYWxfdHJhbnNmb3JtYXRpb24pLFxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuICAgICovXG4gICAgbWFwKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbiB0aGUgZG9jdW1lbnQsIGNhbGxpbmcgYGZgIGZvclxuICAgIGVhY2gsIHdpdGggdGhlIHJhbmdlIGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudCAoYGZyb21BYC1gdG9BYClcbiAgICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxuICAgIChgZnJvbUJgLWB0b0JgKS5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICAgIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtjaGFuZ2UgZGVzY3JpcHRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYykgZm9yIHRoaXMgY2hhbmdlXG4gICAgc2V0LlxuICAgICovXG4gICAgZ2V0IGRlc2MoKSB7IHJldHVybiBDaGFuZ2VEZXNjLmNyZWF0ZSh0aGlzLnNlY3Rpb25zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyKHJhbmdlcykge1xuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgaXRlciA9IG5ldyBTZWN0aW9uSXRlcih0aGlzKTtcbiAgICAgICAgZG9uZTogZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBuZXh0IHx8IHBvcyA9PSBuZXh0ICYmIGl0ZXIubGVuID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgbmV4dCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCBpbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIGVuZCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwKTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBDaGFuZ2VEZXNjLmNyZWF0ZShmaWx0ZXJlZFNlY3Rpb25zKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxlbik7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiBjaGFuZ2VzLCBmb3IgYSBkb2N1bWVudCBvZiB0aGVcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihjaGFuZ2VzLCBsZW5ndGgsIGxpbmVTZXApIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xuICAgICAgICAgICAgbGV0IHNldCA9IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNldC5tYXAodG90YWwpKSA6IHNldDtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBpbnNlcnRlZCA9IFtdO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Moc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5sZW5ndGggIT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7c3BlYy5sZW5ndGh9LCBleHBlY3RlZCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzcGVjLm1hcCh0b3RhbCkpIDogc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvID0gZnJvbSwgaW5zZXJ0IH0gPSBzcGVjO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPiBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zVGV4dCA9ICFpbnNlcnQgPyBUZXh0LmVtcHR5IDogdHlwZW9mIGluc2VydCA9PSBcInN0cmluZ1wiID8gVGV4dC5vZihpbnNlcnQuc3BsaXQobGluZVNlcCB8fCBEZWZhdWx0U3BsaXQpKSA6IGluc2VydDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zTGVuID0gaW5zVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgaW5zTGVuID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgZnJvbSAtIHBvcywgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHRvIC0gZnJvbSwgaW5zTGVuKTtcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0ZWQsIHNlY3Rpb25zLCBpbnNUZXh0KTtcbiAgICAgICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKGNoYW5nZXMpO1xuICAgICAgICBmbHVzaCghdG90YWwpO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBjaGFuZ2VzZXQgb2YgdGhlIGdpdmVuIGxlbmd0aC5cbiAgICAqL1xuICAgIHN0YXRpYyBlbXB0eShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQobGVuZ3RoID8gW2xlbmd0aCwgLTFdIDogW10sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlc2V0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkIGJ5XG4gICAgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IGpzb25baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGFydCkgfHwgdHlwZW9mIHBhcnRbMF0gIT0gXCJudW1iZXJcIiB8fCBwYXJ0LnNvbWUoKGUsIGkpID0+IGkgJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkW2ldID0gVGV4dC5vZihwYXJ0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIGluc2VydGVkW2ldLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zLCBmb3JjZUpvaW4gPSBmYWxzZSkge1xuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsYXN0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMjtcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICBlbHNlIGlmIChsZW4gPT0gMCAmJiBzZWN0aW9uc1tsYXN0XSA9PSAwKVxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIGVsc2UgaWYgKGZvcmNlSm9pbikge1xuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG59XG5mdW5jdGlvbiBhZGRJbnNlcnQodmFsdWVzLCBzZWN0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgaW5kZXggPSAoc2VjdGlvbnMubGVuZ3RoIC0gMikgPj4gMTtcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLmFwcGVuZCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyQ2hhbmdlcyhkZXNjLCBmLCBpbmRpdmlkdWFsKSB7XG4gICAgbGV0IGluc2VydGVkID0gZGVzYy5pbnNlcnRlZDtcbiAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDAsIGkgPSAwOyBpIDwgZGVzYy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK10sIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZW5kQSA9IHBvc0EsIGVuZEIgPSBwb3NCLCB0ZXh0ID0gVGV4dC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBlbmRBICs9IGxlbjtcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zICYmIGluc2VydGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5hcHBlbmQoaW5zZXJ0ZWRbKGkgLSAyKSA+PiAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwgfHwgaSA9PSBkZXNjLnNlY3Rpb25zLmxlbmd0aCB8fCBkZXNjLnNlY3Rpb25zW2kgKyAxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgICAgICBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHBvc0EsIGVuZEEsIHBvc0IsIGVuZEIsIHRleHQpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgICAgICBwb3NCID0gZW5kQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFNldChzZXRBLCBzZXRCLCBiZWZvcmUsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICAvLyBQcm9kdWNlIGEgY29weSBvZiBzZXRBIHRoYXQgYXBwbGllcyB0byB0aGUgZG9jdW1lbnQgYWZ0ZXIgc2V0QlxuICAgIC8vIGhhcyBiZWVuIGFwcGxpZWQgKGFzc3VtaW5nIGJvdGggc3RhcnQgYXQgdGhlIHNhbWUgZG9jdW1lbnQpLlxuICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYm90aCBzZXRzIGluIHBhcmFsbGVsLiBpbnNlcnRlZCB0cmFja3MsIGZvciBjaGFuZ2VzXG4gICAgLy8gaW4gQSB0aGF0IGhhdmUgdG8gYmUgcHJvY2Vzc2VkIHBpZWNlLWJ5LXBpZWNlLCB3aGV0aGVyIHRoZWlyXG4gICAgLy8gY29udGVudCBoYXMgYmVlbiBpbnNlcnRlZCBhbHJlYWR5LCBhbmQgcmVmZXJzIHRvIHRoZSBzZWN0aW9uXG4gICAgLy8gaW5kZXguXG4gICAgZm9yIChsZXQgaW5zZXJ0ZWQgPSAtMTs7KSB7XG4gICAgICAgIGlmIChhLmlucyA9PSAtMSAmJiBiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgLy8gTW92ZSBhY3Jvc3MgcmFuZ2VzIHNraXBwZWQgYnkgYm90aCBzZXRzLlxuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuLCBiLmxlbik7XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5pbnMgPj0gMCAmJiAoYS5pbnMgPCAwIHx8IGluc2VydGVkID09IGEuaSB8fCBhLm9mZiA9PSAwICYmIChiLmxlbiA8IGEubGVuIHx8IGIubGVuID09IGEubGVuICYmICFiZWZvcmUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNoYW5nZSBpbiBCIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBuZXh0IGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gQSAob3JkZXJlZCBieSBzdGFydCBwb3MsIHRoZW4gbGVuLCB0aGVuIGJlZm9yZSBmbGFnKSwgc2tpcFxuICAgICAgICAgICAgLy8gdGhhdCAoYW5kIHByb2Nlc3MgYW55IGNoYW5nZXMgaW4gQSBpdCBjb3ZlcnMpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IGIubGVuO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcbiAgICAgICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihhLmxlbiwgbGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5pbnMgPj0gMCAmJiBpbnNlcnRlZCA8IGEuaSAmJiBhLmxlbiA8PSBwaWVjZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBhLmlucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgbGVuIC09IHBpZWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPj0gMCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGFydCBvZiBhIGNoYW5nZSBpbiBBIHVwIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbm9uLWRlbGV0aW9uIGNoYW5nZSBpbiBCIChpZiBvdmVybGFwcGluZykuXG4gICAgICAgICAgICBsZXQgbGVuID0gMCwgbGVmdCA9IGEubGVuO1xuICAgICAgICAgICAgd2hpbGUgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4obGVmdCwgYi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGIuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IDAgJiYgYi5sZW4gPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gYi5sZW47XG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNlcnRlZCA8IGEuaSA/IGEuaW5zIDogMCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc2VydGVkIDwgYS5pKVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICBhLmZvcndhcmQoYS5sZW4gLSBsZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNldHMoc2V0QSwgc2V0QiwgbWtTZXQgPSBmYWxzZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGxldCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICBmb3IgKGxldCBvcGVuID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gMCkgeyAvLyBEZWxldGlvbiBpbiBBXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLmxlbiwgMCwgb3Blbik7XG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmxlbiA9PSAwICYmICFiLmRvbmUpIHsgLy8gSW5zZXJ0aW9uIGluIEJcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgfHwgYi5kb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbjIsIGIubGVuKSwgc2VjdGlvbkxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNCID0gYi5pbnMgPT0gLTEgPyAtMSA6IGIub2ZmID8gMCA6IGIuaW5zO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zQiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNCKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGxlbiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dEJpdChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBiLm9mZiA/IDAgOiBiLmlucywgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiAhYi5vZmYpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlbiA9IChhLmlucyA+IGxlbiB8fCBiLmlucyA+PSAwICYmIGIubGVuID4gbGVuKSAmJiAob3BlbiB8fCBzZWN0aW9ucy5sZW5ndGggPiBzZWN0aW9uTGVuKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZDIobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2VjdGlvbkl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldCkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB7IHNlY3Rpb25zIH0gPSB0aGlzLnNldDtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgICAgICB0aGlzLmlucyA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9uZSgpIHsgcmV0dXJuIHRoaXMuaW5zID09IC0yOyB9XG4gICAgZ2V0IGxlbjIoKSB7IHJldHVybiB0aGlzLmlucyA8IDAgPyB0aGlzLmxlbiA6IHRoaXMuaW5zOyB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCA/IFRleHQuZW1wdHkgOiBpbnNlcnRlZFtpbmRleF07XG4gICAgfVxuICAgIHRleHRCaXQobGVuKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCAmJiAhbGVuID8gVGV4dC5lbXB0eVxuICAgICAgICAgICAgOiBpbnNlcnRlZFtpbmRleF0uc2xpY2UodGhpcy5vZmYsIGxlbiA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5vZmYgKyBsZW4pO1xuICAgIH1cbiAgICBmb3J3YXJkKGxlbikge1xuICAgICAgICBpZiAobGVuID09IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcndhcmQyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbnMgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkEgc2luZ2xlIHNlbGVjdGlvbiByYW5nZS4gV2hlblxuW2BhbGxvd011bHRpcGxlU2VsZWN0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxubXVsdGlwbGUgcmFuZ2VzLiBCeSBkZWZhdWx0LCBzZWxlY3Rpb25zIGhvbGQgZXhhY3RseSBvbmUgcmFuZ2UuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG8sIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZeKAlHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XG4gICAgZXh0ZW5kIGl0LlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgVGhlIGhlYWQgb2YgdGhlIHJhbmdlLCB3aGljaCBpcyBtb3ZlZCB3aGVuIHRoZSByYW5nZSBpc1xuICAgIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy5mcm9tIDogdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiBgYW5jaG9yYCBhbmQgYGhlYWRgIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIGN1cnNvciB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gICAgdGhlIGNoYXJhY3RlciBiZWZvcmUgaXRzIHBvc2l0aW9uLCAxIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIsIGFuZCAwXG4gICAgbWVhbnMgbm8gYXNzb2NpYXRpb24uXG4gICAgKi9cbiAgICBnZXQgYXNzb2MoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gPyAtMSA6IHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDcgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSA3ID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkICYmXG4gICAgICAgICAgICAoIWluY2x1ZGVBc3NvYyB8fCAhdGhpcy5lbXB0eSB8fCB0aGlzLmFzc29jID09IG90aGVyLmFzc29jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgZmxhZ3MpO1xuICAgIH1cbn1cbi8qKlxuQW4gZWRpdG9yIHNlbGVjdGlvbiBob2xkcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb24gcmFuZ2VzLlxuKi9cbmNsYXNzIEVkaXRvclNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5tYWluSW5kZXggPSBtYWluSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHNlbGVjdGlvbiB0aHJvdWdoIGEgY2hhbmdlLiBVc2VkIHRvIGFkanVzdCB0aGUgc2VsZWN0aW9uXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlLCBhc3NvYykpLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBzZWxlY3Rpb24gdG8gYW5vdGhlciBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsIHJhbmdlc1xuICAgIGFyZSBjb21wYXJlZCBvbmx5IGJ5IHBvc2l0aW9uLiBXaGVuIGBpbmNsdWRlQXNzb2NgIGlzIHRydWUsXG4gICAgY3Vyc29yIHJhbmdlcyBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZVxuICAgIFtgYXNzb2NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmFzc29jKSB2YWx1ZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoICE9IG90aGVyLnJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldLCBpbmNsdWRlQXNzb2MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKSB8XG4gICAgICAgICAgICAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbENvbHVtbiwgYmlkaUxldmVsKSB7XG4gICAgICAgIGxldCBmbGFncyA9ICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gNyA6IE1hdGgubWluKDYsIGJpZGlMZXZlbCkpO1xuICAgICAgICByZXR1cm4gaGVhZCA8IGFuY2hvciA/IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShoZWFkLCBhbmNob3IsIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyB8IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIChoZWFkID4gYW5jaG9yID8gOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSB8IGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgbGV0IG1haW4gPSByYW5nZXNbbWFpbkluZGV4XTtcbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBwcmV2LmZyb20sIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHByZXYudG8pO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIHVzZXMgb2YgZmFjZXRzIGFyZSB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSwgW2VkaXRvclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXG5saXN0ZW5lcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnVwZGF0ZUxpc3RlbmVyKS5cblxuTm90ZSB0aGF0IGBGYWNldGAgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFueXdoZXJlIHdoZXJlXG5bYEZhY2V0UmVhZGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldFJlYWRlcikgaXMgZXhwZWN0ZWQuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIGZhY2V0IHJlYWRlciBmb3IgdGhpcyBmYWNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICBbcmVhZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5mYWNldCkgaXQgYnV0IG5vdCB0byBkZWZpbmUgdmFsdWVzIGZvciBpdC5cbiAgICAqL1xuICAgIGdldCByZWFkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5zdGFydFN0YXRlLmZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSA/IHRyLm5ld1NlbGVjdGlvbiA6IHRyLm5ld1NlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdHIubmV3RG9jLCBzZWxlY3Rpb24sIHN0YXJ0VmFsdWVzLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QudXBkYXRlKHN0YXRlLCB0ciksIHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSB0aGF0XG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy50b1RleHQodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4gKHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgICBmdW5jdGlvbiBmb3IgZWFjaCByYW5nZSBpbiB0aGUgYWN0aXZlIHNlbGVjdGlvbi4gVGhlIGZ1bmN0aW9uXG4gICAgY2FuIHJldHVybiBhbiBvcHRpb25hbCBzZXQgb2YgY2hhbmdlcyAoaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gICAgc3BhY2Ugb2YgdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSBjYWxsJ3Mgb3duIGNoYW5nZXMpLiBUaGlzXG4gICAgbWV0aG9kIHdpbGwgbWVyZ2UgYWxsIHRoZSBjaGFuZ2VzIGFuZCByYW5nZXMgaW50byBhIHNpbmdsZVxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gICAgc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpLCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B1cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4gICAgKi9cbiAgICBjaGFuZ2VCeVJhbmdlKGYpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdDEuY2hhbmdlcyksIHJhbmdlcyA9IFtyZXN1bHQxLnJhbmdlXTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBhc0FycmF5KHJlc3VsdDEuZWZmZWN0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYoc2VsLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICBsZXQgbmV3Q2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksIG5ld01hcHBlZCA9IG5ld0NoYW5nZXMubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLm1hcChuZXdNYXBwZWQpO1xuICAgICAgICAgICAgbGV0IG1hcEJ5ID0gY2hhbmdlcy5tYXBEZXNjKG5ld0NoYW5nZXMsIHRydWUpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29tcG9zZShuZXdNYXBwZWQpO1xuICAgICAgICAgICAgZWZmZWN0cyA9IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZWZmZWN0cywgbmV3TWFwcGVkKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhc0FycmF5KHJlc3VsdC5lZmZlY3RzKSwgbWFwQnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxuICAgICAgICAgICAgZWZmZWN0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpIGZyb20gdGhlIGdpdmVuIGNoYW5nZVxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXG4gICAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KVxuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcbiAgICBzZXBhcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvciksIGNyZWF0ZSBhXG4gICAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBUZXh0Lm9mKHN0cmluZy5zcGxpdCh0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgICAqL1xuICAgIHNsaWNlRG9jKGZyb20gPSAwLCB0byA9IHRoaXMuZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIHRoaXMubGluZUJyZWFrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHN0YXRlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldCkuXG4gICAgKi9cbiAgICBmYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0LmRlZmF1bHQ7XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgICBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIChpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxuICAgICovXG4gICAgdG9KU09OKGZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9jOiB0aGlzLnNsaWNlRG9jKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbdmFsdWUuaWRdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zZWxlY3Rpb24pLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogY29uZmlnLmV4dGVuc2lvbnMgPyBmaWVsZEluaXQuY29uY2F0KFtjb25maWcuZXh0ZW5zaW9uc10pIDogZmllbGRJbml0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cbiAgICBpbml0aWFsaXppbmcgYW4gZWRpdG9y4oCUdXBkYXRlZCBzdGF0ZXMgYXJlIGNyZWF0ZWQgYnkgYXBwbHlpbmdcbiAgICB0cmFuc2FjdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGNvbmZpZy5leHRlbnNpb25zIHx8IFtdLCBuZXcgTWFwKTtcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xuICAgICAgICAgICAgOiBUZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbiwgY29uZmlndXJhdGlvbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QuY3JlYXRlKHN0YXRlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICBcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cbiAgICBwbGFjZSBvZiBtYXJrZXJzIGxpa2UgYCQxYCAoZm9yIHRoZSBmaXJzdCB2YWx1ZSkgYW5kIGAkMmAsIGV0Yy5cbiAgICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXG4gICAgKi9cbiAgICBwaHJhc2UocGhyYXNlLCAuLi5pbnNlcnQpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSkge1xuICAgICAgICAgICAgICAgIHBocmFzZSA9IG1hcFtwaHJhc2VdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW4gfHwgbiA+IGluc2VydC5sZW5ndGggPyBtIDogaW5zZXJ0W24gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXG4gICAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICAgIFxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxuICAgIFxuICAgIC0gW2BcImNvbW1lbnRUb2tlbnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgZm9yIHNwZWNpZnlpbmdcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxuICAgIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgICAgZm9yIHByb3ZpZGluZyBsYW5ndWFnZS1zcGVjaWZpYyBjb21wbGV0aW9uIHNvdXJjZXMuXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xuICAgICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgICAgbGFuZ3VhZ2UuXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xuICAgICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAgICovXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm92aWRlciBvZiB0aGlzLmZhY2V0KGxhbmd1YWdlRGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyZXN1bHRbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXG4gICAgaW50byBvbmUgb2Y6XG4gICAgXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxuICAgICAgIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBsb2NhbCBsYW5ndWFnZSdzIGBcIndvcmRDaGFyc1wiYFxuICAgICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxuICAgICAtIE90aGVyIChhbnl0aGluZyBlbHNlKVxuICAgICovXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIodGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCkuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICAgIGNvbnRhaW5pbmcgYWxsIFt3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSBjaGFyYWN0ZXJzXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcbiAgICB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAqL1xuICAgIHdvcmRBdChwb3MpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCA9PSBlbmQgPyBudWxsIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSk7XG4gICAgfVxufVxuLyoqXG5BIGZhY2V0IHRoYXQsIHdoZW4gZW5hYmxlZCwgY2F1c2VzIHRoZSBlZGl0b3IgdG8gYWxsb3cgbXVsdGlwbGVcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcbmVkaXRvciByZWxpZXMgb24gdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uLCB3aGljaCBjYW5ub3QgaGFuZGxlXG5tdWx0aXBsZSBzZWxlY3Rpb25zLiBBbiBleHRlbnNpb24gbGlrZVxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2VcbnNlY29uZGFyeSBzZWxlY3Rpb25zIHZpc2libGUgdG8gdGhlIHVzZXIuXG4qL1xuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcbi8qKlxuQ29uZmlndXJlcyB0aGUgdGFiIHNpemUgdG8gdXNlIGluIHRoaXMgc3RhdGUuIFRoZSBmaXJzdFxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXG5naXZlbiwgdGhpcyBkZWZhdWx0cyB0byA0LlxuKi9cbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblRoaXMgZmFjZXQgY29udHJvbHMgdGhlIHZhbHVlIG9mIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcbmNvbnN1bHRlZCBieSBjb21tYW5kcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGltcGxlbWVudCBlZGl0aW5nXG5mdW5jdGlvbmFsaXR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgc2hvdWxkIGFwcGx5LiBJdFxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcbmB0cnVlYCwgc3VjaCBmdW5jdGlvbmFsaXR5IGRpc2FibGVzIGl0c2VsZi5cblxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcbltgRWRpdG9yVmlldy5lZGl0YWJsZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRhYmxlKSwgd2hpY2hcbmNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvcidzIERPTSBpcyBzZXQgdG8gYmUgZWRpdGFibGUgKGFuZFxudGh1cyBmb2N1c2FibGUpLlxuKi9cbkVkaXRvclN0YXRlLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLyoqXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcbm9iamVjdCBmcm9tIGFuIGFycmF5IG9mIHByb3ZpZGVkIGNvbmZpZ3MuIGBkZWZhdWx0c2Agc2hvdWxkIGhvbGRcbmRlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgZmllbGRzIGluIGBDb25maWdgLlxuXG5UaGUgZnVuY3Rpb24gd2lsbCwgYnkgZGVmYXVsdCwgZXJyb3JcbndoZW4gYSBmaWVsZCBnZXRzIHR3byB2YWx1ZXMgdGhhdCBhcmVuJ3QgYD09PWAtZXF1YWwsIGJ1dCB5b3UgY2FuXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cbiovXG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIGRlZmF1bHRzLCAvLyBTaG91bGQgaG9sZCBvbmx5IHRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIENvbmZpZywgYnV0IEkgaGF2ZW4ndCBtYW5hZ2VkIHRvIGV4cHJlc3MgdGhhdFxuY29tYmluZSA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29uZmlnW2tleV0sIGN1cnJlbnQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPT09IHZhbHVlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIDsgLy8gTm8gY29uZmxpY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbWJpbmUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZyBtZXJnZSBjb25mbGljdCBmb3IgZmllbGQgXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKVxuICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFVzZWQgd2hlbiBjb21wYXJpbmdcbiAgICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xuICAgIG9mIHlvdXIgdmFsdWUgdHlwZSwgaXQgaXMgYSBnb29kIGlkZWEgdG8gaW1wbGVtZW50IHRoaXNcbiAgICBwcm9wZXJseS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzID09IG90aGVyOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXG4gICAgKi9cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIFJhbmdlLmNyZWF0ZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xuLyoqXG5BIHJhbmdlIGFzc29jaWF0ZXMgYSB2YWx1ZSB3aXRoIGEgcmFuZ2Ugb2YgcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcFJhbmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyBDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcbiAgICAvLyBDaHVua3MgYXJlIG1hcmtlZCB3aXRoIHRoZSBsYXJnZXN0IHBvaW50IHRoYXQgb2NjdXJzXG4gICAgLy8gaW4gdGhlbSAob3IgLTEgZm9yIG5vIHBvaW50cyksIHNvIHRoYXQgc2NhbnMgdGhhdCBhcmVcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxuICAgIC8vIGhlaWdodG1hcC1yZWxhdGVkIGxvZ2ljKSBjYW4gc2tpcCByYW5nZS1vbmx5IGNodW5rcy5cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50b1t0aGlzLnRvLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcbiAgICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICAgIGZpbmRJbmRleChwb3MsIHNpZGUsIGVuZCwgc3RhcnRBdCA9IDApIHtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XG4gICAgICAgIGZvciAobGV0IGxvID0gc3RhcnRBdCwgaGkgPSBhcnIubGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFyclttaWRdIC0gcG9zIHx8IChlbmQgPyB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSA6IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUpIC0gc2lkZTtcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPj0gMCA/IGxvIDogaGk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZXR3ZWVuKG9mZnNldCwgZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5zdGFydFNpZGUgIT0gdmFsLmVuZFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vKipcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxud2F5IHRoYXQgbWFrZXMgdGhlbSBlZmZpY2llbnQgdG8gW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC5tYXApIGFuZFxuW3VwZGF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC51cGRhdGUpLiBUaGlzIGlzIGFuIGltbXV0YWJsZSBkYXRhXG5zdHJ1Y3R1cmUuXG4qL1xuY2xhc3MgUmFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2h1bmsubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubmV4dExheWVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXG4gICAgICAgICAgICBzaXplICs9IGNodW5rLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHJhbmdlIHNldCwgb3B0aW9uYWxseSBhZGRpbmcgbmV3IHJhbmdlcyBvciBmaWx0ZXJpbmdcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cbiAgICBcbiAgICAoTm90ZTogVGhlIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXG4gICAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgICBgWWAuKVxuICAgICovXG4gICAgdXBkYXRlKHVwZGF0ZVNwZWMpIHtcbiAgICAgICAgbGV0IHsgYWRkID0gW10sIHNvcnQgPSBmYWxzZSwgZmlsdGVyRnJvbSA9IDAsIGZpbHRlclRvID0gdGhpcy5sZW5ndGggfSA9IHVwZGF0ZVNwZWM7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcbiAgICAgICAgaWYgKGFkZC5sZW5ndGggPT0gMCAmJiAhZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChzb3J0KVxuICAgICAgICAgICAgYWRkID0gYWRkLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xuICAgICAgICBsZXQgY3VyID0gbmV3IExheWVyQ3Vyc29yKHRoaXMsIG51bGwsIC0xKS5nb3RvKDApLCBpID0gMCwgc3BpbGwgPSBbXTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYWRkLmxlbmd0aCAmJiAoY3VyLmZyb20gLSBhZGRbaV0uZnJvbSB8fCBjdXIuc3RhcnRTaWRlIC0gYWRkW2ldLnZhbHVlLnN0YXJ0U2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGFkZFtpKytdO1xuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChpID09IGFkZC5sZW5ndGggfHwgdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgPCBhZGRbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgfHwgZmlsdGVyVG8gPCB0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSkgJiZcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjdXIubmV4dENodW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gY3VyLnRvIHx8IGZpbHRlclRvIDwgY3VyLmZyb20gfHwgZmlsdGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2hJbm5lcih0aGlzLm5leHRMYXllci5pc0VtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxuICAgICovXG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxuICAgIGNhbGxpbmcgYGZgIGZvciBlYWNoLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2VzIHdpbGxcbiAgICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXG4gICAgKi9cbiAgICBiZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIHRoaXMgc2V0LCBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXG4gICAgKi9cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gdGhpcy5uZXh0TGF5ZXIgPT0gdGhpczsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIGEgY29sbGVjdGlvbiBvZiBzZXRzLCBpbiBvcmRlcixcbiAgICBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpdGVyKHNldHMsIGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oc2V0cykuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHR3byBncm91cHMgb2Ygc2V0cywgY2FsbGluZyBtZXRob2RzIG9uIGBjb21wYXJhdG9yYFxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlKG9sZFNldHMsIG5ld1NldHMsIFxuICAgIC8qKlxuICAgIFRoaXMgaW5kaWNhdGVzIGhvdyB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZWQgYmV0d2VlbiB0aGVzZVxuICAgIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgdGV4dERpZmYsIGNvbXBhcmF0b3IsIFxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIHRoZSBnaXZlbiBzaXplLiBXaGVuIC0xLCBhbGwgcmFuZ2VzIGFyZSBjb21wYXJlZC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgdGV4dERpZmYuaXRlckdhcHMoKGZyb21BLCBmcm9tQiwgbGVuZ3RoKSA9PiBjb21wYXJlKHNpZGVBLCBmcm9tQSwgc2lkZUIsIGZyb21CLCBsZW5ndGgsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgaWYgKHRleHREaWZmLmVtcHR5ICYmIHRleHREaWZmLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXG4gICAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovIC0gMTtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBvbGRTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKSwgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxuICAgICAgICAgICAgICAgICFzYW1lVmFsdWVzKHNpZGVBLmFjdGl2ZSwgc2lkZUIuYWN0aXZlKSB8fFxuICAgICAgICAgICAgICAgIHNpZGVBLnBvaW50ICYmICghc2lkZUIucG9pbnQgfHwgIXNpZGVBLnBvaW50LmVxKHNpZGVCLnBvaW50KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XG4gICAgICAgICAgICBzaWRlQi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxuICAgIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIG9mIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgc3BhbnMoc2V0cywgZnJvbSwgdG8sIGl0ZXJhdG9yLCBcbiAgICAvKipcbiAgICBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICBzaXplIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgb3BlbkNvdW50ID0gY3Vyc29yLnBvaW50RnJvbSA8IGZyb20gPyBhY3RpdmUubGVuZ3RoICsgMSA6IE1hdGgubWluKGFjdGl2ZS5sZW5ndGgsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgYWN0aXZlLCBvcGVuQ291bnQsIGN1cnNvci5wb2ludFJhbmspO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBNYXRoLm1pbihjdXJzb3Iub3BlbkVuZChjdXJUbyksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyVG8gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zcGFuKHBvcywgY3VyVG8sIGN1cnNvci5hY3RpdmUsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlbkVuZChjdXJUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5SYW5nZXMgKyAoY3Vyc29yLnBvaW50ICYmIGN1cnNvci50byA+IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiByYW5nZSBvciBhcnJheSBvZiByYW5nZXMuIEJ5XG4gICAgZGVmYXVsdCwgdGhpcyBleHBlY3RzIHRoZSByYW5nZXMgdG8gYmUgX3NvcnRlZF8gKGJ5IHN0YXJ0XG4gICAgcG9zaXRpb24gYW5kLCBpZiB0d28gc3RhcnQgYXQgdGhlIHNhbWUgcG9zaXRpb24sXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApLiBZb3UgY2FuIHBhc3MgYHRydWVgIGFzIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGNhdXNlIHRoZSBtZXRob2QgdG8gc29ydCB0aGVtLlxuICAgICovXG4gICAgc3RhdGljIG9mKHJhbmdlcywgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgcmFuZ2VzIGluc3RhbmNlb2YgUmFuZ2UgPyBbcmFuZ2VzXSA6IHNvcnQgPyBsYXp5U29ydChyYW5nZXMpIDogcmFuZ2VzKVxuICAgICAgICAgICAgYnVpbGQuYWRkKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiBhbiBhcnJheSBvZiByYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LlxuICAgICovXG4gICAgc3RhdGljIGpvaW4oc2V0cykge1xuICAgICAgICBpZiAoIXNldHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2V0c1tzZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gc2V0cy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXIgPSBzZXRzW2ldOyBsYXllciAhPSBSYW5nZVNldC5lbXB0eTsgbGF5ZXIgPSBsYXllci5uZXh0TGF5ZXIpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJhbmdlU2V0KGxheWVyLmNodW5rUG9zLCBsYXllci5jaHVuaywgcmVzdWx0LCBNYXRoLm1heChsYXllci5tYXhQb2ludCwgcmVzdWx0Lm1heFBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgcmFuZ2VzLlxuKi9cblJhbmdlU2V0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBSYW5nZVNldChbXSwgW10sIG51bGwsIC0xKTtcbmZ1bmN0aW9uIGxhenlTb3J0KHJhbmdlcykge1xuICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IHJhbmdlc1swXSwgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoY21wUmFuZ2UocHJldiwgY3VyKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcy5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5SYW5nZVNldC5lbXB0eS5uZXh0TGF5ZXIgPSBSYW5nZVNldC5lbXB0eTtcbi8qKlxuQSByYW5nZSBzZXQgYnVpbGRlciBpcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaGVscHMgYnVpbGQgdXAgYVxuW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgZGlyZWN0bHksIHdpdGhvdXQgZmlyc3QgYWxsb2NhdGluZ1xuYW4gYXJyYXkgb2YgW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIG9iamVjdHMuXG4qL1xuY2xhc3MgUmFuZ2VTZXRCdWlsZGVyIHtcbiAgICBmaW5pc2hDaHVuayhuZXdBcnJheXMpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgQ2h1bmsodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnZhbHVlLCB0aGlzLm1heFBvaW50KSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIHRoaXMubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIGlmIChuZXdBcnJheXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSByYW5nZS4gUmFuZ2VzIHNob3VsZCBiZSBhZGRlZCBpbiBzb3J0ZWQgKGJ5IGBmcm9tYCBhbmRcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkgb3JkZXIuXG4gICAgKi9cbiAgICBhZGQoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpKVxuICAgICAgICAgICAgKHRoaXMubmV4dExheWVyIHx8ICh0aGlzLm5leHRMYXllciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIpKS5hZGQoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSBmcm9tIC0gdGhpcy5sYXN0VG8gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGU7XG4gICAgICAgIGlmIChkaWZmIDw9IDAgJiYgKGZyb20gLSB0aGlzLmxhc3RGcm9tIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlcyBtdXN0IGJlIGFkZGVkIHNvcnRlZCBieSBgZnJvbWAgcG9zaXRpb24gYW5kIGBzdGFydFNpZGVgXCIpO1xuICAgICAgICBpZiAoZGlmZiA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoID09IDI1MCAvKiBDLkNodW5rU2l6ZSAqLylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5mcm9tLnB1c2goZnJvbSAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMudG8ucHVzaCh0byAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMubGFzdCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLnBvaW50KVxuICAgICAgICAgICAgdGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIHRvIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZENodW5rKGZyb20sIGNodW5rKSB7XG4gICAgICAgIGlmICgoZnJvbSAtIHRoaXMubGFzdFRvIHx8IGNodW5rLnZhbHVlWzBdLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlKSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaChmcm9tKTtcbiAgICAgICAgbGV0IGxhc3QgPSBjaHVuay52YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmxhc3QgPSBjaHVuay52YWx1ZVtsYXN0XTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGNodW5rLmZyb21bbGFzdF0gKyBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IGNodW5rLnRvW2xhc3RdICsgZnJvbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmlzaCB0aGUgcmFuZ2Ugc2V0LiBSZXR1cm5zIHRoZSBuZXcgc2V0LiBUaGUgYnVpbGRlciBjYW4ndCBiZVxuICAgIHVzZWQgYW55bW9yZSBhZnRlciB0aGlzIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAqL1xuICAgIGZpbmlzaCgpIHsgcmV0dXJuIHRoaXMuZmluaXNoSW5uZXIoUmFuZ2VTZXQuZW1wdHkpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5pc2hJbm5lcihuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gUmFuZ2VTZXQuY3JlYXRlKHRoaXMuY2h1bmtQb3MsIHRoaXMuY2h1bmtzLCB0aGlzLm5leHRMYXllciA/IHRoaXMubmV4dExheWVyLmZpbmlzaElubmVyKG5leHQpIDogbmV4dCwgdGhpcy5zZXRNYXhQb2ludCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IG51bGw7IC8vIE1ha2Ugc3VyZSBmdXJ0aGVyIGBhZGRgIGNhbGxzIHByb2R1Y2UgZXJyb3JzXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZikge1xuICAgIGxldCBpbkEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGEpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldC5jaHVua1tpXS5tYXhQb2ludCA8PSAwKVxuICAgICAgICAgICAgICAgIGluQS5zZXQoc2V0LmNodW5rW2ldLCBzZXQuY2h1bmtQb3NbaV0pO1xuICAgIGxldCBzaGFyZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga25vd24gPSBpbkEuZ2V0KHNldC5jaHVua1tpXSk7XG4gICAgICAgICAgICBpZiAoa25vd24gIT0gbnVsbCAmJiAodGV4dERpZmYgPyB0ZXh0RGlmZi5tYXBQb3Moa25vd24pIDoga25vd24pID09IHNldC5jaHVua1Bvc1tpXSAmJlxuICAgICAgICAgICAgICAgICEodGV4dERpZmYgPT09IG51bGwgfHwgdGV4dERpZmYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHREaWZmLnRvdWNoZXNSYW5nZShrbm93biwga25vd24gKyBzZXQuY2h1bmtbaV0ubGVuZ3RoKSkpXG4gICAgICAgICAgICAgICAgc2hhcmVkLmFkZChzZXQuY2h1bmtbaV0pO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHNoYXJlZDtcbn1cbmNsYXNzIExheWVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXllciwgc2tpcCwgbWluUG9pbnQsIHJhbmsgPSAwKSB7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdldCBlbmRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuZW5kU2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCA9IHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ290b0lubmVyKHBvcywgc2lkZSwgZm9yd2FyZCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5za2lwICYmIHRoaXMuc2tpcC5oYXMobmV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyLmNodW5rRW5kKHRoaXMuY2h1bmtJbmRleCkgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICBuZXh0Lm1heFBvaW50IDwgdGhpcy5taW5Qb2ludCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByYW5nZUluZGV4ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLmZpbmRJbmRleChwb3MgLSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIHNpZGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFmb3J3YXJkIHx8IHRoaXMucmFuZ2VJbmRleCA8IHJhbmdlSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHJhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA9PSB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rUG9zID0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBjaHVuayA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNodW5rUG9zICsgY2h1bmsuZnJvbVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IGNodW5rUG9zICsgY2h1bmsudG9bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2h1bmsudmFsdWVbdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgodGhpcy5yYW5nZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluUG9pbnQgPCAwIHx8IHRoaXMudmFsdWUucG9pbnQgJiYgdGhpcy50byAtIHRoaXMuZnJvbSA+PSB0aGlzLm1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRSYW5nZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0udmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGggJiYgdGhpcy5za2lwLmhhcyh0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tIC0gb3RoZXIuZnJvbSB8fCB0aGlzLnN0YXJ0U2lkZSAtIG90aGVyLnN0YXJ0U2lkZSB8fCB0aGlzLnJhbmsgLSBvdGhlci5yYW5rIHx8XG4gICAgICAgICAgICB0aGlzLnRvIC0gb3RoZXIudG8gfHwgdGhpcy5lbmRTaWRlIC0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG59XG5jbGFzcyBIZWFwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFwKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IGhlYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNldHMsIHNraXAgPSBudWxsLCBtaW5Qb2ludCA9IC0xKSB7XG4gICAgICAgIGxldCBoZWFwID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY3VyID0gc2V0c1tpXTsgIWN1ci5pc0VtcHR5OyBjdXIgPSBjdXIubmV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5tYXhQb2ludCA+PSBtaW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgaGVhcC5wdXNoKG5ldyBMYXllckN1cnNvcihjdXIsIHNraXAsIG1pblBvaW50LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYXAubGVuZ3RoID09IDEgPyBoZWFwWzBdIDogbmV3IEhlYXBDdXJzb3IoaGVhcCk7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy52YWx1ZS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXAubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0b3AuZnJvbTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9wLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gdG9wLnJhbms7XG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRvcC5uZXh0KCk7XG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgY3VyID0gaGVhcFtpbmRleF07Oykge1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IChpbmRleCA8PCAxKSArIDE7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcbiAgICAgICAgICAgIGNoaWxkID0gaGVhcFtjaGlsZEluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jb21wYXJlKGNoaWxkKSA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgaW5kZXggPSBjaGlsZEluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFNwYW5DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50KSB7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVUbyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVJhbmsgPSBbXTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgLy8gQSBjdXJyZW50bHkgYWN0aXZlIHBvaW50IHJhbmdlLCBpZiBhbnlcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRGcm9tID0gMDtcbiAgICAgICAgdGhpcy5wb2ludFJhbmsgPSAwO1xuICAgICAgICB0aGlzLnRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IDA7XG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2Ygb3BlbiBhY3RpdmUgcmFuZ2VzIGF0IHRoZSBzdGFydCBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgIC8vIE5vdCBpbmNsdWRpbmcgcG9pbnRzLlxuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XG4gICAgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jdXJzb3IuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCA9IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICB0aGlzLnRvID0gcG9zO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1pbkFjdGl2ZSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW3RoaXMubWluQWN0aXZlXSAtIHBvcyB8fCB0aGlzLmFjdGl2ZVt0aGlzLm1pbkFjdGl2ZV0uZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKHRoaXMubWluQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmUoaW5kZXgpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVRvLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVJhbmssIGluZGV4KTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICBhZGRBY3RpdmUodHJhY2tPcGVuKSB7XG4gICAgICAgIGxldCBpID0gMCwgeyB2YWx1ZSwgdG8sIHJhbmsgfSA9IHRoaXMuY3Vyc29yO1xuICAgICAgICAvLyBPcmdhbml6ZSBhY3RpdmUgbWFya3MgYnkgcmFuayBmaXJzdCwgdGhlbiBieSBzaXplXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiAocmFuayAtIHRoaXMuYWN0aXZlUmFua1tpXSB8fCB0byAtIHRoaXMuYWN0aXZlVG9baV0pID4gMClcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRpZmYgPSAoYS50byArIGRQb3MpIC0gYi50byB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8pLCBiLmFjdGl2ZUZvclBvaW50KGIudG8pKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bzspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.js\");\n\n\n\nfunction getSelection(root) {\n  let target;\n  // Browsers differ on whether shadow roots have a getSelection\n  // method. If it exists, use that, otherwise, call it on the\n  // document.\n  if (root.nodeType == 11) {\n    // Shadow root\n    target = root.getSelection ? root : root.ownerDocument;\n  } else {\n    target = root;\n  }\n  return target.getSelection();\n}\nfunction contains(dom, node) {\n  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n  let elt = doc.activeElement;\n  while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;\n  return elt;\n}\nfunction hasSelection(dom, selection) {\n  if (!selection.anchorNode) return false;\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return contains(dom, selection.anchorNode);\n  } catch (_) {\n    return false;\n  }\n}\nfunction clientRectsFor(dom) {\n  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) return index;\n  }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true;\n    if (off == (dir < 0 ? 0 : maxOffset(node))) {\n      if (node.nodeName == \"DIV\") return false;\n      let parent = node.parentNode;\n      if (!parent || parent.nodeType != 1) return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n      off = dir < 0 ? maxOffset(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\nfunction maxOffset(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n  let x = left ? rect.left : rect.right;\n  return {\n    left: x,\n    right: x,\n    top: rect.top,\n    bottom: rect.bottom\n  };\n}\nfunction windowRect(win) {\n  return {\n    left: 0,\n    right: win.innerWidth,\n    top: 0,\n    bottom: win.innerHeight\n  };\n}\nfunction getScale(elt, rect) {\n  let scaleX = rect.width / elt.offsetWidth;\n  let scaleY = rect.height / elt.offsetHeight;\n  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n  return {\n    scaleX,\n    scaleY\n  };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n  let doc = dom.ownerDocument,\n    win = doc.defaultView || window;\n  for (let cur = dom, stop = false; cur && !stop;) {\n    if (cur.nodeType == 1) {\n      // Element\n      let bounding,\n        top = cur == doc.body;\n      let scaleX = 1,\n        scaleY = 1;\n      if (top) {\n        bounding = windowRect(win);\n      } else {\n        if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n          cur = cur.assignedSlot || cur.parentNode;\n          continue;\n        }\n        let rect = cur.getBoundingClientRect();\n        ({\n          scaleX,\n          scaleY\n        } = getScale(cur, rect));\n        // Make sure scrollbar width isn't included in the rectangle\n        bounding = {\n          left: rect.left,\n          right: rect.left + cur.clientWidth * scaleX,\n          top: rect.top,\n          bottom: rect.top + cur.clientHeight * scaleY\n        };\n      }\n      let moveX = 0,\n        moveY = 0;\n      if (y == \"nearest\") {\n        if (rect.top < bounding.top) {\n          moveY = -(bounding.top - rect.top + yMargin);\n          if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n        } else if (rect.bottom > bounding.bottom) {\n          moveY = rect.bottom - bounding.bottom + yMargin;\n          if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n        }\n      } else {\n        let rectHeight = rect.bottom - rect.top,\n          boundingHeight = bounding.bottom - bounding.top;\n        let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n        moveY = targetTop - bounding.top;\n      }\n      if (x == \"nearest\") {\n        if (rect.left < bounding.left) {\n          moveX = -(bounding.left - rect.left + xMargin);\n          if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n        } else if (rect.right > bounding.right) {\n          moveX = rect.right - bounding.right + xMargin;\n          if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n        }\n      } else {\n        let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n        moveX = targetLeft - bounding.left;\n      }\n      if (moveX || moveY) {\n        if (top) {\n          win.scrollBy(moveX, moveY);\n        } else {\n          let movedX = 0,\n            movedY = 0;\n          if (moveY) {\n            let start = cur.scrollTop;\n            cur.scrollTop += moveY / scaleY;\n            movedY = (cur.scrollTop - start) * scaleY;\n          }\n          if (moveX) {\n            let start = cur.scrollLeft;\n            cur.scrollLeft += moveX / scaleX;\n            movedX = (cur.scrollLeft - start) * scaleX;\n          }\n          rect = {\n            left: rect.left - movedX,\n            top: rect.top - movedY,\n            right: rect.right - movedX,\n            bottom: rect.bottom - movedY\n          };\n          if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n          if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n        }\n      }\n      if (top) break;\n      cur = cur.assignedSlot || cur.parentNode;\n    } else if (cur.nodeType == 11) {\n      // A shadow root\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n}\nfunction scrollableParent(dom) {\n  let doc = dom.ownerDocument;\n  for (let cur = dom.parentNode; cur;) {\n    if (cur == doc.body) {\n      break;\n    } else if (cur.nodeType == 1) {\n      if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;\n      cur = cur.assignedSlot || cur.parentNode;\n    } else if (cur.nodeType == 11) {\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n  return null;\n}\nclass DOMSelectionState {\n  constructor() {\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n  eq(domSel) {\n    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n  }\n  setRange(range) {\n    let {\n      anchorNode,\n      focusNode\n    } = range;\n    // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n  }\n  set(anchorNode, anchorOffset, focusNode, focusOffset) {\n    this.anchorNode = anchorNode;\n    this.anchorOffset = anchorOffset;\n    this.focusNode = focusNode;\n    this.focusOffset = focusOffset;\n  }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive(); // in IE\n  if (preventScrollSupported) return dom.focus(preventScrollSupported);\n  let stack = [];\n  for (let cur = dom; cur; cur = cur.parentNode) {\n    stack.push(cur, cur.scrollTop, cur.scrollLeft);\n    if (cur == cur.ownerDocument) break;\n  }\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {\n        preventScroll: true\n      };\n      return true;\n    }\n  } : undefined);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    for (let i = 0; i < stack.length;) {\n      let elt = stack[i++],\n        top = stack[i++],\n        left = stack[i++];\n      if (elt.scrollTop != top) elt.scrollTop = top;\n      if (elt.scrollLeft != left) elt.scrollLeft = left;\n    }\n  }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n  let range = scratchRange || (scratchRange = document.createRange());\n  range.setEnd(node, to);\n  range.setStart(node, from);\n  return range;\n}\nfunction dispatchKey(elt, name, code) {\n  let options = {\n    key: name,\n    code: name,\n    keyCode: code,\n    which: code,\n    cancelable: true\n  };\n  let down = new KeyboardEvent(\"keydown\", options);\n  down.synthetic = true;\n  elt.dispatchEvent(down);\n  let up = new KeyboardEvent(\"keyup\", options);\n  up.synthetic = true;\n  elt.dispatchEvent(up);\n  return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n  while (node) {\n    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n    node = node.assignedSlot || node.parentNode;\n  }\n  return null;\n}\nfunction clearAttributes(node) {\n  while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n  let node = selection.focusNode,\n    offset = selection.focusOffset;\n  if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n  // Safari can report bogus offsets (#1152)\n  offset = Math.min(offset, maxOffset(node));\n  for (;;) {\n    if (offset) {\n      if (node.nodeType != 1) return false;\n      let prev = node.childNodes[offset - 1];\n      if (prev.contentEditable == \"false\") offset--;else {\n        node = prev;\n        offset = maxOffset(node);\n      }\n    } else if (node == doc) {\n      return true;\n    } else {\n      offset = domIndex(node);\n      node = node.parentNode;\n    }\n  }\n}\nfunction isScrolledToBottom(elt) {\n  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nclass DOMPos {\n  constructor(node, offset, precise = true) {\n    this.node = node;\n    this.offset = offset;\n    this.precise = precise;\n  }\n  static before(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom), precise);\n  }\n  static after(dom, precise) {\n    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n  }\n}\nconst noChildren = [];\nclass ContentView {\n  constructor() {\n    this.parent = null;\n    this.dom = null;\n    this.flags = 2 /* ViewFlag.NodeDirty */;\n  }\n  get overrideDOMText() {\n    return null;\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBefore(this) : 0;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.length;\n  }\n  posBefore(view) {\n    let pos = this.posAtStart;\n    for (let child of this.children) {\n      if (child == view) return pos;\n      pos += child.length + child.breakAfter;\n    }\n    throw new RangeError(\"Invalid child in posBefore\");\n  }\n  posAfter(view) {\n    return this.posBefore(view) + view.length;\n  }\n  sync(view, track) {\n    if (this.flags & 2 /* ViewFlag.NodeDirty */) {\n      let parent = this.dom;\n      let prev = null,\n        next;\n      for (let child of this.children) {\n        if (child.flags & 7 /* ViewFlag.Dirty */) {\n          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n            let contentView = ContentView.get(next);\n            if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n          }\n          child.sync(view, track);\n          child.flags &= ~7 /* ViewFlag.Dirty */;\n        }\n        next = prev ? prev.nextSibling : parent.firstChild;\n        if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n        if (child.dom.parentNode == parent) {\n          while (next && next != child.dom) next = rm$1(next);\n        } else {\n          parent.insertBefore(child.dom, next);\n        }\n        prev = child.dom;\n      }\n      next = prev ? prev.nextSibling : parent.firstChild;\n      if (next && track && track.node == parent) track.written = true;\n      while (next) next = rm$1(next);\n    } else if (this.flags & 1 /* ViewFlag.ChildDirty */) {\n      for (let child of this.children) if (child.flags & 7 /* ViewFlag.Dirty */) {\n        child.sync(view, track);\n        child.flags &= ~7 /* ViewFlag.Dirty */;\n      }\n    }\n  }\n  reuseDOM(_dom) {}\n  localPosFromDOM(node, offset) {\n    let after;\n    if (node == this.dom) {\n      after = this.dom.childNodes[offset];\n    } else {\n      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n      for (;;) {\n        let parent = node.parentNode;\n        if (parent == this.dom) break;\n        if (bias == 0 && parent.firstChild != parent.lastChild) {\n          if (node == parent.firstChild) bias = -1;else bias = 1;\n        }\n        node = parent;\n      }\n      if (bias < 0) after = node;else after = node.nextSibling;\n    }\n    if (after == this.dom.firstChild) return 0;\n    while (after && !ContentView.get(after)) after = after.nextSibling;\n    if (!after) return this.length;\n    for (let i = 0, pos = 0;; i++) {\n      let child = this.children[i];\n      if (child.dom == after) return pos;\n      pos += child.length + child.breakAfter;\n    }\n  }\n  domBoundsAround(from, to, offset = 0) {\n    let fromI = -1,\n      fromStart = -1,\n      toI = -1,\n      toEnd = -1;\n    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n      if (end >= from && fromI == -1) {\n        fromI = i;\n        fromStart = pos;\n      }\n      if (pos > to && child.dom.parentNode == this.dom) {\n        toI = i;\n        toEnd = prevEnd;\n        break;\n      }\n      prevEnd = end;\n      pos = end + child.breakAfter;\n    }\n    return {\n      from: fromStart,\n      to: toEnd < 0 ? offset + this.length : toEnd,\n      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n    };\n  }\n  markDirty(andParent = false) {\n    this.flags |= 2 /* ViewFlag.NodeDirty */;\n    this.markParentsDirty(andParent);\n  }\n  markParentsDirty(childList) {\n    for (let parent = this.parent; parent; parent = parent.parent) {\n      if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */;\n      if (parent.flags & 1 /* ViewFlag.ChildDirty */) return;\n      parent.flags |= 1 /* ViewFlag.ChildDirty */;\n      childList = false;\n    }\n  }\n  setParent(parent) {\n    if (this.parent != parent) {\n      this.parent = parent;\n      if (this.flags & 7 /* ViewFlag.Dirty */) this.markParentsDirty(true);\n    }\n  }\n  setDOM(dom) {\n    if (this.dom == dom) return;\n    if (this.dom) this.dom.cmView = null;\n    this.dom = dom;\n    dom.cmView = this;\n  }\n  get rootView() {\n    for (let v = this;;) {\n      let parent = v.parent;\n      if (!parent) return v;\n      v = parent;\n    }\n  }\n  replaceChildren(from, to, children = noChildren) {\n    this.markDirty();\n    for (let i = from; i < to; i++) {\n      let child = this.children[i];\n      if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n    }\n    this.children.splice(from, to - from, ...children);\n    for (let i = 0; i < children.length; i++) children[i].setParent(this);\n  }\n  ignoreMutation(_rec) {\n    return false;\n  }\n  ignoreEvent(_event) {\n    return false;\n  }\n  childCursor(pos = this.length) {\n    return new ChildCursor(this.children, pos, this.children.length);\n  }\n  childPos(pos, bias = 1) {\n    return this.childCursor().findPos(pos, bias);\n  }\n  toString() {\n    let name = this.constructor.name.replace(\"View\", \"\");\n    return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n  }\n  static get(node) {\n    return node.cmView;\n  }\n  get isEditable() {\n    return true;\n  }\n  get isWidget() {\n    return false;\n  }\n  get isHidden() {\n    return false;\n  }\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    return false;\n  }\n  become(other) {\n    return false;\n  }\n  canReuseDOM(other) {\n    return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);\n  }\n  // When this is a zero-length view with a side, this should return a\n  // number <= 0 to indicate it is before its position, or a\n  // number > 0 when after its position.\n  getSide() {\n    return 0;\n  }\n  destroy() {\n    for (let child of this.children) if (child.parent == this) child.destroy();\n    this.parent = null;\n  }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n  let next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\nclass ChildCursor {\n  constructor(children, pos, i) {\n    this.children = children;\n    this.pos = pos;\n    this.i = i;\n    this.off = 0;\n  }\n  findPos(pos, bias = 1) {\n    for (;;) {\n      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n        this.off = pos - this.pos;\n        return this;\n      }\n      let next = this.children[--this.i];\n      this.pos -= next.length + next.breakAfter;\n    }\n  }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n  let {\n    children\n  } = parent;\n  let before = children.length ? children[fromI] : null;\n  let last = insert.length ? insert[insert.length - 1] : null;\n  let breakAtEnd = last ? last.breakAfter : breakAtStart;\n  // Change within a single child\n  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n  if (toI < children.length) {\n    let after = children[toI];\n    // Make sure the end of the child after the update is preserved in `after`\n    if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n      // If we're splitting a child, separate part of it to avoid that\n      // being mangled when updating the child before the update.\n      if (fromI == toI) {\n        after = after.split(toOff);\n        toOff = 0;\n      }\n      // If the element after the replacement should be merged with\n      // the last replacing element, update `content`\n      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n        insert[insert.length - 1] = after;\n      } else {\n        // Remove the start of the after element, if necessary, and\n        // add it to `content`.\n        if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n        insert.push(after);\n      }\n    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n      // The element at `toI` is entirely covered by this range.\n      // Preserve its line break, if any.\n      if (last) last.breakAfter = 1;else breakAtStart = 1;\n    }\n    // Since we've handled the next element from the current elements\n    // now, make sure `toI` points after that.\n    toI++;\n  }\n  if (before) {\n    before.breakAfter = breakAtStart;\n    if (fromOff > 0) {\n      if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n        before.breakAfter = insert.shift().breakAfter;\n      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n        before.merge(fromOff, before.length, null, false, openStart, 0);\n      }\n      fromI++;\n    }\n  }\n  // Try to merge widgets on the boundaries of the replacement\n  while (fromI < toI && insert.length) {\n    if (children[toI - 1].become(insert[insert.length - 1])) {\n      toI--;\n      insert.pop();\n      openEnd = insert.length ? 0 : openStart;\n    } else if (children[fromI].become(insert[0])) {\n      fromI++;\n      insert.shift();\n      openStart = insert.length ? 0 : openEnd;\n    } else {\n      break;\n    }\n  }\n  if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n  if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n  let cur = parent.childCursor();\n  let {\n    i: toI,\n    off: toOff\n  } = cur.findPos(to, 1);\n  let {\n    i: fromI,\n    off: fromOff\n  } = cur.findPos(from, -1);\n  let dLen = from - to;\n  for (let view of insert) dLen += view.length;\n  parent.length += dLen;\n  replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n  userAgent: \"\",\n  vendor: \"\",\n  platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n  documentElement: {\n    style: {}\n  }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = (\"webkitFontSmoothing\" in doc.documentElement.style);\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && ( /*@__PURE__*/ /Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n  mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n  windows: /*@__PURE__*/ /Win/.test(nav.platform),\n  linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n  ie,\n  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n  gecko,\n  gecko_version: gecko ? +( /*@__PURE__*/ /Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n  chrome: !!chrome,\n  chrome_version: chrome ? +chrome[1] : 0,\n  ios,\n  android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n  webkit,\n  safari,\n  webkit_version: webkit ? +( /*@__PURE__*/ /\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n  tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n  constructor(text) {\n    super();\n    this.text = text;\n  }\n  get length() {\n    return this.text.length;\n  }\n  createDOM(textDOM) {\n    this.setDOM(textDOM || document.createTextNode(this.text));\n  }\n  sync(view, track) {\n    if (!this.dom) this.createDOM();\n    if (this.dom.nodeValue != this.text) {\n      if (track && track.node == this.dom) track.written = true;\n      this.dom.nodeValue = this.text;\n    }\n  }\n  reuseDOM(dom) {\n    if (dom.nodeType == 3) this.createDOM(dom);\n  }\n  merge(from, to, source) {\n    if (this.flags & 8 /* ViewFlag.Composition */ || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */)) return false;\n    this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n    this.markDirty();\n    return true;\n  }\n  split(from) {\n    let result = new TextView(this.text.slice(from));\n    this.text = this.text.slice(0, from);\n    this.markDirty();\n    result.flags |= this.flags & 8 /* ViewFlag.Composition */;\n    return result;\n  }\n  localPosFromDOM(node, offset) {\n    return node == this.dom ? offset : offset ? this.text.length : 0;\n  }\n  domAtPos(pos) {\n    return new DOMPos(this.dom, pos);\n  }\n  domBoundsAround(_from, _to, offset) {\n    return {\n      from: offset,\n      to: offset + this.length,\n      startDOM: this.dom,\n      endDOM: this.dom.nextSibling\n    };\n  }\n  coordsAt(pos, side) {\n    return textCoords(this.dom, pos, side);\n  }\n}\nclass MarkView extends ContentView {\n  constructor(mark, children = [], length = 0) {\n    super();\n    this.mark = mark;\n    this.children = children;\n    this.length = length;\n    for (let ch of children) ch.setParent(this);\n  }\n  setAttrs(dom) {\n    clearAttributes(dom);\n    if (this.mark.class) dom.className = this.mark.class;\n    if (this.mark.attrs) for (let name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);\n    return dom;\n  }\n  canReuseDOM(other) {\n    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);\n  }\n  reuseDOM(node) {\n    if (node.nodeName == this.mark.tagName.toUpperCase()) {\n      this.setDOM(node);\n      this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;\n    }\n  }\n  sync(view, track) {\n    if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));else if (this.flags & 4 /* ViewFlag.AttrsDirty */) this.setAttrs(this.dom);\n    super.sync(view, track);\n  }\n  merge(from, to, source, _hasStart, openStart, openEnd) {\n    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);\n    this.markDirty();\n    return true;\n  }\n  split(from) {\n    let result = [],\n      off = 0,\n      detachFrom = -1,\n      i = 0;\n    for (let elt of this.children) {\n      let end = off + elt.length;\n      if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n      if (detachFrom < 0 && off >= from) detachFrom = i;\n      off = end;\n      i++;\n    }\n    let length = this.length - from;\n    this.length = from;\n    if (detachFrom > -1) {\n      this.children.length = detachFrom;\n      this.markDirty();\n    }\n    return new MarkView(this.mark, result, length);\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this, pos);\n  }\n  coordsAt(pos, side) {\n    return coordsInChildren(this, pos, side);\n  }\n}\nfunction textCoords(text, pos, side) {\n  let length = text.nodeValue.length;\n  if (pos > length) pos = length;\n  let from = pos,\n    to = pos,\n    flatten = 0;\n  if (pos == 0 && side < 0 || pos == length && side >= 0) {\n    if (!(browser.chrome || browser.gecko)) {\n      // These browsers reliably return valid rectangles for empty ranges\n      if (pos) {\n        from--;\n        flatten = 1;\n      } // FIXME this is wrong in RTL text\n      else if (to < length) {\n        to++;\n        flatten = -1;\n      }\n    }\n  } else {\n    if (side < 0) from--;else if (to < length) to++;\n  }\n  let rects = textRange(text, from, to).getClientRects();\n  if (!rects.length) return null;\n  let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, r => r.width) || rect;\n  return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n  static create(widget, length, side) {\n    return new WidgetView(widget, length, side);\n  }\n  constructor(widget, length, side) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.side = side;\n    this.prevWidget = null;\n  }\n  split(from) {\n    let result = WidgetView.create(this.widget, this.length - from, this.side);\n    this.length -= from;\n    return result;\n  }\n  sync(view) {\n    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n      this.prevWidget = null;\n      this.setDOM(this.widget.toDOM(view));\n      if (!this.widget.editable) this.dom.contentEditable = \"false\";\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  become(other) {\n    if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n      if (!this.widget.compare(other.widget)) this.markDirty(true);\n      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n      this.widget = other.widget;\n      this.length = other.length;\n      return true;\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n  get overrideDOMText() {\n    if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    let top = this;\n    while (top.parent) top = top.parent;\n    let {\n        view\n      } = top,\n      text = view && view.state.doc,\n      start = this.posAtStart;\n    return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n  domAtPos(pos) {\n    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(pos, side) {\n    let custom = this.widget.coordsAt(this.dom, pos, side);\n    if (custom) return custom;\n    let rects = this.dom.getClientRects(),\n      rect = null;\n    if (!rects.length) return null;\n    let fromBack = this.side ? this.side < 0 : pos > 0;\n    for (let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1) {\n      rect = rects[i];\n      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n    }\n    return flattenRect(rect, !fromBack);\n  }\n  get isEditable() {\n    return false;\n  }\n  get isWidget() {\n    return true;\n  }\n  get isHidden() {\n    return this.widget.isHidden;\n  }\n  destroy() {\n    super.destroy();\n    if (this.dom) this.widget.destroy(this.dom);\n  }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n  constructor(side) {\n    super();\n    this.side = side;\n  }\n  get length() {\n    return 0;\n  }\n  merge() {\n    return false;\n  }\n  become(other) {\n    return other instanceof WidgetBufferView && other.side == this.side;\n  }\n  split() {\n    return new WidgetBufferView(this.side);\n  }\n  sync() {\n    if (!this.dom) {\n      let dom = document.createElement(\"img\");\n      dom.className = \"cm-widgetBuffer\";\n      dom.setAttribute(\"aria-hidden\", \"true\");\n      this.setDOM(dom);\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  domAtPos(pos) {\n    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n  }\n  localPosFromDOM() {\n    return 0;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(pos) {\n    return this.dom.getBoundingClientRect();\n  }\n  get overrideDOMText() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n  get isHidden() {\n    return true;\n  }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n  let dom = parent.dom,\n    {\n      children\n    } = parent,\n    i = 0;\n  for (let off = 0; i < children.length; i++) {\n    let child = children[i],\n      end = off + child.length;\n    if (end == off && child.getSide() <= 0) continue;\n    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n    if (pos <= off) break;\n    off = end;\n  }\n  for (let j = i; j > 0; j--) {\n    let prev = children[j - 1];\n    if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n  }\n  for (let j = i; j < children.length; j++) {\n    let next = children[j];\n    if (next.dom.parentNode == dom) return next.domAtPos(0);\n  }\n  return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n  let last,\n    {\n      children\n    } = parent;\n  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n    joinInlineInto(last, view.children[0], open - 1);\n  } else {\n    children.push(view);\n    view.setParent(parent);\n  }\n  parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n  let before = null,\n    beforePos = -1,\n    after = null,\n    afterPos = -1;\n  function scan(view, pos) {\n    for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {\n      let child = view.children[i],\n        end = off + child.length;\n      if (end >= pos) {\n        if (child.children.length) {\n          scan(child, pos - off);\n        } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {\n          after = child;\n          afterPos = pos - off;\n        } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n          before = child;\n          beforePos = pos - off;\n        }\n      }\n      off = end;\n    }\n  }\n  scan(view, pos);\n  let target = (side < 0 ? before : after) || before || after;\n  if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n  return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n  let last = view.dom.lastChild;\n  if (!last) return view.dom.getBoundingClientRect();\n  let rects = clientRectsFor(last);\n  return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n  for (let name in source) {\n    if (name == \"class\" && target.class) target.class += \" \" + source.class;else if (name == \"style\" && target.style) target.style += \";\" + source.style;else target[name] = source[name];\n  }\n  return target;\n}\nconst noAttrs = /*@__PURE__*/Object.create(null);\nfunction attrsEq(a, b, ignore) {\n  if (a == b) return true;\n  if (!a) a = noAttrs;\n  if (!b) b = noAttrs;\n  let keysA = Object.keys(a),\n    keysB = Object.keys(b);\n  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n  for (let key of keysA) {\n    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n  }\n  return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n  let changed = false;\n  if (prev) for (let name in prev) if (!(attrs && name in attrs)) {\n    changed = true;\n    if (name == \"style\") dom.style.cssText = \"\";else dom.removeAttribute(name);\n  }\n  if (attrs) for (let name in attrs) if (!(prev && prev[name] == attrs[name])) {\n    changed = true;\n    if (name == \"style\") dom.style.cssText = attrs[name];else dom.setAttribute(name, attrs[name]);\n  }\n  return changed;\n}\nfunction getAttrs(dom) {\n  let attrs = Object.create(null);\n  for (let i = 0; i < dom.attributes.length; i++) {\n    let attr = dom.attributes[i];\n    attrs[attr.name] = attr.value;\n  }\n  return attrs;\n}\nclass LineView extends ContentView {\n  constructor() {\n    super(...arguments);\n    this.children = [];\n    this.length = 0;\n    this.prevAttrs = undefined;\n    this.attrs = null;\n    this.breakAfter = 0;\n  }\n  // Consumes source\n  merge(from, to, source, hasStart, openStart, openEnd) {\n    if (source) {\n      if (!(source instanceof LineView)) return false;\n      if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n    }\n    if (hasStart) this.setDeco(source ? source.attrs : null);\n    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);\n    return true;\n  }\n  split(at) {\n    let end = new LineView();\n    end.breakAfter = this.breakAfter;\n    if (this.length == 0) return end;\n    let {\n      i,\n      off\n    } = this.childPos(at);\n    if (off) {\n      end.append(this.children[i].split(off), 0);\n      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n      i++;\n    }\n    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0);\n    while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy();\n    this.children.length = i;\n    this.markDirty();\n    this.length = at;\n    return end;\n  }\n  transferDOM(other) {\n    if (!this.dom) return;\n    this.markDirty();\n    other.setDOM(this.dom);\n    other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n    this.prevAttrs = undefined;\n    this.dom = null;\n  }\n  setDeco(attrs) {\n    if (!attrsEq(this.attrs, attrs)) {\n      if (this.dom) {\n        this.prevAttrs = this.attrs;\n        this.markDirty();\n      }\n      this.attrs = attrs;\n    }\n  }\n  append(child, openStart) {\n    joinInlineInto(this, child, openStart);\n  }\n  // Only called when building a line view in ContentBuilder\n  addLineDeco(deco) {\n    let attrs = deco.spec.attributes,\n      cls = deco.spec.class;\n    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n    if (cls) this.attrs = combineAttrs({\n      class: cls\n    }, this.attrs || {});\n  }\n  domAtPos(pos) {\n    return inlineDOMAtPos(this, pos);\n  }\n  reuseDOM(node) {\n    if (node.nodeName == \"DIV\") {\n      this.setDOM(node);\n      this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;\n    }\n  }\n  sync(view, track) {\n    var _a;\n    if (!this.dom) {\n      this.setDOM(document.createElement(\"div\"));\n      this.dom.className = \"cm-line\";\n      this.prevAttrs = this.attrs ? null : undefined;\n    } else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {\n      clearAttributes(this.dom);\n      this.dom.className = \"cm-line\";\n      this.prevAttrs = this.attrs ? null : undefined;\n    }\n    if (this.prevAttrs !== undefined) {\n      updateAttrs(this.dom, this.prevAttrs, this.attrs);\n      this.dom.classList.add(\"cm-line\");\n      this.prevAttrs = undefined;\n    }\n    super.sync(view, track);\n    let last = this.dom.lastChild;\n    while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;\n    if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {\n      let hack = document.createElement(\"BR\");\n      hack.cmIgnore = true;\n      this.dom.appendChild(hack);\n    }\n  }\n  measureTextSize() {\n    if (this.children.length == 0 || this.length > 20) return null;\n    let totalWidth = 0,\n      textHeight;\n    for (let child of this.children) {\n      if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n      let rects = clientRectsFor(child.dom);\n      if (rects.length != 1) return null;\n      totalWidth += rects[0].width;\n      textHeight = rects[0].height;\n    }\n    return !totalWidth ? null : {\n      lineHeight: this.dom.getBoundingClientRect().height,\n      charWidth: totalWidth / this.length,\n      textHeight\n    };\n  }\n  coordsAt(pos, side) {\n    let rect = coordsInChildren(this, pos, side);\n    // Correct rectangle height for empty lines when the returned\n    // height is larger than the text height.\n    if (!this.children.length && rect && this.parent) {\n      let {\n          heightOracle\n        } = this.parent.view.viewState,\n        height = rect.bottom - rect.top;\n      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n        let dist = (height - heightOracle.textHeight) / 2;\n        return {\n          top: rect.top + dist,\n          bottom: rect.bottom - dist,\n          left: rect.left,\n          right: rect.left\n        };\n      }\n    }\n    return rect;\n  }\n  become(_other) {\n    return false;\n  }\n  covers() {\n    return true;\n  }\n  static find(docView, pos) {\n    for (let i = 0, off = 0; i < docView.children.length; i++) {\n      let block = docView.children[i],\n        end = off + block.length;\n      if (end >= pos) {\n        if (block instanceof LineView) return block;\n        if (end > pos) break;\n      }\n      off = end + block.breakAfter;\n    }\n    return null;\n  }\n}\nclass BlockWidgetView extends ContentView {\n  constructor(widget, length, deco) {\n    super();\n    this.widget = widget;\n    this.length = length;\n    this.deco = deco;\n    this.breakAfter = 0;\n    this.prevWidget = null;\n  }\n  merge(from, to, source, _takeDeco, openStart, openEnd) {\n    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n    this.length = from + (source ? source.length : 0) + (this.length - to);\n    return true;\n  }\n  domAtPos(pos) {\n    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n  }\n  split(at) {\n    let len = this.length - at;\n    this.length = at;\n    let end = new BlockWidgetView(this.widget, len, this.deco);\n    end.breakAfter = this.breakAfter;\n    return end;\n  }\n  get children() {\n    return noChildren;\n  }\n  sync(view) {\n    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n      this.prevWidget = null;\n      this.setDOM(this.widget.toDOM(view));\n      if (!this.widget.editable) this.dom.contentEditable = \"false\";\n    }\n  }\n  get overrideDOMText() {\n    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  become(other) {\n    if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n      if (!other.widget.compare(this.widget)) this.markDirty(true);\n      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n      this.widget = other.widget;\n      this.length = other.length;\n      this.deco = other.deco;\n      this.breakAfter = other.breakAfter;\n      return true;\n    }\n    return false;\n  }\n  ignoreMutation() {\n    return true;\n  }\n  ignoreEvent(event) {\n    return this.widget.ignoreEvent(event);\n  }\n  get isEditable() {\n    return false;\n  }\n  get isWidget() {\n    return true;\n  }\n  coordsAt(pos, side) {\n    return this.widget.coordsAt(this.dom, pos, side);\n  }\n  destroy() {\n    super.destroy();\n    if (this.dom) this.widget.destroy(this.dom);\n  }\n  covers(side) {\n    let {\n      startSide,\n      endSide\n    } = this.deco;\n    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n  }\n}\n\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/\nclass WidgetType {\n  /**\n  Compare this instance to another instance of the same type.\n  (TypeScript can't express this, but only instances of the same\n  specific class will be passed to this method.) This is used to\n  avoid redrawing widgets when they are replaced by a new\n  decoration of the same type. The default implementation just\n  returns `false`, which will cause new instances of the widget to\n  always be redrawn.\n  */\n  eq(widget) {\n    return false;\n  }\n  /**\n  Update a DOM element created by a widget of the same type (but\n  different, non-`eq` content) to reflect this widget. May return\n  true to indicate that it could update, false to indicate it\n  couldn't (in which case the widget will be redrawn). The default\n  implementation just returns false.\n  */\n  updateDOM(dom, view) {\n    return false;\n  }\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  The estimated height this widget will have, to be used when\n  estimating the height of content that hasn't been drawn. May\n  return -1 to indicate you don't know. The default implementation\n  returns -1.\n  */\n  get estimatedHeight() {\n    return -1;\n  }\n  /**\n  For inline widgets that are displayed inline (as opposed to\n  `inline-block`) and introduce line breaks (through `<br>` tags\n  or textual newlines), this must indicate the amount of line\n  breaks they introduce. Defaults to 0.\n  */\n  get lineBreaks() {\n    return 0;\n  }\n  /**\n  Can be used to configure which kinds of events inside the widget\n  should be ignored by the editor. The default is to ignore all\n  events.\n  */\n  ignoreEvent(event) {\n    return true;\n  }\n  /**\n  Override the way screen coordinates for positions at/in the\n  widget are found. `pos` will be the offset into the widget, and\n  `side` the side of the position that is being queried—less than\n  zero for before, greater than zero for after, and zero for\n  directly at that position.\n  */\n  coordsAt(dom, pos, side) {\n    return null;\n  }\n  /**\n  @internal\n  */\n  get isHidden() {\n    return false;\n  }\n  /**\n  @internal\n  */\n  get editable() {\n    return false;\n  }\n  /**\n  This is called when the an instance of the widget is removed\n  from the editor view.\n  */\n  destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/\nvar BlockType = /*@__PURE__*/function (BlockType) {\n  /**\n  A line of text.\n  */\n  BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n  /**\n  A block widget associated with the position after it.\n  */\n  BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n  /**\n  A block widget associated with the position before it.\n  */\n  BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n  /**\n  A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n  */\n  BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n  return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/\nclass Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n  constructor(\n  /**\n  @internal\n  */\n  startSide,\n  /**\n  @internal\n  */\n  endSide,\n  /**\n  @internal\n  */\n  widget,\n  /**\n  The config object used to create this decoration. You can\n  include additional properties in there to store metadata about\n  your decoration.\n  */\n  spec) {\n    super();\n    this.startSide = startSide;\n    this.endSide = endSide;\n    this.widget = widget;\n    this.spec = spec;\n  }\n  /**\n  @internal\n  */\n  get heightRelevant() {\n    return false;\n  }\n  /**\n  Create a mark decoration, which influences the styling of the\n  content in its range. Nested mark decorations will cause nested\n  DOM elements to be created. Nesting order is determined by\n  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n  the higher-precedence decorations creating the inner DOM nodes.\n  Such elements are split on line boundaries and on the boundaries\n  of lower-precedence decorations.\n  */\n  static mark(spec) {\n    return new MarkDecoration(spec);\n  }\n  /**\n  Create a widget decoration, which displays a DOM element at the\n  given position.\n  */\n  static widget(spec) {\n    let side = Math.max(-10000, Math.min(10000, spec.side || 0)),\n      block = !!spec.block;\n    side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */ : side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */;\n    return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n  }\n  /**\n  Create a replace decoration which replaces the given range with\n  a widget, or simply hides it.\n  */\n  static replace(spec) {\n    let block = !!spec.block,\n      startSide,\n      endSide;\n    if (spec.isBlockGap) {\n      startSide = -500000000 /* Side.GapStart */;\n      endSide = 400000000 /* Side.GapEnd */;\n    } else {\n      let {\n        start,\n        end\n      } = getInclusive(spec, block);\n      startSide = (start ? block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */) - 1;\n      endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */) + 1;\n    }\n    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n  }\n  /**\n  Create a line decoration, which can add DOM attributes to the\n  line starting at the given position.\n  */\n  static line(spec) {\n    return new LineDecoration(spec);\n  }\n  /**\n  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n  decorated range or ranges. If the ranges aren't already sorted,\n  pass `true` for `sort` to make the library sort them for you.\n  */\n  static set(of, sort = false) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n  }\n  /**\n  @internal\n  */\n  hasHeight() {\n    return this.widget ? this.widget.estimatedHeight > -1 : false;\n  }\n}\n/**\nThe empty set of decorations.\n*/\nDecoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n  constructor(spec) {\n    let {\n      start,\n      end\n    } = getInclusive(spec);\n    super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);\n    this.tagName = spec.tagName || \"span\";\n    this.class = spec.class || \"\";\n    this.attrs = spec.attributes || null;\n  }\n  eq(other) {\n    var _a, _b;\n    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n  }\n  range(from, to = from) {\n    if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n    return super.range(from, to);\n  }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n  constructor(spec) {\n    super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);\n  }\n  eq(other) {\n    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n  }\n  range(from, to = from) {\n    if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n    return super.range(from, to);\n  }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n  constructor(spec, startSide, endSide, block, widget, isReplace) {\n    super(startSide, endSide, widget, spec);\n    this.block = block;\n    this.isReplace = isReplace;\n    this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n  }\n  // Only relevant when this.block == true\n  get type() {\n    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n  }\n  get heightRelevant() {\n    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n  }\n  eq(other) {\n    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n  }\n  range(from, to = from) {\n    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n    if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n    return super.range(from, to);\n  }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n  let {\n    inclusiveStart: start,\n    inclusiveEnd: end\n  } = spec;\n  if (start == null) start = spec.inclusive;\n  if (end == null) end = spec.inclusive;\n  return {\n    start: start !== null && start !== void 0 ? start : block,\n    end: end !== null && end !== void 0 ? end : block\n  };\n}\nfunction widgetsEq(a, b) {\n  return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n  let last = ranges.length - 1;\n  if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);\n}\nclass ContentBuilder {\n  constructor(doc, pos, end, disallowBlockEffectsFor) {\n    this.doc = doc;\n    this.pos = pos;\n    this.end = end;\n    this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n    this.content = [];\n    this.curLine = null;\n    this.breakAtStart = 0;\n    this.pendingBuffer = 0 /* Buf.No */;\n    this.bufferMarks = [];\n    // Set to false directly after a widget that covers the position after it\n    this.atCursorPos = true;\n    this.openStart = -1;\n    this.openEnd = -1;\n    this.text = \"\";\n    this.textOff = 0;\n    this.cursor = doc.iter();\n    this.skip = pos;\n  }\n  posCovered() {\n    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n    let last = this.content[this.content.length - 1];\n    return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n  }\n  getLine() {\n    if (!this.curLine) {\n      this.content.push(this.curLine = new LineView());\n      this.atCursorPos = true;\n    }\n    return this.curLine;\n  }\n  flushBuffer(active = this.bufferMarks) {\n    if (this.pendingBuffer) {\n      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n      this.pendingBuffer = 0 /* Buf.No */;\n    }\n  }\n  addBlockWidget(view) {\n    this.flushBuffer();\n    this.curLine = null;\n    this.content.push(view);\n  }\n  finish(openEnd) {\n    if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();else this.pendingBuffer = 0 /* Buf.No */;\n    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n  }\n  buildText(length, active, openStart) {\n    while (length > 0) {\n      if (this.textOff == this.text.length) {\n        let {\n          value,\n          lineBreak,\n          done\n        } = this.cursor.next(this.skip);\n        this.skip = 0;\n        if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n        if (lineBreak) {\n          if (!this.posCovered()) this.getLine();\n          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;\n          this.flushBuffer();\n          this.curLine = null;\n          this.atCursorPos = true;\n          length--;\n          continue;\n        } else {\n          this.text = value;\n          this.textOff = 0;\n        }\n      }\n      let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);\n      this.flushBuffer(active.slice(active.length - openStart));\n      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n      this.atCursorPos = true;\n      this.textOff += take;\n      length -= take;\n      openStart = 0;\n    }\n  }\n  span(from, to, active, openStart) {\n    this.buildText(to - from, active, openStart);\n    this.pos = to;\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  point(from, to, deco, active, openStart, index) {\n    if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n      if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n      if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n    }\n    let len = to - from;\n    if (deco instanceof PointDecoration) {\n      if (deco.block) {\n        if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, deco));\n      } else {\n        let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n        let line = this.getLine();\n        if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */;\n        this.flushBuffer(active);\n        if (cursorBefore) {\n          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n          openStart = active.length + Math.max(0, openStart - active.length);\n        }\n        line.append(wrapMarks(view, active), openStart);\n        this.atCursorPos = cursorAfter;\n        this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;\n        if (this.pendingBuffer) this.bufferMarks = active.slice();\n      }\n    } else if (this.doc.lineAt(this.pos).from == this.pos) {\n      // Line decoration\n      this.getLine().addLineDeco(deco);\n    }\n    if (len) {\n      // Advance the iterator past the replaced content\n      if (this.textOff + len <= this.text.length) {\n        this.textOff += len;\n      } else {\n        this.skip += len - (this.text.length - this.textOff);\n        this.text = \"\";\n        this.textOff = 0;\n      }\n      this.pos = to;\n    }\n    if (this.openStart < 0) this.openStart = openStart;\n  }\n  static build(text, from, to, decorations, dynamicDecorationMap) {\n    let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n    builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n    if (builder.openStart < 0) builder.openStart = builder.openEnd;\n    builder.finish(builder.openEnd);\n    return builder;\n  }\n}\nfunction wrapMarks(view, active) {\n  for (let mark of active) view = new MarkView(mark, [view], view.length);\n  return view;\n}\nclass NullWidget extends WidgetType {\n  constructor(tag) {\n    super();\n    this.tag = tag;\n  }\n  eq(other) {\n    return other.tag == this.tag;\n  }\n  toDOM() {\n    return document.createElement(this.tag);\n  }\n  updateDOM(elt) {\n    return elt.nodeName.toLowerCase() == this.tag;\n  }\n  get isHidden() {\n    return true;\n  }\n}\n\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/\nvar Direction = /*@__PURE__*/function (Direction) {\n  // (These are chosen to match the base levels, in bidi algorithm\n  // terms, of spans in that direction.)\n  /**\n  Left-to-right.\n  */\n  Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n  /**\n  Right-to-left.\n  */\n  Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n  return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR,\n  RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n  let result = [];\n  for (let i = 0; i < str.length; i++) result.push(1 << +str[i]);\n  return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/Object.create(null),\n  BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\"()\", \"[]\", \"{}\"]) {\n  let l = /*@__PURE__*/p.charCodeAt(0),\n    r = /*@__PURE__*/p.charCodeAt(1);\n  Brackets[l] = r;\n  Brackets[r] = -l;\n}\nfunction charType(ch) {\n  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */ : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/\nclass BidiSpan {\n  /**\n  The direction of this span.\n  */\n  get dir() {\n    return this.level % 2 ? RTL : LTR;\n  }\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The start of the span (relative to the start of the line).\n  */\n  from,\n  /**\n  The end of the span.\n  */\n  to,\n  /**\n  The [\"bidi\n  level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n  of the span (in this context, 0 means\n  left-to-right, 1 means right-to-left, 2 means left-to-right\n  number inside right-to-left text).\n  */\n  level) {\n    this.from = from;\n    this.to = to;\n    this.level = level;\n  }\n  /**\n  @internal\n  */\n  side(end, dir) {\n    return this.dir == dir == end ? this.to : this.from;\n  }\n  /**\n  @internal\n  */\n  forward(forward, dir) {\n    return forward == (this.dir == dir);\n  }\n  /**\n  @internal\n  */\n  static find(order, index, level, assoc) {\n    let maybe = -1;\n    for (let i = 0; i < order.length; i++) {\n      let span = order[i];\n      if (span.from <= index && span.to >= index) {\n        if (span.level == level) return i;\n        // When multiple spans match, if assoc != 0, take the one that\n        // covers that side, otherwise take the one with the minimum\n        // level.\n        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n      }\n    }\n    if (maybe < 0) throw new RangeError(\"Index out of range\");\n    return maybe;\n  }\n}\nfunction isolatesEq(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let iA = a[i],\n      iB = b[i];\n    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n  }\n  return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n  for (let iI = 0; iI <= isolates.length; iI++) {\n    let from = iI ? isolates[iI - 1].to : rFrom,\n      to = iI < isolates.length ? isolates[iI].from : rTo;\n    let prevType = iI ? 256 /* T.NI */ : outerType;\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    // (Left after this: L, R, EN, AN, ET, CS, NI)\n    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {\n      let type = charType(line.charCodeAt(i));\n      if (type == 512 /* T.NSM */) type = prev;else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */) type = 16 /* T.AN */;\n      types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;\n      if (type & 7 /* T.Strong */) prevStrong = type;\n      prev = type;\n    }\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    // (Left after this: L, R, EN+AN, NI)\n    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {\n      let type = types[i];\n      if (type == 128 /* T.CS */) {\n        if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */) type = types[i] = prev;else types[i] = 256 /* T.NI */;\n      } else if (type == 64 /* T.ET */) {\n        let end = i + 1;\n        while (end < to && types[end] == 64 /* T.ET */) end++;\n        let replace = i && prev == 8 /* T.EN */ || end < rTo && types[end] == 8 /* T.EN */ ? prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */ : 256 /* T.NI */;\n        for (let j = i; j < end; j++) types[j] = replace;\n        i = end - 1;\n      } else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {\n        types[i] = 1 /* T.L */;\n      }\n      prev = type;\n      if (type & 7 /* T.Strong */) prevStrong = type;\n    }\n  }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n  let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;\n  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {\n    let from = iI ? isolates[iI - 1].to : rFrom,\n      to = iI < isolates.length ? isolates[iI].from : rTo;\n    // N0. Process bracket pairs in an isolating run sequence\n    // sequentially in the logical order of the text positions of the\n    // opening paired brackets using the logic given below. Within this\n    // scope, bidirectional types EN and AN are treated as R.\n    for (let i = from, ch, br, type; i < to; i++) {\n      // Keeps [startIndex, type, strongSeen] triples for each open\n      // bracket on BracketStack.\n      if (br = Brackets[ch = line.charCodeAt(i)]) {\n        if (br < 0) {\n          // Closing bracket\n          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n            if (BracketStack[sJ + 1] == -br) {\n              let flags = BracketStack[sJ + 2];\n              let type = flags & 2 /* Bracketed.EmbedInside */ ? outerType : !(flags & 4 /* Bracketed.OppositeInside */) ? 0 : flags & 1 /* Bracketed.OppositeBefore */ ? oppositeType : outerType;\n              if (type) types[i] = types[BracketStack[sJ]] = type;\n              sI = sJ;\n              break;\n            }\n          }\n        } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {\n          break;\n        } else {\n          BracketStack[sI++] = i;\n          BracketStack[sI++] = ch;\n          BracketStack[sI++] = context;\n        }\n      } else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {\n        let embed = type == outerType;\n        context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;\n        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {\n          let cur = BracketStack[sJ + 2];\n          if (cur & 2 /* Bracketed.EmbedInside */) break;\n          if (embed) {\n            BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;\n          } else {\n            if (cur & 4 /* Bracketed.OppositeInside */) break;\n            BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;\n          }\n        }\n      }\n    }\n  }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {\n    let from = iI ? isolates[iI - 1].to : rFrom,\n      to = iI < isolates.length ? isolates[iI].from : rTo;\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    // (Left after this: L, R, EN+AN)\n    for (let i = from; i < to;) {\n      let type = types[i];\n      if (type == 256 /* T.NI */) {\n        let end = i + 1;\n        for (;;) {\n          if (end == to) {\n            if (iI == isolates.length) break;\n            end = isolates[iI++].to;\n            to = iI < isolates.length ? isolates[iI].from : rTo;\n          } else if (types[end] == 256 /* T.NI */) {\n            end++;\n          } else {\n            break;\n          }\n        }\n        let beforeL = prev == 1 /* T.L */;\n        let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */;\n        let replace = beforeL == afterL ? beforeL ? 1 /* T.L */ : 2 /* T.R */ : outerType;\n        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {\n          if (j == fromJ) {\n            j = isolates[--jI].from;\n            fromJ = jI ? isolates[jI - 1].to : rFrom;\n          }\n          types[--j] = replace;\n        }\n        i = end;\n      } else {\n        prev = type;\n        i++;\n      }\n    }\n  }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n  let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;\n  if (level % 2 == baseLevel % 2) {\n    // Same dir as base direction, don't flip\n    for (let iCh = from, iI = 0; iCh < to;) {\n      // Scan a section of characters in direction ourType, unless\n      // there's another type of char right after iCh, in which case\n      // we scan a section of other characters (which, if ourType ==\n      // T.L, may contain both T.R and T.AN chars).\n      let sameDir = true,\n        isNum = false;\n      if (iI == isolates.length || iCh < isolates[iI].from) {\n        let next = types[iCh];\n        if (next != ourType) {\n          sameDir = false;\n          isNum = next == 16 /* T.AN */;\n        }\n      }\n      // Holds an array of isolates to pass to a recursive call if we\n      // must recurse (to distinguish T.AN inside an RTL section in\n      // LTR text), null if we can emit directly\n      let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;\n      let localLevel = sameDir ? level : level + 1;\n      let iScan = iCh;\n      run: for (;;) {\n        if (iI < isolates.length && iScan == isolates[iI].from) {\n          if (isNum) break run;\n          let iso = isolates[iI];\n          // Scan ahead to verify that there is another char in this dir after the isolate(s)\n          if (!sameDir) for (let upto = iso.to, jI = iI + 1;;) {\n            if (upto == to) break run;\n            if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;else if (types[upto] == ourType) break run;else break;\n          }\n          iI++;\n          if (recurse) {\n            recurse.push(iso);\n          } else {\n            if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n            let dirSwap = iso.direction == LTR != !(localLevel % 2);\n            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n            iCh = iso.to;\n          }\n          iScan = iso.to;\n        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n          break;\n        } else {\n          iScan++;\n        }\n      }\n      if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n      iCh = iScan;\n    }\n  } else {\n    // Iterate in reverse to flip the span order. Same code again, but\n    // going from the back of the section to the front\n    for (let iCh = to, iI = isolates.length; iCh > from;) {\n      let sameDir = true,\n        isNum = false;\n      if (!iI || iCh > isolates[iI - 1].to) {\n        let next = types[iCh - 1];\n        if (next != ourType) {\n          sameDir = false;\n          isNum = next == 16 /* T.AN */;\n        }\n      }\n      let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;\n      let localLevel = sameDir ? level : level + 1;\n      let iScan = iCh;\n      run: for (;;) {\n        if (iI && iScan == isolates[iI - 1].to) {\n          if (isNum) break run;\n          let iso = isolates[--iI];\n          // Scan ahead to verify that there is another char in this dir after the isolate(s)\n          if (!sameDir) for (let upto = iso.from, jI = iI;;) {\n            if (upto == from) break run;\n            if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;else if (types[upto - 1] == ourType) break run;else break;\n          }\n          if (recurse) {\n            recurse.push(iso);\n          } else {\n            if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n            let dirSwap = iso.direction == LTR != !(localLevel % 2);\n            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n            iCh = iso.from;\n          }\n          iScan = iso.from;\n        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n          break;\n        } else {\n          iScan--;\n        }\n      }\n      if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n      iCh = iScan;\n    }\n  }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n  let outerType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;\n  computeCharTypes(line, from, to, isolates, outerType);\n  processBracketPairs(line, from, to, isolates, outerType);\n  processNeutrals(from, to, isolates, outerType);\n  emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n  if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];\n  if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n  if (isolates.length) while (line.length > types.length) types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps\n  let order = [],\n    level = direction == LTR ? 0 : 1;\n  computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n  return order;\n}\nfunction trivialOrder(length) {\n  return [new BidiSpan(0, length, 0)];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n  var _a;\n  let startIndex = start.head - line.from;\n  let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n  let span = order[spanI],\n    spanEnd = span.side(forward, dir);\n  // End of span\n  if (startIndex == spanEnd) {\n    let nextI = spanI += forward ? 1 : -1;\n    if (nextI < 0 || nextI >= order.length) return null;\n    span = order[spanI = nextI];\n    startIndex = span.side(!forward, dir);\n    spanEnd = span.side(forward, dir);\n  }\n  let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n  if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n  for (let i = from; i < to; i++) {\n    let type = charType(text.charCodeAt(i));\n    if (type == 1 /* T.L */) return LTR;\n    if (type == 2 /* T.R */ || type == 4 /* T.AL */) return RTL;\n  }\n  return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\nclass ScrollTarget {\n  constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5,\n  // This data structure is abused to also store precise scroll\n  // snapshots, instead of a `scrollIntoView` request. When this\n  // flag is `true`, `range` points at a position in the reference\n  // line, `yMargin` holds the difference between the top of that\n  // line and the top of the editor, and `xMargin` holds the\n  // editor's `scrollLeft`.\n  isSnapshot = false) {\n    this.range = range;\n    this.y = y;\n    this.x = x;\n    this.yMargin = yMargin;\n    this.xMargin = xMargin;\n    this.isSnapshot = isSnapshot;\n  }\n  map(changes) {\n    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n  }\n  clip(state) {\n    return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n  }\n}\nconst scrollIntoView = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n  map: (t, ch) => t.map(ch)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/\nfunction logException(state, exception, context) {\n  let handler = state.facet(exceptionSink);\n  if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + \":\", exception);else console.error(exception);\n}\nconst editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/\nclass ViewPlugin {\n  constructor(\n  /**\n  @internal\n  */\n  id,\n  /**\n  @internal\n  */\n  create,\n  /**\n  @internal\n  */\n  domEventHandlers,\n  /**\n  @internal\n  */\n  domEventObservers, buildExtensions) {\n    this.id = id;\n    this.create = create;\n    this.domEventHandlers = domEventHandlers;\n    this.domEventObservers = domEventObservers;\n    this.extension = buildExtensions(this);\n  }\n  /**\n  Define a plugin from a constructor function that creates the\n  plugin's value, given an editor view.\n  */\n  static define(create, spec) {\n    const {\n      eventHandlers,\n      eventObservers,\n      provide,\n      decorations: deco\n    } = spec || {};\n    return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {\n      let ext = [viewPlugin.of(plugin)];\n      if (deco) ext.push(decorations.of(view => {\n        let pluginInst = view.plugin(plugin);\n        return pluginInst ? deco(pluginInst) : Decoration.none;\n      }));\n      if (provide) ext.push(provide(plugin));\n      return ext;\n    });\n  }\n  /**\n  Create a plugin for a class whose constructor takes a single\n  editor view as argument.\n  */\n  static fromClass(cls, spec) {\n    return ViewPlugin.define(view => new cls(view), spec);\n  }\n}\nclass PluginInstance {\n  constructor(spec) {\n    this.spec = spec;\n    // When starting an update, all plugins have this field set to the\n    // update object, indicating they need to be updated. When finished\n    // updating, it is set to `false`. Retrieving a plugin that needs to\n    // be updated with `view.plugin` forces an eager update.\n    this.mustUpdate = null;\n    // This is null when the plugin is initially created, but\n    // initialized on the first update.\n    this.value = null;\n  }\n  update(view) {\n    if (!this.value) {\n      if (this.spec) {\n        try {\n          this.value = this.spec.create(view);\n        } catch (e) {\n          logException(view.state, e, \"CodeMirror plugin crashed\");\n          this.deactivate();\n        }\n      }\n    } else if (this.mustUpdate) {\n      let update = this.mustUpdate;\n      this.mustUpdate = null;\n      if (this.value.update) {\n        try {\n          this.value.update(update);\n        } catch (e) {\n          logException(update.state, e, \"CodeMirror plugin crashed\");\n          if (this.value.destroy) try {\n            this.value.destroy();\n          } catch (_) {}\n          this.deactivate();\n        }\n      }\n    }\n    return this;\n  }\n  destroy(view) {\n    var _a;\n    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n      try {\n        this.value.destroy();\n      } catch (e) {\n        logException(view.state, e, \"CodeMirror plugin crashed\");\n      }\n    }\n  }\n  deactivate() {\n    this.spec = this.value = null;\n  }\n}\nconst editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst outerDecorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n  let isolates = view.state.facet(bidiIsolatedRanges);\n  if (!isolates.length) return isolates;\n  let sets = isolates.map(i => i instanceof Function ? i(view) : i);\n  let result = [];\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, line.from, line.to, {\n    point() {},\n    span(fromDoc, toDoc, active, open) {\n      let from = fromDoc - line.from,\n        to = toDoc - line.from;\n      let level = result;\n      for (let i = active.length - 1; i >= 0; i--, open--) {\n        let direction = active[i].spec.bidiIsolate,\n          update;\n        if (direction == null) direction = autoDirection(line.text, from, to);\n        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n          update.to = to;\n          level = update.inner;\n        } else {\n          let add = {\n            from,\n            to,\n            direction,\n            inner: []\n          };\n          level.push(add);\n          level = add.inner;\n        }\n      }\n    }\n  });\n  return result;\n}\nconst scrollMargins = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n  let left = 0,\n    right = 0,\n    top = 0,\n    bottom = 0;\n  for (let source of view.state.facet(scrollMargins)) {\n    let m = source(view);\n    if (m) {\n      if (m.left != null) left = Math.max(left, m.left);\n      if (m.right != null) right = Math.max(right, m.right);\n      if (m.top != null) top = Math.max(top, m.top);\n      if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n    }\n  }\n  return {\n    left,\n    right,\n    top,\n    bottom\n  };\n}\nconst styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n  constructor(fromA, toA, fromB, toB) {\n    this.fromA = fromA;\n    this.toA = toA;\n    this.fromB = fromB;\n    this.toB = toB;\n  }\n  join(other) {\n    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n  }\n  addToSet(set) {\n    let i = set.length,\n      me = this;\n    for (; i > 0; i--) {\n      let range = set[i - 1];\n      if (range.fromA > me.toA) continue;\n      if (range.toA < me.fromA) break;\n      me = me.join(range);\n      set.splice(i - 1, 1);\n    }\n    set.splice(i, 0, me);\n    return set;\n  }\n  static extendWithRanges(diff, ranges) {\n    if (ranges.length == 0) return diff;\n    let result = [];\n    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n      let next = dI == diff.length ? null : diff[dI],\n        off = posA - posB;\n      let end = next ? next.fromB : 1e9;\n      while (rI < ranges.length && ranges[rI] < end) {\n        let from = ranges[rI],\n          to = ranges[rI + 1];\n        let fromB = Math.max(posB, from),\n          toB = Math.min(end, to);\n        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n        if (to > end) break;else rI += 2;\n      }\n      if (!next) return result;\n      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n      posA = next.toA;\n      posB = next.toB;\n    }\n  }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/\nclass ViewUpdate {\n  constructor(\n  /**\n  The editor view that the update is associated with.\n  */\n  view,\n  /**\n  The new editor state.\n  */\n  state,\n  /**\n  The transactions involved in the update. May be empty.\n  */\n  transactions) {\n    this.view = view;\n    this.state = state;\n    this.transactions = transactions;\n    /**\n    @internal\n    */\n    this.flags = 0;\n    this.startState = view.state;\n    this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n    for (let tr of transactions) this.changes = this.changes.compose(tr.changes);\n    let changedRanges = [];\n    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n    this.changedRanges = changedRanges;\n  }\n  /**\n  @internal\n  */\n  static create(view, state, transactions) {\n    return new ViewUpdate(view, state, transactions);\n  }\n  /**\n  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n  update.\n  */\n  get viewportChanged() {\n    return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;\n  }\n  /**\n  Indicates whether the height of a block element in the editor\n  changed in this update.\n  */\n  get heightChanged() {\n    return (this.flags & 2 /* UpdateFlag.Height */) > 0;\n  }\n  /**\n  Returns true when the document was modified or the size of the\n  editor, or elements within the editor, changed.\n  */\n  get geometryChanged() {\n    return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;\n  }\n  /**\n  True when this update indicates a focus change.\n  */\n  get focusChanged() {\n    return (this.flags & 1 /* UpdateFlag.Focus */) > 0;\n  }\n  /**\n  Whether the document changed in this update.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Whether the selection was explicitly set in this update.\n  */\n  get selectionSet() {\n    return this.transactions.some(tr => tr.selection);\n  }\n  /**\n  @internal\n  */\n  get empty() {\n    return this.flags == 0 && this.transactions.length == 0;\n  }\n}\nclass DocView extends ContentView {\n  get length() {\n    return this.view.state.doc.length;\n  }\n  constructor(view) {\n    super();\n    this.view = view;\n    this.decorations = [];\n    this.dynamicDecorationMap = [];\n    this.domChanged = null;\n    this.hasComposition = null;\n    this.markedForComposition = new Set();\n    // Track a minimum width for the editor. When measuring sizes in\n    // measureVisibleLineHeights, this is updated to point at the width\n    // of a given element and its extent in the document. When a change\n    // happens in that range, these are reset. That way, once we've seen\n    // a line/element of a given length, we keep the editor wide enough\n    // to fit at least that element, until it is changed, at which point\n    // we forget it again.\n    this.minWidth = 0;\n    this.minWidthFrom = 0;\n    this.minWidthTo = 0;\n    // Track whether the DOM selection was set in a lossy way, so that\n    // we don't mess it up when reading it back it\n    this.impreciseAnchor = null;\n    this.impreciseHead = null;\n    this.forceSelection = false;\n    // Used by the resize observer to ignore resizes that we caused\n    // ourselves\n    this.lastUpdate = Date.now();\n    this.setDOM(view.contentDOM);\n    this.children = [new LineView()];\n    this.children[0].setParent(this);\n    this.updateDeco();\n    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);\n  }\n  // Update the document view to a given state.\n  update(update) {\n    var _a;\n    let changedRanges = update.changedRanges;\n    if (this.minWidth > 0 && changedRanges.length) {\n      if (!changedRanges.every(({\n        fromA,\n        toA\n      }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n      } else {\n        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n      }\n    }\n    let readCompositionAt = -1;\n    if (this.view.inputState.composing >= 0) {\n      if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n    }\n    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n    this.domChanged = null;\n    if (this.hasComposition) {\n      this.markedForComposition.clear();\n      let {\n        from,\n        to\n      } = this.hasComposition;\n      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n    }\n    this.hasComposition = composition ? {\n      from: composition.range.fromB,\n      to: composition.range.toB\n    } : null;\n    // When the DOM nodes around the selection are moved to another\n    // parent, Chrome sometimes reports a different selection through\n    // getSelection than the one that it actually shows to the user.\n    // This forces a selection update when lines are joined to work\n    // around that. Issue #54\n    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n    let prevDeco = this.decorations,\n      deco = this.updateDeco();\n    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n    if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {\n      return false;\n    } else {\n      this.updateInner(changedRanges, update.startState.doc.length, composition);\n      if (update.transactions.length) this.lastUpdate = Date.now();\n      return true;\n    }\n  }\n  // Used by update and the constructor do perform the actual DOM\n  // update\n  updateInner(changes, oldLength, composition) {\n    this.view.viewState.mustMeasureContent = true;\n    this.updateChildren(changes, oldLength, composition);\n    let {\n      observer\n    } = this.view;\n    observer.ignore(() => {\n      // Lock the height during redrawing, since Chrome sometimes\n      // messes with the scroll position during DOM mutation (though\n      // no relayout is triggered and I cannot imagine how it can\n      // recompute the scroll position without a layout)\n      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n      this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n      // Chrome will sometimes, when DOM mutations occur directly\n      // around the selection, get confused and report a different\n      // selection from the one it displays (issue #218). This tries\n      // to detect that situation.\n      let track = browser.chrome || browser.ios ? {\n        node: observer.selectionRange.focusNode,\n        written: false\n      } : undefined;\n      this.sync(this.view, track);\n      this.flags &= ~7 /* ViewFlag.Dirty */;\n      if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n      this.dom.style.height = \"\";\n    });\n    this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);\n    let gaps = [];\n    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let child of this.children) if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n    observer.updateGaps(gaps);\n  }\n  updateChildren(changes, oldLength, composition) {\n    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n    let cursor = this.childCursor(oldLength);\n    for (let i = ranges.length - 1;; i--) {\n      let next = i >= 0 ? ranges[i] : null;\n      if (!next) break;\n      let {\n          fromA,\n          toA,\n          fromB,\n          toB\n        } = next,\n        content,\n        breakAtStart,\n        openStart,\n        openEnd;\n      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n        breakAtStart = before.breakAtStart;\n        openStart = before.openStart;\n        openEnd = after.openEnd;\n        let compLine = this.compositionView(composition);\n        if (after.breakAtStart) {\n          compLine.breakAfter = 1;\n        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n          compLine.breakAfter = after.content[0].breakAfter;\n          after.content.shift();\n        }\n        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n          before.content.pop();\n        }\n        content = before.content.concat(compLine).concat(after.content);\n      } else {\n        ({\n          content,\n          breakAtStart,\n          openStart,\n          openEnd\n        } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n      }\n      let {\n        i: toI,\n        off: toOff\n      } = cursor.findPos(toA, 1);\n      let {\n        i: fromI,\n        off: fromOff\n      } = cursor.findPos(fromA, -1);\n      replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n    }\n    if (composition) this.fixCompositionDOM(composition);\n  }\n  compositionView(composition) {\n    let cur = new TextView(composition.text.nodeValue);\n    cur.flags |= 8 /* ViewFlag.Composition */;\n    for (let {\n      deco\n    } of composition.marks) cur = new MarkView(deco, [cur], cur.length);\n    let line = new LineView();\n    line.append(cur, 0);\n    return line;\n  }\n  fixCompositionDOM(composition) {\n    let fix = (dom, cView) => {\n      cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);\n      this.markedForComposition.add(cView);\n      let prev = ContentView.get(dom);\n      if (prev && prev != cView) prev.dom = null;\n      cView.setDOM(dom);\n    };\n    let pos = this.childPos(composition.range.fromB, 1);\n    let cView = this.children[pos.i];\n    fix(composition.line, cView);\n    for (let i = composition.marks.length - 1; i >= -1; i--) {\n      pos = cView.childPos(pos.off, 1);\n      cView = cView.children[pos.i];\n      fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n    }\n  }\n  // Sync the DOM selection to this.state.selection\n  updateSelection(mustRead = false, fromPointer = false) {\n    if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n    let activeElt = this.view.root.activeElement,\n      focused = activeElt == this.dom;\n    let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n    if (!(focused || fromPointer || selectionNotFocus)) return;\n    let force = this.forceSelection;\n    this.forceSelection = false;\n    let main = this.view.state.selection.main;\n    let anchor = this.moveToLine(this.domAtPos(main.anchor));\n    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n    // Always reset on Firefox when next to an uneditable node to\n    // avoid invisible cursor bugs (#111)\n    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n      let dummy = document.createTextNode(\"\");\n      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n      anchor = head = new DOMPos(dummy, 0);\n      force = true;\n    }\n    let domSel = this.view.observer.selectionRange;\n    // If the selection is already here, or in an equivalent position, don't touch it\n    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n      this.view.observer.ignore(() => {\n        // Chrome Android will hide the virtual keyboard when tapping\n        // inside an uneditable node, and not bring it back when we\n        // move the cursor to its proper position. This tries to\n        // restore the keyboard by cycling focus.\n        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n          this.dom.blur();\n          this.dom.focus({\n            preventScroll: true\n          });\n        }\n        let rawSel = getSelection(this.view.root);\n        if (!rawSel) ;else if (main.empty) {\n          // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n          if (browser.gecko) {\n            let nextTo = nextToUneditable(anchor.node, anchor.offset);\n            if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {\n              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);\n              if (text) anchor = new DOMPos(text.node, text.offset);\n            }\n          }\n          rawSel.collapse(anchor.node, anchor.offset);\n          if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n        } else if (rawSel.extend) {\n          // Selection.extend can be used to create an 'inverted' selection\n          // (one where the focus is before the anchor), but not all\n          // browsers support it yet.\n          rawSel.collapse(anchor.node, anchor.offset);\n          // Safari will ignore the call above when the editor is\n          // hidden, and then raise an error on the call to extend\n          // (#940).\n          try {\n            rawSel.extend(head.node, head.offset);\n          } catch (_) {}\n        } else {\n          // Primitive (IE) way\n          let range = document.createRange();\n          if (main.anchor > main.head) [anchor, head] = [head, anchor];\n          range.setEnd(head.node, head.offset);\n          range.setStart(anchor.node, anchor.offset);\n          rawSel.removeAllRanges();\n          rawSel.addRange(range);\n        }\n        if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n          this.dom.blur();\n          if (activeElt) activeElt.focus();\n        }\n      });\n      this.view.observer.setSelectionRange(anchor, head);\n    }\n    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n  }\n  // If a zero-length widget is inserted next to the cursor during\n  // composition, avoid moving it across it and disrupting the\n  // composition.\n  suppressWidgetCursorChange(sel, cursor) {\n    return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n  }\n  enforceCursorAssoc() {\n    if (this.hasComposition) return;\n    let {\n        view\n      } = this,\n      cursor = view.state.selection.main;\n    let sel = getSelection(view.root);\n    let {\n      anchorNode,\n      anchorOffset\n    } = view.observer.selectionRange;\n    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n    let line = LineView.find(this, cursor.head);\n    if (!line) return;\n    let lineStart = line.posAtStart;\n    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n    let before = this.coordsAt(cursor.head, -1),\n      after = this.coordsAt(cursor.head, 1);\n    if (!before || !after || before.bottom > after.top) return;\n    let dom = this.domAtPos(cursor.head + cursor.assoc);\n    sel.collapse(dom.node, dom.offset);\n    sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    // This can go wrong in corner cases like single-character lines,\n    // so check and reset if necessary.\n    view.observer.readSelectionRange();\n    let newRange = view.observer.selectionRange;\n    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n  }\n  // If a position is in/near a block widget, move it to a nearby text\n  // line, since we don't want the cursor inside a block widget.\n  moveToLine(pos) {\n    // Block widgets will return positions before/after them, which\n    // are thus directly in the document DOM element.\n    let dom = this.dom,\n      newPos;\n    if (pos.node != dom) return pos;\n    for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {\n      let view = ContentView.get(dom.childNodes[i]);\n      if (view instanceof LineView) newPos = view.domAtPos(0);\n    }\n    for (let i = pos.offset - 1; !newPos && i >= 0; i--) {\n      let view = ContentView.get(dom.childNodes[i]);\n      if (view instanceof LineView) newPos = view.domAtPos(view.length);\n    }\n    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n  }\n  nearest(dom) {\n    for (let cur = dom; cur;) {\n      let domView = ContentView.get(cur);\n      if (domView && domView.rootView == this) return domView;\n      cur = cur.parentNode;\n    }\n    return null;\n  }\n  posFromDOM(node, offset) {\n    let view = this.nearest(node);\n    if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n    return view.localPosFromDOM(node, offset) + view.posAtStart;\n  }\n  domAtPos(pos) {\n    let {\n      i,\n      off\n    } = this.childCursor().findPos(pos, -1);\n    for (; i < this.children.length - 1;) {\n      let child = this.children[i];\n      if (off < child.length || child instanceof LineView) break;\n      i++;\n      off = 0;\n    }\n    return this.children[i].domAtPos(off);\n  }\n  coordsAt(pos, side) {\n    let best = null,\n      bestPos = 0;\n    for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {\n      let child = this.children[i],\n        end = off - child.breakAfter,\n        start = end - child.length;\n      if (end < pos) break;\n      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n        best = child;\n        bestPos = start;\n      }\n      off = start;\n    }\n    return best ? best.coordsAt(pos - bestPos, side) : null;\n  }\n  coordsForChar(pos) {\n    let {\n        i,\n        off\n      } = this.childPos(pos, 1),\n      child = this.children[i];\n    if (!(child instanceof LineView)) return null;\n    while (child.children.length) {\n      let {\n        i,\n        off: childOff\n      } = child.childPos(off, 1);\n      for (;; i++) {\n        if (i == child.children.length) return null;\n        if ((child = child.children[i]).length) break;\n      }\n      off = childOff;\n    }\n    if (!(child instanceof TextView)) return null;\n    let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n    if (end == off) return null;\n    let rects = textRange(child.dom, off, end).getClientRects();\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n    }\n    return null;\n  }\n  measureVisibleLineHeights(viewport) {\n    let result = [],\n      {\n        from,\n        to\n      } = viewport;\n    let contentWidth = this.view.contentDOM.clientWidth;\n    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n    let widest = -1,\n      ltr = this.view.textDirection == Direction.LTR;\n    for (let pos = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i],\n        end = pos + child.length;\n      if (end > to) break;\n      if (pos >= from) {\n        let childRect = child.dom.getBoundingClientRect();\n        result.push(childRect.height);\n        if (isWider) {\n          let last = child.dom.lastChild;\n          let rects = last ? clientRectsFor(last) : [];\n          if (rects.length) {\n            let rect = rects[rects.length - 1];\n            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n            if (width > widest) {\n              widest = width;\n              this.minWidth = contentWidth;\n              this.minWidthFrom = pos;\n              this.minWidthTo = end;\n            }\n          }\n        }\n      }\n      pos = end + child.breakAfter;\n    }\n    return result;\n  }\n  textDirectionAt(pos) {\n    let {\n      i\n    } = this.childPos(pos, 1);\n    return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n  }\n  measureTextSize() {\n    for (let child of this.children) {\n      if (child instanceof LineView) {\n        let measure = child.measureTextSize();\n        if (measure) return measure;\n      }\n    }\n    // If no workable line exists, force a layout of a measurable element\n    let dummy = document.createElement(\"div\"),\n      lineHeight,\n      charWidth,\n      textHeight;\n    dummy.className = \"cm-line\";\n    dummy.style.width = \"99999px\";\n    dummy.style.position = \"absolute\";\n    dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n    this.view.observer.ignore(() => {\n      this.dom.appendChild(dummy);\n      let rect = clientRectsFor(dummy.firstChild)[0];\n      lineHeight = dummy.getBoundingClientRect().height;\n      charWidth = rect ? rect.width / 27 : 7;\n      textHeight = rect ? rect.height : lineHeight;\n      dummy.remove();\n    });\n    return {\n      lineHeight,\n      charWidth,\n      textHeight\n    };\n  }\n  childCursor(pos = this.length) {\n    // Move back to start of last element when possible, so that\n    // `ChildCursor.findPos` doesn't have to deal with the edge case\n    // of being after the last element.\n    let i = this.children.length;\n    if (i) pos -= this.children[--i].length;\n    return new ChildCursor(this.children, pos, i);\n  }\n  computeBlockGapDeco() {\n    let deco = [],\n      vs = this.view.viewState;\n    for (let pos = 0, i = 0;; i++) {\n      let next = i == vs.viewports.length ? null : vs.viewports[i];\n      let end = next ? next.from - 1 : this.length;\n      if (end > pos) {\n        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n        deco.push(Decoration.replace({\n          widget: new BlockGapWidget(height),\n          block: true,\n          inclusive: true,\n          isBlockGap: true\n        }).range(pos, end));\n      }\n      if (!next) break;\n      pos = next.to + 1;\n    }\n    return Decoration.set(deco);\n  }\n  updateDeco() {\n    let allDeco = this.view.state.facet(decorations).map((d, i) => {\n      let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n      return dynamic ? d(this.view) : d;\n    });\n    let dynamicOuter = false,\n      outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {\n        let dynamic = typeof d == \"function\";\n        if (dynamic) dynamicOuter = true;\n        return dynamic ? d(this.view) : d;\n      });\n    if (outerDeco.length) {\n      this.dynamicDecorationMap[allDeco.length] = dynamicOuter;\n      allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.join(outerDeco));\n    }\n    for (let i = allDeco.length; i < allDeco.length + 3; i++) this.dynamicDecorationMap[i] = false;\n    return this.decorations = [...allDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];\n  }\n  scrollIntoView(target) {\n    if (target.isSnapshot) {\n      let ref = this.view.viewState.lineBlockAt(target.range.head);\n      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n      this.view.scrollDOM.scrollLeft = target.xMargin;\n      return;\n    }\n    let {\n      range\n    } = target;\n    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),\n      other;\n    if (!rect) return;\n    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n      left: Math.min(rect.left, other.left),\n      top: Math.min(rect.top, other.top),\n      right: Math.max(rect.right, other.right),\n      bottom: Math.max(rect.bottom, other.bottom)\n    };\n    let margins = getScrollMargins(this.view);\n    let targetRect = {\n      left: rect.left - margins.left,\n      top: rect.top - margins.top,\n      right: rect.right + margins.right,\n      bottom: rect.bottom + margins.bottom\n    };\n    let {\n      offsetWidth,\n      offsetHeight\n    } = this.view.scrollDOM;\n    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n  }\n}\nfunction betweenUneditable(pos) {\n  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n  constructor(height) {\n    super();\n    this.height = height;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    elt.className = \"cm-gap\";\n    this.updateDOM(elt);\n    return elt;\n  }\n  eq(other) {\n    return other.height == this.height;\n  }\n  updateDOM(elt) {\n    elt.style.height = this.height + \"px\";\n    return true;\n  }\n  get editable() {\n    return true;\n  }\n  get estimatedHeight() {\n    return this.height;\n  }\n}\nfunction findCompositionNode(view, headPos) {\n  let sel = view.observer.selectionRange;\n  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n  if (!textNode) return null;\n  let from = headPos - textNode.offset;\n  return {\n    from,\n    to: from + textNode.node.nodeValue.length,\n    node: textNode.node\n  };\n}\nfunction findCompositionRange(view, changes, headPos) {\n  let found = findCompositionNode(view, headPos);\n  if (!found) return null;\n  let {\n      node: textNode,\n      from,\n      to\n    } = found,\n    text = textNode.nodeValue;\n  // Don't try to preserve multi-line compositions\n  if (/[\\n\\r]/.test(text)) return null;\n  if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n  let inv = changes.invertedDesc;\n  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n  let marks = [];\n  for (let parent = textNode.parentNode;; parent = parent.parentNode) {\n    let parentView = ContentView.get(parent);\n    if (parentView instanceof MarkView) marks.push({\n      node: parent,\n      deco: parentView.mark\n    });else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n      range,\n      text: textNode,\n      marks,\n      line: parent\n    };else if (parent != view.contentDOM) marks.push({\n      node: parent,\n      deco: new MarkDecoration({\n        inclusive: true,\n        attributes: getAttrs(parent),\n        tagName: parent.tagName.toLowerCase()\n      })\n    });else return null;\n  }\n}\nfunction nearbyTextNode(startNode, startOffset, side) {\n  if (side <= 0) for (let node = startNode, offset = startOffset;;) {\n    if (node.nodeType == 3) return {\n      node: node,\n      offset: offset\n    };\n    if (node.nodeType == 1 && offset > 0) {\n      node = node.childNodes[offset - 1];\n      offset = maxOffset(node);\n    } else {\n      break;\n    }\n  }\n  if (side >= 0) for (let node = startNode, offset = startOffset;;) {\n    if (node.nodeType == 3) return {\n      node: node,\n      offset: offset\n    };\n    if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      break;\n    }\n  }\n  return null;\n}\nfunction nextToUneditable(node, offset) {\n  if (node.nodeType != 1) return 0;\n  return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */ : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */ : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange(from, to) {\n    addRange(from, to, this.changes);\n  }\n  comparePoint(from, to) {\n    addRange(from, to, this.changes);\n  }\n};\nfunction findChangedDeco(a, b, diff) {\n  let comp = new DecorationComparator$1();\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n  return comp.changes;\n}\nfunction inUneditable(node, inside) {\n  for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {\n    if (cur.nodeType == 1 && cur.contentEditable == 'false') {\n      return true;\n    }\n  }\n  return false;\n}\nfunction touchesComposition(changes, composition) {\n  let touched = false;\n  if (composition) changes.iterChangedRanges((from, to) => {\n    if (from < composition.to && to > composition.from) touched = true;\n  });\n  return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n  let categorize = state.charCategorizer(pos);\n  let line = state.doc.lineAt(pos),\n    linePos = pos - line.from;\n  if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n  if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;\n  let from = linePos,\n    to = linePos;\n  if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n  let cat = categorize(line.text.slice(from, to));\n  while (from > 0) {\n    let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n    if (categorize(line.text.slice(prev, from)) != cat) break;\n    from = prev;\n  }\n  while (to < line.length) {\n    let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n    if (categorize(line.text.slice(to, next)) != cat) break;\n    to = next;\n  }\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n  return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n  return top < rect.top ? {\n    top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  } : rect;\n}\nfunction upBot(rect, bottom) {\n  return bottom > rect.bottom ? {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom\n  } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n  let closest,\n    closestRect,\n    closestX,\n    closestY,\n    closestOverlap = false;\n  let above, below, aboveRect, belowRect;\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    let rects = clientRectsFor(child);\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n      let dx = getdx(x, rect),\n        dy = getdy(y, rect);\n      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n      if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n        closest = child;\n        closestRect = rect;\n        closestX = dx;\n        closestY = dy;\n        let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n        closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n      }\n      if (dx == 0) {\n        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n          above = child;\n          aboveRect = rect;\n        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n          below = child;\n          belowRect = rect;\n        }\n      } else if (aboveRect && yOverlap(aboveRect, rect)) {\n        aboveRect = upBot(aboveRect, rect.bottom);\n      } else if (belowRect && yOverlap(belowRect, rect)) {\n        belowRect = upTop(belowRect, rect.top);\n      }\n    }\n  }\n  if (aboveRect && aboveRect.bottom >= y) {\n    closest = above;\n    closestRect = aboveRect;\n  } else if (belowRect && belowRect.top <= y) {\n    closest = below;\n    closestRect = belowRect;\n  }\n  if (!closest) return {\n    node: parent,\n    offset: 0\n  };\n  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n  if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n  return {\n    node: parent,\n    offset\n  };\n}\nfunction domPosInText(node, x, y) {\n  let len = node.nodeValue.length;\n  let closestOffset = -1,\n    closestDY = 1e9,\n    generalSide = 0;\n  for (let i = 0; i < len; i++) {\n    let rects = textRange(node, i, i + 1).getClientRects();\n    for (let j = 0; j < rects.length; j++) {\n      let rect = rects[j];\n      if (rect.top == rect.bottom) continue;\n      if (!generalSide) generalSide = x - rect.left;\n      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n        let right = x >= (rect.left + rect.right) / 2,\n          after = right;\n        if (browser.chrome || browser.gecko) {\n          // Check for RTL on browsers that support getting client\n          // rects for empty ranges.\n          let rectBefore = textRange(node, i).getBoundingClientRect();\n          if (rectBefore.left == rect.right) after = !right;\n        }\n        if (dy <= 0) return {\n          node,\n          offset: i + (after ? 1 : 0)\n        };\n        closestOffset = i + (after ? 1 : 0);\n        closestDY = dy;\n      }\n    }\n  }\n  return {\n    node,\n    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n  };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n  var _a, _b;\n  let content = view.contentDOM.getBoundingClientRect(),\n    docTop = content.top + view.viewState.paddingTop;\n  let block,\n    {\n      docHeight\n    } = view.viewState;\n  let {\n      x,\n      y\n    } = coords,\n    yOffset = y - docTop;\n  if (yOffset < 0) return 0;\n  if (yOffset > docHeight) return view.state.doc.length;\n  // Scan for a text block near the queried y position\n  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {\n    block = view.elementAtHeight(yOffset);\n    if (block.type == BlockType.Text) break;\n    for (;;) {\n      // Move the y position out of this block\n      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n      if (yOffset >= 0 && yOffset <= docHeight) break;\n      // If the document consists entirely of replaced widgets, we\n      // won't find a text block, so return 0\n      if (bounced) return precise ? null : 0;\n      bounced = true;\n      bias = -bias;\n    }\n  }\n  y = docTop + yOffset;\n  let lineStart = block.from;\n  // If this is outside of the rendered viewport, we can't determine a position\n  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n  // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n  let doc = view.dom.ownerDocument;\n  let root = view.root.elementFromPoint ? view.root : doc;\n  let element = root.elementFromPoint(x, y);\n  if (element && !view.contentDOM.contains(element)) element = null;\n  // If the element is unexpected, clip x at the sides of the content area and try again\n  if (!element) {\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n  }\n  // There's visible editor content under the point, so we can try\n  // using caret(Position|Range)FromPoint as a shortcut\n  let node,\n    offset = -1;\n  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n    if (doc.caretPositionFromPoint) {\n      let pos = doc.caretPositionFromPoint(x, y);\n      if (pos) ({\n        offsetNode: node,\n        offset\n      } = pos);\n    } else if (doc.caretRangeFromPoint) {\n      let range = doc.caretRangeFromPoint(x, y);\n      if (range) {\n        ({\n          startContainer: node,\n          startOffset: offset\n        } = range);\n        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n      }\n    }\n  }\n  // No luck, do our own (potentially expensive) search\n  if (!node || !view.docView.dom.contains(node)) {\n    let line = LineView.find(view.docView, lineStart);\n    if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n    ({\n      node,\n      offset\n    } = domPosAtCoords(line.dom, x, y));\n  }\n  let nearest = view.docView.nearest(node);\n  if (!nearest) return null;\n  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n    let rect = nearest.dom.getBoundingClientRect();\n    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n  } else {\n    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n  }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n    let textHeight = view.viewState.heightOracle.textHeight;\n    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n    into += line * view.viewState.heightOracle.lineLength;\n  }\n  let content = view.state.sliceDoc(block.from, block.to);\n  return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n  let len;\n  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n  for (let next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n  return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n  if (offset != 0) return false;\n  for (let cur = node;;) {\n    let parent = cur.parentNode;\n    if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n    if (parent.classList.contains(\"cm-line\")) break;\n    cur = parent;\n  }\n  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n  return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n  let line = view.lineBlockAt(pos);\n  if (Array.isArray(line.type)) for (let l of line.type) {\n    if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n  }\n  return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n  let line = blockAt(view, start.head);\n  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n  if (coords) {\n    let editorRect = view.dom.getBoundingClientRect();\n    let direction = view.textDirectionAt(line.from);\n    let pos = view.posAtCoords({\n      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n      y: (coords.top + coords.bottom) / 2\n    });\n    if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n  }\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n  let line = view.state.doc.lineAt(start.head),\n    spans = view.bidiSpans(line);\n  let direction = view.textDirectionAt(line.from);\n  for (let cur = start, check = null;;) {\n    let next = moveVisually(line, spans, direction, cur, forward),\n      char = movedOver;\n    if (!next) {\n      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n      char = \"\\n\";\n      line = view.state.doc.line(line.number + (forward ? 1 : -1));\n      spans = view.bidiSpans(line);\n      next = view.visualLineSide(line, !forward);\n    }\n    if (!check) {\n      if (!by) return next;\n      check = by(char);\n    } else if (!check(char)) {\n      return cur;\n    }\n    cur = next;\n  }\n}\nfunction byGroup(view, pos, start) {\n  let categorize = view.state.charCategorizer(pos);\n  let cat = categorize(start);\n  return next => {\n    let nextCat = categorize(next);\n    if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n    return cat == nextCat;\n  };\n}\nfunction moveVertically(view, start, forward, distance) {\n  let startPos = start.head,\n    dir = forward ? 1 : -1;\n  if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n  let goal = start.goalColumn,\n    startY;\n  let rect = view.contentDOM.getBoundingClientRect();\n  let startCoords = view.coordsAtPos(startPos, start.assoc || -1),\n    docTop = view.documentTop;\n  if (startCoords) {\n    if (goal == null) goal = startCoords.left - rect.left;\n    startY = dir < 0 ? startCoords.top : startCoords.bottom;\n  } else {\n    let line = view.viewState.lineBlockAt(startPos);\n    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n    startY = (dir < 0 ? line.top : line.bottom) + docTop;\n  }\n  let resolvedGoal = rect.left + goal;\n  let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n  for (let extra = 0;; extra += 10) {\n    let curY = startY + (dist + extra) * dir;\n    let pos = posAtCoords(view, {\n      x: resolvedGoal,\n      y: curY\n    }, false, dir);\n    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n      let charRect = view.docView.coordsForChar(pos);\n      let assoc = !charRect || curY < charRect.top ? -1 : 1;\n      return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, assoc, undefined, goal);\n    }\n  }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n  for (;;) {\n    let moved = 0;\n    for (let set of atoms) {\n      set.between(pos - 1, pos + 1, (from, to, value) => {\n        if (pos > from && pos < to) {\n          let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n          pos = side < 0 ? from : to;\n          moved = side;\n        }\n      });\n    }\n    if (!moved) return pos;\n  }\n}\nfunction skipAtoms(view, oldPos, pos) {\n  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n  return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\n\n// This will also be where dragging info and such goes\nclass InputState {\n  setSelectionOrigin(origin) {\n    this.lastSelectionOrigin = origin;\n    this.lastSelectionTime = Date.now();\n  }\n  constructor(view) {\n    this.view = view;\n    this.lastKeyCode = 0;\n    this.lastKeyTime = 0;\n    this.lastTouchTime = 0;\n    this.lastFocusTime = 0;\n    this.lastScrollTop = 0;\n    this.lastScrollLeft = 0;\n    // On iOS, some keys need to have their default behavior happen\n    // (after which we retroactively handle them and reset the DOM) to\n    // avoid messing up the virtual keyboard state.\n    this.pendingIOSKey = undefined;\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastEscPress = 0;\n    this.lastContextMenu = 0;\n    this.scrollHandlers = [];\n    this.handlers = Object.create(null);\n    // -1 means not in a composition. Otherwise, this counts the number\n    // of changes made during the composition. The count is used to\n    // avoid treating the start state of the composition, before any\n    // changes have been made, as part of the composition.\n    this.composing = -1;\n    // Tracks whether the next change should be marked as starting the\n    // composition (null means no composition, true means next is the\n    // first, false means first has already been marked for this\n    // composition)\n    this.compositionFirstChange = null;\n    // End time of the previous composition\n    this.compositionEndedAt = 0;\n    // Used in a kludge to detect when an Enter keypress should be\n    // considered part of the composition on Safari, which fires events\n    // in the wrong order\n    this.compositionPendingKey = false;\n    // Used to categorize changes as part of a composition, even when\n    // the mutation events fire shortly after the compositionend event\n    this.compositionPendingChange = false;\n    this.mouseSelection = null;\n    // When a drag from the editor is active, this points at the range\n    // being dragged.\n    this.draggedContent = null;\n    this.handleEvent = this.handleEvent.bind(this);\n    this.notifiedFocused = view.hasFocus;\n    // On Safari adding an input event handler somehow prevents an\n    // issue where the composition vanishes when you press enter.\n    if (browser.safari) view.contentDOM.addEventListener(\"input\", () => null);\n    if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n  }\n  handleEvent(event) {\n    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n    if (event.type == \"keydown\" && this.keydown(event)) return;\n    this.runHandlers(event.type, event);\n  }\n  runHandlers(type, event) {\n    let handlers = this.handlers[type];\n    if (handlers) {\n      for (let observer of handlers.observers) observer(this.view, event);\n      for (let handler of handlers.handlers) {\n        if (event.defaultPrevented) break;\n        if (handler(this.view, event)) {\n          event.preventDefault();\n          break;\n        }\n      }\n    }\n  }\n  ensureHandlers(plugins) {\n    let handlers = computeHandlers(plugins),\n      prev = this.handlers,\n      dom = this.view.contentDOM;\n    for (let type in handlers) if (type != \"scroll\") {\n      let passive = !handlers[type].handlers.length;\n      let exists = prev[type];\n      if (exists && passive != !exists.handlers.length) {\n        dom.removeEventListener(type, this.handleEvent);\n        exists = null;\n      }\n      if (!exists) dom.addEventListener(type, this.handleEvent, {\n        passive\n      });\n    }\n    for (let type in prev) if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n    this.handlers = handlers;\n  }\n  keydown(event) {\n    // Must always run, even if a custom handler handled the event\n    this.lastKeyCode = event.keyCode;\n    this.lastKeyTime = Date.now();\n    if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;\n    if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.view.inputState.lastEscPress = 0;\n    // Chrome for Android usually doesn't fire proper key events, but\n    // occasionally does, usually surrounded by a bunch of complicated\n    // composition changes. When an enter or backspace key event is\n    // seen, hold off on handling DOM events for a bit, and then\n    // dispatch it.\n    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n      this.view.observer.delayAndroidKey(event.key, event.keyCode);\n      return true;\n    }\n    // Preventing the default behavior of Enter on iOS makes the\n    // virtual keyboard get stuck in the wrong (lowercase)\n    // state. So we let it go through, and then, in\n    // applyDOMChange, notify key handlers of it and reset to\n    // the state they produce.\n    let pending;\n    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n      this.pendingIOSKey = pending || event;\n      setTimeout(() => this.flushIOSKey(), 250);\n      return true;\n    }\n    if (event.keyCode != 229) this.view.observer.forceFlush();\n    return false;\n  }\n  flushIOSKey() {\n    let key = this.pendingIOSKey;\n    if (!key) return false;\n    this.pendingIOSKey = undefined;\n    return dispatchKey(this.view.contentDOM, key.key, key.keyCode);\n  }\n  ignoreDuringComposition(event) {\n    if (!/^key/.test(event.type)) return false;\n    if (this.composing > 0) return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On some input method editors (IMEs), the Enter key is used to\n    // confirm character selection. On Safari, when Enter is pressed,\n    // compositionend and keydown events are sometimes emitted in the\n    // wrong order. The key event should still be ignored, even when\n    // it happens after the compositionend event.\n    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n      this.compositionPendingKey = false;\n      return true;\n    }\n    return false;\n  }\n  startMouseSelection(mouseSelection) {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n    this.mouseSelection = mouseSelection;\n  }\n  update(update) {\n    if (this.mouseSelection) this.mouseSelection.update(update);\n    if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n    if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n  }\n  destroy() {\n    if (this.mouseSelection) this.mouseSelection.destroy();\n  }\n}\nfunction bindHandler(plugin, handler) {\n  return (view, event) => {\n    try {\n      return handler.call(plugin, event, view);\n    } catch (e) {\n      logException(view.state, e);\n    }\n  };\n}\nfunction computeHandlers(plugins) {\n  let result = Object.create(null);\n  function record(type) {\n    return result[type] || (result[type] = {\n      observers: [],\n      handlers: []\n    });\n  }\n  for (let plugin of plugins) {\n    let spec = plugin.spec;\n    if (spec && spec.domEventHandlers) for (let type in spec.domEventHandlers) {\n      let f = spec.domEventHandlers[type];\n      if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n    }\n    if (spec && spec.domEventObservers) for (let type in spec.domEventObservers) {\n      let f = spec.domEventObservers[type];\n      if (f) record(type).observers.push(bindHandler(plugin.value, f));\n    }\n  }\n  for (let type in handlers) record(type).handlers.push(handlers[type]);\n  for (let type in observers) record(type).observers.push(observers[type]);\n  return result;\n}\nconst PendingKeys = [{\n  key: \"Backspace\",\n  keyCode: 8,\n  inputType: \"deleteContentBackward\"\n}, {\n  key: \"Enter\",\n  keyCode: 13,\n  inputType: \"insertParagraph\"\n}, {\n  key: \"Enter\",\n  keyCode: 13,\n  inputType: \"insertLineBreak\"\n}, {\n  key: \"Delete\",\n  keyCode: 46,\n  inputType: \"deleteContentForward\"\n}];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n  return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n  constructor(view, startEvent, style, mustSelect) {\n    this.view = view;\n    this.startEvent = startEvent;\n    this.style = style;\n    this.mustSelect = mustSelect;\n    this.scrollSpeed = {\n      x: 0,\n      y: 0\n    };\n    this.scrolling = -1;\n    this.lastEvent = startEvent;\n    this.scrollParent = scrollableParent(view.contentDOM);\n    this.atoms = view.state.facet(atomicRanges).map(f => f(view));\n    let doc = view.contentDOM.ownerDocument;\n    doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    this.extend = startEvent.shiftKey;\n    this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n  }\n  start(event) {\n    // When clicking outside of the selection, immediately apply the\n    // effect of starting the selection\n    if (this.dragging === false) this.select(event);\n  }\n  move(event) {\n    var _a;\n    if (event.buttons == 0) return this.destroy();\n    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n    this.select(this.lastEvent = event);\n    let sx = 0,\n      sy = 0;\n    let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {\n      left: 0,\n      top: 0,\n      right: this.view.win.innerWidth,\n      bottom: this.view.win.innerHeight\n    };\n    let margins = getScrollMargins(this.view);\n    if (event.clientX - margins.left <= rect.left + dragScrollMargin) sx = -dragScrollSpeed(rect.left - event.clientX);else if (event.clientX + margins.right >= rect.right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - rect.right);\n    if (event.clientY - margins.top <= rect.top + dragScrollMargin) sy = -dragScrollSpeed(rect.top - event.clientY);else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - rect.bottom);\n    this.setScrollSpeed(sx, sy);\n  }\n  up(event) {\n    if (this.dragging == null) this.select(this.lastEvent);\n    if (!this.dragging) event.preventDefault();\n    this.destroy();\n  }\n  destroy() {\n    this.setScrollSpeed(0, 0);\n    let doc = this.view.contentDOM.ownerDocument;\n    doc.removeEventListener(\"mousemove\", this.move);\n    doc.removeEventListener(\"mouseup\", this.up);\n    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n  }\n  setScrollSpeed(sx, sy) {\n    this.scrollSpeed = {\n      x: sx,\n      y: sy\n    };\n    if (sx || sy) {\n      if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50);\n    } else if (this.scrolling > -1) {\n      clearInterval(this.scrolling);\n      this.scrolling = -1;\n    }\n  }\n  scroll() {\n    if (this.scrollParent) {\n      this.scrollParent.scrollLeft += this.scrollSpeed.x;\n      this.scrollParent.scrollTop += this.scrollSpeed.y;\n    } else {\n      this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n    }\n    if (this.dragging === false) this.select(this.lastEvent);\n  }\n  skipAtoms(sel) {\n    let ranges = null;\n    for (let i = 0; i < sel.ranges.length; i++) {\n      let range = sel.ranges[i],\n        updated = null;\n      if (range.empty) {\n        let pos = skipAtomicRanges(this.atoms, range.from, 0);\n        if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n      } else {\n        let from = skipAtomicRanges(this.atoms, range.from, -1);\n        let to = skipAtomicRanges(this.atoms, range.to, 1);\n        if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n      }\n      if (updated) {\n        if (!ranges) ranges = sel.ranges.slice();\n        ranges[i] = updated;\n      }\n    }\n    return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n  }\n  select(event) {\n    let {\n        view\n      } = this,\n      selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n      selection,\n      userEvent: \"select.pointer\"\n    });\n    this.mustSelect = false;\n  }\n  update(update) {\n    if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20);\n  }\n}\nfunction addsSelectionRange(view, event) {\n  let facet = view.state.facet(clickAddsSelectionRange);\n  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n  let facet = view.state.facet(dragMovesSelection$1);\n  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n  let {\n    main\n  } = view.state.selection;\n  if (main.empty) return false;\n  // On boundary clicks, check whether the coordinates are inside the\n  // selection's client rectangles\n  let sel = getSelection(view.root);\n  if (!sel || sel.rangeCount == 0) return true;\n  let rects = sel.getRangeAt(0).getClientRects();\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n  }\n  return false;\n}\nfunction eventBelongsToEditor(view, event) {\n  if (!event.bubbles) return true;\n  if (event.defaultPrevented) return false;\n  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n  return true;\n}\nconst handlers = /*@__PURE__*/Object.create(null);\nconst observers = /*@__PURE__*/Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(() => {\n    view.focus();\n    target.remove();\n    doPaste(view, target.value);\n  }, 50);\n}\nfunction doPaste(view, input) {\n  let {\n      state\n    } = view,\n    changes,\n    i = 1,\n    text = state.toText(input);\n  let byLine = text.lines == state.selection.ranges.length;\n  let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();\n  if (linewise) {\n    let lastLine = -1;\n    changes = state.changeByRange(range => {\n      let line = state.doc.lineAt(range.from);\n      if (line.from == lastLine) return {\n        range\n      };\n      lastLine = line.from;\n      let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n      return {\n        changes: {\n          from: line.from,\n          insert\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n      };\n    });\n  } else if (byLine) {\n    changes = state.changeByRange(range => {\n      let line = text.line(i++);\n      return {\n        changes: {\n          from: range.from,\n          to: range.to,\n          insert: line.text\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n      };\n    });\n  } else {\n    changes = state.replaceSelection(text);\n  }\n  view.dispatch(changes, {\n    userEvent: \"input.paste\",\n    scrollIntoView: true\n  });\n}\nobservers.scroll = view => {\n  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event) => {\n  view.inputState.setSelectionOrigin(\"select\");\n  if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();\n  return false;\n};\nobservers.touchstart = (view, e) => {\n  view.inputState.lastTouchTime = Date.now();\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = view => {\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event) => {\n  view.observer.flush();\n  if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n  let style = null;\n  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {\n    style = makeStyle(view, event);\n    if (style) break;\n  }\n  if (!style && event.button == 0) style = basicMouseSelection(view, event);\n  if (style) {\n    let mustFocus = !view.hasFocus;\n    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n    if (mustFocus) view.observer.ignore(() => focusPreventScroll(view.contentDOM));\n    let mouseSel = view.inputState.mouseSelection;\n    if (mouseSel) {\n      mouseSel.start(event);\n      return mouseSel.dragging === false;\n    }\n  }\n  return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n  if (type == 1) {\n    // Single click\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n  } else if (type == 2) {\n    // Double click\n    return groupAt(view.state, pos, bias);\n  } else {\n    // Triple click\n    let visual = LineView.find(view.docView, pos),\n      line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n    let from = visual ? visual.posAtStart : line.from,\n      to = visual ? visual.posAtEnd : line.to;\n    if (to < view.state.doc.length && to == line.to) to++;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n  }\n}\nlet insideY = (y, rect) => y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n  let line = LineView.find(view.docView, pos);\n  if (!line) return 1;\n  let off = pos - line.posAtStart;\n  // Line boundaries point into the line\n  if (off == 0) return 1;\n  if (off == line.length) return -1;\n  // Positions on top of an element point at that element\n  let before = line.coordsAt(off, -1);\n  if (before && inside(x, y, before)) return -1;\n  let after = line.coordsAt(off, 1);\n  if (after && inside(x, y, after)) return 1;\n  // This is probably a line wrap point. Pick before if the point is\n  // beside it.\n  return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n  let pos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  return {\n    pos,\n    bias: findPositionSide(view, pos, event.clientX, event.clientY)\n  };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null,\n  lastMouseDownCount = 0,\n  lastMouseDownTime = 0;\nfunction getClickType(event) {\n  if (!BadMouseDetail) return event.detail;\n  let last = lastMouseDown,\n    lastTime = lastMouseDownTime;\n  lastMouseDown = event;\n  lastMouseDownTime = Date.now();\n  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n  let start = queryPos(view, event),\n    type = getClickType(event);\n  let startSel = view.state.selection;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        start.pos = update.changes.mapPos(start.pos);\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, extend, multiple) {\n      let cur = queryPos(view, event),\n        removed;\n      let range = rangeForClick(view, cur.pos, cur.bias, type);\n      if (start.pos != cur.pos && !extend) {\n        let startRange = rangeForClick(view, start.pos, start.bias, type);\n        let from = Math.min(startRange.from, range.from),\n          to = Math.max(startRange.to, range.to);\n        range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n      }\n      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;else if (multiple) return startSel.addRange(range);else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([range]);\n    }\n  };\n}\nfunction removeRangeAround(sel, pos) {\n  for (let i = 0; i < sel.ranges.length; i++) {\n    let {\n      from,\n      to\n    } = sel.ranges[i];\n    if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n  }\n  return null;\n}\nhandlers.dragstart = (view, event) => {\n  let {\n    selection: {\n      main: range\n    }\n  } = view.state;\n  if (event.target.draggable) {\n    let cView = view.docView.nearest(event.target);\n    if (cView && cView.isWidget) {\n      let from = cView.posAtStart,\n        to = from + cView.length;\n      if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n  }\n  let {\n    inputState\n  } = view;\n  if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n  inputState.draggedContent = range;\n  if (event.dataTransfer) {\n    event.dataTransfer.setData(\"Text\", view.state.sliceDoc(range.from, range.to));\n    event.dataTransfer.effectAllowed = \"copyMove\";\n  }\n  return false;\n};\nhandlers.dragend = view => {\n  view.inputState.draggedContent = null;\n  return false;\n};\nfunction dropText(view, event, text, direct) {\n  if (!text) return;\n  let dropPos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  let {\n    draggedContent\n  } = view.inputState;\n  let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n    from: draggedContent.from,\n    to: draggedContent.to\n  } : null;\n  let ins = {\n    from: dropPos,\n    insert: text\n  };\n  let changes = view.state.changes(del ? [del, ins] : ins);\n  view.focus();\n  view.dispatch({\n    changes,\n    selection: {\n      anchor: changes.mapPos(dropPos, -1),\n      head: changes.mapPos(dropPos, 1)\n    },\n    userEvent: del ? \"move.drop\" : \"input.drop\"\n  });\n  view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event) => {\n  if (!event.dataTransfer) return false;\n  if (view.state.readOnly) return true;\n  let files = event.dataTransfer.files;\n  if (files && files.length) {\n    // For a file drop, read the file's text.\n    let text = Array(files.length),\n      read = 0;\n    let finishFile = () => {\n      if (++read == files.length) dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);\n    };\n    for (let i = 0; i < files.length; i++) {\n      let reader = new FileReader();\n      reader.onerror = finishFile;\n      reader.onload = () => {\n        if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n        finishFile();\n      };\n      reader.readAsText(files[i]);\n    }\n    return true;\n  } else {\n    let text = event.dataTransfer.getData(\"Text\");\n    if (text) {\n      dropText(view, event, text, true);\n      return true;\n    }\n  }\n  return false;\n};\nhandlers.paste = (view, event) => {\n  if (view.state.readOnly) return true;\n  view.observer.flush();\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data) {\n    doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-text\"));\n    return true;\n  } else {\n    capturePaste(view);\n    return false;\n  }\n};\nfunction captureCopy(view, text) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  let parent = view.dom.parentNode;\n  if (!parent) return;\n  let target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.value = text;\n  target.focus();\n  target.selectionEnd = text.length;\n  target.selectionStart = 0;\n  setTimeout(() => {\n    target.remove();\n    view.focus();\n  }, 50);\n}\nfunction copiedRange(state) {\n  let content = [],\n    ranges = [],\n    linewise = false;\n  for (let range of state.selection.ranges) if (!range.empty) {\n    content.push(state.sliceDoc(range.from, range.to));\n    ranges.push(range);\n  }\n  if (!content.length) {\n    // Nothing selected, do a line-wise copy\n    let upto = -1;\n    for (let {\n      from\n    } of state.selection.ranges) {\n      let line = state.doc.lineAt(from);\n      if (line.number > upto) {\n        content.push(line.text);\n        ranges.push({\n          from: line.from,\n          to: Math.min(state.doc.length, line.to + 1)\n        });\n      }\n      upto = line.number;\n    }\n    linewise = true;\n  }\n  return {\n    text: content.join(state.lineBreak),\n    ranges,\n    linewise\n  };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event) => {\n  let {\n    text,\n    ranges,\n    linewise\n  } = copiedRange(view.state);\n  if (!text && !linewise) return false;\n  lastLinewiseCopy = linewise ? text : null;\n  if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n    changes: ranges,\n    scrollIntoView: true,\n    userEvent: \"delete.cut\"\n  });\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data) {\n    data.clearData();\n    data.setData(\"text/plain\", text);\n    return true;\n  } else {\n    captureCopy(view, text);\n    return false;\n  }\n};\nconst isFocusChange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n  let effects = [];\n  for (let getEffect of state.facet(focusChangeEffect)) {\n    let effect = getEffect(state, focus);\n    if (effect) effects.push(effect);\n  }\n  return effects ? state.update({\n    effects,\n    annotations: isFocusChange.of(true)\n  }) : null;\n}\nfunction updateForFocusChange(view) {\n  setTimeout(() => {\n    let focus = view.hasFocus;\n    if (focus != view.inputState.notifiedFocused) {\n      let tr = focusChangeTransaction(view.state, focus);\n      if (tr) view.dispatch(tr);else view.update([]);\n    }\n  }, 10);\n}\nobservers.focus = view => {\n  view.inputState.lastFocusTime = Date.now();\n  // When focusing reset the scroll position, move it back to where it was\n  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n  }\n  updateForFocusChange(view);\n};\nobservers.blur = view => {\n  view.observer.clearSelectionRange();\n  updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = view => {\n  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n  if (view.inputState.composing < 0) {\n    // FIXME possibly set a timeout to clear it again on Android\n    view.inputState.composing = 0;\n  }\n};\nobservers.compositionend = view => {\n  view.inputState.composing = -1;\n  view.inputState.compositionEndedAt = Date.now();\n  view.inputState.compositionPendingKey = true;\n  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n  view.inputState.compositionFirstChange = null;\n  if (browser.chrome && browser.android) {\n    // Delay flushing for a bit on Android because it'll often fire a\n    // bunch of contradictory changes in a row at end of compositon\n    view.observer.flushSoon();\n  } else if (view.inputState.compositionPendingChange) {\n    // If we found pending records, schedule a flush.\n    Promise.resolve().then(() => view.observer.flush());\n  } else {\n    // Otherwise, make sure that, if no changes come in soon, the\n    // composition view is cleared.\n    setTimeout(() => {\n      if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n    }, 50);\n  }\n};\nobservers.contextmenu = view => {\n  view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event) => {\n  var _a;\n  // Because Chrome Android doesn't fire useful key events, use\n  // beforeinput to detect backspace (and possibly enter and delete,\n  // but those usually don't even seem to fire beforeinput events at\n  // the moment) and fake a key event for it.\n  //\n  // (preventDefault on beforeinput, though supported in the spec,\n  // seems to do nothing at all on Chrome).\n  let pending;\n  if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {\n    view.observer.delayAndroidKey(pending.key, pending.keyCode);\n    if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n      let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n      setTimeout(() => {\n        var _a;\n        // Backspacing near uneditable nodes on Chrome Android sometimes\n        // closes the virtual keyboard. This tries to crudely detect\n        // that and refocus to get it back.\n        if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n          view.contentDOM.blur();\n          view.focus();\n        }\n      }, 100);\n    }\n  }\n  return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/new Set();\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n  if (!appliedFirefoxHack.has(doc)) {\n    appliedFirefoxHack.add(doc);\n    doc.addEventListener(\"copy\", () => {});\n    doc.addEventListener(\"cut\", () => {});\n  }\n}\nconst wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\nclass HeightOracle {\n  constructor(lineWrapping) {\n    this.lineWrapping = lineWrapping;\n    this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    this.heightSamples = {};\n    this.lineHeight = 14; // The height of an entire line (line-height)\n    this.charWidth = 7;\n    this.textHeight = 14; // The height of the actual font (font-size)\n    this.lineLength = 30;\n    // Used to track, during updateHeight, if any actual heights changed\n    this.heightChanged = false;\n  }\n  heightForGap(from, to) {\n    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n    if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n    return this.lineHeight * lines;\n  }\n  heightForLine(length) {\n    if (!this.lineWrapping) return this.lineHeight;\n    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n    return lines * this.lineHeight;\n  }\n  setDoc(doc) {\n    this.doc = doc;\n    return this;\n  }\n  mustRefreshForWrapping(whiteSpace) {\n    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n  }\n  mustRefreshForHeights(lineHeights) {\n    let newHeight = false;\n    for (let i = 0; i < lineHeights.length; i++) {\n      let h = lineHeights[i];\n      if (h < 0) {\n        i++;\n      } else if (!this.heightSamples[Math.floor(h * 10)]) {\n        // Round to .1 pixels\n        newHeight = true;\n        this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return newHeight;\n  }\n  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n    this.lineWrapping = lineWrapping;\n    this.lineHeight = lineHeight;\n    this.charWidth = charWidth;\n    this.textHeight = textHeight;\n    this.lineLength = lineLength;\n    if (changed) {\n      this.heightSamples = {};\n      for (let i = 0; i < knownHeights.length; i++) {\n        let h = knownHeights[i];\n        if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;\n      }\n    }\n    return changed;\n  }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n  constructor(from, heights) {\n    this.from = from;\n    this.heights = heights;\n    this.index = 0;\n  }\n  get more() {\n    return this.index < this.heights.length;\n  }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/\nclass BlockInfo {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The start of the element in the document.\n  */\n  from,\n  /**\n  The length of the element.\n  */\n  length,\n  /**\n  The top position of the element (relative to the top of the\n  document).\n  */\n  top,\n  /**\n  Its height.\n  */\n  height,\n  /**\n  @internal Weird packed field that holds an array of children\n  for composite blocks, a decoration for block widgets, and a\n  number indicating the amount of widget-create line breaks for\n  text blocks.\n  */\n  _content) {\n    this.from = from;\n    this.length = length;\n    this.top = top;\n    this.height = height;\n    this._content = _content;\n  }\n  /**\n  The type of element this is. When querying lines, this may be\n  an array of all the blocks that make up the line.\n  */\n  get type() {\n    return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n  }\n  /**\n  The end of the element as a document position.\n  */\n  get to() {\n    return this.from + this.length;\n  }\n  /**\n  The bottom position of the element.\n  */\n  get bottom() {\n    return this.top + this.height;\n  }\n  /**\n  If this is a widget block, this will return the widget\n  associated with it.\n  */\n  get widget() {\n    return this._content instanceof PointDecoration ? this._content.widget : null;\n  }\n  /**\n  If this is a textblock, this holds the number of line breaks\n  that appear in widgets inside the block.\n  */\n  get widgetLineBreaks() {\n    return typeof this._content == \"number\" ? this._content : 0;\n  }\n  /**\n  @internal\n  */\n  join(other) {\n    let content = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);\n    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n  }\n}\nvar QueryType = /*@__PURE__*/function (QueryType) {\n  QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n  QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n  QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n  return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n  constructor(length,\n  // The number of characters covered\n  height,\n  // Height of this part of the document\n  flags = 2 /* Flag.Outdated */) {\n    this.length = length;\n    this.height = height;\n    this.flags = flags;\n  }\n  get outdated() {\n    return (this.flags & 2 /* Flag.Outdated */) > 0;\n  }\n  set outdated(value) {\n    this.flags = (value ? 2 /* Flag.Outdated */ : 0) | this.flags & ~2 /* Flag.Outdated */;\n  }\n  setHeight(oracle, height) {\n    if (this.height != height) {\n      if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n      this.height = height;\n    }\n  }\n  // Base case is to replace a leaf node, which simply builds a tree\n  // from the new nodes and returns that (HeightMapBranch and\n  // HeightMapGap override this to actually use from/to)\n  replace(_from, _to, nodes) {\n    return HeightMap.of(nodes);\n  }\n  // Again, these are base cases, and are overridden for branch and gap nodes.\n  decomposeLeft(_to, result) {\n    result.push(this);\n  }\n  decomposeRight(_from, result) {\n    result.push(this);\n  }\n  applyChanges(decorations, oldDoc, oracle, changes) {\n    let me = this,\n      doc = oracle.doc;\n    for (let i = changes.length - 1; i >= 0; i--) {\n      let {\n        fromA,\n        toA,\n        fromB,\n        toB\n      } = changes[i];\n      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n      toB += end.to - toA;\n      toA = end.to;\n      while (i > 0 && start.from <= changes[i - 1].toA) {\n        fromA = changes[i - 1].fromA;\n        fromB = changes[i - 1].fromB;\n        i--;\n        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n      }\n      fromB += start.from - fromA;\n      fromA = start.from;\n      let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n      me = me.replace(fromA, toA, nodes);\n    }\n    return me.updateHeight(oracle, 0);\n  }\n  static empty() {\n    return new HeightMapText(0, 0);\n  }\n  // nodes uses null values to indicate the position of line breaks.\n  // There are never line breaks at the start or end of the array, or\n  // two line breaks next to each other, and the array isn't allowed\n  // to be empty (same restrictions as return value from the builder).\n  static of(nodes) {\n    if (nodes.length == 1) return nodes[0];\n    let i = 0,\n      j = nodes.length,\n      before = 0,\n      after = 0;\n    for (;;) {\n      if (i == j) {\n        if (before > after * 2) {\n          let split = nodes[i - 1];\n          if (split.break) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);\n          j += 1 + split.break;\n          before -= split.size;\n        } else if (after > before * 2) {\n          let split = nodes[j];\n          if (split.break) nodes.splice(j, 1, split.left, null, split.right);else nodes.splice(j, 1, split.left, split.right);\n          j += 2 + split.break;\n          after -= split.size;\n        } else {\n          break;\n        }\n      } else if (before < after) {\n        let next = nodes[i++];\n        if (next) before += next.size;\n      } else {\n        let next = nodes[--j];\n        if (next) after += next.size;\n      }\n    }\n    let brk = 0;\n    if (nodes[i - 1] == null) {\n      brk = 1;\n      i--;\n    } else if (nodes[i] == null) {\n      brk = 1;\n      j++;\n    }\n    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n  }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n  constructor(length, height, deco) {\n    super(length, height);\n    this.deco = deco;\n  }\n  blockAt(_height, _oracle, top, offset) {\n    return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n  }\n  lineAt(_value, _type, oracle, top, offset) {\n    return this.blockAt(0, oracle, top, offset);\n  }\n  forEachLine(from, to, oracle, top, offset, f) {\n    if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n  }\n  updateHeight(oracle, offset = 0, _force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `block(${this.length})`;\n  }\n}\nclass HeightMapText extends HeightMapBlock {\n  constructor(length, height) {\n    super(length, height, null);\n    this.collapsed = 0; // Amount of collapsed content in the line\n    this.widgetHeight = 0; // Maximum inline widget height\n    this.breaks = 0; // Number of widget-introduced line breaks on the line\n  }\n  blockAt(_height, _oracle, top, offset) {\n    return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n  }\n  replace(_from, _to, nodes) {\n    let node = nodes[0];\n    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */) && Math.abs(this.length - node.length) < 10) {\n      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;\n      if (!this.outdated) node.outdated = false;\n      return node;\n    } else {\n      return HeightMap.of(nodes);\n    }\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n  }\n}\nclass HeightMapGap extends HeightMap {\n  constructor(length) {\n    super(length, 0);\n  }\n  heightMetrics(oracle, offset) {\n    let firstLine = oracle.doc.lineAt(offset).number,\n      lastLine = oracle.doc.lineAt(offset + this.length).number;\n    let lines = lastLine - firstLine + 1;\n    let perLine,\n      perChar = 0;\n    if (oracle.lineWrapping) {\n      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n      perLine = totalPerLine / lines;\n      if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n    } else {\n      perLine = this.height / lines;\n    }\n    return {\n      firstLine,\n      lastLine,\n      perLine,\n      perChar\n    };\n  }\n  blockAt(height, oracle, top, offset) {\n    let {\n      firstLine,\n      lastLine,\n      perLine,\n      perChar\n    } = this.heightMetrics(oracle, offset);\n    if (oracle.lineWrapping) {\n      let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);\n      let line = oracle.doc.lineAt(guess),\n        lineHeight = perLine + line.length * perChar;\n      let lineTop = Math.max(top, height - lineHeight / 2);\n      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n    } else {\n      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n      let {\n        from,\n        length\n      } = oracle.doc.line(firstLine + line);\n      return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n    }\n  }\n  lineAt(value, type, oracle, top, offset) {\n    if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n    if (type == QueryType.ByPosNoHeight) {\n      let {\n        from,\n        to\n      } = oracle.doc.lineAt(value);\n      return new BlockInfo(from, to - from, 0, 0, 0);\n    }\n    let {\n      firstLine,\n      perLine,\n      perChar\n    } = this.heightMetrics(oracle, offset);\n    let line = oracle.doc.lineAt(value),\n      lineHeight = perLine + line.length * perChar;\n    let linesAbove = line.number - firstLine;\n    let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n    return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n  }\n  forEachLine(from, to, oracle, top, offset, f) {\n    from = Math.max(from, offset);\n    to = Math.min(to, offset + this.length);\n    let {\n      firstLine,\n      perLine,\n      perChar\n    } = this.heightMetrics(oracle, offset);\n    for (let pos = from, lineTop = top; pos <= to;) {\n      let line = oracle.doc.lineAt(pos);\n      if (pos == from) {\n        let linesAbove = line.number - firstLine;\n        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n      }\n      let lineHeight = perLine + perChar * line.length;\n      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n      lineTop += lineHeight;\n      pos = line.to + 1;\n    }\n  }\n  replace(from, to, nodes) {\n    let after = this.length - to;\n    if (after > 0) {\n      let last = nodes[nodes.length - 1];\n      if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));\n    }\n    if (from > 0) {\n      let first = nodes[0];\n      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);\n    }\n    return HeightMap.of(nodes);\n  }\n  decomposeLeft(to, result) {\n    result.push(new HeightMapGap(to - 1), null);\n  }\n  decomposeRight(from, result) {\n    result.push(null, new HeightMapGap(this.length - from - 1));\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let end = offset + this.length;\n    if (measured && measured.from <= offset + this.length && measured.more) {\n      // Fill in part of this gap with measured lines. We know there\n      // can't be widgets or collapsed ranges in those lines, because\n      // they would already have been added to the heightmap (gaps\n      // only contain plain text).\n      let nodes = [],\n        pos = Math.max(offset, measured.from),\n        singleHeight = -1;\n      if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n      while (pos <= end && measured.more) {\n        let len = oracle.doc.lineAt(pos).length;\n        if (nodes.length) nodes.push(null);\n        let height = measured.heights[measured.index++];\n        if (singleHeight == -1) singleHeight = height;else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n        let line = new HeightMapText(len, height);\n        line.outdated = false;\n        nodes.push(line);\n        pos += len + 1;\n      }\n      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n      let result = HeightMap.of(nodes);\n      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) oracle.heightChanged = true;\n      return result;\n    } else if (force || this.outdated) {\n      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n      this.outdated = false;\n    }\n    return this;\n  }\n  toString() {\n    return `gap(${this.length})`;\n  }\n}\nclass HeightMapBranch extends HeightMap {\n  constructor(left, brk, right) {\n    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));\n    this.left = left;\n    this.right = right;\n    this.size = left.size + right.size;\n  }\n  get break() {\n    return this.flags & 1 /* Flag.Break */;\n  }\n  blockAt(height, oracle, top, offset) {\n    let mid = top + this.left.height;\n    return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n  }\n  lineAt(value, type, oracle, top, offset) {\n    let rightTop = top + this.left.height,\n      rightOffset = offset + this.left.length + this.break;\n    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n    let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n    if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n    if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n  }\n  forEachLine(from, to, oracle, top, offset, f) {\n    let rightTop = top + this.left.height,\n      rightOffset = offset + this.left.length + this.break;\n    if (this.break) {\n      if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n      if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n    } else {\n      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n      if (mid.to >= from && mid.from <= to) f(mid);\n      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n    }\n  }\n  replace(from, to, nodes) {\n    let rightStart = this.left.length + this.break;\n    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n    let result = [];\n    if (from > 0) this.decomposeLeft(from, result);\n    let left = result.length;\n    for (let node of nodes) result.push(node);\n    if (from > 0) mergeGaps(result, left - 1);\n    if (to < this.length) {\n      let right = result.length;\n      this.decomposeRight(to, result);\n      mergeGaps(result, right);\n    }\n    return HeightMap.of(result);\n  }\n  decomposeLeft(to, result) {\n    let left = this.left.length;\n    if (to <= left) return this.left.decomposeLeft(to, result);\n    result.push(this.left);\n    if (this.break) {\n      left++;\n      if (to >= left) result.push(null);\n    }\n    if (to > left) this.right.decomposeLeft(to - left, result);\n  }\n  decomposeRight(from, result) {\n    let left = this.left.length,\n      right = left + this.break;\n    if (from >= right) return this.right.decomposeRight(from - right, result);\n    if (from < left) this.left.decomposeRight(from, result);\n    if (this.break && from < right) result.push(null);\n    result.push(this.right);\n  }\n  balanced(left, right) {\n    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);\n    this.left = left;\n    this.right = right;\n    this.height = left.height + right.height;\n    this.outdated = left.outdated || right.outdated;\n    this.size = left.size + right.size;\n    this.length = left.length + this.break + right.length;\n    return this;\n  }\n  updateHeight(oracle, offset = 0, force = false, measured) {\n    let {\n        left,\n        right\n      } = this,\n      rightStart = offset + left.length + this.break,\n      rebalance = null;\n    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);\n    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);\n    if (rebalance) return this.balanced(left, right);\n    this.height = this.left.height + this.right.height;\n    this.outdated = false;\n    return this;\n  }\n  toString() {\n    return this.left + (this.break ? \" \" : \"-\") + this.right;\n  }\n}\nfunction mergeGaps(nodes, around) {\n  let before, after;\n  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n  constructor(pos, oracle) {\n    this.pos = pos;\n    this.oracle = oracle;\n    this.nodes = [];\n    this.lineStart = -1;\n    this.lineEnd = -1;\n    this.covering = null;\n    this.writtenTo = pos;\n  }\n  get isCovered() {\n    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n  }\n  span(_from, to) {\n    if (this.lineStart > -1) {\n      let end = Math.min(to, this.lineEnd),\n        last = this.nodes[this.nodes.length - 1];\n      if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n      this.writtenTo = end;\n      if (to > end) {\n        this.nodes.push(null);\n        this.writtenTo++;\n        this.lineStart = -1;\n      }\n    }\n    this.pos = to;\n  }\n  point(from, to, deco) {\n    if (from < to || deco.heightRelevant) {\n      let height = deco.widget ? deco.widget.estimatedHeight : 0;\n      let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n      if (height < 0) height = this.oracle.lineHeight;\n      let len = to - from;\n      if (deco.block) {\n        this.addBlock(new HeightMapBlock(len, height, deco));\n      } else if (len || breaks || height >= relevantWidgetHeight) {\n        this.addLineDeco(height, breaks, len);\n      }\n    } else if (to > from) {\n      this.span(from, to);\n    }\n    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n  }\n  enterLine() {\n    if (this.lineStart > -1) return;\n    let {\n      from,\n      to\n    } = this.oracle.doc.lineAt(this.pos);\n    this.lineStart = from;\n    this.lineEnd = to;\n    if (this.writtenTo < from) {\n      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n      this.nodes.push(null);\n    }\n    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n    this.writtenTo = this.pos;\n  }\n  blankContent(from, to) {\n    let gap = new HeightMapGap(to - from);\n    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */;\n    return gap;\n  }\n  ensureLine() {\n    this.enterLine();\n    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n    if (last instanceof HeightMapText) return last;\n    let line = new HeightMapText(0, -1);\n    this.nodes.push(line);\n    return line;\n  }\n  addBlock(block) {\n    this.enterLine();\n    let deco = block.deco;\n    if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n    this.nodes.push(block);\n    this.writtenTo = this.pos = this.pos + block.length;\n    if (deco && deco.endSide > 0) this.covering = block;\n  }\n  addLineDeco(height, breaks, length) {\n    let line = this.ensureLine();\n    line.length += length;\n    line.collapsed += length;\n    line.widgetHeight = Math.max(line.widgetHeight, height);\n    line.breaks += breaks;\n    this.writtenTo = this.pos = this.pos + length;\n  }\n  finish(from) {\n    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n    let pos = from;\n    for (let node of this.nodes) {\n      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n      pos += node ? node.length : 1;\n    }\n    return this.nodes;\n  }\n  // Always called with a region that on both sides either stretches\n  // to a line break or the end of the document.\n  // The returned array uses null to indicate line breaks, but never\n  // starts or ends in a line break, or has multiple line breaks next\n  // to each other.\n  static build(oracle, decorations, from, to) {\n    let builder = new NodeBuilder(from, oracle);\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n    return builder.finish(from);\n  }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n  let comp = new DecorationComparator();\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n  return comp.changes;\n}\nclass DecorationComparator {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange() {}\n  comparePoint(from, to, a, b) {\n    if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n  }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n  let rect = dom.getBoundingClientRect();\n  let doc = dom.ownerDocument,\n    win = doc.defaultView || window;\n  let left = Math.max(0, rect.left),\n    right = Math.min(win.innerWidth, rect.right);\n  let top = Math.max(0, rect.top),\n    bottom = Math.min(win.innerHeight, rect.bottom);\n  for (let parent = dom.parentNode; parent && parent != doc.body;) {\n    if (parent.nodeType == 1) {\n      let elt = parent;\n      let style = window.getComputedStyle(elt);\n      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n        let parentRect = elt.getBoundingClientRect();\n        left = Math.max(left, parentRect.left);\n        right = Math.min(right, parentRect.right);\n        top = Math.max(top, parentRect.top);\n        bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n      }\n      parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n    } else if (parent.nodeType == 11) {\n      // Shadow root\n      parent = parent.host;\n    } else {\n      break;\n    }\n  }\n  return {\n    left: left - rect.left,\n    right: Math.max(left, right) - rect.left,\n    top: top - (rect.top + paddingTop),\n    bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n  };\n}\nfunction fullPixelRange(dom, paddingTop) {\n  let rect = dom.getBoundingClientRect();\n  return {\n    left: 0,\n    right: rect.right - rect.left,\n    top: paddingTop,\n    bottom: rect.bottom - (rect.top + paddingTop)\n  };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n  constructor(from, to, size) {\n    this.from = from;\n    this.to = to;\n    this.size = size;\n  }\n  static same(a, b) {\n    if (a.length != b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      let gA = a[i],\n        gB = b[i];\n      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n    }\n    return true;\n  }\n  draw(viewState, wrapping) {\n    return Decoration.replace({\n      widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n    }).range(this.from, this.to);\n  }\n}\nclass LineGapWidget extends WidgetType {\n  constructor(size, vertical) {\n    super();\n    this.size = size;\n    this.vertical = vertical;\n  }\n  eq(other) {\n    return other.size == this.size && other.vertical == this.vertical;\n  }\n  toDOM() {\n    let elt = document.createElement(\"div\");\n    if (this.vertical) {\n      elt.style.height = this.size + \"px\";\n    } else {\n      elt.style.width = this.size + \"px\";\n      elt.style.height = \"2px\";\n      elt.style.display = \"inline-block\";\n    }\n    return elt;\n  }\n  get estimatedHeight() {\n    return this.vertical ? this.size : -1;\n  }\n}\nclass ViewState {\n  constructor(state) {\n    this.state = state;\n    // These are contentDOM-local coordinates\n    this.pixelViewport = {\n      left: 0,\n      right: window.innerWidth,\n      top: 0,\n      bottom: 0\n    };\n    this.inView = true;\n    this.paddingTop = 0; // Padding above the document, scaled\n    this.paddingBottom = 0; // Padding below the document, scaled\n    this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n    this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n    this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n    this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n    this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n    this.scrolledToBottom = true;\n    // The CSS-transformation scale of the editor (transformed size /\n    // concrete size)\n    this.scaleX = 1;\n    this.scaleY = 1;\n    // The vertical position (document-relative) to which to anchor the\n    // scroll position. -1 means anchor to the end of the document.\n    this.scrollAnchorPos = 0;\n    // The height at the anchor position. Set by the DOM update phase.\n    // -1 means no height available.\n    this.scrollAnchorHeight = -1;\n    // See VP.MaxDOMHeight\n    this.scaler = IdScaler;\n    this.scrollTarget = null;\n    // Briefly set to true when printing, to disable viewport limiting\n    this.printing = false;\n    // Flag set when editor content was redrawn, so that the next\n    // measure stage knows it must read DOM layout\n    this.mustMeasureContent = true;\n    this.defaultTextDirection = Direction.LTR;\n    this.visibleRanges = [];\n    // Cursor 'assoc' is only significant when the cursor is on a line\n    // wrap point, where it must stick to the character that it is\n    // associated with. Since browsers don't provide a reasonable\n    // interface to set or query this, when a selection is set that\n    // might cause this to be significant, this flag is set. The next\n    // measure phase will check whether the cursor is on a line-wrapping\n    // boundary and, if so, reset it to make sure it is positioned in\n    // the right place.\n    this.mustEnforceCursorAssoc = false;\n    let guessWrapping = state.facet(contentAttributes).some(v => typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n    this.heightOracle = new HeightOracle(guessWrapping);\n    this.stateDeco = state.facet(decorations).filter(d => typeof d != \"function\");\n    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n    this.viewport = this.getViewport(0, null);\n    this.updateViewportLines();\n    this.updateForViewport();\n    this.lineGaps = this.ensureLineGaps([]);\n    this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));\n    this.computeVisibleRanges();\n  }\n  updateForViewport() {\n    let viewports = [this.viewport],\n      {\n        main\n      } = this.state.selection;\n    for (let i = 0; i <= 1; i++) {\n      let pos = i ? main.head : main.anchor;\n      if (!viewports.some(({\n        from,\n        to\n      }) => pos >= from && pos <= to)) {\n        let {\n          from,\n          to\n        } = this.lineBlockAt(pos);\n        viewports.push(new Viewport(from, to));\n      }\n    }\n    this.viewports = viewports.sort((a, b) => a.from - b.from);\n    this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n  }\n  updateViewportLines() {\n    this.viewportLines = [];\n    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {\n      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n    });\n  }\n  update(update, scrollTarget = null) {\n    this.state = update.state;\n    let prevDeco = this.stateDeco;\n    this.stateDeco = this.state.facet(decorations).filter(d => typeof d != \"function\");\n    let contentChanges = update.changedRanges;\n    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n    let prevHeight = this.heightMap.height;\n    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n    if (this.heightMap.height != prevHeight) update.flags |= 2 /* UpdateFlag.Height */;\n    if (scrollAnchor) {\n      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n      this.scrollAnchorHeight = scrollAnchor.top;\n    } else {\n      this.scrollAnchorPos = -1;\n      this.scrollAnchorHeight = this.heightMap.height;\n    }\n    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n    let updateLines = !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */ || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n    this.viewport = viewport;\n    this.updateForViewport();\n    if (updateLines) this.updateViewportLines();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n    update.flags |= this.computeVisibleRanges();\n    if (scrollTarget) this.scrollTarget = scrollTarget;\n    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n  }\n  measure(view) {\n    let dom = view.contentDOM,\n      style = window.getComputedStyle(dom);\n    let oracle = this.heightOracle;\n    let whiteSpace = style.whiteSpace;\n    this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n    let domRect = dom.getBoundingClientRect();\n    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n    this.contentDOMHeight = domRect.height;\n    this.mustMeasureContent = false;\n    let result = 0,\n      bias = 0;\n    if (domRect.width && domRect.height) {\n      let {\n        scaleX,\n        scaleY\n      } = getScale(dom, domRect);\n      if (this.scaleX != scaleX || this.scaleY != scaleY) {\n        this.scaleX = scaleX;\n        this.scaleY = scaleY;\n        result |= 8 /* UpdateFlag.Geometry */;\n        refresh = measureContent = true;\n      }\n    }\n    // Vertical padding\n    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n      this.paddingTop = paddingTop;\n      this.paddingBottom = paddingBottom;\n      result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;\n    }\n    if (this.editorWidth != view.scrollDOM.clientWidth) {\n      if (oracle.lineWrapping) measureContent = true;\n      this.editorWidth = view.scrollDOM.clientWidth;\n      result |= 8 /* UpdateFlag.Geometry */;\n    }\n    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n    if (this.scrollTop != scrollTop) {\n      this.scrollAnchorHeight = -1;\n      this.scrollTop = scrollTop;\n    }\n    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n    // Pixel viewport\n    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n    let dTop = pixelViewport.top - this.pixelViewport.top,\n      dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n    this.pixelViewport = pixelViewport;\n    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n    if (inView != this.inView) {\n      this.inView = inView;\n      if (inView) measureContent = true;\n    }\n    if (!this.inView && !this.scrollTarget) return 0;\n    let contentWidth = domRect.width;\n    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n      this.contentDOMWidth = domRect.width;\n      this.editorHeight = view.scrollDOM.clientHeight;\n      result |= 8 /* UpdateFlag.Geometry */;\n    }\n    if (measureContent) {\n      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n      if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n        let {\n          lineHeight,\n          charWidth,\n          textHeight\n        } = view.docView.measureTextSize();\n        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n        if (refresh) {\n          view.docView.minWidth = 0;\n          result |= 8 /* UpdateFlag.Geometry */;\n        }\n      }\n      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n      oracle.heightChanged = false;\n      for (let vp of this.viewports) {\n        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n      }\n      if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */;\n    }\n    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n    if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n    this.updateForViewport();\n    if (result & 2 /* UpdateFlag.Height */ || viewportChange) this.updateViewportLines();\n    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */ << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n    result |= this.computeVisibleRanges();\n    if (this.mustEnforceCursorAssoc) {\n      this.mustEnforceCursorAssoc = false;\n      // This is done in the read stage, because moving the selection\n      // to a line end is going to trigger a layout anyway, so it\n      // can't be a pure write. It should be rare that it does any\n      // writing.\n      view.docView.enforceCursorAssoc();\n    }\n    return result;\n  }\n  get visibleTop() {\n    return this.scaler.fromDOM(this.pixelViewport.top);\n  }\n  get visibleBottom() {\n    return this.scaler.fromDOM(this.pixelViewport.bottom);\n  }\n  getViewport(bias, scrollTarget) {\n    // This will divide VP.Margin between the top and the\n    // bottom, depending on the bias (the change in viewport position\n    // since the last update). It'll hold a number between 0 and 1\n    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));\n    let map = this.heightMap,\n      oracle = this.heightOracle;\n    let {\n      visibleTop,\n      visibleBottom\n    } = this;\n    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);\n    // If scrollTarget is given, make sure the viewport includes that position\n    if (scrollTarget) {\n      let {\n        head\n      } = scrollTarget.range;\n      if (head < viewport.from || head > viewport.to) {\n        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0),\n          topPos;\n        if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;else topPos = block.bottom - viewHeight;\n        viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);\n      }\n    }\n    return viewport;\n  }\n  mapViewport(viewport, changes) {\n    let from = changes.mapPos(viewport.from, -1),\n      to = changes.mapPos(viewport.to, 1);\n    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n  }\n  // Checks if a given viewport covers the visible part of the\n  // document and not too much beyond that.\n  viewportIsAppropriate({\n    from,\n    to\n  }, bias = 0) {\n    if (!this.inView) return true;\n    let {\n      top\n    } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n    let {\n      bottom\n    } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n    let {\n      visibleTop,\n      visibleBottom\n    } = this;\n    return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) && top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */;\n  }\n  mapLineGaps(gaps, changes) {\n    if (!gaps.length || changes.empty) return gaps;\n    let mapped = [];\n    for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n    return mapped;\n  }\n  // Computes positions in the viewport where the start or end of a\n  // line should be hidden, trying to reuse existing line gaps when\n  // appropriate to avoid unneccesary redraws.\n  // Uses crude character-counting for the positioning and sizing,\n  // since actual DOM coordinates aren't always available and\n  // predictable. Relies on generous margins (see LG.Margin) to hide\n  // the artifacts this might produce from the user.\n  ensureLineGaps(current, mayMeasure) {\n    let wrapping = this.heightOracle.lineWrapping;\n    let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */,\n      halfMargin = margin >> 1,\n      doubleMargin = margin << 1;\n    // The non-wrapping logic won't work at all in predominantly right-to-left text.\n    if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n    let gaps = [];\n    let addGap = (from, to, line, structure) => {\n      if (to - from < halfMargin) return;\n      let sel = this.state.selection.main,\n        avoid = [sel.from];\n      if (!sel.empty) avoid.push(sel.to);\n      for (let pos of avoid) {\n        if (pos > from && pos < to) {\n          addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);\n          addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);\n          return;\n        }\n      }\n      let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some(pos => gap.from < pos && gap.to > pos));\n      if (!gap) {\n        // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {\n          let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n          if (lineStart > from) to = lineStart;\n        }\n        gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n      }\n      gaps.push(gap);\n    };\n    for (let line of this.viewportLines) {\n      if (line.length < doubleMargin) continue;\n      let structure = lineStructure(line.from, line.to, this.stateDeco);\n      if (structure.total < doubleMargin) continue;\n      let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n      let viewFrom, viewTo;\n      if (wrapping) {\n        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n        let top, bot;\n        if (target != null) {\n          let targetFrac = findFraction(structure, target);\n          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n          top = targetFrac - spaceFrac;\n          bot = targetFrac + spaceFrac;\n        } else {\n          top = (this.visibleTop - line.top - marginHeight) / line.height;\n          bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n        }\n        viewFrom = findPosition(structure, top);\n        viewTo = findPosition(structure, bot);\n      } else {\n        let totalWidth = structure.total * this.heightOracle.charWidth;\n        let marginWidth = margin * this.heightOracle.charWidth;\n        let left, right;\n        if (target != null) {\n          let targetFrac = findFraction(structure, target);\n          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n          left = targetFrac - spaceFrac;\n          right = targetFrac + spaceFrac;\n        } else {\n          left = (this.pixelViewport.left - marginWidth) / totalWidth;\n          right = (this.pixelViewport.right + marginWidth) / totalWidth;\n        }\n        viewFrom = findPosition(structure, left);\n        viewTo = findPosition(structure, right);\n      }\n      if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n      if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n    }\n    return gaps;\n  }\n  gapSize(line, from, to, structure) {\n    let fraction = findFraction(structure, to) - findFraction(structure, from);\n    if (this.heightOracle.lineWrapping) {\n      return line.height * fraction;\n    } else {\n      return structure.total * this.heightOracle.charWidth * fraction;\n    }\n  }\n  updateLineGaps(gaps) {\n    if (!LineGap.same(gaps, this.lineGaps)) {\n      this.lineGaps = gaps;\n      this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));\n    }\n  }\n  computeVisibleRanges() {\n    let deco = this.stateDeco;\n    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n    let ranges = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n      span(from, to) {\n        ranges.push({\n          from,\n          to\n        });\n      },\n      point() {}\n    }, 20);\n    let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);\n    this.visibleRanges = ranges;\n    return changed ? 4 /* UpdateFlag.Viewport */ : 0;\n  }\n  lineBlockAt(pos) {\n    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n  }\n  lineBlockAtHeight(height) {\n    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n  }\n  scrollAnchorAt(scrollTop) {\n    let block = this.lineBlockAtHeight(scrollTop + 8);\n    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n  }\n  elementAtHeight(height) {\n    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n  }\n  get docHeight() {\n    return this.scaler.toDOM(this.heightMap.height);\n  }\n  get contentHeight() {\n    return this.docHeight + this.paddingTop + this.paddingBottom;\n  }\n}\nclass Viewport {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n}\nfunction lineStructure(from, to, stateDeco) {\n  let ranges = [],\n    pos = from,\n    total = 0;\n  _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n    span() {},\n    point(from, to) {\n      if (from > pos) {\n        ranges.push({\n          from: pos,\n          to: from\n        });\n        total += from - pos;\n      }\n      pos = to;\n    }\n  }, 20); // We're only interested in collapsed ranges of a significant size\n  if (pos < to) {\n    ranges.push({\n      from: pos,\n      to\n    });\n    total += to - pos;\n  }\n  return {\n    total,\n    ranges\n  };\n}\nfunction findPosition({\n  total,\n  ranges\n}, ratio) {\n  if (ratio <= 0) return ranges[0].from;\n  if (ratio >= 1) return ranges[ranges.length - 1].to;\n  let dist = Math.floor(total * ratio);\n  for (let i = 0;; i++) {\n    let {\n        from,\n        to\n      } = ranges[i],\n      size = to - from;\n    if (dist <= size) return from + dist;\n    dist -= size;\n  }\n}\nfunction findFraction(structure, pos) {\n  let counted = 0;\n  for (let {\n    from,\n    to\n  } of structure.ranges) {\n    if (pos <= to) {\n      counted += pos - from;\n      break;\n    }\n    counted += to - from;\n  }\n  return counted / structure.total;\n}\nfunction find(array, f) {\n  for (let val of array) if (f(val)) return val;\n  return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n  toDOM(n) {\n    return n;\n  },\n  fromDOM(n) {\n    return n;\n  },\n  scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n  constructor(oracle, heightMap, viewports) {\n    let vpHeight = 0,\n      base = 0,\n      domBase = 0;\n    this.viewports = viewports.map(({\n      from,\n      to\n    }) => {\n      let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n      vpHeight += bottom - top;\n      return {\n        from,\n        to,\n        top,\n        bottom,\n        domTop: 0,\n        domBottom: 0\n      };\n    });\n    this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);\n    for (let obj of this.viewports) {\n      obj.domTop = domBase + (obj.top - base) * this.scale;\n      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n      base = obj.bottom;\n    }\n  }\n  toDOM(n) {\n    for (let i = 0, base = 0, domBase = 0;; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n      if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n  fromDOM(n) {\n    for (let i = 0, base = 0, domBase = 0;; i++) {\n      let vp = i < this.viewports.length ? this.viewports[i] : null;\n      if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n      if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n      base = vp.bottom;\n      domBase = vp.domBottom;\n    }\n  }\n}\nfunction scaleBlock(block, scaler) {\n  if (scaler.scale == 1) return block;\n  let bTop = scaler.toDOM(block.top),\n    bBottom = scaler.toDOM(block.bottom);\n  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: strs => strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n  baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n  baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n  \"&light\": \".\" + baseLightID,\n  \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n  return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n    finish(sel) {\n      return /&/.test(sel) ? sel.replace(/&\\w*/, m => {\n        if (m == \"&\") return main;\n        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n        return scopes[m];\n      }) : main + \" \" + sel;\n    }\n  });\n}\nconst baseTheme$1 = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\n  \"&\": {\n    position: \"relative !important\",\n    boxSizing: \"border-box\",\n    \"&.cm-focused\": {\n      // Provide a simple default outline to make sure a focused\n      // editor is visually distinct. Can't leave the default behavior\n      // because that will apply to the content element, which is\n      // inside the scrollable container and doesn't include the\n      // gutters. We also can't use an 'auto' outline, since those\n      // are, for some reason, drawn behind the element content, which\n      // will cause things like the active line background to cover\n      // the outline (#297).\n      outline: \"1px dotted #212121\"\n    },\n    display: \"flex !important\",\n    flexDirection: \"column\"\n  },\n  \".cm-scroller\": {\n    display: \"flex !important\",\n    alignItems: \"flex-start !important\",\n    fontFamily: \"monospace\",\n    lineHeight: 1.4,\n    height: \"100%\",\n    overflowX: \"auto\",\n    position: \"relative\",\n    zIndex: 0\n  },\n  \".cm-content\": {\n    margin: 0,\n    flexGrow: 2,\n    flexShrink: 0,\n    display: \"block\",\n    whiteSpace: \"pre\",\n    wordWrap: \"normal\",\n    // https://github.com/codemirror/dev/issues/456\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    padding: \"4px 0\",\n    outline: \"none\",\n    \"&[contenteditable=true]\": {\n      WebkitUserModify: \"read-write-plaintext-only\"\n    }\n  },\n  \".cm-lineWrapping\": {\n    whiteSpace_fallback: \"pre-wrap\",\n    // For IE\n    whiteSpace: \"break-spaces\",\n    wordBreak: \"break-word\",\n    // For Safari, which doesn't support overflow-wrap: anywhere\n    overflowWrap: \"anywhere\",\n    flexShrink: 1\n  },\n  \"&light .cm-content\": {\n    caretColor: \"black\"\n  },\n  \"&dark .cm-content\": {\n    caretColor: \"white\"\n  },\n  \".cm-line\": {\n    display: \"block\",\n    padding: \"0 2px 0 6px\"\n  },\n  \".cm-layer\": {\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    contain: \"size style\",\n    \"& > *\": {\n      position: \"absolute\"\n    }\n  },\n  \"&light .cm-selectionBackground\": {\n    background: \"#d9d9d9\"\n  },\n  \"&dark .cm-selectionBackground\": {\n    background: \"#222\"\n  },\n  \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n    background: \"#d7d4f0\"\n  },\n  \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n    background: \"#233\"\n  },\n  \".cm-cursorLayer\": {\n    pointerEvents: \"none\"\n  },\n  \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n    animation: \"steps(1) cm-blink 1.2s infinite\"\n  },\n  // Two animations defined so that we can switch between them to\n  // restart the animation without forcing another style\n  // recomputation.\n  \"@keyframes cm-blink\": {\n    \"0%\": {},\n    \"50%\": {\n      opacity: 0\n    },\n    \"100%\": {}\n  },\n  \"@keyframes cm-blink2\": {\n    \"0%\": {},\n    \"50%\": {\n      opacity: 0\n    },\n    \"100%\": {}\n  },\n  \".cm-cursor, .cm-dropCursor\": {\n    borderLeft: \"1.2px solid black\",\n    marginLeft: \"-0.6px\",\n    pointerEvents: \"none\"\n  },\n  \".cm-cursor\": {\n    display: \"none\"\n  },\n  \"&dark .cm-cursor\": {\n    borderLeftColor: \"#444\"\n  },\n  \".cm-dropCursor\": {\n    position: \"absolute\"\n  },\n  \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n    display: \"block\"\n  },\n  \".cm-iso\": {\n    unicodeBidi: \"isolate\"\n  },\n  \".cm-announced\": {\n    position: \"fixed\",\n    top: \"-10000px\"\n  },\n  \"@media print\": {\n    \".cm-announced\": {\n      display: \"none\"\n    }\n  },\n  \"&light .cm-activeLine\": {\n    backgroundColor: \"#cceeff44\"\n  },\n  \"&dark .cm-activeLine\": {\n    backgroundColor: \"#99eeff33\"\n  },\n  \"&light .cm-specialChar\": {\n    color: \"red\"\n  },\n  \"&dark .cm-specialChar\": {\n    color: \"#f78\"\n  },\n  \".cm-gutters\": {\n    flexShrink: 0,\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    insetInlineStart: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#6c6c6c\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    // Necessary -- prevents margin collapsing\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  },\n  \".cm-panels\": {\n    boxSizing: \"border-box\",\n    position: \"sticky\",\n    left: 0,\n    right: 0\n  },\n  \"&light .cm-panels\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"black\"\n  },\n  \"&light .cm-panels-top\": {\n    borderBottom: \"1px solid #ddd\"\n  },\n  \"&light .cm-panels-bottom\": {\n    borderTop: \"1px solid #ddd\"\n  },\n  \"&dark .cm-panels\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tab\": {\n    display: \"inline-block\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\"\n  },\n  \".cm-widgetBuffer\": {\n    verticalAlign: \"text-top\",\n    height: \"1em\",\n    width: 0,\n    display: \"inline\"\n  },\n  \".cm-placeholder\": {\n    color: \"#888\",\n    display: \"inline-block\",\n    verticalAlign: \"top\"\n  },\n  \".cm-highlightSpace:before\": {\n    content: \"attr(data-display)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    color: \"#888\"\n  },\n  \".cm-highlightTab\": {\n    backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n    backgroundSize: \"auto 100%\",\n    backgroundPosition: \"right 90%\",\n    backgroundRepeat: \"no-repeat\"\n  },\n  \".cm-trailingSpace\": {\n    backgroundColor: \"#ff332255\"\n  },\n  \".cm-button\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    padding: \".2em 1em\",\n    borderRadius: \"1px\"\n  },\n  \"&light .cm-button\": {\n    backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n    }\n  },\n  \"&dark .cm-button\": {\n    backgroundImage: \"linear-gradient(#393939, #111)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#111, #333)\"\n    }\n  },\n  \".cm-textfield\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    border: \"1px solid silver\",\n    padding: \".2em .5em\"\n  },\n  \"&light .cm-textfield\": {\n    backgroundColor: \"white\"\n  },\n  \"&dark .cm-textfield\": {\n    border: \"1px solid #555\",\n    backgroundColor: \"inherit\"\n  }\n}, lightDarkIDs);\nconst LineBreakPlaceholder = \"\\uffff\";\nclass DOMReader {\n  constructor(points, state) {\n    this.points = points;\n    this.text = \"\";\n    this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n  }\n  append(text) {\n    this.text += text;\n  }\n  lineBreak() {\n    this.text += LineBreakPlaceholder;\n  }\n  readRange(start, end) {\n    if (!start) return this;\n    let parent = start.parentNode;\n    for (let cur = start;;) {\n      this.findPointBefore(parent, cur);\n      let oldLen = this.text.length;\n      this.readNode(cur);\n      let next = cur.nextSibling;\n      if (next == end) break;\n      let view = ContentView.get(cur),\n        nextView = ContentView.get(next);\n      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();\n      cur = next;\n    }\n    this.findPointBefore(parent, end);\n    return this;\n  }\n  readTextNode(node) {\n    let text = node.nodeValue;\n    for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n    for (let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;) {\n      let nextBreak = -1,\n        breakSize = 1,\n        m;\n      if (this.lineSeparator) {\n        nextBreak = text.indexOf(this.lineSeparator, off);\n        breakSize = this.lineSeparator.length;\n      } else if (m = re.exec(text)) {\n        nextBreak = m.index;\n        breakSize = m[0].length;\n      }\n      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n      if (nextBreak < 0) break;\n      this.lineBreak();\n      if (breakSize > 1) for (let point of this.points) if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n      off = nextBreak + breakSize;\n    }\n  }\n  readNode(node) {\n    if (node.cmIgnore) return;\n    let view = ContentView.get(node);\n    let fromView = view && view.overrideDOMText;\n    if (fromView != null) {\n      this.findPointInside(node, fromView.length);\n      for (let i = fromView.iter(); !i.next().done;) {\n        if (i.lineBreak) this.lineBreak();else this.append(i.value);\n      }\n    } else if (node.nodeType == 3) {\n      this.readTextNode(node);\n    } else if (node.nodeName == \"BR\") {\n      if (node.nextSibling) this.lineBreak();\n    } else if (node.nodeType == 1) {\n      this.readRange(node.firstChild, null);\n    }\n  }\n  findPointBefore(node, next) {\n    for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n  }\n  findPointInside(node, length) {\n    for (let point of this.points) if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n  }\n}\nfunction isAtEnd(parent, node, offset) {\n  for (;;) {\n    if (!node || offset < maxOffset(node)) return false;\n    if (node == parent) return true;\n    offset = domIndex(node) + 1;\n    node = node.parentNode;\n  }\n}\nfunction isBlockElement(node) {\n  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n  constructor(node, offset) {\n    this.node = node;\n    this.offset = offset;\n    this.pos = -1;\n  }\n}\nclass DOMChange {\n  constructor(view, start, end, typeOver) {\n    this.typeOver = typeOver;\n    this.bounds = null;\n    this.text = \"\";\n    let {\n      impreciseHead: iHead,\n      impreciseAnchor: iAnchor\n    } = view.docView;\n    if (view.state.readOnly && start > -1) {\n      // Ignore changes when the editor is read-only\n      this.newSel = null;\n    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n      let reader = new DOMReader(selPoints, view.state);\n      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n      this.text = reader.text;\n      this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n    } else {\n      let domSel = view.observer.selectionRange;\n      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n      // iOS will refuse to select the block gaps when doing select-all\n      let vp = view.viewport;\n      if (browser.ios && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n        let offFrom = vp.from - Math.min(head, anchor),\n          offTo = vp.to - Math.max(head, anchor);\n        if ((offFrom == 0 || offFrom == 1) && (offTo == 0 || offTo == -1)) {\n          head = 0;\n          anchor = view.state.doc.length;\n        }\n      }\n      this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n    }\n  }\n}\nfunction applyDOMChange(view, domChange) {\n  let change;\n  let {\n      newSel\n    } = domChange,\n    sel = view.state.selection.main;\n  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n  if (domChange.bounds) {\n    let {\n      from,\n      to\n    } = domChange.bounds;\n    let preferredPos = sel.from,\n      preferredSide = null;\n    // Prefer anchoring to end when Backspace is pressed (or, on\n    // Android, when something was deleted)\n    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n      preferredPos = sel.to;\n      preferredSide = \"end\";\n    }\n    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n    if (diff) {\n      // Chrome inserts two newlines when pressing shift-enter at the\n      // end of a line. DomChange drops one of those.\n      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n      change = {\n        from: from + diff.from,\n        to: from + diff.toA,\n        insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n      };\n    }\n  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n    newSel = null;\n  }\n  if (!change && !newSel) return false;\n  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n    // Heuristic to notice typing over a selected character\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: view.state.doc.slice(sel.from, sel.to)\n    };\n  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n    // If the change is inside the selection and covers most of it,\n    // assume it is a selection replace (with identical characters at\n    // the start/end not included in the diff)\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n    };\n  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n    // Detect insert-period-on-double-space Mac and Android behavior,\n    // and transform it into a regular space insert.\n    if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"])\n    };\n  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n    // In Chrome, if you insert a space at the start of a wrapped\n    // line, it will actually insert a newline and a space, causing a\n    // bogus new line to be created in CodeMirror (#968)\n    if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n    change = {\n      from: sel.from,\n      to: sel.to,\n      insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\" \"])\n    };\n  }\n  if (change) {\n    if (browser.ios && view.inputState.flushIOSKey()) return true;\n    // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n    let text = change.insert.toString();\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let defaultTr;\n    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n    if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n    return true;\n  } else if (newSel && !newSel.main.eq(sel)) {\n    let scrollIntoView = false,\n      userEvent = \"select\";\n    if (view.inputState.lastSelectionTime > Date.now() - 50) {\n      if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n      userEvent = view.inputState.lastSelectionOrigin;\n    }\n    view.dispatch({\n      selection: newSel,\n      scrollIntoView,\n      userEvent\n    });\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction applyDefaultInsert(view, change, newSel) {\n  let tr,\n    startState = view.state,\n    sel = startState.selection.main;\n  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n  } else {\n    let changes = startState.changes(change);\n    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n    // Try to apply a composition change to all cursors\n    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n      let replaced = view.state.sliceDoc(change.from, change.to);\n      let compositionRange,\n        composition = newSel && findCompositionNode(view, newSel.main.head);\n      if (composition) {\n        let dLen = change.insert.length - (change.to - change.from);\n        compositionRange = {\n          from: composition.from,\n          to: composition.to - dLen\n        };\n      } else {\n        compositionRange = view.state.doc.lineAt(sel.head);\n      }\n      let offset = sel.to - change.to,\n        size = sel.to - sel.from;\n      tr = startState.changeByRange(range => {\n        if (range.from == sel.from && range.to == sel.to) return {\n          changes,\n          range: mainSel || range.map(changes)\n        };\n        let to = range.to - offset,\n          from = to - replaced.length;\n        if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||\n        // Unfortunately, there's no way to make multiple\n        // changes in the same node work without aborting\n        // composition, so cursors in the composition range are\n        // ignored.\n        range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n          range\n        };\n        let rangeChanges = startState.changes({\n            from,\n            to,\n            insert: change.insert\n          }),\n          selOff = range.to - sel.to;\n        return {\n          changes: rangeChanges,\n          range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n        };\n      });\n    } else {\n      tr = {\n        changes,\n        selection: mainSel && startState.selection.replaceRange(mainSel)\n      };\n    }\n  }\n  let userEvent = \"input.type\";\n  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n    view.inputState.compositionPendingChange = false;\n    userEvent += \".compose\";\n    if (view.inputState.compositionFirstChange) {\n      userEvent += \".start\";\n      view.inputState.compositionFirstChange = false;\n    }\n  }\n  return startState.update(tr, {\n    userEvent,\n    scrollIntoView: true\n  });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n  let minLen = Math.min(a.length, b.length);\n  let from = 0;\n  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;\n  if (from == minLen && a.length == b.length) return null;\n  let toA = a.length,\n    toB = b.length;\n  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n    toA--;\n    toB--;\n  }\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, from - Math.min(toA, toB));\n    preferredPos -= toA + adjust - from;\n  }\n  if (toA < from && a.length < b.length) {\n    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n    from -= move;\n    toB = from + (toB - toA);\n    toA = from;\n  } else if (toB < from) {\n    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n    from -= move;\n    toA = from + (toA - toB);\n    toB = from;\n  }\n  return {\n    from,\n    toA,\n    toB\n  };\n}\nfunction selectionPoints(view) {\n  let result = [];\n  if (view.root.activeElement != view.contentDOM) return result;\n  let {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  } = view.observer.selectionRange;\n  if (anchorNode) {\n    result.push(new DOMPoint(anchorNode, anchorOffset));\n    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n  }\n  return result;\n}\nfunction selectionFromPoints(points, base) {\n  if (points.length == 0) return null;\n  let anchor = points[0].pos,\n    head = points.length == 2 ? points[1].pos : anchor;\n  return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  subtree: true,\n  attributes: true,\n  characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n  constructor(view) {\n    this.view = view;\n    this.active = false;\n    // The known selection. Kept in our own object, as opposed to just\n    // directly accessing the selection because:\n    //  - Safari doesn't report the right selection in shadow DOM\n    //  - Reading from the selection forces a DOM layout\n    //  - This way, we can ignore selectionchange events if we have\n    //    already seen the 'new' selection\n    this.selectionRange = new DOMSelectionState();\n    // Set when a selection change is detected, cleared on flush\n    this.selectionChanged = false;\n    this.delayedFlush = -1;\n    this.resizeTimeout = -1;\n    this.queue = [];\n    this.delayedAndroidKey = null;\n    this.flushingAndroidKey = -1;\n    this.lastChange = 0;\n    this.scrollTargets = [];\n    this.intersection = null;\n    this.resizeScroll = null;\n    this.intersecting = false;\n    this.gapIntersection = null;\n    this.gaps = [];\n    // Timeout for scheduling check of the parents that need scroll handlers\n    this.parentCheck = -1;\n    this.dom = view.contentDOM;\n    this.observer = new MutationObserver(mutations => {\n      for (let mut of mutations) this.queue.push(mut);\n      // IE11 will sometimes (on typing over a selection or\n      // backspacing out a single character text node) call the\n      // observer callback before actually updating the DOM.\n      //\n      // Unrelatedly, iOS Safari will, when ending a composition,\n      // sometimes first clear it, deliver the mutations, and then\n      // reinsert the finished text. CodeMirror's handling of the\n      // deletion will prevent the reinsertion from happening,\n      // breaking composition.\n      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();else this.flush();\n    });\n    if (useCharData) this.onCharData = event => {\n      this.queue.push({\n        target: event.target,\n        type: \"characterData\",\n        oldValue: event.prevValue\n      });\n      this.flushSoon();\n    };\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this.onPrint = this.onPrint.bind(this);\n    this.onScroll = this.onScroll.bind(this);\n    if (typeof ResizeObserver == \"function\") {\n      this.resizeScroll = new ResizeObserver(() => {\n        var _a;\n        if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n      });\n      this.resizeScroll.observe(view.scrollDOM);\n    }\n    this.addWindowListeners(this.win = view.win);\n    this.start();\n    if (typeof IntersectionObserver == \"function\") {\n      this.intersection = new IntersectionObserver(entries => {\n        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n          this.intersecting = !this.intersecting;\n          if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n        }\n      }, {\n        threshold: [0, .001]\n      });\n      this.intersection.observe(this.dom);\n      this.gapIntersection = new IntersectionObserver(entries => {\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n      }, {});\n    }\n    this.listenForScroll();\n    this.readSelectionRange();\n  }\n  onScrollChanged(e) {\n    this.view.inputState.runHandlers(\"scroll\", e);\n    if (this.intersecting) this.view.measure();\n  }\n  onScroll(e) {\n    if (this.intersecting) this.flush(false);\n    this.onScrollChanged(e);\n  }\n  onResize() {\n    if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(() => {\n      this.resizeTimeout = -1;\n      this.view.requestMeasure();\n    }, 50);\n  }\n  onPrint() {\n    this.view.viewState.printing = true;\n    this.view.measure();\n    setTimeout(() => {\n      this.view.viewState.printing = false;\n      this.view.requestMeasure();\n    }, 500);\n  }\n  updateGaps(gaps) {\n    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {\n      this.gapIntersection.disconnect();\n      for (let gap of gaps) this.gapIntersection.observe(gap);\n      this.gaps = gaps;\n    }\n  }\n  onSelectionChange(event) {\n    let wasChanged = this.selectionChanged;\n    if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n    let {\n        view\n      } = this,\n      sel = this.selectionRange;\n    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n    if (context && context.ignoreEvent(event)) {\n      if (!wasChanged) this.selectionChanged = false;\n      return;\n    }\n    // Deletions on IE11 fire their events in the wrong order, giving\n    // us a selection change event before the DOM changes are\n    // reported.\n    // Chrome Android has a similar issue when backspacing out a\n    // selection (#645).\n    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&\n    // (Selection.isCollapsed isn't reliable on IE)\n    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush(false);\n  }\n  readSelectionRange() {\n    let {\n      view\n    } = this;\n    // The Selection object is broken in shadow roots in Safari. See\n    // https://github.com/codemirror/dev/issues/414\n    let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);\n    if (!range || this.selectionRange.eq(range)) return false;\n    let local = hasSelection(this.dom, range);\n    // Detect the situation where the browser has, on focus, moved the\n    // selection to the start of the content element. Reset it to the\n    // position from the editor state.\n    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n      this.view.inputState.lastFocusTime = 0;\n      view.docView.updateSelection();\n      return false;\n    }\n    this.selectionRange.setRange(range);\n    if (local) this.selectionChanged = true;\n    return true;\n  }\n  setSelectionRange(anchor, head) {\n    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n    this.selectionChanged = false;\n  }\n  clearSelectionRange() {\n    this.selectionRange.set(null, 0, null, 0);\n  }\n  listenForScroll() {\n    this.parentCheck = -1;\n    let i = 0,\n      changed = null;\n    for (let dom = this.dom; dom;) {\n      if (dom.nodeType == 1) {\n        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) changed.push(dom);\n        dom = dom.assignedSlot || dom.parentNode;\n      } else if (dom.nodeType == 11) {\n        // Shadow root\n        dom = dom.host;\n      } else {\n        break;\n      }\n    }\n    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n    if (changed) {\n      for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n      for (let dom of this.scrollTargets = changed) dom.addEventListener(\"scroll\", this.onScroll);\n    }\n  }\n  ignore(f) {\n    if (!this.active) return f();\n    try {\n      this.stop();\n      return f();\n    } finally {\n      this.start();\n      this.clear();\n    }\n  }\n  start() {\n    if (this.active) return;\n    this.observer.observe(this.dom, observeOptions);\n    if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.active = true;\n  }\n  stop() {\n    if (!this.active) return;\n    this.active = false;\n    this.observer.disconnect();\n    if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n  }\n  // Throw away any pending changes\n  clear() {\n    this.processRecords();\n    this.queue.length = 0;\n    this.selectionChanged = false;\n  }\n  // Chrome Android, especially in combination with GBoard, not only\n  // doesn't reliably fire regular key events, but also often\n  // surrounds the effect of enter or backspace with a bunch of\n  // composition events that, when interrupted, cause text duplication\n  // or other kinds of corruption. This hack makes the editor back off\n  // from handling DOM changes for a moment when such a key is\n  // detected (via beforeinput or keydown), and then tries to flush\n  // them or, if that has no effect, dispatches the given key.\n  delayAndroidKey(key, keyCode) {\n    var _a;\n    if (!this.delayedAndroidKey) {\n      let flush = () => {\n        let key = this.delayedAndroidKey;\n        if (key) {\n          this.clearDelayedAndroidKey();\n          this.view.inputState.lastKeyCode = key.keyCode;\n          this.view.inputState.lastKeyTime = Date.now();\n          let flushed = this.flush();\n          if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n        }\n      };\n      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n    }\n    // Since backspace beforeinput is sometimes signalled spuriously,\n    // Enter always takes precedence.\n    if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n      key,\n      keyCode,\n      // Only run the key handler when no changes are detected if\n      // this isn't coming right after another change, in which case\n      // it is probably part of a weird chain of updates, and should\n      // be ignored if it returns the DOM to its previous state.\n      force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n    };\n  }\n  clearDelayedAndroidKey() {\n    this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    this.delayedAndroidKey = null;\n    this.flushingAndroidKey = -1;\n  }\n  flushSoon() {\n    if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(() => {\n      this.delayedFlush = -1;\n      this.flush();\n    });\n  }\n  forceFlush() {\n    if (this.delayedFlush >= 0) {\n      this.view.win.cancelAnimationFrame(this.delayedFlush);\n      this.delayedFlush = -1;\n    }\n    this.flush();\n  }\n  pendingRecords() {\n    for (let mut of this.observer.takeRecords()) this.queue.push(mut);\n    return this.queue;\n  }\n  processRecords() {\n    let records = this.pendingRecords();\n    if (records.length) this.queue = [];\n    let from = -1,\n      to = -1,\n      typeOver = false;\n    for (let record of records) {\n      let range = this.readMutation(record);\n      if (!range) continue;\n      if (range.typeOver) typeOver = true;\n      if (from == -1) {\n        ({\n          from,\n          to\n        } = range);\n      } else {\n        from = Math.min(range.from, from);\n        to = Math.max(range.to, to);\n      }\n    }\n    return {\n      from,\n      to,\n      typeOver\n    };\n  }\n  readChange() {\n    let {\n      from,\n      to,\n      typeOver\n    } = this.processRecords();\n    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n    if (from < 0 && !newSel) return null;\n    if (from > -1) this.lastChange = Date.now();\n    this.view.inputState.lastFocusTime = 0;\n    this.selectionChanged = false;\n    let change = new DOMChange(this.view, from, to, typeOver);\n    this.view.docView.domChanged = {\n      newSel: change.newSel ? change.newSel.main : null\n    };\n    return change;\n  }\n  // Apply pending changes, if any\n  flush(readSelection = true) {\n    // Completely hold off flushing when pending keys are set—the code\n    // managing those will make sure processRecords is called and the\n    // view is resynchronized after\n    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n    if (readSelection) this.readSelectionRange();\n    let domChange = this.readChange();\n    if (!domChange) {\n      this.view.requestMeasure();\n      return false;\n    }\n    let startState = this.view.state;\n    let handled = applyDOMChange(this.view, domChange);\n    // The view wasn't updated\n    if (this.view.state == startState) this.view.update([]);\n    return handled;\n  }\n  readMutation(rec) {\n    let cView = this.view.docView.nearest(rec.target);\n    if (!cView || cView.ignoreMutation(rec)) return null;\n    cView.markDirty(rec.type == \"attributes\");\n    if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */;\n    if (rec.type == \"childList\") {\n      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n      return {\n        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n        typeOver: false\n      };\n    } else if (rec.type == \"characterData\") {\n      return {\n        from: cView.posAtStart,\n        to: cView.posAtEnd,\n        typeOver: rec.target.nodeValue == rec.oldValue\n      };\n    } else {\n      return null;\n    }\n  }\n  setWindow(win) {\n    if (win != this.win) {\n      this.removeWindowListeners(this.win);\n      this.win = win;\n      this.addWindowListeners(this.win);\n    }\n  }\n  addWindowListeners(win) {\n    win.addEventListener(\"resize\", this.onResize);\n    win.addEventListener(\"beforeprint\", this.onPrint);\n    win.addEventListener(\"scroll\", this.onScroll);\n    win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  removeWindowListeners(win) {\n    win.removeEventListener(\"scroll\", this.onScroll);\n    win.removeEventListener(\"resize\", this.onResize);\n    win.removeEventListener(\"beforeprint\", this.onPrint);\n    win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  destroy() {\n    var _a, _b, _c;\n    this.stop();\n    (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n    for (let dom of this.scrollTargets) dom.removeEventListener(\"scroll\", this.onScroll);\n    this.removeWindowListeners(this.win);\n    clearTimeout(this.parentCheck);\n    clearTimeout(this.resizeTimeout);\n    this.win.cancelAnimationFrame(this.delayedFlush);\n    this.win.cancelAnimationFrame(this.flushingAndroidKey);\n  }\n}\nfunction findChild(cView, dom, dir) {\n  while (dom) {\n    let curView = ContentView.get(dom);\n    if (curView && curView.parent == cView) return curView;\n    let parent = dom.parentNode;\n    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n  }\n  return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n  let found = null;\n  // Because Safari (at least in 2018-2021) doesn't provide regular\n  // access to the selection inside a shadowroot, we have to perform a\n  // ridiculous hack to get at it—using `execCommand` to trigger a\n  // `beforeInput` event so that we can read the target range from the\n  // event.\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found = event.getTargetRanges()[0];\n  }\n  view.contentDOM.addEventListener(\"beforeinput\", read, true);\n  view.dom.ownerDocument.execCommand(\"indent\");\n  view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n  if (!found) return null;\n  let anchorNode = found.startContainer,\n    anchorOffset = found.startOffset;\n  let focusNode = found.endContainer,\n    focusOffset = found.endOffset;\n  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n  // Since such a range doesn't distinguish between anchor and head,\n  // use a heuristic that flips it around if its end matches the\n  // current anchor.\n  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n  return {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset\n  };\n}\n\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/\nclass EditorView {\n  /**\n  The current editor state.\n  */\n  get state() {\n    return this.viewState.state;\n  }\n  /**\n  To be able to display large documents without consuming too much\n  memory or overloading the browser, CodeMirror only draws the\n  code that is visible (plus a margin around it) to the DOM. This\n  property tells you the extent of the current drawn viewport, in\n  document positions.\n  */\n  get viewport() {\n    return this.viewState.viewport;\n  }\n  /**\n  When there are, for example, large collapsed ranges in the\n  viewport, its size can be a lot bigger than the actual visible\n  content. Thus, if you are doing something like styling the\n  content in the viewport, it is preferable to only do so for\n  these ranges, which are the subset of the viewport that is\n  actually drawn.\n  */\n  get visibleRanges() {\n    return this.viewState.visibleRanges;\n  }\n  /**\n  Returns false when the editor is entirely scrolled out of view\n  or otherwise hidden.\n  */\n  get inView() {\n    return this.viewState.inView;\n  }\n  /**\n  Indicates whether the user is currently composing text via\n  [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n  one change has been made in the current composition.\n  */\n  get composing() {\n    return this.inputState.composing > 0;\n  }\n  /**\n  Indicates whether the user is currently in composing state. Note\n  that on some platforms, like Android, this will be the case a\n  lot, since just putting the cursor on a word starts a\n  composition there.\n  */\n  get compositionStarted() {\n    return this.inputState.composing >= 0;\n  }\n  /**\n  The document or shadow root that the view lives in.\n  */\n  get root() {\n    return this._root;\n  }\n  /**\n  @internal\n  */\n  get win() {\n    return this.dom.ownerDocument.defaultView || window;\n  }\n  /**\n  Construct a new view. You'll want to either provide a `parent`\n  option, or put `view.dom` into your document after creating a\n  view, so that the user can see the editor.\n  */\n  constructor(config = {}) {\n    this.plugins = [];\n    this.pluginMap = new Map();\n    this.editorAttrs = {};\n    this.contentAttrs = {};\n    this.bidiCache = [];\n    this.destroyed = false;\n    /**\n    @internal\n    */\n    this.updateState = 2 /* UpdateState.Updating */;\n    /**\n    @internal\n    */\n    this.measureScheduled = -1;\n    /**\n    @internal\n    */\n    this.measureRequests = [];\n    this.contentDOM = document.createElement(\"div\");\n    this.scrollDOM = document.createElement(\"div\");\n    this.scrollDOM.tabIndex = -1;\n    this.scrollDOM.className = \"cm-scroller\";\n    this.scrollDOM.appendChild(this.contentDOM);\n    this.announceDOM = document.createElement(\"div\");\n    this.announceDOM.className = \"cm-announced\";\n    this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n    this.dom = document.createElement(\"div\");\n    this.dom.appendChild(this.announceDOM);\n    this.dom.appendChild(this.scrollDOM);\n    if (config.parent) config.parent.appendChild(this.dom);\n    let {\n      dispatch\n    } = config;\n    this.dispatchTransactions = config.dispatchTransactions || dispatch && (trs => trs.forEach(tr => dispatch(tr, this))) || (trs => this.update(trs));\n    this.dispatch = this.dispatch.bind(this);\n    this._root = config.root || getRoot(config.parent) || document;\n    this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n    if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n    this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));\n    for (let plugin of this.plugins) plugin.update(this);\n    this.observer = new DOMObserver(this);\n    this.inputState = new InputState(this);\n    this.inputState.ensureHandlers(this.plugins);\n    this.docView = new DocView(this);\n    this.mountStyles();\n    this.updateAttrs();\n    this.updateState = 0 /* UpdateState.Idle */;\n    this.requestMeasure();\n  }\n  dispatch(...input) {\n    let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];\n    this.dispatchTransactions(trs, this);\n  }\n  /**\n  Update the view for the given array of transactions. This will\n  update the visible document and selection to match the state\n  produced by the transactions, and notify view plugins of the\n  change. You should usually call\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n  as a primitive.\n  */\n  update(transactions) {\n    if (this.updateState != 0 /* UpdateState.Idle */) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n    let redrawn = false,\n      attrsChanged = false,\n      update;\n    let state = this.state;\n    for (let tr of transactions) {\n      if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n      state = tr.state;\n    }\n    if (this.destroyed) {\n      this.viewState.state = state;\n      return;\n    }\n    let focus = this.hasFocus,\n      focusFlag = 0,\n      dispatchFocus = null;\n    if (transactions.some(tr => tr.annotation(isFocusChange))) {\n      this.inputState.notifiedFocused = focus;\n      // If a focus-change transaction is being dispatched, set this update flag.\n      focusFlag = 1 /* UpdateFlag.Focus */;\n    } else if (focus != this.inputState.notifiedFocused) {\n      this.inputState.notifiedFocused = focus;\n      // Schedule a separate focus transaction if necessary, otherwise\n      // add a flag to this update\n      dispatchFocus = focusChangeTransaction(state, focus);\n      if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */;\n    }\n    // If there was a pending DOM change, eagerly read it and try to\n    // apply it after the given transactions.\n    let pendingKey = this.observer.delayedAndroidKey,\n      domChange = null;\n    if (pendingKey) {\n      this.observer.clearDelayedAndroidKey();\n      domChange = this.observer.readChange();\n      // Only try to apply DOM changes if the transactions didn't\n      // change the doc or selection.\n      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n    } else {\n      this.observer.clear();\n    }\n    // When the phrases change, redraw the editor\n    if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n    update = ViewUpdate.create(this, state, transactions);\n    update.flags |= focusFlag;\n    let scrollTarget = this.viewState.scrollTarget;\n    try {\n      this.updateState = 2 /* UpdateState.Updating */;\n      for (let tr of transactions) {\n        if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n        if (tr.scrollIntoView) {\n          let {\n            main\n          } = tr.state.selection;\n          scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n        }\n        for (let e of tr.effects) if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n      }\n      this.viewState.update(update, scrollTarget);\n      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n      if (!update.empty) {\n        this.updatePlugins(update);\n        this.inputState.update(update);\n      }\n      redrawn = this.docView.update(update);\n      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n      attrsChanged = this.updateAttrs();\n      this.showAnnouncements(transactions);\n      this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent(\"select.pointer\")));\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n    }\n    if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n    if (!update.empty) for (let listener of this.state.facet(updateListener)) {\n      try {\n        listener(update);\n      } catch (e) {\n        logException(this.state, e, \"update listener\");\n      }\n    }\n    if (dispatchFocus || domChange) Promise.resolve().then(() => {\n      if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n      if (domChange) {\n        if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n      }\n    });\n  }\n  /**\n  Reset the view to the given state. (This will cause the entire\n  document to be redrawn and all view plugins to be reinitialized,\n  so you should probably only use it when the new state isn't\n  derived from the old state. Otherwise, use\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n  */\n  setState(newState) {\n    if (this.updateState != 0 /* UpdateState.Idle */) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n    if (this.destroyed) {\n      this.viewState.state = newState;\n      return;\n    }\n    this.updateState = 2 /* UpdateState.Updating */;\n    let hadFocus = this.hasFocus;\n    try {\n      for (let plugin of this.plugins) plugin.destroy(this);\n      this.viewState = new ViewState(newState);\n      this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));\n      this.pluginMap.clear();\n      for (let plugin of this.plugins) plugin.update(this);\n      this.docView.destroy();\n      this.docView = new DocView(this);\n      this.inputState.ensureHandlers(this.plugins);\n      this.mountStyles();\n      this.updateAttrs();\n      this.bidiCache = [];\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n    }\n    if (hadFocus) this.focus();\n    this.requestMeasure();\n  }\n  updatePlugins(update) {\n    let prevSpecs = update.startState.facet(viewPlugin),\n      specs = update.state.facet(viewPlugin);\n    if (prevSpecs != specs) {\n      let newPlugins = [];\n      for (let spec of specs) {\n        let found = prevSpecs.indexOf(spec);\n        if (found < 0) {\n          newPlugins.push(new PluginInstance(spec));\n        } else {\n          let plugin = this.plugins[found];\n          plugin.mustUpdate = update;\n          newPlugins.push(plugin);\n        }\n      }\n      for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this);\n      this.plugins = newPlugins;\n      this.pluginMap.clear();\n    } else {\n      for (let p of this.plugins) p.mustUpdate = update;\n    }\n    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);\n    if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n  }\n  /**\n  @internal\n  */\n  measure(flush = true) {\n    if (this.destroyed) return;\n    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n    if (this.observer.delayedAndroidKey) {\n      this.measureScheduled = -1;\n      this.requestMeasure();\n      return;\n    }\n    this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n    if (flush) this.observer.forceFlush();\n    let updated = null;\n    let sDOM = this.scrollDOM,\n      scrollTop = sDOM.scrollTop * this.scaleY;\n    let {\n      scrollAnchorPos,\n      scrollAnchorHeight\n    } = this.viewState;\n    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n    this.viewState.scrollAnchorHeight = -1;\n    try {\n      for (let i = 0;; i++) {\n        if (scrollAnchorHeight < 0) {\n          if (isScrolledToBottom(sDOM)) {\n            scrollAnchorPos = -1;\n            scrollAnchorHeight = this.viewState.heightMap.height;\n          } else {\n            let block = this.viewState.scrollAnchorAt(scrollTop);\n            scrollAnchorPos = block.from;\n            scrollAnchorHeight = block.top;\n          }\n        }\n        this.updateState = 1 /* UpdateState.Measuring */;\n        let changed = this.viewState.measure(this);\n        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n        if (i > 5) {\n          console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n          break;\n        }\n        let measuring = [];\n        // Only run measure requests in this cycle when the viewport didn't change\n        if (!(changed & 4 /* UpdateFlag.Viewport */)) [this.measureRequests, measuring] = [measuring, this.measureRequests];\n        let measured = measuring.map(m => {\n          try {\n            return m.read(this);\n          } catch (e) {\n            logException(this.state, e);\n            return BadMeasure;\n          }\n        });\n        let update = ViewUpdate.create(this, this.state, []),\n          redrawn = false;\n        update.flags |= changed;\n        if (!updated) updated = update;else updated.flags |= changed;\n        this.updateState = 2 /* UpdateState.Updating */;\n        if (!update.empty) {\n          this.updatePlugins(update);\n          this.inputState.update(update);\n          this.updateAttrs();\n          redrawn = this.docView.update(update);\n        }\n        for (let i = 0; i < measuring.length; i++) if (measured[i] != BadMeasure) {\n          try {\n            let m = measuring[i];\n            if (m.write) m.write(measured[i], this);\n          } catch (e) {\n            logException(this.state, e);\n          }\n        }\n        if (redrawn) this.docView.updateSelection(true);\n        if (!update.viewportChanged && this.measureRequests.length == 0) {\n          if (this.viewState.editorHeight) {\n            if (this.viewState.scrollTarget) {\n              this.docView.scrollIntoView(this.viewState.scrollTarget);\n              this.viewState.scrollTarget = null;\n              scrollAnchorHeight = -1;\n              continue;\n            } else {\n              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n              let diff = newAnchorHeight - scrollAnchorHeight;\n              if (diff > 1 || diff < -1) {\n                scrollTop = scrollTop + diff;\n                sDOM.scrollTop = scrollTop / this.scaleY;\n                scrollAnchorHeight = -1;\n                continue;\n              }\n            }\n          }\n          break;\n        }\n      }\n    } finally {\n      this.updateState = 0 /* UpdateState.Idle */;\n      this.measureScheduled = -1;\n    }\n    if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);\n  }\n  /**\n  Get the CSS classes for the currently active editor themes.\n  */\n  get themeClasses() {\n    return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n  }\n  updateAttrs() {\n    let editorAttrs = attrsFromFacet(this, editorAttributes, {\n      class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n    });\n    let contentAttrs = {\n      spellcheck: \"false\",\n      autocorrect: \"off\",\n      autocapitalize: \"off\",\n      translate: \"no\",\n      contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n      class: \"cm-content\",\n      style: `${browser.tabSize}: ${this.state.tabSize}`,\n      role: \"textbox\",\n      \"aria-multiline\": \"true\"\n    };\n    if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n    attrsFromFacet(this, contentAttributes, contentAttrs);\n    let changed = this.observer.ignore(() => {\n      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n      return changedContent || changedEditor;\n    });\n    this.editorAttrs = editorAttrs;\n    this.contentAttrs = contentAttrs;\n    return changed;\n  }\n  showAnnouncements(trs) {\n    let first = true;\n    for (let tr of trs) for (let effect of tr.effects) if (effect.is(EditorView.announce)) {\n      if (first) this.announceDOM.textContent = \"\";\n      first = false;\n      let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n      div.textContent = effect.value;\n    }\n  }\n  mountStyles() {\n    this.styleModules = this.state.facet(styleModule);\n    let nonce = this.state.facet(EditorView.cspNonce);\n    style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n      nonce\n    } : undefined);\n  }\n  readMeasured() {\n    if (this.updateState == 2 /* UpdateState.Updating */) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n    if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1) this.measure(false);\n  }\n  /**\n  Schedule a layout measurement, optionally providing callbacks to\n  do custom DOM measuring followed by a DOM write phase. Using\n  this is preferable reading DOM layout directly from, for\n  example, an event handler, because it'll make sure measuring and\n  drawing done by other components is synchronized, avoiding\n  unnecessary DOM layout computations.\n  */\n  requestMeasure(request) {\n    if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());\n    if (request) {\n      if (this.measureRequests.indexOf(request) > -1) return;\n      if (request.key != null) for (let i = 0; i < this.measureRequests.length; i++) {\n        if (this.measureRequests[i].key === request.key) {\n          this.measureRequests[i] = request;\n          return;\n        }\n      }\n      this.measureRequests.push(request);\n    }\n  }\n  /**\n  Get the value of a specific plugin, if present. Note that\n  plugins that crash can be dropped from a view, so even when you\n  know you registered a given plugin, it is recommended to check\n  the return value of this method.\n  */\n  plugin(plugin) {\n    let known = this.pluginMap.get(plugin);\n    if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);\n    return known && known.update(this).value;\n  }\n  /**\n  The top position of the document, in screen coordinates. This\n  may be negative when the editor is scrolled down. Points\n  directly to the top of the first line, not above the padding.\n  */\n  get documentTop() {\n    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n  }\n  /**\n  Reports the padding above and below the document.\n  */\n  get documentPadding() {\n    return {\n      top: this.viewState.paddingTop,\n      bottom: this.viewState.paddingBottom\n    };\n  }\n  /**\n  If the editor is transformed with CSS, this provides the scale\n  along the X axis. Otherwise, it will just be 1. Note that\n  transforms other than translation and scaling are not supported.\n  */\n  get scaleX() {\n    return this.viewState.scaleX;\n  }\n  /**\n  Provide the CSS transformed scale along the Y axis.\n  */\n  get scaleY() {\n    return this.viewState.scaleY;\n  }\n  /**\n  Find the text line or block widget at the given vertical\n  position (which is interpreted as relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n  */\n  elementAtHeight(height) {\n    this.readMeasured();\n    return this.viewState.elementAtHeight(height);\n  }\n  /**\n  Find the line block (see\n  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n  height, again interpreted relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n  */\n  lineBlockAtHeight(height) {\n    this.readMeasured();\n    return this.viewState.lineBlockAtHeight(height);\n  }\n  /**\n  Get the extent and vertical position of all [line\n  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n  are relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n  */\n  get viewportLineBlocks() {\n    return this.viewState.viewportLines;\n  }\n  /**\n  Find the line block around the given document position. A line\n  block is a range delimited on both sides by either a\n  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n  start/end of the document. It will usually just hold a line of\n  text, but may be broken into multiple textblocks by block\n  widgets.\n  */\n  lineBlockAt(pos) {\n    return this.viewState.lineBlockAt(pos);\n  }\n  /**\n  The editor's total content height.\n  */\n  get contentHeight() {\n    return this.viewState.contentHeight;\n  }\n  /**\n  Move a cursor position by [grapheme\n  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n  the motion is away from the line start, or towards it. In\n  bidirectional text, the line is traversed in visual order, using\n  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n  When the start position was the last one on the line, the\n  returned position will be across the line break. If there is no\n  further line, the original position is returned.\n  \n  By default, this method moves over a single cluster. The\n  optional `by` argument can be used to move across more. It will\n  be called with the first cluster as argument, and should return\n  a predicate that determines, for each subsequent cluster,\n  whether it should also be moved over.\n  */\n  moveByChar(start, forward, by) {\n    return skipAtoms(this, start, moveByChar(this, start, forward, by));\n  }\n  /**\n  Move a cursor position across the next group of either\n  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n  non-whitespace characters.\n  */\n  moveByGroup(start, forward) {\n    return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));\n  }\n  /**\n  Get the cursor position visually at the start or end of a line.\n  Note that this may differ from the _logical_ position at its\n  start or end (which is simply at `line.from`/`line.to`) if text\n  at the start or end goes against the line's base text direction.\n  */\n  visualLineSide(line, end) {\n    let order = this.bidiSpans(line),\n      dir = this.textDirectionAt(line.from);\n    let span = order[end ? order.length - 1 : 0];\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n  }\n  /**\n  Move to the next line boundary in the given direction. If\n  `includeWrap` is true, line wrapping is on, and there is a\n  further wrap point on the current line, the wrap point will be\n  returned. Otherwise this function will return the start or end\n  of the line.\n  */\n  moveToLineBoundary(start, forward, includeWrap = true) {\n    return moveToLineBoundary(this, start, forward, includeWrap);\n  }\n  /**\n  Move a cursor position vertically. When `distance` isn't given,\n  it defaults to moving to the next line (including wrapped\n  lines). Otherwise, `distance` should provide a positive distance\n  in pixels.\n  \n  When `start` has a\n  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n  motion will use that as a target horizontal position. Otherwise,\n  the cursor's own horizontal position is used. The returned\n  cursor will have its goal column set to whichever column was\n  used.\n  */\n  moveVertically(start, forward, distance) {\n    return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n  }\n  /**\n  Find the DOM parent node and offset (child offset if `node` is\n  an element, character offset when it is a text node) at the\n  given document position.\n  \n  Note that for positions that aren't currently in\n  `visibleRanges`, the resulting DOM position isn't necessarily\n  meaningful (it may just point before or after a placeholder\n  element).\n  */\n  domAtPos(pos) {\n    return this.docView.domAtPos(pos);\n  }\n  /**\n  Find the document position at the given DOM node. Can be useful\n  for associating positions with DOM events. Will raise an error\n  when `node` isn't part of the editor content.\n  */\n  posAtDOM(node, offset = 0) {\n    return this.docView.posFromDOM(node, offset);\n  }\n  posAtCoords(coords, precise = true) {\n    this.readMeasured();\n    return posAtCoords(this, coords, precise);\n  }\n  /**\n  Get the screen coordinates at the given document position.\n  `side` determines whether the coordinates are based on the\n  element before (-1) or after (1) the position (if no element is\n  available on the given side, the method will transparently use\n  another strategy to get reasonable coordinates).\n  */\n  coordsAtPos(pos, side = 1) {\n    this.readMeasured();\n    let rect = this.docView.coordsAt(pos, side);\n    if (!rect || rect.left == rect.right) return rect;\n    let line = this.state.doc.lineAt(pos),\n      order = this.bidiSpans(line);\n    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n    return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n  }\n  /**\n  Return the rectangle around a given character. If `pos` does not\n  point in front of a character that is in the viewport and\n  rendered (i.e. not replaced, not a line break), this will return\n  null. For space characters that are a line wrap point, this will\n  return the position before the line break.\n  */\n  coordsForChar(pos) {\n    this.readMeasured();\n    return this.docView.coordsForChar(pos);\n  }\n  /**\n  The default width of a character in the editor. May not\n  accurately reflect the width of all characters (given variable\n  width fonts or styling of invididual ranges).\n  */\n  get defaultCharacterWidth() {\n    return this.viewState.heightOracle.charWidth;\n  }\n  /**\n  The default height of a line in the editor. May not be accurate\n  for all lines.\n  */\n  get defaultLineHeight() {\n    return this.viewState.heightOracle.lineHeight;\n  }\n  /**\n  The text direction\n  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n  CSS property) of the editor's content element.\n  */\n  get textDirection() {\n    return this.viewState.defaultTextDirection;\n  }\n  /**\n  Find the text direction of the block at the given position, as\n  assigned by CSS. If\n  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n  isn't enabled, or the given position is outside of the viewport,\n  this will always return the same as\n  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n  this may trigger a DOM layout.\n  */\n  textDirectionAt(pos) {\n    let perLine = this.state.facet(perLineTextDirection);\n    if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n    this.readMeasured();\n    return this.docView.textDirectionAt(pos);\n  }\n  /**\n  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n  (as determined by the\n  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n  CSS property of its content element).\n  */\n  get lineWrapping() {\n    return this.viewState.heightOracle.lineWrapping;\n  }\n  /**\n  Returns the bidirectional text structure of the given line\n  (which should be in the current document) as an array of span\n  objects. The order of these spans matches the [text\n  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n  left-to-right, the leftmost spans come first, otherwise the\n  rightmost spans come first.\n  */\n  bidiSpans(line) {\n    if (line.length > MaxBidiLine) return trivialOrder(line.length);\n    let dir = this.textDirectionAt(line.from),\n      isolates;\n    for (let entry of this.bidiCache) {\n      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n    }\n    if (!isolates) isolates = getIsolatedRanges(this, line);\n    let order = computeOrder(line.text, dir, isolates);\n    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n    return order;\n  }\n  /**\n  Check whether the editor has focus.\n  */\n  get hasFocus() {\n    var _a;\n    // Safari return false for hasFocus when the context menu is open\n    // or closing, which leads us to ignore selection changes from the\n    // context menu because it looks like the editor isn't focused.\n    // This kludges around that.\n    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n  }\n  /**\n  Put focus on the editor.\n  */\n  focus() {\n    this.observer.ignore(() => {\n      focusPreventScroll(this.contentDOM);\n      this.docView.updateSelection();\n    });\n  }\n  /**\n  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n  necessary when moving the editor's existing DOM to a new window or shadow root.\n  */\n  setRoot(root) {\n    if (this._root != root) {\n      this._root = root;\n      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n      this.mountStyles();\n    }\n  }\n  /**\n  Clean up this editor view, removing its element from the\n  document, unregistering event handlers, and notifying\n  plugins. The view instance can no longer be used after\n  calling this.\n  */\n  destroy() {\n    for (let plugin of this.plugins) plugin.destroy(this);\n    this.plugins = [];\n    this.inputState.destroy();\n    this.docView.destroy();\n    this.dom.remove();\n    this.observer.destroy();\n    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n    this.destroyed = true;\n  }\n  /**\n  Returns an effect that can be\n  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n  cause it to scroll the given position or range into view.\n  */\n  static scrollIntoView(pos, options = {}) {\n    return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n  }\n  /**\n  Return an effect that resets the editor to its current (at the\n  time this method was called) scroll position. Note that this\n  only affects the editor's own scrollable element, not parents.\n  See also\n  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n  \n  The effect should be used with a document identical to the one\n  it was created for. Failing to do so is not an error, but may\n  not scroll to the expected position. You can\n  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n  */\n  scrollSnapshot() {\n    let {\n      scrollTop,\n      scrollLeft\n    } = this.scrollDOM;\n    let ref = this.viewState.scrollAnchorAt(scrollTop);\n    return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n  }\n  /**\n  Returns an extension that can be used to add DOM event handlers.\n  The value should be an object mapping event names to handler\n  functions. For any given event, such functions are ordered by\n  extension precedence, and the first handler to return true will\n  be assumed to have handled that event, and no other handlers or\n  built-in behavior will be activated for it. These are registered\n  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n  for `scroll` handlers, which will be called any time the\n  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n  its parent nodes is scrolled.\n  */\n  static domEventHandlers(handlers) {\n    return ViewPlugin.define(() => ({}), {\n      eventHandlers: handlers\n    });\n  }\n  /**\n  Create an extension that registers DOM event observers. Contrary\n  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n  observers can't be prevented from running by a higher-precedence\n  handler returning true. They also don't prevent other handlers\n  and observers from running when they return true, and should not\n  call `preventDefault`.\n  */\n  static domEventObservers(observers) {\n    return ViewPlugin.define(() => ({}), {\n      eventObservers: observers\n    });\n  }\n  /**\n  Create a theme extension. The first argument can be a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n  style spec providing the styles for the theme. These will be\n  prefixed with a generated class for the style.\n  \n  Because the selectors will be prefixed with a scope class, rule\n  that directly match the editor's [wrapper\n  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n  added—need to be explicitly differentiated by adding an `&` to\n  the selector for that element—for example\n  `&.cm-focused`.\n  \n  When `dark` is set to true, the theme will be marked as dark,\n  which will cause the `&dark` rules from [base\n  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n  `&light` when a light theme is active).\n  */\n  static theme(spec, options) {\n    let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];\n    if (options && options.dark) result.push(darkTheme.of(true));\n    return result;\n  }\n  /**\n  Create an extension that adds styles to the base theme. Like\n  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n  place of the editor wrapper element when directly targeting\n  that. You can also use `&dark` or `&light` instead to only\n  target editors with a dark or light theme.\n  */\n  static baseTheme(spec) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n  }\n  /**\n  Retrieve an editor view instance from the view's DOM\n  representation.\n  */\n  static findFromDOM(dom) {\n    var _a;\n    let content = dom.querySelector(\".cm-content\");\n    let cView = content && ContentView.get(content) || ContentView.get(dom);\n    return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n  }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/\nEditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/\nEditorView.inputHandler = inputHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/\nEditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/\nEditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/\nEditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/\nEditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/\nEditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/\nEditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/\nEditorView.decorations = decorations;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping \\`outerDecorations\\` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/\nEditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/\nEditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/\nEditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/\nEditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/\nEditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/\nEditorView.cspNonce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/\nEditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/\nEditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({\n  \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n  constructor(from, to, dir, isolates, fresh, order) {\n    this.from = from;\n    this.to = to;\n    this.dir = dir;\n    this.isolates = isolates;\n    this.fresh = fresh;\n    this.order = order;\n  }\n  static update(cache, changes) {\n    if (changes.empty && !cache.some(c => c.fresh)) return cache;\n    let result = [],\n      lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n      let entry = cache[i];\n      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n    }\n    return result;\n  }\n}\nfunction attrsFromFacet(view, facet, base) {\n  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {\n    let source = sources[i],\n      value = typeof source == \"function\" ? source(view) : source;\n    if (value) combineAttrs(value, base);\n  }\n  return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (platform == \"mac\") meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\nconst handleKeyEvents = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default( /*@__PURE__*/EditorView.domEventHandlers({\n  keydown(event, view) {\n    return runHandlers(getKeymap(view.state), event, view, \"editor\");\n  }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/\nconst keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n  let bindings = state.facet(keymap);\n  let map = Keymaps.get(bindings);\n  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));\n  return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/\nfunction runScopeHandlers(view, event, scope) {\n  return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n  let bound = Object.create(null);\n  let isPrefix = Object.create(null);\n  let checkPrefix = (name, is) => {\n    let current = isPrefix[name];\n    if (current == null) isPrefix[name] = is;else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n  };\n  let add = (scope, key, command, preventDefault, stopPropagation) => {\n    var _a, _b;\n    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n    let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));\n    for (let i = 1; i < parts.length; i++) {\n      let prefix = parts.slice(0, i).join(\" \");\n      checkPrefix(prefix, true);\n      if (!scopeObj[prefix]) scopeObj[prefix] = {\n        preventDefault: true,\n        stopPropagation: false,\n        run: [view => {\n          let ourObj = storedPrefix = {\n            view,\n            prefix,\n            scope\n          };\n          setTimeout(() => {\n            if (storedPrefix == ourObj) storedPrefix = null;\n          }, PrefixTimeout);\n          return true;\n        }]\n      };\n    }\n    let full = parts.join(\" \");\n    checkPrefix(full, false);\n    let binding = scopeObj[full] || (scopeObj[full] = {\n      preventDefault: false,\n      stopPropagation: false,\n      run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n    });\n    if (command) binding.run.push(command);\n    if (preventDefault) binding.preventDefault = true;\n    if (stopPropagation) binding.stopPropagation = true;\n  };\n  for (let b of bindings) {\n    let scopes = b.scope ? b.scope.split(\" \") : [\"editor\"];\n    if (b.any) for (let scope of scopes) {\n      let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n      if (!scopeObj._any) scopeObj._any = {\n        preventDefault: false,\n        stopPropagation: false,\n        run: []\n      };\n      for (let key in scopeObj) scopeObj[key].run.push(b.any);\n    }\n    let name = b[platform] || b.key;\n    if (!name) continue;\n    for (let scope of scopes) {\n      add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n      if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n    }\n  }\n  return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n  let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n  let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0),\n    isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n  let prefix = \"\",\n    handled = false,\n    prevented = false,\n    stopPropagation = false;\n  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n    prefix = storedPrefix.prefix + \" \";\n    if (modifierCodes.indexOf(event.keyCode) < 0) {\n      prevented = true;\n      storedPrefix = null;\n    }\n  }\n  let ran = new Set();\n  let runFor = binding => {\n    if (binding) {\n      for (let cmd of binding.run) if (!ran.has(cmd)) {\n        ran.add(cmd);\n        if (cmd(view, event)) {\n          if (binding.stopPropagation) stopPropagation = true;\n          return true;\n        }\n      }\n      if (binding.preventDefault) {\n        if (binding.stopPropagation) stopPropagation = true;\n        prevented = true;\n      }\n    }\n    return false;\n  };\n  let scopeObj = map[scope],\n    baseName,\n    shiftName;\n  if (scopeObj) {\n    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n      handled = true;\n    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&\n    // Ctrl-Alt may be used for AltGr on Windows\n    !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n        handled = true;\n      } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n        handled = true;\n      }\n    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n      handled = true;\n    }\n    if (!handled && runFor(scopeObj._any)) handled = true;\n  }\n  if (prevented) handled = true;\n  if (handled && stopPropagation) event.stopPropagation();\n  return handled;\n}\n\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/\nclass RectangleMarker {\n  /**\n  Create a marker with the given class and dimensions. If `width`\n  is null, the DOM element will get no width style.\n  */\n  constructor(className,\n  /**\n  The left position of the marker (in pixels, document-relative).\n  */\n  left,\n  /**\n  The top position of the marker.\n  */\n  top,\n  /**\n  The width of the marker, or null if it shouldn't get a width assigned.\n  */\n  width,\n  /**\n  The height of the marker.\n  */\n  height) {\n    this.className = className;\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n  }\n  draw() {\n    let elt = document.createElement(\"div\");\n    elt.className = this.className;\n    this.adjust(elt);\n    return elt;\n  }\n  update(elt, prev) {\n    if (prev.className != this.className) return false;\n    this.adjust(elt);\n    return true;\n  }\n  adjust(elt) {\n    elt.style.left = this.left + \"px\";\n    elt.style.top = this.top + \"px\";\n    if (this.width != null) elt.style.width = this.width + \"px\";\n    elt.style.height = this.height + \"px\";\n  }\n  eq(p) {\n    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n  }\n  /**\n  Create a set of rectangles for the given selection range,\n  assigning them theclass`className`. Will create a single\n  rectangle for empty ranges, and a set of selection-style\n  rectangles covering the range's content (in a bidi-aware\n  way) for non-empty ones.\n  */\n  static forRange(view, className, range) {\n    if (range.empty) {\n      let pos = view.coordsAtPos(range.head, range.assoc || 1);\n      if (!pos) return [];\n      let base = getBase(view);\n      return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];\n    } else {\n      return rectanglesForRange(view, className, range);\n    }\n  }\n}\nfunction getBase(view) {\n  let rect = view.scrollDOM.getBoundingClientRect();\n  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n  return {\n    left: left - view.scrollDOM.scrollLeft * view.scaleX,\n    top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n  };\n}\nfunction wrappedLine(view, pos, inside) {\n  let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n  return {\n    from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n    to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n    type: BlockType.Text\n  };\n}\nfunction rectanglesForRange(view, className, range) {\n  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n  let from = Math.max(range.from, view.viewport.from),\n    to = Math.min(range.to, view.viewport.to);\n  let ltr = view.textDirection == Direction.LTR;\n  let content = view.contentDOM,\n    contentRect = content.getBoundingClientRect(),\n    base = getBase(view);\n  let lineElt = content.querySelector(\".cm-line\"),\n    lineStyle = lineElt && window.getComputedStyle(lineElt);\n  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n  let startBlock = blockAt(view, from),\n    endBlock = blockAt(view, to);\n  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, visualStart);\n  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, visualEnd);\n  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n    return pieces(drawForLine(range.from, range.to, visualStart));\n  } else {\n    let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n    let between = [];\n    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n    return pieces(top).concat(between).concat(pieces(bottom));\n  }\n  function piece(left, top, right, bottom) {\n    return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);\n  }\n  function pieces({\n    top,\n    bottom,\n    horizontal\n  }) {\n    let pieces = [];\n    for (let i = 0; i < horizontal.length; i += 2) pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n    return pieces;\n  }\n  // Gets passed from/to in line-local positions\n  function drawForLine(from, to, line) {\n    let top = 1e9,\n      bottom = -1e9,\n      horizontal = [];\n    function addSpan(from, fromOpen, to, toOpen, dir) {\n      // Passing 2/-2 is a kludge to force the view to return\n      // coordinates on the proper side of block widgets, since\n      // normalizing the side there, though appropriate for most\n      // coordsAtPos queries, would break selection drawing.\n      let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n      let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n      if (!fromCoords || !toCoords) return;\n      top = Math.min(fromCoords.top, toCoords.top, top);\n      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n    }\n    let start = from !== null && from !== void 0 ? from : line.from,\n      end = to !== null && to !== void 0 ? to : line.to;\n    // Split the range by visible range and document line\n    for (let r of view.visibleRanges) if (r.to > start && r.from < end) {\n      for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {\n        let docLine = view.state.doc.lineAt(pos);\n        for (let span of view.bidiSpans(docLine)) {\n          let spanFrom = span.from + docLine.from,\n            spanTo = span.to + docLine.from;\n          if (spanFrom >= endPos) break;\n          if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n        }\n        pos = docLine.to + 1;\n        if (pos >= endPos) break;\n      }\n    }\n    if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n    return {\n      top,\n      bottom,\n      horizontal\n    };\n  }\n  function drawForWidget(block, top) {\n    let y = contentRect.top + (top ? block.top : block.bottom);\n    return {\n      top: y,\n      bottom: y,\n      horizontal: []\n    };\n  }\n}\nfunction sameMarker(a, b) {\n  return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n  constructor(view, layer) {\n    this.view = view;\n    this.layer = layer;\n    this.drawn = [];\n    this.scaleX = 1;\n    this.scaleY = 1;\n    this.measureReq = {\n      read: this.measure.bind(this),\n      write: this.draw.bind(this)\n    };\n    this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.dom.classList.add(\"cm-layer\");\n    if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n    if (layer.class) this.dom.classList.add(layer.class);\n    this.scale();\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.setOrder(view.state);\n    view.requestMeasure(this.measureReq);\n    if (layer.mount) layer.mount(this.dom, view);\n  }\n  update(update) {\n    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n    if (this.layer.update(update, this.dom) || update.geometryChanged) {\n      this.scale();\n      update.view.requestMeasure(this.measureReq);\n    }\n  }\n  setOrder(state) {\n    let pos = 0,\n      order = state.facet(layerOrder);\n    while (pos < order.length && order[pos] != this.layer) pos++;\n    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n  }\n  measure() {\n    return this.layer.markers(this.view);\n  }\n  scale() {\n    let {\n      scaleX,\n      scaleY\n    } = this.view;\n    if (scaleX != this.scaleX || scaleY != this.scaleY) {\n      this.scaleX = scaleX;\n      this.scaleY = scaleY;\n      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n    }\n  }\n  draw(markers) {\n    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {\n      let old = this.dom.firstChild,\n        oldI = 0;\n      for (let marker of markers) {\n        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n          old = old.nextSibling;\n          oldI++;\n        } else {\n          this.dom.insertBefore(marker.draw(), old);\n        }\n      }\n      while (old) {\n        let next = old.nextSibling;\n        old.remove();\n        old = next;\n      }\n      this.drawn = markers;\n    }\n  }\n  destroy() {\n    if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n    this.dom.remove();\n  }\n}\nconst layerOrder = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/\nfunction layer(config) {\n  return [ViewPlugin.define(v => new LayerView(v, config)), layerOrder.of(config)];\n}\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n      cursorBlinkRate: 1200,\n      drawRangeCursor: true\n    }, {\n      cursorBlinkRate: (a, b) => Math.min(a, b),\n      drawRangeCursor: (a, b) => a || b\n    });\n  }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/\nfunction drawSelection(config = {}) {\n  return [selectionConfig.of(config), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/\nfunction getDrawSelectionConfig(state) {\n  return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/layer({\n  above: true,\n  markers(view) {\n    let {\n        state\n      } = view,\n      conf = state.facet(selectionConfig);\n    let cursors = [];\n    for (let r of state.selection.ranges) {\n      let prim = r == state.selection.main;\n      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n        let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n        let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n        for (let piece of RectangleMarker.forRange(view, className, cursor)) cursors.push(piece);\n      }\n    }\n    return cursors;\n  },\n  update(update, dom) {\n    if (update.transactions.some(tr => tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n    let confChange = configChanged(update);\n    if (confChange) setBlinkRate(update.state, dom);\n    return update.docChanged || update.selectionSet || confChange;\n  },\n  mount(dom, view) {\n    setBlinkRate(view.state, dom);\n  },\n  class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/layer({\n  above: false,\n  markers(view) {\n    return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b) => a.concat(b));\n  },\n  update(update, dom) {\n    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n  },\n  class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n  \".cm-line\": {\n    \"& ::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    \"&::selection\": {\n      backgroundColor: \"transparent !important\"\n    }\n  }\n};\nif (CanHidePrimary) {\n  themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\n  themeSpec[\".cm-content\"] = {\n    caretColor: \"transparent !important\"\n  };\n}\nconst hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest( /*@__PURE__*/EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n  map(pos, mapping) {\n    return pos == null ? null : mapping.mapPos(pos);\n  }\n});\nconst dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n  create() {\n    return null;\n  },\n  update(pos, tr) {\n    if (pos != null) pos = tr.changes.mapPos(pos);\n    return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);\n  }\n});\nconst drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.cursor = null;\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawCursor.bind(this)\n    };\n  }\n  update(update) {\n    var _a;\n    let cursorPos = update.state.field(dropCursorPos);\n    if (cursorPos == null) {\n      if (this.cursor != null) {\n        (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n        this.cursor = null;\n      }\n    } else {\n      if (!this.cursor) {\n        this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursor.className = \"cm-dropCursor\";\n      }\n      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n    }\n  }\n  readPos() {\n    let {\n      view\n    } = this;\n    let pos = view.state.field(dropCursorPos);\n    let rect = pos != null && view.coordsAtPos(pos);\n    if (!rect) return null;\n    let outer = view.scrollDOM.getBoundingClientRect();\n    return {\n      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n      height: rect.bottom - rect.top\n    };\n  }\n  drawCursor(pos) {\n    if (this.cursor) {\n      let {\n        scaleX,\n        scaleY\n      } = this.view;\n      if (pos) {\n        this.cursor.style.left = pos.left / scaleX + \"px\";\n        this.cursor.style.top = pos.top / scaleY + \"px\";\n        this.cursor.style.height = pos.height / scaleY + \"px\";\n      } else {\n        this.cursor.style.left = \"-100000px\";\n      }\n    }\n  }\n  destroy() {\n    if (this.cursor) this.cursor.remove();\n  }\n  setDropPos(pos) {\n    if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n      effects: setDropCursorPos.of(pos)\n    });\n  }\n}, {\n  eventObservers: {\n    dragover(event) {\n      this.setDropPos(this.view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n      }));\n    },\n    dragleave(event) {\n      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n    },\n    dragend() {\n      this.setDropPos(null);\n    },\n    drop() {\n      this.setDropPos(null);\n    }\n  }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/\nfunction dropCursor() {\n  return [dropCursorPos, drawDropCursor];\n}\nfunction iterMatches(doc, re, from, to, f) {\n  re.lastIndex = 0;\n  for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, m);\n  }\n}\nfunction matchRanges(view, maxLength) {\n  let visible = view.visibleRanges;\n  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n  let result = [];\n  for (let {\n    from,\n    to\n  } of visible) {\n    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n    if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;else result.push({\n      from,\n      to\n    });\n  }\n  return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/\nclass MatchDecorator {\n  /**\n  Create a decorator.\n  */\n  constructor(config) {\n    const {\n      regexp,\n      decoration,\n      decorate,\n      boundary,\n      maxLength = 1000\n    } = config;\n    if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n    this.regexp = regexp;\n    if (decorate) {\n      this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);\n    } else if (typeof decoration == \"function\") {\n      this.addMatch = (match, view, from, add) => {\n        let deco = decoration(match, view, from);\n        if (deco) add(from, from + match[0].length, deco);\n      };\n    } else if (decoration) {\n      this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);\n    } else {\n      throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n    }\n    this.boundary = boundary;\n    this.maxLength = maxLength;\n  }\n  /**\n  Compute the full set of decorations for matches in the given\n  view's viewport. You'll want to call this when initializing your\n  plugin.\n  */\n  createDeco(view) {\n    let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(),\n      add = build.add.bind(build);\n    for (let {\n      from,\n      to\n    } of matchRanges(view, this.maxLength)) iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));\n    return build.finish();\n  }\n  /**\n  Update a set of decorations for a view update. `deco` _must_ be\n  the set of decorations produced by _this_ `MatchDecorator` for\n  the view state before the update.\n  */\n  updateDeco(update, deco) {\n    let changeFrom = 1e9,\n      changeTo = -1;\n    if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {\n      if (to > update.view.viewport.from && from < update.view.viewport.to) {\n        changeFrom = Math.min(from, changeFrom);\n        changeTo = Math.max(to, changeTo);\n      }\n    });\n    if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n    if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n    return deco;\n  }\n  updateRange(view, deco, updateFrom, updateTo) {\n    for (let r of view.visibleRanges) {\n      let from = Math.max(r.from, updateFrom),\n        to = Math.min(r.to, updateTo);\n      if (to > from) {\n        let fromLine = view.state.doc.lineAt(from),\n          toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n        let start = Math.max(r.from, fromLine.from),\n          end = Math.min(r.to, toLine.to);\n        if (this.boundary) {\n          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n            start = from;\n            break;\n          }\n          for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {\n            end = to;\n            break;\n          }\n        }\n        let ranges = [],\n          m;\n        let add = (from, to, deco) => ranges.push(deco.range(from, to));\n        if (fromLine == toLine) {\n          this.regexp.lastIndex = start - fromLine.from;\n          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) this.addMatch(m, view, m.index + fromLine.from, add);\n        } else {\n          iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));\n        }\n        deco = deco.update({\n          filterFrom: start,\n          filterTo: end,\n          filter: (from, to) => from < start || to > end,\n          add: ranges\n        });\n      }\n    }\n    return deco;\n  }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/new RegExp(\"[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]\", UnicodeRegexpSupport);\nconst Names = {\n  0: \"null\",\n  7: \"bell\",\n  8: \"backspace\",\n  10: \"newline\",\n  11: \"vertical tab\",\n  13: \"carriage return\",\n  27: \"escape\",\n  8203: \"zero width space\",\n  8204: \"zero width non-joiner\",\n  8205: \"zero width joiner\",\n  8206: \"left-to-right mark\",\n  8207: \"right-to-left mark\",\n  8232: \"line separator\",\n  8237: \"left-to-right override\",\n  8238: \"right-to-left override\",\n  8294: \"left-to-right isolate\",\n  8295: \"right-to-left isolate\",\n  8297: \"pop directional isolate\",\n  8233: \"paragraph separator\",\n  65279: \"zero width no-break space\",\n  65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n  var _a;\n  if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n    let styles = document.body.style;\n    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n  }\n  return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n      render: null,\n      specialChars: Specials,\n      addSpecialChars: null\n    });\n    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n    return config;\n  }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/\nfunction highlightSpecialChars(\n/**\nConfiguration options.\n*/\nconfig = {}) {\n  return [specialCharConfig.of(config), specialCharPlugin()];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n  return _plugin || (_plugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.decorations = Decoration.none;\n      this.decorationCache = Object.create(null);\n      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n      this.decorations = this.decorator.createDeco(view);\n    }\n    makeDecorator(conf) {\n      return new MatchDecorator({\n        regexp: conf.specialChars,\n        decoration: (m, view, pos) => {\n          let {\n            doc\n          } = view.state;\n          let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n          if (code == 9) {\n            let line = doc.lineAt(pos);\n            let size = view.state.tabSize,\n              col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n            return Decoration.replace({\n              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n            });\n          }\n          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n            widget: new SpecialCharWidget(conf, code)\n          }));\n        },\n        boundary: conf.replaceTabs ? undefined : /[^]/\n      });\n    }\n    update(update) {\n      let conf = update.state.facet(specialCharConfig);\n      if (update.startState.facet(specialCharConfig) != conf) {\n        this.decorator = this.makeDecorator(conf);\n        this.decorations = this.decorator.createDeco(update.view);\n      } else {\n        this.decorations = this.decorator.updateDeco(update, this.decorations);\n      }\n    }\n  }, {\n    decorations: v => v.decorations\n  }));\n}\nconst DefaultPlaceholder = \"\\u2022\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n  if (code >= 32) return DefaultPlaceholder;\n  if (code == 10) return \"\\u2424\";\n  return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n  constructor(options, code) {\n    super();\n    this.options = options;\n    this.code = code;\n  }\n  eq(other) {\n    return other.code == this.code;\n  }\n  toDOM(view) {\n    let ph = placeholder$1(this.code);\n    let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n    let custom = this.options.render && this.options.render(this.code, desc, ph);\n    if (custom) return custom;\n    let span = document.createElement(\"span\");\n    span.textContent = ph;\n    span.title = desc;\n    span.setAttribute(\"aria-label\", desc);\n    span.className = \"cm-specialChar\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nclass TabWidget extends WidgetType {\n  constructor(width) {\n    super();\n    this.width = width;\n  }\n  eq(other) {\n    return other.width == this.width;\n  }\n  toDOM() {\n    let span = document.createElement(\"span\");\n    span.textContent = \"\\t\";\n    span.className = \"cm-tab\";\n    span.style.width = this.width + \"px\";\n    return span;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\nconst plugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor() {\n    this.height = 1000;\n    this.attrs = {\n      style: \"padding-bottom: 1000px\"\n    };\n  }\n  update(update) {\n    let {\n      view\n    } = update;\n    let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;\n    if (height >= 0 && height != this.height) {\n      this.height = height;\n      this.attrs = {\n        style: `padding-bottom: ${height}px`\n      };\n    }\n  }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/\nfunction scrollPastEnd() {\n  return [plugin, contentAttributes.of(view => {\n    var _a;\n    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n  })];\n}\n\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/\nfunction highlightActiveLine() {\n  return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/Decoration.line({\n  class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n  update(update) {\n    if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n  }\n  getDeco(view) {\n    let lastLineStart = -1,\n      deco = [];\n    for (let r of view.state.selection.ranges) {\n      let line = view.lineBlockAt(r.head);\n      if (line.from > lastLineStart) {\n        deco.push(lineDeco.range(line.from));\n        lastLineStart = line.from;\n      }\n    }\n    return Decoration.set(deco);\n  }\n}, {\n  decorations: v => v.decorations\n});\nclass Placeholder extends WidgetType {\n  constructor(content) {\n    super();\n    this.content = content;\n  }\n  toDOM() {\n    let wrap = document.createElement(\"span\");\n    wrap.className = \"cm-placeholder\";\n    wrap.style.pointerEvents = \"none\";\n    wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n    if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);else wrap.setAttribute(\"aria-hidden\", \"true\");\n    return wrap;\n  }\n  coordsAt(dom) {\n    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n    if (!rects.length) return null;\n    let style = window.getComputedStyle(dom.parentNode);\n    let rect = flattenRect(rects[0], style.direction != \"rtl\");\n    let lineHeight = parseInt(style.lineHeight);\n    if (rect.bottom - rect.top > lineHeight * 1.5) return {\n      left: rect.left,\n      right: rect.right,\n      top: rect.top,\n      bottom: rect.top + lineHeight\n    };\n    return rect;\n  }\n  ignoreEvent() {\n    return false;\n  }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/\nfunction placeholder(content) {\n  return ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.placeholder = content ? Decoration.set([Decoration.widget({\n        widget: new Placeholder(content),\n        side: 1\n      }).range(0)]) : Decoration.none;\n    }\n    get decorations() {\n      return this.view.state.doc.length ? Decoration.none : this.placeholder;\n    }\n  }, {\n    decorations: v => v.decorations\n  });\n}\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n  let startLine = Math.min(a.line, b.line),\n    endLine = Math.max(a.line, b.line);\n  let ranges = [];\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    let startOff = Math.min(a.off, b.off),\n      endOff = Math.max(a.off, b.off);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    let startCol = Math.min(a.col, b.col),\n      endCol = Math.max(a.col, b.col);\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n      if (start < 0) {\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n      } else {\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n      }\n    }\n  }\n  return ranges;\n}\nfunction absoluteColumn(view, x) {\n  let ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n  let offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  let line = view.state.doc.lineAt(offset),\n    off = offset - line.from;\n  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n  return {\n    line: line.number,\n    col,\n    off\n  };\n}\nfunction rectangleSelectionStyle(view, event) {\n  let start = getPos(view, event),\n    startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n        let newLine = update.state.doc.lineAt(newStart);\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(update.changes);\n      }\n    },\n    get(event, _extend, multiple) {\n      let cur = getPos(view, event);\n      if (!cur) return startSel;\n      let ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n    }\n  };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\nfunction rectangularSelection(options) {\n  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n  Alt: [18, e => !!e.altKey],\n  Control: [17, e => !!e.ctrlKey],\n  Shift: [16, e => !!e.shiftKey],\n  Meta: [91, e => !!e.metaKey]\n};\nconst showCrosshair = {\n  style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/\nfunction crosshairCursor(options = {}) {\n  let [code, getter] = keys[options.key || \"Alt\"];\n  let plugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.view = view;\n      this.isDown = false;\n    }\n    set(isDown) {\n      if (this.isDown != isDown) {\n        this.isDown = isDown;\n        this.view.update([]);\n      }\n    }\n  }, {\n    eventObservers: {\n      keydown(e) {\n        this.set(e.keyCode == code || getter(e));\n      },\n      keyup(e) {\n        if (e.keyCode == code || !getter(e)) this.set(false);\n      },\n      mousemove(e) {\n        this.set(getter(e));\n      }\n    }\n  });\n  return [plugin, EditorView.contentAttributes.of(view => {\n    var _a;\n    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n  })];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n  constructor(view, facet, createTooltipView, removeTooltipView) {\n    this.facet = facet;\n    this.createTooltipView = createTooltipView;\n    this.removeTooltipView = removeTooltipView;\n    this.input = view.state.facet(facet);\n    this.tooltips = this.input.filter(t => t);\n    this.tooltipViews = this.tooltips.map(createTooltipView);\n  }\n  update(update, above) {\n    var _a;\n    let input = update.state.facet(this.facet);\n    let tooltips = input.filter(x => x);\n    if (input === this.input) {\n      for (let t of this.tooltipViews) if (t.update) t.update(update);\n      return false;\n    }\n    let tooltipViews = [],\n      newAbove = above ? [] : null;\n    for (let i = 0; i < tooltips.length; i++) {\n      let tip = tooltips[i],\n        known = -1;\n      if (!tip) continue;\n      for (let i = 0; i < this.tooltips.length; i++) {\n        let other = this.tooltips[i];\n        if (other && other.create == tip.create) known = i;\n      }\n      if (known < 0) {\n        tooltipViews[i] = this.createTooltipView(tip);\n        if (newAbove) newAbove[i] = !!tip.above;\n      } else {\n        let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n        if (newAbove) newAbove[i] = above[known];\n        if (tooltipView.update) tooltipView.update(update);\n      }\n    }\n    for (let t of this.tooltipViews) if (tooltipViews.indexOf(t) < 0) {\n      this.removeTooltipView(t);\n      (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    if (above) {\n      newAbove.forEach((val, i) => above[i] = val);\n      above.length = newAbove.length;\n    }\n    this.input = input;\n    this.tooltips = tooltips;\n    this.tooltipViews = tooltipViews;\n    return true;\n  }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/\nfunction tooltips(config = {}) {\n  return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n  let {\n    win\n  } = view;\n  return {\n    top: 0,\n    left: 0,\n    bottom: win.innerHeight,\n    right: win.innerWidth\n  };\n}\nconst tooltipConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => {\n    var _a, _b, _c;\n    return {\n      position: browser.ios ? \"absolute\" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n      parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n      tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n    };\n  }\n});\nconst knownHeight = /*@__PURE__*/new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.above = [];\n    this.inView = true;\n    this.madeAbsolute = false;\n    this.lastTransaction = 0;\n    this.measureTimeout = -1;\n    let config = view.state.facet(tooltipConfig);\n    this.position = config.position;\n    this.parent = config.parent;\n    this.classes = view.themeClasses;\n    this.createContainer();\n    this.measureReq = {\n      read: this.readMeasure.bind(this),\n      write: this.writeMeasure.bind(this),\n      key: this\n    };\n    this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(() => this.measureSoon()) : null;\n    this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t), t => {\n      if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n      t.dom.remove();\n    });\n    this.above = this.manager.tooltips.map(t => !!t.above);\n    this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver(entries => {\n      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n    }, {\n      threshold: [1]\n    }) : null;\n    this.observeIntersection();\n    view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n    this.maybeMeasure();\n  }\n  createContainer() {\n    if (this.parent) {\n      this.container = document.createElement(\"div\");\n      this.container.style.position = \"relative\";\n      this.container.className = this.view.themeClasses;\n      this.parent.appendChild(this.container);\n    } else {\n      this.container = this.view.dom;\n    }\n  }\n  observeIntersection() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      for (let tooltip of this.manager.tooltipViews) this.intersectionObserver.observe(tooltip.dom);\n    }\n  }\n  measureSoon() {\n    if (this.measureTimeout < 0) this.measureTimeout = setTimeout(() => {\n      this.measureTimeout = -1;\n      this.maybeMeasure();\n    }, 50);\n  }\n  update(update) {\n    if (update.transactions.length) this.lastTransaction = Date.now();\n    let updated = this.manager.update(update, this.above);\n    if (updated) this.observeIntersection();\n    let shouldMeasure = updated || update.geometryChanged;\n    let newConfig = update.state.facet(tooltipConfig);\n    if (newConfig.position != this.position && !this.madeAbsolute) {\n      this.position = newConfig.position;\n      for (let t of this.manager.tooltipViews) t.dom.style.position = this.position;\n      shouldMeasure = true;\n    }\n    if (newConfig.parent != this.parent) {\n      if (this.parent) this.container.remove();\n      this.parent = newConfig.parent;\n      this.createContainer();\n      for (let t of this.manager.tooltipViews) this.container.appendChild(t.dom);\n      shouldMeasure = true;\n    } else if (this.parent && this.view.themeClasses != this.classes) {\n      this.classes = this.container.className = this.view.themeClasses;\n    }\n    if (shouldMeasure) this.maybeMeasure();\n  }\n  createTooltip(tooltip) {\n    let tooltipView = tooltip.create(this.view);\n    tooltipView.dom.classList.add(\"cm-tooltip\");\n    if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n      let arrow = document.createElement(\"div\");\n      arrow.className = \"cm-tooltip-arrow\";\n      tooltipView.dom.appendChild(arrow);\n    }\n    tooltipView.dom.style.position = this.position;\n    tooltipView.dom.style.top = Outside;\n    tooltipView.dom.style.left = \"0px\";\n    this.container.appendChild(tooltipView.dom);\n    if (tooltipView.mount) tooltipView.mount(this.view);\n    if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n    return tooltipView;\n  }\n  destroy() {\n    var _a, _b, _c;\n    this.view.win.removeEventListener(\"resize\", this.measureSoon);\n    for (let tooltipView of this.manager.tooltipViews) {\n      tooltipView.dom.remove();\n      (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n    }\n    if (this.parent) this.container.remove();\n    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n    clearTimeout(this.measureTimeout);\n  }\n  readMeasure() {\n    let editor = this.view.dom.getBoundingClientRect();\n    let scaleX = 1,\n      scaleY = 1,\n      makeAbsolute = false;\n    if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n      let {\n        dom\n      } = this.manager.tooltipViews[0];\n      if (browser.gecko) {\n        // Firefox sets the element's `offsetParent` to the\n        // transformed element when a transform interferes with fixed\n        // positioning.\n        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;\n      } else if (dom.style.top == Outside && dom.style.left == \"0px\") {\n        // On other browsers, we have to awkwardly try and use other\n        // information to detect a transform.\n        let rect = dom.getBoundingClientRect();\n        makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n      }\n    }\n    if (makeAbsolute || this.position == \"absolute\") {\n      if (this.parent) {\n        let rect = this.parent.getBoundingClientRect();\n        if (rect.width && rect.height) {\n          scaleX = rect.width / this.parent.offsetWidth;\n          scaleY = rect.height / this.parent.offsetHeight;\n        }\n      } else {\n        ({\n          scaleX,\n          scaleY\n        } = this.view.viewState);\n      }\n    }\n    return {\n      editor,\n      parent: this.parent ? this.container.getBoundingClientRect() : editor,\n      pos: this.manager.tooltips.map((t, i) => {\n        let tv = this.manager.tooltipViews[i];\n        return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n      }),\n      size: this.manager.tooltipViews.map(({\n        dom\n      }) => dom.getBoundingClientRect()),\n      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n      scaleX,\n      scaleY,\n      makeAbsolute\n    };\n  }\n  writeMeasure(measured) {\n    var _a;\n    if (measured.makeAbsolute) {\n      this.madeAbsolute = true;\n      this.position = \"absolute\";\n      for (let t of this.manager.tooltipViews) t.dom.style.position = \"absolute\";\n    }\n    let {\n      editor,\n      space,\n      scaleX,\n      scaleY\n    } = measured;\n    let others = [];\n    for (let i = 0; i < this.manager.tooltips.length; i++) {\n      let tooltip = this.manager.tooltips[i],\n        tView = this.manager.tooltipViews[i],\n        {\n          dom\n        } = tView;\n      let pos = measured.pos[i],\n        size = measured.size[i];\n      // Hide tooltips that are outside of the editor.\n      if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {\n        dom.style.top = Outside;\n        continue;\n      }\n      let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n      let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;\n      let width = size.right - size.left,\n        height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n      let offset = tView.offset || noOffset,\n        ltr = this.view.textDirection == Direction.LTR;\n      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);\n      let above = this.above[i];\n      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n      if (spaceVert < height && tView.resize !== false) {\n        if (spaceVert < this.view.defaultLineHeight) {\n          dom.style.top = Outside;\n          continue;\n        }\n        knownHeight.set(tView, height);\n        dom.style.height = (height = spaceVert) / scaleY + \"px\";\n      } else if (dom.style.height) {\n        dom.style.height = \"\";\n      }\n      let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n      let right = left + width;\n      if (tView.overlap !== true) for (let r of others) if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n      if (this.position == \"absolute\") {\n        dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n        dom.style.left = (left - measured.parent.left) / scaleX + \"px\";\n      } else {\n        dom.style.top = top / scaleY + \"px\";\n        dom.style.left = left / scaleX + \"px\";\n      }\n      if (arrow) {\n        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);\n        arrow.style.left = arrowLeft / scaleX + \"px\";\n      }\n      if (tView.overlap !== true) others.push({\n        left,\n        top,\n        right,\n        bottom: top + height\n      });\n      dom.classList.toggle(\"cm-tooltip-above\", above);\n      dom.classList.toggle(\"cm-tooltip-below\", !above);\n      if (tView.positioned) tView.positioned(measured.space);\n    }\n  }\n  maybeMeasure() {\n    if (this.manager.tooltips.length) {\n      if (this.view.inView) this.view.requestMeasure(this.measureReq);\n      if (this.inView != this.view.inView) {\n        this.inView = this.view.inView;\n        if (!this.inView) for (let tv of this.manager.tooltipViews) tv.dom.style.top = Outside;\n      }\n    }\n  }\n}, {\n  eventObservers: {\n    scroll() {\n      this.maybeMeasure();\n    }\n  }\n});\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-tooltip\": {\n    zIndex: 100,\n    boxSizing: \"border-box\"\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #bbb\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&light .cm-tooltip-section:not(:first-child)\": {\n    borderTop: \"1px solid #bbb\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tooltip-arrow\": {\n    height: `${7 /* Arrow.Size */}px`,\n    width: `${7 /* Arrow.Size */ * 2}px`,\n    position: \"absolute\",\n    zIndex: -1,\n    overflow: \"hidden\",\n    \"&:before, &:after\": {\n      content: \"''\",\n      position: \"absolute\",\n      width: 0,\n      height: 0,\n      borderLeft: `${7 /* Arrow.Size */}px solid transparent`,\n      borderRight: `${7 /* Arrow.Size */}px solid transparent`\n    },\n    \".cm-tooltip-above &\": {\n      bottom: `-${7 /* Arrow.Size */}px`,\n      \"&:before\": {\n        borderTop: `${7 /* Arrow.Size */}px solid #bbb`\n      },\n      \"&:after\": {\n        borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n        bottom: \"1px\"\n      }\n    },\n    \".cm-tooltip-below &\": {\n      top: `-${7 /* Arrow.Size */}px`,\n      \"&:before\": {\n        borderBottom: `${7 /* Arrow.Size */}px solid #bbb`\n      },\n      \"&:after\": {\n        borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,\n        top: \"1px\"\n      }\n    }\n  },\n  \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n    \"&:before\": {\n      borderTopColor: \"#333338\",\n      borderBottomColor: \"#333338\"\n    },\n    \"&:after\": {\n      borderTopColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    }\n  }\n});\nconst noOffset = {\n  x: 0,\n  y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/\nconst showTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: [tooltipPlugin, baseTheme]\n});\nconst showHoverTooltip = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass HoverTooltipHost {\n  // Needs to be static so that host tooltip instances always match\n  static create(view) {\n    return new HoverTooltipHost(view);\n  }\n  constructor(view) {\n    this.view = view;\n    this.mounted = false;\n    this.dom = document.createElement(\"div\");\n    this.dom.classList.add(\"cm-tooltip-hover\");\n    this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t), t => t.dom.remove());\n  }\n  createHostedView(tooltip) {\n    let hostedView = tooltip.create(this.view);\n    hostedView.dom.classList.add(\"cm-tooltip-section\");\n    this.dom.appendChild(hostedView.dom);\n    if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n    return hostedView;\n  }\n  mount(view) {\n    for (let hostedView of this.manager.tooltipViews) {\n      if (hostedView.mount) hostedView.mount(view);\n    }\n    this.mounted = true;\n  }\n  positioned(space) {\n    for (let hostedView of this.manager.tooltipViews) {\n      if (hostedView.positioned) hostedView.positioned(space);\n    }\n  }\n  update(update) {\n    this.manager.update(update);\n  }\n  destroy() {\n    var _a;\n    for (let t of this.manager.tooltipViews) (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n  }\n  passProp(name) {\n    let value = undefined;\n    for (let view of this.manager.tooltipViews) {\n      let given = view[name];\n      if (given !== undefined) {\n        if (value === undefined) value = given;else if (value !== given) return undefined;\n      }\n    }\n    return value;\n  }\n  get offset() {\n    return this.passProp(\"offset\");\n  }\n  get getCoords() {\n    return this.passProp(\"getCoords\");\n  }\n  get overlap() {\n    return this.passProp(\"overlap\");\n  }\n  get resize() {\n    return this.passProp(\"resize\");\n  }\n}\nconst showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {\n  let tooltips = state.facet(showHoverTooltip).filter(t => t);\n  if (tooltips.length === 0) return null;\n  return {\n    pos: Math.min(...tooltips.map(t => t.pos)),\n    end: Math.max(...tooltips.map(t => {\n      var _a;\n      return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n    })),\n    create: HoverTooltipHost.create,\n    above: tooltips[0].above,\n    arrow: tooltips.some(t => t.arrow)\n  };\n});\nclass HoverPlugin {\n  constructor(view, source, field, setHover, hoverTime) {\n    this.view = view;\n    this.source = source;\n    this.field = field;\n    this.setHover = setHover;\n    this.hoverTime = hoverTime;\n    this.hoverTimeout = -1;\n    this.restartTimeout = -1;\n    this.pending = null;\n    this.lastMove = {\n      x: 0,\n      y: 0,\n      target: view.dom,\n      time: 0\n    };\n    this.checkHover = this.checkHover.bind(this);\n    view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n    view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n  }\n  update() {\n    if (this.pending) {\n      this.pending = null;\n      clearTimeout(this.restartTimeout);\n      this.restartTimeout = setTimeout(() => this.startHover(), 20);\n    }\n  }\n  get active() {\n    return this.view.state.field(this.field);\n  }\n  checkHover() {\n    this.hoverTimeout = -1;\n    if (this.active) return;\n    let hovered = Date.now() - this.lastMove.time;\n    if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();\n  }\n  startHover() {\n    clearTimeout(this.restartTimeout);\n    let {\n      view,\n      lastMove\n    } = this;\n    let desc = view.docView.nearest(lastMove.target);\n    if (!desc) return;\n    let pos,\n      side = 1;\n    if (desc instanceof WidgetView) {\n      pos = desc.posAtStart;\n    } else {\n      pos = view.posAtCoords(lastMove);\n      if (pos == null) return;\n      let posCoords = view.coordsAtPos(pos);\n      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n      side = lastMove.x < posCoords.left ? -rtl : rtl;\n    }\n    let open = this.source(view, pos, side);\n    if (open === null || open === void 0 ? void 0 : open.then) {\n      let pending = this.pending = {\n        pos\n      };\n      open.then(result => {\n        if (this.pending == pending) {\n          this.pending = null;\n          if (result) view.dispatch({\n            effects: this.setHover.of(result)\n          });\n        }\n      }, e => logException(view.state, e, \"hover tooltip\"));\n    } else if (open) {\n      view.dispatch({\n        effects: this.setHover.of(open)\n      });\n    }\n  }\n  get tooltip() {\n    let plugin = this.view.plugin(tooltipPlugin);\n    let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;\n    return index > -1 ? plugin.manager.tooltipViews[index] : null;\n  }\n  mousemove(event) {\n    var _a;\n    this.lastMove = {\n      x: event.clientX,\n      y: event.clientY,\n      target: event.target,\n      time: Date.now()\n    };\n    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n    let {\n      active,\n      tooltip\n    } = this;\n    if (active && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n      let {\n          pos\n        } = active || this.pending,\n        end = (_a = active === null || active === void 0 ? void 0 : active.end) !== null && _a !== void 0 ? _a : pos;\n      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n        this.view.dispatch({\n          effects: this.setHover.of(null)\n        });\n        this.pending = null;\n      }\n    }\n  }\n  mouseleave(event) {\n    clearTimeout(this.hoverTimeout);\n    this.hoverTimeout = -1;\n    let {\n      active\n    } = this;\n    if (active) {\n      let {\n        tooltip\n      } = this;\n      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n      if (!inTooltip) this.view.dispatch({\n        effects: this.setHover.of(null)\n      });else this.watchTooltipLeave(tooltip.dom);\n    }\n  }\n  watchTooltipLeave(tooltip) {\n    let watch = event => {\n      tooltip.removeEventListener(\"mouseleave\", watch);\n      if (this.active && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n        effects: this.setHover.of(null)\n      });\n    };\n    tooltip.addEventListener(\"mouseleave\", watch);\n  }\n  destroy() {\n    clearTimeout(this.hoverTimeout);\n    this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n    this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n  }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n  let rect = tooltip.getBoundingClientRect();\n  return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n  let rect = view.scrollDOM.getBoundingClientRect();\n  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n  let pos = view.posAtCoords({\n    x,\n    y\n  }, false);\n  return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/\nfunction hoverTooltip(source, options = {}) {\n  let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n  let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create() {\n      return null;\n    },\n    update(value, tr) {\n      if (value && (options.hideOnChange && (tr.docChanged || tr.selection) || options.hideOn && options.hideOn(tr, value))) return null;\n      if (value && tr.docChanged) {\n        let newPos = tr.changes.mapPos(value.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n        if (newPos == null) return null;\n        let copy = Object.assign(Object.create(null), value);\n        copy.pos = newPos;\n        if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n        value = copy;\n      }\n      for (let effect of tr.effects) {\n        if (effect.is(setHover)) value = effect.value;\n        if (effect.is(closeHoverTooltipEffect)) value = null;\n      }\n      return value;\n    },\n    provide: f => showHoverTooltip.from(f)\n  });\n  return [hoverState, ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)), showHoverTooltipHost];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/\nfunction getTooltip(view, tooltip) {\n  let plugin = view.plugin(tooltipPlugin);\n  if (!plugin) return null;\n  let found = plugin.manager.tooltips.indexOf(tooltip);\n  return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/\nfunction hasHoverTooltips(state) {\n  return state.facet(showHoverTooltip).some(x => x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/\nconst closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/\nfunction repositionTooltips(view) {\n  let plugin = view.plugin(tooltipPlugin);\n  if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(configs) {\n    let topContainer, bottomContainer;\n    for (let c of configs) {\n      topContainer = topContainer || c.topContainer;\n      bottomContainer = bottomContainer || c.bottomContainer;\n    }\n    return {\n      topContainer,\n      bottomContainer\n    };\n  }\n});\n/**\nConfigures the panel-managing extension.\n*/\nfunction panels(config) {\n  return config ? [panelConfig.of(config)] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/\nfunction getPanel(view, panel) {\n  let plugin = view.plugin(panelPlugin);\n  let index = plugin ? plugin.specs.indexOf(panel) : -1;\n  return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.input = view.state.facet(showPanel);\n    this.specs = this.input.filter(s => s);\n    this.panels = this.specs.map(spec => spec(view));\n    let conf = view.state.facet(panelConfig);\n    this.top = new PanelGroup(view, true, conf.topContainer);\n    this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n    this.top.sync(this.panels.filter(p => p.top));\n    this.bottom.sync(this.panels.filter(p => !p.top));\n    for (let p of this.panels) {\n      p.dom.classList.add(\"cm-panel\");\n      if (p.mount) p.mount();\n    }\n  }\n  update(update) {\n    let conf = update.state.facet(panelConfig);\n    if (this.top.container != conf.topContainer) {\n      this.top.sync([]);\n      this.top = new PanelGroup(update.view, true, conf.topContainer);\n    }\n    if (this.bottom.container != conf.bottomContainer) {\n      this.bottom.sync([]);\n      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n    }\n    this.top.syncClasses();\n    this.bottom.syncClasses();\n    let input = update.state.facet(showPanel);\n    if (input != this.input) {\n      let specs = input.filter(x => x);\n      let panels = [],\n        top = [],\n        bottom = [],\n        mount = [];\n      for (let spec of specs) {\n        let known = this.specs.indexOf(spec),\n          panel;\n        if (known < 0) {\n          panel = spec(update.view);\n          mount.push(panel);\n        } else {\n          panel = this.panels[known];\n          if (panel.update) panel.update(update);\n        }\n        panels.push(panel);\n        (panel.top ? top : bottom).push(panel);\n      }\n      this.specs = specs;\n      this.panels = panels;\n      this.top.sync(top);\n      this.bottom.sync(bottom);\n      for (let p of mount) {\n        p.dom.classList.add(\"cm-panel\");\n        if (p.mount) p.mount();\n      }\n    } else {\n      for (let p of this.panels) if (p.update) p.update(update);\n    }\n  }\n  destroy() {\n    this.top.sync([]);\n    this.bottom.sync([]);\n  }\n}, {\n  provide: plugin => EditorView.scrollMargins.of(view => {\n    let value = view.plugin(plugin);\n    return value && {\n      top: value.top.scrollMargin(),\n      bottom: value.bottom.scrollMargin()\n    };\n  })\n});\nclass PanelGroup {\n  constructor(view, top, container) {\n    this.view = view;\n    this.top = top;\n    this.container = container;\n    this.dom = undefined;\n    this.classes = \"\";\n    this.panels = [];\n    this.syncClasses();\n  }\n  sync(panels) {\n    for (let p of this.panels) if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n    this.panels = panels;\n    this.syncDOM();\n  }\n  syncDOM() {\n    if (this.panels.length == 0) {\n      if (this.dom) {\n        this.dom.remove();\n        this.dom = undefined;\n      }\n      return;\n    }\n    if (!this.dom) {\n      this.dom = document.createElement(\"div\");\n      this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n      this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n      let parent = this.container || this.view.dom;\n      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n    }\n    let curDOM = this.dom.firstChild;\n    for (let panel of this.panels) {\n      if (panel.dom.parentNode == this.dom) {\n        while (curDOM != panel.dom) curDOM = rm(curDOM);\n        curDOM = curDOM.nextSibling;\n      } else {\n        this.dom.insertBefore(panel.dom, curDOM);\n      }\n    }\n    while (curDOM) curDOM = rm(curDOM);\n  }\n  scrollMargin() {\n    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n  }\n  syncClasses() {\n    if (!this.container || this.classes == this.view.themeClasses) return;\n    for (let cls of this.classes.split(\" \")) if (cls) this.container.classList.remove(cls);\n    for (let cls of (this.classes = this.view.themeClasses).split(\" \")) if (cls) this.container.classList.add(cls);\n  }\n}\nfunction rm(node) {\n  let next = node.nextSibling;\n  node.remove();\n  return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/\nconst showPanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  enables: panelPlugin\n});\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\nclass GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  Compare this marker to another marker of the same type.\n  */\n  eq(other) {\n    return false;\n  }\n  /**\n  Called if the marker has a `toDOM` method and its representation\n  was removed from a gutter.\n  */\n  destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\nconst gutterLineClass = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n  class: \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: () => _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n  lineMarker: () => null,\n  widgetMarker: () => null,\n  lineMarkerChange: null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst unfixGutters = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\nfunction gutters(config) {\n  let result = [gutterView];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.prevViewport = view.viewport;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);\n    this.fixed = !view.state.facet(unfixGutters);\n    if (this.fixed) {\n      // FIXME IE11 fallback, which doesn't support position: sticky,\n      // by using position: relative + event handlers that realign the\n      // gutter (or just force fixed=false on IE11?)\n      this.dom.style.position = \"sticky\";\n    }\n    this.syncGutters(false);\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n  update(update) {\n    if (this.updateGutters(update)) {\n      // Detach during sync when the viewport changed significantly\n      // (such as during scrolling), since for large updates that is\n      // faster.\n      let vpA = this.prevViewport,\n        vpB = update.view.viewport;\n      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n    }\n    if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    if (this.view.state.facet(unfixGutters) != !this.fixed) {\n      this.fixed = !this.fixed;\n      this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n    }\n    this.prevViewport = update.view.viewport;\n  }\n  syncGutters(detach) {\n    let after = this.dom.nextSibling;\n    if (detach) this.dom.remove();\n    let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n    let classSet = [];\n    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n    for (let line of this.view.viewportLineBlocks) {\n      if (classSet.length) classSet = [];\n      if (Array.isArray(line.type)) {\n        let first = true;\n        for (let b of line.type) {\n          if (b.type == BlockType.Text && first) {\n            advanceCursor(lineClasses, classSet, b.from);\n            for (let cx of contexts) cx.line(this.view, b, classSet);\n            first = false;\n          } else if (b.widget) {\n            for (let cx of contexts) cx.widget(this.view, b);\n          }\n        }\n      } else if (line.type == BlockType.Text) {\n        advanceCursor(lineClasses, classSet, line.from);\n        for (let cx of contexts) cx.line(this.view, line, classSet);\n      } else if (line.widget) {\n        for (let cx of contexts) cx.widget(this.view, line);\n      }\n    }\n    for (let cx of contexts) cx.finish();\n    if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n  }\n  updateGutters(update) {\n    let prev = update.startState.facet(activeGutters),\n      cur = update.state.facet(activeGutters);\n    let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n    if (prev == cur) {\n      for (let gutter of this.gutters) if (gutter.update(update)) change = true;\n    } else {\n      change = true;\n      let gutters = [];\n      for (let conf of cur) {\n        let known = prev.indexOf(conf);\n        if (known < 0) {\n          gutters.push(new SingleGutterView(this.view, conf));\n        } else {\n          this.gutters[known].update(update);\n          gutters.push(this.gutters[known]);\n        }\n      }\n      for (let g of this.gutters) {\n        g.dom.remove();\n        if (gutters.indexOf(g) < 0) g.destroy();\n      }\n      for (let g of gutters) this.dom.appendChild(g.dom);\n      this.gutters = gutters;\n    }\n    return change;\n  }\n  destroy() {\n    for (let view of this.gutters) view.destroy();\n    this.dom.remove();\n  }\n}, {\n  provide: plugin => EditorView.scrollMargins.of(view => {\n    let value = view.plugin(plugin);\n    if (!value || value.gutters.length == 0 || !value.fixed) return null;\n    return view.textDirection == Direction.LTR ? {\n      left: value.dom.offsetWidth * view.scaleX\n    } : {\n      right: value.dom.offsetWidth * view.scaleX\n    };\n  })\n});\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\nfunction advanceCursor(cursor, collect, pos) {\n  while (cursor.value && cursor.from <= pos) {\n    if (cursor.from == pos) collect.push(cursor.value);\n    cursor.next();\n  }\n}\nclass UpdateContext {\n  constructor(gutter, viewport, height) {\n    this.gutter = gutter;\n    this.height = height;\n    this.i = 0;\n    this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n  }\n  addElement(view, block, markers) {\n    let {\n        gutter\n      } = this,\n      above = (block.top - this.height) / view.scaleY,\n      height = block.height / view.scaleY;\n    if (this.i == gutter.elements.length) {\n      let newElt = new GutterElement(view, height, above, markers);\n      gutter.elements.push(newElt);\n      gutter.dom.appendChild(newElt.dom);\n    } else {\n      gutter.elements[this.i].update(view, height, above, markers);\n    }\n    this.height = block.bottom;\n    this.i++;\n  }\n  line(view, line, extraMarkers) {\n    let localMarkers = [];\n    advanceCursor(this.cursor, localMarkers, line.from);\n    if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n    if (forLine) localMarkers.unshift(forLine);\n    let gutter = this.gutter;\n    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n    this.addElement(view, line, localMarkers);\n  }\n  widget(view, block) {\n    let marker = this.gutter.config.widgetMarker(view, block.widget, block);\n    if (marker) this.addElement(view, block, [marker]);\n  }\n  finish() {\n    let gutter = this.gutter;\n    while (gutter.elements.length > this.i) {\n      let last = gutter.elements.pop();\n      gutter.dom.removeChild(last.dom);\n      last.destroy();\n    }\n  }\n}\nclass SingleGutterView {\n  constructor(view, config) {\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n    for (let prop in config.domEventHandlers) {\n      this.dom.addEventListener(prop, event => {\n        let target = event.target,\n          y;\n        if (target != this.dom && this.dom.contains(target)) {\n          while (target.parentNode != this.dom) target = target.parentNode;\n          let rect = target.getBoundingClientRect();\n          y = (rect.top + rect.bottom) / 2;\n        } else {\n          y = event.clientY;\n        }\n        let line = view.lineBlockAtHeight(y - view.documentTop);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    }\n    this.markers = asArray(config.markers(view));\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n  update(update) {\n    let prevMarkers = this.markers;\n    this.markers = asArray(this.config.markers(update.view));\n    if (this.spacer && this.config.updateSpacer) {\n      let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);\n    }\n    let vp = update.view.viewport;\n    return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n  }\n  destroy() {\n    for (let elt of this.elements) elt.destroy();\n  }\n}\nclass GutterElement {\n  constructor(view, height, above, markers) {\n    this.height = -1;\n    this.above = 0;\n    this.markers = [];\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutterElement\";\n    this.update(view, height, above, markers);\n  }\n  update(view, height, above, markers) {\n    if (this.height != height) {\n      this.height = height;\n      this.dom.style.height = height + \"px\";\n    }\n    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n  }\n  setMarkers(view, markers) {\n    let cls = \"cm-gutterElement\",\n      domPos = this.dom.firstChild;\n    for (let iNew = 0, iOld = 0;;) {\n      let skipTo = iOld,\n        marker = iNew < markers.length ? markers[iNew++] : null,\n        matched = false;\n      if (marker) {\n        let c = marker.elementClass;\n        if (c) cls += \" \" + c;\n        for (let i = iOld; i < this.markers.length; i++) if (this.markers[i].compare(marker)) {\n          skipTo = i;\n          matched = true;\n          break;\n        }\n      } else {\n        skipTo = this.markers.length;\n      }\n      while (iOld < skipTo) {\n        let next = this.markers[iOld++];\n        if (next.toDOM) {\n          next.destroy(domPos);\n          let after = domPos.nextSibling;\n          domPos.remove();\n          domPos = after;\n        }\n      }\n      if (!marker) break;\n      if (marker.toDOM) {\n        if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);\n      }\n      if (matched) iOld++;\n    }\n    this.dom.className = cls;\n    this.markers = markers;\n  }\n  destroy() {\n    this.setMarkers(null, []); // First argument not used unless creating markers\n  }\n}\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;\n  return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\nconst lineNumberMarkers = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n  combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers(a, b) {\n        let result = Object.assign({}, a);\n        for (let event in b) {\n          let exists = result[event],\n            add = b[event];\n          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n        }\n        return result;\n      }\n    });\n  }\n});\nclass NumberMarker extends GutterMarker {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n  eq(other) {\n    return this.number == other.number;\n  }\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n}\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n  class: \"cm-lineNumbers\",\n  renderEmptyElements: false,\n  markers(view) {\n    return view.state.facet(lineNumberMarkers);\n  },\n  lineMarker(view, line, others) {\n    if (others.some(m => m.toDOM)) return null;\n    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n  },\n  widgetMarker: () => null,\n  lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n  initialSpacer(view) {\n    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n  },\n  updateSpacer(spacer, update) {\n    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n    return max == spacer.number ? spacer : new NumberMarker(max);\n  },\n  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\nfunction lineNumbers(config = {}) {\n  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];\n}\nfunction maxLineNumber(lines) {\n  let last = 9;\n  while (last < lines) last = last * 10 + 9;\n  return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n  constructor() {\n    super(...arguments);\n    this.elementClass = \"cm-activeLineGutter\";\n  }\n}();\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n  let marks = [],\n    last = -1;\n  for (let range of state.selection.ranges) {\n    let linePos = state.doc.lineAt(range.head).from;\n    if (linePos > last) {\n      last = linePos;\n      marks.push(activeLineGutterMarker.range(linePos));\n    }\n  }\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\nfunction highlightActiveLineGutter() {\n  return activeLineGutterHighlighter;\n}\nconst WhitespaceDeco = /*@__PURE__*/new Map();\nfunction getWhitespaceDeco(space) {\n  let deco = WhitespaceDeco.get(space);\n  if (!deco) WhitespaceDeco.set(space, deco = Decoration.mark({\n    attributes: space === \"\\t\" ? {\n      class: \"cm-highlightTab\"\n    } : {\n      class: \"cm-highlightSpace\",\n      \"data-display\": space.replace(/ /g, \"·\")\n    }\n  }));\n  return deco;\n}\nfunction matcher(decorator) {\n  return ViewPlugin.define(view => ({\n    decorations: decorator.createDeco(view),\n    update(u) {\n      this.decorations = decorator.updateDeco(u, this.decorations);\n    }\n  }), {\n    decorations: v => v.decorations\n  });\n}\nconst whitespaceHighlighter = /*@__PURE__*/matcher( /*@__PURE__*/new MatchDecorator({\n  regexp: /\\t| +/g,\n  decoration: match => getWhitespaceDeco(match[0]),\n  boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/\nfunction highlightWhitespace() {\n  return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/matcher( /*@__PURE__*/new MatchDecorator({\n  regexp: /\\s+$/g,\n  decoration: /*@__PURE__*/Decoration.mark({\n    class: \"cm-trailingSpace\"\n  }),\n  boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/\nfunction highlightTrailingWhitespace() {\n  return trailingHighlighter;\n}\n\n/**\n@internal\n*/\nconst __test = {\n  HeightMap,\n  HeightOracle,\n  MeasuredHeights,\n  QueryType,\n  ChangedRange,\n  computeOrder,\n  moveVisually\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUlBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzPzg3YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dCwgUmFuZ2VTZXQsIE1hcE1vZGUsIFJhbmdlVmFsdWUsIGZpbmRDbHVzdGVyQnJlYWssIEVkaXRvclNlbGVjdGlvbiwgRmFjZXQsIFN0YXRlRWZmZWN0LCBDaGFuZ2VTZXQsIGZpbmRDb2x1bW4sIENoYXJDYXRlZ29yeSwgQW5ub3RhdGlvbiwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uLCBQcmVjLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgUmFuZ2VTZXRCdWlsZGVyLCBjb3VudENvbHVtbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFN0eWxlTW9kdWxlIH0gZnJvbSAnc3R5bGUtbW9kJztcbmltcG9ydCB7IGtleU5hbWUsIGJhc2UsIHNoaWZ0IH0gZnJvbSAndzNjLWtleW5hbWUnO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20gPT0gbm9kZSB8fCBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBoYXNTZWxlY3Rpb24oZG9tLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIXNlbGVjdGlvbi5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBjb250YWlucyhkb20sIHNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3RzRm9yKGRvbSkge1xuICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHRleHRSYW5nZShkb20sIDAsIGRvbS5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICByZXR1cm4gZG9tLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gW107XG59XG4vLyBTY2FucyBmb3J3YXJkIGFuZCBiYWNrd2FyZCB0aHJvdWdoIERPTSBwb3NpdGlvbnMgZXF1aXZhbGVudCB0byB0aGVcbi8vIGdpdmVuIG9uZSB0byBzZWUgaWYgdGhlIHR3byBhcmUgaW4gdGhlIHNhbWUgcGxhY2UgKGkuZS4gYWZ0ZXIgYVxuLy8gdGV4dCBub2RlIHZzIGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUpXG5mdW5jdGlvbiBpc0VxdWl2YWxlbnRQb3NpdGlvbihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZikge1xuICAgIHJldHVybiB0YXJnZXROb2RlID8gKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRvbUluZGV4KG5vZGUpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7OyBpbmRleCsrKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogd2luLmlubmVyV2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiB3aW4uaW5uZXJIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldFNjYWxlKGVsdCwgcmVjdCkge1xuICAgIGxldCBzY2FsZVggPSByZWN0LndpZHRoIC8gZWx0Lm9mZnNldFdpZHRoO1xuICAgIGxldCBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsdC5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNjYWxlWCA+IDAuOTk1ICYmIHNjYWxlWCA8IDEuMDA1IHx8ICFpc0Zpbml0ZShzY2FsZVgpIHx8IE1hdGguYWJzKHJlY3Qud2lkdGggLSBlbHQub2Zmc2V0V2lkdGgpIDwgMSlcbiAgICAgICAgc2NhbGVYID0gMTtcbiAgICBpZiAoc2NhbGVZID4gMC45OTUgJiYgc2NhbGVZIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWSkgfHwgTWF0aC5hYnMocmVjdC5oZWlnaHQgLSBlbHQub2Zmc2V0SGVpZ2h0KSA8IDEpXG4gICAgICAgIHNjYWxlWSA9IDE7XG4gICAgcmV0dXJuIHsgc2NhbGVYLCBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyhkb20sIHJlY3QsIHNpZGUsIHgsIHksIHhNYXJnaW4sIHlNYXJnaW4sIGx0cikge1xuICAgIGxldCBkb2MgPSBkb20ub3duZXJEb2N1bWVudCwgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICBmb3IgKGxldCBjdXIgPSBkb20sIHN0b3AgPSBmYWxzZTsgY3VyICYmICFzdG9wOykge1xuICAgICAgICBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHsgLy8gRWxlbWVudFxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nLCB0b3AgPSBjdXIgPT0gZG9jLmJvZHk7XG4gICAgICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKGN1cikucG9zaXRpb24pKVxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA8PSBjdXIuY2xpZW50SGVpZ2h0ICYmIGN1ci5zY3JvbGxXaWR0aCA8PSBjdXIuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShjdXIsIHJlY3QpKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0ICsgY3VyLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgY3VyLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICAgICAgaWYgKHkgPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSAtKGJvdW5kaW5nLnRvcCAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIG1vdmVZICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIGJvdW5kaW5nLmJvdHRvbSArIHlNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiAocmVjdC50b3AgLSBtb3ZlWSkgPCBib3VuZGluZy50b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wICsgbW92ZVkgLSByZWN0LnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByZWN0SGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCwgYm91bmRpbmdIZWlnaHQgPSBib3VuZGluZy5ib3R0b20gLSBib3VuZGluZy50b3A7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFRvcCA9IHkgPT0gXCJjZW50ZXJcIiAmJiByZWN0SGVpZ2h0IDw9IGJvdW5kaW5nSGVpZ2h0ID8gcmVjdC50b3AgKyByZWN0SGVpZ2h0IC8gMiAtIGJvdW5kaW5nSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgICAgICAgIHkgPT0gXCJzdGFydFwiIHx8IHkgPT0gXCJjZW50ZXJcIiAmJiBzaWRlIDwgMCA/IHJlY3QudG9wIC0geU1hcmdpbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LmJvdHRvbSAtIGJvdW5kaW5nSGVpZ2h0ICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWSA9IHRhcmdldFRvcCAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID09IFwibmVhcmVzdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZVggPSAtKGJvdW5kaW5nLmxlZnQgLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCArIG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBtb3ZlWCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlIDwgMCAmJiByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCArIG1vdmVYIC0gcmVjdC5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExlZnQgPSB4ID09IFwiY2VudGVyXCIgPyByZWN0LmxlZnQgKyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAyIC0gKGJvdW5kaW5nLnJpZ2h0IC0gYm91bmRpbmcubGVmdCkgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHggPT0gXCJzdGFydFwiKSA9PSBsdHIgPyByZWN0LmxlZnQgLSB4TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QucmlnaHQgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSArIHhNYXJnaW47XG4gICAgICAgICAgICAgICAgbW92ZVggPSB0YXJnZXRMZWZ0IC0gYm91bmRpbmcubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW92ZWRYID0gMCwgbW92ZWRZID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbFRvcCArPSBtb3ZlWSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWSA9IChjdXIuc2Nyb2xsVG9wIC0gc3RhcnQpICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsTGVmdCArPSBtb3ZlWCAvIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkWCA9IChjdXIuc2Nyb2xsTGVmdCAtIHN0YXJ0KSAqIHNjYWxlWDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBtb3ZlZFgsIHRvcDogcmVjdC50b3AgLSBtb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCAtIG1vdmVkWCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIG1vdmVkWSB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZWRYICYmIE1hdGguYWJzKG1vdmVkWCAtIG1vdmVYKSA8IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXCJuZWFyZXN0XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFkgJiYgTWF0aC5hYnMobW92ZWRZIC0gbW92ZVkpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY3VyID0gY3VyLmFzc2lnbmVkU2xvdCB8fCBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNjcm9sbGFibGVQYXJlbnQoZG9tKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gZG9jLmJvZHkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQgfHwgY3VyLnNjcm9sbFdpZHRoID4gY3VyLmNsaWVudFdpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBhbmNob3JOb2RlLCBmb2N1c05vZGUgfSA9IHJhbmdlO1xuICAgICAgICAvLyBDbGlwIG9mZnNldHMgdG8gbm9kZSBzaXplIHRvIGF2b2lkIGNyYXNoZXMgd2hlbiBTYWZhcmkgcmVwb3J0cyBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICAgICAgdGhpcy5zZXQoYW5jaG9yTm9kZSwgTWF0aC5taW4ocmFuZ2UuYW5jaG9yT2Zmc2V0LCBhbmNob3JOb2RlID8gbWF4T2Zmc2V0KGFuY2hvck5vZGUpIDogMCksIGZvY3VzTm9kZSwgTWF0aC5taW4ocmFuZ2UuZm9jdXNPZmZzZXQsIGZvY3VzTm9kZSA/IG1heE9mZnNldChmb2N1c05vZGUpIDogMCkpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSkge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBTYWZhcmkgY2FuIHJlcG9ydCBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG1heE9mZnNldChub2RlKSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlID09IGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1Njcm9sbGVkVG9Cb3R0b20oZWx0KSB7XG4gICAgcmV0dXJuIGVsdC5zY3JvbGxUb3AgPiBNYXRoLm1heCgxLCBlbHQuc2Nyb2xsSGVpZ2h0IC0gZWx0LmNsaWVudEhlaWdodCAtIDQpO1xufVxuXG5jbGFzcyBET01Qb3Mge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCwgcHJlY2lzZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IHByZWNpc2U7XG4gICAgfVxuICAgIHN0YXRpYyBiZWZvcmUoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pLCBwcmVjaXNlKTsgfVxuICAgIHN0YXRpYyBhZnRlcihkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSkgKyAxLCBwcmVjaXNlKTsgfVxufVxuY29uc3Qgbm9DaGlsZHJlbiA9IFtdO1xuY2xhc3MgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbGFncyA9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmUodGhpcykgOiAwO1xuICAgIH1cbiAgICBnZXQgcG9zQXRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgcG9zQmVmb3JlKHZpZXcpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkID09IHZpZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjaGlsZCBpbiBwb3NCZWZvcmVcIik7XG4gICAgfVxuICAgIHBvc0FmdGVyKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlKHZpZXcpICsgdmlldy5sZW5ndGg7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBudWxsLCBuZXh0O1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kb20gJiYgKG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZW50VmlldyB8fCAhY29udGVudFZpZXcucGFyZW50ICYmIGNvbnRlbnRWaWV3LmNhblJldXNlRE9NKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjayAmJiAhdHJhY2sud3JpdHRlbiAmJiB0cmFjay5ub2RlID09IHBhcmVudCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBuZXh0ICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZC5kb20sIG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGQuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiB0cmFjayAmJiB0cmFjay5ub2RlID09IHBhcmVudClcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KVxuICAgICAgICAgICAgICAgIG5leHQgPSBybSQxKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZmxhZ3MgJj0gfjcgLyogVmlld0ZsYWcuRGlydHkgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKF9kb20pIHsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGFmdGVyO1xuICAgICAgICBpZiAobm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLmRvbS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IG1heE9mZnNldChub2RlKSA9PSAwID8gMCA6IG9mZnNldCA9PSAwID8gLTEgOiAxO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGJpYXMgPT0gMCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPSBwYXJlbnQubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09IHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaWFzIDwgMClcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlciA9PSB0aGlzLmRvbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHdoaWxlIChhZnRlciAmJiAhQ29udGVudFZpZXcuZ2V0KGFmdGVyKSlcbiAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLmRvbSA9PSBhZnRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBmcm9tSSA9IC0xLCBmcm9tU3RhcnQgPSAtMSwgdG9JID0gLTEsIHRvRW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBvZmZzZXQsIHByZXZFbmQgPSBvZmZzZXQ7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQm91bmRzQXJvdW5kKGZyb20sIHRvLCBwb3MpO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBmcm9tICYmIGZyb21JID09IC0xKSB7XG4gICAgICAgICAgICAgICAgZnJvbUkgPSBpO1xuICAgICAgICAgICAgICAgIGZyb21TdGFydCA9IHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPiB0byAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRvSSA9IGk7XG4gICAgICAgICAgICAgICAgdG9FbmQgPSBwcmV2RW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkVuZCA9IGVuZDtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJvbTogZnJvbVN0YXJ0LCB0bzogdG9FbmQgPCAwID8gb2Zmc2V0ICsgdGhpcy5sZW5ndGggOiB0b0VuZCxcbiAgICAgICAgICAgIHN0YXJ0RE9NOiAoZnJvbUkgPyB0aGlzLmNoaWxkcmVuW2Zyb21JIC0gMV0uZG9tLm5leHRTaWJsaW5nIDogbnVsbCkgfHwgdGhpcy5kb20uZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIGVuZERPTTogdG9JIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgdG9JID49IDAgPyB0aGlzLmNoaWxkcmVuW3RvSV0uZG9tIDogbnVsbCB9O1xuICAgIH1cbiAgICBtYXJrRGlydHkoYW5kUGFyZW50ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mbGFncyB8PSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KGFuZFBhcmVudCk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoY2hpbGRMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXMucGFyZW50OyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZExpc3QpXG4gICAgICAgICAgICAgICAgcGFyZW50LmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovO1xuICAgICAgICAgICAgY2hpbGRMaXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLylcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RE9NKGRvbSkge1xuICAgICAgICBpZiAodGhpcy5kb20gPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmRvbS5jbVZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgICAgZG9tLmNtVmlldyA9IHRoaXM7XG4gICAgfVxuICAgIGdldCByb290VmlldygpIHtcbiAgICAgICAgZm9yIChsZXQgdiA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHYucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB2ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2VDaGlsZHJlbihmcm9tLCB0bywgY2hpbGRyZW4gPSBub0NoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcyAmJiBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA8IDApXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgLi4uY2hpbGRyZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY2hpbGRyZW5baV0uc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihfcmVjKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlnbm9yZUV2ZW50KF9ldmVudCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICBjaGlsZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhwb3MsIGJpYXMpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZShcIlZpZXdcIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBuYW1lICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyB0aGlzLmNoaWxkcmVuLmpvaW4oKSArIFwiKVwiIDpcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID8gXCJbXCIgKyAobmFtZSA9PSBcIlRleHRcIiA/IHRoaXMudGV4dCA6IHRoaXMubGVuZ3RoKSArIFwiXVwiIDogXCJcIikgK1xuICAgICAgICAgICAgKHRoaXMuYnJlYWtBZnRlciA/IFwiI1wiIDogXCJcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobm9kZSkgeyByZXR1cm4gbm9kZS5jbVZpZXc7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjYW5SZXVzZURPTShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIuY29uc3RydWN0b3IgPT0gdGhpcy5jb25zdHJ1Y3RvciAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhpcyBpcyBhIHplcm8tbGVuZ3RoIHZpZXcgd2l0aCBhIHNpZGUsIHRoaXMgc2hvdWxkIHJldHVybiBhXG4gICAgLy8gbnVtYmVyIDw9IDAgdG8gaW5kaWNhdGUgaXQgaXMgYmVmb3JlIGl0cyBwb3NpdGlvbiwgb3IgYVxuICAgIC8vIG51bWJlciA+IDAgd2hlbiBhZnRlciBpdHMgcG9zaXRpb24uXG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtJDEoZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbmNsYXNzIENoaWxkQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgcG9zLCBpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuaSA9IGk7XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZmluZFBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0aGlzLnBvcyB8fCBwb3MgPT0gdGhpcy5wb3MgJiZcbiAgICAgICAgICAgICAgICAoYmlhcyA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmID0gcG9zIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuY2hpbGRyZW5bLS10aGlzLmldO1xuICAgICAgICAgICAgdGhpcy5wb3MgLT0gbmV4dC5sZW5ndGggKyBuZXh0LmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuW2Zyb21JXSA6IG51bGw7XG4gICAgbGV0IGxhc3QgPSBpbnNlcnQubGVuZ3RoID8gaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgbGV0IGJyZWFrQXRFbmQgPSBsYXN0ID8gbGFzdC5icmVha0FmdGVyIDogYnJlYWtBdFN0YXJ0O1xuICAgIC8vIENoYW5nZSB3aXRoaW4gYSBzaW5nbGUgY2hpbGRcbiAgICBpZiAoZnJvbUkgPT0gdG9JICYmIGJlZm9yZSAmJiAhYnJlYWtBdFN0YXJ0ICYmICFicmVha0F0RW5kICYmIGluc2VydC5sZW5ndGggPCAyICYmXG4gICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCB0b09mZiwgaW5zZXJ0Lmxlbmd0aCA/IGxhc3QgOiBudWxsLCBmcm9tT2ZmID09IDAsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodG9JIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhZnRlciA9IGNoaWxkcmVuW3RvSV07XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZW5kIG9mIHRoZSBjaGlsZCBhZnRlciB0aGUgdXBkYXRlIGlzIHByZXNlcnZlZCBpbiBgYWZ0ZXJgXG4gICAgICAgIGlmIChhZnRlciAmJiAodG9PZmYgPCBhZnRlci5sZW5ndGggfHwgYWZ0ZXIuYnJlYWtBZnRlciAmJiAobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LmJyZWFrQWZ0ZXIpKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGEgY2hpbGQsIHNlcGFyYXRlIHBhcnQgb2YgaXQgdG8gYXZvaWQgdGhhdFxuICAgICAgICAgICAgLy8gYmVpbmcgbWFuZ2xlZCB3aGVuIHVwZGF0aW5nIHRoZSBjaGlsZCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIGlmIChmcm9tSSA9PSB0b0kpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IGFmdGVyLnNwbGl0KHRvT2ZmKTtcbiAgICAgICAgICAgICAgICB0b09mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBhZnRlciB0aGUgcmVwbGFjZW1lbnQgc2hvdWxkIGJlIG1lcmdlZCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgbGFzdCByZXBsYWNpbmcgZWxlbWVudCwgdXBkYXRlIGBjb250ZW50YFxuICAgICAgICAgICAgaWYgKCFicmVha0F0RW5kICYmIGxhc3QgJiYgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIGxhc3QsIHRydWUsIDAsIG9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSA9IGFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFydCBvZiB0aGUgYWZ0ZXIgZWxlbWVudCwgaWYgbmVjZXNzYXJ5LCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgdG8gYGNvbnRlbnRgLlxuICAgICAgICAgICAgICAgIGlmICh0b09mZiB8fCBhZnRlci5jaGlsZHJlbi5sZW5ndGggJiYgIWFmdGVyLmNoaWxkcmVuWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIubWVyZ2UoMCwgdG9PZmYsIG51bGwsIGZhbHNlLCAwLCBvcGVuRW5kKTtcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChhZnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPT09IG51bGwgfHwgYWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFmdGVyLmJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGF0IGB0b0lgIGlzIGVudGlyZWx5IGNvdmVyZWQgYnkgdGhpcyByYW5nZS5cbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGl0cyBsaW5lIGJyZWFrLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICBsYXN0LmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugd2UndmUgaGFuZGxlZCB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgZWxlbWVudHNcbiAgICAgICAgLy8gbm93LCBtYWtlIHN1cmUgYHRvSWAgcG9pbnRzIGFmdGVyIHRoYXQuXG4gICAgICAgIHRvSSsrO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gYnJlYWtBdFN0YXJ0O1xuICAgICAgICBpZiAoZnJvbU9mZiA+IDApIHtcbiAgICAgICAgICAgIGlmICghYnJlYWtBdFN0YXJ0ICYmIGluc2VydC5sZW5ndGggJiYgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIGluc2VydFswXSwgZmFsc2UsIG9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGluc2VydC5zaGlmdCgpLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tT2ZmIDwgYmVmb3JlLmxlbmd0aCB8fCBiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoICYmIGJlZm9yZS5jaGlsZHJlbltiZWZvcmUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgbnVsbCwgZmFsc2UsIG9wZW5TdGFydCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBtZXJnZSB3aWRnZXRzIG9uIHRoZSBib3VuZGFyaWVzIG9mIHRoZSByZXBsYWNlbWVudFxuICAgIHdoaWxlIChmcm9tSSA8IHRvSSAmJiBpbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjaGlsZHJlblt0b0kgLSAxXS5iZWNvbWUoaW5zZXJ0W2luc2VydC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHRvSS0tO1xuICAgICAgICAgICAgaW5zZXJ0LnBvcCgpO1xuICAgICAgICAgICAgb3BlbkVuZCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlblN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkcmVuW2Zyb21JXS5iZWNvbWUoaW5zZXJ0WzBdKSkge1xuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgICAgIGluc2VydC5zaGlmdCgpO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuRW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbnNlcnQubGVuZ3RoICYmIGZyb21JICYmIHRvSSA8IGNoaWxkcmVuLmxlbmd0aCAmJiAhY2hpbGRyZW5bZnJvbUkgLSAxXS5icmVha0FmdGVyICYmXG4gICAgICAgIGNoaWxkcmVuW3RvSV0ubWVyZ2UoMCwgMCwgY2hpbGRyZW5bZnJvbUkgLSAxXSwgZmFsc2UsIG9wZW5TdGFydCwgb3BlbkVuZCkpXG4gICAgICAgIGZyb21JLS07XG4gICAgaWYgKGZyb21JIDwgdG9JIHx8IGluc2VydC5sZW5ndGgpXG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGRyZW4oZnJvbUksIHRvSSwgaW5zZXJ0KTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW5JbnRvKHBhcmVudCwgZnJvbSwgdG8sIGluc2VydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IGN1ciA9IHBhcmVudC5jaGlsZEN1cnNvcigpO1xuICAgIGxldCB7IGk6IHRvSSwgb2ZmOiB0b09mZiB9ID0gY3VyLmZpbmRQb3ModG8sIDEpO1xuICAgIGxldCB7IGk6IGZyb21JLCBvZmY6IGZyb21PZmYgfSA9IGN1ci5maW5kUG9zKGZyb20sIC0xKTtcbiAgICBsZXQgZExlbiA9IGZyb20gLSB0bztcbiAgICBmb3IgKGxldCB2aWV3IG9mIGluc2VydClcbiAgICAgICAgZExlbiArPSB2aWV3Lmxlbmd0aDtcbiAgICBwYXJlbnQubGVuZ3RoICs9IGRMZW47XG4gICAgcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgMCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbn1cblxubGV0IG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvciA6IHsgdXNlckFnZW50OiBcIlwiLCB2ZW5kb3I6IFwiXCIsIHBsYXRmb3JtOiBcIlwiIH07XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IHsgZG9jdW1lbnRFbGVtZW50OiB7IHN0eWxlOiB7fSB9IH07XG5jb25zdCBpZV9lZGdlID0gLypAX19QVVJFX18qLy9FZGdlXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gLypAX19QVVJFX18qLy9NU0lFIFxcZC8udGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvKkBfX1BVUkVfXyovL1RyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGdlY2tvID0gIWllICYmIC8qQF9fUFVSRV9fKi8vZ2Vja29cXC8oXFxkKykvaS50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgY2hyb21lID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQ2hyb21lXFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdi52ZW5kb3IpO1xuY29uc3QgaW9zID0gc2FmYXJpICYmICgvKkBfX1BVUkVfXyovL01vYmlsZVxcL1xcdysvLnRlc3QobmF2LnVzZXJBZ2VudCkgfHwgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgYnJvd3NlciA9IHtcbiAgICBtYWM6IGlvcyB8fCAvKkBfX1BVUkVfXyovL01hYy8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIHdpbmRvd3M6IC8qQF9fUFVSRV9fKi8vV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgbGludXg6IC8qQF9fUFVSRV9fKi8vTGludXh8WDExLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgaWUsXG4gICAgaWVfdmVyc2lvbjogaWVfdXB0bzEwID8gZG9jLmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cCA/ICtpZV8xMXVwWzFdIDogaWVfZWRnZSA/ICtpZV9lZGdlWzFdIDogMCxcbiAgICBnZWNrbyxcbiAgICBnZWNrb192ZXJzaW9uOiBnZWNrbyA/ICsoLypAX19QVVJFX18qLy9GaXJlZm94XFwvKFxcZCspLy5leGVjKG5hdi51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIGNocm9tZTogISFjaHJvbWUsXG4gICAgY2hyb21lX3ZlcnNpb246IGNocm9tZSA/ICtjaHJvbWVbMV0gOiAwLFxuICAgIGlvcyxcbiAgICBhbmRyb2lkOiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2LnVzZXJBZ2VudCksXG4gICAgd2Via2l0LFxuICAgIHNhZmFyaSxcbiAgICB3ZWJraXRfdmVyc2lvbjogd2Via2l0ID8gKygvKkBfX1BVUkVfXyovL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICAgIHRhYlNpemU6IGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5cbmNvbnN0IE1heEpvaW5MZW4gPSAyNTY7XG5jbGFzcyBUZXh0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgY3JlYXRlRE9NKHRleHRET00pIHtcbiAgICAgICAgdGhpcy5zZXRET00odGV4dERPTSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tLm5vZGVWYWx1ZSAhPSB0aGlzLnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0cmFjay5ub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20ubm9kZVZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldXNlRE9NKGRvbSkge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTShkb20pO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlKSB7XG4gICAgICAgIGlmICgodGhpcy5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pIHx8XG4gICAgICAgICAgICBzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuIHx8XG4gICAgICAgICAgICAgICAgKHNvdXJjZS5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmVzdWx0LmZsYWdzIHw9IHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBub2RlID09IHRoaXMuZG9tID8gb2Zmc2V0IDogb2Zmc2V0ID8gdGhpcy50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gbmV3IERPTVBvcyh0aGlzLmRvbSwgcG9zKTsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChfZnJvbSwgX3RvLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogb2Zmc2V0LCB0bzogb2Zmc2V0ICsgdGhpcy5sZW5ndGgsIHN0YXJ0RE9NOiB0aGlzLmRvbSwgZW5kRE9NOiB0aGlzLmRvbS5uZXh0U2libGluZyB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRleHRDb29yZHModGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxufVxuY2xhc3MgTWFya1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IobWFyaywgY2hpbGRyZW4gPSBbXSwgbGVuZ3RoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGNoLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgc2V0QXR0cnMoZG9tKSB7XG4gICAgICAgIGNsZWFyQXR0cmlidXRlcyhkb20pO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmNsYXNzKVxuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IHRoaXMubWFyay5jbGFzcztcbiAgICAgICAgaWYgKHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdGhpcy5tYXJrLmF0dHJzW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNhblJldXNlRE9NKG90aGVyKSAmJiAhKCh0aGlzLmZsYWdzIHwgb3RoZXIuZmxhZ3MpICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMuc2V0QXR0cnMoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm1hcmsudGFnTmFtZSkpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuLnNsaWNlKCkgOiBbXSwgb3BlblN0YXJ0IC0gMSwgb3BlbkVuZCAtIDEpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIG9mZiA9IDAsIGRldGFjaEZyb20gPSAtMSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gb2ZmICsgZWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9mZiA8IGZyb20gPyBlbHQuc3BsaXQoZnJvbSAtIG9mZikgOiBlbHQpO1xuICAgICAgICAgICAgaWYgKGRldGFjaEZyb20gPCAwICYmIG9mZiA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIGRldGFjaEZyb20gPSBpO1xuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbTtcbiAgICAgICAgaWYgKGRldGFjaEZyb20gPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBkZXRhY2hGcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE1hcmtWaWV3KHRoaXMubWFyaywgcmVzdWx0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHRDb29yZHModGV4dCwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGxlbmd0aCA9IHRleHQubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zID4gbGVuZ3RoKVxuICAgICAgICBwb3MgPSBsZW5ndGg7XG4gICAgbGV0IGZyb20gPSBwb3MsIHRvID0gcG9zLCBmbGF0dGVuID0gMDtcbiAgICBpZiAocG9zID09IDAgJiYgc2lkZSA8IDAgfHwgcG9zID09IGxlbmd0aCAmJiBzaWRlID49IDApIHtcbiAgICAgICAgaWYgKCEoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykpIHsgLy8gVGhlc2UgYnJvd3NlcnMgcmVsaWFibHkgcmV0dXJuIHZhbGlkIHJlY3RhbmdsZXMgZm9yIGVtcHR5IHJhbmdlc1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gMTtcbiAgICAgICAgICAgIH0gLy8gRklYTUUgdGhpcyBpcyB3cm9uZyBpbiBSVEwgdGV4dFxuICAgICAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgfVxuICAgIGxldCByZWN0cyA9IHRleHRSYW5nZSh0ZXh0LCBmcm9tLCB0bykuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHJlY3QgPSByZWN0c1soZmxhdHRlbiA/IGZsYXR0ZW4gPCAwIDogc2lkZSA+PSAwKSA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoYnJvd3Nlci5zYWZhcmkgJiYgIWZsYXR0ZW4gJiYgcmVjdC53aWR0aCA9PSAwKVxuICAgICAgICByZWN0ID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgciA9PiByLndpZHRoKSB8fCByZWN0O1xuICAgIHJldHVybiBmbGF0dGVuID8gZmxhdHRlblJlY3QocmVjdCwgZmxhdHRlbiA8IDApIDogcmVjdCB8fCBudWxsO1xufVxuLy8gQWxzbyB1c2VkIGZvciBjb2xsYXBzZWQgcmFuZ2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIHBsYWNlaG9sZGVyIHdpZGdldCFcbmNsYXNzIFdpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgc3RhdGljIGNyZWF0ZSh3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdpZGdldFZpZXcod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFdpZGdldFZpZXcuY3JlYXRlKHRoaXMud2lkZ2V0LCB0aGlzLmxlbmd0aCAtIGZyb20sIHRoaXMuc2lkZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGZyb207XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0VmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZSAmJlxuICAgICAgICAgICAgdGhpcy53aWRnZXQuY29uc3RydWN0b3IgPT0gb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmNvbXBhcmUob3RoZXIud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRvcCwgdGV4dCA9IHZpZXcgJiYgdmlldy5zdGF0ZS5kb2MsIHN0YXJ0ID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4gdGV4dCA/IHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgdGhpcy5sZW5ndGgpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHRoaXMuc2lkZSA+IDApXG4gICAgICAgICAgICA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pXG4gICAgICAgICAgICA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb21CYWNrID0gdGhpcy5zaWRlID8gdGhpcy5zaWRlIDwgMCA6IHBvcyA+IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tQmFjayA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwOzsgaSArPSAoZnJvbUJhY2sgPyAtMSA6IDEpKSB7XG4gICAgICAgICAgICByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocG9zID4gMCA/IGkgPT0gMCA6IGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAhZnJvbUJhY2spO1xuICAgIH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRoaXMud2lkZ2V0LmlzSGlkZGVuOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgZHJhd24gYXJvdW5kIHVuZWRpdGFibGUgd2lkZ2V0cyB0byBhdm9pZCBhIG51bWJlciBvZlxuLy8gYnJvd3NlciBidWdzIHRoYXQgc2hvdyB1cCB3aGVuIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgbmV4dCB0b1xuLy8gdW5lZGl0YWJsZSBpbmxpbmUgY29udGVudC5cbmNsYXNzIFdpZGdldEJ1ZmZlclZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Ioc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuICAgIG1lcmdlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgV2lkZ2V0QnVmZmVyVmlldyAmJiBvdGhlci5zaWRlID09IHRoaXMuc2lkZTtcbiAgICB9XG4gICAgc3BsaXQoKSB7IHJldHVybiBuZXcgV2lkZ2V0QnVmZmVyVmlldyh0aGlzLnNpZGUpOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJjbS13aWRnZXRCdWZmZXJcIjtcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIHRoaXMuc2lkZSA+IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5UZXh0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldEJ1ZmZlclZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gbm9DaGlsZHJlbjtcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKHBhcmVudCwgcG9zKSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudC5kb20sIHsgY2hpbGRyZW4gfSA9IHBhcmVudCwgaSA9IDA7XG4gICAgZm9yIChsZXQgb2ZmID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmICYmIGNoaWxkLmdldFNpZGUoKSA8PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChwb3MgPiBvZmYgJiYgcG9zIDwgZW5kICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21BdFBvcyhwb3MgLSBvZmYpO1xuICAgICAgICBpZiAocG9zIDw9IG9mZilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvZmYgPSBlbmQ7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY2hpbGRyZW5baiAtIDFdO1xuICAgICAgICBpZiAocHJldi5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gcHJldi5kb21BdFBvcyhwcmV2Lmxlbmd0aCk7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKG5leHQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZG9tQXRQb3MoMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgYmVmb3JlID0gbnVsbCwgYmVmb3JlUG9zID0gLTEsIGFmdGVyID0gbnVsbCwgYWZ0ZXJQb3MgPSAtMTtcbiAgICBmdW5jdGlvbiBzY2FuKHZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoICYmIG9mZiA8PSBwb3M7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oY2hpbGQsIHBvcyAtIG9mZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuaXNIaWRkZW4gJiYgc2lkZSA+IDApICYmXG4gICAgICAgICAgICAgICAgICAgIChlbmQgPiBwb3MgfHwgb2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZnRlciA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhZnRlclBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmIDwgcG9zIHx8IChvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA8IDApICYmICFjaGlsZC5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuKHZpZXcsIHBvcyk7XG4gICAgbGV0IHRhcmdldCA9IChzaWRlIDwgMCA/IGJlZm9yZSA6IGFmdGVyKSB8fCBiZWZvcmUgfHwgYWZ0ZXI7XG4gICAgaWYgKHRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb29yZHNBdChNYXRoLm1heCgwLCB0YXJnZXQgPT0gYmVmb3JlID8gYmVmb3JlUG9zIDogYWZ0ZXJQb3MpLCBzaWRlKTtcbiAgICByZXR1cm4gZmFsbGJhY2tSZWN0KHZpZXcpO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tSZWN0KHZpZXcpIHtcbiAgICBsZXQgbGFzdCA9IHZpZXcuZG9tLmxhc3RDaGlsZDtcbiAgICBpZiAoIWxhc3QpXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihsYXN0KTtcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiICYmIHRhcmdldC5jbGFzcylcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgdGFyZ2V0LnN0eWxlKVxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlICs9IFwiO1wiICsgc291cmNlLnN0eWxlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBub0F0dHJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIsIGlnbm9yZSkge1xuICAgIGlmIChhID09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghYSlcbiAgICAgICAgYSA9IG5vQXR0cnM7XG4gICAgaWYgKCFiKVxuICAgICAgICBiID0gbm9BdHRycztcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQS5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSAhPVxuICAgICAgICBrZXlzQi5sZW5ndGggLSAoaWdub3JlICYmIGtleXNCLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQga2V5IG9mIGtleXNBKSB7XG4gICAgICAgIGlmIChrZXkgIT0gaWdub3JlICYmIChrZXlzQi5pbmRleE9mKGtleSkgPT0gLTEgfHwgYVtrZXldICE9PSBiW2tleV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChwcmV2KVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgICAgICBpZiAoIShhdHRycyAmJiBuYW1lIGluIGF0dHJzKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBdHRycyhkb20pIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHIgPSBkb20uYXR0cmlidXRlc1tpXTtcbiAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbn1cblxuY2xhc3MgTGluZVZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdHRycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgfVxuICAgIC8vIENvbnN1bWVzIHNvdXJjZVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgc291cmNlLnRyYW5zZmVyRE9NKHRoaXMpOyAvLyBSZXVzZSBzb3VyY2UuZG9tIHdoZW4gYXBwcm9wcmlhdGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzU3RhcnQpXG4gICAgICAgICAgICB0aGlzLnNldERlY28oc291cmNlID8gc291cmNlLmF0dHJzIDogbnVsbCk7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4uc2xpY2UoKSA6IFtdLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2pdLCAwKTtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblstLWldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZChjaGlsZCwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKHRoaXMsIGNoaWxkLCBvcGVuU3RhcnQpO1xuICAgIH1cbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gICAgYWRkTGluZURlY28oZGVjbykge1xuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKGF0dHJzLCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoeyBjbGFzczogY2xzIH0sIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMsIHBvcyk7XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLyB8IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovKSB7XG4gICAgICAgICAgICBjbGVhckF0dHJpYnV0ZXModGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZBdHRycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1cGRhdGVBdHRycyh0aGlzLmRvbSwgdGhpcy5wcmV2QXR0cnMsIHRoaXMuYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxpbmVcIik7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zeW5jKHZpZXcsIHRyYWNrKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChsYXN0ICYmIENvbnRlbnRWaWV3LmdldChsYXN0KSBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbGFzdCA9IGxhc3QubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWxhc3QgfHwgIXRoaXMubGVuZ3RoIHx8XG4gICAgICAgICAgICBsYXN0Lm5vZGVOYW1lICE9IFwiQlJcIiAmJiAoKF9hID0gQ29udGVudFZpZXcuZ2V0KGxhc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAoIWJyb3dzZXIuaW9zIHx8ICF0aGlzLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUZXh0VmlldykpKSB7XG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcbiAgICAgICAgICAgIGhhY2suY21JZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMCwgdGV4dEhlaWdodDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgL1teIC1+XS8udGVzdChjaGlsZC50ZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkLmRvbSk7XG4gICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0b3RhbFdpZHRoICs9IHJlY3RzWzBdLndpZHRoO1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3RzWzBdLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRvdGFsV2lkdGggPyBudWxsIDoge1xuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgICAgICAgY2hhcldpZHRoOiB0b3RhbFdpZHRoIC8gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdCA9IGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICAgICAgLy8gQ29ycmVjdCByZWN0YW5nbGUgaGVpZ2h0IGZvciBlbXB0eSBsaW5lcyB3aGVuIHRoZSByZXR1cm5lZFxuICAgICAgICAvLyBoZWlnaHQgaXMgbGFyZ2VyIHRoYW4gdGhlIHRleHQgaGVpZ2h0LlxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHJlY3QgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlaWdodE9yYWNsZSB9ID0gdGhpcy5wYXJlbnQudmlldy52aWV3U3RhdGUsIGhlaWdodCA9IHJlY3QuYm90dG9tIC0gcmVjdC50b3A7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQpIDwgMiAmJiBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gKGhlaWdodCAtIGhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiByZWN0LnRvcCArIGRpc3QsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkaXN0LCBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgYmVjb21lKF9vdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBjb3ZlcnMoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgZG9jVmlldy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIGRlY28pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMubGVuZ3RoIC0gYXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMuZGVjbyk7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnZpZXcuc3RhdGUuZG9jLnNsaWNlKHRoaXMucG9zQXRTdGFydCwgdGhpcy5wb3NBdEVuZCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJlxuICAgICAgICAgICAgb3RoZXIud2lkZ2V0LmNvbnN0cnVjdG9yID09IHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIW90aGVyLndpZGdldC5jb21wYXJlKHRoaXMud2lkZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiAhdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjbyA9IG90aGVyLmRlY287XG4gICAgICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSBvdGhlci5icmVha0FmdGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbiAgICBjb3ZlcnMoc2lkZSkge1xuICAgICAgICBsZXQgeyBzdGFydFNpZGUsIGVuZFNpZGUgfSA9IHRoaXMuZGVjbztcbiAgICAgICAgcmV0dXJuIHN0YXJ0U2lkZSA9PSBlbmRTaWRlID8gZmFsc2UgOiBzaWRlIDwgMCA/IHN0YXJ0U2lkZSA8IDAgOiBlbmRTaWRlID4gMDtcbiAgICB9XG59XG5cbi8qKlxuV2lkZ2V0cyBhZGRlZCB0byB0aGUgY29udGVudCBhcmUgZGVzY3JpYmVkIGJ5IHN1YmNsYXNzZXMgb2YgdGhpc1xuY2xhc3MuIFVzaW5nIGEgZGVzY3JpcHRpb24gb2JqZWN0IGxpa2UgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0b1xuZGVsYXkgY3JlYXRpbmcgb2YgdGhlIERPTSBzdHJ1Y3R1cmUgZm9yIGEgd2lkZ2V0IHVudGlsIGl0IGlzXG5uZWVkZWQsIGFuZCB0byBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyBldmVuIGlmIHRoZSBkZWNvcmF0aW9uc1xudGhhdCBkZWZpbmUgdGhlbSBhcmUgcmVjcmVhdGVkLlxuKi9cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBpbnN0YW5jZSB0byBhbm90aGVyIGluc3RhbmNlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcbiAgICBzcGVjaWZpYyBjbGFzcyB3aWxsIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC4pIFRoaXMgaXMgdXNlZCB0b1xuICAgIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIHdoZW4gdGhleSBhcmUgcmVwbGFjZWQgYnkgYSBuZXdcbiAgICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcbiAgICByZXR1cm5zIGBmYWxzZWAsIHdoaWNoIHdpbGwgY2F1c2UgbmV3IGluc3RhbmNlcyBvZiB0aGUgd2lkZ2V0IHRvXG4gICAgYWx3YXlzIGJlIHJlZHJhd24uXG4gICAgKi9cbiAgICBlcSh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgRE9NIGVsZW1lbnQgY3JlYXRlZCBieSBhIHdpZGdldCBvZiB0aGUgc2FtZSB0eXBlIChidXRcbiAgICBkaWZmZXJlbnQsIG5vbi1gZXFgIGNvbnRlbnQpIHRvIHJlZmxlY3QgdGhpcyB3aWRnZXQuIE1heSByZXR1cm5cbiAgICB0cnVlIHRvIGluZGljYXRlIHRoYXQgaXQgY291bGQgdXBkYXRlLCBmYWxzZSB0byBpbmRpY2F0ZSBpdFxuICAgIGNvdWxkbid0IChpbiB3aGljaCBjYXNlIHRoZSB3aWRnZXQgd2lsbCBiZSByZWRyYXduKS4gVGhlIGRlZmF1bHRcbiAgICBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgZmFsc2UuXG4gICAgKi9cbiAgICB1cGRhdGVET00oZG9tLCB2aWV3KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZXN0aW1hdGVkIGhlaWdodCB0aGlzIHdpZGdldCB3aWxsIGhhdmUsIHRvIGJlIHVzZWQgd2hlblxuICAgIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxuICAgIHJldHVybiAtMSB0byBpbmRpY2F0ZSB5b3UgZG9uJ3Qga25vdy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm5zIC0xLlxuICAgICovXG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIC0xOyB9XG4gICAgLyoqXG4gICAgRm9yIGlubGluZSB3aWRnZXRzIHRoYXQgYXJlIGRpc3BsYXllZCBpbmxpbmUgKGFzIG9wcG9zZWQgdG9cbiAgICBgaW5saW5lLWJsb2NrYCkgYW5kIGludHJvZHVjZSBsaW5lIGJyZWFrcyAodGhyb3VnaCBgPGJyPmAgdGFnc1xuICAgIG9yIHRleHR1YWwgbmV3bGluZXMpLCB0aGlzIG11c3QgaW5kaWNhdGUgdGhlIGFtb3VudCBvZiBsaW5lXG4gICAgYnJlYWtzIHRoZXkgaW50cm9kdWNlLiBEZWZhdWx0cyB0byAwLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVha3MoKSB7IHJldHVybiAwOyB9XG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHdoaWNoIGtpbmRzIG9mIGV2ZW50cyBpbnNpZGUgdGhlIHdpZGdldFxuICAgIHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBlZGl0b3IuIFRoZSBkZWZhdWx0IGlzIHRvIGlnbm9yZSBhbGxcbiAgICBldmVudHMuXG4gICAgKi9cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIC8qKlxuICAgIE92ZXJyaWRlIHRoZSB3YXkgc2NyZWVuIGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvbnMgYXQvaW4gdGhlXG4gICAgd2lkZ2V0IGFyZSBmb3VuZC4gYHBvc2Agd2lsbCBiZSB0aGUgb2Zmc2V0IGludG8gdGhlIHdpZGdldCwgYW5kXG4gICAgYHNpZGVgIHRoZSBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIHF1ZXJpZWTigJRsZXNzIHRoYW5cbiAgICB6ZXJvIGZvciBiZWZvcmUsIGdyZWF0ZXIgdGhhbiB6ZXJvIGZvciBhZnRlciwgYW5kIHplcm8gZm9yXG4gICAgZGlyZWN0bHkgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvb3Jkc0F0KGRvbSwgcG9zLCBzaWRlKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcbiAgICBmcm9tIHRoZSBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbi8qKlxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXG4qL1xudmFyIEJsb2NrVHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIC8qKlxuICAgIEEgbGluZSBvZiB0ZXh0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYWZ0ZXIgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QmVmb3JlXCJdID0gMV0gPSBcIldpZGdldEJlZm9yZVwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEFmdGVyXCJdID0gMl0gPSBcIldpZGdldEFmdGVyXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgW3JlcGxhY2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgYSByYW5nZSBvZiBjb250ZW50LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XG5yZXR1cm4gQmxvY2tUeXBlfSkoQmxvY2tUeXBlIHx8IChCbG9ja1R5cGUgPSB7fSkpO1xuLyoqXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxub2YgY29udGVudC4gWW91J2xsIHVzdWFsbHkgdXNlIGl0IHdyYXBwZWQgaW4gYVxuW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpLCB3aGljaCBhZGRzIGEgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbkBub25hYnN0cmFjdFxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0U2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbmRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdpZGdldCwgXG4gICAgLyoqXG4gICAgVGhlIGNvbmZpZyBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhpcyBkZWNvcmF0aW9uLiBZb3UgY2FuXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcbiAgICB5b3VyIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTaWRlID0gc3RhcnRTaWRlO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgICBjb250ZW50IGluIGl0cyByYW5nZS4gTmVzdGVkIG1hcmsgZGVjb3JhdGlvbnMgd2lsbCBjYXVzZSBuZXN0ZWRcbiAgICBET00gZWxlbWVudHMgdG8gYmUgY3JlYXRlZC4gTmVzdGluZyBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5XG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgICB0aGUgaGlnaGVyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMgY3JlYXRpbmcgdGhlIGlubmVyIERPTSBub2Rlcy5cbiAgICBTdWNoIGVsZW1lbnRzIGFyZSBzcGxpdCBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBNYXRoLm1heCgtMTAwMDAsIE1hdGgubWluKDEwMDAwLCBzcGVjLnNpZGUgfHwgMCkpLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSAoYmxvY2sgJiYgIXNwZWMuaW5saW5lT3JkZXIpXG4gICAgICAgICAgICA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pXG4gICAgICAgICAgICA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBTaWRlLklubGluZUFmdGVyICovIDogLTEwMDAwMDAwMCAvKiBTaWRlLklubGluZUJlZm9yZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxuICAgIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XG4gICAgICAgIGxldCBibG9jayA9ICEhc3BlYy5ibG9jaywgc3RhcnRTaWRlLCBlbmRTaWRlO1xuICAgICAgICBpZiAoc3BlYy5pc0Jsb2NrR2FwKSB7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XG4gICAgICAgICAgICBlbmRTaWRlID0gNDAwMDAwMDAwIC8qIFNpZGUuR2FwRW5kICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrKTtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IChzdGFydCA/IChibG9jayA/IC0zMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY1N0YXJ0ICovIDogLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLykgOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLykgLSAxO1xuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8gOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLywgZW5kID8gMSAvKiBTaWRlLklubGluZUluY0VuZCAqLyA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8sIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmF0dHJpYnV0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmNsYXNzIHx8ICgoX2EgPSB0aGlzLmF0dHJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3MpKSA9PSAob3RoZXIuY2xhc3MgfHwgKChfYiA9IG90aGVyLmF0dHJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3MpKSAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMsIFwiY2xhc3NcIik7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFyayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbk1hcmtEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCAtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgbnVsbCwgc3BlYyk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLnNwZWMuY2xhc3MgPT0gb3RoZXIuc3BlYy5jbGFzcyAmJlxuICAgICAgICAgICAgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgIT0gdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDw9IDAgPyBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgKHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+PSA1IHx8IHRoaXMud2lkZ2V0LmxpbmVCcmVha3MgPiAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB3aWRnZXRzRXEodGhpcy53aWRnZXQsIG90aGVyLndpZGdldCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPT0gb3RoZXIuYmxvY2sgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaWRlID09IG90aGVyLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVwbGFjZSAmJiAoZnJvbSA+IHRvIHx8IChmcm9tID09IHRvICYmIHRoaXMuc3RhcnRTaWRlID4gMCAmJiB0aGlzLmVuZFNpZGUgPD0gMCkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJhbmdlIGZvciByZXBsYWNlbWVudCBkZWNvcmF0aW9uXCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZXBsYWNlICYmIHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldpZGdldCBkZWNvcmF0aW9ucyBjYW4gb25seSBoYXZlIHplcm8tbGVuZ3RoIHJhbmdlc1wiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5Qb2ludERlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldEluY2x1c2l2ZShzcGVjLCBibG9jayA9IGZhbHNlKSB7XG4gICAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IHN0YXJ0LCBpbmNsdXNpdmVFbmQ6IGVuZCB9ID0gc3BlYztcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgc3RhcnQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gdm9pZCAwID8gc3RhcnQgOiBibG9jaywgZW5kOiBlbmQgIT09IG51bGwgJiYgZW5kICE9PSB2b2lkIDAgPyBlbmQgOiBibG9jayB9O1xufVxuZnVuY3Rpb24gd2lkZ2V0c0VxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8ICEhKGEgJiYgYiAmJiBhLmNvbXBhcmUoYikpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoZnJvbSwgdG8sIHJhbmdlcywgbWFyZ2luID0gMCkge1xuICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0gKyBtYXJnaW4gPj0gZnJvbSlcbiAgICAgICAgcmFuZ2VzW2xhc3RdID0gTWF0aC5tYXgocmFuZ2VzW2xhc3RdLCB0byk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZXMucHVzaChmcm9tLCB0byk7XG59XG5cbmNsYXNzIENvbnRlbnRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2MsIHBvcywgZW5kLCBkaXNhbGxvd0Jsb2NrRWZmZWN0c0Zvcikge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yID0gZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDA7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gW107XG4gICAgICAgIC8vIFNldCB0byBmYWxzZSBkaXJlY3RseSBhZnRlciBhIHdpZGdldCB0aGF0IGNvdmVycyB0aGUgcG9zaXRpb24gYWZ0ZXIgaXRcbiAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IC0xO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvYy5pdGVyKCk7XG4gICAgICAgIHRoaXMuc2tpcCA9IHBvcztcbiAgICB9XG4gICAgcG9zQ292ZXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5icmVha0F0U3RhcnQgJiYgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tICE9IHRoaXMucG9zO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiAhKGxhc3QuYnJlYWtBZnRlciB8fCBsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QuZGVjby5lbmRTaWRlIDwgMCk7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh0aGlzLmN1ckxpbmUgPSBuZXcgTGluZVZpZXcpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyTGluZTtcbiAgICB9XG4gICAgZmx1c2hCdWZmZXIoYWN0aXZlID0gdGhpcy5idWZmZXJNYXJrcykge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygtMSksIGFjdGl2ZSksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQmxvY2tXaWRnZXQodmlldykge1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHZpZXcpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyICYmIG9wZW5FbmQgPD0gdGhpcy5idWZmZXJNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpICYmXG4gICAgICAgICAgICAhKG9wZW5FbmQgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCAmJiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSlcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgIH1cbiAgICBidWlsZFRleHQobGVuZ3RoLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdmFsdWUsIGxpbmVCcmVhaywgZG9uZSB9ID0gdGhpcy5jdXJzb3IubmV4dCh0aGlzLnNraXApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgdGV4dCBjb250ZW50IHdoZW4gZHJhd2luZyBpbmxpbmUgdmlld3NcIik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIFQuQ2h1bmsgKi8pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUuc2xpY2UoYWN0aXZlLmxlbmd0aCAtIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQsIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yW2luZGV4XSAmJiBkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJsb2NrIGRlY29yYXRpb25zIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICAgICAgaWYgKHRvID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlY29yYXRpb25zIHRoYXQgcmVwbGFjZSBsaW5lIGJyZWFrcyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVjby5zdGFydFNpZGUgPiAwICYmICF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCbG9ja1dpZGdldChuZXcgQmxvY2tXaWRnZXRWaWV3KGRlY28ud2lkZ2V0IHx8IG5ldyBOdWxsV2lkZ2V0KFwiZGl2XCIpLCBsZW4sIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gV2lkZ2V0Vmlldy5jcmVhdGUoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJzcGFuXCIpLCBsZW4sIGxlbiA/IDAgOiBkZWNvLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvckJlZm9yZSA9IHRoaXMuYXRDdXJzb3JQb3MgJiYgIXZpZXcuaXNFZGl0YWJsZSAmJiBvcGVuU3RhcnQgPD0gYWN0aXZlLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoZnJvbSA8IHRvIHx8IGRlY28uc3RhcnRTaWRlID4gMCk7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvckFmdGVyID0gIXZpZXcuaXNFZGl0YWJsZSAmJiAoZnJvbSA8IHRvIHx8IG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGggfHwgZGVjby5zdGFydFNpZGUgPD0gMCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyID09IDIgLyogQnVmLklmQ3Vyc29yICovICYmICFjdXJzb3JCZWZvcmUgJiYgIXZpZXcuaXNFZGl0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcihhY3RpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3JCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KDEpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSBhY3RpdmUubGVuZ3RoICsgTWF0aC5tYXgoMCwgb3BlblN0YXJ0IC0gYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyh2aWV3LCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSBjdXJzb3JBZnRlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAhY3Vyc29yQWZ0ZXIgPyAwIC8qIEJ1Zi5ObyAqLyA6IGZyb20gPCB0byB8fCBvcGVuU3RhcnQgPiBhY3RpdmUubGVuZ3RoID8gMSAvKiBCdWYuWWVzICovIDogMiAvKiBCdWYuSWZDdXJzb3IgKi87XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IGFjdGl2ZS5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSA9PSB0aGlzLnBvcykgeyAvLyBMaW5lIGRlY29yYXRpb25cbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFkZExpbmVEZWNvKGRlY28pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGl0ZXJhdG9yIHBhc3QgdGhlIHJlcGxhY2VkIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgKyBsZW4gPD0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgKz0gbGVuIC0gKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQodGV4dCwgZnJvbSwgdG8sIGRlY29yYXRpb25zLCBkeW5hbWljRGVjb3JhdGlvbk1hcCkge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBDb250ZW50QnVpbGRlcih0ZXh0LCBmcm9tLCB0bywgZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICBidWlsZGVyLm9wZW5FbmQgPSBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIpO1xuICAgICAgICBpZiAoYnVpbGRlci5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgYnVpbGRlci5vcGVuU3RhcnQgPSBidWlsZGVyLm9wZW5FbmQ7XG4gICAgICAgIGJ1aWxkZXIuZmluaXNoKGJ1aWxkZXIub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyh2aWV3LCBhY3RpdmUpIHtcbiAgICBmb3IgKGxldCBtYXJrIG9mIGFjdGl2ZSlcbiAgICAgICAgdmlldyA9IG5ldyBNYXJrVmlldyhtYXJrLCBbdmlld10sIHZpZXcubGVuZ3RoKTtcbiAgICByZXR1cm4gdmlldztcbn1cbmNsYXNzIE51bGxXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci50YWcgPT0gdGhpcy50YWc7IH1cbiAgICB0b0RPTSgpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWcpOyB9XG4gICAgdXBkYXRlRE9NKGVsdCkgeyByZXR1cm4gZWx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy50YWc7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0cnVlOyB9XG59XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3J3YXJkKGZvcndhcmQsIGRpcikgeyByZXR1cm4gZm9yd2FyZCA9PSAodGhpcy5kaXIgPT0gZGlyKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZXNFcShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpQSA9IGFbaV0sIGlCID0gYltpXTtcbiAgICAgICAgaWYgKGlBLmZyb20gIT0gaUIuZnJvbSB8fCBpQS50byAhPSBpQi50byB8fCBpQS5kaXJlY3Rpb24gIT0gaUIuZGlyZWN0aW9uIHx8ICFpc29sYXRlc0VxKGlBLmlubmVyLCBpQi5pbm5lcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbi8vIEZpbGwgaW4gdGhlIGNoYXJhY3RlciB0eXBlcyAoaW4gYHR5cGVzYCkgZnJvbSBgZnJvbWAgdG8gYHRvYCBhbmRcbi8vIGFwcGx5IFcgbm9ybWFsaXphdGlvbiBydWxlcy5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgbGV0IHByZXZUeXBlID0gaUkgPyAyNTYgLyogVC5OSSAqLyA6IG91dGVyVHlwZTtcbiAgICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAgIC8vIG51bWJlci5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgICAgLy8gTmV1dHJhbC5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdG8gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW5kIDwgdG8gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgclRvICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFByb2Nlc3MgYnJhY2tldHMgdGhyb3VnaG91dCBhIHJ1biBzZXF1ZW5jZS5cbmZ1bmN0aW9uIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGxldCBvcHBvc2l0ZVR5cGUgPSBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGZvciAobGV0IGlJID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAgICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBjaCwgYnIsIHR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmV1dHJhbHMockZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpc29sYXRlc1tpSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVMID0gcHJldiA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IHJUbyA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBlbmQsIGpJID0gaUksIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207IGogPiBpOykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBmcm9tSikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzWy0tal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCB0aGUgY29udGlndW91cyByYW5nZXMgb2YgY2hhcmFjdGVyIHR5cGVzIGluIGEgZ2l2ZW4gcmFuZ2UsIGFuZFxuLy8gZW1pdCBzcGFucyBmb3IgdGhlbS4gRmxpcCB0aGUgb3JkZXIgb2YgdGhlIHNwYW5zIGFzIGFwcHJvcHJpYXRlXG4vLyBiYXNlZCBvbiB0aGUgbGV2ZWwsIGFuZCBjYWxsIHRocm91Z2ggdG8gY29tcHV0ZSB0aGUgc3BhbnMgZm9yXG4vLyBpc29sYXRlcyBhdCB0aGUgcHJvcGVyIHBvaW50LlxuZnVuY3Rpb24gZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpIHtcbiAgICBsZXQgb3VyVHlwZSA9IGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKChsZXZlbCAlIDIpID09IChiYXNlTGV2ZWwgJSAyKSkgeyAvLyBTYW1lIGRpciBhcyBiYXNlIGRpcmVjdGlvbiwgZG9uJ3QgZmxpcFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSBmcm9tLCBpSSA9IDA7IGlDaCA8IHRvOykge1xuICAgICAgICAgICAgLy8gU2NhbiBhIHNlY3Rpb24gb2YgY2hhcmFjdGVycyBpbiBkaXJlY3Rpb24gb3VyVHlwZSwgdW5sZXNzXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGFub3RoZXIgdHlwZSBvZiBjaGFyIHJpZ2h0IGFmdGVyIGlDaCwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgLy8gd2Ugc2NhbiBhIHNlY3Rpb24gb2Ygb3RoZXIgY2hhcmFjdGVycyAod2hpY2gsIGlmIG91clR5cGUgPT1cbiAgICAgICAgICAgIC8vIFQuTCwgbWF5IGNvbnRhaW4gYm90aCBULlIgYW5kIFQuQU4gY2hhcnMpLlxuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aCB8fCBpQ2ggPCBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG9sZHMgYW4gYXJyYXkgb2YgaXNvbGF0ZXMgdG8gcGFzcyB0byBhIHJlY3Vyc2l2ZSBjYWxsIGlmIHdlXG4gICAgICAgICAgICAvLyBtdXN0IHJlY3Vyc2UgKHRvIGRpc3Rpbmd1aXNoIFQuQU4gaW5zaWRlIGFuIFJUTCBzZWN0aW9uIGluXG4gICAgICAgICAgICAvLyBMVFIgdGV4dCksIG51bGwgaWYgd2UgY2FuIGVtaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlTY2FuID09IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzW2lJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby50bywgakkgPSBpSSArIDE7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlzb2xhdGVzW2pJXS5mcm9tID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1tqSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaUkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby5mcm9tID4gaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaXNvLmZyb20sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSB0byB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW5dID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaUNoLCBpU2NhbiwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlDaCA8IGlTY2FuKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaVNjYW4sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgdG8gZmxpcCB0aGUgc3BhbiBvcmRlci4gU2FtZSBjb2RlIGFnYWluLCBidXRcbiAgICAgICAgLy8gZ29pbmcgZnJvbSB0aGUgYmFjayBvZiB0aGUgc2VjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgZm9yIChsZXQgaUNoID0gdG8sIGlJID0gaXNvbGF0ZXMubGVuZ3RoOyBpQ2ggPiBmcm9tOykge1xuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpSSB8fCBpQ2ggPiBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2ggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1stLWlJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby5mcm9tLCBqSSA9IGlJOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJICYmIGlzb2xhdGVzW2pJIC0gMV0udG8gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0byAtIDFdID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLnRvIDwgaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlzby50bywgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IGZyb20gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2NhbiAtIDFdICE9IG91clR5cGUgOiB0eXBlc1tpU2NhbiAtIDFdID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaVNjYW4sIGlDaCwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuIDwgaUNoKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlTY2FuLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgZnJvbSwgdG8sIG9yZGVyKSB7XG4gICAgbGV0IG91dGVyVHlwZSA9IChsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovKTtcbiAgICBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzTmV1dHJhbHMoZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24sIGlzb2xhdGVzKSB7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCAwLCBkaXJlY3Rpb24gPT0gUlRMID8gMSA6IDApXTtcbiAgICBpZiAoZGlyZWN0aW9uID09IExUUiAmJiAhaXNvbGF0ZXMubGVuZ3RoICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgaWYgKGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gdHlwZXMubGVuZ3RoKVxuICAgICAgICAgICAgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IDI1NiAvKiBULk5JICovOyAvLyBNYWtlIHN1cmUgdHlwZXMgYXJyYXkgaGFzIG5vIGdhcHNcbiAgICBsZXQgb3JkZXIgPSBbXSwgbGV2ZWwgPSBkaXJlY3Rpb24gPT0gTFRSID8gMCA6IDE7XG4gICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgbGV2ZWwsIGlzb2xhdGVzLCAwLCBsaW5lLmxlbmd0aCwgb3JkZXIpO1xuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBtb3ZlcyBzdHJpY3RseSB2aXN1YWxseSwgd2l0aG91dCBjb25jZXJuIGZvciBhXG4vLyB0cmF2ZXJzYWwgdmlzaXRpbmcgZXZlcnkgbG9naWNhbCBwb3NpdGlvbiBpbiB0aGUgc3RyaW5nLiBJdCB3aWxsXG4vLyBzdGlsbCBkbyBzbyBmb3Igc2ltcGxlIGlucHV0LCBidXQgc2l0dWF0aW9ucyBsaWtlIG11bHRpcGxlIGlzb2xhdGVzXG4vLyB3aXRoIHRoZSBzYW1lIGxldmVsIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGV4dCBnb2luZyBhZ2FpbnN0IHRoZVxuLy8gbWFpbiBkaXIgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSwgd2lsbCBtYWtlIHNvbWUgcG9zaXRpb25zXG4vLyB1bnJlYWNoYWJsZSB3aXRoIHRoaXMgbW90aW9uLiBFYWNoIHZpc2libGUgY3Vyc29yIHBvc2l0aW9uIHdpbGxcbi8vIGNvcnJlc3BvbmQgdG8gdGhlIGxvd2VyLWxldmVsIGJpZGkgc3BhbiB0aGF0IHRvdWNoZXMgaXQuXG4vL1xuLy8gVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHNvbHZlIGFuIG9yZGVyIGdsb2JhbGx5IGZvciBhIGdpdmVuXG4vLyBsaW5lLCBtYWtpbmcgc3VyZSB0aGF0IGl0IGluY2x1ZGVzIGV2ZXJ5IHBvc2l0aW9uLCBidXQgdGhhdCB3b3VsZFxuLy8gcmVxdWlyZSBhc3NvY2lhdGluZyBub24tY2Fub25pY2FsIChoaWdoZXIgYmlkaSBzcGFuIGxldmVsKVxuLy8gcG9zaXRpb25zIHdpdGggYSBnaXZlbiB2aXN1YWwgcG9zaXRpb24sIHdoaWNoIGlzIGxpa2VseSB0byBjb25mdXNlXG4vLyBwZW9wbGUuIChBbmQgd291bGQgZ2VuZXJhbGx5IGJlIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQuKVxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV0sIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICAvLyBFbmQgb2Ygc3BhblxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW5FbmQpIHtcbiAgICAgICAgbGV0IG5leHRJID0gc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKG5leHRJIDwgMCB8fCBuZXh0SSA+PSBvcmRlci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JID0gbmV4dEldO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgICAgICBzcGFuRW5kID0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgc3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikpO1xuICAgIGlmIChuZXh0SW5kZXggPCBzcGFuLmZyb20gfHwgbmV4dEluZGV4ID4gc3Bhbi50bylcbiAgICAgICAgbmV4dEluZGV4ID0gc3BhbkVuZDtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgbGV0IG5leHRTcGFuID0gc3BhbkkgPT0gKGZvcndhcmQgPyBvcmRlci5sZW5ndGggLSAxIDogMCkgPyBudWxsIDogb3JkZXJbc3BhbkkgKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0SW5kZXggPT0gc3BhbkVuZCAmJiBuZXh0U3Bhbi5sZXZlbCArIChmb3J3YXJkID8gMCA6IDEpIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgbmV4dFNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5mdW5jdGlvbiBhdXRvRGlyZWN0aW9uKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUodGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAvKiBULkwgKi8pXG4gICAgICAgICAgICByZXR1cm4gTFRSO1xuICAgICAgICBpZiAodHlwZSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHJldHVybiBSVEw7XG4gICAgfVxuICAgIHJldHVybiBMVFI7XG59XG5cbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZm9jdXNDaGFuZ2VFZmZlY3QgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBwZXJMaW5lVGV4dERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbmNvbnN0IG5hdGl2ZVNlbGVjdGlvbkhpZGRlbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpXG59KTtcbmNsYXNzIFNjcm9sbFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUsIFxuICAgIC8vIFRoaXMgZGF0YSBzdHJ1Y3R1cmUgaXMgYWJ1c2VkIHRvIGFsc28gc3RvcmUgcHJlY2lzZSBzY3JvbGxcbiAgICAvLyBzbmFwc2hvdHMsIGluc3RlYWQgb2YgYSBgc2Nyb2xsSW50b1ZpZXdgIHJlcXVlc3QuIFdoZW4gdGhpc1xuICAgIC8vIGZsYWcgaXMgYHRydWVgLCBgcmFuZ2VgIHBvaW50cyBhdCBhIHBvc2l0aW9uIGluIHRoZSByZWZlcmVuY2VcbiAgICAvLyBsaW5lLCBgeU1hcmdpbmAgaG9sZHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdG9wIG9mIHRoYXRcbiAgICAvLyBsaW5lIGFuZCB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIGFuZCBgeE1hcmdpbmAgaG9sZHMgdGhlXG4gICAgLy8gZWRpdG9yJ3MgYHNjcm9sbExlZnRgLlxuICAgIGlzU25hcHNob3QgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgICAgIHRoaXMuaXNTbmFwc2hvdCA9IGlzU25hcHNob3Q7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KHRoaXMucmFuZ2UubWFwKGNoYW5nZXMpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxuICAgIGNsaXAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UudG8gPD0gc3RhdGUuZG9jLmxlbmd0aCA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXRlLmRvYy5sZW5ndGgpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcbiAgICAgICAgd2luZG93Lm9uZXJyb3IoU3RyaW5nKGV4Y2VwdGlvbiksIGNvbnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xubGV0IG5leHRQbHVnaW5JRCA9IDA7XG5jb25zdCB2aWV3UGx1Z2luID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5WaWV3IHBsdWdpbnMgYXNzb2NpYXRlIHN0YXRlZnVsIHZhbHVlcyB3aXRoIGEgdmlldy4gVGhleSBjYW5cbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xudGhhdCBoYXBwZW4gaW4gdGhlIHZpZXcuXG4qL1xuY2xhc3MgVmlld1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRIYW5kbGVycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudE9ic2VydmVycywgYnVpbGRFeHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IGRvbUV2ZW50SGFuZGxlcnM7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRPYnNlcnZlcnMgPSBkb21FdmVudE9ic2VydmVycztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBidWlsZEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHByb3ZpZGUsIGRlY29yYXRpb25zOiBkZWNvIH0gPSBzcGVjIHx8IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdQbHVnaW4obmV4dFBsdWdpbklEKyssIGNyZWF0ZSwgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHBsdWdpbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXh0ID0gW3ZpZXdQbHVnaW4ub2YocGx1Z2luKV07XG4gICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICBleHQucHVzaChkZWNvcmF0aW9ucy5vZih2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbkluc3QgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSW5zdCA/IGRlY28ocGx1Z2luSW5zdCkgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGUpXG4gICAgICAgICAgICAgICAgZXh0LnB1c2gocHJvdmlkZShwbHVnaW4pKTtcbiAgICAgICAgICAgIHJldHVybiBleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBjbHModmlldyksIHNwZWMpO1xuICAgIH1cbn1cbmNsYXNzIFBsdWdpbkluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8vIFdoZW4gc3RhcnRpbmcgYW4gdXBkYXRlLCBhbGwgcGx1Z2lucyBoYXZlIHRoaXMgZmllbGQgc2V0IHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0LCBpbmRpY2F0aW5nIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLiBXaGVuIGZpbmlzaGVkXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYGZhbHNlYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5jcmVhdGUodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KHZpZXcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgZWRpdG9yQXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNvbnRlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLy8gUHJvdmlkZSBkZWNvcmF0aW9uc1xuY29uc3QgZGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBvdXRlckRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYmlkaUlzb2xhdGVkUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0SXNvbGF0ZWRSYW5nZXModmlldywgbGluZSkge1xuICAgIGxldCBpc29sYXRlcyA9IHZpZXcuc3RhdGUuZmFjZXQoYmlkaUlzb2xhdGVkUmFuZ2VzKTtcbiAgICBpZiAoIWlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGlzb2xhdGVzO1xuICAgIGxldCBzZXRzID0gaXNvbGF0ZXMubWFwKGkgPT4gaSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gaSh2aWV3KSA6IGkpO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBSYW5nZVNldC5zcGFucyhzZXRzLCBsaW5lLmZyb20sIGxpbmUudG8sIHtcbiAgICAgICAgcG9pbnQoKSB7IH0sXG4gICAgICAgIHNwYW4oZnJvbURvYywgdG9Eb2MsIGFjdGl2ZSwgb3Blbikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBmcm9tRG9jIC0gbGluZS5mcm9tLCB0byA9IHRvRG9jIC0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGxldmVsID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSwgb3Blbi0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGFjdGl2ZVtpXS5zcGVjLmJpZGlJc29sYXRlLCB1cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBhdXRvRGlyZWN0aW9uKGxpbmUudGV4dCwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuID4gMCAmJiBsZXZlbC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHVwZGF0ZSA9IGxldmVsW2xldmVsLmxlbmd0aCAtIDFdKS50byA9PSBmcm9tICYmIHVwZGF0ZS5kaXJlY3Rpb24gPT0gZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZS50byA9IHRvO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IHVwZGF0ZS5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSB7IGZyb20sIHRvLCBkaXJlY3Rpb24sIGlubmVyOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXZlbC5wdXNoKGFkZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYWRkLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBzY3JvbGxNYXJnaW5zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsTWFyZ2lucyh2aWV3KSB7XG4gICAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDAsIHRvcCA9IDAsIGJvdHRvbSA9IDA7XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgbGV0IG0gPSBzb3VyY2Uodmlldyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobS5sZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIG0ubGVmdCk7XG4gICAgICAgICAgICBpZiAobS5yaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIG0ucmlnaHQpO1xuICAgICAgICAgICAgaWYgKG0udG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBtLnRvcCk7XG4gICAgICAgICAgICBpZiAobS5ib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIG0uYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcbn1cbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLyB8IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHVwZGF0ZSBpbmRpY2F0ZXMgYSBmb2N1cyBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZm9jdXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZG9jdW1lbnQgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc2VsZWN0aW9uIHdhcyBleHBsaWNpdGx5IHNldCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBzZWxlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLnNlbGVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5mbGFncyA9PSAwICYmIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCA9PSAwOyB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoOyB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXAgPSBbXTtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24gPSBuZXcgU2V0O1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkQ29tcG9zaXRpb25BdCA9IC0xO1xuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLmRvbUNoYW5nZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdTZWwpXG4gICAgICAgICAgICAgICAgcmVhZENvbXBvc2l0aW9uQXQgPSB0aGlzLmRvbUNoYW5nZWQubmV3U2VsLmhlYWQ7XG4gICAgICAgICAgICBlbHNlIGlmICghdG91Y2hlc0NvbXBvc2l0aW9uKHVwZGF0ZS5jaGFuZ2VzLCB0aGlzLmhhc0NvbXBvc2l0aW9uKSAmJiAhdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHJlYWRDb21wb3NpdGlvbkF0ID4gLTEgPyBmaW5kQ29tcG9zaXRpb25SYW5nZSh0aGlzLnZpZXcsIHVwZGF0ZS5jaGFuZ2VzLCByZWFkQ29tcG9zaXRpb25BdCkgOiBudWxsO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5jbGVhcigpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuaGFzQ29tcG9zaXRpb247XG4gICAgICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gbmV3IENoYW5nZWRSYW5nZShmcm9tLCB0bywgdXBkYXRlLmNoYW5nZXMubWFwUG9zKGZyb20sIC0xKSwgdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRvLCAxKSlcbiAgICAgICAgICAgICAgICAuYWRkVG9TZXQoY2hhbmdlZFJhbmdlcy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gPyB7IGZyb206IGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0bzogY29tcG9zaXRpb24ucmFuZ2UudG9CIH0gOiBudWxsO1xuICAgICAgICAvLyBXaGVuIHRoZSBET00gbm9kZXMgYXJvdW5kIHRoZSBzZWxlY3Rpb24gYXJlIG1vdmVkIHRvIGFub3RoZXJcbiAgICAgICAgLy8gcGFyZW50LCBDaHJvbWUgc29tZXRpbWVzIHJlcG9ydHMgYSBkaWZmZXJlbnQgc2VsZWN0aW9uIHRocm91Z2hcbiAgICAgICAgLy8gZ2V0U2VsZWN0aW9uIHRoYW4gdGhlIG9uZSB0aGF0IGl0IGFjdHVhbGx5IHNob3dzIHRvIHRoZSB1c2VyLlxuICAgICAgICAvLyBUaGlzIGZvcmNlcyBhIHNlbGVjdGlvbiB1cGRhdGUgd2hlbiBsaW5lcyBhcmUgam9pbmVkIHRvIHdvcmtcbiAgICAgICAgLy8gYXJvdW5kIHRoYXQuIElzc3VlICM1NFxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgfHwgYnJvd3Nlci5jaHJvbWUpICYmICFjb21wb3NpdGlvbiAmJiB1cGRhdGUgJiZcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5kb2MubGluZXMgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzKVxuICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuZGVjb3JhdGlvbnMsIGRlY28gPSB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgbGV0IGRlY29EaWZmID0gZmluZENoYW5nZWREZWNvKHByZXZEZWNvLCBkZWNvLCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGNoYW5nZWRSYW5nZXMgPSBDaGFuZ2VkUmFuZ2UuZXh0ZW5kV2l0aFJhbmdlcyhjaGFuZ2VkUmFuZ2VzLCBkZWNvRGlmZik7XG4gICAgICAgIGlmICghKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlZCBieSB1cGRhdGUgYW5kIHRoZSBjb25zdHJ1Y3RvciBkbyBwZXJmb3JtIHRoZSBhY3R1YWwgRE9NXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlSW5uZXIoY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoLCBjb21wb3NpdGlvbik7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmZsZXhCYXNpcyA9IHRoaXMubWluV2lkdGggPyB0aGlzLm1pbldpZHRoICsgXCJweFwiIDogXCJcIjtcbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcywgd2hlbiBET00gbXV0YXRpb25zIG9jY3VyIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBhcm91bmQgdGhlIHNlbGVjdGlvbiwgZ2V0IGNvbmZ1c2VkIGFuZCByZXBvcnQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBmcm9tIHRoZSBvbmUgaXQgZGlzcGxheXMgKGlzc3VlICMyMTgpLiBUaGlzIHRyaWVzXG4gICAgICAgICAgICAvLyB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSBicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmlvcyA/IHsgbm9kZTogb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zeW5jKHRoaXMudmlldywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgIGlmICh0cmFjayAmJiAodHJhY2sud3JpdHRlbiB8fCBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUgIT0gdHJhY2subm9kZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5mb3JFYWNoKGNWaWV3ID0+IGNWaWV3LmZsYWdzICY9IH44IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgY2hpbGQud2lkZ2V0IGluc3RhbmNlb2YgQmxvY2tHYXBXaWRnZXQpXG4gICAgICAgICAgICAgICAgICAgIGdhcHMucHVzaChjaGlsZC5kb20pO1xuICAgICAgICBvYnNlcnZlci51cGRhdGVHYXBzKGdhcHMpO1xuICAgIH1cbiAgICB1cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBjb21wb3NpdGlvbiA/IGNvbXBvc2l0aW9uLnJhbmdlLmFkZFRvU2V0KGNoYW5nZXMuc2xpY2UoKSkgOiBjaGFuZ2VzO1xuICAgICAgICBsZXQgY3Vyc29yID0gdGhpcy5jaGlsZEN1cnNvcihvbGRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gcmFuZ2VzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IG5leHQsIGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CIDwgdG9CICYmIGNvbXBvc2l0aW9uLnJhbmdlLnRvQiA+IGZyb21CKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCBjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgY29tcG9zaXRpb24ucmFuZ2UudG9CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrQXRTdGFydCA9IGJlZm9yZS5icmVha0F0U3RhcnQ7XG4gICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYmVmb3JlLm9wZW5TdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gYWZ0ZXIub3BlbkVuZDtcbiAgICAgICAgICAgICAgICBsZXQgY29tcExpbmUgPSB0aGlzLmNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLmJyZWFrQXRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIuY29udGVudC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUubWVyZ2UoY29tcExpbmUubGVuZ3RoLCBjb21wTGluZS5sZW5ndGgsIGFmdGVyLmNvbnRlbnRbMF0sIGZhbHNlLCBhZnRlci5vcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSBhZnRlci5jb250ZW50WzBdLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLmNvbnRlbnQuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZSgwLCAwLCBiZWZvcmUuY29udGVudFtiZWZvcmUuY29udGVudC5sZW5ndGggLSAxXSwgdHJ1ZSwgMCwgYmVmb3JlLm9wZW5FbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZS5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQuY29uY2F0KGNvbXBMaW5lKS5jb25jYXQoYWZ0ZXIuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID1cbiAgICAgICAgICAgICAgICAgICAgQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyh0b0EsIDEpO1xuICAgICAgICAgICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3Vyc29yLmZpbmRQb3MoZnJvbUEsIC0xKTtcbiAgICAgICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbilcbiAgICAgICAgICAgIHRoaXMuZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBjb21wb3NpdGlvblZpZXcoY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBUZXh0Vmlldyhjb21wb3NpdGlvbi50ZXh0Lm5vZGVWYWx1ZSk7XG4gICAgICAgIGN1ci5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovO1xuICAgICAgICBmb3IgKGxldCB7IGRlY28gfSBvZiBjb21wb3NpdGlvbi5tYXJrcylcbiAgICAgICAgICAgIGN1ciA9IG5ldyBNYXJrVmlldyhkZWNvLCBbY3VyXSwgY3VyLmxlbmd0aCk7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBsaW5lLmFwcGVuZChjdXIsIDApO1xuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9XG4gICAgZml4Q29tcG9zaXRpb25ET00oY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGZpeCA9IChkb20sIGNWaWV3KSA9PiB7XG4gICAgICAgICAgICBjVmlldy5mbGFncyB8PSA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovIHwgKGNWaWV3LmNoaWxkcmVuLnNvbWUoYyA9PiBjLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykgPyAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8gOiAwKTtcbiAgICAgICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uYWRkKGNWaWV3KTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9IGNWaWV3KVxuICAgICAgICAgICAgICAgIHByZXYuZG9tID0gbnVsbDtcbiAgICAgICAgICAgIGNWaWV3LnNldERPTShkb20pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5jaGlsZFBvcyhjb21wb3NpdGlvbi5yYW5nZS5mcm9tQiwgMSk7XG4gICAgICAgIGxldCBjVmlldyA9IHRoaXMuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICBmaXgoY29tcG9zaXRpb24ubGluZSwgY1ZpZXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gY29tcG9zaXRpb24ubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAtMTsgaS0tKSB7XG4gICAgICAgICAgICBwb3MgPSBjVmlldy5jaGlsZFBvcyhwb3Mub2ZmLCAxKTtcbiAgICAgICAgICAgIGNWaWV3ID0gY1ZpZXcuY2hpbGRyZW5bcG9zLmldO1xuICAgICAgICAgICAgZml4KGkgPj0gMCA/IGNvbXBvc2l0aW9uLm1hcmtzW2ldLm5vZGUgOiBjb21wb3NpdGlvbi50ZXh0LCBjVmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZCB8fCAhdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGFjdGl2ZUVsdCA9IHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQsIGZvY3VzZWQgPSBhY3RpdmVFbHQgPT0gdGhpcy5kb207XG4gICAgICAgIGxldCBzZWxlY3Rpb25Ob3RGb2N1cyA9ICFmb2N1c2VkICYmXG4gICAgICAgICAgICBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSkgJiYgIShhY3RpdmVFbHQgJiYgdGhpcy5kb20uY29udGFpbnMoYWN0aXZlRWx0KSk7XG4gICAgICAgIGlmICghKGZvY3VzZWQgfHwgZnJvbVBvaW50ZXIgfHwgc2VsZWN0aW9uTm90Rm9jdXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZm9yY2UgPSB0aGlzLmZvcmNlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBtYWluID0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICBsZXQgYW5jaG9yID0gdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpKTtcbiAgICAgICAgbGV0IGhlYWQgPSBtYWluLmVtcHR5ID8gYW5jaG9yIDogdGhpcy5tb3ZlVG9MaW5lKHRoaXMuZG9tQXRQb3MobWFpbi5oZWFkKSk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmICF0aGlzLmhhc0NvbXBvc2l0aW9uICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHwgKCFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkgJiYgIXRoaXMuc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UoZG9tU2VsLCBtYWluKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnZpZXcucm9vdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdTZWwpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIE5leHRUby5CZWZvcmUgKi8gfCAyIC8qIE5leHRUby5BZnRlciAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5lYXJieVRleHROb2RlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBuZXh0VG8gPT0gMSAvKiBOZXh0VG8uQmVmb3JlICovID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IERPTVBvcyh0ZXh0Lm5vZGUsIHRleHQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5iaWRpTGV2ZWwgIT0gbnVsbCAmJiByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jYXJldEJpZGlMZXZlbCA9IG1haW4uYmlkaUxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdTZWwuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSB3aWxsIGlnbm9yZSB0aGUgY2FsbCBhYm92ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZGVuLCBhbmQgdGhlbiByYWlzZSBhbiBlcnJvciBvbiB0aGUgY2FsbCB0byBleHRlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gKCM5NDApLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmV4dGVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgKElFKSB3YXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYW5jaG9yID4gbWFpbi5oZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBbaGVhZCwgYW5jaG9yXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vdEZvY3VzICYmIHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBJZiBhIHplcm8tbGVuZ3RoIHdpZGdldCBpcyBpbnNlcnRlZCBuZXh0IHRvIHRoZSBjdXJzb3IgZHVyaW5nXG4gICAgLy8gY29tcG9zaXRpb24sIGF2b2lkIG1vdmluZyBpdCBhY3Jvc3MgaXQgYW5kIGRpc3J1cHRpbmcgdGhlXG4gICAgLy8gY29tcG9zaXRpb24uXG4gICAgc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2Uoc2VsLCBjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29tcG9zaXRpb24gJiYgY3Vyc29yLmVtcHR5ICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5wb3NGcm9tRE9NKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gY3Vyc29yLmhlYWQ7XG4gICAgfVxuICAgIGVuZm9yY2VDdXJzb3JBc3NvYygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcbiAgICAgICAgLy8gc28gY2hlY2sgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5ld1JhbmdlLmFuY2hvck5vZGUsIG5ld1JhbmdlLmFuY2hvck9mZnNldCkgIT0gY3Vyc29yLmZyb20pXG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSBwb3NpdGlvbiBpcyBpbi9uZWFyIGEgYmxvY2sgd2lkZ2V0LCBtb3ZlIGl0IHRvIGEgbmVhcmJ5IHRleHRcbiAgICAvLyBsaW5lLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRoZSBjdXJzb3IgaW5zaWRlIGEgYmxvY2sgd2lkZ2V0LlxuICAgIG1vdmVUb0xpbmUocG9zKSB7XG4gICAgICAgIC8vIEJsb2NrIHdpZGdldHMgd2lsbCByZXR1cm4gcG9zaXRpb25zIGJlZm9yZS9hZnRlciB0aGVtLCB3aGljaFxuICAgICAgICAvLyBhcmUgdGh1cyBkaXJlY3RseSBpbiB0aGUgZG9jdW1lbnQgRE9NIGVsZW1lbnQuXG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbSwgbmV3UG9zO1xuICAgICAgICBpZiAocG9zLm5vZGUgIT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQ7ICFuZXdQb3MgJiYgaSA8IGRvbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQgLSAxOyAhbmV3UG9zICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3Modmlldy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQb3MgPyBuZXcgRE9NUG9zKG5ld1Bvcy5ub2RlLCBuZXdQb3Mub2Zmc2V0LCB0cnVlKSA6IHBvcztcbiAgICB9XG4gICAgbmVhcmVzdChkb20pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgICAgICBsZXQgZG9tVmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpO1xuICAgICAgICAgICAgaWYgKGRvbVZpZXcgJiYgZG9tVmlldy5yb290VmlldyA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21WaWV3O1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZWFyZXN0KG5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBmaW5kIHBvc2l0aW9uIGZvciBhIERPTSBwb3NpdGlvbiBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkgKyB2aWV3LnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgLTEpO1xuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAob2ZmIDwgY2hpbGQubGVuZ3RoIHx8IGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUF0UG9zKG9mZik7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgYmVzdCA9IG51bGwsIGJlc3RQb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIsIHN0YXJ0ID0gZW5kIC0gY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwb3MgJiYgKHN0YXJ0IDwgcG9zIHx8IGNoaWxkLmNvdmVycygtMSkpICYmIChlbmQgPiBwb3MgfHwgY2hpbGQuY292ZXJzKDEpKSAmJlxuICAgICAgICAgICAgICAgICghYmVzdCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3ICYmICEoYmVzdCBpbnN0YW5jZW9mIExpbmVWaWV3ICYmIHNpZGUgPj0gMCkpKSB7XG4gICAgICAgICAgICAgICAgYmVzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGJlc3RQb3MgPSBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0ID8gYmVzdC5jb29yZHNBdChwb3MgLSBiZXN0UG9zLCBzaWRlKSA6IG51bGw7XG4gICAgfVxuICAgIGNvb3Jkc0ZvckNoYXIocG9zKSB7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhwb3MsIDEpLCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGksIG9mZjogY2hpbGRPZmYgfSA9IGNoaWxkLmNoaWxkUG9zKG9mZiwgMSk7XG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09IGNoaWxkLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKChjaGlsZCA9IGNoaWxkLmNoaWxkcmVuW2ldKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gY2hpbGRPZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVuZCA9IGZpbmRDbHVzdGVyQnJlYWsoY2hpbGQudGV4dCwgb2ZmKTtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkLmRvbSwgb2ZmLCBlbmQpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAoaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20gJiYgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2aWV3cG9ydCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHsgZnJvbSwgdG8gfSA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgY29udGVudFdpZHRoID0gdGhpcy52aWV3LmNvbnRlbnRET00uY2xpZW50V2lkdGg7XG4gICAgICAgIGxldCBpc1dpZGVyID0gY29udGVudFdpZHRoID4gTWF0aC5tYXgodGhpcy52aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCwgdGhpcy5taW5XaWR0aCkgKyAxO1xuICAgICAgICBsZXQgd2lkZXN0ID0gLTEsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkUmVjdCA9IGNoaWxkLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZFJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWRlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGNoaWxkLmRvbS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0cyA9IGxhc3QgPyBjbGllbnRSZWN0c0ZvcihsYXN0KSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gbHRyID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0IDogY2hpbGRSZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID4gd2lkZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZXN0ID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRleHREaXJlY3Rpb25BdChwb3MpIHtcbiAgICAgICAgbGV0IHsgaSB9ID0gdGhpcy5jaGlsZFBvcyhwb3MsIDEpO1xuICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNoaWxkcmVuW2ldLmRvbSkuZGlyZWN0aW9uID09IFwicnRsXCIgPyBEaXJlY3Rpb24uUlRMIDogRGlyZWN0aW9uLkxUUjtcbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykge1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlID0gY2hpbGQubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHdvcmthYmxlIGxpbmUgZXhpc3RzLCBmb3JjZSBhIGxheW91dCBvZiBhIG1lYXN1cmFibGUgZWxlbWVudFxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQ7XG4gICAgICAgIGR1bW15LmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICBkdW1teS5zdHlsZS53aWR0aCA9IFwiOTk5OTlweFwiO1xuICAgICAgICBkdW1teS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgZHVtbXkudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiO1xuICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgICAgICAgIGxldCByZWN0ID0gY2xpZW50UmVjdHNGb3IoZHVtbXkuZmlyc3RDaGlsZClbMF07XG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZHVtbXkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgY2hhcldpZHRoID0gcmVjdCA/IHJlY3Qud2lkdGggLyAyNyA6IDc7XG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gcmVjdCA/IHJlY3QuaGVpZ2h0IDogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGR1bW15LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0IH07XG4gICAgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIE1vdmUgYmFjayB0byBzdGFydCBvZiBsYXN0IGVsZW1lbnQgd2hlbiBwb3NzaWJsZSwgc28gdGhhdFxuICAgICAgICAvLyBgQ2hpbGRDdXJzb3IuZmluZFBvc2AgZG9lc24ndCBoYXZlIHRvIGRlYWwgd2l0aCB0aGUgZWRnZSBjYXNlXG4gICAgICAgIC8vIG9mIGJlaW5nIGFmdGVyIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICAgIGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgICAgcG9zIC09IHRoaXMuY2hpbGRyZW5bLS1pXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCBpKTtcbiAgICB9XG4gICAgY29tcHV0ZUJsb2NrR2FwRGVjbygpIHtcbiAgICAgICAgbGV0IGRlY28gPSBbXSwgdnMgPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHZzLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogdnMudmlld3BvcnRzW2ldO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb20gLSAxIDogdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9ICh2cy5saW5lQmxvY2tBdChlbmQpLmJvdHRvbSAtIHZzLmxpbmVCbG9ja0F0KHBvcykudG9wKSAvIHRoaXMudmlldy5zY2FsZVk7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQmxvY2tHYXA6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgbGV0IGFsbERlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLm1hcCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IGR5bmFtaWMgPSB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGR5bmFtaWNPdXRlciA9IGZhbHNlLCBvdXRlckRlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQob3V0ZXJEZWNvcmF0aW9ucykubWFwKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIGlmIChkeW5hbWljKVxuICAgICAgICAgICAgICAgIGR5bmFtaWNPdXRlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pYyA/IGQodGhpcy52aWV3KSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0ZXJEZWNvLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFthbGxEZWNvLmxlbmd0aF0gPSBkeW5hbWljT3V0ZXI7XG4gICAgICAgICAgICBhbGxEZWNvLnB1c2goUmFuZ2VTZXQuam9pbihvdXRlckRlY28pKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gYWxsRGVjby5sZW5ndGg7IGkgPCBhbGxEZWNvLmxlbmd0aCArIDM7IGkrKylcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaV0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi5hbGxEZWNvLFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQmxvY2tHYXBEZWNvKCksXG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVHYXBEZWNvXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCkge1xuICAgICAgICBpZiAodGFyZ2V0LmlzU25hcHNob3QpIHtcbiAgICAgICAgICAgIGxldCByZWYgPSB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KHRhcmdldC5yYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gcmVmLnRvcCAtIHRhcmdldC55TWFyZ2luO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ID0gdGFyZ2V0LnhNYXJnaW47XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHRhcmdldDtcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmhlYWQsIHJhbmdlLmVtcHR5ID8gcmFuZ2UuYXNzb2MgOiByYW5nZS5oZWFkID4gcmFuZ2UuYW5jaG9yID8gLTEgOiAxKSwgb3RoZXI7XG4gICAgICAgIGlmICghcmVjdClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSAmJiAob3RoZXIgPSB0aGlzLmNvb3Jkc0F0KHJhbmdlLmFuY2hvciwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IC0xIDogMSkpKVxuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogTWF0aC5taW4ocmVjdC5sZWZ0LCBvdGhlci5sZWZ0KSwgdG9wOiBNYXRoLm1pbihyZWN0LnRvcCwgb3RoZXIudG9wKSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgocmVjdC5yaWdodCwgb3RoZXIucmlnaHQpLCBib3R0b206IE1hdGgubWF4KHJlY3QuYm90dG9tLCBvdGhlci5ib3R0b20pIH07XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgdGFyZ2V0UmVjdCA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIG1hcmdpbnMubGVmdCwgdG9wOiByZWN0LnRvcCAtIG1hcmdpbnMudG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtYXJnaW5zLnJpZ2h0LCBib3R0b206IHJlY3QuYm90dG9tICsgbWFyZ2lucy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gdGhpcy52aWV3LnNjcm9sbERPTTtcbiAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMudmlldy5zY3JvbGxET00sIHRhcmdldFJlY3QsIHJhbmdlLmhlYWQgPCByYW5nZS5hbmNob3IgPyAtMSA6IDEsIHRhcmdldC54LCB0YXJnZXQueSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnhNYXJnaW4sIG9mZnNldFdpZHRoKSwgLW9mZnNldFdpZHRoKSwgTWF0aC5tYXgoTWF0aC5taW4odGFyZ2V0LnlNYXJnaW4sIG9mZnNldEhlaWdodCksIC1vZmZzZXRIZWlnaHQpLCB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiZXR3ZWVuVW5lZGl0YWJsZShwb3MpIHtcbiAgICByZXR1cm4gcG9zLm5vZGUubm9kZVR5cGUgPT0gMSAmJiBwb3Mubm9kZS5maXJzdENoaWxkICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IDAgfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gcG9zLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGggfHwgcG9zLm5vZGUuY2hpbGROb2Rlc1twb3Mub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWdhcFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuaGVpZ2h0OyB9XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSBoZWFkUG9zIC0gdGV4dE5vZGUub2Zmc2V0O1xuICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgdGV4dE5vZGUubm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBub2RlOiB0ZXh0Tm9kZS5ub2RlIH07XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25SYW5nZSh2aWV3LCBjaGFuZ2VzLCBoZWFkUG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBub2RlOiB0ZXh0Tm9kZSwgZnJvbSwgdG8gfSA9IGZvdW5kLCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgIC8vIERvbid0IHRyeSB0byBwcmVzZXJ2ZSBtdWx0aS1saW5lIGNvbXBvc2l0aW9uc1xuICAgIGlmICgvW1xcblxccl0vLnRlc3QodGV4dCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmb3VuZC5mcm9tLCBmb3VuZC50bykgIT0gdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGludiA9IGNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgIGxldCByYW5nZSA9IG5ldyBDaGFuZ2VkUmFuZ2UoaW52Lm1hcFBvcyhmcm9tKSwgaW52Lm1hcFBvcyh0byksIGZyb20sIHRvKTtcbiAgICBsZXQgbWFya3MgPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlOzsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IHBhcmVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IHBhcmVudFZpZXcubWFyayB9KTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIExpbmVWaWV3IHx8IHBhcmVudC5ub2RlTmFtZSA9PSBcIkRJVlwiICYmIHBhcmVudC5wYXJlbnROb2RlID09IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB0ZXh0Tm9kZSwgbWFya3MsIGxpbmU6IHBhcmVudCB9O1xuICAgICAgICBlbHNlIGlmIChwYXJlbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogbmV3IE1hcmtEZWNvcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBnZXRBdHRycyhwYXJlbnQpLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIHNpZGUpIHtcbiAgICBpZiAoc2lkZSA8PSAwKVxuICAgICAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBvZmZzZXQgPSBzdGFydE9mZnNldDs7KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNpZGUgPj0gMClcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XG4gICAgICAgIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAyIC8qIE5leHRUby5BZnRlciAqLyA6IDApO1xufVxubGV0IERlY29yYXRpb25Db21wYXJhdG9yJDEgPSBjbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn07XG5mdW5jdGlvbiBmaW5kQ2hhbmdlZERlY28oYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvdWNoZXNDb21wb3NpdGlvbihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPCBjb21wb3NpdGlvbi50byAmJiB0byA+IGNvbXBvc2l0aW9uLmZyb20pXG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGVkO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gZHkgPyAoeSA8IHJlY3QudG9wID8gLTEgOiAxKSA6IGR4ID8gKHggPCByZWN0LmxlZnQgPyAtMSA6IDEpIDogMDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFzaWRlIHx8IChzaWRlID4gMCA/IGkgPCByZWN0cy5sZW5ndGggLSAxIDogaSA+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmIChjbG9zZXN0T3ZlcmxhcCAmJiBjbG9zZXN0LmNvbnRlbnRFZGl0YWJsZSAhPSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMsIHByZWNpc2UsIGJpYXMgPSAtMSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeyB4LCB5IH0gPSBjb29yZHMsIHlPZmZzZXQgPSB5IC0gZG9jVG9wO1xuICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHlPZmZzZXQgPiBkb2NIZWlnaHQpXG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxuICAgIGZvciAobGV0IGhhbGZMaW5lID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChub2RlKTtcbiAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChuZWFyZXN0LmlzV2lkZ2V0ICYmICgoX2IgPSBuZWFyZXN0LmRvbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vZGVUeXBlKSA9PSAxKSB7XG4gICAgICAgIGxldCByZWN0ID0gbmVhcmVzdC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBjb29yZHMueSA8IHJlY3QudG9wIHx8IGNvb3Jkcy55IDw9IHJlY3QuYm90dG9tICYmIGNvb3Jkcy54IDw9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDJcbiAgICAgICAgICAgID8gbmVhcmVzdC5wb3NBdFN0YXJ0IDogbmVhcmVzdC5wb3NBdEVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgbmVhcmVzdC5wb3NBdFN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnRSZWN0LCBibG9jaywgeCwgeSkge1xuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZyAmJiBibG9jay5oZWlnaHQgPiB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lID0gTWF0aC5mbG9vcigoeSAtIGJsb2NrLnRvcCAtICh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdGV4dEhlaWdodCkgKiAwLjUpIC8gdGV4dEhlaWdodCk7XG4gICAgICAgIGludG8gKz0gbGluZSAqIHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xuICAgIHJldHVybiBibG9jay5mcm9tICsgZmluZENvbHVtbihjb250ZW50LCBpbnRvLCB2aWV3LnN0YXRlLnRhYlNpemUpO1xufVxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXG4vLyB0aGUgc3BhY2UgYmV0d2VlbiBsaW5lcyBhcyBiZWxvbmdpbmcgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gbGluZSBiZWZvcmUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3Qgc3VjaCBhIHJlc3VsdCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBsZXQgbGVuO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7IG5leHQ7IG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKVxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0ZXh0UmFuZ2Uobm9kZSwgbGVuIC0gMSwgbGVuKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4geDtcbn1cbi8vIENocm9tZSB3aWxsIG1vdmUgcG9zaXRpb25zIGJldHdlZW4gbGluZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGxpbmVcbmZ1bmN0aW9uIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGlmIChvZmZzZXQgIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLnRvID4gcG9zIHx8IGwudG8gPT0gcG9zICYmIChsLnRvID09IGxpbmUudG8gfHwgbC50eXBlID09IEJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gdmlldy52aXN1YWxMaW5lU2lkZShsaW5lLCAhZm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyB8fCAtMSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJSZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICAgICAgICAgIGxldCBhc3NvYyA9ICFjaGFyUmVjdCB8fCBjdXJZIDwgY2hhclJlY3QudG9wID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBhc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHBvcywgYmlhcykge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MgLSAxLCBwb3MgKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBtb3ZlZCB8fCBiaWFzIHx8IChwb3MgLSBmcm9tIDwgdG8gLSBwb3MgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzaWRlIDwgMCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSBzaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBuZXdQb3MgPSBza2lwQXRvbWljUmFuZ2VzKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLmZyb20sIG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyAtMSA6IDEpO1xuICAgIHJldHVybiBuZXdQb3MgPT0gcG9zLmZyb20gPyBwb3MgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgbmV3UG9zIDwgcG9zLmZyb20gPyAxIDogLTEpO1xufVxuXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbmV4dCBjaGFuZ2Ugc2hvdWxkIGJlIG1hcmtlZCBhcyBzdGFydGluZyB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gKG51bGwgbWVhbnMgbm8gY29tcG9zaXRpb24sIHRydWUgbWVhbnMgbmV4dCBpcyB0aGVcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uKVxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAvLyBFbmQgdGltZSBvZiB0aGUgcHJldmlvdXMgY29tcG9zaXRpb25cbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAvLyBVc2VkIGluIGEga2x1ZGdlIHRvIGRldGVjdCB3aGVuIGFuIEVudGVyIGtleXByZXNzIHNob3VsZCBiZVxuICAgICAgICAvLyBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uIG9uIFNhZmFyaSwgd2hpY2ggZmlyZXMgZXZlbnRzXG4gICAgICAgIC8vIGluIHRoZSB3cm9uZyBvcmRlclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIHRvIGNhdGVnb3JpemUgY2hhbmdlcyBhcyBwYXJ0IG9mIGEgY29tcG9zaXRpb24sIGV2ZW4gd2hlblxuICAgICAgICAvLyB0aGUgbXV0YXRpb24gZXZlbnRzIGZpcmUgc2hvcnRseSBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFdoZW4gYSBkcmFnIGZyb20gdGhlIGVkaXRvciBpcyBhY3RpdmUsIHRoaXMgcG9pbnRzIGF0IHRoZSByYW5nZVxuICAgICAgICAvLyBiZWluZyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvKVxuICAgICAgICAgICAgZmlyZWZveENvcHlDdXRIYWNrKHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih0aGlzLnZpZXcsIGV2ZW50KSB8fCB0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ydW5IYW5kbGVycyhldmVudC50eXBlLCBldmVudCk7XG4gICAgfVxuICAgIHJ1bkhhbmRsZXJzKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JzZXJ2ZXIgb2YgaGFuZGxlcnMub2JzZXJ2ZXJzKVxuICAgICAgICAgICAgICAgIG9ic2VydmVyKHRoaXMudmlldywgZXZlbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycy5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnMocGx1Z2lucykge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSBjb21wdXRlSGFuZGxlcnMocGx1Z2lucyksIHByZXYgPSB0aGlzLmhhbmRsZXJzLCBkb20gPSB0aGlzLnZpZXcuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFzc2l2ZSA9ICFoYW5kbGVyc1t0eXBlXS5oYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHByZXZbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cyAmJiBwYXNzaXZlICE9ICFleGlzdHMuaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCwgeyBwYXNzaXZlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHByZXYpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiICYmICFoYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBrZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIE11c3QgYWx3YXlzIHJ1biwgZXZlbiBpZiBhIGN1c3RvbSBoYW5kbGVyIGhhbmRsZWQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAmJiBEYXRlLm5vdygpIDwgdGhpcy5sYXN0RXNjUHJlc3MgKyAyMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9IDI3ICYmIG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KGV2ZW50LmtleSwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIEVudGVyIG9uIGlPUyBtYWtlcyB0aGVcbiAgICAgICAgLy8gdmlydHVhbCBrZXlib2FyZCBnZXQgc3R1Y2sgaW4gdGhlIHdyb25nIChsb3dlcmNhc2UpXG4gICAgICAgIC8vIHN0YXRlLiBTbyB3ZSBsZXQgaXQgZ28gdGhyb3VnaCwgYW5kIHRoZW4sIGluXG4gICAgICAgIC8vIGFwcGx5RE9NQ2hhbmdlLCBub3RpZnkga2V5IGhhbmRsZXJzIG9mIGl0IGFuZCByZXNldCB0b1xuICAgICAgICAvLyB0aGUgc3RhdGUgdGhleSBwcm9kdWNlLlxuICAgICAgICBsZXQgcGVuZGluZztcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmICFldmVudC5zeW50aGV0aWMgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgICAgICAgKChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmtleUNvZGUgPT0gZXZlbnQua2V5Q29kZSkpICYmICFldmVudC5jdHJsS2V5IHx8XG4gICAgICAgICAgICAgICAgRW1hY3N5UGVuZGluZ0tleXMuaW5kZXhPZihldmVudC5rZXkpID4gLTEgJiYgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSBwZW5kaW5nIHx8IGV2ZW50O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoSU9TS2V5KCksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KCkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodGhpcy52aWV3LmNvbnRlbnRET00sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICB9XG4gICAgaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCEvXmtleS8udGVzdChldmVudC50eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgICAgIC8vIE9uIHNvbWUgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gY29uZmlybSBjaGFyYWN0ZXIgc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCxcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgLy8gd3Jvbmcgb3JkZXIuIFRoZSBrZXkgZXZlbnQgc2hvdWxkIHN0aWxsIGJlIGlnbm9yZWQsIGV2ZW4gd2hlblxuICAgICAgICAvLyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudC5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZENvbnRlbnQgJiYgdXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gdGhpcy5kcmFnZ2VkQ29udGVudC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmluZEhhbmRsZXIocGx1Z2luLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChwbHVnaW4sIGV2ZW50LCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gcmVjb3JkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFt0eXBlXSB8fCAocmVzdWx0W3R5cGVdID0geyBvYnNlcnZlcnM6IFtdLCBoYW5kbGVyczogW10gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGxldCBzcGVjID0gcGx1Z2luLnNwZWM7XG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuZG9tRXZlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50SGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2goYmluZEhhbmRsZXIocGx1Z2luLnZhbHVlLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGhhbmRsZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIG9ic2VydmVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKG9ic2VydmVyc1t0eXBlXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFBlbmRpbmdLZXlzID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBrZXlDb2RlOiA4LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydFBhcmFncmFwaFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRMaW5lQnJlYWtcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmNvbnN0IGRyYWdTY3JvbGxNYXJnaW4gPSA2O1xuZnVuY3Rpb24gZHJhZ1Njcm9sbFNwZWVkKGRpc3QpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGlzdCkgKiAwLjcgKyA4O1xufVxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGEuY2xpZW50WCAtIGIuY2xpZW50WCksIE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSkpO1xufVxuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlLCBtdXN0U2VsZWN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gbXVzdFNlbGVjdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgZGlzdCh0aGlzLnN0YXJ0RXZlbnQsIGV2ZW50KSA8IDEwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCA9IGV2ZW50KTtcbiAgICAgICAgbGV0IHN4ID0gMCwgc3kgPSAwO1xuICAgICAgICBsZXQgcmVjdCA9ICgoX2EgPSB0aGlzLnNjcm9sbFBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuICAgICAgICAgICAgfHwgeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB0aGlzLnZpZXcud2luLmlubmVyV2lkdGgsIGJvdHRvbTogdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggLSBtYXJnaW5zLmxlZnQgPD0gcmVjdC5sZWZ0ICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LmxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmVjdC5yaWdodCAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIC0gbWFyZ2lucy50b3AgPD0gcmVjdC50b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHJlY3QudG9wIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgKyBtYXJnaW5zLmJvdHRvbSA+PSByZWN0LmJvdHRvbSAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gcmVjdC5ib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICs9IHRoaXMuc2Nyb2xsU3BlZWQueDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArPSB0aGlzLnNjcm9sbFNwZWVkLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHRoaXMuc2Nyb2xsU3BlZWQueCwgdGhpcy5zY3JvbGxTcGVlZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNraXBBdG9tcyhzZWwpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsLnJhbmdlc1tpXSwgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICE9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLnRvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSByYW5nZS5mcm9tIHx8IHRvICE9IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20gPT0gcmFuZ2UuYW5jaG9yID8gZnJvbSA6IHRvLCByYW5nZS5mcm9tID09IHJhbmdlLmhlYWQgPyBmcm9tIDogdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gc2VsLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcyA/IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSA6IHNlbDtcbiAgICB9XG4gICAgc2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbGVjdGlvbiA9IHRoaXMuc2tpcEF0b21zKHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSkpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3QucG9pbnRlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgKChjVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKSkgJiYgY1ZpZXcuaWdub3JlRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGhhbmRsZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBvYnNlcnZlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbm9ic2VydmVycy5zY3JvbGwgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xufTtcbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xub2JzZXJ2ZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xub2JzZXJ2ZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gIXZpZXcuaGFzRm9jdXM7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xuICAgICAgICBpZiAobXVzdEZvY3VzKVxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSkpO1xuICAgICAgICBsZXQgbW91c2VTZWwgPSB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb247XG4gICAgICAgIGlmIChtb3VzZVNlbCkge1xuICAgICAgICAgICAgbW91c2VTZWwuc3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlU2VsLmRyYWdnaW5nID09PSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gcmFuZ2VGb3JDbGljayh2aWV3LCBwb3MsIGJpYXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSAxKSB7IC8vIFNpbmdsZSBjbGlja1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09IDIpIHsgLy8gRG91YmxlIGNsaWNrXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUcmlwbGUgY2xpY2tcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5sZXQgaW5zaWRlWSA9ICh5LCByZWN0KSA9PiB5ID49IHJlY3QudG9wICYmIHkgPD0gcmVjdC5ib3R0b207XG5sZXQgaW5zaWRlID0gKHgsIHksIHJlY3QpID0+IGluc2lkZVkoeSwgcmVjdCkgJiYgeCA+PSByZWN0LmxlZnQgJiYgeCA8PSByZWN0LnJpZ2h0O1xuLy8gVHJ5IHRvIGRldGVybWluZSwgZm9yIHRoZSBnaXZlbiBjb29yZGluYXRlcywgYXNzb2NpYXRlZCB3aXRoIHRoZVxuLy8gZ2l2ZW4gcG9zaXRpb24sIHdoZXRoZXIgdGhleSBhcmUgcmVsYXRlZCB0byB0aGUgZWxlbWVudCBiZWZvcmUgb3Jcbi8vIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCB4LCB5KSB7XG4gICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKTtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBvZmYgPSBwb3MgLSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgLy8gTGluZSBib3VuZGFyaWVzIHBvaW50IGludG8gdGhlIGxpbmVcbiAgICBpZiAob2ZmID09IDApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChvZmYgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAvLyBQb3NpdGlvbnMgb24gdG9wIG9mIGFuIGVsZW1lbnQgcG9pbnQgYXQgdGhhdCBlbGVtZW50XG4gICAgbGV0IGJlZm9yZSA9IGxpbmUuY29vcmRzQXQob2ZmLCAtMSk7XG4gICAgaWYgKGJlZm9yZSAmJiBpbnNpZGUoeCwgeSwgYmVmb3JlKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBhZnRlciA9IGxpbmUuY29vcmRzQXQob2ZmLCAxKTtcbiAgICBpZiAoYWZ0ZXIgJiYgaW5zaWRlKHgsIHksIGFmdGVyKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGxpbmUgd3JhcCBwb2ludC4gUGljayBiZWZvcmUgaWYgdGhlIHBvaW50IGlzXG4gICAgLy8gYmVzaWRlIGl0LlxuICAgIHJldHVybiBiZWZvcmUgJiYgaW5zaWRlWSh5LCBiZWZvcmUpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIHJldHVybiB7IHBvcywgYmlhczogZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpIH07XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgcmVtb3ZlZDtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgdHlwZSA9PSAxICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIChyZW1vdmVkID0gcmVtb3ZlUmFuZ2VBcm91bmQoc3RhcnRTZWwsIGN1ci5wb3MpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2VBcm91bmQoc2VsLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogcmFuZ2UgfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoY1ZpZXcgJiYgY1ZpZXcuaXNXaWRnZXQpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY1ZpZXcucG9zQXRTdGFydCwgdG8gPSBmcm9tICsgY1ZpZXcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgaW5wdXRTdGF0ZSB9ID0gdmlldztcbiAgICBpZiAoaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IHRydWU7XG4gICAgaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IHJhbmdlO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHZpZXcuc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCB7IGRyYWdnZWRDb250ZW50IH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBkcmFnZ2VkQ29udGVudCAmJiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpXG4gICAgICAgID8geyBmcm9tOiBkcmFnZ2VkQ29udGVudC5mcm9tLCB0bzogZHJhZ2dlZENvbnRlbnQudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktdGV4dFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogY29udGVudC5qb2luKHN0YXRlLmxpbmVCcmVhayksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBnZXRFZmZlY3Qgb2Ygc3RhdGUuZmFjZXQoZm9jdXNDaGFuZ2VFZmZlY3QpKSB7XG4gICAgICAgIGxldCBlZmZlY3QgPSBnZXRFZmZlY3Qoc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgaWYgKGVmZmVjdClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cyA/IHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHMsIGFubm90YXRpb25zOiBpc0ZvY3VzQ2hhbmdlLm9mKHRydWUpIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24odmlldy5zdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfVxuICAgIH0sIDEwKTtcbn1cbm9ic2VydmVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24sIG1vdmUgaXQgYmFjayB0byB3aGVyZSBpdCB3YXNcbiAgICBpZiAoIXZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAmJiAodmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgfHwgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0KSkge1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25zdGFydCA9IG9ic2VydmVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9PSBudWxsKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSB0cnVlO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSB2aWV3Lm9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID4gMDtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCkge1xuICAgICAgICAvLyBEZWxheSBmbHVzaGluZyBmb3IgYSBiaXQgb24gQW5kcm9pZCBiZWNhdXNlIGl0J2xsIG9mdGVuIGZpcmUgYVxuICAgICAgICAvLyBidW5jaCBvZiBjb250cmFkaWN0b3J5IGNoYW5nZXMgaW4gYSByb3cgYXQgZW5kIG9mIGNvbXBvc2l0b25cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBwZW5kaW5nIHJlY29yZHMsIHNjaGVkdWxlIGEgZmx1c2guXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5vYnNlcnZlci5mbHVzaCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSBzdXJlIHRoYXQsIGlmIG5vIGNoYW5nZXMgY29tZSBpbiBzb29uLCB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gdmlldyBpcyBjbGVhcmVkLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFwcGxpZWRGaXJlZm94SGFjayA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0O1xuLy8gSW4gRmlyZWZveCwgd2hlbiBjdXQvY29weSBoYW5kbGVycyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LCB0aGF0XG4vLyBzb21laG93IGF2b2lkcyBhIGJ1ZyB3aGVyZSB0aG9zZSBldmVudHMgYXJlbid0IGZpcmVkIHdoZW4gdGhlXG4vLyBzZWxlY3Rpb24gaXMgZW1wdHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzEwODJcbi8vIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05OTU5NjFcbmZ1bmN0aW9uIGZpcmVmb3hDb3B5Q3V0SGFjayhkb2MpIHtcbiAgICBpZiAoIWFwcGxpZWRGaXJlZm94SGFjay5oYXMoZG9jKSkge1xuICAgICAgICBhcHBsaWVkRmlyZWZveEhhY2suYWRkKGRvYyk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCAoKSA9PiB7IH0pO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCAoKSA9PiB7IH0pO1xuICAgIH1cbn1cblxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbmNsYXNzIEhlaWdodE9yYWNsZSB7XG4gICAgY29uc3RydWN0b3IobGluZVdyYXBwaW5nKSB7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmRvYyA9IFRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiBhbiBlbnRpcmUgbGluZSAobGluZS1oZWlnaHQpXG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIGFjdHVhbCBmb250IChmb250LXNpemUpXG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IDMwO1xuICAgICAgICAvLyBVc2VkIHRvIHRyYWNrLCBkdXJpbmcgdXBkYXRlSGVpZ2h0LCBpZiBhbnkgYWN0dWFsIGhlaWdodHMgY2hhbmdlZFxuICAgICAgICB0aGlzLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaGVpZ2h0Rm9yR2FwKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIGxpbmVzICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoKHRvIC0gZnJvbSkgLSAobGluZXMgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpKSAvIHRoaXMubGluZUxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZSBsaW5lIGJyZWFrcyBmb3JcbiAgICB0ZXh0IGJsb2Nrcy5cbiAgICAqL1xuICAgIF9jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBfY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IEJsb2NrVHlwZS5UZXh0IDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogdGhpcy5fY29udGVudC50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB3aWRnZXQgYmxvY2ssIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdpZGdldFxuICAgIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50IGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uID8gdGhpcy5fY29udGVudC53aWRnZXQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgdGV4dGJsb2NrLCB0aGlzIGhvbGRzIHRoZSBudW1iZXIgb2YgbGluZSBicmVha3NcbiAgICB0aGF0IGFwcGVhciBpbiB3aWRnZXRzIGluc2lkZSB0aGUgYmxvY2suXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0TGluZUJyZWFrcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyB0aGlzLl9jb250ZW50IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gKEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLl9jb250ZW50KSA/IG90aGVyLl9jb250ZW50IDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgY29udGVudCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KG9yYWNsZSwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDApOyB9XG4gICAgLy8gbm9kZXMgdXNlcyBudWxsIHZhbHVlcyB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb2YgbGluZSBicmVha3MuXG4gICAgLy8gVGhlcmUgYXJlIG5ldmVyIGxpbmUgYnJlYWtzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGFycmF5LCBvclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAgIC8vIHRvIGJlIGVtcHR5IChzYW1lIHJlc3RyaWN0aW9ucyBhcyByZXR1cm4gdmFsdWUgZnJvbSB0aGUgYnVpbGRlcikuXG4gICAgc3RhdGljIG9mKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoLCBiZWZvcmUgPSAwLCBhZnRlciA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID4gYWZ0ZXIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMSArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPiBiZWZvcmUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDIgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBhZnRlciArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJyayA9IDA7XG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2Rlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0TWFwQnJhbmNoKEhlaWdodE1hcC5vZihub2Rlcy5zbGljZSgwLCBpKSksIGJyaywgSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKGopKSk7XG4gICAgfVxufVxuSGVpZ2h0TWFwLnByb3RvdHlwZS5zaXplID0gMTtcbmNsYXNzIEhlaWdodE1hcEJsb2NrIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCwgZGVjbykge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVjbyA9IGRlY287XG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy5kZWNvIHx8IDApO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBpZiAoZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiB0byA+PSBvZmZzZXQpXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIF9mb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcFRleHQgZXh0ZW5kcyBIZWlnaHRNYXBCbG9jayB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IDA7IC8vIEFtb3VudCBvZiBjb2xsYXBzZWQgY29udGVudCBpbiB0aGUgbGluZVxuICAgICAgICB0aGlzLndpZGdldEhlaWdodCA9IDA7IC8vIE1heGltdW0gaW5saW5lIHdpZGdldCBoZWlnaHRcbiAgICAgICAgdGhpcy5icmVha3MgPSAwOyAvLyBOdW1iZXIgb2Ygd2lkZ2V0LWludHJvZHVjZWQgbGluZSBicmVha3Mgb24gdGhlIGxpbmVcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLmJyZWFrcyk7XG4gICAgfVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5sZW5ndGggLSBub2RlLmxlbmd0aCkgPCAxMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgICAgICBub2RlLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSArXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3MgKiBvcmFjbGUubGluZUhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYGxpbmUoJHt0aGlzLmxlbmd0aH0ke3RoaXMuY29sbGFwc2VkID8gLXRoaXMuY29sbGFwc2VkIDogXCJcIn0ke3RoaXMud2lkZ2V0SGVpZ2h0ID8gXCI6XCIgKyB0aGlzLndpZGdldEhlaWdodCA6IFwiXCJ9KWA7XG4gICAgfVxufVxuY2xhc3MgSGVpZ2h0TWFwR2FwIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxuICAgIGhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCkubnVtYmVyLCBsYXN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCArIHRoaXMubGVuZ3RoKS5udW1iZXI7XG4gICAgICAgIGxldCBsaW5lcyA9IGxhc3RMaW5lIC0gZmlyc3RMaW5lICsgMTtcbiAgICAgICAgbGV0IHBlckxpbmUsIHBlckNoYXIgPSAwO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IHRvdGFsUGVyTGluZSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCBvcmFjbGUubGluZUhlaWdodCAqIGxpbmVzKTtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0b3RhbFBlckxpbmUgLyBsaW5lcztcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IGxpbmVzICsgMSlcbiAgICAgICAgICAgICAgICBwZXJDaGFyID0gKHRoaXMuaGVpZ2h0IC0gdG90YWxQZXJMaW5lKSAvICh0aGlzLmxlbmd0aCAtIGxpbmVzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJMaW5lID0gdGhpcy5oZWlnaHQgLyBsaW5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ3Vlc3MgPSBvZmZzZXQgKyBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChoZWlnaHQgLSB0b3ApIC8gdGhpcy5oZWlnaHQpKSAqIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQoZ3Vlc3MpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgICAgIGxldCBsaW5lVG9wID0gTWF0aC5tYXgodG9wLCBoZWlnaHQgLSBsaW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGFzdExpbmUgLSBmaXJzdExpbmUsIE1hdGguZmxvb3IoKGhlaWdodCAtIHRvcCkgLyBwZXJMaW5lKSkpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBvcmFjbGUuZG9jLmxpbmUoZmlyc3RMaW5lICsgbGluZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIHBlckxpbmUgKiBsaW5lLCBwZXJMaW5lLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgdG8gLSBmcm9tLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgbGV0IGxpbmVUb3AgPSB0b3AgKyBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAobGluZS5mcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIE1hdGgubWF4KHRvcCwgTWF0aC5taW4obGluZVRvcCwgdG9wICsgdGhpcy5oZWlnaHQgLSBsaW5lSGVpZ2h0KSksIGxpbmVIZWlnaHQsIDApO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoZnJvbSwgb2Zmc2V0KTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpO1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb20sIGxpbmVUb3AgPSB0b3A7IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lc0Fib3ZlID0gbGluZS5udW1iZXIgLSBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgbGluZVRvcCArPSBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAoZnJvbSAtIG9mZnNldCAtIGxpbmVzQWJvdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgcGVyQ2hhciAqIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgZihuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApKTtcbiAgICAgICAgICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMubGVuZ3RoIC0gdG87XG4gICAgICAgIGlmIChhZnRlciA+IDApIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG5ldyBIZWlnaHRNYXBHYXAobGFzdC5sZW5ndGggKyBhZnRlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGFmdGVyIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbMF0gPSBuZXcgSGVpZ2h0TWFwR2FwKGZyb20gKyBmaXJzdC5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobmV3IEhlaWdodE1hcEdhcChmcm9tIC0gMSksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IEhlaWdodE1hcEdhcCh0byAtIDEpLCBudWxsKTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAodGhpcy5sZW5ndGggLSBmcm9tIC0gMSkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gcGFydCBvZiB0aGlzIGdhcCB3aXRoIG1lYXN1cmVkIGxpbmVzLiBXZSBrbm93IHRoZXJlXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSB3aWRnZXRzIG9yIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhvc2UgbGluZXMsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZXkgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGhlaWdodG1hcCAoZ2Fwc1xuICAgICAgICAgICAgLy8gb25seSBjb250YWluIHBsYWluIHRleHQpLlxuICAgICAgICAgICAgbGV0IG5vZGVzID0gW10sIHBvcyA9IE1hdGgubWF4KG9mZnNldCwgbWVhc3VyZWQuZnJvbSksIHNpbmdsZUhlaWdodCA9IC0xO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwR2FwKG1lYXN1cmVkLmZyb20gLSBvZmZzZXQgLSAxKS51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPD0gZW5kICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSAtMjtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KGxlbiwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChlbmQgLSBwb3MpLnVwZGF0ZUhlaWdodChvcmFjbGUsIHBvcykpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0IDwgMCB8fCBNYXRoLmFicyhyZXN1bHQuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpID49IEVwc2lsb24gfHxcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzaW5nbGVIZWlnaHQgLSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpLnBlckxpbmUpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG9yYWNsZS5oZWlnaHRGb3JHYXAob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBnYXAoJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwQnJhbmNoIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCBicmssIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlZnQubGVuZ3RoICsgYnJrICsgcmlnaHQubGVuZ3RoLCBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCwgYnJrIHwgKGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGJyZWFrKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDEgLyogRmxhZy5CcmVhayAqLzsgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBtaWQgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaGVpZ2h0IDwgbWlkID8gdGhpcy5sZWZ0LmJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIG1pZCwgb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWspO1xuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgbGV0IGxlZnQgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodCA/IHZhbHVlIDwgcmlnaHRUb3AgOiB2YWx1ZSA8IHJpZ2h0T2Zmc2V0O1xuICAgICAgICBsZXQgYmFzZSA9IGxlZnQgPyB0aGlzLmxlZnQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayB8fCAobGVmdCA/IGJhc2UudG8gPCByaWdodE9mZnNldCA6IGJhc2UuZnJvbSA+IHJpZ2h0T2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgc3ViUXVlcnkgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0ID8gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgOiBRdWVyeVR5cGUuQnlQb3M7XG4gICAgICAgIGlmIChsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuam9pbih0aGlzLnJpZ2h0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCB0b3AsIG9mZnNldCkuam9pbihiYXNlKTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmICh0byA+PSByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gdGhpcy5saW5lQXQocmlnaHRPZmZzZXQsIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IG1pZC5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCBtaWQuZnJvbSAtIDEsIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKG1pZC50byA+PSBmcm9tICYmIG1pZC5mcm9tIDw9IHRvKVxuICAgICAgICAgICAgICAgIGYobWlkKTtcbiAgICAgICAgICAgIGlmICh0byA+IG1pZC50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKG1pZC50byArIDEsIHRvLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRvIDwgcmlnaHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdC5yZXBsYWNlKGZyb20sIHRvLCBub2RlcyksIHRoaXMucmlnaHQpO1xuICAgICAgICBpZiAoZnJvbSA+IHRoaXMubGVmdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQsIHRoaXMucmlnaHQucmVwbGFjZShmcm9tIC0gcmlnaHRTdGFydCwgdG8gLSByaWdodFN0YXJ0LCBub2RlcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlTGVmdChmcm9tLCByZXN1bHQpO1xuICAgICAgICBsZXQgbGVmdCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpXG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgbGVmdCAtIDEpO1xuICAgICAgICBpZiAodG8gPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlUmlnaHQodG8sIHJlc3VsdCk7XG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihyZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgICAgICBpZiAodG8gPD0gbGVmdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIGlmICh0byA+PSBsZWZ0KVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA+IGxlZnQpXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmRlY29tcG9zZUxlZnQodG8gLSBsZWZ0LCByZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoLCByaWdodCA9IGxlZnQgKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAoZnJvbSA+PSByaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmRlY29tcG9zZVJpZ2h0KGZyb20gLSByaWdodCwgcmVzdWx0KTtcbiAgICAgICAgaWYgKGZyb20gPCBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5sZWZ0LmRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrICYmIGZyb20gPCByaWdodClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgYmFsYW5jZWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQuc2l6ZSA+IDIgKiByaWdodC5zaXplIHx8IHJpZ2h0LnNpemUgPiAyICogbGVmdC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZih0aGlzLmJyZWFrID8gW2xlZnQsIG51bGwsIHJpZ2h0XSA6IFtsZWZ0LCByaWdodF0pO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHBhcmVudFJlY3QuYm90dG9tIDogTWF0aC5taW4oYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBzdHlsZS5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgfHwgc3R5bGUucG9zaXRpb24gPT0gXCJmaXhlZFwiID8gZWx0Lm9mZnNldFBhcmVudCA6IGVsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0LCByaWdodDogTWF0aC5tYXgobGVmdCwgcmlnaHQpIC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IE1hdGgubWF4KHRvcCwgYm90dG9tKSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG5mdW5jdGlvbiBmdWxsUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBwYWRkaW5nVG9wLCBib3R0b206IHJlY3QuYm90dG9tIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXG4vLyBsaW5lcyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBhcyBhIGtsdWRnZSB0byBrZWVwIHRoZSBlZGl0b3Jcbi8vIHJlc3BvbnNpdmUgd2hlbiBhIHJpZGljdWxvdXNseSBsb25nIGxpbmUgaXMgbG9hZGVkIGludG8gaXQuXG5jbGFzcyBMaW5lR2FwIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc2l6ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnQSA9IGFbaV0sIGdCID0gYltpXTtcbiAgICAgICAgICAgIGlmIChnQS5mcm9tICE9IGdCLmZyb20gfHwgZ0EudG8gIT0gZ0IudG8gfHwgZ0Euc2l6ZSAhPSBnQi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyh2aWV3U3RhdGUsIHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgd2lkZ2V0OiBuZXcgTGluZUdhcFdpZGdldCh0aGlzLnNpemUgKiAod3JhcHBpbmcgPyB2aWV3U3RhdGUuc2NhbGVZIDogdmlld1N0YXRlLnNjYWxlWCksIHdyYXBwaW5nKVxuICAgICAgICB9KS5yYW5nZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIExpbmVHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCB2ZXJ0aWNhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5zaXplID09IHRoaXMuc2l6ZSAmJiBvdGhlci52ZXJ0aWNhbCA9PSB0aGlzLnZlcnRpY2FsOyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSBcIjJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsID8gdGhpcy5zaXplIDogLTE7IH1cbn1cbmNsYXNzIFZpZXdTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29udGVudERPTS1sb2NhbCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCwgdG9wOiAwLCBib3R0b206IDAgfTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSAwOyAvLyBQYWRkaW5nIGFib3ZlIHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7IC8vIFBhZGRpbmcgYmVsb3cgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudEhlaWdodCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRXaWR0aCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSAwOyAvLyBMYXN0IHNlZW4gc2Nyb2xsRE9NLnNjcm9sbFRvcCwgc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBDU1MtdHJhbnNmb3JtYXRpb24gc2NhbGUgb2YgdGhlIGVkaXRvciAodHJhbnNmb3JtZWQgc2l6ZSAvXG4gICAgICAgIC8vIGNvbmNyZXRlIHNpemUpXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICAvLyBUaGUgdmVydGljYWwgcG9zaXRpb24gKGRvY3VtZW50LXJlbGF0aXZlKSB0byB3aGljaCB0byBhbmNob3IgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbi4gLTEgbWVhbnMgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IDA7XG4gICAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIGFuY2hvciBwb3NpdGlvbi4gU2V0IGJ5IHRoZSBET00gdXBkYXRlIHBoYXNlLlxuICAgICAgICAvLyAtMSBtZWFucyBubyBoZWlnaHQgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCBmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICB0aGlzLnNjYWxlciA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodCA8PSA3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyA/IElkU2NhbGVyIDpcbiAgICAgICAgICAgIG5ldyBCaWdTY2FsZXIodGhpcy5oZWlnaHRPcmFjbGUsIHRoaXMuaGVpZ2h0TWFwLCB0aGlzLnZpZXdwb3J0cyk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdwb3J0TGluZXMoKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnRMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodE1hcC5mb3JFYWNoTGluZSh0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIDAsIDAsIGJsb2NrID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5wdXNoKHRoaXMuc2NhbGVyLnNjYWxlID09IDEgPyBibG9jayA6IHNjYWxlQmxvY2soYmxvY2ssIHRoaXMuc2NhbGVyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB1cGRhdGUuc3RhdGU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICB0aGlzLnN0YXRlRGVjbyA9IHRoaXMuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIGxldCBjb250ZW50Q2hhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBsZXQgaGVpZ2h0Q2hhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNvbnRlbnRDaGFuZ2VzLCBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKHByZXZEZWNvLCB0aGlzLnN0YXRlRGVjbywgdXBkYXRlID8gdXBkYXRlLmNoYW5nZXMgOiBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgICAgICBsZXQgcHJldkhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgbGV0IHNjcm9sbEFuY2hvciA9IHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA/IG51bGwgOiB0aGlzLnNjcm9sbEFuY2hvckF0KHRoaXMuc2Nyb2xsVG9wKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodClcbiAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICBpZiAoc2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzY3JvbGxBbmNob3IuZnJvbSwgLTEpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3IudG9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fFxuICAgICAgICAgICAgdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh1cGRhdGVMaW5lcylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmICghdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXG4gICAgICAgICAgICAhdXBkYXRlLnN0YXRlLmZhY2V0KG5hdGl2ZVNlbGVjdGlvbkhpZGRlbikpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKHZpZXcpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcuY29udGVudERPTSwgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgbGV0IGRvbVJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBtZWFzdXJlQ29udGVudCA9IHJlZnJlc2ggfHwgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgfHwgdGhpcy5jb250ZW50RE9NSGVpZ2h0ICE9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAsIGJpYXMgPSAwO1xuICAgICAgICBpZiAoZG9tUmVjdC53aWR0aCAmJiBkb21SZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGRvbSwgZG9tUmVjdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZVggIT0gc2NhbGVYIHx8IHRoaXMuc2NhbGVZICE9IHNjYWxlWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBpc1Njcm9sbGVkVG9Cb3R0b20odmlldy5zY3JvbGxET00pO1xuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NV2lkdGggIT0gY29udGVudFdpZHRoIHx8IHRoaXMuZWRpdG9ySGVpZ2h0ICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykpXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfSA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbGluZUhlaWdodCA+IDAgJiYgb3JhY2xlLnJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgdnAgb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0cyA9IHZwLmZyb20gPT0gdGhpcy52aWV3cG9ydC5mcm9tID8gbGluZUhlaWdodHMgOiB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2cCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSAocmVmcmVzaCA/IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUsIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldKSA6IHRoaXMuaGVpZ2h0TWFwKS51cGRhdGVIZWlnaHQob3JhY2xlLCAwLCByZWZyZXNoLCBuZXcgTWVhc3VyZWRIZWlnaHRzKHZwLmZyb20sIGhlaWdodHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmFjbGUuaGVpZ2h0Q2hhbmdlZClcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydChiaWFzLCB0aGlzLnNjcm9sbFRhcmdldCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwb3NpdGlvbnMgaW4gdGhlIHZpZXdwb3J0IHdoZXJlIHRoZSBzdGFydCBvciBlbmQgb2YgYVxuICAgIC8vIGxpbmUgc2hvdWxkIGJlIGhpZGRlbiwgdHJ5aW5nIHRvIHJldXNlIGV4aXN0aW5nIGxpbmUgZ2FwcyB3aGVuXG4gICAgLy8gYXBwcm9wcmlhdGUgdG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVkcmF3cy5cbiAgICAvLyBVc2VzIGNydWRlIGNoYXJhY3Rlci1jb3VudGluZyBmb3IgdGhlIHBvc2l0aW9uaW5nIGFuZCBzaXppbmcsXG4gICAgLy8gc2luY2UgYWN0dWFsIERPTSBjb29yZGluYXRlcyBhcmVuJ3QgYWx3YXlzIGF2YWlsYWJsZSBhbmRcbiAgICAvLyBwcmVkaWN0YWJsZS4gUmVsaWVzIG9uIGdlbmVyb3VzIG1hcmdpbnMgKHNlZSBMRy5NYXJnaW4pIHRvIGhpZGVcbiAgICAvLyB0aGUgYXJ0aWZhY3RzIHRoaXMgbWlnaHQgcHJvZHVjZSBmcm9tIHRoZSB1c2VyLlxuICAgIGVuc3VyZUxpbmVHYXBzKGN1cnJlbnQsIG1heU1lYXN1cmUpIHtcbiAgICAgICAgbGV0IHdyYXBwaW5nID0gdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nO1xuICAgICAgICBsZXQgbWFyZ2luID0gd3JhcHBpbmcgPyAxMDAwMCAvKiBMRy5NYXJnaW5XcmFwICovIDogMjAwMCAvKiBMRy5NYXJnaW4gKi8sIGhhbGZNYXJnaW4gPSBtYXJnaW4gPj4gMSwgZG91YmxlTWFyZ2luID0gbWFyZ2luIDw8IDE7XG4gICAgICAgIC8vIFRoZSBub24td3JhcHBpbmcgbG9naWMgd29uJ3Qgd29yayBhdCBhbGwgaW4gcHJlZG9taW5hbnRseSByaWdodC10by1sZWZ0IHRleHQuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgJiYgIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBsZXQgYWRkR2FwID0gKGZyb20sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpID0+IHtcbiAgICAgICAgICAgIGlmICh0byAtIGZyb20gPCBoYWxmTWFyZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbi5tYWluLCBhdm9pZCA9IFtzZWwuZnJvbV07XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSlcbiAgICAgICAgICAgICAgICBhdm9pZC5wdXNoKHNlbC50byk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgYXZvaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAoZnJvbSwgcG9zIC0gMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAocG9zICsgMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCB0bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnYXAgPSBmaW5kKGN1cnJlbnQsIGdhcCA9PiBnYXAuZnJvbSA+PSBsaW5lLmZyb20gJiYgZ2FwLnRvIDw9IGxpbmUudG8gJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYXAuZnJvbSAtIGZyb20pIDwgaGFsZk1hcmdpbiAmJiBNYXRoLmFicyhnYXAudG8gLSB0bykgPCBoYWxmTWFyZ2luICYmXG4gICAgICAgICAgICAgICAgIWF2b2lkLnNvbWUocG9zID0+IGdhcC5mcm9tIDwgcG9zICYmIGdhcC50byA+IHBvcykpO1xuICAgICAgICAgICAgaWYgKCFnYXApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBkb3duLCBzbmFwIGdhcCBlbmRzIHRvIGxpbmUgc3RhcnRzIHRvIGF2b2lkIHNoaWZ0cyBpbiB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIGlmICh0byA8IGxpbmUudG8gJiYgbWF5TWVhc3VyZSAmJiB3cmFwcGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlNZWFzdXJlLnZpc2libGVSYW5nZXMuc29tZShyID0+IHIuZnJvbSA8PSB0byAmJiByLnRvID49IHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbWF5TWVhc3VyZS5tb3ZlVG9MaW5lQm91bmRhcnkoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0byksIGZhbHNlLCB0cnVlKS5oZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlld3BvcnRMaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0cnVjdHVyZSA9IGxpbmVTdHJ1Y3R1cmUobGluZS5mcm9tLCBsaW5lLnRvLCB0aGlzLnN0YXRlRGVjbyk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0IC0gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQpIC8gMiArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld0Zyb20gPiBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgYWRkR2FwKGxpbmUuZnJvbSwgdmlld0Zyb20sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICBpZiAodmlld1RvIDwgbGluZS50bylcbiAgICAgICAgICAgICAgICBhZGRHYXAodmlld1RvLCBsaW5lLnRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSByYW5nZXMubGVuZ3RoICE9IHRoaXMudmlzaWJsZVJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChyLCBpKSA9PiByLmZyb20gIT0gcmFuZ2VzW2ldLmZyb20gfHwgci50byAhPSByYW5nZXNbaV0udG8pO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkID8gNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovIDogMDtcbiAgICB9XG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiAocG9zID49IHRoaXMudmlld3BvcnQuZnJvbSAmJiBwb3MgPD0gdGhpcy52aWV3cG9ydC50byAmJiB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChiID0+IGIuZnJvbSA8PSBwb3MgJiYgYi50byA+PSBwb3MpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQocG9zLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMubGluZUJsb2NrQXRIZWlnaHQoc2Nyb2xsVG9wICsgOCk7XG4gICAgICAgIHJldHVybiBibG9jay5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gc2Nyb2xsVG9wID4gMjAwID8gYmxvY2sgOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDFcbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yYWNsZSwgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2suX2NvbnRlbnQpID8gYmxvY2suX2NvbnRlbnQubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLl9jb250ZW50KTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiZcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDU2XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIiwgLy8gRm9yIElFXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsIC8vIEZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZVxuICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYW55d2hlcmVcIixcbiAgICAgICAgZmxleFNocmluazogMVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXG4gICAgfSxcbiAgICBcIi5jbS1sYXllclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIFwiJiA+ICpcIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiIzQ0NFwiXG4gICAgfSxcbiAgICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXIgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCIuY20taXNvXCI6IHtcbiAgICAgICAgdW5pY29kZUJpZGk6IFwiaXNvbGF0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIlxuICAgIH0sXG4gICAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgICAgICBcIi5jbS1hbm5vdW5jZWRcIjogeyBkaXNwbGF5OiBcIm5vbmVcIiB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsIC8vIE5lY2Vzc2FyeSAtLSBwcmV2ZW50cyBtYXJnaW4gY29sbGFwc2luZ1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlOmJlZm9yZVwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiYXR0cihkYXRhLWRpc3BsYXkpXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgbGV0IG9sZExlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgbmV4dFZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkgJiYgdGhpcy50ZXh0Lmxlbmd0aCA+IG9sZExlbikpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgbGV0IHRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihwb2ludC5vZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gMCwgcmUgPSB0aGlzLmxpbmVTZXBhcmF0b3IgPyBudWxsIDogL1xcclxcbj98XFxuL2c7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IC0xLCBicmVha1NpemUgPSAxLCBtO1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IHRleHQuaW5kZXhPZih0aGlzLmxpbmVTZXBhcmF0b3IsIG9mZik7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG0gPSByZS5leGVjKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKHRleHQuc2xpY2Uob2ZmLCBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWspKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGlmIChicmVha1NpemUgPiAxKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIHBvaW50LnBvcyA+IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5wb3MgLT0gYnJlYWtTaXplIC0gMTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRCcmVhayArIGJyZWFrU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgaWYgKGZyb21WaWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW5zaWRlKG5vZGUsIGZyb21WaWV3Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5saW5lQnJlYWspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbnNpZGUobm9kZSwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyA/IHBvaW50Lm5vZGUgPT0gbm9kZSA6IG5vZGUuY29udGFpbnMocG9pbnQubm9kZSkpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIChpc0F0RW5kKG5vZGUsIHBvaW50Lm5vZGUsIHBvaW50Lm9mZnNldCkgPyBsZW5ndGggOiAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0F0RW5kKHBhcmVudCwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIW5vZGUgfHwgb2Zmc2V0IDwgbWF4T2Zmc2V0KG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAvLyBpT1Mgd2lsbCByZWZ1c2UgdG8gc2VsZWN0IHRoZSBibG9jayBnYXBzIHdoZW4gZG9pbmcgc2VsZWN0LWFsbFxuICAgICAgICAgICAgbGV0IHZwID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGlmIChicm93c2VyLmlvcyAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIGhlYWQgIT0gYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgKHZwLmZyb20gPiAwIHx8IHZwLnRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGxldCBvZmZGcm9tID0gdnAuZnJvbSAtIE1hdGgubWluKGhlYWQsIGFuY2hvciksIG9mZlRvID0gdnAudG8gLSBNYXRoLm1heChoZWFkLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGlmICgob2ZmRnJvbSA9PSAwIHx8IG9mZkZyb20gPT0gMSkgJiYgKG9mZlRvID09IDAgfHwgb2ZmVG8gPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZSh2aWV3LCBkb21DaGFuZ2UpIHtcbiAgICBsZXQgY2hhbmdlO1xuICAgIGxldCB7IG5ld1NlbCB9ID0gZG9tQ2hhbmdlLCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBsYXN0S2V5ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCA/IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA6IC0xO1xuICAgIGlmIChkb21DaGFuZ2UuYm91bmRzKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb21DaGFuZ2UuYm91bmRzO1xuICAgICAgICBsZXQgcHJlZmVycmVkUG9zID0gc2VsLmZyb20sIHByZWZlcnJlZFNpZGUgPSBudWxsO1xuICAgICAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkIChvciwgb25cbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXG4gICAgICAgIGlmIChsYXN0S2V5ID09PSA4IHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGxhc3RLZXkgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgJiYgdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgbmV3U2VsLm1haW4uZXEoc2VsKSkpIHtcbiAgICAgICAgbmV3U2VsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcbiAgICAgICAgL15cXC4gPyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSAmJiB2aWV3LmNvbnRlbnRET00uZ2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIikgPT0gXCJvZmZcIikge1xuICAgICAgICAvLyBEZXRlY3QgaW5zZXJ0LXBlcmlvZC1vbi1kb3VibGUtc3BhY2UgTWFjIGFuZCBBbmRyb2lkIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cbiAgICAgICAgaWYgKG5ld1NlbCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAyKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyLmNocm9tZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkICYmXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGlmIHlvdSBpbnNlcnQgYSBzcGFjZSBhdCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkXG4gICAgICAgIC8vIGxpbmUsIGl0IHdpbGwgYWN0dWFsbHkgaW5zZXJ0IGEgbmV3bGluZSBhbmQgYSBzcGFjZSwgY2F1c2luZyBhXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcbiAgICAgICAgaWYgKG5ld1NlbClcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5pbnB1dFN0YXRlLmZsdXNoSU9TS2V5KCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGxhc3RLZXkgPT0gOCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA8IGNoYW5nZS50byAtIGNoYW5nZS5mcm9tICYmIGNoYW5nZS50byA+IHNlbC5oZWFkKSAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCBkZWZhdWx0VHI7XG4gICAgICAgIGxldCBkZWZhdWx0SW5zZXJ0ID0gKCkgPT4gZGVmYXVsdFRyIHx8IChkZWZhdWx0VHIgPSBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpKTtcbiAgICAgICAgaWYgKCF2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCwgZGVmYXVsdEluc2VydCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZhdWx0SW5zZXJ0KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkge1xuICAgIGxldCB0ciwgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGUsIHNlbCA9IHN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aCA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luID0gdmlldy53aW4pO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDaGVjayA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSBzZXRUaW1lb3V0KHRoaXMubGlzdGVuRm9yU2Nyb2xsLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgKGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApICE9IHRoaXMuaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gIXRoaXMuaW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcgIT0gdGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMCwgLjAwMV0gfSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuSGFuZGxlcnMoXCJzY3JvbGxcIiwgZSk7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xuICAgIH1cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb25QcmludCgpIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHZpZXcuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy5uZWFyZXN0KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3KSB8fCBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9IGtleS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbHVzaGVkID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRvbUNoYW5nZWQgPSB7IG5ld1NlbDogY2hhbmdlLm5ld1NlbCA/IGNoYW5nZS5uZXdTZWwubWFpbiA6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXTigJR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZFxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChyZWMudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjVmlldyB8fCBjVmlldy5pZ25vcmVNdXRhdGlvbihyZWMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNWaWV3Lm1hcmtEaXJ0eShyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIik7XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIilcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZChjVmlldywgcmVjLnByZXZpb3VzU2libGluZyB8fCByZWMudGFyZ2V0LnByZXZpb3VzU2libGluZywgLTEpO1xuICAgICAgICAgICAgbGV0IGNoaWxkQWZ0ZXIgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogY2hpbGRBZnRlciA/IGNWaWV3LnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaW5kb3cod2luKSB7XG4gICAgICAgIGlmICh3aW4gIT0gdGhpcy53aW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9iID0gdGhpcy5nYXBJbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENoaWxkKGNWaWV3LCBkb20sIGRpcikge1xuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbGV0IGN1clZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgaWYgKGN1clZpZXcgJiYgY3VyVmlldy5wYXJlbnQgPT0gY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm4gY3VyVmlldztcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBkb20gPSBwYXJlbnQgIT0gY1ZpZXcuZG9tID8gcGFyZW50IDogZGlyID4gMCA/IGRvbS5uZXh0U2libGluZyA6IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWcgKCM0MTQpXG5mdW5jdGlvbiBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodmlldykge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBmb3VuZC5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gZm91bmQuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IGZvdW5kLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSBmb3VuZC5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgICAgSWRsZSDihpIgVXBkYXRpbmcg4oeGIElkbGUgKHVuY2hlY2tlZCkg4oaSIE1lYXN1cmluZyDihpIgSWRsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSAgICAgIOKGk1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0aW5nIChtZWFzdXJlKVxuLy9cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxuLy8gd2hldGhlciBhIGxheW91dCBjaGVjayBoYXMgYmVlbiBzY2hlZHVsZWQuIEEgcmVndWxhciB1cGRhdGUgdGhyb3VnaFxuLy8gdGhlIGB1cGRhdGVgIG1ldGhvZCB1cGRhdGVzIHRoZSBET00gaW4gYSB3cml0ZS1vbmx5IGZhc2hpb24sIGFuZFxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXG4vLyBzdXJlIGV2ZXJ5dGhpbmcgaXMgd2hlcmUgaXQgc2hvdWxkIGJlIGFuZCB0aGUgdmlld3BvcnQgY292ZXJzIHRoZVxuLy8gdmlzaWJsZSBjb2RlLiBUaGF0IGNoZWNrIGNvbnRpbnVlcyB0byBtZWFzdXJlIGFuZCB0aGVuIG9wdGlvbmFsbHlcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXG4vKipcbkFuIGVkaXRvciB2aWV3IHJlcHJlc2VudHMgdGhlIGVkaXRvcidzIHVzZXIgaW50ZXJmYWNlLiBJdCBob2xkc1xudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcbmxpbmUgbnVtYmVyIGd1dHRlci4gSXQgaGFuZGxlcyBldmVudHMgYW5kIGRpc3BhdGNoZXMgc3RhdGVcbnRyYW5zYWN0aW9ucyBmb3IgZWRpdGluZyBhY3Rpb25zLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcbiAgICBvbmUgY2hhbmdlIGhhcyBiZWVuIG1hZGUgaW4gdGhlIGN1cnJlbnQgY29tcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgaW4gY29tcG9zaW5nIHN0YXRlLiBOb3RlXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICAgIGxvdCwgc2luY2UganVzdCBwdXR0aW5nIHRoZSBjdXJzb3Igb24gYSB3b3JkIHN0YXJ0cyBhXG4gICAgY29tcG9zaXRpb24gdGhlcmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaXRpb25TdGFydGVkKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXG4gICAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICAgIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZSB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5jbGFzc05hbWUgPSBcImNtLWFubm91bmNlZFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICBsZXQgeyBkaXNwYXRjaCB9ID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zID0gY29uZmlnLmRpc3BhdGNoVHJhbnNhY3Rpb25zIHx8XG4gICAgICAgICAgICAoZGlzcGF0Y2ggJiYgKCh0cnMpID0+IHRycy5mb3JFYWNoKHRyID0+IGRpc3BhdGNoKHRyLCB0aGlzKSkpKSB8fFxuICAgICAgICAgICAgKCh0cnMpID0+IHRoaXMudXBkYXRlKHRycykpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5zY3JvbGxUbyAmJiBjb25maWcuc2Nyb2xsVG8uaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gY29uZmlnLnNjcm9sbFRvLnZhbHVlLmNsaXAodGhpcy52aWV3U3RhdGUuc3RhdGUpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICBsZXQgdHJzID0gaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0XG4gICAgICAgICAgICA6IGlucHV0Lmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoaW5wdXRbMF0pID8gaW5wdXRbMF1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCldO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zKHRycywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUgPSB0ci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvY3VzID0gdGhpcy5oYXNGb2N1cywgZm9jdXNGbGFnID0gMCwgZGlzcGF0Y2hGb2N1cyA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5hbm5vdGF0aW9uKGlzRm9jdXNDaGFuZ2UpKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gSWYgYSBmb2N1cy1jaGFuZ2UgdHJhbnNhY3Rpb24gaXMgYmVpbmcgZGlzcGF0Y2hlZCwgc2V0IHRoaXMgdXBkYXRlIGZsYWcuXG4gICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXMgIT0gdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBzZXBhcmF0ZSBmb2N1cyB0cmFuc2FjdGlvbiBpZiBuZWNlc3NhcnksIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYWRkIGEgZmxhZyB0byB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgZGlzcGF0Y2hGb2N1cyA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlLmRvYykgfHwgIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gZm9jdXNGbGFnO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlLmNsaXAodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHJlZHJhd24sIHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwic2VsZWN0LnBvaW50ZXJcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHRoZW1lKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhlbWUpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcInVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaEZvY3VzIHx8IGRvbUNoYW5nZSlcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaEZvY3VzICYmIHRoaXMuc3RhdGUgPT0gZGlzcGF0Y2hGb2N1cy5zdGFydFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRpc3BhdGNoRm9jdXMpO1xuICAgICAgICAgICAgICAgIGlmIChkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcHBseURPTUNoYW5nZSh0aGlzLCBkb21DaGFuZ2UpICYmIHBlbmRpbmdLZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmNvbnRlbnRET00sIHBlbmRpbmdLZXkua2V5LCBwZW5kaW5nS2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCB0aGUgdmlldyB0byB0aGUgZ2l2ZW4gc3RhdGUuIChUaGlzIHdpbGwgY2F1c2UgdGhlIGVudGlyZVxuICAgIGRvY3VtZW50IHRvIGJlIHJlZHJhd24gYW5kIGFsbCB2aWV3IHBsdWdpbnMgdG8gYmUgcmVpbml0aWFsaXplZCxcbiAgICBzbyB5b3Ugc2hvdWxkIHByb2JhYmx5IG9ubHkgdXNlIGl0IHdoZW4gdGhlIG5ldyBzdGF0ZSBpc24ndFxuICAgIGRlcml2ZWQgZnJvbSB0aGUgb2xkIHN0YXRlLiBPdGhlcndpc2UsIHVzZVxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZC4pXG4gICAgKi9cbiAgICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnNldFN0YXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgbGV0IGhhZEZvY3VzID0gdGhpcy5oYXNGb2N1cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3U3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWRGb2N1cylcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5zKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldlNwZWNzID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodmlld1BsdWdpbiksIHNwZWNzID0gdXBkYXRlLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5tdXN0VXBkYXRlICE9IHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgc0RPTSA9IHRoaXMuc2Nyb2xsRE9NLCBzY3JvbGxUb3AgPSBzRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgeyBzY3JvbGxBbmNob3JQb3MsIHNjcm9sbEFuY2hvckhlaWdodCB9ID0gdGhpcy52aWV3U3RhdGU7XG4gICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSlcbiAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEFuY2hvckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWRUb0JvdHRvbShzRE9NKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IGJsb2NrLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJNZWFzdXJlIGxvb3AgcmVzdGFydGVkIG1vcmUgdGhhbiA1IHRpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIG1lYXN1cmUgcmVxdWVzdHMgaW4gdGhpcyBjeWNsZSB3aGVuIHRoZSB2aWV3cG9ydCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCByZWRyYXduID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWVhc3VyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvclBvcyA8IDAgPyB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQoc2Nyb2xsQW5jaG9yUG9zKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdBbmNob3JIZWlnaHQgLSBzY3JvbGxBbmNob3JIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRE9NLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAvIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiAhdXBkYXRlZC5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAgICovXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUaGVtZUlEICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoaXMuc3RhdGUuZmFjZXQoZGFya1RoZW1lKSA/IGJhc2VEYXJrSUQgOiBiYXNlTGlnaHRJRCkgKyBcIiBcIiArXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcbiAgICB9XG4gICAgdXBkYXRlQXR0cnMoKSB7XG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBcIm5vXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICF0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxuICAgICAgICAgICAgc3R5bGU6IGAke2Jyb3dzZXIudGFiU2l6ZX06ICR7dGhpcy5zdGF0ZS50YWJTaXplfWAsXG4gICAgICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIGF0dHJzRnJvbUZhY2V0KHRoaXMsIGNvbnRlbnRBdHRyaWJ1dGVzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZEVkaXRvciA9IHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZENvbnRlbnQgfHwgY2hhbmdlZEVkaXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSBlZGl0b3JBdHRycztcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuY3NwTm9uY2UpO1xuICAgICAgICBTdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUkMSkucmV2ZXJzZSgpLCBub25jZSA/IHsgbm9uY2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmljIHBsdWdpbiwgaWYgcHJlc2VudC4gTm90ZSB0aGF0XG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XG4gICAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgcGx1Z2luKHBsdWdpbikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLnBsdWdpbk1hcC5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24uc3BlYyAhPSBwbHVnaW4pXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5zZXQocGx1Z2luLCBrbm93biA9IHRoaXMucGx1Z2lucy5maW5kKHAgPT4gcC5zcGVjID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGF0IHRoZSBnaXZlblxuICAgIGhlaWdodCwgYWdhaW4gaW50ZXJwcmV0ZWQgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKS5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGFsbCBbbGluZVxuICAgIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXG4gICAgYXJlIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCk7XG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRMaW5lQmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnRMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayBhcm91bmQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBBIGxpbmVcbiAgICBibG9jayBpcyBhIHJhbmdlIGRlbGltaXRlZCBvbiBib3RoIHNpZGVzIGJ5IGVpdGhlciBhXG4gICAgbm9uLVtoaWRkZW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGxpbmUgYnJlYWtzLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspLiBgZm9yd2FyZGAgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICAgIHRoZSBlZGl0b3IncyBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxuICAgIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICAgIGZ1cnRoZXIgbGluZSwgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gICAgb3B0aW9uYWwgYGJ5YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFjcm9zcyBtb3JlLiBJdCB3aWxsXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXG4gICAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gICAgd2hldGhlciBpdCBzaG91bGQgYWxzbyBiZSBtb3ZlZCBvdmVyLlxuICAgICovXG4gICAgbW92ZUJ5Q2hhcihzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgYnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXG4gICAgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGluaXRpYWwgPT4gYnlHcm91cCh0aGlzLCBzdGFydC5oZWFkLCBpbml0aWFsKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB2aXN1YWxseSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbGluZS5cbiAgICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgICBzdGFydCBvciBlbmQgKHdoaWNoIGlzIHNpbXBseSBhdCBgbGluZS5mcm9tYC9gbGluZS50b2ApIGlmIHRleHRcbiAgICBhdCB0aGUgc3RhcnQgb3IgZW5kIGdvZXMgYWdhaW5zdCB0aGUgbGluZSdzIGJhc2UgdGV4dCBkaXJlY3Rpb24uXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lU2lkZShsaW5lLCBlbmQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSksIGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbZW5kID8gb3JkZXIubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzcGFuLnNpZGUoZW5kLCBkaXIpICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoIWVuZCwgZGlyKSA/IDEgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgcmVjdGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGNoYXJhY3Rlci4gSWYgYHBvc2AgZG9lcyBub3RcbiAgICBwb2ludCBpbiBmcm9udCBvZiBhIGNoYXJhY3RlciB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCBhbmRcbiAgICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgbnVsbC4gRm9yIHNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYSBsaW5lIHdyYXAgcG9pbnQsIHRoaXMgd2lsbFxuICAgIHJldHVybiB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBsaW5lIGJyZWFrLlxuICAgICovXG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pLCBpc29sYXRlcztcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdGhpcy5iaWRpQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyICYmXG4gICAgICAgICAgICAgICAgKGVudHJ5LmZyZXNoIHx8IGlzb2xhdGVzRXEoZW50cnkuaXNvbGF0ZXMsIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc29sYXRlcylcbiAgICAgICAgICAgIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSk7XG4gICAgICAgIGxldCBvcmRlciA9IGNvbXB1dGVPcmRlcihsaW5lLnRleHQsIGRpciwgaXNvbGF0ZXMpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgaXNvbGF0ZXMsIHRydWUsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGFuIGVmZmVjdCB0aGF0IHJlc2V0cyB0aGUgZWRpdG9yIHRvIGl0cyBjdXJyZW50IChhdCB0aGVcbiAgICB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQpIHNjcm9sbCBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAgICBvbmx5IGFmZmVjdHMgdGhlIGVkaXRvcidzIG93biBzY3JvbGxhYmxlIGVsZW1lbnQsIG5vdCBwYXJlbnRzLlxuICAgIFNlZSBhbHNvXG4gICAgW2BFZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG8pLlxuICAgIFxuICAgIFRoZSBlZmZlY3Qgc2hvdWxkIGJlIHVzZWQgd2l0aCBhIGRvY3VtZW50IGlkZW50aWNhbCB0byB0aGUgb25lXG4gICAgaXQgd2FzIGNyZWF0ZWQgZm9yLiBGYWlsaW5nIHRvIGRvIHNvIGlzIG5vdCBhbiBlcnJvciwgYnV0IG1heVxuICAgIG5vdCBzY3JvbGwgdG8gdGhlIGV4cGVjdGVkIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRoZSBlZmZlY3QgdG8gYWNjb3VudCBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIHNjcm9sbFNuYXBzaG90KCkge1xuICAgICAgICBsZXQgeyBzY3JvbGxUb3AsIHNjcm9sbExlZnQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xuICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyZWYuZnJvbSksIFwic3RhcnRcIiwgXCJzdGFydFwiLCByZWYudG9wIC0gc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIERPTSBldmVudCBoYW5kbGVycy5cbiAgICBUaGUgdmFsdWUgc2hvdWxkIGJlIGFuIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJcbiAgICBmdW5jdGlvbnMuIEZvciBhbnkgZ2l2ZW4gZXZlbnQsIHN1Y2ggZnVuY3Rpb25zIGFyZSBvcmRlcmVkIGJ5XG4gICAgZXh0ZW5zaW9uIHByZWNlZGVuY2UsIGFuZCB0aGUgZmlyc3QgaGFuZGxlciB0byByZXR1cm4gdHJ1ZSB3aWxsXG4gICAgYmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yXG4gICAgYnVpbHQtaW4gYmVoYXZpb3Igd2lsbCBiZSBhY3RpdmF0ZWQgZm9yIGl0LiBUaGVzZSBhcmUgcmVnaXN0ZXJlZFxuICAgIG9uIHRoZSBbY29udGVudCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb250ZW50RE9NKSwgZXhjZXB0XG4gICAgZm9yIGBzY3JvbGxgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGVcbiAgICBlZGl0b3IncyBbc2Nyb2xsIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mXG4gICAgaXRzIHBhcmVudCBub2RlcyBpcyBzY3JvbGxlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGhhbmRsZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIERPTSBldmVudCBvYnNlcnZlcnMuIENvbnRyYXJ5XG4gICAgdG8gZXZlbnQgW2hhbmRsZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kb21FdmVudEhhbmRsZXJzKSxcbiAgICBvYnNlcnZlcnMgY2FuJ3QgYmUgcHJldmVudGVkIGZyb20gcnVubmluZyBieSBhIGhpZ2hlci1wcmVjZWRlbmNlXG4gICAgaGFuZGxlciByZXR1cm5pbmcgdHJ1ZS4gVGhleSBhbHNvIGRvbid0IHByZXZlbnQgb3RoZXIgaGFuZGxlcnNcbiAgICBhbmQgb2JzZXJ2ZXJzIGZyb20gcnVubmluZyB3aGVuIHRoZXkgcmV0dXJuIHRydWUsIGFuZCBzaG91bGQgbm90XG4gICAgY2FsbCBgcHJldmVudERlZmF1bHRgLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50T2JzZXJ2ZXJzKG9ic2VydmVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudE9ic2VydmVyczogb2JzZXJ2ZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0aGVtZSBleHRlbnNpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBjYW4gYmUgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXG4gICAgcHJlZml4ZWQgd2l0aCBhIGdlbmVyYXRlZCBjbGFzcyBmb3IgdGhlIHN0eWxlLlxuICAgIFxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxuICAgIHRoYXQgZGlyZWN0bHkgbWF0Y2ggdGhlIGVkaXRvcidzIFt3cmFwcGVyXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKeKAlHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gICAgYWRkZWTigJRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xuICAgIHRoZSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW504oCUZm9yIGV4YW1wbGVcbiAgICBgJi5jbS1mb2N1c2VkYC5cbiAgICBcbiAgICBXaGVuIGBkYXJrYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHRoZW1lIHdpbGwgYmUgbWFya2VkIGFzIGRhcmssXG4gICAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cbiAgICBgJmxpZ2h0YCB3aGVuIGEgbGlnaHQgdGhlbWUgaXMgYWN0aXZlKS5cbiAgICAqL1xuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhlbWUub2YocHJlZml4KSwgc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShgLiR7cHJlZml4fWAsIHNwZWMpKV07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhcmtUaGVtZS5vZih0cnVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHN0eWxlcyB0byB0aGUgYmFzZSB0aGVtZS4gTGlrZVxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgICBwbGFjZSBvZiB0aGUgZWRpdG9yIHdyYXBwZXIgZWxlbWVudCB3aGVuIGRpcmVjdGx5IHRhcmdldGluZ1xuICAgIHRoYXQuIFlvdSBjYW4gYWxzbyB1c2UgYCZkYXJrYCBvciBgJmxpZ2h0YCBpbnN0ZWFkIHRvIG9ubHlcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgICAqL1xuICAgIHN0YXRpYyBiYXNlVGhlbWUoc3BlYykge1xuICAgICAgICByZXR1cm4gUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGFuIGVkaXRvciB2aWV3IGluc3RhbmNlIGZyb20gdGhlIHZpZXcncyBET01cbiAgICByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbURPTShkb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGVudCA9IGRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLWNvbnRlbnRcIik7XG4gICAgICAgIGxldCBjVmlldyA9IGNvbnRlbnQgJiYgQ29udGVudFZpZXcuZ2V0KGNvbnRlbnQpIHx8IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICByZXR1cm4gKChfYSA9IGNWaWV3ID09PSBudWxsIHx8IGNWaWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjVmlldy5yb290VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXcpIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5GYWNldCB0byBhZGQgYSBbc3R5bGVcbm1vZHVsZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pIHRvXG5hbiBlZGl0b3Igdmlldy4gVGhlIHZpZXcgd2lsbCBlbnN1cmUgdGhhdCB0aGUgbW9kdWxlIGlzXG5tb3VudGVkIGluIGl0cyBbZG9jdW1lbnRcbnJvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnN0cnVjdG9yXmNvbmZpZy5yb290KS5cbiovXG5FZGl0b3JWaWV3LnN0eWxlTW9kdWxlID0gc3R5bGVNb2R1bGU7XG4vKipcbkFuIGlucHV0IGhhbmRsZXIgY2FuIG92ZXJyaWRlIHRoZSB3YXkgY2hhbmdlcyB0byB0aGUgZWRpdGFibGVcbkRPTSBjb250ZW50IGFyZSBoYW5kbGVkLiBIYW5kbGVycyBhcmUgcGFzc2VkIHRoZSBkb2N1bWVudFxucG9zaXRpb25zIGJldHdlZW4gd2hpY2ggdGhlIGNoYW5nZSB3YXMgZm91bmQsIGFuZCB0aGUgbmV3XG5jb250ZW50LiBXaGVuIG9uZSByZXR1cm5zIHRydWUsIG5vIGZ1cnRoZXIgaW5wdXQgaGFuZGxlcnMgYXJlXG5jYWxsZWQgYW5kIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZC5cblxuVGhlIGBpbnNlcnRgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvblxudGhhdCB3b3VsZCBiZSBhcHBsaWVkIGZvciB0aGlzIGlucHV0LiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlblxuZGlzcGF0Y2hpbmcgdGhlIGN1c3RvbSBiZWhhdmlvciBhcyBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uLlxuKi9cbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuLyoqXG5UaGlzIGZhY2V0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGVmZmVjdHNcbnRvIGJlIGRpc3BhdGNoZWQgd2hlbiB0aGUgZWRpdG9yJ3MgZm9jdXMgc3RhdGUgY2hhbmdlcy5cbiovXG5FZGl0b3JWaWV3LmZvY3VzQ2hhbmdlRWZmZWN0ID0gZm9jdXNDaGFuZ2VFZmZlY3Q7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXPigJRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5GYWNldCB0aGF0IHdvcmtzIG11Y2ggbGlrZVxuW2BkZWNvcmF0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgYnV0IHB1dHMgaXRzXG5pbnB1dHMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwcmVjZWRlbmNlIHN0YWNrLCBtZWFuaW5nIG1hcmtcbmRlY29yYXRpb25zIHByb3ZpZGVkIGhlcmUgd2lsbCBvbmx5IGJlIHNwbGl0IGJ5IG90aGVyLCBwYXJ0aWFsbHlcbm92ZXJsYXBwaW5nIFxcYG91dGVyRGVjb3JhdGlvbnNcXGAgcmFuZ2VzLCBhbmQgd3JhcCBhcm91bmQgYWxsXG5yZWd1bGFyIGRlY29yYXRpb25zLiBVc2UgdGhpcyBmb3IgbWFyayBlbGVtZW50cyB0aGF0IHNob3VsZCwgYXNcbm11Y2ggYXMgcG9zc2libGUsIHJlbWFpbiBpbiBvbmUgcGllY2UuXG4qL1xuRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zID0gb3V0ZXJEZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5XaGVuIHJhbmdlIGRlY29yYXRpb25zIGFkZCBhIGB1bmljb2RlLWJpZGk6IGlzb2xhdGVgIHN0eWxlLCB0aGV5XG5zaG91bGQgYWxzbyBpbmNsdWRlIGFcbltgYmlkaUlzb2xhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTWFya0RlY29yYXRpb25TcGVjLmJpZGlJc29sYXRlKSBwcm9wZXJ0eVxuaW4gdGhlaXIgZGVjb3JhdGlvbiBzcGVjLCBhbmQgYmUgZXhwb3NlZCB0aHJvdWdoIHRoaXMgZmFjZXQsIHNvXG50aGF0IHRoZSBlZGl0b3IgY2FuIGNvbXB1dGUgdGhlIHByb3BlciB0ZXh0IG9yZGVyLiAoT3RoZXIgdmFsdWVzXG5mb3IgYHVuaWNvZGUtYmlkaWAsIGV4Y2VwdCBvZiBjb3Vyc2UgYG5vcm1hbGAsIGFyZSBub3RcbnN1cHBvcnRlZC4pXG4qL1xuRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBiaWRpSXNvbGF0ZWRSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcblByb3ZpZGVzIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbnRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBlZGl0b3IuIEhvbGRzIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBub1xubm9uY2UgaGFzIGJlZW4gcHJvdmlkZWQuXG4qL1xuRWRpdG9yVmlldy5jc3BOb25jZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBpc29sYXRlcywgZnJlc2gsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuaXNvbGF0ZXMgPSBpc29sYXRlcztcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgJiYgIWNhY2hlLnNvbWUoYyA9PiBjLmZyZXNoKSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgYmluZGluZy5zdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBzdG9wUHJvcGFnYXRpb246IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKGIuYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJzKG1hcCwgZXZlbnQsIHZpZXcsIHNjb3BlKSB7XG4gICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgaGFuZGxlZCA9IGZhbHNlLCBwcmV2ZW50ZWQgPSBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgLy8gQ3RybC1BbHQgbWF5IGJlIHVzZWQgZm9yIEFsdEdyIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICEoYnJvd3Nlci53aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVkO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgKGluIHBpeGVscywgZG9jdW1lbnQtcmVsYXRpdmUpLlxuICAgICovXG4gICAgbGVmdCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgb3IgbnVsbCBpZiBpdCBzaG91bGRuJ3QgZ2V0IGEgd2lkdGggYXNzaWduZWQuXG4gICAgKi9cbiAgICB3aWR0aCwgXG4gICAgLyoqXG4gICAgVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGggKiB2aWV3LnNjYWxlWDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHR5cGU6IEJsb2NrVHlwZS5UZXh0IH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVFbHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY20tbGluZVwiKSwgbGluZVN0eWxlID0gbGluZUVsdCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsaW5lRWx0KTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICtcbiAgICAgICAgKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpIDogMCk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCB2aXN1YWxTdGFydCk7XG4gICAgaWYgKHZpc3VhbEVuZCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgZW5kQmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCB2aXN1YWxFbmQpO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSkge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgPyAxIDogMCkgfHxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcyA+IDEgJiYgdG9wLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyIDwgYm90dG9tLnRvcClcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhIGxheWVyLlxuKi9cbmZ1bmN0aW9uIGxheWVyKGNvbmZpZykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHYgPT4gbmV3IExheWVyVmlldyh2LCBjb25maWcpKSxcbiAgICAgICAgbGF5ZXJPcmRlci5vZihjb25maWcpXG4gICAgXTtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjdXJzb3JMYXllcixcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIsXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG4vKipcblJldHJpZXZlIHRoZSBbYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY29uZmlndXJhdGlvblxuZm9yIHRoaXMgc3RhdGUuIChOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIHNldCBvZiBkZWZhdWx0cyBldmVuXG5pZiBgZHJhd1NlbGVjdGlvbmAgaXNuJ3QgZW5hYmxlZC4pXG4qL1xuZnVuY3Rpb24gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuZnVuY3Rpb24gY29uZmlnQ2hhbmdlZCh1cGRhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmNvbnN0IGN1cnNvckxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCImOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KSB7XG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuICAgIHRoZW1lU3BlY1tcIi5jbS1jb250ZW50XCJdID0geyBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9O1xufVxuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgKiB2aWV3LnNjYWxlWSAtXG4gICAgICAgICAgICB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdmlldy5kb2N1bWVudFBhZGRpbmcudG9wIC0gMC41O1xuICAgICAgICBpZiAoaGVpZ2h0ID49IDAgJiYgaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gZmluZENvbHVtbihsaW5lLnRleHQsIGVuZENvbCwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0LCBsaW5lLmZyb20gKyBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gYWJzb2x1dGVDb2x1bW4odmlldywgeCkge1xuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgcmV0dXJuIHJlZiA/IE1hdGgucm91bmQoTWF0aC5hYnMoKHJlZi5sZWZ0IC0geCkgLyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkpIDogLTE7XG59XG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KG9mZnNldCksIG9mZiA9IG9mZnNldCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcbiAgICAgICAgOiBvZmYgPT0gbGluZS5sZW5ndGggPyBhYnNvbHV0ZUNvbHVtbih2aWV3LCBldmVudC5jbGllbnRYKVxuICAgICAgICAgICAgOiBjb3VudENvbHVtbihsaW5lLnRleHQsIHZpZXcuc3RhdGUudGFiU2l6ZSwgb2Zmc2V0IC0gbGluZS5mcm9tKTtcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xpbmUgPSB1cGRhdGUuc3RhdGUuZG9jLmxpbmVBdChuZXdTdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7IGxpbmU6IG5ld0xpbmUubnVtYmVyLCBjb2w6IHN0YXJ0LmNvbCwgb2ZmOiBNYXRoLm1pbihzdGFydC5vZmYsIG5ld0xpbmUubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGdldFBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWN1cilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gcmVjdGFuZ2xlRm9yKHZpZXcuc3RhdGUsIHN0YXJ0LCBjdXIpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuY29uY2F0KHN0YXJ0U2VsLnJhbmdlcykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuZGVmYXVsdCwgaXQgd2lsbCByZWFjdCB0byBsZWZ0IG1vdXNlIGRyYWcgd2l0aCB0aGUgQWx0IGtleSBoZWxkXG5kb3duLiBXaGVuIHN1Y2ggYSBzZWxlY3Rpb24gb2NjdXJzLCB0aGUgdGV4dCB3aXRoaW4gdGhlIHJlY3RhbmdsZVxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbltyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG4qL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBmaWx0ZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RmlsdGVyKSB8fCAoZSA9PiBlLmFsdEtleSAmJiBlLmJ1dHRvbiA9PSAwKTtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlLm9mKCh2aWV3LCBldmVudCkgPT4gZmlsdGVyKGV2ZW50KSA/IHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSA6IG51bGwpO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgICBBbHQ6IFsxOCwgZSA9PiAhIWUuYWx0S2V5XSxcbiAgICBDb250cm9sOiBbMTcsIGUgPT4gISFlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gISFlLnNoaWZ0S2V5XSxcbiAgICBNZXRhOiBbOTEsIGUgPT4gISFlLm1ldGFLZXldXG59O1xuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IHR1cm5zIHRoZSBwb2ludGVyIGN1cnNvciBpbnRvIGFcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxuZG93bi4gQ2FuIHNlcnZlIGFzIGEgdmlzdWFsIGhpbnQgdGhhdCByZWN0YW5ndWxhciBzZWxlY3Rpb24gaXNcbmdvaW5nIHRvIGhhcHBlbiB3aGVuIHBhaXJlZCB3aXRoXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cbiovXG5mdW5jdGlvbiBjcm9zc2hhaXJDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rvd24gIT0gaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBpc0Rvd247XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3LCByZW1vdmVUb29sdGlwVmlldykge1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcgPSBjcmVhdGVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyA9IHJlbW92ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKGNyZWF0ZVRvb2x0aXBWaWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgYWJvdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaW5wdXQgPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCk7XG4gICAgICAgIGxldCB0b29sdGlwcyA9IGlucHV0LmZpbHRlcih4ID0+IHgpO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgaWYgKHQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b29sdGlwVmlld3MgPSBbXSwgbmV3QWJvdmUgPSBhYm92ZSA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHRpcCA9IHRvb2x0aXBzW2ldLCBrbm93biA9IC0xO1xuICAgICAgICAgICAgaWYgKCF0aXApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSB0aGlzLnRvb2x0aXBzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdGhlciAmJiBvdGhlci5jcmVhdGUgPT0gdGlwLmNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAga25vd24gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBWaWV3c1tpXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcodGlwKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3QWJvdmUpXG4gICAgICAgICAgICAgICAgICAgIG5ld0Fib3ZlW2ldID0gISF0aXAuYWJvdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwVmlld3NbaV0gPSB0aGlzLnRvb2x0aXBWaWV3c1trbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9IGFib3ZlW2tub3duXTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcFZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3cy5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcFZpZXcodCk7XG4gICAgICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFib3ZlKSB7XG4gICAgICAgICAgICBuZXdBYm92ZS5mb3JFYWNoKCh2YWwsIGkpID0+IGFib3ZlW2ldID0gdmFsKTtcbiAgICAgICAgICAgIGFib3ZlLmxlbmd0aCA9IG5ld0Fib3ZlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0b29sdGlwcztcbiAgICAgICAgdGhpcy50b29sdGlwVmlld3MgPSB0b29sdGlwVmlld3M7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlcyBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIHRvb2x0aXAgYmVoYXZpb3IuXG4qL1xuZnVuY3Rpb24gdG9vbHRpcHMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdG9vbHRpcENvbmZpZy5vZihjb25maWcpO1xufVxuZnVuY3Rpb24gd2luZG93U3BhY2Uodmlldykge1xuICAgIGxldCB7IHdpbiB9ID0gdmlldztcbiAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogd2luLmlubmVySGVpZ2h0LCByaWdodDogd2luLmlubmVyV2lkdGggfTtcbn1cbmNvbnN0IHRvb2x0aXBDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwb3NpdGlvbjogYnJvd3Nlci5pb3MgPyBcImFic29sdXRlXCIgOiAoKF9hID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBTcGFjZTogKChfYyA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi50b29sdGlwU3BhY2UpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHRpcFNwYWNlKSB8fCB3aW5kb3dTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBrbm93bkhlaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFib3ZlID0gW107XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSAwO1xuICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGNvbmZpZy5wYXJlbnQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZE1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMud3JpdGVNZWFzdXJlLmJpbmQodGhpcyksIGtleTogdGhpcyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLm1lYXN1cmVTb29uKCkpIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgdCA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCksIHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodC5kb20pO1xuICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFib3ZlID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCh0ID0+ICEhdC5hYm92ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aGlzLmxhc3RUcmFuc2FjdGlvbiAtIDUwICYmXG4gICAgICAgICAgICAgICAgZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA8IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzFdIH0pIDogbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuYWJvdmUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uICYmICF0aGlzLm1hZGVBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCkge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIGlmICh0b29sdGlwLmFycm93ICYmICF0b29sdGlwVmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwID4gLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRvb2x0aXBWaWV3Lm1vdW50KVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBWaWV3O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIChfYiA9IHRoaXMucmVzaXplT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lYXN1cmVUaW1lb3V0KTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIGxldCBlZGl0b3IgPSB0aGlzLnZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgbWFrZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFwiZml4ZWRcIiAmJiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzWzBdO1xuICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNldHMgdGhlIGVsZW1lbnQncyBgb2Zmc2V0UGFyZW50YCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1lZCBlbGVtZW50IHdoZW4gYSB0cmFuc2Zvcm0gaW50ZXJmZXJlcyB3aXRoIGZpeGVkXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25pbmcuXG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gZG9tLm9mZnNldFBhcmVudCAhPSB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkb20uc3R5bGUudG9wID09IE91dHNpZGUgJiYgZG9tLnN0eWxlLmxlZnQgPT0gXCIwcHhcIikge1xuICAgICAgICAgICAgICAgIC8vIE9uIG90aGVyIGJyb3dzZXJzLCB3ZSBoYXZlIHRvIGF3a3dhcmRseSB0cnkgYW5kIHVzZSBvdGhlclxuICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uIHRvIGRldGVjdCBhIHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBtYWtlQWJzb2x1dGUgPSBNYXRoLmFicyhyZWN0LnRvcCArIDEwMDAwKSA+IDEgfHwgTWF0aC5hYnMocmVjdC5sZWZ0KSA+IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ha2VBYnNvbHV0ZSB8fCB0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSByZWN0LndpZHRoIC8gdGhpcy5wYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5wYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXcudmlld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogZWRpdG9yLFxuICAgICAgICAgICAgcG9zOiB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR2ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHYuZ2V0Q29vcmRzID8gdHYuZ2V0Q29vcmRzKHQucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyh0LnBvcyk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbSB9KSA9PiBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLFxuICAgICAgICAgICAgc3BhY2U6IHRoaXMudmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKS50b29sdGlwU3BhY2UodGhpcy52aWV3KSxcbiAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLCBtYWtlQWJzb2x1dGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JpdGVNZWFzdXJlKG1lYXN1cmVkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG1lYXN1cmVkLm1ha2VBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBlZGl0b3IsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCBwb3MuYm90dG9tIDw9IE1hdGgubWF4KGVkaXRvci50b3AsIHNwYWNlLnRvcCkgfHxcbiAgICAgICAgICAgICAgICBwb3MudG9wID49IE1hdGgubWluKGVkaXRvci5ib3R0b20sIHNwYWNlLmJvdHRvbSkgfHxcbiAgICAgICAgICAgICAgICBwb3MucmlnaHQgPCBNYXRoLm1heChlZGl0b3IubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4oZWRpdG9yLnJpZ2h0LCBzcGFjZS5yaWdodCkgKyAuMSkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFycm93ID0gdG9vbHRpcC5hcnJvdyA/IHRWaWV3LmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXRvb2x0aXAtYXJyb3dcIikgOiBudWxsO1xuICAgICAgICAgICAgbGV0IGFycm93SGVpZ2h0ID0gYXJyb3cgPyA3IC8qIEFycm93LlNpemUgKi8gOiAwO1xuICAgICAgICAgICAgbGV0IHdpZHRoID0gc2l6ZS5yaWdodCAtIHNpemUubGVmdCwgaGVpZ2h0ID0gKF9hID0ga25vd25IZWlnaHQuZ2V0KHRWaWV3KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2l6ZS5ib3R0b20gLSBzaXplLnRvcDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0Vmlldy5vZmZzZXQgfHwgbm9PZmZzZXQsIGx0ciA9IHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IHNpemUud2lkdGggPiBzcGFjZS5yaWdodCAtIHNwYWNlLmxlZnQgPyAobHRyID8gc3BhY2UubGVmdCA6IHNwYWNlLnJpZ2h0IC0gc2l6ZS53aWR0aClcbiAgICAgICAgICAgICAgICA6IGx0ciA/IE1hdGgubWluKHBvcy5sZWZ0IC0gKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgKyBvZmZzZXQueCwgc3BhY2UucmlnaHQgLSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1heChzcGFjZS5sZWZ0LCBwb3MubGVmdCAtIHdpZHRoICsgKGFycm93ID8gMTQgLyogQXJyb3cuT2Zmc2V0ICovIDogMCkgLSBvZmZzZXQueCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApIC0gb2Zmc2V0LnkgPCBzcGFjZS50b3BcbiAgICAgICAgICAgICAgICA6IHBvcy5ib3R0b20gKyAoc2l6ZS5ib3R0b20gLSBzaXplLnRvcCkgKyBvZmZzZXQueSA+IHNwYWNlLmJvdHRvbSkgJiZcbiAgICAgICAgICAgICAgICBhYm92ZSA9PSAoc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSA+IHBvcy50b3AgLSBzcGFjZS50b3ApKVxuICAgICAgICAgICAgICAgIGFib3ZlID0gdGhpcy5hYm92ZVtpXSA9ICFhYm92ZTtcbiAgICAgICAgICAgIGxldCBzcGFjZVZlcnQgPSAoYWJvdmUgPyBwb3MudG9wIC0gc3BhY2UudG9wIDogc3BhY2UuYm90dG9tIC0gcG9zLmJvdHRvbSkgLSBhcnJvd0hlaWdodDtcbiAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCBoZWlnaHQgJiYgdFZpZXcucmVzaXplICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZVZlcnQgPCB0aGlzLnZpZXcuZGVmYXVsdExpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrbm93bkhlaWdodC5zZXQodFZpZXcsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLmhlaWdodCA9IChoZWlnaHQgPSBzcGFjZVZlcnQpIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRvcCA9IGFib3ZlID8gcG9zLnRvcCAtIGhlaWdodCAtIGFycm93SGVpZ2h0IC0gb2Zmc2V0LnkgOiBwb3MuYm90dG9tICsgYXJyb3dIZWlnaHQgKyBvZmZzZXQueTtcbiAgICAgICAgICAgIGxldCByaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2Ygb3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5sZWZ0IDwgcmlnaHQgJiYgci5yaWdodCA+IGxlZnQgJiYgci50b3AgPCB0b3AgKyBoZWlnaHQgJiYgci5ib3R0b20gPiB0b3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBhYm92ZSA/IHIudG9wIC0gaGVpZ2h0IC0gMiAtIGFycm93SGVpZ2h0IDogci5ib3R0b20gKyBhcnJvd0hlaWdodCArIDI7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gKHRvcCAtIG1lYXN1cmVkLnBhcmVudC50b3ApIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gKGxlZnQgLSBtZWFzdXJlZC5wYXJlbnQubGVmdCkgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5sZWZ0ID0gbGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcnJvdykge1xuICAgICAgICAgICAgICAgIGxldCBhcnJvd0xlZnQgPSBwb3MubGVmdCArIChsdHIgPyBvZmZzZXQueCA6IC1vZmZzZXQueCkgLSAobGVmdCArIDE0IC8qIEFycm93Lk9mZnNldCAqLyAtIDcgLyogQXJyb3cuU2l6ZSAqLyk7XG4gICAgICAgICAgICAgICAgYXJyb3cuc3R5bGUubGVmdCA9IGFycm93TGVmdCAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0Vmlldy5vdmVybGFwICE9PSB0cnVlKVxuICAgICAgICAgICAgICAgIG90aGVycy5wdXNoKHsgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tOiB0b3AgKyBoZWlnaHQgfSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgYWJvdmUpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWJlbG93XCIsICFhYm92ZSk7XG4gICAgICAgICAgICBpZiAodFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICB0Vmlldy5wb3NpdGlvbmVkKG1lYXN1cmVkLnNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZU1lYXN1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluVmlldyAhPSB0aGlzLnZpZXcuaW5WaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pblZpZXcgPSB0aGlzLnZpZXcuaW5WaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHR2IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0di5kb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBzY3JvbGwoKSB7IHRoaXMubWF5YmVNZWFzdXJlKCk7IH1cbiAgICB9XG59KTtcbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2JiYlwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdG9vbHRpcC1zZWN0aW9uOm5vdCg6Zmlyc3QtY2hpbGQpXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIGhlaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgd2lkdGg6IGAkezcgLyogQXJyb3cuU2l6ZSAqLyAqIDJ9cHhgLFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICAgICAgICBib3R0b206IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICBib3R0b206IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgICAgICAgIHRvcDogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIHRvcDogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvd1wiOiB7XG4gICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzMzMzMzOFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9XG4gICAgfVxufSk7XG5jb25zdCBub09mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuLyoqXG5GYWNldCB0byB3aGljaCBhbiBleHRlbnNpb24gY2FuIGFkZCBhIHZhbHVlIHRvIHNob3cgYSB0b29sdGlwLlxuKi9cbmNvbnN0IHNob3dUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgZW5hYmxlczogW3Rvb2x0aXBQbHVnaW4sIGJhc2VUaGVtZV1cbn0pO1xuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIEhvdmVyVG9vbHRpcEhvc3Qge1xuICAgIC8vIE5lZWRzIHRvIGJlIHN0YXRpYyBzbyB0aGF0IGhvc3QgdG9vbHRpcCBpbnN0YW5jZXMgYWx3YXlzIG1hdGNoXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgSG92ZXJUb29sdGlwSG9zdCh2aWV3KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1ob3ZlclwiKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93SG92ZXJUb29sdGlwLCB0ID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0KSwgdCA9PiB0LmRvbS5yZW1vdmUoKSk7XG4gICAgfVxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCkge1xuICAgICAgICBsZXQgaG9zdGVkVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGhvc3RlZFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLXNlY3Rpb25cIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhvc3RlZFZpZXcuZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCAmJiBob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh0aGlzLnZpZXcpO1xuICAgICAgICByZXR1cm4gaG9zdGVkVmlldztcbiAgICB9XG4gICAgbW91bnQodmlldykge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3Lm1vdW50KVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zaXRpb25lZChzcGFjZSkge1xuICAgICAgICBmb3IgKGxldCBob3N0ZWRWaWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGlmIChob3N0ZWRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5wb3NpdGlvbmVkKHNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci51cGRhdGUodXBkYXRlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAoX2EgPSB0LmRlc3Ryb3kpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHQpO1xuICAgIH1cbiAgICBwYXNzUHJvcChuYW1lKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBsZXQgZ2l2ZW4gPSB2aWV3W25hbWVdO1xuICAgICAgICAgICAgaWYgKGdpdmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnaXZlbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gZ2l2ZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcIm9mZnNldFwiKTsgfVxuICAgIGdldCBnZXRDb29yZHMoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwiZ2V0Q29vcmRzXCIpOyB9XG4gICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib3ZlcmxhcFwiKTsgfVxuICAgIGdldCByZXNpemUoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwicmVzaXplXCIpOyB9XG59XG5jb25zdCBzaG93SG92ZXJUb29sdGlwSG9zdCA9IC8qQF9fUFVSRV9fKi9zaG93VG9vbHRpcC5jb21wdXRlKFtzaG93SG92ZXJUb29sdGlwXSwgc3RhdGUgPT4ge1xuICAgIGxldCB0b29sdGlwcyA9IHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLmZpbHRlcih0ID0+IHQpO1xuICAgIGlmICh0b29sdGlwcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvczogTWF0aC5taW4oLi4udG9vbHRpcHMubWFwKHQgPT4gdC5wb3MpKSxcbiAgICAgICAgZW5kOiBNYXRoLm1heCguLi50b29sdGlwcy5tYXAodCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHQuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0LnBvczsgfSkpLFxuICAgICAgICBjcmVhdGU6IEhvdmVyVG9vbHRpcEhvc3QuY3JlYXRlLFxuICAgICAgICBhYm92ZTogdG9vbHRpcHNbMF0uYWJvdmUsXG4gICAgICAgIGFycm93OiB0b29sdGlwcy5zb21lKHQgPT4gdC5hcnJvdyksXG4gICAgfTtcbn0pO1xuY2xhc3MgSG92ZXJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHNvdXJjZSwgZmllbGQsIHNldEhvdmVyLCBob3ZlclRpbWUpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5zZXRIb3ZlciA9IHNldEhvdmVyO1xuICAgICAgICB0aGlzLmhvdmVyVGltZSA9IGhvdmVyVGltZTtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiAwLCB5OiAwLCB0YXJnZXQ6IHZpZXcuZG9tLCB0aW1lOiAwIH07XG4gICAgICAgIHRoaXMuY2hlY2tIb3ZlciA9IHRoaXMuY2hlY2tIb3Zlci5iaW5kKHRoaXMpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUgPSB0aGlzLm1vdXNlbGVhdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUgPSB0aGlzLm1vdXNlbW92ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzdGFydFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydEhvdmVyKCksIDIwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuZmllbGQpO1xuICAgIH1cbiAgICBjaGVja0hvdmVyKCkge1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGxhc3RNb3ZlLnRhcmdldCk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcywgc2lkZSA9IDE7XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgV2lkZ2V0Vmlldykge1xuICAgICAgICAgICAgcG9zID0gZGVzYy5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihyZXN1bHQpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3Blbikge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2Yob3BlbikgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7XG4gICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgICAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5maW5kSW5kZXgodCA9PiB0LmNyZWF0ZSA9PSBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSwgdGFyZ2V0OiBldmVudC50YXJnZXQsIHRpbWU6IERhdGUubm93KCkgfTtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lKTtcbiAgICAgICAgbGV0IHsgYWN0aXZlLCB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYWN0aXZlICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYSA9IGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZS5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcztcbiAgICAgICAgICAgIGlmICgocG9zID09IGVuZCA/IHRoaXMudmlldy5wb3NBdENvb3Jkcyh0aGlzLmxhc3RNb3ZlKSAhPSBwb3NcbiAgICAgICAgICAgICAgICA6ICFpc092ZXJSYW5nZSh0aGlzLnZpZXcsIHBvcywgZW5kLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKG51bGwpIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCB7IHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgaW5Ub29sdGlwID0gdG9vbHRpcCAmJiB0b29sdGlwLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaW5Ub29sdGlwKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy53YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcCkge1xuICAgICAgICBsZXQgd2F0Y2ggPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YobnVsbCkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuY29uc3QgdG9vbHRpcE1hcmdpbiA9IDQ7XG5mdW5jdGlvbiBpc0luVG9vbHRpcCh0b29sdGlwLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFggPD0gcmVjdC5yaWdodCArIHRvb2x0aXBNYXJnaW4gJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA+PSByZWN0LnRvcCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbSArIHRvb2x0aXBNYXJnaW47XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jQm90dG9tID0gdmlldy5kb2N1bWVudFRvcCArIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCArIHZpZXcuY29udGVudEhlaWdodDtcbiAgICBpZiAocmVjdC5sZWZ0ID4geCB8fCByZWN0LnJpZ2h0IDwgeCB8fCByZWN0LnRvcCA+IHkgfHwgTWF0aC5taW4ocmVjdC5ib3R0b20sIGRvY0JvdHRvbSkgPCB5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4LCB5IH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhpZGVPbiAmJiBvcHRpb25zLmhpZGVPbih0ciwgdmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1BvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkuZW5kID0gdHIuY2hhbmdlcy5tYXBQb3ModmFsdWUuZW5kKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0SG92ZXIpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9XG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyc1wiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayk7XG4gICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgYmxvY2ssIFttYXJrZXJdKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCwgeTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2cCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UgPyB0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlKHVwZGF0ZSkgOiBmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAgICAgZWx0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5jbGFzcyBHdXR0ZXJFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMuYWJvdmUgPSAwO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlckVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiB1cGRhdGUgPT4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLFxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgbWF4TGluZU51bWJlcih2aWV3LnN0YXRlLmRvYy5saW5lcykpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbWF4ID0gZm9ybWF0TnVtYmVyKHVwZGF0ZS52aWV3LCBtYXhMaW5lTnVtYmVyKHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lcykpO1xuICAgICAgICByZXR1cm4gbWF4ID09IHNwYWNlci5udW1iZXIgPyBzcGFjZXIgOiBuZXcgTnVtYmVyTWFya2VyKG1heCk7XG4gICAgfSxcbiAgICBkb21FdmVudEhhbmRsZXJzOiBzdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5kb21FdmVudEhhbmRsZXJzXG59KSk7XG4vKipcbkNyZWF0ZSBhIGxpbmUgbnVtYmVyIGd1dHRlciBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW5lTnVtYmVyQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGd1dHRlcnMoKSxcbiAgICAgICAgbGluZU51bWJlckd1dHRlclxuICAgIF07XG59XG5mdW5jdGlvbiBtYXhMaW5lTnVtYmVyKGxpbmVzKSB7XG4gICAgbGV0IGxhc3QgPSA5O1xuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXG4gICAgICAgIGxhc3QgPSBsYXN0ICogMTAgKyA5O1xuICAgIHJldHVybiBsYXN0O1xufVxuY29uc3QgYWN0aXZlTGluZUd1dHRlck1hcmtlciA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovZ3V0dGVyTGluZUNsYXNzLmNvbXB1dGUoW1wic2VsZWN0aW9uXCJdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IG1hcmtzID0gW10sIGxhc3QgPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgICAgICBpZiAobGluZVBvcyA+IGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lUG9zO1xuICAgICAgICAgICAgbWFya3MucHVzaChhY3RpdmVMaW5lR3V0dGVyTWFya2VyLnJhbmdlKGxpbmVQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya3MpO1xufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS1hY3RpdmVMaW5lR3V0dGVyYCBjbGFzcyB0b1xuYWxsIGd1dHRlciBlbGVtZW50cyBvbiB0aGUgW2FjdGl2ZVxubGluZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlcjtcbn1cblxuY29uc3QgV2hpdGVzcGFjZURlY28gPSAvKkBfX1BVUkVfXyovbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZURlY28oc3BhY2UpIHtcbiAgICBsZXQgZGVjbyA9IFdoaXRlc3BhY2VEZWNvLmdldChzcGFjZSk7XG4gICAgaWYgKCFkZWNvKVxuICAgICAgICBXaGl0ZXNwYWNlRGVjby5zZXQoc3BhY2UsIGRlY28gPSBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogc3BhY2UgPT09IFwiXFx0XCIgPyB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIsXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhLWRpc3BsYXlcIjogc3BhY2UucmVwbGFjZSgvIC9nLCBcIsK3XCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICByZXR1cm4gZGVjbztcbn1cbmZ1bmN0aW9uIG1hdGNoZXIoZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gKHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpLFxuICAgICAgICB1cGRhdGUodSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRvci51cGRhdGVEZWNvKHUsIHRoaXMuZGVjb3JhdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH0pLCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KTtcbn1cbmNvbnN0IHdoaXRlc3BhY2VIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xcdHwgKy9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IGdldFdoaXRlc3BhY2VEZWNvKG1hdGNoWzBdKSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlnaGxpZ2h0cyB3aGl0ZXNwYWNlLCBhZGRpbmcgYVxuYGNtLWhpZ2hsaWdodFNwYWNlYCBjbGFzcyB0byBzdHJldGNoZXMgb2Ygc3BhY2VzLCBhbmQgYVxuYGNtLWhpZ2hsaWdodFRhYmAgY2xhc3MgdG8gaW5kaXZpZHVhbCB0YWIgY2hhcmFjdGVycy4gQnkgZGVmYXVsdCxcbnRoZSBmb3JtZXIgYXJlIHNob3duIGFzIGZhaW50IGRvdHMsIGFuZCB0aGUgbGF0dGVyIGFzIGFycm93cy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCB0cmFpbGluZ0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFxzKyQvZyxcbiAgICBkZWNvcmF0aW9uOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tdHJhaWxpbmdTcGFjZVwiIH0pLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLXRyYWlsaW5nU3BhY2VgIGNsYXNzIHRvIGFsbFxudHJhaWxpbmcgd2hpdGVzcGFjZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRyYWlsaW5nSGlnaGxpZ2h0ZXI7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZywgZ2V0UGFuZWwsIGdldFRvb2x0aXAsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJzLCBoYXNIb3ZlclRvb2x0aXBzLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSwgaGlnaGxpZ2h0V2hpdGVzcGFjZSwgaG92ZXJUb29sdGlwLCBrZXltYXAsIGxheWVyLCBsaW5lTnVtYmVyTWFya2VycywgbGluZU51bWJlcnMsIGxvZ0V4Y2VwdGlvbiwgcGFuZWxzLCBwbGFjZWhvbGRlciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIHJlcG9zaXRpb25Ub29sdGlwcywgcnVuU2NvcGVIYW5kbGVycywgc2Nyb2xsUGFzdEVuZCwgc2hvd1BhbmVsLCBzaG93VG9vbHRpcCwgdG9vbHRpcHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/view/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n  /**\n  Create a new node prop type.\n  */\n  constructor(config = {}) {\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n    this.deserialize = config.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  }\n  /**\n  This is meant to be used with\n  [`NodeSet.extend`](#common.NodeSet.extend) or\n  [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  prop values for each node type in the set. Takes a [match\n  object](#common.NodeType^match) or function that returns undefined\n  if the node type doesn't get this prop, and the prop's value if\n  it does.\n  */\n  add(match) {\n    if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/\nNodeProp.isolate = new NodeProp({\n  deserialize: value => {\n    if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n    return value || \"auto\";\n  }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({\n  perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n  constructor(\n  /**\n  The inner tree.\n  */\n  tree,\n  /**\n  If this is null, this tree replaces the entire node (it will\n  be included in the regular iteration instead of its host\n  node). If not, only the given ranges are considered to be\n  covered by this tree. This is used for trees that are mixed in\n  a way that isn't strictly hierarchical. Such mounted trees are\n  only entered by [`resolveInner`](#common.Tree.resolveInner)\n  and [`enter`](#common.SyntaxNode.enter).\n  */\n  overlay,\n  /**\n  The parser used to create this subtree.\n  */\n  parser) {\n    this.tree = tree;\n    this.overlay = overlay;\n    this.parser = parser;\n  }\n  /**\n  @internal\n  */\n  static get(tree) {\n    return tree && tree.props && tree.props[NodeProp.mounted.id];\n  }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The name of the node type. Not necessarily unique, but if the\n  grammar was written properly, different node types with the\n  same name within a node set should play the same semantic\n  role.\n  */\n  name,\n  /**\n  @internal\n  */\n  props,\n  /**\n  The id of this node in its set. Corresponds to the term ids\n  used in the parser.\n  */\n  id,\n  /**\n  @internal\n  */\n  flags = 0) {\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n  /**\n  Define a node type.\n  */\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) | (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n      if (src) {\n        if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n        props[src[0].id] = src[1];\n      }\n    }\n    return type;\n  }\n  /**\n  Retrieves a node prop for this type. Will return `undefined` if\n  the prop isn't present on this node.\n  */\n  prop(prop) {\n    return this.props[prop.id];\n  }\n  /**\n  True when this is the top node of a grammar.\n  */\n  get isTop() {\n    return (this.flags & 1 /* NodeFlag.Top */) > 0;\n  }\n  /**\n  True when this node is produced by a skip rule.\n  */\n  get isSkipped() {\n    return (this.flags & 2 /* NodeFlag.Skipped */) > 0;\n  }\n  /**\n  Indicates whether this is an error node.\n  */\n  get isError() {\n    return (this.flags & 4 /* NodeFlag.Error */) > 0;\n  }\n  /**\n  When true, this node type doesn't correspond to a user-declared\n  named node, for example because it is used to cache repetition.\n  */\n  get isAnonymous() {\n    return (this.flags & 8 /* NodeFlag.Anonymous */) > 0;\n  }\n  /**\n  Returns true when this node's name or one of its\n  [groups](#common.NodeProp^group) matches the given string.\n  */\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n    return this.id == name;\n  }\n  /**\n  Create a function from node types to arbitrary values by\n  specifying an object whose property names are node or\n  [group](#common.NodeProp^group) names. Often useful with\n  [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  names, separated by spaces, in a single property name to map\n  multiple node names to a single value.\n  */\n  static match(map) {\n    let direct = Object.create(null);\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n  /**\n  Create a set with the given types. The `id` property of each\n  type should correspond to its position within the array.\n  */\n  constructor(\n  /**\n  The node types in this set, by id.\n  */\n  types) {\n    this.types = types;\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  /**\n  Create a copy of this set with some node properties added. The\n  arguments to this method can be created with\n  [`NodeProp.add`](#common.NodeProp.add).\n  */\n  extend(...props) {\n    let newTypes = [];\n    for (let type of this.types) {\n      let newProps = null;\n      for (let source of props) {\n        let add = source(type);\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          newProps[add[0].id] = add[1];\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n    return new NodeSet(newTypes);\n  }\n}\nconst CachedNode = new WeakMap(),\n  CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n  /**\n  When enabled, iteration will only visit [`Tree`](#common.Tree)\n  objects, not nodes packed into\n  [`TreeBuffer`](#common.TreeBuffer)s.\n  */\n  IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n  /**\n  Enable this to make iteration include anonymous nodes (such as\n  the nodes that wrap repeated grammar constructs into a balanced\n  tree).\n  */\n  IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n  /**\n  By default, regular [mounted](#common.NodeProp^mounted) nodes\n  replace their base node in iteration. Enable this to ignore them\n  instead.\n  */\n  IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n  /**\n  This option only applies in\n  [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n  library to not enter mounted overlays if one covers the given\n  position.\n  */\n  IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n  /**\n  Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  */\n  constructor(\n  /**\n  The type of the top node.\n  */\n  type,\n  /**\n  This node's child nodes.\n  */\n  children,\n  /**\n  The positions (offsets relative to the start of this tree) of\n  the children.\n  */\n  positions,\n  /**\n  The total length of this tree\n  */\n  length,\n  /**\n  Per-node [node props](#common.NodeProp) to associate with this node.\n  */\n  props) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n    /**\n    @internal\n    */\n    this.props = null;\n    if (props && props.length) {\n      this.props = Object.create(null);\n      for (let [prop, value] of props) this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n    }\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let mounted = MountedTree.get(this);\n    if (mounted && !mounted.overlay) return mounted.tree.toString();\n    let children = \"\";\n    for (let ch of this.children) {\n      let str = ch.toString();\n      if (str) {\n        if (children) children += \",\";\n        children += str;\n      }\n    }\n    return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) positioned at the top of\n  the tree. Mode can be used to [control](#common.IterMode) which\n  nodes the cursor visits.\n  */\n  cursor(mode = 0) {\n    return new TreeCursor(this.topNode, mode);\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) pointing into this tree\n  at the given position and side (see\n  [`moveTo`](#common.TreeCursor.moveTo).\n  */\n  cursorAt(pos, side = 0, mode = 0) {\n    let scope = CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n    cursor.moveTo(pos, side);\n    CachedNode.set(this, cursor._tree);\n    return cursor;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) object for the top of the\n  tree.\n  */\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  }\n  /**\n  Get the [syntax node](#common.SyntaxNode) at the given position.\n  If `side` is -1, this will move into nodes that end at the\n  position. If 1, it'll move into nodes that start at the\n  position. With 0, it'll only enter nodes that cover the position\n  from both sides.\n  \n  Note that this will not enter\n  [overlays](#common.MountedTree.overlay), and you often want\n  [`resolveInner`](#common.Tree.resolveInner) instead.\n  */\n  resolve(pos, side = 0) {\n    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n    CachedNode.set(this, node);\n    return node;\n  }\n  /**\n  Like [`resolve`](#common.Tree.resolve), but will enter\n  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  pointing into the innermost overlaid tree at the given position\n  (with parent links going through all parent structure, including\n  the host trees).\n  */\n  resolveInner(pos, side = 0) {\n    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n    CachedInnerNode.set(this, node);\n    return node;\n  }\n  /**\n  In some situations, it can be useful to iterate through all\n  nodes around a position, including those in overlays that don't\n  directly cover the position. This method gives you an iterator\n  that will produce all nodes, from small to big, around the given\n  position.\n  */\n  resolveStack(pos, side = 0) {\n    return stackIterator(this, pos, side);\n  }\n  /**\n  Iterate over the tree and its children, calling `enter` for any\n  node that touches the `from`/`to` region (if given) before\n  running over such a node's children, and `leave` (if given) when\n  leaving the node. When `enter` returns `false`, that node will\n  not have its children iterated over (or `leave` called).\n  */\n  iterate(spec) {\n    let {\n      enter,\n      leave,\n      from = 0,\n      to = this.length\n    } = spec;\n    let mode = spec.mode || 0,\n      anon = (mode & IterMode.IncludeAnonymous) > 0;\n    for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n      let entered = false;\n      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n        if (c.firstChild()) continue;\n        entered = true;\n      }\n      for (;;) {\n        if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        entered = true;\n      }\n    }\n  }\n  /**\n  Get the value of the given [node prop](#common.NodeProp) for this\n  node. Works with both per-node and per-type props.\n  */\n  prop(prop) {\n    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n  }\n  /**\n  Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  format that can be passed to the [`Tree`](#common.Tree)\n  constructor.\n  */\n  get propValues() {\n    let result = [];\n    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);\n    return result;\n  }\n  /**\n  Balance the direct children of this tree, producing a copy of\n  which may have children grouped into subtrees with type\n  [`NodeType.none`](#common.NodeType^none).\n  */\n  balance(config = {}) {\n    return this.children.length <= 8 /* Balance.BranchFactor */ ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n  }\n  /**\n  Build a tree from a postfix-ordered buffer of node information,\n  or a cursor over such a buffer.\n  */\n  static build(data) {\n    return buildTree(data);\n  }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  get pos() {\n    return this.index;\n  }\n  next() {\n    this.index -= 4;\n  }\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n  /**\n  Create a tree buffer.\n  */\n  constructor(\n  /**\n  The buffer's content.\n  */\n  buffer,\n  /**\n  The total length of the group of nodes in the buffer.\n  */\n  length,\n  /**\n  The node set used in this buffer.\n  */\n  set) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  }\n  /**\n  @internal\n  */\n  get type() {\n    return NodeType.none;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let result = [];\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result.join(\",\");\n  }\n  /**\n  @internal\n  */\n  childString(index) {\n    let id = this.buffer[index],\n      endIndex = this.buffer[index + 3];\n    let type = this.set.types[id],\n      result = type.name;\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result + \"(\" + children.join(\",\") + \")\";\n  }\n  /**\n  @internal\n  */\n  findChild(startIndex, endIndex, dir, pos, side) {\n    let {\n        buffer\n      } = this,\n      pick = -1;\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n    return pick;\n  }\n  /**\n  @internal\n  */\n  slice(startI, endI, from) {\n    let b = this.buffer;\n    let copy = new Uint16Array(endI - startI),\n      len = 0;\n    for (let i = startI, j = 0; i < endI;) {\n      copy[j++] = b[i++];\n      copy[j++] = b[i++] - from;\n      let to = copy[j++] = b[i++] - from;\n      copy[j++] = b[i++] - startI;\n      len = Math.max(len, to);\n    }\n    return new TreeBuffer(copy, len, this.set);\n  }\n}\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2 /* Side.Before */:\n      return from < pos;\n    case -1 /* Side.AtOrBefore */:\n      return to >= pos && from < pos;\n    case 0 /* Side.Around */:\n      return from < pos && to > pos;\n    case 1 /* Side.AtOrAfter */:\n      return from <= pos && to > pos;\n    case 2 /* Side.After */:\n      return to > pos;\n    case 4 /* Side.DontCare */:\n      return true;\n  }\n}\nfunction resolveNode(node, pos, side, overlays) {\n  var _a;\n  // Move up to a node that actually holds the position, if possible\n  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {\n    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n    if (!parent) return node;\n    node = parent;\n  }\n  let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n  // Must go up out of overlays when those do not overlap with pos\n  if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n    if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n  }\n  for (;;) {\n    let inner = node.enter(pos, side, mode);\n    if (!inner) return node;\n    node = inner;\n  }\n}\nclass BaseNode {\n  cursor(mode = 0) {\n    return new TreeCursor(this, mode);\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n  resolve(pos, side = 0) {\n    return resolveNode(this, pos, side, false);\n  }\n  resolveInner(pos, side = 0) {\n    return resolveNode(this, pos, side, true);\n  }\n  matchContext(context) {\n    return matchNodeContext(this, context);\n  }\n  enterUnfinishedNodesBefore(pos) {\n    let scan = this.childBefore(pos),\n      node = this;\n    while (scan) {\n      let last = scan.lastChild;\n      if (!last || last.to != scan.to) break;\n      if (last.type.isError && last.from == last.to) {\n        node = scan;\n        scan = last.prevSibling;\n      } else {\n        scan = last;\n      }\n    }\n    return node;\n  }\n  get node() {\n    return this;\n  }\n  get next() {\n    return this.parent;\n  }\n}\nclass TreeNode extends BaseNode {\n  constructor(_tree, from,\n  // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    super();\n    this._tree = _tree;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n  get type() {\n    return this._tree.type;\n  }\n  get name() {\n    return this._tree.type.name;\n  }\n  get to() {\n    return this.from + this._tree.length;\n  }\n  nextChild(i, dir, pos, side, mode = 0) {\n    for (let parent = this;;) {\n      for (let {\n          children,\n          positions\n        } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i],\n          start = positions[i] + parent.from;\n        if (!checkSide(side, pos, start, start + next.length)) continue;\n        if (next instanceof TreeBuffer) {\n          if (mode & IterMode.ExcludeBuffers) continue;\n          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n          let mounted;\n          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n          let inner = new TreeNode(next, start, i, parent);\n          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n        }\n      }\n      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n  get firstChild() {\n    return this.nextChild(0, 1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    let mounted;\n    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n      let rPos = pos - this.from;\n      for (let {\n        from,\n        to\n      } of mounted.overlay) {\n        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n      }\n    }\n    return this.nextChild(0, 1, pos, side, mode);\n  }\n  nextSignificantParent() {\n    let val = this;\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n    return val;\n  }\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n  }\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n  }\n  get tree() {\n    return this._tree;\n  }\n  toTree() {\n    return this._tree;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this._tree.toString();\n  }\n}\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor(),\n    result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) for (let found = false; !found;) {\n    found = cur.type.is(before);\n    if (!cur.nextSibling()) return result;\n  }\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n  for (let p = node.parent; i >= 0; p = p.parent) {\n    if (!p) return false;\n    if (!p.type.isAnonymous) {\n      if (context[i] && context[i] != p.name) return false;\n      i--;\n    }\n  }\n  return true;\n}\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n}\nclass BufferNode extends BaseNode {\n  get name() {\n    return this.type.name;\n  }\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n  constructor(context, _parent, index) {\n    super();\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n  child(dir, pos, side) {\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get firstChild() {\n    return this.child(1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.child(-1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.child(1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.child(-1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    if (mode & IterMode.ExcludeBuffers) return null;\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n  }\n  get nextSibling() {\n    let {\n      buffer\n    } = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n  get prevSibling() {\n    let {\n      buffer\n    } = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n  }\n  get tree() {\n    return null;\n  }\n  toTree() {\n    let children = [],\n      positions = [];\n    let {\n      buffer\n    } = this.context;\n    let startI = this.index + 4,\n      endI = buffer.buffer[this.index + 3];\n    if (endI > startI) {\n      let from = buffer.buffer[this.index + 1];\n      children.push(buffer.slice(startI, endI, from));\n      positions.push(0);\n    }\n    return new Tree(this.type, children, positions, this.to - this.from);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n}\nfunction iterStack(heads) {\n  if (!heads.length) return null;\n  let pick = 0,\n    picked = heads[0];\n  for (let i = 1; i < heads.length; i++) {\n    let node = heads[i];\n    if (node.from > picked.from || node.to < picked.to) {\n      picked = node;\n      pick = i;\n    }\n  }\n  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n  let newHeads = heads.slice();\n  if (next) newHeads[pick] = next;else newHeads.splice(pick, 1);\n  return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n  constructor(heads, node) {\n    this.heads = heads;\n    this.node = node;\n  }\n  get next() {\n    return iterStack(this.heads);\n  }\n}\nfunction stackIterator(tree, pos, side) {\n  let inner = tree.resolveInner(pos, side),\n    layers = null;\n  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {\n    if (scan.index < 0) {\n      // This is an overlay root\n      let parent = scan.parent;\n      (layers || (layers = [inner])).push(parent.resolve(pos, side));\n      scan = parent;\n    } else {\n      let mount = MountedTree.get(scan.tree);\n      // Relevant overlay branching off\n      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));\n      }\n    }\n  }\n  return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n  /**\n  Shorthand for `.type.name`.\n  */\n  get name() {\n    return this.type.name;\n  }\n  /**\n  @internal\n  */\n  constructor(node,\n  /**\n  @internal\n  */\n  mode = 0) {\n    this.mode = mode;\n    /**\n    @internal\n    */\n    this.buffer = null;\n    this.stack = [];\n    /**\n    @internal\n    */\n    this.index = 0;\n    this.bufferNode = null;\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  }\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n  yieldBuf(index, type) {\n    this.index = index;\n    let {\n      start,\n      buffer\n    } = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n  /**\n  @internal\n  */\n  yield(node) {\n    if (!node) return false;\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  }\n  /**\n  @internal\n  */\n  enterChild(dir, pos, side) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n    let {\n      buffer\n    } = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  }\n  /**\n  Move the cursor to this node's first child. When this returns\n  false, the node has no child, and the cursor has not been moved.\n  */\n  firstChild() {\n    return this.enterChild(1, 0, 4 /* Side.DontCare */);\n  }\n  /**\n  Move the cursor to this node's last child.\n  */\n  lastChild() {\n    return this.enterChild(-1, 0, 4 /* Side.DontCare */);\n  }\n  /**\n  Move the cursor to the first child that ends after `pos`.\n  */\n  childAfter(pos) {\n    return this.enterChild(1, pos, 2 /* Side.After */);\n  }\n  /**\n  Move to the last child that starts before `pos`.\n  */\n  childBefore(pos) {\n    return this.enterChild(-1, pos, -2 /* Side.Before */);\n  }\n  /**\n  Move the cursor to the child around `pos`. If side is -1 the\n  child may end at that position, when 1 it may start there. This\n  will also enter [overlaid](#common.MountedTree.overlay)\n  [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  set to false.\n  */\n  enter(pos, side, mode = this.mode) {\n    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n  }\n  /**\n  Move to the node's parent node, if this isn't the top node.\n  */\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  }\n  /**\n  @internal\n  */\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n    let {\n        buffer\n      } = this.buffer,\n      d = this.stack.length - 1;\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n  }\n  /**\n  Move to this node's next sibling, if any.\n  */\n  nextSibling() {\n    return this.sibling(1);\n  }\n  /**\n  Move to this node's previous sibling, if any.\n  */\n  prevSibling() {\n    return this.sibling(-1);\n  }\n  atLastNode(dir) {\n    let index,\n      parent,\n      {\n        buffer\n      } = this;\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n      ({\n        index,\n        parent\n      } = buffer);\n    } else {\n      ({\n        index,\n        _parent: parent\n      } = this._tree);\n    }\n    for (; parent; ({\n      index,\n      _parent: parent\n    } = parent)) {\n      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n        let child = parent._tree.children[i];\n        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n      }\n    }\n    return true;\n  }\n  move(dir, enter) {\n    if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true;\n    for (;;) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  }\n  /**\n  Move to the next node in a\n  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n  traversal, going from a node to its first child or, if the\n  current node is empty or `enter` is false, its next sibling or\n  the next sibling of the first parent node that has one.\n  */\n  next(enter = true) {\n    return this.move(1, enter);\n  }\n  /**\n  Move to the next node in a last-to-first pre-order traveral. A\n  node is followed by its last child or, if it has none, its\n  previous sibling or the previous sibling of the first parent\n  node that has one.\n  */\n  prev(enter = true) {\n    return this.move(-1, enter);\n  }\n  /**\n  Move the cursor to the innermost node that covers `pos`. If\n  `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  it will enter nodes that start at `pos`.\n  */\n  moveTo(pos, side = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;\n    // Then scan down into child nodes as far as possible\n    while (this.enterChild(1, pos, side)) {}\n    return this;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  position.\n  */\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode,\n      result = null,\n      depth = 0;\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n        index = this.stack[--d];\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  }\n  /**\n  Get the [tree](#common.Tree) that represents the current node, if\n  any. Will return null when the node is in a [tree\n  buffer](#common.TreeBuffer).\n  */\n  get tree() {\n    return this.buffer ? null : this._tree._tree;\n  }\n  /**\n  Iterate over the current node and all its descendants, calling\n  `enter` when entering a node and `leave`, if given, when leaving\n  one. When `enter` returns `false`, any children of that node are\n  skipped, and `leave` isn't called for it.\n  */\n  iterate(enter, leave) {\n    for (let depth = 0;;) {\n      let mustLeave = false;\n      if (this.type.isAnonymous || enter(this) !== false) {\n        if (this.firstChild()) {\n          depth++;\n          continue;\n        }\n        if (!this.type.isAnonymous) mustLeave = true;\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(this);\n        mustLeave = this.type.isAnonymous;\n        if (this.nextSibling()) break;\n        if (!depth) return;\n        this.parent();\n        depth--;\n        mustLeave = true;\n      }\n    }\n  }\n  /**\n  Test whether the current node matches a given context—a sequence\n  of direct parent node names. Empty strings in the context array\n  are treated as wildcards.\n  */\n  matchContext(context) {\n    if (!this.buffer) return matchNodeContext(this.node, context);\n    let {\n        buffer\n      } = this.buffer,\n      {\n        types\n      } = buffer.set;\n    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n      if (d < 0) return matchNodeContext(this.node, context, i);\n      let type = types[buffer.buffer[this.stack[d]]];\n      if (!type.isAnonymous) {\n        if (context[i] && context[i] != type.name) return false;\n        i--;\n      }\n    }\n    return true;\n  }\n}\nfunction hasChild(tree) {\n  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n  var _a;\n  let {\n    buffer,\n    nodeSet,\n    maxBufferLength = DefaultBufferLength,\n    reused = [],\n    minRepeatType = nodeSet.types.length\n  } = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0,\n    lookAhead = 0;\n  function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    let lookAheadAtStart = lookAhead;\n    while (size < 0) {\n      cursor.next();\n      if (size == -1 /* SpecialRecord.Reuse */) {\n        let node = reused[id];\n        children.push(node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3 /* SpecialRecord.ContextChange */) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4 /* SpecialRecord.LookAhead */) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(`Unrecognized record size: ${size}`);\n      }\n    }\n    let type = types[id],\n      node,\n      buffer;\n    let startPos = start - parentStart;\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size,\n        index = data.length;\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);\n      node = new TreeBuffer(data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [],\n        localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n      let lastGroup = 0,\n        lastEnd = end;\n      while (cursor.pos > endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n          cursor.next();\n        } else if (depth > 2500 /* CutOff.Depth */) {\n          takeFlatNode(start, endPos, localChildren, localPositions);\n        } else {\n          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n        }\n      }\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && lastGroup > 0) {\n        let make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n    children.push(node);\n    positions.push(startPos);\n  }\n  function takeFlatNode(parentStart, minPos, children, positions) {\n    let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n    let nodeCount = 0,\n      stopAt = -1;\n    while (cursor.pos > minPos) {\n      let {\n        id,\n        start,\n        end,\n        size\n      } = cursor;\n      if (size > 4) {\n        // Not a leaf\n        cursor.next();\n      } else if (stopAt > -1 && start < stopAt) {\n        break;\n      } else {\n        if (stopAt < 0) stopAt = end - maxBufferLength;\n        nodes.push(id, start, end);\n        nodeCount++;\n        cursor.next();\n      }\n    }\n    if (nodeCount) {\n      let buffer = new Uint16Array(nodeCount * 4);\n      let start = nodes[nodes.length - 2];\n      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {\n        buffer[j++] = nodes[i];\n        buffer[j++] = nodes[i + 1] - start;\n        buffer[j++] = nodes[i + 2] - start;\n        buffer[j++] = j;\n      }\n      children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n      positions.push(start - parentStart);\n    }\n  }\n  function makeBalanced(type) {\n    return (children, positions, length) => {\n      let lookAhead = 0,\n        lastI = children.length - 1,\n        last,\n        lookAheadProp;\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    let localChildren = [],\n      localPositions = [];\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n  function makeTree(type, children, positions, length, lookAhead = 0, props) {\n    if (contextHash) {\n      let pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    if (lookAhead > 25) {\n      let pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    return new Tree(type, children, positions, length, props);\n  }\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork();\n    let size = 0,\n      start = 0,\n      skip = 0,\n      minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size;\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat && nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n      let startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3 /* SpecialRecord.ContextChange */) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n        fork.next();\n      }\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n    return result.size > 4 ? result : undefined;\n  }\n  function copyToBuffer(bufferStart, buffer, index) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    cursor.next();\n    if (size >= 0 && id < minRepeatType) {\n      let startIndex = index;\n      if (size > 4) {\n        let endPos = cursor.pos - (size - 4);\n        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);\n      }\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3 /* SpecialRecord.ContextChange */) {\n      contextHash = id;\n    } else if (size == -4 /* SpecialRecord.LookAhead */) {\n      lookAhead = id;\n    }\n    return index;\n  }\n  let children = [],\n    positions = [];\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap();\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  let size = nodeSizeCache.get(node);\n  if (size == null) {\n    size = 1;\n    for (let child of node.children) {\n      if (child.type != balanceType || !(child instanceof Tree)) {\n        size = 1;\n        break;\n      }\n      size += nodeSize(balanceType, child);\n    }\n    nodeSizeCache.set(node, size);\n  }\n  return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType,\n// The direct children and their positions\nchildren, positions,\n// The index range in children/positions to use\nfrom, to,\n// The start position of the nodes, relative to their parent.\nstart,\n// Length of the outer node\nlength,\n// Function to build the top node of the balanced tree\nmkTop,\n// Function to build internal nodes for the balanced tree\nmkTree) {\n  let total = 0;\n  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);\n  let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */);\n  let localChildren = [],\n    localPositions = [];\n  function divide(children, positions, from, to, offset) {\n    for (let i = from; i < to;) {\n      let groupFrom = i,\n        groupStart = positions[i],\n        groupSize = nodeSize(balanceType, children[i]);\n      i++;\n      for (; i < to; i++) {\n        let nextSize = nodeSize(balanceType, children[i]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n      if (i == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          let only = children[groupFrom]; // Only trees can have a size > 1\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n        localChildren.push(children[groupFrom]);\n      } else {\n        let length = positions[i - 1] + children[i - 1].length - groupStart;\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n      }\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n  constructor() {\n    this.map = new WeakMap();\n  }\n  setBuffer(buffer, index, value) {\n    let inner = this.map.get(buffer);\n    if (!inner) this.map.set(buffer, inner = new Map());\n    inner.set(index, value);\n  }\n  getBuffer(buffer, index) {\n    let inner = this.map.get(buffer);\n    return inner && inner.get(index);\n  }\n  /**\n  Set the value for this syntax node.\n  */\n  set(node, value) {\n    if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);else if (node instanceof TreeNode) this.map.set(node.tree, value);\n  }\n  /**\n  Retrieve value for this syntax node, if it exists in the map.\n  */\n  get(node) {\n    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n  }\n  /**\n  Set the value for the node that a cursor currently points to.\n  */\n  cursorSet(cursor, value) {\n    if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);else this.map.set(cursor.tree, value);\n  }\n  /**\n  Retrieve the value for the node that a cursor currently points\n  to.\n  */\n  cursorGet(cursor) {\n    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n  }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n  /**\n  Construct a tree fragment. You'll usually want to use\n  [`addTree`](#common.TreeFragment^addTree) and\n  [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n  calling this directly.\n  */\n  constructor(\n  /**\n  The start of the unchanged range pointed to by this fragment.\n  This refers to an offset in the _updated_ document (as opposed\n  to the original tree).\n  */\n  from,\n  /**\n  The end of the unchanged range.\n  */\n  to,\n  /**\n  The tree that this fragment is based on.\n  */\n  tree,\n  /**\n  The offset between the fragment's tree and the document that\n  this fragment can be used against. Add this when going from\n  document to tree positions, subtract it to go from tree to\n  document positions.\n  */\n  offset, openStart = false, openEnd = false) {\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n  }\n  /**\n  Whether the start of the fragment represents the start of a\n  parse, or the end of a change. (In the second case, it may not\n  be safe to reuse some nodes at the start, depending on the\n  parsing algorithm.)\n  */\n  get openStart() {\n    return (this.open & 1 /* Open.Start */) > 0;\n  }\n  /**\n  Whether the end of the fragment represents the end of a\n  full-document parse, or the start of a change.\n  */\n  get openEnd() {\n    return (this.open & 2 /* Open.End */) > 0;\n  }\n  /**\n  Create a set of fragments from a freshly parsed tree, or update\n  an existing set of fragments by replacing the ones that overlap\n  with a tree with content from the new tree. When `partial` is\n  true, the parse is treated as incomplete, and the resulting\n  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n  true.\n  */\n  static addTree(tree, fragments = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n    return result;\n  }\n  /**\n  Apply a set of edits to an array of fragments, removing or\n  splitting fragments as necessary to remove edited ranges, and\n  adjusting offsets for fragments that moved.\n  */\n  static applyChanges(fragments, changes, minGap = 128) {\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1,\n      nextF = fragments.length ? fragments[0] : null;\n    for (let cI = 0, pos = 0, off = 0;; cI++) {\n      let nextC = cI < changes.length ? changes[cI] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off,\n            fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n        }\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n    return result;\n  }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n  /**\n  Start a parse, returning a [partial parse](#common.PartialParse)\n  object. [`fragments`](#common.TreeFragment) can be passed in to\n  make the parse incremental.\n  \n  By default, the entire input is parsed. You can pass `ranges`,\n  which should be a sorted array of non-empty, non-overlapping\n  ranges, to parse only those ranges. The tree returned in that\n  case will start at `ranges[0].from`.\n  */\n  startParse(input, fragments, ranges) {\n    if (typeof input == \"string\") input = new StringInput(input);\n    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n    return this.createParse(input, fragments || [], ranges);\n  }\n  /**\n  Run a full parse, returning the resulting tree.\n  */\n  parse(input, fragments, ranges) {\n    let parse = this.startParse(input, fragments, ranges);\n    for (;;) {\n      let done = parse.advance();\n      if (done) return done;\n    }\n  }\n}\nclass StringInput {\n  constructor(string) {\n    this.string = string;\n  }\n  get length() {\n    return this.string.length;\n  }\n  chunk(from) {\n    return this.string.slice(from);\n  }\n  get lineChunks() {\n    return false;\n  }\n  read(from, to) {\n    return this.string.slice(from, to);\n  }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n  constructor(parser, parse, overlay, target, from) {\n    this.parser = parser;\n    this.parse = parse;\n    this.overlay = overlay;\n    this.target = target;\n    this.from = from;\n  }\n}\nfunction checkRanges(ranges) {\n  if (!ranges.length || ranges.some(r => r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n  constructor(parser, predicate, mounts, index, start, target, prev) {\n    this.parser = parser;\n    this.predicate = predicate;\n    this.mounts = mounts;\n    this.index = index;\n    this.start = start;\n    this.target = target;\n    this.prev = prev;\n    this.depth = 0;\n    this.ranges = [];\n  }\n}\nconst stoppedInner = new NodeProp({\n  perNode: true\n});\nclass MixedParse {\n  constructor(base, nest, input, fragments, ranges) {\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n  advance() {\n    if (this.baseParse) {\n      let done = this.baseParse.advance();\n      if (!done) return null;\n      this.baseParse = null;\n      this.baseTree = done;\n      this.startInner();\n      if (this.stoppedAt != null) for (let inner of this.inner) inner.parse.stopAt(this.stoppedAt);\n    }\n    if (this.innerDone == this.inner.length) {\n      let result = this.baseTree;\n      if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n      return result;\n    }\n    let inner = this.inner[this.innerDone],\n      done = inner.parse.advance();\n    if (done) {\n      this.innerDone++;\n      // This is a somewhat dodgy but super helpful hack where we\n      // patch up nodes created by the inner parse (and thus\n      // presumably not aliased anywhere else) to hold the information\n      // about the inner parse.\n      let props = Object.assign(Object.create(null), inner.target.props);\n      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n      inner.target.props = props;\n    }\n    return null;\n  }\n  get parsedPos() {\n    if (this.baseParse) return 0;\n    let pos = this.input.length;\n    for (let i = this.innerDone; i < this.inner.length; i++) {\n      if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n    }\n    return pos;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);\n  }\n  startInner() {\n    let fragmentCursor = new FragmentCursor(this.fragments);\n    let overlay = null;\n    let covered = null;\n    let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    scan: for (let nest, isCovered;;) {\n      let enter = true,\n        range;\n      if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n        enter = false;\n      } else if (fragmentCursor.hasNode(cursor)) {\n        if (overlay) {\n          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n          if (match) for (let r of match.mount.overlay) {\n            let from = r.from + match.pos,\n              to = r.to + match.pos;\n            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from)) overlay.ranges.push({\n              from,\n              to\n            });\n          }\n        }\n        enter = false;\n      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n        enter = isCovered != 2 /* Cover.Full */;\n      } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n        if (!cursor.tree) materialize(cursor);\n        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n        if (typeof nest.overlay == \"function\") {\n          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n        } else {\n          let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));\n          if (ranges.length) checkRanges(ranges);\n          if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n          if (!nest.overlay) enter = false;else if (ranges.length) covered = {\n            ranges,\n            depth: 0,\n            prev: covered\n          };\n        }\n      } else if (overlay && (range = overlay.predicate(cursor))) {\n        if (range === true) range = new Range(cursor.from, cursor.to);\n        if (range.from < range.to) overlay.ranges.push(range);\n      }\n      if (enter && cursor.firstChild()) {\n        if (overlay) overlay.depth++;\n        if (covered) covered.depth++;\n      } else {\n        for (;;) {\n          if (cursor.nextSibling()) break;\n          if (!cursor.parent()) break scan;\n          if (overlay && ! --overlay.depth) {\n            let ranges = punchRanges(this.ranges, overlay.ranges);\n            if (ranges.length) {\n              checkRanges(ranges);\n              this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n            }\n            overlay = overlay.prev;\n          }\n          if (covered && ! --covered.depth) covered = covered.prev;\n        }\n      }\n    }\n  }\n}\nfunction checkCover(covered, from, to) {\n  for (let range of covered) {\n    if (range.from >= to) break;\n    if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n  }\n  return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    let from = buf.buffer[startI + 1];\n    nodes.push(buf.slice(startI, endI, from));\n    positions.push(from - off);\n  }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n  let {\n      node\n    } = cursor,\n    stack = [];\n  let buffer = node.context.buffer;\n  // Scan up to the nearest tree\n  do {\n    stack.push(cursor.index);\n    cursor.parent();\n  } while (!cursor.tree);\n  // Find the index of the buffer in that tree\n  let base = cursor.tree,\n    i = base.children.indexOf(buffer);\n  let buf = base.children[i],\n    b = buf.buffer,\n    newStack = [i];\n  // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n  function split(startI, endI, type, innerOffset, length, stackPos) {\n    let targetI = stack[stackPos];\n    let children = [],\n      positions = [];\n    sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n    let from = b[targetI + 1],\n      to = b[targetI + 2];\n    newStack.push(children.length);\n    let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n    children.push(child);\n    positions.push(from - innerOffset);\n    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n    return new Tree(type, children, positions, length);\n  }\n  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n  // Move the cursor back to the target node\n  for (let index of newStack) {\n    let tree = cursor.tree.children[index],\n      pos = cursor.tree.positions[index];\n    cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n  }\n}\nclass StructureCursor {\n  constructor(root, offset) {\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n  }\n  // Move to the first node (in pre-order) that starts at or after `pos`.\n  moveTo(pos) {\n    let {\n        cursor\n      } = this,\n      p = pos - this.offset;\n    while (!this.done && cursor.from < p) {\n      if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;else if (!cursor.next(false)) this.done = true;\n    }\n  }\n  hasNode(cursor) {\n    this.moveTo(cursor.from);\n    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n      for (let tree = this.cursor.tree;;) {\n        if (tree == cursor.tree) return true;\n        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n      }\n    }\n    return false;\n  }\n}\nclass FragmentCursor {\n  constructor(fragments) {\n    var _a;\n    this.fragments = fragments;\n    this.curTo = 0;\n    this.fragI = 0;\n    if (fragments.length) {\n      let first = this.curFrag = fragments[0];\n      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n  hasNode(node) {\n    while (this.curFrag && node.from >= this.curTo) this.nextFrag();\n    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n  }\n  nextFrag() {\n    var _a;\n    this.fragI++;\n    if (this.fragI == this.fragments.length) {\n      this.curFrag = this.inner = null;\n    } else {\n      let frag = this.curFrag = this.fragments[this.fragI];\n      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n      this.inner = new StructureCursor(frag.tree, -frag.offset);\n    }\n  }\n  findMounts(pos, parser) {\n    var _a;\n    let result = [];\n    if (this.inner) {\n      this.inner.cursor.moveTo(pos, 1);\n      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n        if (mount && mount.parser == parser) {\n          for (let i = this.fragI; i < this.fragments.length; i++) {\n            let frag = this.fragments[i];\n            if (frag.from >= pos.to) break;\n            if (frag.tree == this.curFrag.tree) result.push({\n              frag,\n              pos: pos.from - frag.offset,\n              mount\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\nfunction punchRanges(outer, ranges) {\n  let copy = null,\n    current = ranges;\n  for (let i = 1, j = 0; i < outer.length; i++) {\n    let gapFrom = outer[i - 1].to,\n      gapTo = outer[i].from;\n    for (; j < current.length; j++) {\n      let r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n  return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n  let iA = 0,\n    iB = 0,\n    inA = false,\n    inB = false,\n    pos = -1e9;\n  let result = [];\n  for (;;) {\n    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n    if (inA != inB) {\n      let start = Math.max(pos, from),\n        end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n  return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n  let result = [];\n  for (let {\n    pos,\n    mount,\n    frag\n  } of mounts) {\n    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n      endPos = startPos + mount.tree.length;\n    let from = Math.max(frag.from, startPos),\n      to = Math.min(frag.to, endPos);\n    if (mount.overlay) {\n      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n      let changes = findCoverChanges(ranges, overlay, from, to);\n      for (let i = 0, pos = from;; i++) {\n        let last = i == changes.length,\n          end = last ? to : changes[i].from;\n        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n        if (last) break;\n        pos = changes[i].to;\n      }\n    } else {\n      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n    }\n  }\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFHQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzP2MxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlLlxuKi9cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vKipcbkVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG4qL1xuY2xhc3MgTm9kZVByb3Age1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIGl0IGRvZXMuXG4gICAgKi9cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbmRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG5zcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG5mb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG4qL1xuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcblRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbm9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbiovXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxudHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG4qL1xuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcbkF0dGFjaGVkIHRvIG5vZGVzIHRvIGluZGljYXRlIHRoZXNlIHNob3VsZCBiZVxuW2Rpc3BsYXllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSlcbmluIGEgYmlkaXJlY3Rpb25hbCB0ZXh0IGlzb2xhdGUsIHNvIHRoYXQgZGlyZWN0aW9uLW5ldXRyYWxcbmNoYXJhY3RlcnMgb24gdGhlaXIgc2lkZXMgZG9uJ3QgaW5jb3JyZWN0bHkgZ2V0IGFzc29jaWF0ZWQgd2l0aFxuc3Vycm91bmRpbmcgdGV4dC4gWW91J2xsIGdlbmVyYWxseSB3YW50IHRvIHNldCB0aGlzIGZvciBub2Rlc1xudGhhdCBjb250YWluIGFyYml0cmFyeSB0ZXh0LCBsaWtlIHN0cmluZ3MgYW5kIGNvbW1lbnRzLCBhbmQgZm9yXG5ub2RlcyB0aGF0IGFwcGVhciBfaW5zaWRlXyBhcmJpdHJhcnkgdGV4dCwgbGlrZSBIVE1MIHRhZ3MuIFdoZW5cbm5vdCBnaXZlbiBhIHZhbHVlLCBpbiBhIGdyYW1tYXIgZGVjbGFyYXRpb24sIGRlZmF1bHRzIHRvXG5gXCJhdXRvXCJgLlxuKi9cbk5vZGVQcm9wLmlzb2xhdGUgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT0gXCJydGxcIiAmJiB2YWx1ZSAhPSBcImx0clwiICYmIHZhbHVlICE9IFwiYXV0b1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBpc29sYXRlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFwiYXV0b1wiO1xuICAgIH0gfSk7XG4vKipcblRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxudGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2ZcbmNvbnRleHR1YWwgbm9kZXMuXG4qL1xuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5UaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG5sb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxucGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG5lZmZpY2llbmN5IHJlYXNvbnMuKVxuKi9cbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbm5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbmRpZmZlcmVudCBsYW5ndWFnZXMgaW4gbWl4ZWQtbGFuZ3VhZ2UgcGFyc2Vycy5cbiovXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuQSBtb3VudGVkIHRyZWUsIHdoaWNoIGNhbiBiZSBbc3RvcmVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG9uXG5hIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxucmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuKi9cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgaW5uZXIgdHJlZS5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgbm9kZSkuIElmIG5vdCwgb25seSB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIG9ubHkgZW50ZXJlZCBieSBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpXG4gICAgYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgICovXG4gICAgb3ZlcmxheSwgXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlciB1c2VkIHRvIGNyZWF0ZSB0aGlzIHN1YnRyZWUuXG4gICAgKi9cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGdldCh0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlICYmIHRyZWUucHJvcHMgJiYgdHJlZS5wcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXTtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICByb2xlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwcm9wcywgXG4gICAgLyoqXG4gICAgVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbm9kZSB0eXBlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICAqL1xuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBOb2RlRmxhZy5Ub3AgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgKi9cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICAqL1xuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG4qL1xuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLyk7XG4vKipcbkEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbmNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbnR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuKi9cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgKi9cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICAgIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgICovXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbk9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxub3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG4qL1xudmFyIEl0ZXJNb2RlO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8qKlxuQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG50cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG5jb252ZW5pZW50IHdheS5cblxuU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG5vYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG5ub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuXG5Ib3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG5yZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG51c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3JcbltgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG5hIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xubW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgdGhlIGNoaWxkcmVuLlxuICAgICovXG4gICAgcG9zaXRpb25zLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgICovXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgKi9cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICB0cmVlLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICBmcm9tIGJvdGggc2lkZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcikgaW5zdGVhZC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICB0aGUgaG9zdCB0cmVlcykuXG4gICAgKi9cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW4gc29tZSBzaXR1YXRpb25zLCBpdCBjYW4gYmUgdXNlZnVsIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGxcbiAgICBub2RlcyBhcm91bmQgYSBwb3NpdGlvbiwgaW5jbHVkaW5nIHRob3NlIGluIG92ZXJsYXlzIHRoYXQgZG9uJ3RcbiAgICBkaXJlY3RseSBjb3ZlciB0aGUgcG9zaXRpb24uIFRoaXMgbWV0aG9kIGdpdmVzIHlvdSBhbiBpdGVyYXRvclxuICAgIHRoYXQgd2lsbCBwcm9kdWNlIGFsbCBub2RlcywgZnJvbSBzbWFsbCB0byBiaWcsIGFyb3VuZCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHJlc29sdmVTdGFjayhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFja0l0ZXJhdG9yKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gICAgbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgICovXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGxldCBtb2RlID0gc3BlYy5tb2RlIHx8IDAsIGFub24gPSAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID4gMDtcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKG1vZGUgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKCFhbm9uICYmIGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAoYW5vbiB8fCAhYy50eXBlLmlzQW5vbnltb3VzKSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIGNvbnN0cnVjdG9yLlxuICAgICovXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICAqL1xuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICAqL1xuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHRyZWVcbiovXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vKipcblRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbm5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG5iZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuY2hpbGRyZW4gYmVsb25nIHRvIGl0KS5cbiovXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXQgdXNlZCBpbiB0aGlzIGJ1ZmZlci5cbiAgICAqL1xuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQmFzZU5vZGUge1xuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQuX3RyZWUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQobmV4dCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzLl90cmVlKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIGZvciAobGV0IGZvdW5kID0gZmFsc2U7ICFmb3VuZDspIHtcbiAgICAgICAgICAgIGZvdW5kID0gY3VyLnR5cGUuaXMoYmVmb3JlKTtcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZS5wYXJlbnQ7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIGxldCBidWZmZXIgPSBub2RlLmNvbnRleHQuYnVmZmVyO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBiYXNlID0gY3Vyc29yLnRyZWUsIGkgPSBiYXNlLmNoaWxkcmVuLmluZGV4T2YoYnVmZmVyKTtcbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXIsIG5ld1N0YWNrID0gW2ldO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCwgc3RhY2tQb3MpIHtcbiAgICAgICAgbGV0IHRhcmdldEkgPSBzdGFja1tzdGFja1Bvc107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIHRhcmdldEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW3RhcmdldEkgKyAxXSwgdG8gPSBiW3RhcmdldEkgKyAyXTtcbiAgICAgICAgbmV3U3RhY2sucHVzaChjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICBsZXQgY2hpbGQgPSBzdGFja1Bvc1xuICAgICAgICAgICAgPyBzcGxpdCh0YXJnZXRJICsgNCwgYlt0YXJnZXRJICsgM10sIGJ1Zi5zZXQudHlwZXNbYlt0YXJnZXRJXV0sIGZyb20sIHRvIC0gZnJvbSwgc3RhY2tQb3MgLSAxKVxuICAgICAgICAgICAgOiBub2RlLnRvVHJlZSgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW3RhcmdldEkgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpbmRleCBvZiBuZXdTdGFjaykge1xuICAgICAgICBsZXQgdHJlZSA9IGN1cnNvci50cmVlLmNoaWxkcmVuW2luZGV4XSwgcG9zID0gY3Vyc29yLnRyZWUucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgY3Vyc29yLnlpZWxkKG5ldyBUcmVlTm9kZSh0cmVlLCBwb3MgKyBjdXJzb3IuZnJvbSwgaW5kZXgsIGN1cnNvci5fdHJlZSkpO1xuICAgIH1cbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The set of this tag and all its parent tags, starting with\n  this one itself and sorted in order of decreasing specificity.\n  */\n  set,\n  /**\n  The base unmodified tag that this one is based on, if it's\n  modified @internal\n  */\n  base,\n  /**\n  The modifiers applied to this.base @internal\n  */\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /**\n    @internal\n    */\n    this.id = nextTagID++;\n  }\n  /**\n  Define a new tag. If `parent` is given, the tag is treated as a\n  sub-tag of that parent, and\n  [highlighters](#highlight.tagHighlighter) that don't mention\n  this tag will try to fall back to the parent tag (or grandparent\n  tag, etc).\n  */\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /**\n  Define a tag _modifier_, which is a function that, given a tag,\n  will return a tag that is a subtag of the original. Applying the\n  same modifier to a twice tag will return the same value (`m1(t1)\n  == m1(t1)`) and applying multiple modifiers will, regardless or\n  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  \n  When multiple modifiers are applied to a given base tag, each\n  smaller set of modifiers is registered as a parent, so that for\n  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  `m1(m3(t1)`, and so on.\n  */\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n      tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = powerSet(mods);\n    for (let parent of base.set) if (!parent.modified.length) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n  let sets = [[]];\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0, e = sets.length; j < e; j++) {\n      sets.push(sets[j].concat(array[i]));\n    }\n  }\n  return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n        mode = 2 /* Mode.Normal */,\n        rest = part;\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1 /* Mode.Inherit */;\n          break;\n        }\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0 /* Mode.Opaque */;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1,\n        inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  get opaque() {\n    return this.mode == 0 /* Mode.Opaque */;\n  }\n  get inherit() {\n    return this.mode == 1 /* Mode.Inherit */;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n      return cls;\n    },\n    scope\n  };\n}\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n  return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/\nfunction highlightTree(tree, highlighter,\n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle,\n/**\nThe start of the range to highlight.\n*/\nfrom = 0,\n/**\nThe end of the range.\n*/\nto = tree.length) {\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/\nfunction highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n  let pos = from;\n  function writeTo(p, classes) {\n    if (p <= pos) return;\n    for (let text = code.slice(pos, p), i = 0;;) {\n      let nextBreak = text.indexOf(\"\\n\", i);\n      let upto = nextBreak < 0 ? text.length : nextBreak;\n      if (upto > i) putText(text.slice(i, upto), classes);\n      if (nextBreak < 0) break;\n      putBreak();\n      i = nextBreak + 1;\n    }\n    pos = p;\n  }\n  highlightTree(tree, highlighter, (from, to, classes) => {\n    writeTo(from, \"\");\n    writeTo(to, classes);\n  }, from, to);\n  writeTo(to, \"\");\n}\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = getStyleTags(cursor) || Rule.empty;\n    let tagCls = highlightTags(highlighters, rule.tags);\n    if (tagCls) {\n      if (cls) cls += \" \";\n      cls += tagCls;\n      if (rule.mode == 1 /* Mode.Inherit */) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n    }\n    this.startSpan(Math.max(from, start), cls);\n    if (rule.opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n          rangeTo = Math.min(to, nextPos);\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(rangeTo, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n          this.startSpan(Math.min(to, pos), cls);\n        }\n      }\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      if (mounted) inheritedClass = \"\";\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n  let rule = node.type.prop(ruleNodeProp);\n  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;\n  return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(),\n  name = t(),\n  typeName = t(name),\n  propertyName = t(name),\n  literal = t(),\n  string = t(literal),\n  number = t(literal),\n  content = t(),\n  heading = t(content),\n  keyword = t(),\n  operator = t(),\n  punctuation = t(),\n  bracket = t(punctuation),\n  meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n  /**\n  A comment.\n  */\n  comment,\n  /**\n  A line [comment](#highlight.tags.comment).\n  */\n  lineComment: t(comment),\n  /**\n  A block [comment](#highlight.tags.comment).\n  */\n  blockComment: t(comment),\n  /**\n  A documentation [comment](#highlight.tags.comment).\n  */\n  docComment: t(comment),\n  /**\n  Any kind of identifier.\n  */\n  name,\n  /**\n  The [name](#highlight.tags.name) of a variable.\n  */\n  variableName: t(name),\n  /**\n  A type [name](#highlight.tags.name).\n  */\n  typeName: typeName,\n  /**\n  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  */\n  tagName: t(typeName),\n  /**\n  A property or field [name](#highlight.tags.name).\n  */\n  propertyName: propertyName,\n  /**\n  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  */\n  attributeName: t(propertyName),\n  /**\n  The [name](#highlight.tags.name) of a class.\n  */\n  className: t(name),\n  /**\n  A label [name](#highlight.tags.name).\n  */\n  labelName: t(name),\n  /**\n  A namespace [name](#highlight.tags.name).\n  */\n  namespace: t(name),\n  /**\n  The [name](#highlight.tags.name) of a macro.\n  */\n  macroName: t(name),\n  /**\n  A literal value.\n  */\n  literal,\n  /**\n  A string [literal](#highlight.tags.literal).\n  */\n  string,\n  /**\n  A documentation [string](#highlight.tags.string).\n  */\n  docString: t(string),\n  /**\n  A character literal (subtag of [string](#highlight.tags.string)).\n  */\n  character: t(string),\n  /**\n  An attribute value (subtag of [string](#highlight.tags.string)).\n  */\n  attributeValue: t(string),\n  /**\n  A number [literal](#highlight.tags.literal).\n  */\n  number,\n  /**\n  An integer [number](#highlight.tags.number) literal.\n  */\n  integer: t(number),\n  /**\n  A floating-point [number](#highlight.tags.number) literal.\n  */\n  float: t(number),\n  /**\n  A boolean [literal](#highlight.tags.literal).\n  */\n  bool: t(literal),\n  /**\n  Regular expression [literal](#highlight.tags.literal).\n  */\n  regexp: t(literal),\n  /**\n  An escape [literal](#highlight.tags.literal), for example a\n  backslash escape in a string.\n  */\n  escape: t(literal),\n  /**\n  A color [literal](#highlight.tags.literal).\n  */\n  color: t(literal),\n  /**\n  A URL [literal](#highlight.tags.literal).\n  */\n  url: t(literal),\n  /**\n  A language keyword.\n  */\n  keyword,\n  /**\n  The [keyword](#highlight.tags.keyword) for the self or this\n  object.\n  */\n  self: t(keyword),\n  /**\n  The [keyword](#highlight.tags.keyword) for null.\n  */\n  null: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  */\n  atom: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that represents a unit.\n  */\n  unit: t(keyword),\n  /**\n  A modifier [keyword](#highlight.tags.keyword).\n  */\n  modifier: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that acts as an operator.\n  */\n  operatorKeyword: t(keyword),\n  /**\n  A control-flow related [keyword](#highlight.tags.keyword).\n  */\n  controlKeyword: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that defines something.\n  */\n  definitionKeyword: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) related to defining or\n  interfacing with modules.\n  */\n  moduleKeyword: t(keyword),\n  /**\n  An operator.\n  */\n  operator,\n  /**\n  An [operator](#highlight.tags.operator) that dereferences something.\n  */\n  derefOperator: t(operator),\n  /**\n  Arithmetic-related [operator](#highlight.tags.operator).\n  */\n  arithmeticOperator: t(operator),\n  /**\n  Logical [operator](#highlight.tags.operator).\n  */\n  logicOperator: t(operator),\n  /**\n  Bit [operator](#highlight.tags.operator).\n  */\n  bitwiseOperator: t(operator),\n  /**\n  Comparison [operator](#highlight.tags.operator).\n  */\n  compareOperator: t(operator),\n  /**\n  [Operator](#highlight.tags.operator) that updates its operand.\n  */\n  updateOperator: t(operator),\n  /**\n  [Operator](#highlight.tags.operator) that defines something.\n  */\n  definitionOperator: t(operator),\n  /**\n  Type-related [operator](#highlight.tags.operator).\n  */\n  typeOperator: t(operator),\n  /**\n  Control-flow [operator](#highlight.tags.operator).\n  */\n  controlOperator: t(operator),\n  /**\n  Program or markup punctuation.\n  */\n  punctuation,\n  /**\n  [Punctuation](#highlight.tags.punctuation) that separates\n  things.\n  */\n  separator: t(punctuation),\n  /**\n  Bracket-style [punctuation](#highlight.tags.punctuation).\n  */\n  bracket,\n  /**\n  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  tokens).\n  */\n  angleBracket: t(bracket),\n  /**\n  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  tokens).\n  */\n  squareBracket: t(bracket),\n  /**\n  Parentheses (usually `(` and `)` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  paren: t(bracket),\n  /**\n  Braces (usually `{` and `}` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  brace: t(bracket),\n  /**\n  Content, for example plain text in XML or markup documents.\n  */\n  content,\n  /**\n  [Content](#highlight.tags.content) that represents a heading.\n  */\n  heading,\n  /**\n  A level 1 [heading](#highlight.tags.heading).\n  */\n  heading1: t(heading),\n  /**\n  A level 2 [heading](#highlight.tags.heading).\n  */\n  heading2: t(heading),\n  /**\n  A level 3 [heading](#highlight.tags.heading).\n  */\n  heading3: t(heading),\n  /**\n  A level 4 [heading](#highlight.tags.heading).\n  */\n  heading4: t(heading),\n  /**\n  A level 5 [heading](#highlight.tags.heading).\n  */\n  heading5: t(heading),\n  /**\n  A level 6 [heading](#highlight.tags.heading).\n  */\n  heading6: t(heading),\n  /**\n  A prose separator (such as a horizontal rule).\n  */\n  contentSeparator: t(content),\n  /**\n  [Content](#highlight.tags.content) that represents a list.\n  */\n  list: t(content),\n  /**\n  [Content](#highlight.tags.content) that represents a quote.\n  */\n  quote: t(content),\n  /**\n  [Content](#highlight.tags.content) that is emphasized.\n  */\n  emphasis: t(content),\n  /**\n  [Content](#highlight.tags.content) that is styled strong.\n  */\n  strong: t(content),\n  /**\n  [Content](#highlight.tags.content) that is part of a link.\n  */\n  link: t(content),\n  /**\n  [Content](#highlight.tags.content) that is styled as code or\n  monospace.\n  */\n  monospace: t(content),\n  /**\n  [Content](#highlight.tags.content) that has a strike-through\n  style.\n  */\n  strikethrough: t(content),\n  /**\n  Inserted text in a change-tracking format.\n  */\n  inserted: t(),\n  /**\n  Deleted text.\n  */\n  deleted: t(),\n  /**\n  Changed text.\n  */\n  changed: t(),\n  /**\n  An invalid or unsyntactic element.\n  */\n  invalid: t(),\n  /**\n  Metadata or meta-instruction.\n  */\n  meta,\n  /**\n  [Metadata](#highlight.tags.meta) that applies to the entire\n  document.\n  */\n  documentMeta: t(meta),\n  /**\n  [Metadata](#highlight.tags.meta) that annotates or adds\n  attributes to a given syntactic element.\n  */\n  annotation: t(meta),\n  /**\n  Processing instruction or preprocessor directive. Subtag of\n  [meta](#highlight.tags.meta).\n  */\n  processingInstruction: t(meta),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  given element is being defined. Expected to be used with the\n  various [name](#highlight.tags.name) tags.\n  */\n  definition: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that\n  something is constant. Mostly expected to be used with\n  [variable names](#highlight.tags.variableName).\n  */\n  constant: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  a [variable](#highlight.tags.variableName) or [property\n  name](#highlight.tags.propertyName) is being called or defined\n  as a function.\n  */\n  function: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  [names](#highlight.tags.name) to indicate that they belong to\n  the language's standard environment.\n  */\n  standard: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  [names](#highlight.tags.name) is local to some scope.\n  */\n  local: Tag.defineModifier(),\n  /**\n  A generic variant [modifier](#highlight.Tag^defineModifier) that\n  can be used to tag language-specific alternative variants of\n  some common tag. It is recommended for themes to define special\n  forms of at least the [string](#highlight.tags.string) and\n  [variable name](#highlight.tags.variableName) tags, since those\n  come up a lot.\n  */\n  special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguanM/ZjI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5sZXQgbmV4dFRhZ0lEID0gMDtcbi8qKlxuSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG5UaGV5IGFyZSBbYXNzb2NpYXRlZF0oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcbnRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuXG5CZWNhdXNlIHN5bnRheCB0cmVlIG5vZGUgdHlwZXMgYW5kIGhpZ2hsaWdodCBzdHlsZXMgaGF2ZSB0byBiZVxuYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cblt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG50cmFkaXRpb25hbCBvcGVuIHN0cmluZy1iYXNlZCBzeXN0ZW1zLCB3aGljaCBtYWtlIGl0IGhhcmQgZm9yXG5oaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxudmFyaW91cyBsYW5ndWFnZXMpLlxuXG5JdCBfaXNfIHBvc3NpYmxlIHRvIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgeW91ciBvd25cbmhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG50aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuYmUgcGlja2VkIHVwIGJ5IHJlZ3VsYXIgaGlnaGxpZ2h0ZXJzICh0aG91Z2ggeW91IGNhbiBkZXJpdmUgdGhlbVxuZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuKi9cbmNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIHRoaXMgdGFnIGFuZCBhbGwgaXRzIHBhcmVudCB0YWdzLCBzdGFydGluZyB3aXRoXG4gICAgdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICAqL1xuICAgIHNldCwgXG4gICAgLyoqXG4gICAgVGhlIGJhc2UgdW5tb2RpZmllZCB0YWcgdGhhdCB0aGlzIG9uZSBpcyBiYXNlZCBvbiwgaWYgaXQnc1xuICAgIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgICovXG4gICAgYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIG1vZGlmaWVycyBhcHBsaWVkIHRvIHRoaXMuYmFzZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgICBzdWItdGFnIG9mIHRoYXQgcGFyZW50LCBhbmRcbiAgICBbaGlnaGxpZ2h0ZXJzXSgjaGlnaGxpZ2h0LnRhZ0hpZ2hsaWdodGVyKSB0aGF0IGRvbid0IG1lbnRpb25cbiAgICB0aGlzIHRhZyB3aWxsIHRyeSB0byBmYWxsIGJhY2sgdG8gdGhlIHBhcmVudCB0YWcgKG9yIGdyYW5kcGFyZW50XG4gICAgdGFnLCBldGMpLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5iYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXJpdmUgZnJvbSBhIG1vZGlmaWVkIHRhZ1wiKTtcbiAgICAgICAgbGV0IHRhZyA9IG5ldyBUYWcoW10sIG51bGwsIFtdKTtcbiAgICAgICAgdGFnLnNldC5wdXNoKHRhZyk7XG4gICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHBhcmVudC5zZXQpXG4gICAgICAgICAgICAgICAgdGFnLnNldC5wdXNoKHQpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgICB3aWxsIHJldHVybiBhIHRhZyB0aGF0IGlzIGEgc3VidGFnIG9mIHRoZSBvcmlnaW5hbC4gQXBwbHlpbmcgdGhlXG4gICAgc2FtZSBtb2RpZmllciB0byBhIHR3aWNlIHRhZyB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZSAoYG0xKHQxKVxuICAgID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICAgIG9yZGVyLCBwcm9kdWNlIHRoZSBzYW1lIHRhZyAoYG0xKG0yKHQxKSkgPT0gbTIobTEodDEpKWApLlxuICAgIFxuICAgIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgICBzbWFsbGVyIHNldCBvZiBtb2RpZmllcnMgaXMgcmVnaXN0ZXJlZCBhcyBhIHBhcmVudCwgc28gdGhhdCBmb3JcbiAgICBleGFtcGxlIGBtMShtMihtMyh0MSkpKWAgaXMgYSBzdWJ0eXBlIG9mIGBtMShtMih0MSkpYCxcbiAgICBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZU1vZGlmaWVyKCkge1xuICAgICAgICBsZXQgbW9kID0gbmV3IE1vZGlmaWVyO1xuICAgICAgICByZXR1cm4gKHRhZykgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZy5tb2RpZmllZC5pbmRleE9mKG1vZCkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICAgICAgcmV0dXJuIE1vZGlmaWVyLmdldCh0YWcuYmFzZSB8fCB0YWcsIHRhZy5tb2RpZmllZC5jb25jYXQobW9kKS5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCkpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmxldCBuZXh0TW9kaWZpZXJJRCA9IDA7XG5jbGFzcyBNb2RpZmllciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoc2V0LCBiYXNlLCBtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBtb2RzKVxuICAgICAgICAgICAgbS5pbnN0YW5jZXMucHVzaCh0YWcpO1xuICAgICAgICBsZXQgY29uZmlncyA9IHBvd2VyU2V0KG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgb2YgYmFzZS5zZXQpXG4gICAgICAgICAgICBpZiAoIXBhcmVudC5tb2RpZmllZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKE1vZGlmaWVyLmdldChwYXJlbnQsIGNvbmZpZykpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKHgsIGkpID0+IHggPT0gYltpXSk7XG59XG5mdW5jdGlvbiBwb3dlclNldChhcnJheSkge1xuICAgIGxldCBzZXRzID0gW1tdXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBlID0gc2V0cy5sZW5ndGg7IGogPCBlOyBqKyspIHtcbiAgICAgICAgICAgIHNldHMucHVzaChzZXRzW2pdLmNvbmNhdChhcnJheVtpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuLyoqXG5UaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYWRkIGEgc2V0IG9mIHRhZ3MgdG8gYSBsYW5ndWFnZSBzeW50YXhcbnZpYSBbYE5vZGVTZXQuZXh0ZW5kYF0oI2NvbW1vbi5Ob2RlU2V0LmV4dGVuZCkgb3JcbltgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLkxSUGFyc2VyLmNvbmZpZ3VyZSkuXG5cblRoZSBhcmd1bWVudCBvYmplY3QgbWFwcyBub2RlIHNlbGVjdG9ycyB0byBbaGlnaGxpZ2h0aW5nXG50YWdzXSgjaGlnaGxpZ2h0LlRhZykgb3IgYXJyYXlzIG9mIHRhZ3MuXG5cbk5vZGUgc2VsZWN0b3JzIG1heSBob2xkIG9uZSBvciBtb3JlIChzcGFjZS1zZXBhcmF0ZWQpIG5vZGUgcGF0aHMuXG5TdWNoIGEgcGF0aCBjYW4gYmUgYSBbbm9kZSBuYW1lXSgjY29tbW9uLk5vZGVUeXBlLm5hbWUpLCBvclxubXVsdGlwbGUgbm9kZSBuYW1lcyAob3IgYCpgIHdpbGRjYXJkcykgc2VwYXJhdGVkIGJ5IHNsYXNoXG5jaGFyYWN0ZXJzLCBhcyBpbiBgXCJCbG9jay9EZWNsYXJhdGlvbi9WYXJpYWJsZU5hbWVcImAuIFN1Y2ggYSBwYXRoXG5tYXRjaGVzIHRoZSBmaW5hbCBub2RlIGJ1dCBvbmx5IGlmIGl0cyBkaXJlY3QgcGFyZW50IG5vZGVzIGFyZSB0aGVcbm90aGVyIG5vZGVzIG1lbnRpb25lZC4gQSBgKmAgaW4gc3VjaCBhIHBhdGggbWF0Y2hlcyBhbnkgcGFyZW50LFxuYnV0IG9ubHkgYSBzaW5nbGUgbGV2ZWzigJR3aWxkY2FyZHMgdGhhdCBtYXRjaCBtdWx0aXBsZSBwYXJlbnRzXG5hcmVuJ3Qgc3VwcG9ydGVkLCBib3RoIGZvciBlZmZpY2llbmN5IHJlYXNvbnMgYW5kIGJlY2F1c2UgTGV6ZXJcbnRyZWVzIG1ha2UgaXQgcmF0aGVyIGhhcmQgdG8gcmVhc29uIGFib3V0IHdoYXQgdGhleSB3b3VsZCBtYXRjaC4pXG5cbkEgcGF0aCBjYW4gYmUgZW5kZWQgd2l0aCBgLy4uLmAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGFnIGFzc2lnbmVkXG50byB0aGUgbm9kZSBzaG91bGQgYWxzbyBhcHBseSB0byBhbGwgY2hpbGQgbm9kZXMsIGV2ZW4gaWYgdGhleVxubWF0Y2ggdGhlaXIgb3duIHN0eWxlIChieSBkZWZhdWx0LCBvbmx5IHRoZSBpbm5lcm1vc3Qgc3R5bGUgaXNcbnVzZWQpLlxuXG5XaGVuIGEgcGF0aCBlbmRzIGluIGAhYCwgYXMgaW4gYEF0dHJpYnV0ZSFgLCBubyBmdXJ0aGVyIG1hdGNoaW5nXG5oYXBwZW5zIGZvciB0aGUgbm9kZSdzIGNoaWxkIG5vZGVzLCBhbmQgdGhlIGVudGlyZSBub2RlIGdldHMgdGhlXG5naXZlbiBzdHlsZS5cblxuSW4gdGhpcyBub3RhdGlvbiwgbm9kZSBuYW1lcyB0aGF0IGNvbnRhaW4gYC9gLCBgIWAsIGAqYCwgb3IgYC4uLmBcbm11c3QgYmUgcXVvdGVkIGFzIEpTT04gc3RyaW5ncy5cblxuRm9yIGV4YW1wbGU6XG5cbmBgYGphdmFzY3JpcHRcbnBhcnNlci53aXRoUHJvcHMoXG4gIHN0eWxlVGFncyh7XG4gICAgLy8gU3R5bGUgTnVtYmVyIGFuZCBCaWdOdW1iZXIgbm9kZXNcbiAgICBcIk51bWJlciBCaWdOdW1iZXJcIjogdGFncy5udW1iZXIsXG4gICAgLy8gU3R5bGUgRXNjYXBlIG5vZGVzIHdob3NlIHBhcmVudCBpcyBTdHJpbmdcbiAgICBcIlN0cmluZy9Fc2NhcGVcIjogdGFncy5lc2NhcGUsXG4gICAgLy8gU3R5bGUgYW55dGhpbmcgaW5zaWRlIEF0dHJpYnV0ZXMgbm9kZXNcbiAgICBcIkF0dHJpYnV0ZXMhXCI6IHRhZ3MubWV0YSxcbiAgICAvLyBBZGQgYSBzdHlsZSB0byBhbGwgY29udGVudCBpbnNpZGUgSXRhbGljIG5vZGVzXG4gICAgXCJJdGFsaWMvLi4uXCI6IHRhZ3MuZW1waGFzaXMsXG4gICAgLy8gU3R5bGUgSW52YWxpZFN0cmluZyBub2RlcyBhcyBib3RoIGBzdHJpbmdgIGFuZCBgaW52YWxpZGBcbiAgICBcIkludmFsaWRTdHJpbmdcIjogW3RhZ3Muc3RyaW5nLCB0YWdzLmludmFsaWRdLFxuICAgIC8vIFN0eWxlIHRoZSBub2RlIG5hbWVkIFwiL1wiIGFzIHB1bmN0dWF0aW9uXG4gICAgJ1wiL1wiJzogdGFncy5wdW5jdHVhdGlvblxuICB9KVxuKVxuYGBgXG4qL1xuZnVuY3Rpb24gc3R5bGVUYWdzKHNwZWMpIHtcbiAgICBsZXQgYnlOYW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHRhZ3MgPSBzcGVjW3Byb3BdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpXG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2VzID0gW10sIG1vZGUgPSAyIC8qIE1vZGUuTm9ybWFsICovLCByZXN0ID0gcGFydDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3QgPT0gXCIuLi5cIiAmJiBwb3MgPiAwICYmIHBvcyArIDMgPT0gcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAxIC8qIE1vZGUuSW5oZXJpdCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gL15cIig/OlteXCJcXFxcXXxcXFxcLikqP1wifFteXFwvIV0rLy5leGVjKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcGllY2VzLnB1c2gobVswXSA9PSBcIipcIiA/IFwiXCIgOiBtWzBdWzBdID09ICdcIicgPyBKU09OLnBhcnNlKG1bMF0pIDogbVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRbcG9zKytdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoICYmIG5leHQgPT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPSAwIC8qIE1vZGUuT3BhcXVlICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gXCIvXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc2xpY2UocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBwaWVjZXMubGVuZ3RoIC0gMSwgaW5uZXIgPSBwaWVjZXNbbGFzdF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSBuZXcgUnVsZSh0YWdzLCBtb2RlLCBsYXN0ID4gMCA/IHBpZWNlcy5zbGljZSgwLCBsYXN0KSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGJ5TmFtZVtpbm5lcl0gPSBydWxlLnNvcnQoYnlOYW1lW2lubmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlTm9kZVByb3AuYWRkKGJ5TmFtZSk7XG59XG5jb25zdCBydWxlTm9kZVByb3AgPSBuZXcgTm9kZVByb3AoKTtcbmNsYXNzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MsIG1vZGUsIGNvbnRleHQsIG5leHQpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgICB9XG4gICAgZ2V0IG9wYXF1ZSgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAwIC8qIE1vZGUuT3BhcXVlICovOyB9XG4gICAgZ2V0IGluaGVyaXQoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi87IH1cbiAgICBzb3J0KG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIgfHwgb3RoZXIuZGVwdGggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBvdGhlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyLm5leHQgPSB0aGlzLnNvcnQob3RoZXIubmV4dCk7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7IH1cbn1cblJ1bGUuZW1wdHkgPSBuZXcgUnVsZShbXSwgMiAvKiBNb2RlLk5vcm1hbCAqLywgbnVsbCk7XG4vKipcbkRlZmluZSBhIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikgZnJvbSBhbiBhcnJheSBvZlxudGFnL2NsYXNzIHBhaXJzLiBDbGFzc2VzIGFzc29jaWF0ZWQgd2l0aCBtb3JlIHNwZWNpZmljIHRhZ3Mgd2lsbFxudGFrZSBwcmVjZWRlbmNlLlxuKi9cbmZ1bmN0aW9uIHRhZ0hpZ2hsaWdodGVyKHRhZ3MsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBzdHlsZSBvZiB0YWdzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS50YWcpKVxuICAgICAgICAgICAgbWFwW3N0eWxlLnRhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHN0eWxlLnRhZylcbiAgICAgICAgICAgICAgICBtYXBbdGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgIH1cbiAgICBsZXQgeyBzY29wZSwgYWxsID0gbnVsbCB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogKHRhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBhbGw7XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2YgdGFncykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiB0YWcuc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWdDbGFzcyA9IG1hcFtzdWIuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFnQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNscyA9IGNscyA/IGNscyArIFwiIFwiICsgdGFnQ2xhc3MgOiB0YWdDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfSxcbiAgICAgICAgc2NvcGVcbiAgICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHRhZ3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiBbdHJlZV0oI2NvbW1vbi5UcmVlKSB3aXRoIHRoZSBnaXZlblxuW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS4gT2Z0ZW4sIHRoZSBoaWdoZXItbGV2ZWxcbltgaGlnaGxpZ2h0Q29kZWBdKCNoaWdobGlnaHQuaGlnaGxpZ2h0Q29kZSkgZnVuY3Rpb24gaXMgZWFzaWVyIHRvXG51c2UuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgXG4vKipcbkFzc2lnbiBzdHlsaW5nIHRvIGEgcmVnaW9uIG9mIHRoZSB0ZXh0LiBXaWxsIGJlIGNhbGxlZCwgaW4gb3JkZXJcbm9mIHBvc2l0aW9uLCBmb3IgYW55IHJhbmdlcyB3aGVyZSBtb3JlIHRoYW4gemVybyBjbGFzc2VzIGFwcGx5LlxuYGNsYXNzZXNgIGlzIGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBDU1MgY2xhc3Nlcy5cbiovXG5wdXRTdHlsZSwgXG4vKipcblRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gaGlnaGxpZ2h0LlxuKi9cbmZyb20gPSAwLCBcbi8qKlxuVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4qL1xudG8gPSB0cmVlLmxlbmd0aCkge1xuICAgIGxldCBidWlsZGVyID0gbmV3IEhpZ2hsaWdodEJ1aWxkZXIoZnJvbSwgQXJyYXkuaXNBcnJheShoaWdobGlnaHRlcikgPyBoaWdobGlnaHRlciA6IFtoaWdobGlnaHRlcl0sIHB1dFN0eWxlKTtcbiAgICBidWlsZGVyLmhpZ2hsaWdodFJhbmdlKHRyZWUuY3Vyc29yKCksIGZyb20sIHRvLCBcIlwiLCBidWlsZGVyLmhpZ2hsaWdodGVycyk7XG4gICAgYnVpbGRlci5mbHVzaCh0byk7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gdHJlZSB3aXRoIHRoZSBnaXZlbiBoaWdobGlnaHRlciwgY2FsbGluZ1xuYHB1dFRleHRgIGZvciBldmVyeSBwaWVjZSBvZiB0ZXh0LCBlaXRoZXIgd2l0aCBhIHNldCBvZiBjbGFzc2VzIG9yXG53aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiB1bnN0eWxlZCwgYW5kIGBwdXRCcmVha2AgZm9yIGV2ZXJ5IGxpbmVcbmJyZWFrLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodENvZGUoY29kZSwgdHJlZSwgaGlnaGxpZ2h0ZXIsIHB1dFRleHQsIHB1dEJyZWFrLCBmcm9tID0gMCwgdG8gPSBjb2RlLmxlbmd0aCkge1xuICAgIGxldCBwb3MgPSBmcm9tO1xuICAgIGZ1bmN0aW9uIHdyaXRlVG8ocCwgY2xhc3Nlcykge1xuICAgICAgICBpZiAocCA8PSBwb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHRleHQgPSBjb2RlLnNsaWNlKHBvcywgcCksIGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgaSk7XG4gICAgICAgICAgICBsZXQgdXB0byA9IG5leHRCcmVhayA8IDAgPyB0ZXh0Lmxlbmd0aCA6IG5leHRCcmVhaztcbiAgICAgICAgICAgIGlmICh1cHRvID4gaSlcbiAgICAgICAgICAgICAgICBwdXRUZXh0KHRleHQuc2xpY2UoaSwgdXB0byksIGNsYXNzZXMpO1xuICAgICAgICAgICAgaWYgKG5leHRCcmVhayA8IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwdXRCcmVhaygpO1xuICAgICAgICAgICAgaSA9IG5leHRCcmVhayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gcDtcbiAgICB9XG4gICAgaGlnaGxpZ2h0VHJlZSh0cmVlLCBoaWdobGlnaHRlciwgKGZyb20sIHRvLCBjbGFzc2VzKSA9PiB7XG4gICAgICAgIHdyaXRlVG8oZnJvbSwgXCJcIik7XG4gICAgICAgIHdyaXRlVG8odG8sIGNsYXNzZXMpO1xuICAgIH0sIGZyb20sIHRvKTtcbiAgICB3cml0ZVRvKHRvLCBcIlwiKTtcbn1cbmNsYXNzIEhpZ2hsaWdodEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGF0LCBoaWdobGlnaHRlcnMsIHNwYW4pIHtcbiAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVycyA9IGhpZ2hsaWdodGVycztcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IFwiXCI7XG4gICAgfVxuICAgIHN0YXJ0U3BhbihhdCwgY2xzKSB7XG4gICAgICAgIGlmIChjbHMgIT0gdGhpcy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5mbHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQgPiB0aGlzLmF0KVxuICAgICAgICAgICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2godG8pIHtcbiAgICAgICAgaWYgKHRvID4gdGhpcy5hdCAmJiB0aGlzLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5zcGFuKHRoaXMuYXQsIHRvLCB0aGlzLmNsYXNzKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgeyB0eXBlLCBmcm9tOiBzdGFydCwgdG86IGVuZCB9ID0gY3Vyc29yO1xuICAgICAgICBpZiAoc3RhcnQgPj0gdG8gfHwgZW5kIDw9IGZyb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlLmlzVG9wKVxuICAgICAgICAgICAgaGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZSh0eXBlKSk7XG4gICAgICAgIGxldCBjbHMgPSBpbmhlcml0ZWRDbGFzcztcbiAgICAgICAgbGV0IHJ1bGUgPSBnZXRTdHlsZVRhZ3MoY3Vyc29yKSB8fCBSdWxlLmVtcHR5O1xuICAgICAgICBsZXQgdGFnQ2xzID0gaGlnaGxpZ2h0VGFncyhoaWdobGlnaHRlcnMsIHJ1bGUudGFncyk7XG4gICAgICAgIGlmICh0YWdDbHMpIHtcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiO1xuICAgICAgICAgICAgY2xzICs9IHRhZ0NscztcbiAgICAgICAgICAgIGlmIChydWxlLm1vZGUgPT0gMSAvKiBNb2RlLkluaGVyaXQgKi8pXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgKz0gKGluaGVyaXRlZENsYXNzID8gXCIgXCIgOiBcIlwiKSArIHRhZ0NscztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1heChmcm9tLCBzdGFydCksIGNscyk7XG4gICAgICAgIGlmIChydWxlLm9wYXF1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1vdW50ZWQgPSBjdXJzb3IudHJlZSAmJiBjdXJzb3IudHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGN1cnNvci5ub2RlLmVudGVyKG1vdW50ZWQub3ZlcmxheVswXS5mcm9tICsgc3RhcnQsIDEpO1xuICAgICAgICAgICAgbGV0IGlubmVySGlnaGxpZ2h0ZXJzID0gdGhpcy5oaWdobGlnaHRlcnMuZmlsdGVyKGggPT4gIWguc2NvcGUgfHwgaC5zY29wZShtb3VudGVkLnRyZWUudHlwZSkpO1xuICAgICAgICAgICAgbGV0IGhhc0NoaWxkID0gY3Vyc29yLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBzdGFydDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaSA8IG1vdW50ZWQub3ZlcmxheS5sZW5ndGggPyBtb3VudGVkLm92ZXJsYXlbaV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dCA/IG5leHQuZnJvbSArIHN0YXJ0IDogZW5kO1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpLCByYW5nZVRvID0gTWF0aC5taW4odG8sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUZyb20gPCByYW5nZVRvICYmIGhhc0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IuZnJvbSA8IHJhbmdlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCByYW5nZUZyb20sIHJhbmdlVG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ocmFuZ2VUbywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gbmV4dFBvcyB8fCAhY3Vyc29yLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHRQb3MgPiB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gbmV4dC50byArIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaW5uZXIuY3Vyc29yKCksIE1hdGgubWF4KGZyb20sIG5leHQuZnJvbSArIHN0YXJ0KSwgTWF0aC5taW4odG8sIHBvcyksIFwiXCIsIGlubmVySGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIHBvcyksIGNscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkKVxuICAgICAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJzb3IuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZClcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyA9IFwiXCI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA8PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0UmFuZ2UoY3Vyc29yLCBmcm9tLCB0bywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4odG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbk1hdGNoIGEgc3ludGF4IG5vZGUncyBbaGlnaGxpZ2h0IHJ1bGVzXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykuIElmXG50aGVyZSdzIGEgbWF0Y2gsIHJldHVybiBpdHMgc2V0IG9mIHRhZ3MsIGFuZCB3aGV0aGVyIGl0IGlzXG5vcGFxdWUgKHVzZXMgYSBgIWApIG9yIGFwcGxpZXMgdG8gYWxsIGNoaWxkIG5vZGVzIChgLy4uLmApLlxuKi9cbmZ1bmN0aW9uIGdldFN0eWxlVGFncyhub2RlKSB7XG4gICAgbGV0IHJ1bGUgPSBub2RlLnR5cGUucHJvcChydWxlTm9kZVByb3ApO1xuICAgIHdoaWxlIChydWxlICYmIHJ1bGUuY29udGV4dCAmJiAhbm9kZS5tYXRjaENvbnRleHQocnVsZS5jb250ZXh0KSlcbiAgICAgICAgcnVsZSA9IHJ1bGUubmV4dDtcbiAgICByZXR1cm4gcnVsZSB8fCBudWxsO1xufVxuY29uc3QgdCA9IFRhZy5kZWZpbmU7XG5jb25zdCBjb21tZW50ID0gdCgpLCBuYW1lID0gdCgpLCB0eXBlTmFtZSA9IHQobmFtZSksIHByb3BlcnR5TmFtZSA9IHQobmFtZSksIGxpdGVyYWwgPSB0KCksIHN0cmluZyA9IHQobGl0ZXJhbCksIG51bWJlciA9IHQobGl0ZXJhbCksIGNvbnRlbnQgPSB0KCksIGhlYWRpbmcgPSB0KGNvbnRlbnQpLCBrZXl3b3JkID0gdCgpLCBvcGVyYXRvciA9IHQoKSwgcHVuY3R1YXRpb24gPSB0KCksIGJyYWNrZXQgPSB0KHB1bmN0dWF0aW9uKSwgbWV0YSA9IHQoKTtcbi8qKlxuVGhlIGRlZmF1bHQgc2V0IG9mIGhpZ2hsaWdodGluZyBbdGFnc10oI2hpZ2hsaWdodC5UYWcpLlxuXG5UaGlzIGNvbGxlY3Rpb24gaXMgaGVhdmlseSBiaWFzZWQgdG93YXJkcyBwcm9ncmFtbWluZyBsYW5ndWFnZXMsXG5hbmQgbmVjZXNzYXJpbHkgaW5jb21wbGV0ZS4gQSBmdWxsIG9udG9sb2d5IG9mIHN5bnRhY3RpY1xuY29uc3RydWN0cyB3b3VsZCBmaWxsIGEgc3RhY2sgb2YgYm9va3MsIGFuZCBiZSBpbXByYWN0aWNhbCB0b1xud3JpdGUgdGhlbWVzIGZvci4gU28gdHJ5IHRvIG1ha2UgZG8gd2l0aCB0aGlzIHNldC4gSWYgYWxsIGVsc2VcbmZhaWxzLCBbb3BlbiBhblxuaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2NvZGVtaXJyb3IubmV4dCkgdG8gcHJvcG9zZSBhXG5uZXcgdGFnLCBvciBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIGEgbG9jYWwgY3VzdG9tIHRhZyBmb3JcbnlvdXIgdXNlIGNhc2UuXG5cbk5vdGUgdGhhdCBpdCBpcyBub3Qgb2JsaWdhdG9yeSB0byBhbHdheXMgYXR0YWNoIHRoZSBtb3N0IHNwZWNpZmljXG50YWcgcG9zc2libGUgdG8gYW4gZWxlbWVudOKAlGlmIHlvdXIgZ3JhbW1hciBjYW4ndCBlYXNpbHlcbmRpc3Rpbmd1aXNoIGEgY2VydGFpbiB0eXBlIG9mIGVsZW1lbnQgKHN1Y2ggYXMgYSBsb2NhbCB2YXJpYWJsZSksXG5pdCBpcyBva2F5IHRvIHN0eWxlIGl0IGFzIGl0cyBtb3JlIGdlbmVyYWwgdmFyaWFudCAoYSB2YXJpYWJsZSkuXG5cbkZvciB0YWdzIHRoYXQgZXh0ZW5kIHNvbWUgcGFyZW50IHRhZywgdGhlIGRvY3VtZW50YXRpb24gbGlua3MgdG9cbnRoZSBwYXJlbnQuXG4qL1xuY29uc3QgdGFncyA9IHtcbiAgICAvKipcbiAgICBBIGNvbW1lbnQuXG4gICAgKi9cbiAgICBjb21tZW50LFxuICAgIC8qKlxuICAgIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgbGluZUNvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgYmxvY2tDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAgICovXG4gICAgZG9jQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAgICovXG4gICAgbmFtZSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIHZhcmlhYmxlLlxuICAgICovXG4gICAgdmFyaWFibGVOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgdHlwZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxuICAgIC8qKlxuICAgIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICAgKi9cbiAgICB0YWdOYW1lOiB0KHR5cGVOYW1lKSxcbiAgICAvKipcbiAgICBBIHByb3BlcnR5IG9yIGZpZWxkIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgbmFtZSAoc3VidGFnIG9mIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkpLlxuICAgICovXG4gICAgYXR0cmlidXRlTmFtZTogdChwcm9wZXJ0eU5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICAgKi9cbiAgICBjbGFzc05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbGFiZWxOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBuYW1lc3BhY2U6IHQobmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgICAqL1xuICAgIG1hY3JvTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxpdGVyYWwgdmFsdWUuXG4gICAgKi9cbiAgICBsaXRlcmFsLFxuICAgIC8qKlxuICAgIEEgc3RyaW5nIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBzdHJpbmcsXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpLlxuICAgICovXG4gICAgZG9jU3RyaW5nOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBjaGFyYWN0ZXIgbGl0ZXJhbCAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGNoYXJhY3RlcjogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZVZhbHVlOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQSBudW1iZXIgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIG51bWJlcixcbiAgICAvKipcbiAgICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBpbnRlZ2VyOiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBmbG9hdGluZy1wb2ludCBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgZmxvYXQ6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGJvb2xlYW4gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGJvb2w6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgUmVndWxhciBleHByZXNzaW9uIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICByZWdleHA6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQW4gZXNjYXBlIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCksIGZvciBleGFtcGxlIGFcbiAgICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAgICovXG4gICAgZXNjYXBlOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIGNvbG9yOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICB1cmw6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAgICovXG4gICAga2V5d29yZCxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgdGhlIHNlbGYgb3IgdGhpc1xuICAgIG9iamVjdC5cbiAgICAqL1xuICAgIHNlbGY6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICAgKi9cbiAgICBudWxsOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgICAqL1xuICAgIGF0b206IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICAgKi9cbiAgICB1bml0OiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIG1vZGlmaWVyOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgY29udHJvbEtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICAgIGludGVyZmFjaW5nIHdpdGggbW9kdWxlcy5cbiAgICAqL1xuICAgIG1vZHVsZUtleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQW4gb3BlcmF0b3IuXG4gICAgKi9cbiAgICBvcGVyYXRvcixcbiAgICAvKipcbiAgICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVyZWZPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQXJpdGhtZXRpYy1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGFyaXRobWV0aWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgTG9naWNhbCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBsb2dpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYml0d2lzZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb21wYXJpc29uIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbXBhcmVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgdXBkYXRlcyBpdHMgb3BlcmFuZC5cbiAgICAqL1xuICAgIHVwZGF0ZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25PcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgVHlwZS1yZWxhdGVkIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIHR5cGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29udHJvbC1mbG93IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGNvbnRyb2xPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICAgKi9cbiAgICBwdW5jdHVhdGlvbixcbiAgICAvKipcbiAgICBbUHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikgdGhhdCBzZXBhcmF0ZXNcbiAgICB0aGluZ3MuXG4gICAgKi9cbiAgICBzZXBhcmF0b3I6IHQocHVuY3R1YXRpb24pLFxuICAgIC8qKlxuICAgIEJyYWNrZXQtc3R5bGUgW3B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pLlxuICAgICovXG4gICAgYnJhY2tldCxcbiAgICAvKipcbiAgICBBbmdsZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgPGAgYW5kIGA+YFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBhbmdsZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgU3F1YXJlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGBbYCBhbmQgYF1gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIHNxdWFyZUJyYWNrZXQ6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIHBhcmVuOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIEJyYWNlcyAodXN1YWxseSBge2AgYW5kIGB9YCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgYnJhY2U6IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQ29udGVudCwgZm9yIGV4YW1wbGUgcGxhaW4gdGV4dCBpbiBYTUwgb3IgbWFya3VwIGRvY3VtZW50cy5cbiAgICAqL1xuICAgIGNvbnRlbnQsXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBoZWFkaW5nLlxuICAgICovXG4gICAgaGVhZGluZyxcbiAgICAvKipcbiAgICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcxOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzI6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMzogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc0OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzU6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICAgKi9cbiAgICBjb250ZW50U2VwYXJhdG9yOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgICAqL1xuICAgIGxpc3Q6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgICAqL1xuICAgIHF1b3RlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAgICovXG4gICAgZW1waGFzaXM6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICAgKi9cbiAgICBzdHJvbmc6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAgICovXG4gICAgbGluazogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgICBtb25vc3BhY2UuXG4gICAgKi9cbiAgICBtb25vc3BhY2U6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGhhcyBhIHN0cmlrZS10aHJvdWdoXG4gICAgc3R5bGUuXG4gICAgKi9cbiAgICBzdHJpa2V0aHJvdWdoOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIEluc2VydGVkIHRleHQgaW4gYSBjaGFuZ2UtdHJhY2tpbmcgZm9ybWF0LlxuICAgICovXG4gICAgaW5zZXJ0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBEZWxldGVkIHRleHQuXG4gICAgKi9cbiAgICBkZWxldGVkOiB0KCksXG4gICAgLyoqXG4gICAgQ2hhbmdlZCB0ZXh0LlxuICAgICovXG4gICAgY2hhbmdlZDogdCgpLFxuICAgIC8qKlxuICAgIEFuIGludmFsaWQgb3IgdW5zeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGludmFsaWQ6IHQoKSxcbiAgICAvKipcbiAgICBNZXRhZGF0YSBvciBtZXRhLWluc3RydWN0aW9uLlxuICAgICovXG4gICAgbWV0YSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jdW1lbnRNZXRhOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYW5ub3RhdGVzIG9yIGFkZHNcbiAgICBhdHRyaWJ1dGVzIHRvIGEgZ2l2ZW4gc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gb3IgcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZS4gU3VidGFnIG9mXG4gICAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgICAqL1xuICAgIHByb2Nlc3NpbmdJbnN0cnVjdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgICBnaXZlbiBlbGVtZW50IGlzIGJlaW5nIGRlZmluZWQuIEV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICB2YXJpb3VzIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdGFncy5cbiAgICAqL1xuICAgIGRlZmluaXRpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoKVxufTtcbi8qKlxuVGhpcyBpcyBhIGhpZ2hsaWdodGVyIHRoYXQgYWRkcyBzdGFibGUsIHByZWRpY3RhYmxlIGNsYXNzZXMgdG9cbnRva2VucywgZm9yIHN0eWxpbmcgd2l0aCBleHRlcm5hbCBDU1MuXG5cblRoZSBmb2xsb3dpbmcgdGFncyBhcmUgbWFwcGVkIHRvIHRoZWlyIG5hbWUgcHJlZml4ZWQgd2l0aCBgXCJ0b2stXCJgXG4oZm9yIGV4YW1wbGUgYFwidG9rLWNvbW1lbnRcImApOlxuXG4qIFtgbGlua2BdKCNoaWdobGlnaHQudGFncy5saW5rKVxuKiBbYGhlYWRpbmdgXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZylcbiogW2BlbXBoYXNpc2BdKCNoaWdobGlnaHQudGFncy5lbXBoYXNpcylcbiogW2BzdHJvbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3Ryb25nKVxuKiBbYGtleXdvcmRgXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZClcbiogW2BhdG9tYF0oI2hpZ2hsaWdodC50YWdzLmF0b20pXG4qIFtgYm9vbGBdKCNoaWdobGlnaHQudGFncy5ib29sKVxuKiBbYHVybGBdKCNoaWdobGlnaHQudGFncy51cmwpXG4qIFtgbGFiZWxOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmxhYmVsTmFtZSlcbiogW2BpbnNlcnRlZGBdKCNoaWdobGlnaHQudGFncy5pbnNlcnRlZClcbiogW2BkZWxldGVkYF0oI2hpZ2hsaWdodC50YWdzLmRlbGV0ZWQpXG4qIFtgbGl0ZXJhbGBdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKVxuKiBbYHN0cmluZ2BdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4qIFtgbnVtYmVyYF0oI2hpZ2hsaWdodC50YWdzLm51bWJlcilcbiogW2B2YXJpYWJsZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuKiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKVxuKiBbYG5hbWVzcGFjZWBdKCNoaWdobGlnaHQudGFncy5uYW1lc3BhY2UpXG4qIFtgY2xhc3NOYW1lYF0oI2hpZ2hsaWdodC50YWdzLmNsYXNzTmFtZSlcbiogW2BtYWNyb05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubWFjcm9OYW1lKVxuKiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4qIFtgb3BlcmF0b3JgXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpXG4qIFtgY29tbWVudGBdKCNoaWdobGlnaHQudGFncy5jb21tZW50KVxuKiBbYG1ldGFgXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSlcbiogW2BwdW5jdHVhdGlvbmBdKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbilcbiogW2BpbnZhbGlkYF0oI2hpZ2hsaWdodC50YWdzLmludmFsaWQpXG5cbkluIGFkZGl0aW9uLCB0aGVzZSBtYXBwaW5ncyBhcmUgcHJvdmlkZWQ6XG5cbiogW2ByZWdleHBgXSgjaGlnaGxpZ2h0LnRhZ3MucmVnZXhwKSxcbiAgW2Blc2NhcGVgXSgjaGlnaGxpZ2h0LnRhZ3MuZXNjYXBlKSwgYW5kXG4gIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHN0cmluZylgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuICBhcmUgbWFwcGVkIHRvIGBcInRvay1zdHJpbmcyXCJgXG4qIFtgc3BlY2lhbGBdKCNoaWdobGlnaHQudGFncy5zcGVjaWFsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lMlwiYFxuKiBbYGxvY2FsYF0oI2hpZ2hsaWdodC50YWdzLmxvY2FsKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKiBbYGRlZmluaXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MuZGVmaW5pdGlvbilbYChwcm9wZXJ0eU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiAgdG8gYFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiYFxuKi9cbmNvbnN0IGNsYXNzSGlnaGxpZ2h0ZXIgPSB0YWdIaWdobGlnaHRlcihbXG4gICAgeyB0YWc6IHRhZ3MubGluaywgY2xhc3M6IFwidG9rLWxpbmtcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsIGNsYXNzOiBcInRvay1oZWFkaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsIGNsYXNzOiBcInRvay1zdHJvbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsIGNsYXNzOiBcInRvay1rZXl3b3JkXCIgfSxcbiAgICB7IHRhZzogdGFncy5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYm9vbCwgY2xhc3M6IFwidG9rLWJvb2xcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnVybCwgY2xhc3M6IFwidG9rLXVybFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnNlcnRlZCwgY2xhc3M6IFwidG9rLWluc2VydGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWxldGVkLCBjbGFzczogXCJ0b2stZGVsZXRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmluZywgY2xhc3M6IFwidG9rLXN0cmluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MubnVtYmVyLCBjbGFzczogXCJ0b2stbnVtYmVyXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgICB7IHRhZzogdGFncy52YXJpYWJsZU5hbWUsIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZTJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgICB7IHRhZzogdGFncy50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5uYW1lc3BhY2UsIGNsYXNzOiBcInRvay1uYW1lc3BhY2VcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSwgY2xhc3M6IFwidG9rLWNsYXNzTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5wcm9wZXJ0eU5hbWUsIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm9wZXJhdG9yLCBjbGFzczogXCJ0b2stb3BlcmF0b3JcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgICB7IHRhZzogdGFncy5tZXRhLCBjbGFzczogXCJ0b2stbWV0YVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCwgY2xhc3M6IFwidG9rLWludmFsaWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcblxuZXhwb3J0IHsgVGFnLCBjbGFzc0hpZ2hsaWdodGVyLCBnZXRTdHlsZVRhZ3MsIGhpZ2hsaWdodENvZGUsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncywgdGFnSGlnaGxpZ2h0ZXIsIHRhZ3MgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StyleModule: () => (/* binding */ StyleModule)\n/* harmony export */ });\nconst C = \"\\u037c\";\nconst COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol.for(C);\nconst SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\");\nconst top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {};\n\n// :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\nclass StyleModule {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(spec, options) {\n    this.rules = [];\n    let {\n      finish\n    } = options || {};\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/);\n    }\n    function render(selectors, spec, target, isKeyframes) {\n      let local = [],\n        isAt = /^@(\\w+)\\b/.exec(selectors[0]),\n        keyframes = isAt && isAt[1] == \"keyframes\";\n      if (isAt && spec == null) return target.push(selectors[0] + \";\");\n      for (let prop in spec) {\n        let value = spec[prop];\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);\n        } else if (value && typeof value == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\");\n          render(splitSelector(prop), value, local, keyframes);\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, l => \"-\" + l.toLowerCase()) + \": \" + value + \";\");\n        }\n      }\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") + \" {\" + local.join(\" \") + \"}\");\n      }\n    }\n    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);\n  }\n\n  // :: () → string\n  // Returns a string containing the module's CSS rules.\n  getRules() {\n    return this.rules.join(\"\\n\");\n  }\n\n  // :: () → string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let id = top[COUNT] || 1;\n    top[COUNT] = id + 1;\n    return C + id.toString(36);\n  }\n\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(root, modules, options) {\n    let set = root[SET],\n      nonce = options && options.nonce;\n    if (!set) set = new StyleSet(root, nonce);else if (nonce) set.setNonce(nonce);\n    set.mount(Array.isArray(modules) ? modules : [modules]);\n  }\n}\nlet adoptedSet = new Map(); //<Document, StyleSet>\n\nclass StyleSet {\n  constructor(root, nonce) {\n    let doc = root.ownerDocument || root,\n      win = doc.defaultView;\n    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {\n      let adopted = adoptedSet.get(doc);\n      if (adopted) {\n        root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets];\n        return root[SET] = adopted;\n      }\n      this.sheet = new win.CSSStyleSheet();\n      root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];\n      adoptedSet.set(doc, this);\n    } else {\n      this.styleTag = doc.createElement(\"style\");\n      if (nonce) this.styleTag.setAttribute(\"nonce\", nonce);\n      let target = root.head || root;\n      target.insertBefore(this.styleTag, target.firstChild);\n    }\n    this.modules = [];\n    root[SET] = this;\n  }\n  mount(modules) {\n    let sheet = this.sheet;\n    let pos = 0 /* Current rule offset */,\n      j = 0; /* Index into this.modules */\n    for (let i = 0; i < modules.length; i++) {\n      let mod = modules[i],\n        index = this.modules.indexOf(mod);\n      if (index < j && index > -1) {\n        // Ordering conflict\n        this.modules.splice(index, 1);\n        j--;\n        index = -1;\n      }\n      if (index == -1) {\n        this.modules.splice(j++, 0, mod);\n        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);\n      } else {\n        while (j < index) pos += this.modules[j++].rules.length;\n        pos += mod.rules.length;\n        j++;\n      }\n    }\n    if (!sheet) {\n      let text = \"\";\n      for (let i = 0; i < this.modules.length; i++) text += this.modules[i].getRules() + \"\\n\";\n      this.styleTag.textContent = text;\n    }\n  }\n  setNonce(nonce) {\n    if (this.styleTag && this.styleTag.getAttribute(\"nonce\") != nonce) this.styleTag.setAttribute(\"nonce\", nonce);\n  }\n}\n\n// Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9zdHlsZS1tb2Qvc3JjL3N0eWxlLW1vZC5qcz82ZDM4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEMgPSBcIlxcdTAzN2NcIlxuY29uc3QgQ09VTlQgPSB0eXBlb2YgU3ltYm9sID09IFwidW5kZWZpbmVkXCIgPyBcIl9fXCIgKyBDIDogU3ltYm9sLmZvcihDKVxuY29uc3QgU0VUID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX3N0eWxlU2V0XCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTgpIDogU3ltYm9sKFwic3R5bGVTZXRcIilcbmNvbnN0IHRvcCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge31cblxuLy8gOjogLSBTdHlsZSBtb2R1bGVzIGVuY2Fwc3VsYXRlIGEgc2V0IG9mIENTUyBydWxlcyBkZWZpbmVkIGZyb21cbi8vIEphdmFTY3JpcHQuIFRoZWlyIGRlZmluaXRpb25zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBhIGdpdmVuIERPTVxuLy8gcm9vdCBhZnRlciBpdCBoYXMgYmVlbiBfbW91bnRlZF8gdGhlcmUgd2l0aCBgU3R5bGVNb2R1bGUubW91bnRgLlxuLy9cbi8vIFN0eWxlIG1vZHVsZXMgc2hvdWxkIGJlIGNyZWF0ZWQgb25jZSBhbmQgc3RvcmVkIHNvbWV3aGVyZSwgYXNcbi8vIG9wcG9zZWQgdG8gcmUtY3JlYXRpbmcgdGhlbSBldmVyeSB0aW1lIHlvdSBuZWVkIHRoZW0uIFRoZSBhbW91bnQgb2Zcbi8vIENTUyBydWxlcyBnZW5lcmF0ZWQgZm9yIGEgZ2l2ZW4gRE9NIHJvb3QgaXMgYm91bmRlZCBieSB0aGUgYW1vdW50XG4vLyBvZiBzdHlsZSBtb2R1bGVzIHRoYXQgd2VyZSB1c2VkLiBTbyB0byBhdm9pZCBsZWFraW5nIHJ1bGVzLCBkb24ndFxuLy8gY3JlYXRlIHRoZXNlIGR5bmFtaWNhbGx5LCBidXQgdHJlYXQgdGhlbSBhcyBvbmUtdGltZSBhbGxvY2F0aW9ucy5cbmV4cG9ydCBjbGFzcyBTdHlsZU1vZHVsZSB7XG4gIC8vIDo6IChPYmplY3Q8U3R5bGU+LCA/e2ZpbmlzaDogPyhzdHJpbmcpIOKGkiBzdHJpbmd9KVxuICAvLyBDcmVhdGUgYSBzdHlsZSBtb2R1bGUgZnJvbSB0aGUgZ2l2ZW4gc3BlYy5cbiAgLy9cbiAgLy8gV2hlbiBgZmluaXNoYCBpcyBnaXZlbiwgaXQgaXMgY2FsbGVkIG9uIHJlZ3VsYXIgKG5vbi1gQGApXG4gIC8vIHNlbGVjdG9ycyAoYWZ0ZXIgYCZgIGV4cGFuc2lvbikgdG8gY29tcHV0ZSB0aGUgZmluYWwgc2VsZWN0b3IuXG4gIGNvbnN0cnVjdG9yKHNwZWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnJ1bGVzID0gW11cbiAgICBsZXQge2ZpbmlzaH0gPSBvcHRpb25zIHx8IHt9XG5cbiAgICBmdW5jdGlvbiBzcGxpdFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gL15ALy50ZXN0KHNlbGVjdG9yKSA/IFtzZWxlY3Rvcl0gOiBzZWxlY3Rvci5zcGxpdCgvLFxccyovKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlcihzZWxlY3RvcnMsIHNwZWMsIHRhcmdldCwgaXNLZXlmcmFtZXMpIHtcbiAgICAgIGxldCBsb2NhbCA9IFtdLCBpc0F0ID0gL15AKFxcdyspXFxiLy5leGVjKHNlbGVjdG9yc1swXSksIGtleWZyYW1lcyA9IGlzQXQgJiYgaXNBdFsxXSA9PSBcImtleWZyYW1lc1wiXG4gICAgICBpZiAoaXNBdCAmJiBzcGVjID09IG51bGwpIHJldHVybiB0YXJnZXQucHVzaChzZWxlY3RvcnNbMF0gKyBcIjtcIilcbiAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdmFsdWUgPSBzcGVjW3Byb3BdXG4gICAgICAgIGlmICgvJi8udGVzdChwcm9wKSkge1xuICAgICAgICAgIHJlbmRlcihwcm9wLnNwbGl0KC8sXFxzKi8pLm1hcChwYXJ0ID0+IHNlbGVjdG9ycy5tYXAoc2VsID0+IHBhcnQucmVwbGFjZSgvJi8sIHNlbCkpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKSxcbiAgICAgICAgICAgICAgICAgdmFsdWUsIHRhcmdldClcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmICghaXNBdCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSAoXCIgKyBwcm9wICsgXCIpIHNob3VsZCBiZSBhIHByaW1pdGl2ZSB2YWx1ZS5cIilcbiAgICAgICAgICByZW5kZXIoc3BsaXRTZWxlY3Rvcihwcm9wKSwgdmFsdWUsIGxvY2FsLCBrZXlmcmFtZXMpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGxvY2FsLnB1c2gocHJvcC5yZXBsYWNlKC9fLiovLCBcIlwiKS5yZXBsYWNlKC9bQS1aXS9nLCBsID0+IFwiLVwiICsgbC50b0xvd2VyQ2FzZSgpKSArIFwiOiBcIiArIHZhbHVlICsgXCI7XCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb2NhbC5sZW5ndGggfHwga2V5ZnJhbWVzKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKChmaW5pc2ggJiYgIWlzQXQgJiYgIWlzS2V5ZnJhbWVzID8gc2VsZWN0b3JzLm1hcChmaW5pc2gpIDogc2VsZWN0b3JzKS5qb2luKFwiLCBcIikgK1xuICAgICAgICAgICAgICAgICAgICBcIiB7XCIgKyBsb2NhbC5qb2luKFwiIFwiKSArIFwifVwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHNwZWNbcHJvcF0sIHRoaXMucnVsZXMpXG4gIH1cblxuICAvLyA6OiAoKSDihpIgc3RyaW5nXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kdWxlJ3MgQ1NTIHJ1bGVzLlxuICBnZXRSdWxlcygpIHsgcmV0dXJuIHRoaXMucnVsZXMuam9pbihcIlxcblwiKSB9XG5cbiAgLy8gOjogKCkg4oaSIHN0cmluZ1xuICAvLyBHZW5lcmF0ZSBhIG5ldyB1bmlxdWUgQ1NTIGNsYXNzIG5hbWUuXG4gIHN0YXRpYyBuZXdOYW1lKCkge1xuICAgIGxldCBpZCA9IHRvcFtDT1VOVF0gfHwgMVxuICAgIHRvcFtDT1VOVF0gPSBpZCArIDFcbiAgICByZXR1cm4gQyArIGlkLnRvU3RyaW5nKDM2KVxuICB9XG5cbiAgLy8gOjogKHVuaW9uPERvY3VtZW50LCBTaGFkb3dSb290PiwgdW5pb248W1N0eWxlTW9kdWxlXSwgU3R5bGVNb2R1bGU+LCA/e25vbmNlOiA/c3RyaW5nfSlcbiAgLy9cbiAgLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxuICAvLyBjb250ZXh0LlxuICAvL1xuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cbiAgLy9cbiAgLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXG4gIC8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3RcbiAgLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXG4gIC8vXG4gIC8vIElmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgaXMgcHJvdmlkZWQsIGl0IGlzIGFkZGVkIHRvXG4gIC8vIHRoZSBgPHN0eWxlPmAgdGFnIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeS5cbiAgc3RhdGljIG1vdW50KHJvb3QsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2V0ID0gcm9vdFtTRVRdLCBub25jZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZVxuICAgIGlmICghc2V0KSBzZXQgPSBuZXcgU3R5bGVTZXQocm9vdCwgbm9uY2UpXG4gICAgZWxzZSBpZiAobm9uY2UpIHNldC5zZXROb25jZShub25jZSlcbiAgICBzZXQubW91bnQoQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbbW9kdWxlc10pXG4gIH1cbn1cblxubGV0IGFkb3B0ZWRTZXQgPSBuZXcgTWFwIC8vPERvY3VtZW50LCBTdHlsZVNldD5cblxuY2xhc3MgU3R5bGVTZXQge1xuICBjb25zdHJ1Y3Rvcihyb290LCBub25jZSkge1xuICAgIGxldCBkb2MgPSByb290Lm93bmVyRG9jdW1lbnQgfHwgcm9vdCwgd2luID0gZG9jLmRlZmF1bHRWaWV3XG4gICAgaWYgKCFyb290LmhlYWQgJiYgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgd2luLkNTU1N0eWxlU2hlZXQpIHtcbiAgICAgIGxldCBhZG9wdGVkID0gYWRvcHRlZFNldC5nZXQoZG9jKVxuICAgICAgaWYgKGFkb3B0ZWQpIHtcbiAgICAgICAgcm9vdC5hZG9wdGVkU3R5bGVTaGVldHMgPSBbYWRvcHRlZC5zaGVldCwgLi4ucm9vdC5hZG9wdGVkU3R5bGVTaGVldHNdXG4gICAgICAgIHJldHVybiByb290W1NFVF0gPSBhZG9wdGVkXG4gICAgICB9XG4gICAgICB0aGlzLnNoZWV0ID0gbmV3IHdpbi5DU1NTdHlsZVNoZWV0XG4gICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFt0aGlzLnNoZWV0LCAuLi5yb290LmFkb3B0ZWRTdHlsZVNoZWV0c11cbiAgICAgIGFkb3B0ZWRTZXQuc2V0KGRvYywgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHlsZVRhZyA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIilcbiAgICAgIGlmIChub25jZSkgdGhpcy5zdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSlcbiAgICAgIGxldCB0YXJnZXQgPSByb290LmhlYWQgfHwgcm9vdFxuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0aGlzLnN0eWxlVGFnLCB0YXJnZXQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgdGhpcy5tb2R1bGVzID0gW11cbiAgICByb290W1NFVF0gPSB0aGlzXG4gIH1cblxuICBtb3VudChtb2R1bGVzKSB7XG4gICAgbGV0IHNoZWV0ID0gdGhpcy5zaGVldFxuICAgIGxldCBwb3MgPSAwIC8qIEN1cnJlbnQgcnVsZSBvZmZzZXQgKi8sIGogPSAwIC8qIEluZGV4IGludG8gdGhpcy5tb2R1bGVzICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbW9kID0gbW9kdWxlc1tpXSwgaW5kZXggPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihtb2QpXG4gICAgICBpZiAoaW5kZXggPCBqICYmIGluZGV4ID4gLTEpIHsgLy8gT3JkZXJpbmcgY29uZmxpY3RcbiAgICAgICAgdGhpcy5tb2R1bGVzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgai0tXG4gICAgICAgIGluZGV4ID0gLTFcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGorKywgMCwgbW9kKVxuICAgICAgICBpZiAoc2hlZXQpIGZvciAobGV0IGsgPSAwOyBrIDwgbW9kLnJ1bGVzLmxlbmd0aDsgaysrKVxuICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUobW9kLnJ1bGVzW2tdLCBwb3MrKylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChqIDwgaW5kZXgpIHBvcyArPSB0aGlzLm1vZHVsZXNbaisrXS5ydWxlcy5sZW5ndGhcbiAgICAgICAgcG9zICs9IG1vZC5ydWxlcy5sZW5ndGhcbiAgICAgICAgaisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaGVldCkge1xuICAgICAgbGV0IHRleHQgPSBcIlwiXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGV4dCArPSB0aGlzLm1vZHVsZXNbaV0uZ2V0UnVsZXMoKSArIFwiXFxuXCJcbiAgICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgfVxuICB9XG5cbiAgc2V0Tm9uY2Uobm9uY2UpIHtcbiAgICBpZiAodGhpcy5zdHlsZVRhZyAmJiB0aGlzLnN0eWxlVGFnLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpICE9IG5vbmNlKVxuICAgICAgdGhpcy5zdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSlcbiAgfVxufVxuXG4vLyBTdHlsZTo6T2JqZWN0PHVuaW9uPFN0eWxlLHN0cmluZz4+XG4vL1xuLy8gQSBzdHlsZSBpcyBhbiBvYmplY3QgdGhhdCwgaW4gdGhlIHNpbXBsZSBjYXNlLCBtYXBzIENTUyBwcm9wZXJ0eVxuLy8gbmFtZXMgdG8gc3RyaW5ncyBob2xkaW5nIHRoZWlyIHZhbHVlcywgYXMgaW4gYHtjb2xvcjogXCJyZWRcIixcbi8vIGZvbnRXZWlnaHQ6IFwiYm9sZFwifWAuIFRoZSBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZ2l2ZW4gaW5cbi8vIGNhbWVsLWNhc2XigJR0aGUgbGlicmFyeSB3aWxsIGluc2VydCBhIGRhc2ggYmVmb3JlIGNhcGl0YWwgbGV0dGVyc1xuLy8gd2hlbiBjb252ZXJ0aW5nIHRoZW0gdG8gQ1NTLlxuLy9cbi8vIElmIHlvdSBpbmNsdWRlIGFuIHVuZGVyc2NvcmUgaW4gYSBwcm9wZXJ0eSBuYW1lLCBpdCBhbmQgZXZlcnl0aGluZ1xuLy8gYWZ0ZXIgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIG91dHB1dCwgd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuXG4vLyBwcm92aWRpbmcgYSBwcm9wZXJ0eSBtdWx0aXBsZSB0aW1lcywgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuLy8gcmVhc29ucy5cbi8vXG4vLyBBIHByb3BlcnR5IGluIGEgc3R5bGUgb2JqZWN0IGNhbiBhbHNvIGJlIGEgc3ViLXNlbGVjdG9yLCB3aGljaFxuLy8gZXh0ZW5kcyB0aGUgY3VycmVudCBjb250ZXh0IHRvIGFkZCBhIHBzZXVkby1zZWxlY3RvciBvciBhIGNoaWxkXG4vLyBzZWxlY3Rvci4gU3VjaCBhIHByb3BlcnR5IHNob3VsZCBjb250YWluIGEgYCZgIGNoYXJhY3Rlciwgd2hpY2hcbi8vIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGN1cnJlbnQgc2VsZWN0b3IuIEZvciBleGFtcGxlIGB7XCImOmJlZm9yZVwiOlxuLy8ge2NvbnRlbnQ6ICdcImhpXCInfX1gLiBTdWItc2VsZWN0b3JzIGFuZCByZWd1bGFyIHByb3BlcnRpZXMgY2FuXG4vLyBmcmVlbHkgYmUgbWl4ZWQgaW4gYSBnaXZlbiBvYmplY3QuIEFueSBwcm9wZXJ0eSBjb250YWluaW5nIGEgYCZgIGlzXG4vLyBhc3N1bWVkIHRvIGJlIGEgc3ViLXNlbGVjdG9yLlxuLy9cbi8vIEZpbmFsbHksIGEgcHJvcGVydHkgY2FuIHNwZWNpZnkgYW4gQC1ibG9jayB0byBiZSB3cmFwcGVkIGFyb3VuZCB0aGVcbi8vIHN0eWxlcyBkZWZpbmVkIGluc2lkZSB0aGUgb2JqZWN0IHRoYXQncyB0aGUgcHJvcGVydHkncyB2YWx1ZS4gRm9yXG4vLyBleGFtcGxlIHRvIGNyZWF0ZSBhIG1lZGlhIHF1ZXJ5IHlvdSBjYW4gZG8gYHtcIkBtZWRpYSBzY3JlZW4gYW5kXG4vLyAobWluLXdpZHRoOiA0MDBweClcIjogey4uLn19YC5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-mod/src/style-mod.js\n");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   keyName: () => (/* binding */ keyName),\n/* harmony export */   shift: () => (/* binding */ shift)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n};\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n};\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\nfunction keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzPzBmYTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.js\n");

/***/ })

};
