/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_egjs_hammerjs_dist_hammer_esm_js";
export const ids = ["vendors-node_modules_egjs_hammerjs_dist_hammer_esm_js"];
export const modules = {

/***/ "./node_modules/@egjs/hammerjs/dist/hammer.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@egjs/hammerjs/dist/hammer.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttrRecognizer: () => (/* binding */ AttrRecognizer),\n/* harmony export */   DIRECTION_ALL: () => (/* binding */ DIRECTION_ALL),\n/* harmony export */   DIRECTION_DOWN: () => (/* binding */ DIRECTION_DOWN),\n/* harmony export */   DIRECTION_HORIZONTAL: () => (/* binding */ DIRECTION_HORIZONTAL),\n/* harmony export */   DIRECTION_LEFT: () => (/* binding */ DIRECTION_LEFT),\n/* harmony export */   DIRECTION_NONE: () => (/* binding */ DIRECTION_NONE),\n/* harmony export */   DIRECTION_RIGHT: () => (/* binding */ DIRECTION_RIGHT),\n/* harmony export */   DIRECTION_UP: () => (/* binding */ DIRECTION_UP),\n/* harmony export */   DIRECTION_VERTICAL: () => (/* binding */ DIRECTION_VERTICAL),\n/* harmony export */   INPUT_CANCEL: () => (/* binding */ INPUT_CANCEL),\n/* harmony export */   INPUT_END: () => (/* binding */ INPUT_END),\n/* harmony export */   INPUT_MOVE: () => (/* binding */ INPUT_MOVE),\n/* harmony export */   INPUT_START: () => (/* binding */ INPUT_START),\n/* harmony export */   Input: () => (/* binding */ Input),\n/* harmony export */   Manager: () => (/* binding */ Manager),\n/* harmony export */   MouseInput: () => (/* binding */ MouseInput),\n/* harmony export */   Pan: () => (/* binding */ PanRecognizer),\n/* harmony export */   Pinch: () => (/* binding */ PinchRecognizer),\n/* harmony export */   PointerEventInput: () => (/* binding */ PointerEventInput),\n/* harmony export */   Press: () => (/* binding */ PressRecognizer),\n/* harmony export */   Recognizer: () => (/* binding */ Recognizer),\n/* harmony export */   Rotate: () => (/* binding */ RotateRecognizer),\n/* harmony export */   STATE_BEGAN: () => (/* binding */ STATE_BEGAN),\n/* harmony export */   STATE_CANCELLED: () => (/* binding */ STATE_CANCELLED),\n/* harmony export */   STATE_CHANGED: () => (/* binding */ STATE_CHANGED),\n/* harmony export */   STATE_ENDED: () => (/* binding */ STATE_ENDED),\n/* harmony export */   STATE_FAILED: () => (/* binding */ STATE_FAILED),\n/* harmony export */   STATE_POSSIBLE: () => (/* binding */ STATE_POSSIBLE),\n/* harmony export */   STATE_RECOGNIZED: () => (/* binding */ STATE_RECOGNIZED),\n/* harmony export */   SingleTouchInput: () => (/* binding */ SingleTouchInput),\n/* harmony export */   Swipe: () => (/* binding */ SwipeRecognizer),\n/* harmony export */   Tap: () => (/* binding */ TapRecognizer),\n/* harmony export */   TouchAction: () => (/* binding */ TouchAction),\n/* harmony export */   TouchInput: () => (/* binding */ TouchInput),\n/* harmony export */   TouchMouseInput: () => (/* binding */ TouchMouseInput),\n/* harmony export */   addEventListeners: () => (/* binding */ addEventListeners),\n/* harmony export */   assign: () => (/* binding */ assign$1),\n/* harmony export */   bindFn: () => (/* binding */ bindFn),\n/* harmony export */   boolOrFn: () => (/* binding */ boolOrFn),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaults: () => (/* binding */ defaults$1),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   hasParent: () => (/* binding */ hasParent),\n/* harmony export */   inArray: () => (/* binding */ inArray),\n/* harmony export */   inherit: () => (/* binding */ inherit),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   off: () => (/* binding */ removeEventListeners),\n/* harmony export */   on: () => (/* binding */ addEventListeners),\n/* harmony export */   prefixed: () => (/* binding */ prefixed),\n/* harmony export */   removeEventListeners: () => (/* binding */ removeEventListeners),\n/* harmony export */   splitStr: () => (/* binding */ splitStr),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   uniqueArray: () => (/* binding */ uniqueArray)\n/* harmony export */ });\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\nvar assign$1 = assign;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n  abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n  if (!obj) {\n    return;\n  }\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction = /*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n  var _proto = TouchAction.prototype;\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  var firstInput = session.firstInput,\n    firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input = /*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n  var _proto = Input.prototype;\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\nvar PointerEventInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n  function PointerEventInput() {\n    var _this;\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = PointerEventInput.prototype;\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n  return results;\n}\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n  function TouchInput() {\n    var _this;\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n  var _proto = TouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return TouchInput;\n}(Input);\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n  if (!changedTargetTouches.length) {\n    return;\n  }\n  return [\n  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n  function MouseInput() {\n    var _this;\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = MouseInput.prototype;\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n    touch = _eventData$changedPoi[0];\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\nvar TouchMouseInput = /*#__PURE__*/\nfunction () {\n  var TouchMouseInput = /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n      _this = _Input.call(this, _manager, callback) || this;\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n        _this.callback(manager, inputEvent, inputData);\n      };\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n    return TouchMouseInput;\n  }(Input);\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer = /*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n  var _proto = Recognizer.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n  _proto.reset = function reset() {};\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n  function TapRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n  var _proto = TapRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  };\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n  var _proto = AttrRecognizer.prototype;\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  };\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n  function PanRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n  var _proto = PanRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  };\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && (\n    // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n  var _proto = SwipeRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  };\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = RotateRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n  function PressRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n  var _proto = PressRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return PressRecognizer;\n}(Recognizer);\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n  if (!element.style) {\n    return;\n  }\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Manager = /*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n  var _proto = Manager.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n    var i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && (\n      // 1\n      !curRecognizer || recognizer === curRecognizer ||\n      // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n    var recognizers = this.recognizers;\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n    var existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n    var i = 0;\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n  return Manager;\n}();\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n  function SingleTouchInput() {\n    var _this;\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n  var _proto = SingleTouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n    if (!this.started) {\n      return;\n    }\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return SingleTouchInput;\n}(Input);\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer = /*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nvar defaults$1 = Hammer.defaults;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hammer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvaGFtbWVyanMvZGlzdC9oYW1tZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQWhCQTtBQURBO0FBb0JBOztBQUdBO0FDL0JBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7O0FDTkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQ3ZCQTtBQUVBO0FBRUE7O0FBRUE7QUFGQTtBQUlBOztBQ0pBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUpBO0FBTUE7O0FDZEE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDUkE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUNoQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBT0E7QUFDQTs7Ozs7QUN2QkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7QUFFQTs7O0FDYkE7Ozs7Ozs7QUFPQTtBQUNBOzs7QUNDQTs7Ozs7OztBQU1BOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBZEE7O0FBa0JBO0FBQ0E7QUFuQkE7O0FBdUJBO0FBQ0E7O0FBR0E7OztBQ3RCQTs7Ozs7Ozs7O0FBUUE7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRkE7QUFLQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUtBOzs7O0FBS0E7QUFHQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7OztBQzVIQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FDYkE7Ozs7Ozs7QUFNQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRkE7OztBQ3pCQTs7Ozs7OztBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7QUNwQkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQ2ZBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUNiQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTs7QUNoQkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBQ0E7OztBQ3ZCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOzs7QUNQQTs7Ozs7Ozs7O0FBUUE7QUFDQTs7O0FDUkE7Ozs7Ozs7O0FBT0E7QUFDQTs7O0FDTkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVZBOztBQWFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBUEE7O0FBV0E7QUFDQTtBQURBO0FBR0E7O0FBR0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFHQTtBQUNBOztBQUVBOzs7QUM1RUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBVkE7OztBQWVBOztBQUdBOztBQUdBO0FBRUE7QUFDQTs7O0FDbENBOzs7Ozs7QUFPQTtBQUNBOzs7QUNOQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFEQTs7O0FDUkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBREE7OztBQ1ZBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7OztBQ0hBOzs7Ozs7Ozs7QUFRQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFGQTtBQU1BOzs7Ozs7Ozs7QUFRQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTs7O0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTUE7QUFwQkE7O0FBd0JBOztBQXhCQTs7QUE2QkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7QUFFQTs7OztBQXZEQTs7QUM3Q0E7Ozs7OztBQU1BO0FBQ0E7OztBQ0xBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7OztBQU1BOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7Ozs7Ozs7QUFRQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7OztBQWRBO0FBOEJBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBREE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7O0FBK0JBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBTUE7QUFDQTs7QUFFQTs7QUFHQTs7O0FBSUE7QUFBQTtBQUVBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTs7Ozs7Ozs7QUFRQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQVRBOztBQWFBOzs7QUFJQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7O0FBcENBOztBQ1pBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBOztBQUpBO0FBUUE7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFHQTs7QUFJQTs7QUFBQTs7O0FBQ0E7O0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFFQTs7QUFKQTs7QUFTQTtBQUNBO0FBREE7OztBQU1BO0FBL0JBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBO0FBQ0E7QUFDQTs7O0FBekNBO0FBQUE7OztBQ2xFQTs7Ozs7Ozs7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7O0FBRUE7OztBQzVCQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7QUNQQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUNMQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFFQTs7O0FDTkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTs7QUFHQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTEE7O0FBU0E7QUFDQTs7QUFHQTs7QUFFQTs7QUFDQTtBQWhCQTs7QUFvQkE7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7OztBQVFBOzs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7O0FBUkE7O0FBYUE7QUFDQTs7QUFHQTs7O0FBSUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7OztBQVFBOzs7O0FDaFNBOzs7Ozs7Ozs7Ozs7QUFXQTs7O0FBQ0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFWQTs7O0FBZUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7O0FBR0E7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7QUFJQTs7QUFHQTs7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBL0ZBOztBQ1JBOzs7Ozs7O0FBTUE7OztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBREE7QUFHQTs7QUFFQTs7QUFFQTs7O0FBN0NBOztBQ1pBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBOztBQUVBOzs7QUNSQTs7Ozs7Ozs7QUFPQTs7O0FBQ0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFBQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTs7O0FBaEVBOztBQ2ZBOzs7Ozs7OztBQU9BOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBOztBQUdBOztBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUdBOzs7QUF6Q0E7O0FDVkE7Ozs7Ozs7O0FBT0E7OztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUdBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQXhCQTs7QUNQQTs7Ozs7Ozs7QUFPQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBR0E7QUFDQTs7O0FBZkE7O0FDRUE7Ozs7Ozs7O0FBT0E7OztBQUNBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUdBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBT0E7O0FBRUE7O0FBR0E7QUFDQTs7QUFHQTtBQUNBOzs7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBOzs7O0FBdERBO0FDWEE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBU0E7Ozs7OztBQU9BOzs7Ozs7Ozs7QUFVQTs7Ozs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7Ozs7QUFPQTs7Ozs7OztBQVFBOzs7Ozs7Ozs7QUFVQTs7Ozs7OztBQVFBOzs7Ozs7O0FBUUE7Ozs7Ozs7O0FBU0E7O0FBcEdBOzs7Ozs7Ozs7QUErR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FDN0dBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQU5BO0FBU0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTs7QUFDQTs7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSkE7Ozs7Ozs7Ozs7QUFjQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFFQTs7QUFIQTs7QUFRQTtBQUVBO0FBQ0E7Ozs7QUFLQTs7O0FBSUE7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFIQTtBQUtBO0FBZEE7OztBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFGQTs7QUFNQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUlBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFKQTtBQU9BOzs7Ozs7OztBQVFBOztBQUVBO0FBQ0E7QUFIQTs7QUFPQTtBQUVBOzs7QUFJQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTs7Ozs7Ozs7QUFRQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTs7O0FBSUE7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7OztBQTdCQTtBQTZDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBOzs7QUNoRkE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQVZBOzs7QUNUQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQVRBOztBQ1JBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBREE7O0FDVEE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQ2pCQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQURBOzs7QUNrREE7Ozs7Ozs7O0FBT0E7O0FBQUE7Ozs7O0FBNkRBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBSUE7O0FBbkVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE0REE7QUFBQTtBQTVEQTs7O0FDSEE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvYXNzaWduLmpzP2U3OTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3V0aWxzLWNvbnN0cy5qcz9jNzE1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9wcmVmaXhlZC5qcz82M2QwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9icm93c2VyLmpzPzU1ZmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3RvdWNoYWN0aW9uanMvZ2V0LXRvdWNoYWN0aW9uLXByb3BzLmpzPzJjNDgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzLmpzP2IzMDMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvaW5wdXQtY29uc3RzLmpzPzA0OTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2VhY2guanM/MmYxZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvYm9vbC1vci1mbi5qcz8wMzA5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9pbi1zdHIuanM/NjhhOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdG91Y2hhY3Rpb25qcy9jbGVhbi10b3VjaC1hY3Rpb25zLmpzPzAyMTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tY29uc3RydWN0b3IuanM/MjdhMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvaGFzLXBhcmVudC5qcz9hMDJiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1jZW50ZXIuanM/YzM0OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9zaW1wbGUtY2xvbmUtaW5wdXQtZGF0YS5qcz9jMmEyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1kaXN0YW5jZS5qcz8wNjZmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1hbmdsZS5qcz83MjJkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1kaXJlY3Rpb24uanM/MzA0NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9jb21wdXRlLWRlbHRhLXh5LmpzP2Q4ZmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LXZlbG9jaXR5LmpzPzdmMGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LXNjYWxlLmpzPzA1MTAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LXJvdGF0aW9uLmpzPzNhMDciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvY29tcHV0ZS1pbnRlcnZhbC1pbnB1dC1kYXRhLmpzPzJhMmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvY29tcHV0ZS1pbnB1dC1kYXRhLmpzPzNlYzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvaW5wdXQtaGFuZGxlci5qcz9lMjUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9zcGxpdC1zdHIuanM/Zjk1NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvYWRkLWV2ZW50LWxpc3RlbmVycy5qcz8zMDhlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9yZW1vdmUtZXZlbnQtbGlzdGVuZXJzLmpzP2NjMmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2dldC13aW5kb3ctZm9yLWVsZW1lbnQuanM/NmQ3YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3Rvci5qcz80YTE5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9pbi1hcnJheS5qcz8zMzM4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dC9wb2ludGVyZXZlbnQuanM/YTg0NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvdG8tYXJyYXkuanM/OThiMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvdW5pcXVlLWFycmF5LmpzP2M3NjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0L3RvdWNoLmpzP2RlMjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0L21vdXNlLmpzP2JmNjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0L3RvdWNobW91c2UuanM/ZDRmMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9jcmVhdGUtaW5wdXQtaW5zdGFuY2UuanM/NjgxNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvaW52b2tlLWFycmF5LWFyZy5qcz9hMWRlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMuanM/YTY4MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvdW5pcXVlLWlkLmpzPzMwYmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJqcy9nZXQtcmVjb2duaXplci1ieS1uYW1lLWlmLW1hbmFnZXIuanM/OTA4YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcmpzL3N0YXRlLXN0ci5qcz8wZGU4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3Rvci5qcz9jYmEyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy90YXAuanM/ZGRiZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvYXR0cmlidXRlLmpzP2MzOWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJqcy9kaXJlY3Rpb24tc3RyLmpzP2NhMjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3Bhbi5qcz9hYTMyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9zd2lwZS5qcz9jMzU2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9waW5jaC5qcz9kY2Y2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9yb3RhdGUuanM/NzQ2MCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvcHJlc3MuanM/M2M3OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvZGVmYXVsdHMuanM/NmM2MSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvbWFuYWdlci5qcz9iOTJlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dC9zaW5nbGV0b3VjaC5qcz8xNzE0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9kZXByZWNhdGUuanM/YjEzZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvZXh0ZW5kLmpzPzgwYWIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL21lcmdlLmpzPzU2M2QiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2luaGVyaXQuanM/NjMzZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvYmluZC1mbi5qcz9lNmY1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9oYW1tZXIuanM/MWNiOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5kZXguanM/NWE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG5sZXQgYXNzaWduO1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBsZXQgb3V0cHV0ID0gT2JqZWN0KHRhcmdldCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgICAgICBvdXRwdXRbbmV4dEtleV0gPSBzb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59IGVsc2Uge1xuICBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ247IiwiXG5jb25zdCBWRU5ET1JfUFJFRklYRVMgPSBbJycsICd3ZWJraXQnLCAnTW96JywgJ01TJywgJ21zJywgJ28nXTtcbmNvbnN0IFRFU1RfRUxFTUVOVCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHtzdHlsZToge319IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbmNvbnN0IFRZUEVfRlVOQ1RJT04gPSAnZnVuY3Rpb24nO1xuXG5jb25zdCB7IHJvdW5kLCBhYnMgfSA9IE1hdGg7XG5jb25zdCB7IG5vdyB9ID0gRGF0ZTtcblxuZXhwb3J0IHtcbiAgICBWRU5ET1JfUFJFRklYRVMsXG4gICAgVEVTVF9FTEVNRU5ULFxuICAgIFRZUEVfRlVOQ1RJT04sXG4gICAgcm91bmQsXG4gICAgYWJzLFxuICAgIG5vd1xufTtcbiIsImltcG9ydCB7IFZFTkRPUl9QUkVGSVhFUyB9IGZyb20gJy4vdXRpbHMtY29uc3RzJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgbGV0IHByZWZpeDtcbiAgbGV0IHByb3A7XG4gIGxldCBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgcHJvcCA9IChwcmVmaXgpID8gcHJlZml4ICsgY2FtZWxQcm9wIDogcHJvcGVydHk7XG5cbiAgICBpZiAocHJvcCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG5sZXQgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHQvLyB3aW5kb3cgaXMgdW5kZWZpbmVkIGluIG5vZGUuanNcblx0d2luID0ge307XG59IGVsc2Uge1xuXHR3aW4gPSB3aW5kb3c7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG5leHBvcnQge3dpbiBhcyB3aW5kb3d9O1xuIiwiaW1wb3J0IHByZWZpeGVkIGZyb20gJy4uL3V0aWxzL3ByZWZpeGVkJztcbmltcG9ydCB7IFRFU1RfRUxFTUVOVCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQge3dpbmRvd30gZnJvbSAnLi4vYnJvd3Nlcic7XG5cbmV4cG9ydCBjb25zdCBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xuZXhwb3J0IGNvbnN0IE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgaWYgKCFOQVRJVkVfVE9VQ0hfQUNUSU9OKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCB0b3VjaE1hcCA9IHt9O1xuICBsZXQgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goKHZhbCkgPT4ge1xuXG4gICAgLy8gSWYgY3NzLnN1cHBvcnRzIGlzIG5vdCBzdXBwb3J0ZWQgYnV0IHRoZXJlIGlzIG5hdGl2ZSB0b3VjaC1hY3Rpb24gYXNzdW1lIGl0IHN1cHBvcnRzXG4gICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgIHJldHVybiB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB0b3VjaE1hcDtcbn1cbiIsImltcG9ydCBnZXRUb3VjaEFjdGlvblByb3BzIGZyb20gJy4vZ2V0LXRvdWNoYWN0aW9uLXByb3BzJztcblxuXG5cbi8vIG1hZ2ljYWwgdG91Y2hBY3Rpb24gdmFsdWVcbmNvbnN0IFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xuY29uc3QgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG5jb25zdCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxuY29uc3QgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG5jb25zdCBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xuY29uc3QgVE9VQ0hfQUNUSU9OX1BBTl9ZID0gJ3Bhbi15JztcbmNvbnN0IFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbmV4cG9ydCB7XG4gIFRPVUNIX0FDVElPTl9BVVRPLFxuICBUT1VDSF9BQ1RJT05fQ09NUFVURSxcbiAgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTixcbiAgVE9VQ0hfQUNUSU9OX05PTkUsXG4gIFRPVUNIX0FDVElPTl9QQU5fWCxcbiAgVE9VQ0hfQUNUSU9OX1BBTl9ZLFxuICBUT1VDSF9BQ1RJT05fTUFQXG59O1xuIiwiaW1wb3J0IHByZWZpeGVkIGZyb20gJy4uL3V0aWxzL3ByZWZpeGVkJztcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vYnJvd3NlclwiO1xuXG5jb25zdCBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbmNvbnN0IFNVUFBPUlRfVE9VQ0ggPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbmNvbnN0IFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xuY29uc3QgU1VQUE9SVF9PTkxZX1RPVUNIID0gU1VQUE9SVF9UT1VDSCAmJiBNT0JJTEVfUkVHRVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuY29uc3QgSU5QVVRfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XG5jb25zdCBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xuY29uc3QgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG5jb25zdCBJTlBVVF9UWVBFX0tJTkVDVCA9ICdraW5lY3QnO1xuXG5jb25zdCBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbmNvbnN0IElOUFVUX1NUQVJUID0gMTtcbmNvbnN0IElOUFVUX01PVkUgPSAyO1xuY29uc3QgSU5QVVRfRU5EID0gNDtcbmNvbnN0IElOUFVUX0NBTkNFTCA9IDg7XG5cbmNvbnN0IERJUkVDVElPTl9OT05FID0gMTtcbmNvbnN0IERJUkVDVElPTl9MRUZUID0gMjtcbmNvbnN0IERJUkVDVElPTl9SSUdIVCA9IDQ7XG5jb25zdCBESVJFQ1RJT05fVVAgPSA4O1xuY29uc3QgRElSRUNUSU9OX0RPV04gPSAxNjtcblxuY29uc3QgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fTEVGVCB8IERJUkVDVElPTl9SSUdIVDtcbmNvbnN0IERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9VUCB8IERJUkVDVElPTl9ET1dOO1xuY29uc3QgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG5jb25zdCBQUk9QU19YWSA9IFsneCcsICd5J107XG5jb25zdCBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG5leHBvcnQge1xuICAgIE1PQklMRV9SRUdFWCxcbiAgICBTVVBQT1JUX09OTFlfVE9VQ0gsXG4gICAgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyxcbiAgICBTVVBQT1JUX1RPVUNILFxuICAgIElOUFVUX1RZUEVfS0lORUNULFxuICAgIElOUFVUX1RZUEVfTU9VU0UsXG4gICAgSU5QVVRfVFlQRV9QRU4sXG4gICAgSU5QVVRfVFlQRV9UT1VDSCxcbiAgICBDT01QVVRFX0lOVEVSVkFMLFxuICAgIElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTCxcbiAgICBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fQUxMLFxuICAgIFBST1BTX1hZLFxuICAgIFBST1BTX0NMSUVOVF9YWVxufTtcbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gIGxldCBpO1xuXG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICBpKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFRZUEVfRlVOQ1RJT04gfSBmcm9tICcuL3V0aWxzLWNvbnN0cyc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZihmaW5kKSA+IC0xO1xufVxuIiwiaW1wb3J0IGluU3RyIGZyb20gJy4uL3V0aWxzL2luLXN0cic7XG5pbXBvcnQge1xuICAgIFRPVUNIX0FDVElPTl9OT05FLFxuICAgIFRPVUNIX0FDVElPTl9QQU5fWCxcbiAgICBUT1VDSF9BQ1RJT05fUEFOX1ksXG4gICAgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTixcbiAgICBUT1VDSF9BQ1RJT05fQVVUT1xufSBmcm9tICcuL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gIC8vIG5vbmVcbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfVxuXG4gIGxldCBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgbGV0IGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH1cblxuICAvLyBwYW4teCBPUiBwYW4teVxuICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gIH1cblxuICAvLyBtYW5pcHVsYXRpb25cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG4iLCJpbXBvcnQge1xuICAgIFRPVUNIX0FDVElPTl9DT01QVVRFLFxuICAgIFRPVUNIX0FDVElPTl9NQVAsXG4gICAgVE9VQ0hfQUNUSU9OX05PTkUsXG4gICAgVE9VQ0hfQUNUSU9OX1BBTl9YLFxuICAgIFRPVUNIX0FDVElPTl9QQU5fWVxufSBmcm9tICcuL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQge1xuICBOQVRJVkVfVE9VQ0hfQUNUSU9OLFxuICBQUkVGSVhFRF9UT1VDSF9BQ1RJT04sXG59IGZyb20gXCIuL2dldC10b3VjaGFjdGlvbi1wcm9wc1wiO1xuaW1wb3J0IHtcbiAgICBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUxcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IGVhY2ggZnJvbSAnLi4vdXRpbHMvZWFjaCc7XG5pbXBvcnQgYm9vbE9yRm4gZnJvbSAnLi4vdXRpbHMvYm9vbC1vci1mbic7XG5pbXBvcnQgaW5TdHIgZnJvbSAnLi4vdXRpbHMvaW4tc3RyJztcbmltcG9ydCBjbGVhblRvdWNoQWN0aW9ucyBmcm9tICcuL2NsZWFuLXRvdWNoLWFjdGlvbnMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoQWN0aW9uIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXQodmFsdWUpIHtcbiAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgIGlmICh2YWx1ZSA9PT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAqL1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNvbXB1dGUgdGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgYmFzZWQgb24gdGhlIHJlY29nbml6ZXIncyBzZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgY29tcHV0ZSgpIHtcbiAgICBsZXQgYWN0aW9ucyA9IFtdO1xuICAgIGVhY2godGhpcy5tYW5hZ2VyLnJlY29nbml6ZXJzLCAocmVjb2duaXplcikgPT4ge1xuICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdHMoaW5wdXQpIHtcbiAgICBsZXQgeyBzcmNFdmVudCB9ID0gaW5wdXQ7XG4gICAgbGV0IGRpcmVjdGlvbiA9IGlucHV0Lm9mZnNldERpcmVjdGlvbjtcblxuICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHsgYWN0aW9ucyB9ID0gdGhpcztcbiAgICBsZXQgaGFzTm9uZSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgbGV0IGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgbGV0IGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWF07XG5cbiAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgLy8gZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG4gICAgICBsZXQgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgbGV0IGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICBsZXQgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgIChoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB8fFxuICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCB0byBwcmV2ZW50IHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvciAoc2Nyb2xsaW5nIGluIG1vc3QgY2FzZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgKi9cbiAgcHJldmVudFNyYyhzcmNFdmVudCkge1xuICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gIGxldCBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAvLyBubyBuZWVkIHRvIGxvb3Agd2hlbiBvbmx5IG9uZSB0b3VjaFxuICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgIH07XG4gIH1cblxuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgeCArPSBwb2ludGVyc1tpXS5jbGllbnRYO1xuICAgIHkgKz0gcG9pbnRlcnNbaV0uY2xpZW50WTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggLyBwb2ludGVyc0xlbmd0aCksXG4gICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICB9O1xufVxuIiwiaW1wb3J0IHsgbm93LHJvdW5kIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCBnZXRDZW50ZXIgZnJvbSAnLi9nZXQtY2VudGVyJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICBsZXQgcG9pbnRlcnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgIH07XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgIHBvaW50ZXJzLFxuICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICB9O1xufVxuIiwiaW1wb3J0IHsgUFJPUFNfWFkgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cbiAgbGV0IHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIGxldCB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xufVxuIiwiaW1wb3J0IHsgUFJPUFNfWFkgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFuZ2xlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cbiAgbGV0IHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV07XG4gIGxldCB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG59XG4iLCJpbXBvcnQgeyBhYnMgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IHsgRElSRUNUSU9OX05PTkUsRElSRUNUSU9OX0xFRlQsRElSRUNUSU9OX1JJR0hULERJUkVDVElPTl9VUCxESVJFQ1RJT05fRE9XTiB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG5cbiAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgfVxuICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cbiIsImltcG9ydCB7IElOUFVUX1NUQVJULCBJTlBVVF9FTkQgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gIGxldCB7IGNlbnRlciB9ID0gaW5wdXQ7XG4gIC8vIGxldCB7IG9mZnNldERlbHRhOm9mZnNldCA9IHt9LCBwcmV2RGVsdGEgPSB7fSwgcHJldklucHV0ID0ge30gfSA9IHNlc3Npb247XG4gIC8vIGpzY3MgdGhyb3dpbmcgZXJyb3Igb24gZGVmYWx1dCBkZXN0cnVjdHVyZWQgdmFsdWVzIGFuZCB3aXRob3V0IGRlZmF1bHRzIHRlc3RzIGZhaWxcbiAgbGV0IG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgfHwge307XG4gIGxldCBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSB8fCB7fTtcbiAgbGV0IHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX1NUQVJUIHx8IHByZXZJbnB1dC5ldmVudFR5cGUgPT09IElOUFVUX0VORCkge1xuICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgfTtcblxuICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55XG4gICAgfTtcbiAgfVxuXG4gIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gIH07XG59XG4iLCJpbXBvcnQgeyBQUk9QU19DTElFTlRfWFkgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgZ2V0RGlzdGFuY2UgZnJvbSAnLi9nZXQtZGlzdGFuY2UnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cbiIsImltcG9ydCBnZXRBbmdsZSBmcm9tICcuL2dldC1hbmdsZSc7XG5pbXBvcnQgeyBQUk9QU19DTElFTlRfWFkgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cbiIsImltcG9ydCB7IElOUFVUX0NBTkNFTCxDT01QVVRFX0lOVEVSVkFMIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IHsgYWJzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCBnZXRWZWxvY2l0eSBmcm9tICcuL2dldC12ZWxvY2l0eSc7XG5pbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJy4vZ2V0LWRpcmVjdGlvbic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHZlbG9jaXR5IGlzIGNhbGN1bGF0ZWQgZXZlcnkgeCBtc1xuICogQHBhcmFtIHtPYmplY3R9IHNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgbGV0IGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dDtcbiAgbGV0IGRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGxhc3QudGltZVN0YW1wO1xuICBsZXQgdmVsb2NpdHk7XG4gIGxldCB2ZWxvY2l0eVg7XG4gIGxldCB2ZWxvY2l0eVk7XG4gIGxldCBkaXJlY3Rpb247XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfQ0FOQ0VMICYmIChkZWx0YVRpbWUgPiBDT01QVVRFX0lOVEVSVkFMIHx8IGxhc3QudmVsb2NpdHkgPT09IHVuZGVmaW5lZCkpIHtcbiAgICBsZXQgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgbGV0IGRlbHRhWSA9IGlucHV0LmRlbHRhWSAtIGxhc3QuZGVsdGFZO1xuXG4gICAgbGV0IHYgPSBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgdmVsb2NpdHlZID0gdi55O1xuICAgIHZlbG9jaXR5ID0gKGFicyh2LngpID4gYWJzKHYueSkpID8gdi54IDogdi55O1xuICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gIH1cblxuICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuIiwiaW1wb3J0IHsgbm93IH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCB7IGFicyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgaGFzUGFyZW50IGZyb20gJy4uL3V0aWxzL2hhcy1wYXJlbnQnO1xuaW1wb3J0IHNpbXBsZUNsb25lSW5wdXREYXRhIGZyb20gJy4vc2ltcGxlLWNsb25lLWlucHV0LWRhdGEnO1xuaW1wb3J0IGdldENlbnRlciBmcm9tICcuL2dldC1jZW50ZXInO1xuaW1wb3J0IGdldERpc3RhbmNlIGZyb20gJy4vZ2V0LWRpc3RhbmNlJztcbmltcG9ydCBnZXRBbmdsZSBmcm9tICcuL2dldC1hbmdsZSc7XG5pbXBvcnQgZ2V0RGlyZWN0aW9uIGZyb20gJy4vZ2V0LWRpcmVjdGlvbic7XG5pbXBvcnQgY29tcHV0ZURlbHRhWFkgZnJvbSAnLi9jb21wdXRlLWRlbHRhLXh5JztcbmltcG9ydCBnZXRWZWxvY2l0eSBmcm9tICcuL2dldC12ZWxvY2l0eSc7XG5pbXBvcnQgZ2V0U2NhbGUgZnJvbSAnLi9nZXQtc2NhbGUnO1xuaW1wb3J0IGdldFJvdGF0aW9uIGZyb20gJy4vZ2V0LXJvdGF0aW9uJztcbmltcG9ydCBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEgZnJvbSAnLi9jb21wdXRlLWludGVydmFsLWlucHV0LWRhdGEnO1xuXG4vKipcbiogQHByaXZhdGVcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICBsZXQgeyBzZXNzaW9uIH0gPSBtYW5hZ2VyO1xuICBsZXQgeyBwb2ludGVycyB9ID0gaW5wdXQ7XG4gIGxldCB7IGxlbmd0aDpwb2ludGVyc0xlbmd0aCB9ID0gcG9pbnRlcnM7XG5cbiAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfVxuXG4gIC8vIHRvIGNvbXB1dGUgc2NhbGUgYW5kIHJvdGF0aW9uIHdlIG5lZWQgdG8gc3RvcmUgdGhlIG11bHRpcGxlIHRvdWNoZXNcbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgc2Vzc2lvbi5maXJzdE11bHRpcGxlID0gZmFsc2U7XG4gIH1cblxuICBsZXQgeyBmaXJzdElucHV0LCBmaXJzdE11bHRpcGxlIH0gPSBzZXNzaW9uO1xuICBsZXQgb2Zmc2V0Q2VudGVyID0gZmlyc3RNdWx0aXBsZSA/IGZpcnN0TXVsdGlwbGUuY2VudGVyIDogZmlyc3RJbnB1dC5jZW50ZXI7XG5cbiAgbGV0IGNlbnRlciA9IGlucHV0LmNlbnRlciA9IGdldENlbnRlcihwb2ludGVycyk7XG4gIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICBpbnB1dC5kZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBmaXJzdElucHV0LnRpbWVTdGFtcDtcblxuICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpO1xuICBpbnB1dC5vZmZzZXREaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuXG4gIGxldCBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WCA9IG92ZXJhbGxWZWxvY2l0eS54O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZID0gb3ZlcmFsbFZlbG9jaXR5Lnk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpO1xuXG4gIC8vIGZpbmQgdGhlIGNvcnJlY3QgdGFyZ2V0XG4gIGxldCB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gIGNvbnN0IHNyY0V2ZW50ID0gaW5wdXQuc3JjRXZlbnQ7XG4gIGxldCBzcmNFdmVudFRhcmdldDtcblxuICBpZiAoc3JjRXZlbnQuY29tcG9zZWRQYXRoKSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfSBlbHNlIGlmIChzcmNFdmVudC5wYXRoKSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC5wYXRoWzBdO1xuICB9IGVsc2Uge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQudGFyZ2V0O1xuICB9XG5cbiAgaWYgKGhhc1BhcmVudChzcmNFdmVudFRhcmdldCwgdGFyZ2V0KSkge1xuICAgIHRhcmdldCA9IHNyY0V2ZW50VGFyZ2V0O1xuICB9XG4gIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cbiIsImltcG9ydCB7IElOUFVUX1NUQVJULElOUFVUX0VORCxJTlBVVF9DQU5DRUwgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgY29tcHV0ZUlucHV0RGF0YSBmcm9tICcuL2NvbXB1dGUtaW5wdXQtZGF0YSc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGhhbmRsZSBpbnB1dCBldmVudHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlucHV0SGFuZGxlcihtYW5hZ2VyLCBldmVudFR5cGUsIGlucHV0KSB7XG4gIGxldCBwb2ludGVyc0xlbiA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aDtcbiAgbGV0IGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gIGxldCBpc0ZpcnN0ID0gKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuICBsZXQgaXNGaW5hbCA9IChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcblxuICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gIGlmIChpc0ZpcnN0KSB7XG4gICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gIH1cblxuICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAvLyBsaWtlICd0b3VjaHN0YXJ0LCBtb3VzZXVwLCBwb2ludGVyZG93bidcbiAgaW5wdXQuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuXG4gIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KTtcblxuICAvLyBlbWl0IHNlY3JldCBldmVudFxuICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIHNwbGl0IHN0cmluZyBvbiB3aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHdvcmRzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuIiwiaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoJztcbmltcG9ydCBzcGxpdFN0ciBmcm9tICcuL3NwbGl0LXN0cic7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksICh0eXBlKSA9PiB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cbiIsImltcG9ydCBlYWNoIGZyb20gJy4vZWFjaCc7XG5pbXBvcnQgc3BsaXRTdHIgZnJvbSAnLi9zcGxpdC1zdHInO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCAodHlwZSkgPT4ge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICBsZXQgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gIHJldHVybiAoZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcbn1cbiIsImltcG9ydCBib29sT3JGbiBmcm9tICcuLi91dGlscy9ib29sLW9yLWZuJztcbmltcG9ydCBhZGRFdmVudExpc3RlbmVycyBmcm9tICcuLi91dGlscy9hZGQtZXZlbnQtbGlzdGVuZXJzJztcbmltcG9ydCByZW1vdmVFdmVudExpc3RlbmVycyBmcm9tICcuLi91dGlscy9yZW1vdmUtZXZlbnQtbGlzdGVuZXJzJztcbmltcG9ydCBnZXRXaW5kb3dGb3JFbGVtZW50IGZyb20gJy4uL3V0aWxzL2dldC13aW5kb3ctZm9yLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0lucHV0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0IHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5lbGVtZW50ID0gbWFuYWdlci5lbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0ID0gbWFuYWdlci5vcHRpb25zLmlucHV0VGFyZ2V0O1xuXG4gICAgLy8gc21hbGxlciB3cmFwcGVyIGFyb3VuZCB0aGUgaGFuZGxlciwgZm9yIHRoZSBzY29wZSBhbmQgdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIG1hbmFnZXIsXG4gICAgLy8gc28gd2hlbiBkaXNhYmxlZCB0aGUgaW5wdXQgZXZlbnRzIGFyZSBjb21wbGV0ZWx5IGJ5cGFzc2VkLlxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICBpZiAoYm9vbE9yRm4obWFuYWdlci5vcHRpb25zLmVuYWJsZSwgW21hbmFnZXJdKSkge1xuICAgICAgICBzZWxmLmhhbmRsZXIoZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmluaXQoKTtcblxuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuICBoYW5kbGVyKCkgeyB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGJpbmQgdGhlIGV2ZW50c1xuICAgKi9cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIGFkZEV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmV2RWwgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICB9IGVsc2Uge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIGlmICgoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQpIHx8ICghZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkpIHsvLyBkbyBub3QgdXNlID09PSBoZXJlLCB0ZXN0IGZhaWxzXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gICAgSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTCxcbiAgICBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgSU5QVVRfVFlQRV9NT1VTRSxcbiAgICBJTlBVVF9UWVBFX1BFTixcbiAgICBJTlBVVF9UWVBFX0tJTkVDVFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uL2Jyb3dzZXJcIjtcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yJztcbmltcG9ydCBpbkFycmF5IGZyb20gJy4uL3V0aWxzL2luLWFycmF5JztcblxuY29uc3QgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbmNvbnN0IElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gIDM6IElOUFVUX1RZUEVfUEVOLFxuICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbmxldCBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbmxldCBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdNU1BvaW50ZXJEb3duJztcbiAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRlckV2ZW50SW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBwcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IHsgc3RvcmUgfSA9IHRoaXM7XG4gICAgbGV0IHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgIGxldCBldmVudFR5cGVOb3JtYWxpemVkID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ21zJywgJycpO1xuICAgIGxldCBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICBsZXQgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgIGxldCBpc1RvdWNoID0gKHBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgIC8vIGdldCBpbmRleCBvZiB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgbGV0IHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKGV2LmJ1dHRvbiA9PT0gMCB8fCBpc1RvdWNoKSkge1xuICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuXG4gICAgaWYgKHJlbW92ZVBvaW50ZXIpIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgc3RvcmUuc3BsaWNlKHN0b3JlSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogY29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gcmVhbCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaiwgMCk7XG59XG4iLCJpbXBvcnQgaW5BcnJheSBmcm9tICcuL2luLWFycmF5JztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdW5pcXVlIGFycmF5IHdpdGggb2JqZWN0cyBiYXNlZCBvbiBhIGtleSAobGlrZSAnaWQnKSBvciBqdXN0IGJ5IHRoZSBhcnJheSdzIHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5fSBzcmMgW3tpZDoxfSx7aWQ6Mn0se2lkOjF9XVxuICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzb3J0PUZhbHNlXVxuICogQHJldHVybnMge0FycmF5fSBbe2lkOjF9LHtpZDoyfV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5pcXVlQXJyYXkoc3JjLCBrZXksIHNvcnQpIHtcbiAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgbGV0IHZhbHVlcyA9IFtdO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgbGV0IHZhbCA9IGtleSA/IHNyY1tpXVtrZXldIDogc3JjW2ldO1xuICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgIH1cbiAgICB2YWx1ZXNbaV0gPSB2YWw7XG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHJldHVybiBhW2tleV0gPiBiW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsImltcG9ydCB7XG4gIElOUFVUX1NUQVJULFxuICBJTlBVVF9NT1ZFLFxuICBJTlBVVF9FTkQsXG4gIElOUFVUX0NBTkNFTCxcbiAgSU5QVVRfVFlQRV9UT1VDSFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgdG9BcnJheSBmcm9tICcuLi91dGlscy90by1hcnJheSc7XG5pbXBvcnQgaGFzUGFyZW50IGZyb20gJy4uL3V0aWxzL2hhcy1wYXJlbnQnO1xuaW1wb3J0IHVuaXF1ZUFycmF5IGZyb20gJy4uL3V0aWxzL3VuaXF1ZS1hcnJheSc7XG5cbmNvbnN0IFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxuY29uc3QgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoSW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudGFyZ2V0SWRzID0ge307XG4gICAgLy8gdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gIH1cbiAgaGFuZGxlcihldikge1xuICAgIGxldCB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgIGxldCB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIGxldCBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgbGV0IHsgdGFyZ2V0SWRzIH0gPSB0aGlzO1xuXG4gIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG4gIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICB0YXJnZXRJZHNbYWxsVG91Y2hlc1swXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgdGFyZ2V0VG91Y2hlcztcbiAgbGV0IGNoYW5nZWRUb3VjaGVzID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG4gIGxldCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdO1xuICBsZXQgeyB0YXJnZXQgfSA9IHRoaXM7XG5cbiAgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoKHRvdWNoKSA9PiB7XG4gICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gIH0pO1xuXG4gIC8vIGNvbGxlY3QgdG91Y2hlc1xuICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICBpID0gMDtcbiAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICB1bmlxdWVBcnJheSh0YXJnZXRUb3VjaGVzLmNvbmNhdChjaGFuZ2VkVGFyZ2V0VG91Y2hlcyksICdpZGVudGlmaWVyJywgdHJ1ZSksXG4gICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgXTtcbn1cbiIsImltcG9ydCB7XG4gICAgSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQsXG4gICAgSU5QVVRfVFlQRV9NT1VTRVxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3Rvcic7XG5cbmNvbnN0IE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgbW91c2Vkb3duOiBJTlBVVF9TVEFSVCxcbiAgbW91c2Vtb3ZlOiBJTlBVVF9NT1ZFLFxuICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbmNvbnN0IE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG5jb25zdCBNT1VTRV9XSU5ET1dfRVZFTlRTID0gJ21vdXNlbW92ZSBtb3VzZXVwJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vdXNlSW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBwcm90byA9IE1vdXNlSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2RWwgPSBNT1VTRV9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IE1PVVNFX1dJTkRPV19FVkVOVFM7XG5cbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgaGFuZGxlcihldikge1xuICAgIGxldCBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgfVxuXG4gICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBJbnB1dCBmcm9tIFwiLi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IFRvdWNoSW5wdXQgZnJvbSBcIi4vdG91Y2hcIjtcbmltcG9ydCBNb3VzZUlucHV0IGZyb20gXCIuL21vdXNlXCI7XG5pbXBvcnQge1xuXHRJTlBVVF9TVEFSVCxcblx0SU5QVVRfRU5ELFxuXHRJTlBVVF9DQU5DRUwsXG5cdElOUFVUX1RZUEVfVE9VQ0gsXG5cdElOUFVUX1RZUEVfTU9VU0UsXG59IGZyb20gXCIuLi9pbnB1dGpzL2lucHV0LWNvbnN0c1wiO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBDb21iaW5lZCB0b3VjaCBhbmQgbW91c2UgaW5wdXRcbiAqXG4gKiBUb3VjaCBoYXMgYSBoaWdoZXIgcHJpb3JpdHkgdGhlbiBtb3VzZSwgYW5kIHdoaWxlIHRvdWNoaW5nIG5vIG1vdXNlIGV2ZW50cyBhcmUgYWxsb3dlZC5cbiAqIFRoaXMgYmVjYXVzZSB0b3VjaCBkZXZpY2VzIGFsc28gZW1pdCBtb3VzZSBldmVudHMgd2hpbGUgZG9pbmcgYSB0b3VjaC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxuY29uc3QgREVEVVBfVElNRU9VVCA9IDI1MDA7XG5jb25zdCBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG5cdGNvbnN0IHsgY2hhbmdlZFBvaW50ZXJzOiBbdG91Y2hdIH0gPSBldmVudERhdGE7XG5cblx0aWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG5cdFx0Y29uc3QgbGFzdFRvdWNoID0geyB4OiB0b3VjaC5jbGllbnRYLCB5OiB0b3VjaC5jbGllbnRZIH07XG5cdFx0Y29uc3QgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcblxuXHRcdHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuXG5cblx0XHRjb25zdCByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuXG5cdFx0XHRpZiAoaSA+IC0xKSB7XG5cdFx0XHRcdGx0cy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcblx0aWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG5cdFx0dGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG5cdFx0c2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcblx0fSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuXHRcdHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG5cdH1cbn1cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG5cdGNvbnN0IHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WDtcblx0Y29uc3QgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuXHRcdGNvbnN0IGR4ID0gTWF0aC5hYnMoeCAtIHQueCk7XG5cdFx0Y29uc3QgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcblxuXHRcdGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3VjaE1vdXNlSW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG5cdGNvbnN0cnVjdG9yKG1hbmFnZXIsIGNhbGxiYWNrKSB7XG5cdFx0c3VwZXIobWFuYWdlciwgY2FsbGJhY2spO1xuXG5cdFx0dGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgdGhpcy5oYW5kbGVyKTtcblx0XHR0aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQodGhpcy5tYW5hZ2VyLCB0aGlzLmhhbmRsZXIpO1xuXHRcdHRoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcblx0XHR0aGlzLmxhc3RUb3VjaGVzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogaGFuZGxlIG1vdXNlIGFuZCB0b3VjaCBldmVudHNcblx0ICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuXHQgKi9cblx0aGFuZGxlciA9IChtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpID0+IHtcblx0XHRjb25zdCBpc1RvdWNoID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cdFx0Y29uc3QgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfTU9VU0UpO1xuXG5cdFx0aWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuXHRcdGlmIChpc1RvdWNoKSB7XG5cdFx0XHRyZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcblx0ICovXG5cdGRlc3Ryb3koKSB7XG5cdFx0dGhpcy50b3VjaC5kZXN0cm95KCk7XG5cdFx0dGhpcy5tb3VzZS5kZXN0cm95KCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMsU1VQUE9SVF9PTkxZX1RPVUNILFNVUFBPUlRfVE9VQ0ggfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgaW5wdXRIYW5kbGVyIGZyb20gJy4vaW5wdXQtaGFuZGxlcic7XG5pbXBvcnQgUG9pbnRlckV2ZW50SW5wdXQgZnJvbSAnLi4vaW5wdXQvcG9pbnRlcmV2ZW50JztcbmltcG9ydCBUb3VjaElucHV0IGZyb20gJy4uL2lucHV0L3RvdWNoJztcbmltcG9ydCBNb3VzZUlucHV0IGZyb20gJy4uL2lucHV0L21vdXNlJztcbmltcG9ydCBUb3VjaE1vdXNlSW5wdXQgZnJvbSAnLi4vaW5wdXQvdG91Y2htb3VzZSc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUlucHV0SW5zdGFuY2UobWFuYWdlcikge1xuICBsZXQgVHlwZTtcbiAgLy8gbGV0IGlucHV0Q2xhc3MgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRDbGFzcztcbiAgbGV0IHsgb3B0aW9uczp7IGlucHV0Q2xhc3MgfSB9ID0gbWFuYWdlcjtcbiAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgfVxuICByZXR1cm4gbmV3IChUeXBlKShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuIiwiaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgd2Ugd2FudCB0byBleGVjdXRlIHRoZSBmbiBvbiBlYWNoIGVudHJ5XG4gKiBpZiBpdCBhaW50IGFuIGFycmF5IHdlIGRvbid0IHdhbnQgdG8gZG8gYSB0aGluZy5cbiAqIHRoaXMgaXMgdXNlZCBieSBhbGwgdGhlIG1ldGhvZHMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYW5kIGFycmF5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfEFycmF5fSBhcmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiY29uc3QgU1RBVEVfUE9TU0lCTEUgPSAxO1xuY29uc3QgU1RBVEVfQkVHQU4gPSAyO1xuY29uc3QgU1RBVEVfQ0hBTkdFRCA9IDQ7XG5jb25zdCBTVEFURV9FTkRFRCA9IDg7XG5jb25zdCBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG5jb25zdCBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbmNvbnN0IFNUQVRFX0ZBSUxFRCA9IDMyO1xuXG5leHBvcnQge1xuICAgIFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEXG59O1xuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdW5pcXVlIGlkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB1bmlxdWVJZFxuICovXG5sZXQgX3VuaXF1ZUlkID0gMTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gIGxldCB7IG1hbmFnZXIgfSA9IHJlY29nbml6ZXI7XG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gIH1cbiAgcmV0dXJuIG90aGVyUmVjb2duaXplcjtcbn1cbiIsImltcG9ydCB7XG4gICAgU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0VOREVELFxuICAgIFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfQkVHQU5cbn0gZnJvbSAnLi9yZWNvZ25pemVyLWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtjb25zdGFudH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgIHJldHVybiAnY2FuY2VsJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgIHJldHVybiAnbW92ZSc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cbiIsImltcG9ydCB7XG4gICAgU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfRkFJTEVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRURcbn0gZnJvbSAnLi9yZWNvZ25pemVyLWNvbnN0cyc7XG5pbXBvcnQgYXNzaWduIGZyb20gJy4uL3V0aWxzL2Fzc2lnbic7XG5pbXBvcnQgdW5pcXVlSWQgZnJvbSAnLi4vdXRpbHMvdW5pcXVlLWlkJztcbmltcG9ydCBpbnZva2VBcnJheUFyZyBmcm9tICcuLi91dGlscy9pbnZva2UtYXJyYXktYXJnJztcbmltcG9ydCBpbkFycmF5IGZyb20gJy4uL3V0aWxzL2luLWFycmF5JztcbmltcG9ydCBib29sT3JGbiBmcm9tICcuLi91dGlscy9ib29sLW9yLWZuJztcbmltcG9ydCBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyIGZyb20gJy4vZ2V0LXJlY29nbml6ZXItYnktbmFtZS1pZi1tYW5hZ2VyJztcbmltcG9ydCBzdGF0ZVN0ciBmcm9tICcuL3N0YXRlLXN0cic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXIgZmxvdyBleHBsYWluZWQ7ICpcbiAqIEFsbCByZWNvZ25pemVycyBoYXZlIHRoZSBpbml0aWFsIHN0YXRlIG9mIFBPU1NJQkxFIHdoZW4gYSBpbnB1dCBzZXNzaW9uIHN0YXJ0cy5cbiAqIFRoZSBkZWZpbml0aW9uIG9mIGEgaW5wdXQgc2Vzc2lvbiBpcyBmcm9tIHRoZSBmaXJzdCBpbnB1dCB1bnRpbCB0aGUgbGFzdCBpbnB1dCwgd2l0aCBhbGwgaXQncyBtb3ZlbWVudCBpbiBpdC4gKlxuICogRXhhbXBsZSBzZXNzaW9uIGZvciBtb3VzZS1pbnB1dDogbW91c2Vkb3duIC0+IG1vdXNlbW92ZSAtPiBtb3VzZXVwXG4gKlxuICogT24gZWFjaCByZWNvZ25pemluZyBjeWNsZSAoc2VlIE1hbmFnZXIucmVjb2duaXplKSB0aGUgLnJlY29nbml6ZSgpIG1ldGhvZCBpcyBleGVjdXRlZFxuICogd2hpY2ggZGV0ZXJtaW5lcyB3aXRoIHN0YXRlIGl0IHNob3VsZCBiZS5cbiAqXG4gKiBJZiB0aGUgcmVjb2duaXplciBoYXMgdGhlIHN0YXRlIEZBSUxFRCwgQ0FOQ0VMTEVEIG9yIFJFQ09HTklaRUQgKGVxdWFscyBFTkRFRCksIGl0IGlzIHJlc2V0IHRvXG4gKiBQT1NTSUJMRSB0byBnaXZlIGl0IGFub3RoZXIgY2hhbmdlIG9uIHRoZSBuZXh0IGN5Y2xlLlxuICpcbiAqICAgICAgICAgICAgICAgUG9zc2libGVcbiAqICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICArLS0tLS0rLS0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICArLS0tLS0rLS0tLS0rICAgICAgICAgICAgICAgfFxuICogICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICogICBGYWlsZWQgICAgICBDYW5jZWxsZWQgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tKy0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICBSZWNvZ25pemVkICAgICAgIEJlZ2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoYW5nZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbmRlZC9SZWNvZ25pemVkXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplclxuICogRXZlcnkgcmVjb2duaXplciBuZWVkcyB0byBleHRlbmQgZnJvbSB0aGlzIGNsYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgKi9cbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG4gIHJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IHsgc2ltdWx0YW5lb3VzIH0gPSB0aGlzO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSBzaW11bHRhbmVvdXMgbGluay4gaXQgZG9lc250IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG4gIGRyb3BSZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgZGVsZXRlIHRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplciBjYW4gb25seSBydW4gd2hlbiBhbiBvdGhlciBpcyBmYWlsaW5nXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuICByZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IHsgcmVxdWlyZUZhaWwgfSA9IHRoaXM7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuICBkcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgbGV0IGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlcXVpcmVGYWlsLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNSZXF1aXJlRmFpbHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBpZiB0aGUgcmVjb2duaXplciBjYW4gcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjYW5SZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIHJldHVybiAhIXRoaXMuc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgZW1pdChpbnB1dCkge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIHNlbGYubWFuYWdlci5lbWl0KGV2ZW50LCBpbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gJ3BhbnN0YXJ0JyBhbmQgJ3Bhbm1vdmUnXG4gICAgaWYgKHN0YXRlIDwgU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG5cbiAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCk7IC8vIHNpbXBsZSAnZXZlbnROYW1lJyBldmVudHNcblxuICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHsgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgfVxuXG4gICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmUgZmFpbHVyZSByZWNvZ25pemVycyBoYXMgZmFpbGVkLFxuICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICB0cnlFbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuY2FuRW1pdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICB9XG4gICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FuIHdlIGVtaXQ/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuRW1pdCgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCkge1xuICAgICAgaWYgKCEodGhpcy5yZXF1aXJlRmFpbFtpXS5zdGF0ZSAmIChTVEFURV9GQUlMRUQgfCBTVEFURV9QT1NTSUJMRSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdXBkYXRlIHRoZSByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICovXG4gIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgbGV0IGlucHV0RGF0YUNsb25lID0gYXNzaWduKHt9LCBpbnB1dERhdGEpO1xuXG4gICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgaWYgKCFib29sT3JGbih0aGlzLm9wdGlvbnMuZW5hYmxlLCBbdGhpcywgaW5wdXREYXRhQ2xvbmVdKSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX1JFQ09HTklaRUQgfCBTVEFURV9DQU5DRUxMRUQgfCBTVEFURV9GQUlMRUQpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSByZWNvZ25pemVyXG4gICAqIHRoZSBhY3R1YWwgcmVjb2duaXppbmcgaGFwcGVucyBpbiB0aGlzIG1ldGhvZFxuICAgKiBAdmlydHVhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqIEByZXR1cm5zIHtjb25zdGFudH0gU1RBVEVcbiAgICovXG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBwcm9jZXNzKGlucHV0RGF0YSkgeyB9XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgcHJlZmVycmVkIHRvdWNoLWFjdGlvblxuICAgKiBAdmlydHVhbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRUb3VjaEFjdGlvbigpIHsgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuICByZXNldCgpIHsgfVxufSIsImltcG9ydCBSZWNvZ25pemVyIGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gfSBmcm9tICcuLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQge0lOUFVUX1NUQVJULElOUFVUX0VORCB9IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCB7XG4gICAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9CRUdBTixcbiAgICBTVEFURV9GQUlMRURcbn0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcbmltcG9ydCBnZXREaXN0YW5jZSBmcm9tICcuLi9pbnB1dGpzL2dldC1kaXN0YW5jZSc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEEgdGFwIGlzIHJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYXBSZWNvZ25pemVyIGV4dGVuZHMgUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGFwczogMSxcbiAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICB0aW1lOiAyNTAsIC8vIG1heCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIGRvd24gKGxpa2UgZmluZ2VyIG9uIHRoZSBzY3JlZW4pXG4gICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICBwb3NUaHJlc2hvbGQ6IDEwLCAvLyBhIG11bHRpLXRhcCBjYW4gYmUgYSBiaXQgb2ZmIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgLy8gcHJldmlvdXMgdGltZSBhbmQgY2VudGVyLFxuICAgIC8vIHVzZWQgZm9yIHRhcCBjb3VudGluZ1xuICAgIHRoaXMucFRpbWUgPSBmYWxzZTtcbiAgICB0aGlzLnBDZW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICB9XG5cbiAgcHJvY2VzcyhpbnB1dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXM7XG5cbiAgICBsZXQgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICBsZXQgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgbGV0IHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuXG4gICAgaWYgKChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkgJiYgKHRoaXMuY291bnQgPT09IDApKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgIH1cblxuICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgIGxldCB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAvLyBpZiB0YXAgY291bnQgbWF0Y2hlcyB3ZSBoYXZlIHJlY29nbml6ZWQgaXQsXG4gICAgICAvLyBlbHNlIGl0IGhhcyBiZWdhbiByZWNvZ25pemluZy4uLlxuICAgICAgbGV0IHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfVxuXG4gIGZhaWxUaW1lb3V0KCkge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH1cblxuICBlbWl0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBSZWNvZ25pemVyIGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7XG4gICAgU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfRkFJTEVEXG59IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5pbXBvcnQge1xuICAgIElOUFVUX0NBTkNFTCxcbiAgICBJTlBVVF9FTkRcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0clJlY29nbml6ZXIgZXh0ZW5kcyBSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgKi9cbiAgYXR0clRlc3QoaW5wdXQpIHtcbiAgICBsZXQgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogUHJvY2VzcyB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMgeyp9IFN0YXRlXG4gICAqL1xuICBwcm9jZXNzKGlucHV0KSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRoaXM7XG4gICAgbGV0IHsgZXZlbnRUeXBlIH0gPSBpbnB1dDtcblxuICAgIGxldCBpc1JlY29nbml6ZWQgPSBzdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQpO1xuICAgIGxldCBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICB9XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgICBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQsXG4gICAgRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge2NvbnN0YW50fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpcmVjdGlvblN0cihkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICByZXR1cm4gJ2Rvd24nO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1VQKSB7XG4gICAgcmV0dXJuICd1cCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICByZXR1cm4gJ3JpZ2h0JztcbiAgfVxuICByZXR1cm4gJyc7XG59XG4iLCJpbXBvcnQgIEF0dHJSZWNvZ25pemVyIGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7XG4gICAgRElSRUNUSU9OX0FMTCxcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOLFxuICAgIERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgeyBTVEFURV9CRUdBTiB9IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5pbXBvcnQgeyBUT1VDSF9BQ1RJT05fUEFOX1gsVE9VQ0hfQUNUSU9OX1BBTl9ZIH0gZnJvbSAnLi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IGRpcmVjdGlvblN0ciBmcm9tICcuLi9yZWNvZ25pemVyanMvZGlyZWN0aW9uLXN0cic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBhblxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gYW5kIG1vdmVkIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFuUmVjb2duaXplciBleHRlbmRzIEF0dHJSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgICB0aGlzLnBYID0gbnVsbDtcbiAgICB0aGlzLnBZID0gbnVsbDtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIGxldCB7IG9wdGlvbnM6eyBkaXJlY3Rpb24gfSB9ID0gdGhpcztcbiAgICBsZXQgYWN0aW9ucyA9IFtdO1xuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfVxuXG4gIGRpcmVjdGlvblRlc3QoaW5wdXQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGxldCBoYXNNb3ZlZCA9IHRydWU7XG4gICAgbGV0IHsgZGlzdGFuY2UgfSA9IGlucHV0O1xuICAgIGxldCB7IGRpcmVjdGlvbiB9ID0gaW5wdXQ7XG4gICAgbGV0IHggPSBpbnB1dC5kZWx0YVg7XG4gICAgbGV0IHkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAvLyBsb2NrIHRvIGF4aXM/XG4gICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBkaXJlY3Rpb24gPSAoeCA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh4IDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgaGFzTW92ZWQgPSB4ICE9PSB0aGlzLnBYO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSAoeSA9PT0gMCkgPyBESVJFQ1RJT05fTk9ORSA6ICh5IDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgaGFzTW92ZWQgPSB5ICE9PSB0aGlzLnBZO1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKGlucHV0LmRlbHRhWSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgfVxuXG4gIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAvLyByZXBsYWNlIHdpdGggYSBzdXBlciBjYWxsXG4gICAgICAgICh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4gfHwgKCEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKSk7XG4gIH1cblxuICBlbWl0KGlucHV0KSB7XG5cbiAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICBsZXQgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0LmRpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgfVxuICAgIHN1cGVyLmVtaXQoaW5wdXQpO1xuICB9XG59XG4iLCJpbXBvcnQgQXR0clJlY29nbml6ZXIgZnJvbSAnLi4vcmVjb2duaXplcnMvYXR0cmlidXRlJztcbmltcG9ydCB7IGFicyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgeyBESVJFQ1RJT05fSE9SSVpPTlRBTCxESVJFQ1RJT05fVkVSVElDQUwgfSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgUGFuUmVjb2duaXplciBmcm9tICcuL3Bhbic7XG5pbXBvcnQgeyBJTlBVVF9FTkQgfSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgZGlyZWN0aW9uU3RyIGZyb20gJy4uL3JlY29nbml6ZXJqcy9kaXJlY3Rpb24tc3RyJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXBlUmVjb2duaXplciBleHRlbmRzIEF0dHJSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXZlbnQ6ICdzd2lwZScsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgdmVsb2NpdHk6IDAuMyxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgfVxuXG4gIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgbGV0IHsgZGlyZWN0aW9uIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgbGV0IHZlbG9jaXR5O1xuXG4gICAgaWYgKGRpcmVjdGlvbiAmIChESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlZO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5hdHRyVGVzdChpbnB1dCkgJiZcbiAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgIGlucHV0LmRpc3RhbmNlID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAmJlxuICAgICAgICBpbnB1dC5tYXhQb2ludGVycyA9PT0gdGhpcy5vcHRpb25zLnBvaW50ZXJzICYmXG4gICAgICAgIGFicyh2ZWxvY2l0eSkgPiB0aGlzLm9wdGlvbnMudmVsb2NpdHkgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EO1xuICB9XG5cbiAgZW1pdChpbnB1dCkge1xuICAgIGxldCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgfVxufVxuIiwiaW1wb3J0IEF0dHJSZWNvZ25pemVyIGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7IFRPVUNIX0FDVElPTl9OT05FIH0gZnJvbSAnLi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IHsgU1RBVEVfQkVHQU4gfSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQaW5jaFxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaW5jaFJlY29nbml6ZXIgZXh0ZW5kcyBBdHRyUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH1cblxuICBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBzdXBlci5hdHRyVGVzdChpbnB1dCkgJiZcbiAgICAgICAgKE1hdGguYWJzKGlucHV0LnNjYWxlIC0gMSkgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH1cblxuICBlbWl0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnNjYWxlICE9PSAxKSB7XG4gICAgICBsZXQgaW5PdXQgPSBpbnB1dC5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCc7XG4gICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICB9XG4gICAgc3VwZXIuZW1pdChpbnB1dCk7XG4gIH1cbn1cbiIsImltcG9ydCBBdHRyUmVjb2duaXplciBmcm9tICcuL2F0dHJpYnV0ZSc7XG5pbXBvcnQgeyBUT1VDSF9BQ1RJT05fTk9ORSB9IGZyb20gJy4uL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCB7IFNUQVRFX0JFR0FOIH0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUm90YXRlXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlciBhcmUgbW92aW5nIGluIGEgY2lyY3VsYXIgbW90aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3RhdGVSZWNvZ25pemVyIGV4dGVuZHMgQXR0clJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigge1xuICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcG9pbnRlcnM6IDIsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH1cblxuICBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBzdXBlci5hdHRyVGVzdChpbnB1dCkgJiZcbiAgICAgICAgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfVxufSIsImltcG9ydCBSZWNvZ25pemVyIGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7XG4gICAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9GQUlMRURcbn0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcbmltcG9ydCB7IG5vdyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgeyBUT1VDSF9BQ1RJT05fQVVUTyB9IGZyb20gJy4uL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCB7XG4gICAgSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFByZXNzXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBmb3IgeCBtcyB3aXRob3V0IGFueSBtb3ZlbWVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzc1JlY29nbml6ZXIgZXh0ZW5kcyBSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSwgLy8gbWluaW1hbCB0aW1lIG9mIHRoZSBwb2ludGVyIHRvIGJlIHByZXNzZWRcbiAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICB9XG5cbiAgcHJvY2VzcyhpbnB1dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgbGV0IHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgbGV0IHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIGxldCB2YWxpZFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPiBvcHRpb25zLnRpbWU7XG5cbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB0aGlzLnRyeUVtaXQoKTtcbiAgICAgIH0sIG9wdGlvbnMudGltZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgIH1cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuXG4gIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYCR7dGhpcy5vcHRpb25zLmV2ZW50fXVwYCwgaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfVxufVxuXG4iLCJpbXBvcnQgeyBUT1VDSF9BQ1RJT05fQ09NUFVURSB9IGZyb20gXCIuL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzXCI7XG5pbXBvcnQgVGFwUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy90YXBcIjtcbmltcG9ydCBQYW5SZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BhblwiO1xuaW1wb3J0IFN3aXBlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9zd2lwZVwiO1xuaW1wb3J0IFBpbmNoUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9waW5jaFwiO1xuaW1wb3J0IFJvdGF0ZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcm90YXRlXCI7XG5pbXBvcnQgUHJlc3NSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3ByZXNzXCI7XG5pbXBvcnQge0RJUkVDVElPTl9IT1JJWk9OVEFMfSBmcm9tIFwiLi9pbnB1dGpzL2lucHV0LWNvbnN0c1wiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuXHQgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdGRvbUV2ZW50czogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuXHQgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY29tcHV0ZVxuXHQgKi9cblx0dG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgdHJ1ZVxuXHQgKi9cblx0ZW5hYmxlOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG5cdCAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuXHQgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuXHQgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cblx0ICogQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0aW5wdXRUYXJnZXQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG5cdCAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRpbnB1dENsYXNzOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuXHQgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG5cdCAqIEBuYW1lc3BhY2Vcblx0ICovXG5cdGNzc1Byb3BzOiB7XG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAnbm9uZSdcblx0XHQgKi9cblx0XHR1c2VyU2VsZWN0OiBcIm5vbmVcIixcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAnbm9uZSdcblx0XHQgKi9cblx0XHR0b3VjaFNlbGVjdDogXCJub25lXCIsXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG5cdFx0ICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG5cdFx0ICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xuXHRcdCAqL1xuXHRcdHRvdWNoQ2FsbG91dDogXCJub25lXCIsXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXG5cdFx0ICovXG5cdFx0Y29udGVudFpvb21pbmc6IFwibm9uZVwiLFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAnbm9uZSdcblx0XHQgKi9cblx0XHR1c2VyRHJhZzogXCJub25lXCIsXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG5cdFx0ICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG5cdFx0ICovXG5cdFx0dGFwSGlnaGxpZ2h0Q29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuXHR9LFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gKiBXaGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIgdGhlc2Ugd2lsbCBiZSBza2lwcGVkLlxuICogVGhpcyBpcyBzZXBhcmF0ZWQgd2l0aCBvdGhlciBkZWZhdWx0cyBiZWNhdXNlIG9mIHRyZWUtc2hha2luZy5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHByZXNldCA9IFtcbiAgW1JvdGF0ZVJlY29nbml6ZXIsIHsgZW5hYmxlOiBmYWxzZSB9XSxcbiAgW1BpbmNoUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH0sIFsncm90YXRlJ11dLFxuICBbU3dpcGVSZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfV0sXG4gIFtQYW5SZWNvZ25pemVyLCB7IGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUwgfSwgWydzd2lwZSddXSxcbiAgW1RhcFJlY29nbml6ZXJdLFxuICBbVGFwUmVjb2duaXplciwgeyBldmVudDogJ2RvdWJsZXRhcCcsIHRhcHM6IDIgfSwgWyd0YXAnXV0sXG4gIFtQcmVzc1JlY29nbml6ZXJdXG5dO1xuIiwiaW1wb3J0IGFzc2lnbiBmcm9tIFwiLi91dGlscy9hc3NpZ25cIjtcbmltcG9ydCBUb3VjaEFjdGlvbiBmcm9tIFwiLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgY3JlYXRlSW5wdXRJbnN0YW5jZSBmcm9tIFwiLi9pbnB1dGpzL2NyZWF0ZS1pbnB1dC1pbnN0YW5jZVwiO1xuaW1wb3J0IGVhY2ggZnJvbSBcIi4vdXRpbHMvZWFjaFwiO1xuaW1wb3J0IGluQXJyYXkgZnJvbSBcIi4vdXRpbHMvaW4tYXJyYXlcIjtcbmltcG9ydCBpbnZva2VBcnJheUFyZyBmcm9tIFwiLi91dGlscy9pbnZva2UtYXJyYXktYXJnXCI7XG5pbXBvcnQgc3BsaXRTdHIgZnJvbSBcIi4vdXRpbHMvc3BsaXQtc3RyXCI7XG5pbXBvcnQgcHJlZml4ZWQgZnJvbSBcIi4vdXRpbHMvcHJlZml4ZWRcIjtcbmltcG9ydCBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQge1xuICBTVEFURV9CRUdBTixcbiAgU1RBVEVfRU5ERUQsXG4gIFNUQVRFX0NIQU5HRUQsXG4gIFNUQVRFX1JFQ09HTklaRUQsXG59IGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0c1wiO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gXCIuL2RlZmF1bHRzXCI7XG5cbmNvbnN0IFNUT1AgPSAxO1xuY29uc3QgRk9SQ0VEX1NUT1AgPSAyO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGFkZC9yZW1vdmUgdGhlIGNzcyBwcm9wZXJ0aWVzIGFzIGRlZmluZWQgaW4gbWFuYWdlci5vcHRpb25zLmNzc1Byb3BzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICBjb25zdCB7IGVsZW1lbnQgfSA9IG1hbmFnZXI7XG5cbiAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBwcm9wO1xuXG4gIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgaWYgKGFkZCkge1xuICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8IFwiXCI7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFhZGQpIHtcbiAgICBtYW5hZ2VyLm9sZENzc1Byb3BzID0ge307XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdHJpZ2dlciBkb20gZXZlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIGNvbnN0IGdlc3R1cmVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG5cbiAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gIGdlc3R1cmVFdmVudC5nZXN0dXJlID0gZGF0YTtcbiAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5cbi8qKlxuKiBAcHJpdmF0ZVxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBpdGVtID0+IHtcbiAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcblxuICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogc2V0IG9wdGlvbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHJldHVybnMge01hbmFnZXJ9XG5cdCAqL1xuICBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cblx0ICogVGhpcyBzZXNzaW9uIHdpbGwgYmUgZGlzY2FyZGVkLCB3aGVuIGEgbmV3IFtpbnB1dF1zdGFydCBldmVudCBpcyBmaXJlZC5cblx0ICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuXHQgKi9cbiAgc3RvcChmb3JjZSkge1xuICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogcnVuIHRoZSByZWNvZ25pemVycyFcblx0ICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuXHQgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuXHQgKi9cbiAgcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIGNvbnN0IHsgc2Vzc2lvbiB9ID0gdGhpcztcblxuICAgIGlmIChzZXNzaW9uLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgIHRoaXMudG91Y2hBY3Rpb24ucHJldmVudERlZmF1bHRzKGlucHV0RGF0YSk7XG5cbiAgICBsZXQgcmVjb2duaXplcjtcbiAgICBjb25zdCB7IHJlY29nbml6ZXJzIH0gPSB0aGlzO1xuXG4gICAgLy8gdGhpcyBob2xkcyB0aGUgcmVjb2duaXplciB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICBsZXQgeyBjdXJSZWNvZ25pemVyIH0gPSBzZXNzaW9uO1xuXG4gICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cbiAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICgvLyAxXG4gICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBnZXQgYSByZWNvZ25pemVyIGJ5IGl0cyBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG5cdCAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG5cdCAqL1xuICBnZXQocmVjb2duaXplcikge1xuICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZWNvZ25pemVycyB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGUgYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuXHQgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG5cdCAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuXHQgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuXHQgKi9cbiAgYWRkKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJhZGRcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBleGlzdGluZ1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcblxuICAgIGlmIChleGlzdGluZykge1xuICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgIH1cblxuICAgIHRoaXMucmVjb2duaXplcnMucHVzaChyZWNvZ25pemVyKTtcbiAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2Vcblx0ICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuXHQgKiBAcmV0dXJucyB7TWFuYWdlcn1cblx0ICovXG4gIHJlbW92ZShyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRSZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICBjb25zdCB7IHJlY29nbml6ZXJzIH0gPSB0aGlzO1xuICAgICAgY29uc3QgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIGJpbmQgZXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcblx0ICovXG4gIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaGFuZGxlcnMgfSA9IHRoaXM7XG5cbiAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGV2ZW50ID0+IHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlIHVuYmluZCBldmVudCwgbGVhdmUgZW1pdCBibGFuayB0byByZW1vdmUgYWxsIGhhbmRsZXJzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IHRoaXNcblx0ICovXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaGFuZGxlcnMgfSA9IHRoaXM7XG5cbiAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGV2ZW50ID0+IHtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBkZWxldGUgaGFuZGxlcnNbZXZlbnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqL1xuICBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIG5vIGhhbmRsZXJzLCBzbyBza2lwIGl0IGFsbFxuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcblxuICAgIGlmICghaGFuZGxlcnMgfHwgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRhdGEudHlwZSA9IGV2ZW50O1xuICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG5cdCAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG5cdCAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgICBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUwsXG4gICAgSU5QVVRfVFlQRV9UT1VDSFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgdG9BcnJheSBmcm9tICcuLi91dGlscy90by1hcnJheSc7XG5pbXBvcnQgdW5pcXVlQXJyYXkgZnJvbSAnLi4vdXRpbHMvdW5pcXVlLWFycmF5JztcblxuY29uc3QgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gIHRvdWNobW92ZTogSU5QVVRfTU9WRSxcbiAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxuY29uc3QgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG5jb25zdCBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW5nbGVUb3VjaElucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvdG8gPSBTaW5nbGVUb3VjaElucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldlRhcmdldCA9IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG5cbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlcihldikge1xuICAgIGxldCB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gIGxldCBhbGwgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICBsZXQgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIFthbGwsIGNoYW5nZWRdO1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgbGV0IGRlcHJlY2F0aW9uTWVzc2FnZSA9IGBERVBSRUNBVEVEIE1FVEhPRDogJHtuYW1lfVxcbiR7bWVzc2FnZX0gQVQgXFxuYDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGxldCBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICBsZXQgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxzK2F0XFxzKy9nbSwgJycpXG4gICAgICAgIC5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG5cbiAgICBsZXQgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICBpZiAobG9nKSB7XG4gICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBkZXByZWNhdGUgZnJvbSAnLi9kZXByZWNhdGUnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXVxuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5jb25zdCBleHRlbmQgPSBkZXByZWNhdGUoKGRlc3QsIHNyYywgbWVyZ2UpID0+IHtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhzcmMpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICBpZiAoIW1lcmdlIHx8IChtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpKSB7XG4gICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuZXhwb3J0IGRlZmF1bHQgZXh0ZW5kO1xuIiwiaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuL2RlcHJlY2F0ZSc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vZXh0ZW5kJztcbi8qKlxuICogQHByaXZhdGVcbiAqIG1lcmdlIHRoZSB2YWx1ZXMgZnJvbSBzcmMgaW4gdGhlIGRlc3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBkZXN0IHdpbGwgbm90IGJlIG92ZXJ3cml0dGVuIGJ5IHNyY1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuY29uc3QgbWVyZ2UgPSBkZXByZWNhdGUoKGRlc3QsIHNyYykgPT4ge1xuICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTtcbiIsImltcG9ydCBhc3NpZ24gZnJvbSAnLi9hc3NpZ24nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmhlcml0KGNoaWxkLCBiYXNlLCBwcm9wZXJ0aWVzKSB7XG4gIGxldCBiYXNlUCA9IGJhc2UucHJvdG90eXBlO1xuICBsZXQgY2hpbGRQO1xuXG4gIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gIH1cbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZEZuKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiaW1wb3J0IE1hbmFnZXIgZnJvbSBcIi4vbWFuYWdlclwiO1xuaW1wb3J0IGRlZmF1bHRzLCB7IHByZXNldCB9IGZyb20gXCIuL2RlZmF1bHRzXCI7XG5pbXBvcnQgYXNzaWduIGZyb20gJy4vdXRpbHMvYXNzaWduJztcbmltcG9ydCB7XG4gIElOUFVUX1NUQVJULFxuICBJTlBVVF9NT1ZFLFxuICBJTlBVVF9FTkQsXG4gIElOUFVUX0NBTkNFTCxcbiAgRElSRUNUSU9OX05PTkUsXG4gIERJUkVDVElPTl9MRUZULFxuICBESVJFQ1RJT05fUklHSFQsXG4gIERJUkVDVElPTl9VUCxcbiAgRElSRUNUSU9OX0RPV04sXG4gIERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICBESVJFQ1RJT05fVkVSVElDQUwsXG4gIERJUkVDVElPTl9BTEwsXG59IGZyb20gXCIuL2lucHV0anMvaW5wdXQtY29uc3RzXCI7XG5pbXBvcnQge1xuICBTVEFURV9QT1NTSUJMRSxcbiAgU1RBVEVfQkVHQU4sXG4gIFNUQVRFX0NIQU5HRUQsXG4gIFNUQVRFX0VOREVELFxuICBTVEFURV9SRUNPR05JWkVELFxuICBTVEFURV9DQU5DRUxMRUQsXG4gIFNUQVRFX0ZBSUxFRCxcbn0gZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzXCI7XG5cbmltcG9ydCBJbnB1dCBmcm9tIFwiLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgVG91Y2hBY3Rpb24gZnJvbSBcIi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IFRvdWNoSW5wdXQgZnJvbSBcIi4vaW5wdXQvdG91Y2hcIjtcbmltcG9ydCBNb3VzZUlucHV0IGZyb20gXCIuL2lucHV0L21vdXNlXCI7XG5pbXBvcnQgUG9pbnRlckV2ZW50SW5wdXQgZnJvbSBcIi4vaW5wdXQvcG9pbnRlcmV2ZW50XCI7XG5pbXBvcnQgU2luZ2xlVG91Y2hJbnB1dCBmcm9tIFwiLi9pbnB1dC9zaW5nbGV0b3VjaFwiO1xuaW1wb3J0IFRvdWNoTW91c2VJbnB1dCBmcm9tIFwiLi9pbnB1dC90b3VjaG1vdXNlXCI7XG5cbmltcG9ydCBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgQXR0clJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvYXR0cmlidXRlXCI7XG5pbXBvcnQgVGFwUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy90YXBcIjtcbmltcG9ydCBQYW5SZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BhblwiO1xuaW1wb3J0IFN3aXBlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9zd2lwZVwiO1xuaW1wb3J0IFBpbmNoUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9waW5jaFwiO1xuaW1wb3J0IFJvdGF0ZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcm90YXRlXCI7XG5pbXBvcnQgUHJlc3NSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3ByZXNzXCI7XG5cbmltcG9ydCBhZGRFdmVudExpc3RlbmVycyBmcm9tIFwiLi91dGlscy9hZGQtZXZlbnQtbGlzdGVuZXJzXCI7XG5pbXBvcnQgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vdXRpbHMvcmVtb3ZlLWV2ZW50LWxpc3RlbmVyc1wiO1xuaW1wb3J0IGVhY2ggZnJvbSBcIi4vdXRpbHMvZWFjaFwiO1xuaW1wb3J0IG1lcmdlIGZyb20gXCIuL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgZXh0ZW5kIGZyb20gXCIuL3V0aWxzL2V4dGVuZFwiO1xuaW1wb3J0IGluaGVyaXQgZnJvbSBcIi4vdXRpbHMvaW5oZXJpdFwiO1xuaW1wb3J0IGJpbmRGbiBmcm9tIFwiLi91dGlscy9iaW5kLWZuXCI7XG5pbXBvcnQgcHJlZml4ZWQgZnJvbSBcIi4vdXRpbHMvcHJlZml4ZWRcIjtcbmltcG9ydCB0b0FycmF5IGZyb20gXCIuL3V0aWxzL3RvLWFycmF5XCI7XG5pbXBvcnQgdW5pcXVlQXJyYXkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlLWFycmF5XCI7XG5pbXBvcnQgc3BsaXRTdHIgZnJvbSBcIi4vdXRpbHMvc3BsaXQtc3RyXCI7XG5pbXBvcnQgaW5BcnJheSBmcm9tIFwiLi91dGlscy9pbi1hcnJheVwiO1xuaW1wb3J0IGJvb2xPckZuIGZyb20gXCIuL3V0aWxzL2Jvb2wtb3ItZm5cIjtcbmltcG9ydCBoYXNQYXJlbnQgZnJvbSBcIi4vdXRpbHMvaGFzLXBhcmVudFwiO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIYW1tZXIge1xuXHQvKipcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuXHRzdGF0aWMgVkVSU0lPTiA9IFwiI19fVkVSU0lPTl9fI1wiO1xuXHRzdGF0aWMgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG5cdHN0YXRpYyBESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuXHRzdGF0aWMgRElSRUNUSU9OX0xFRlQgPSBESVJFQ1RJT05fTEVGVDtcblx0c3RhdGljIERJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcblx0c3RhdGljIERJUkVDVElPTl9VUCA9IERJUkVDVElPTl9VUDtcblx0c3RhdGljIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0hPUklaT05UQUw7XG5cdHN0YXRpYyBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVkVSVElDQUw7XG5cdHN0YXRpYyBESVJFQ1RJT05fTk9ORSA9IERJUkVDVElPTl9OT05FO1xuXHRzdGF0aWMgRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcblx0c3RhdGljIElOUFVUX1NUQVJUID0gSU5QVVRfU1RBUlQ7XG5cdHN0YXRpYyBJTlBVVF9NT1ZFID0gSU5QVVRfTU9WRTtcbiAgc3RhdGljIElOUFVUX0VORCA9IElOUFVUX0VORDtcblx0c3RhdGljIElOUFVUX0NBTkNFTCA9IElOUFVUX0NBTkNFTDtcblx0c3RhdGljIFNUQVRFX1BPU1NJQkxFID0gU1RBVEVfUE9TU0lCTEU7XG5cdHN0YXRpYyBTVEFURV9CRUdBTiA9IFNUQVRFX0JFR0FOO1xuXHRzdGF0aWMgU1RBVEVfQ0hBTkdFRCA9IFNUQVRFX0NIQU5HRUQ7XG5cdHN0YXRpYyBTVEFURV9FTkRFRCA9IFNUQVRFX0VOREVEO1xuXHRzdGF0aWMgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX1JFQ09HTklaRUQ7XG5cdHN0YXRpYyBTVEFURV9DQU5DRUxMRUQgPSBTVEFURV9DQU5DRUxMRUQ7XG5cdHN0YXRpYyBTVEFURV9GQUlMRUQgPSBTVEFURV9GQUlMRUQ7XG5cdHN0YXRpYyBNYW5hZ2VyID0gTWFuYWdlcjtcblx0c3RhdGljIElucHV0ID0gSW5wdXQ7XG5cdHN0YXRpYyBUb3VjaEFjdGlvbiA9IFRvdWNoQWN0aW9uO1xuXHRzdGF0aWMgVG91Y2hJbnB1dCA9IFRvdWNoSW5wdXQ7XG5cdHN0YXRpYyBNb3VzZUlucHV0ID0gTW91c2VJbnB1dDtcblx0c3RhdGljIFBvaW50ZXJFdmVudElucHV0ID0gUG9pbnRlckV2ZW50SW5wdXQ7XG5cdHN0YXRpYyBUb3VjaE1vdXNlSW5wdXQgPSBUb3VjaE1vdXNlSW5wdXQ7XG5cdHN0YXRpYyBTaW5nbGVUb3VjaElucHV0ID0gU2luZ2xlVG91Y2hJbnB1dDtcblx0c3RhdGljIFJlY29nbml6ZXIgPSBSZWNvZ25pemVyO1xuXHRzdGF0aWMgQXR0clJlY29nbml6ZXIgPSBBdHRyUmVjb2duaXplcjtcblx0c3RhdGljIFRhcCA9IFRhcFJlY29nbml6ZXI7XG5cdHN0YXRpYyBQYW4gPSBQYW5SZWNvZ25pemVyO1xuXHRzdGF0aWMgU3dpcGUgPSBTd2lwZVJlY29nbml6ZXI7XG5cdHN0YXRpYyBQaW5jaCA9IFBpbmNoUmVjb2duaXplcjtcblx0c3RhdGljIFJvdGF0ZSA9IFJvdGF0ZVJlY29nbml6ZXI7XG5cdHN0YXRpYyBQcmVzcyA9IFByZXNzUmVjb2duaXplcjtcblx0c3RhdGljIG9uID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG5cdHN0YXRpYyBvZmYgPSByZW1vdmVFdmVudExpc3RlbmVycztcblx0c3RhdGljIGVhY2ggPSBlYWNoO1xuXHRzdGF0aWMgbWVyZ2UgPSBtZXJnZTtcblx0c3RhdGljIGV4dGVuZCA9IGV4dGVuZDtcblx0c3RhdGljIGJpbmRGbiA9IGJpbmRGbjtcblx0c3RhdGljIGFzc2lnbiA9IGFzc2lnbjtcblx0c3RhdGljIGluaGVyaXQgPSBpbmhlcml0O1xuXHRzdGF0aWMgYmluZEZuID0gYmluZEZuO1xuXHRzdGF0aWMgcHJlZml4ZWQgPSBwcmVmaXhlZDtcblx0c3RhdGljIHRvQXJyYXkgPSB0b0FycmF5O1xuXHRzdGF0aWMgaW5BcnJheSA9IGluQXJyYXk7XG5cdHN0YXRpYyB1bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuXHRzdGF0aWMgc3BsaXRTdHIgPSBzcGxpdFN0cjtcblx0c3RhdGljIGJvb2xPckZuID0gYm9vbE9yRm47XG5cdHN0YXRpYyBoYXNQYXJlbnQgPSBoYXNQYXJlbnQ7XG5cdHN0YXRpYyBhZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuXHRzdGF0aWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSByZW1vdmVFdmVudExpc3RlbmVycztcblx0c3RhdGljIGRlZmF1bHRzID0gYXNzaWduKHt9LCBkZWZhdWx0cywgeyBwcmVzZXQgfSk7XG5cdGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuXHRcdHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCB7XG5cdFx0XHRyZWNvZ25pemVyczogW1xuICAgICAgICAvLyBSZWNvZ25pemVyQ2xhc3MsIG9wdGlvbnMsIFtyZWNvZ25pemVXaXRoLCAuLi5dLCBbcmVxdWlyZUZhaWx1cmUsIC4uLl1cbiAgICAgICAgLi4ucHJlc2V0XG5cdFx0XHRdLFxuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHR9KTtcblx0fVxufVxuIiwiXG5pbXBvcnQgSGFtbWVyIGZyb20gXCIuL2hhbW1lclwiO1xuaW1wb3J0IGFzc2lnbiBmcm9tIFwiLi91dGlscy9hc3NpZ25cIjtcblxuaW1wb3J0IHtcbiAgSU5QVVRfU1RBUlQsXG4gIElOUFVUX01PVkUsXG4gIElOUFVUX0VORCxcbiAgSU5QVVRfQ0FOQ0VMLFxuICBESVJFQ1RJT05fTk9ORSxcbiAgRElSRUNUSU9OX0xFRlQsXG4gIERJUkVDVElPTl9SSUdIVCxcbiAgRElSRUNUSU9OX1VQLFxuICBESVJFQ1RJT05fRE9XTixcbiAgRElSRUNUSU9OX0hPUklaT05UQUwsXG4gIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgRElSRUNUSU9OX0FMTCxcbn0gZnJvbSBcIi4vaW5wdXRqcy9pbnB1dC1jb25zdHNcIjtcbmltcG9ydCB7XG4gIFNUQVRFX1BPU1NJQkxFLFxuICBTVEFURV9CRUdBTixcbiAgU1RBVEVfQ0hBTkdFRCxcbiAgU1RBVEVfRU5ERUQsXG4gIFNUQVRFX1JFQ09HTklaRUQsXG4gIFNUQVRFX0NBTkNFTExFRCxcbiAgU1RBVEVfRkFJTEVELFxufSBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHNcIjtcblxuaW1wb3J0IE1hbmFnZXIgZnJvbSBcIi4vbWFuYWdlclwiO1xuaW1wb3J0IElucHV0IGZyb20gXCIuL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3JcIjtcbmltcG9ydCBUb3VjaEFjdGlvbiBmcm9tIFwiLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgVG91Y2hJbnB1dCBmcm9tIFwiLi9pbnB1dC90b3VjaFwiO1xuaW1wb3J0IE1vdXNlSW5wdXQgZnJvbSBcIi4vaW5wdXQvbW91c2VcIjtcbmltcG9ydCBQb2ludGVyRXZlbnRJbnB1dCBmcm9tIFwiLi9pbnB1dC9wb2ludGVyZXZlbnRcIjtcbmltcG9ydCBTaW5nbGVUb3VjaElucHV0IGZyb20gXCIuL2lucHV0L3NpbmdsZXRvdWNoXCI7XG5pbXBvcnQgVG91Y2hNb3VzZUlucHV0IGZyb20gXCIuL2lucHV0L3RvdWNobW91c2VcIjtcblxuaW1wb3J0IFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3JcIjtcbmltcG9ydCBBdHRyUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9hdHRyaWJ1dGVcIjtcbmltcG9ydCBUYXBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3RhcFwiO1xuaW1wb3J0IFBhblJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGFuXCI7XG5pbXBvcnQgU3dpcGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3N3aXBlXCI7XG5pbXBvcnQgUGluY2hSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BpbmNoXCI7XG5pbXBvcnQgUm90YXRlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9yb3RhdGVcIjtcbmltcG9ydCBQcmVzc1JlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcHJlc3NcIjtcblxuaW1wb3J0IGFkZEV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL3V0aWxzL2FkZC1ldmVudC1saXN0ZW5lcnNcIjtcbmltcG9ydCByZW1vdmVFdmVudExpc3RlbmVycyBmcm9tIFwiLi91dGlscy9yZW1vdmUtZXZlbnQtbGlzdGVuZXJzXCI7XG5pbXBvcnQgZWFjaCBmcm9tIFwiLi91dGlscy9lYWNoXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4vdXRpbHMvbWVyZ2VcIjtcbmltcG9ydCBleHRlbmQgZnJvbSBcIi4vdXRpbHMvZXh0ZW5kXCI7XG5pbXBvcnQgaW5oZXJpdCBmcm9tIFwiLi91dGlscy9pbmhlcml0XCI7XG5pbXBvcnQgYmluZEZuIGZyb20gXCIuL3V0aWxzL2JpbmQtZm5cIjtcbmltcG9ydCBwcmVmaXhlZCBmcm9tIFwiLi91dGlscy9wcmVmaXhlZFwiO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSBcIi4vdXRpbHMvdG8tYXJyYXlcIjtcbmltcG9ydCB1bmlxdWVBcnJheSBmcm9tIFwiLi91dGlscy91bmlxdWUtYXJyYXlcIjtcbmltcG9ydCBzcGxpdFN0ciBmcm9tIFwiLi91dGlscy9zcGxpdC1zdHJcIjtcbmltcG9ydCBpbkFycmF5IGZyb20gXCIuL3V0aWxzL2luLWFycmF5XCI7XG5pbXBvcnQgYm9vbE9yRm4gZnJvbSBcIi4vdXRpbHMvYm9vbC1vci1mblwiO1xuaW1wb3J0IGhhc1BhcmVudCBmcm9tIFwiLi91dGlscy9oYXMtcGFyZW50XCI7XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cblxuY29uc3QgZGVmYXVsdHMgPSBIYW1tZXIuZGVmYXVsdHM7XG5cbmV4cG9ydCB7XG4gIEhhbW1lciBhcyBkZWZhdWx0LFxuICBJTlBVVF9TVEFSVCxcbiAgSU5QVVRfTU9WRSxcbiAgSU5QVVRfRU5ELFxuICBJTlBVVF9DQU5DRUwsXG4gIFNUQVRFX1BPU1NJQkxFLFxuICBTVEFURV9CRUdBTixcbiAgU1RBVEVfQ0hBTkdFRCxcbiAgU1RBVEVfRU5ERUQsXG4gIFNUQVRFX1JFQ09HTklaRUQsXG4gIFNUQVRFX0NBTkNFTExFRCxcbiAgU1RBVEVfRkFJTEVELFxuXG4gIERJUkVDVElPTl9OT05FLFxuICBESVJFQ1RJT05fTEVGVCxcbiAgRElSRUNUSU9OX1JJR0hULFxuICBESVJFQ1RJT05fVVAsXG4gIERJUkVDVElPTl9ET1dOLFxuICBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICBESVJFQ1RJT05fQUxMLFxuICBNYW5hZ2VyLFxuICBJbnB1dCxcbiAgVG91Y2hBY3Rpb24sXG4gIFRvdWNoSW5wdXQsXG4gIE1vdXNlSW5wdXQsXG4gIFBvaW50ZXJFdmVudElucHV0LFxuICBUb3VjaE1vdXNlSW5wdXQsXG4gIFNpbmdsZVRvdWNoSW5wdXQsXG4gIFJlY29nbml6ZXIsXG4gIEF0dHJSZWNvZ25pemVyLFxuICBUYXBSZWNvZ25pemVyIGFzIFRhcCxcbiAgUGFuUmVjb2duaXplciBhcyBQYW4sXG4gIFN3aXBlUmVjb2duaXplciBhcyBTd2lwZSxcbiAgUGluY2hSZWNvZ25pemVyIGFzIFBpbmNoLFxuICBSb3RhdGVSZWNvZ25pemVyIGFzIFJvdGF0ZSxcbiAgUHJlc3NSZWNvZ25pemVyIGFzIFByZXNzLFxuICBhZGRFdmVudExpc3RlbmVycyBhcyBvbixcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgYXMgb2ZmLFxuICBlYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICBhc3NpZ24sXG4gIGluaGVyaXQsXG4gIGJpbmRGbixcbiAgcHJlZml4ZWQsXG4gIHRvQXJyYXksXG4gIGluQXJyYXksXG4gIHVuaXF1ZUFycmF5LFxuICBzcGxpdFN0cixcbiAgYm9vbE9yRm4sXG4gIGhhc1BhcmVudCxcbiAgYWRkRXZlbnRMaXN0ZW5lcnMsXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICBkZWZhdWx0cyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@egjs/hammerjs/dist/hammer.esm.js\n");

/***/ })

};
