/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
export const id = "vendors-node_modules_hls_js_dist_hls_light_mjs";
export const ids = ["vendors-node_modules_hls_js_dist_hls_light_mjs"];
export const modules = {

/***/ "./node_modules/hls.js/dist/hls.light.mjs":
/*!************************************************!*\
  !*** ./node_modules/hls.js/dist/hls.light.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbrController: () => (/* binding */ AbrController),\n/* harmony export */   AttrList: () => (/* binding */ AttrList),\n/* harmony export */   AudioStreamController: () => (/* binding */ Cues),\n/* harmony export */   AudioTrackController: () => (/* binding */ Cues),\n/* harmony export */   BasePlaylistController: () => (/* binding */ BasePlaylistController),\n/* harmony export */   BaseSegment: () => (/* binding */ BaseSegment),\n/* harmony export */   BaseStreamController: () => (/* binding */ BaseStreamController),\n/* harmony export */   BufferController: () => (/* binding */ BufferController),\n/* harmony export */   CMCDController: () => (/* binding */ Cues),\n/* harmony export */   CapLevelController: () => (/* binding */ CapLevelController),\n/* harmony export */   ChunkMetadata: () => (/* binding */ ChunkMetadata),\n/* harmony export */   ContentSteeringController: () => (/* binding */ ContentSteeringController),\n/* harmony export */   DateRange: () => (/* binding */ DateRange),\n/* harmony export */   EMEController: () => (/* binding */ Cues),\n/* harmony export */   ErrorActionFlags: () => (/* binding */ ErrorActionFlags),\n/* harmony export */   ErrorController: () => (/* binding */ ErrorController),\n/* harmony export */   ErrorDetails: () => (/* binding */ ErrorDetails),\n/* harmony export */   ErrorTypes: () => (/* binding */ ErrorTypes),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   FPSController: () => (/* binding */ FPSController),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Hls: () => (/* binding */ Hls),\n/* harmony export */   HlsSkip: () => (/* binding */ HlsSkip),\n/* harmony export */   HlsUrlParameters: () => (/* binding */ HlsUrlParameters),\n/* harmony export */   KeySystemFormats: () => (/* binding */ KeySystemFormats),\n/* harmony export */   KeySystems: () => (/* binding */ KeySystems),\n/* harmony export */   Level: () => (/* binding */ Level),\n/* harmony export */   LevelDetails: () => (/* binding */ LevelDetails),\n/* harmony export */   LevelKey: () => (/* binding */ LevelKey),\n/* harmony export */   LoadStats: () => (/* binding */ LoadStats),\n/* harmony export */   MetadataSchema: () => (/* binding */ MetadataSchema),\n/* harmony export */   NetworkErrorAction: () => (/* binding */ NetworkErrorAction),\n/* harmony export */   Part: () => (/* binding */ Part),\n/* harmony export */   PlaylistLevelType: () => (/* binding */ PlaylistLevelType),\n/* harmony export */   SubtitleStreamController: () => (/* binding */ SubtitleStreamController),\n/* harmony export */   SubtitleTrackController: () => (/* binding */ Cues),\n/* harmony export */   TimelineController: () => (/* binding */ TimelineController),\n/* harmony export */   \"default\": () => (/* binding */ Hls),\n/* harmony export */   getMediaSource: () => (/* binding */ getMediaSource),\n/* harmony export */   isMSESupported: () => (/* binding */ isMSESupported),\n/* harmony export */   isSupported: () => (/* binding */ isSupported)\n/* harmony export */ });\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar urlToolkit = {\n  exports: {}\n};\n(function (module, exports) {\n  // see https://tools.ietf.org/html/rfc1808\n\n  (function (root) {\n    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n    var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n    var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n    var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n    var URLToolkit = {\n      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n      // E.g\n      // With opts.alwaysNormalize = false (default, spec compliant)\n      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n      // With opts.alwaysNormalize = true (not spec compliant)\n      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n      buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n        opts = opts || {};\n        // remove any remaining space and CRLF\n        baseURL = baseURL.trim();\n        relativeURL = relativeURL.trim();\n        if (!relativeURL) {\n          // 2a) If the embedded URL is entirely empty, it inherits the\n          // entire base URL (i.e., is set equal to the base URL)\n          // and we are done.\n          if (!opts.alwaysNormalize) {\n            return baseURL;\n          }\n          var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n          if (!basePartsForNormalise) {\n            throw new Error('Error trying to parse base URL.');\n          }\n          basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n          return URLToolkit.buildURLFromParts(basePartsForNormalise);\n        }\n        var relativeParts = URLToolkit.parseURL(relativeURL);\n        if (!relativeParts) {\n          throw new Error('Error trying to parse relative URL.');\n        }\n        if (relativeParts.scheme) {\n          // 2b) If the embedded URL starts with a scheme name, it is\n          // interpreted as an absolute URL and we are done.\n          if (!opts.alwaysNormalize) {\n            return relativeURL;\n          }\n          relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n          return URLToolkit.buildURLFromParts(relativeParts);\n        }\n        var baseParts = URLToolkit.parseURL(baseURL);\n        if (!baseParts) {\n          throw new Error('Error trying to parse base URL.');\n        }\n        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n          // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n          // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n          baseParts.netLoc = pathParts[1];\n          baseParts.path = pathParts[2];\n        }\n        if (baseParts.netLoc && !baseParts.path) {\n          baseParts.path = '/';\n        }\n        var builtParts = {\n          // 2c) Otherwise, the embedded URL inherits the scheme of\n          // the base URL.\n          scheme: baseParts.scheme,\n          netLoc: relativeParts.netLoc,\n          path: null,\n          params: relativeParts.params,\n          query: relativeParts.query,\n          fragment: relativeParts.fragment\n        };\n        if (!relativeParts.netLoc) {\n          // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n          // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n          // (if any) of the base URL.\n          builtParts.netLoc = baseParts.netLoc;\n          // 4) If the embedded URL path is preceded by a slash \"/\", the\n          // path is not relative and we skip to Step 7.\n          if (relativeParts.path[0] !== '/') {\n            if (!relativeParts.path) {\n              // 5) If the embedded URL path is empty (and not preceded by a\n              // slash), then the embedded URL inherits the base URL path\n              builtParts.path = baseParts.path;\n              // 5a) if the embedded URL's <params> is non-empty, we skip to\n              // step 7; otherwise, it inherits the <params> of the base\n              // URL (if any) and\n              if (!relativeParts.params) {\n                builtParts.params = baseParts.params;\n                // 5b) if the embedded URL's <query> is non-empty, we skip to\n                // step 7; otherwise, it inherits the <query> of the base\n                // URL (if any) and we skip to step 7.\n                if (!relativeParts.query) {\n                  builtParts.query = baseParts.query;\n                }\n              }\n            } else {\n              // 6) The last segment of the base URL's path (anything\n              // following the rightmost slash \"/\", or the entire path if no\n              // slash is present) is removed and the embedded URL's path is\n              // appended in its place.\n              var baseURLPath = baseParts.path;\n              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n              builtParts.path = URLToolkit.normalizePath(newPath);\n            }\n          }\n        }\n        if (builtParts.path === null) {\n          builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n        }\n        return URLToolkit.buildURLFromParts(builtParts);\n      },\n      parseURL: function (url) {\n        var parts = URL_REGEX.exec(url);\n        if (!parts) {\n          return null;\n        }\n        return {\n          scheme: parts[1] || '',\n          netLoc: parts[2] || '',\n          path: parts[3] || '',\n          params: parts[4] || '',\n          query: parts[5] || '',\n          fragment: parts[6] || ''\n        };\n      },\n      normalizePath: function (path) {\n        // The following operations are\n        // then applied, in order, to the new path:\n        // 6a) All occurrences of \"./\", where \".\" is a complete path\n        // segment, are removed.\n        // 6b) If the path ends with \".\" as a complete path segment,\n        // that \".\" is removed.\n        path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n        // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n        // complete path segment not equal to \"..\", are removed.\n        // Removal of these path segments is performed iteratively,\n        // removing the leftmost matching pattern on each iteration,\n        // until no matching pattern remains.\n        // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n        // complete path segment not equal to \"..\", that\n        // \"<segment>/..\" is removed.\n        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n        return path.split('').reverse().join('');\n      },\n      buildURLFromParts: function (parts) {\n        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n      }\n    };\n    module.exports = URLToolkit;\n  })();\n})(urlToolkit);\nvar urlToolkitExports = urlToolkit.exports;\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function (value) {\n  return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nlet Events = /*#__PURE__*/function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nlet exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  const func = self.console[type];\n  if (func) {\n    return func.bind(self.console, `[${type}] >`);\n  }\n  return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\nfunction enableLogs(debugConfig, id) {\n  // check that console is available\n  if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.5.3\"}`);\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nconst logger = exportedLogger;\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    _extends(this, attrs);\n  }\n  get clientAttrs() {\n    return Object.keys(this).filter(attr => attr.substring(0, 2) === 'X-');\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    } else {\n      return null;\n    }\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      let value = match[2];\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n      const name = match[1].trim();\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    if (\"END-DATE\" in this.attr) {\n      const endDate = new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    if (this._endDate) {\n      return this._endDate;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n  }\n}\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  constructor(baseurl) {\n    this._byteRange = null;\n    this._url = null;\n    // baseurl is the URL to the playlist\n    this.baseurl = void 0;\n    // relurl is the portion of the URL that comes from inside the playlist.\n    this.relurl = void 0;\n    // Holds the types of data this fragment supports\n    this.elementaryStreams = {\n      [ElementaryStreamTypes.AUDIO]: null,\n      [ElementaryStreamTypes.VIDEO]: null,\n      [ElementaryStreamTypes.AUDIOVIDEO]: null\n    };\n    this.baseurl = baseurl;\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    let start;\n    if (params.length === 1) {\n      start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n    } else {\n      start = parseInt(params[1]);\n    }\n    this._byteRange = [start, parseInt(params[0]) + start];\n  }\n  get byteRange() {\n    if (!this._byteRange) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  constructor(type, baseurl) {\n    super(baseurl);\n    this._decryptdata = null;\n    this.rawProgramDateTime = null;\n    this.programDateTime = null;\n    this.tagList = [];\n    // EXTINF has to be present for a m3u8 to be considered valid\n    this.duration = 0;\n    // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n    this.sn = 0;\n    // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n    // core difference from the private field _decryptdata is the lack of the initialized IV\n    // _decryptdata will set the IV for this segment based on the segment number in the fragment\n    this.levelkeys = void 0;\n    // A string representing the fragment type\n    this.type = void 0;\n    // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n    this.loader = null;\n    // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n    this.keyLoader = null;\n    // The level/track index to which the fragment belongs\n    this.level = -1;\n    // The continuity counter of the fragment\n    this.cc = 0;\n    // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.startPTS = void 0;\n    // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.endPTS = void 0;\n    // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.startDTS = void 0;\n    // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.endDTS = void 0;\n    // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n    this.start = 0;\n    // Set by `updateFragPTSDTS` in level-helper\n    this.deltaPTS = void 0;\n    // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.maxStartPTS = void 0;\n    // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.minEndPTS = void 0;\n    // Load/parse timing information\n    this.stats = new LoadStats();\n    // Init Segment bytes (unset for media segments)\n    this.data = void 0;\n    // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n    this.bitrateTest = false;\n    // #EXTINF  segment title\n    this.title = null;\n    // The Media Initialization Section for this segment\n    this.initSegment = null;\n    // Fragment is the last fragment in the media playlist\n    this.endList = void 0;\n    // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n    this.gap = void 0;\n    // Deprecated\n    this.urlId = 0;\n    this.type = type;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    if (!isFiniteNumber(this.programDateTime)) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, baseurl, index, previous) {\n    super(baseurl);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.stats = new LoadStats();\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    // Manifest reload synchronization\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n    this.availabilityDelay = previous.availabilityDelay;\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n}\n\n// This file is inserted as a shim for modules which we do not want to include into the distro.\n// This replacement is done in the \"alias\" plugin of the rollup config.\nvar empty = undefined;\nvar Cues = /*@__PURE__*/getDefaultExportFromCjs(empty);\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isHeader$2 = (data, offset) => {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isFooter = (data, offset) => {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nconst getID3Data = (data, offset) => {\n  const front = offset;\n  let length = 0;\n  while (isHeader$2(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readSize(data, offset + 6);\n    length += size;\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n};\nconst readSize = (data, offset) => {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\nconst canParse$2 = (data, offset) => {\n  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */\nconst getTimeStamp = data => {\n  const frames = getID3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */\nconst isTimeStampFrame = frame => {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\nconst getFrameData = data => {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */\nconst getID3Frames = id3Data => {\n  let offset = 0;\n  const frames = [];\n  while (isHeader$2(id3Data, offset)) {\n    const size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      const frameData = getFrameData(id3Data.subarray(offset));\n      const frame = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n  return frames;\n};\nconst decodeFrame = frame => {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n  return decodeTextFrame(frame);\n};\nconst decodePrivFrame = frame => {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\nconst decodeTextFrame = frame => {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\nconst decodeURLFrame = frame => {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\nconst readTimeStamp = timeStampFrame => {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nconst utf8ArrayToStr = (array, exitOnNull = false) => {\n  const decoder = getTextDecoder();\n  if (decoder) {\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n  // On Play Station 4, TextDecoder is defined but partially implemented.\n  // Manual decoding option is preferable\n  if (navigator.userAgent.includes('PlayStation 4')) {\n    return;\n  }\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n  return decoder;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find \"moof\" box\nfunction hasMoofData(data) {\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n      return true;\n    }\n    i = size > 1 ? i + size : end;\n  }\n  return false;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n\n  // TODO: parse earliestPresentationTime and firstOffset\n  // usually zero in our case\n  const earliestPresentationTime = 0;\n  const firstOffset = 0;\n  if (version === 0) {\n    index += 8;\n  } else {\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            const stsdData = parseStsd(stsd);\n            result[trackId] = {\n              timescale,\n              type\n            };\n            result[type] = _objectSpread2({\n              timescale,\n              id: trackId\n            }, stsdData);\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction parseStsd(stsd) {\n  const sampleEntries = stsd.subarray(8);\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\n  let codec = fourCC;\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\n  if (encrypted) {\n    const encBox = findBox(sampleEntries, [fourCC])[0];\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n    const sinfs = findBox(encBoxChildren, ['sinf']);\n    sinfs.forEach(sinf => {\n      const schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          const frma = findBox(sinf, ['frma'])[0];\n          if (frma) {\n            // for encrypted content codec fourCC will be in frma\n            codec = bin2str(frma);\n          }\n        }\n      }\n    });\n  }\n  switch (codec) {\n    case 'avc1':\n    case 'avc2':\n    case 'avc3':\n    case 'avc4':\n      {\n        // extract profile + compatibility + level out of avcC box\n        const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n        codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n        break;\n      }\n    case 'mp4a':\n      {\n        const codecBox = findBox(sampleEntries, [fourCC])[0];\n        const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n        if (esdsBox && esdsBox.length > 12) {\n          let i = 4;\n          // ES Descriptor tag\n          if (esdsBox[i++] !== 0x03) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          i += 2; // skip es_id;\n          const flags = esdsBox[i++];\n          if (flags & 0x80) {\n            i += 2; // skip dependency es_id\n          }\n          if (flags & 0x40) {\n            i += esdsBox[i++]; // skip URL\n          }\n          // Decoder config descriptor\n          if (esdsBox[i++] !== 0x04) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const objectType = esdsBox[i++];\n          if (objectType === 0x40) {\n            codec += '.' + toHex(objectType);\n          } else {\n            break;\n          }\n          i += 12;\n          // Decoder specific info\n          if (esdsBox[i++] !== 0x05) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const firstByte = esdsBox[i++];\n          let audioObjectType = (firstByte & 0xf8) >> 3;\n          if (audioObjectType === 31) {\n            audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n          }\n          codec += '.' + audioObjectType;\n        }\n        break;\n      }\n    case 'hvc1':\n    case 'hev1':\n      {\n        const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n        const profileByte = hvcCBox[1];\n        const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n        const generalProfileIdc = profileByte & 0x1f;\n        const profileCompat = readUint32(hvcCBox, 2);\n        const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n        const levelIDC = hvcCBox[12];\n        const constraintIndicator = hvcCBox.subarray(6, 12);\n        codec += '.' + profileSpace + generalProfileIdc;\n        codec += '.' + profileCompat.toString(16).toUpperCase();\n        codec += '.' + tierFlag + levelIDC;\n        let constraintString = '';\n        for (let i = constraintIndicator.length; i--;) {\n          const byte = constraintIndicator[i];\n          if (byte || constraintString) {\n            const encodedByte = byte.toString(16).toUpperCase();\n            constraintString = '.' + encodedByte + constraintString;\n          }\n        }\n        codec += constraintString;\n        break;\n      }\n    case 'dvh1':\n    case 'dvhe':\n      {\n        const dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];\n        const profile = dvcCBox[2] >> 1 & 0x7f;\n        const level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;\n        codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);\n        break;\n      }\n    case 'vp09':\n      {\n        const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n        const profile = vpcCBox[4];\n        const level = vpcCBox[5];\n        const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n        codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);\n        break;\n      }\n    case 'av01':\n      {\n        const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n        const profile = av1CBox[1] >>> 5;\n        const level = av1CBox[1] & 0x1f;\n        const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n        const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n        const twelveBit = (av1CBox[2] & 0x20) >> 5;\n        const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n        const monochrome = (av1CBox[2] & 0x10) >> 4;\n        const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n        const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n        const chromaSamplePosition = av1CBox[2] & 0x03;\n        // TODO: parse color_description_present_flag\n        // default it to BT.709/limited range for now\n        // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n        const colorPrimaries = 1;\n        const transferCharacteristics = 1;\n        const matrixCoefficients = 1;\n        const videoFullRangeFlag = 0;\n        codec += '.' + profile + '.' + addLeadingZero(level) + tierFlag + '.' + addLeadingZero(bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n        break;\n      }\n  }\n  return {\n    codec,\n    encrypted\n  };\n}\nfunction skipBERInteger(bytes, i) {\n  const limit = i + 5;\n  while (bytes[i++] & 0x80 && i < limit) {}\n  return i;\n}\nfunction toHex(x) {\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n  return (num < 10 ? '0' : '') + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  logger.error(`[eme] missing 'schm' box`);\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce((result, traf) => {\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    const version = tfdt[0];\n    const start = findBox(traf, ['tfhd']).reduce((result, tfhd) => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (track) {\n        let baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n          // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n          // https://github.com/video-dev/hls.js/issues/5303\n          if (baseTime === UINT32_MAX$1) {\n            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n            return result;\n          }\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const scale = track.timescale || 90e3;\n        // convert base time to seconds\n        const startTime = baseTime / scale;\n        if (isFiniteNumber(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n      return result;\n    }, null);\n    if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {\n      return start;\n    }\n    return result;\n  }, null);\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(‘tfhd’, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nfunction getDuration(data, initData) {\n  let rawDuration = 0;\n  let videoDuration = 0;\n  let audioDuration = 0;\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    const timescale = track.timescale || 90e3;\n    const truns = findBox(traf, ['trun']);\n    for (let j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        const sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxDuration = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxDuration += sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n      }\n    }\n    return sidxDuration;\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(‘trun’, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nfunction computeRawDurationFromSamples(trun) {\n  const flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  let offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n  let duration = 0;\n  const sampleCount = readUint32(trun, 4);\n  for (let i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      const sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(traf => {\n    findBox(traf, ['tfhd']).forEach(tfhd => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      const timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach(tfdt => {\n        const version = tfdt[0];\n        const offset = timeOffset * timescale;\n        if (offset) {\n          let baseMediaDecodeTime = readUint32(tfdt, 4);\n          if (version === 0) {\n            baseMediaDecodeTime -= offset;\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n            writeUint32(tfdt, 4, baseMediaDecodeTime);\n          } else {\n            baseMediaDecodeTime *= Math.pow(2, 32);\n            baseMediaDecodeTime += readUint32(tfdt, 8);\n            baseMediaDecodeTime -= offset;\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n            writeUint32(tfdt, 4, upper);\n            writeUint32(tfdt, 8, lower);\n          }\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const delimit = codec.indexOf('.');\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    // Create a variable to process the payload\n    let payPtr = seiPtr;\n\n    // Increment the seiPtr to the end of the payload\n    if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      // Some type of corruption has happened?\n      logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n      // We might be able to parse some data, but let's be safe and ignore it.\n      break;\n    }\n    if (payloadType === 4) {\n      const countryCode = data[payPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, payPtr);\n        payPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, payPtr);\n          payPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[payPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[payPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[payPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5) {\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[payPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[payPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {}\n  constructor(method, uri, format, formatversions = [1], iv = null) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (this.method === 'AES-128' || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (this.method === 'AES-128' && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        if (this.method === 'AES-128' && !this.iv) {\n          logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n        }\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n    {\n      return this;\n    }\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\n/**\n * MediaSource helper\n */\n\nfunction getMediaSource(preferManagedMediaSource = true) {\n  if (typeof self === 'undefined') return undefined;\n  const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n  return mms || self.MediaSource || self.WebKitMediaSource;\n}\n\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: 1,\n    'ac-3': 0.95,\n    'ac-4': 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    'dts+': 1,\n    'dts-': 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    'ec-3': 0.9,\n    enca: 1,\n    fLaC: 0.9,\n    // MP4-RA listed codec entry for FLAC\n    flac: 0.9,\n    // legacy browser codec name for FLAC\n    FLAC: 0.9,\n    // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    'raw ': 1,\n    Opus: 1,\n    opus: 1,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    'vc-1': 1,\n    vp08: 1,\n    vp09: 0.9\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1\n  }\n};\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n  return !codecs.split(',').some(codec => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n  var _MediaSource$isTypeSu;\n  const MediaSource = getMediaSource(preferManagedMediaSource);\n  return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n  return `${type}/mp4;codecs=\"${codec}\"`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n  if (videoCodec) {\n    const fourCC = videoCodec.substring(0, 4);\n    return sampleEntryCodesISO.video[fourCC];\n  }\n  return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n  return codecSet.split(',').reduce((num, fourCC) => {\n    const preferenceValue = sampleEntryCodesISO.video[fourCC];\n    if (preferenceValue) {\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\n    }\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n  }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n  }\n\n  // Idealy fLaC and Opus would be first (spec-compliant) but\n  // some browsers will report that fLaC is supported then fail.\n  // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n  const codecsToCheck = {\n    flac: ['flac', 'fLaC', 'FLAC'],\n    opus: ['opus', 'Opus']\n  }[lowerCaseCodec];\n  for (let i = 0; i < codecsToCheck.length; i++) {\n    if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n      return codecsToCheck[i];\n    }\n  }\n  return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n  return codec.replace(AUDIO_CODEC_REGEXP, m => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n  // so use level codec is parsed codec is unavailable or incomplete\n  if (parsedCodec && parsedCodec !== 'mp4a') {\n    return parsedCodec;\n  }\n  return levelCodec;\n}\nfunction convertAVC1ToAVCOTI(codec) {\n  // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n  const avcdata = codec.split('.');\n  if (avcdata.length > 2) {\n    let result = avcdata.shift() + '.';\n    result += parseInt(avcdata.shift()).toString(16);\n    result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n    return result;\n  }\n  return codec;\n}\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[\\S ]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source,\n// next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n// next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = false;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1]);\n        const uri = result[2];\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs(attrs.CODECS, level);\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes);\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes);\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1]);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        const lang = attrs.LANGUAGE;\n        const assocLang = attrs['ASSOC-LANGUAGE'];\n        const channels = attrs.CHANNELS;\n        const characteristics = attrs.CHARACTERISTICS;\n        const instreamId = attrs['INSTREAM-ID'];\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          name: attrs.NAME || lang || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (assocLang) {\n          media.assocLang = assocLang;\n        }\n        if (channels) {\n          media.channels = channels;\n        }\n        if (characteristics) {\n          media.characteristics = characteristics;\n        }\n        if (instreamId) {\n          media.instreamId = instreamId;\n        }\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, baseurl);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    let nextByteRange = null;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = false;\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, baseurl);\n        // setup the next fragment for part loading\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n          if (nextByteRange) {\n            frag.setByteRange(nextByteRange);\n            nextByteRange = null;\n          }\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = uri;\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        const data = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              const skipAttrs = new AttrList(value1);\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments = skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n          case 'INDEPENDENT-SEGMENTS':\n          case 'EXTM3U':\n            break;\n          case 'ENDLIST':\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1);\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                if (levelkeys[levelKey.keyFormat]) {\n                  levelkeys = _extends({}, levelkeys);\n                }\n                levelkeys[levelKey.keyFormat] = levelKey;\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1);\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                const end = frag.byteRangeEndOffset;\n                if (end) {\n                  const start = frag.byteRangeStartOffset;\n                  nextByteRange = `${end - start}@${start}`;\n                } else {\n                  nextByteRange = null;\n                }\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              const serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1);\n              const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1);\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1);\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n    return level;\n  }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes);\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n  let codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(c => c);\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      // Comma separated list of all codecs for type\n      level[`${type}Codec`] = filtered.join(',');\n      // Remove known codecs so that only unknownCodecs are left after iterating through each type\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n  if (!isFiniteNumber(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      pathwayId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      level,\n      pathwayId,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {\n        // same URL can't overlap\n        logger.trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string)) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelUrlId = 0;\n    const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_PARSING_ERROR,\n        fatal: false,\n        url,\n        error,\n        reason: error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  while (left <= right) {\n    const mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\nvar MetadataSchema = {\n  audioId3: \"org.id3\",\n  dateRange: \"com.apple.quicktime.HLS\",\n  emsg: \"https://aomedia.org/emsg/ID3\"\n};\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n  return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n  let cue = new Cue(startTime, endTime, '');\n  try {\n    cue.value = data;\n    if (type) {\n      cue.type = type;\n    }\n  } catch (e) {\n    cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({\n      type\n    }, data) : data));\n  }\n  return cue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n\n  // Add ID3 metatadata text track.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n  }\n  onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n    clearCurrentCues(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    if (!Cue) {\n      return;\n    }\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getID3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isTimeStampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n            if (cue) {\n              this.id3Track.addCue(cue);\n            }\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      dateRangeCuesAppended,\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track) {\n      const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n      for (let i = idsToRemove.length; i--;) {\n        const id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(key => {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n\n      // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      let endTime = MAX_CUE_ENDTIME;\n      const endDate = dateRange.endDate;\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id) => {\n          if (id !== dateRange.id) {\n            const otherDateRange = dateRanges[id];\n            if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n              return otherDateRange;\n            }\n          }\n          return candidateDateRange;\n        }, null);\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n\n      // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n      // This is to emulate Safari HLS playback handling of DateRange tags\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        const cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else if (Cue) {\n          let data = dateRange.attr[key];\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          const _cue = createCueWithDataFields(Cue, startTime, endTime, {\n            key,\n            data\n          }, MetadataSchema.dateRange);\n          if (_cue) {\n            _cue.id = id;\n            this.id3Track.addCue(_cue);\n            cues[key] = _cue;\n          }\n        }\n      }\n\n      // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this.timeupdateHandler = () => this.timeupdate();\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config,\n      levelDetails\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    const liveSyncOnStallIncrease = 1.0;\n    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    const levelDetails = this.levelDetails;\n    if (liveEdge === null || targetLatency === null || levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null;\n    // @ts-ignore\n    this.hls = this.timeupdateHandler = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.levelDetails = details;\n    if (details.advanced) {\n      this.timeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  timeupdate() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return;\n    }\n    this.currentTime = media.currentTime;\n    const latency = this.computeLatency();\n    if (latency === null) {\n      return;\n    }\n    this._latency = latency;\n\n    // Adapt playbackRate to meet target latency in low-latency mode\n    const {\n      lowLatencyMode,\n      maxLiveSyncPlaybackRate\n    } = this.config;\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n      return;\n    }\n    const targetLatency = this.targetLatency;\n    if (targetLatency === null) {\n      return;\n    }\n    const distanceFromTarget = latency - targetLatency;\n    // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n    if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  }\n  estimateLiveEdge() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nfunction isHdcpLevel(value) {\n  return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = ['SDR', 'PQ', 'HLG'];\nfunction isVideoRange(value) {\n  return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details, msn) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    endSN\n  } = details;\n  const snChangeGoal = msn !== undefined ? msn - endSN : 0;\n  if (canSkipUntil && snChangeGoal < canSkipUntil) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.url = void 0;\n    this.frameRate = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.supportedPromise = void 0;\n    this.supportedResult = void 0;\n    this._avgBitrate = 0;\n    this._audioGroups = void 0;\n    this._subtitleGroups = void 0;\n    // Deprecated (retained for backwards compatibility)\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n    this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => !!c).map(s => s.substring(0, 4)).join(',');\n    this.addGroupId('audio', data.attrs.AUDIO);\n    this.addGroupId('text', data.attrs.SUBTITLES);\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get averageBitrate() {\n    return this._avgBitrate || this.realBitrate || this.bitrate;\n  }\n  get attrs() {\n    return this._attrs[0];\n  }\n  get codecs() {\n    return this.attrs.CODECS || '';\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get videoRange() {\n    return this.attrs['VIDEO-RANGE'] || 'SDR';\n  }\n  get score() {\n    return this.attrs.optionalFloat('SCORE', 0);\n  }\n  get uri() {\n    return this.url[0] || '';\n  }\n  hasAudioGroup(groupId) {\n    return hasGroup(this._audioGroups, groupId);\n  }\n  hasSubtitleGroup(groupId) {\n    return hasGroup(this._subtitleGroups, groupId);\n  }\n  get audioGroups() {\n    return this._audioGroups;\n  }\n  get subtitleGroups() {\n    return this._subtitleGroups;\n  }\n  addGroupId(type, groupId) {\n    if (!groupId) {\n      return;\n    }\n    if (type === 'audio') {\n      let audioGroups = this._audioGroups;\n      if (!audioGroups) {\n        audioGroups = this._audioGroups = [];\n      }\n      if (audioGroups.indexOf(groupId) === -1) {\n        audioGroups.push(groupId);\n      }\n    } else if (type === 'text') {\n      let subtitleGroups = this._subtitleGroups;\n      if (!subtitleGroups) {\n        subtitleGroups = this._subtitleGroups = [];\n      }\n      if (subtitleGroups.indexOf(groupId) === -1) {\n        subtitleGroups.push(groupId);\n      }\n    }\n  }\n\n  // Deprecated methods (retained for backwards compatibility)\n  get urlId() {\n    return 0;\n  }\n  set urlId(value) {}\n  get audioGroupIds() {\n    return this.audioGroups ? [this.audioGroupId] : undefined;\n  }\n  get textGroupIds() {\n    return this.subtitleGroups ? [this.textGroupId] : undefined;\n  }\n  get audioGroupId() {\n    var _this$audioGroups;\n    return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n  }\n  get textGroupId() {\n    var _this$subtitleGroups;\n    return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n  }\n  addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n  if (!groupId || !groups) {\n    return false;\n  }\n  return groups.indexOf(groupId) !== -1;\n}\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.start = startPTS;\n  }\n  frag.duration = endPTS - frag.start;\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n  let ccOffset = 0;\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  if (currentInitSegment) {\n    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newDetails.fragments.shift();\n      }\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n  const newFragments = newDetails.fragments;\n  if (ccOffset) {\n    logger.warn('discontinuity sliding from playlist, take drift into account');\n    for (let i = 0; i < newFragments.length; i++) {\n      newFragments[i].cc += ccOffset;\n    }\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  Object.keys(deltaDateRanges).forEach(id => {\n    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n    }\n  });\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  const levelDetails = level.details;\n  let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = levelDetails.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  var _level$details;\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n  levels.forEach((level, index) => {\n    const {\n      details\n    } = level;\n    if (details != null && details.fragments) {\n      details.fragments.forEach(fragment => {\n        fragment.level = index;\n      });\n    }\n  });\n}\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n  if (!retryConfig) {\n    return false;\n  }\n  const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n  const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n  return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n    // check for buffer-end rounding error\n    const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n    if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n      bufferEnd += 0.0000015;\n    }\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && (!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[Ø] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return BinarySearch.search(fragments, candidate => {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[info]:`);\n    this.warn = logger.warn.bind(logger, `[warning]:`);\n    this.error = logger.error.bind(logger, `[error]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.playlistError = 0;\n  }\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag, _data$level;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = {\n            action: NetworkErrorAction.DoNothing,\n            flags: ErrorActionFlags.None\n          };\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.levels[hls.loadLevel];\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.levels[hls.loadLevel];\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          } else {\n            this.keySystemError(data);\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = {\n          action: NetworkErrorAction.DoNothing,\n          flags: ErrorActionFlags.None\n        };\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.keySystemError(data);\n    }\n  }\n  keySystemError(data) {\n    const levelIndex = this.getVariantLevelIndex(data.frag);\n    // Do not retry level. Escalate to fatal if switching levels fails.\n    data.levelRetry = false;\n    data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      var _data$frag2, _data$context2;\n      const errorDetails = data.details;\n      level.loadError++;\n      if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n        level.fragmentError++;\n      }\n      // Search for next level to retry\n      let nextLevel = -1;\n      const {\n        levels,\n        loadLevel,\n        minAutoLevel,\n        maxAutoLevel\n      } = hls;\n      if (!hls.autoLevelEnabled) {\n        hls.loadLevel = -1;\n      }\n      const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n      // Find alternate audio codec if available on audio codec error\n      const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findAudioCodecAlternate = isAudioCodecError && levels.some(({\n        audioCodec\n      }) => level.audioCodec !== audioCodec);\n      // Find alternate video codec if available on video codec error\n      const isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findVideoCodecAlternate = isVideoCodecError && levels.some(({\n        codecSet,\n        audioCodec\n      }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);\n      const {\n        type: playlistErrorType,\n        groupId: playlistErrorGroupId\n      } = (_data$context2 = data.context) != null ? _data$context2 : {};\n      for (let i = levels.length; i--;) {\n        const candidate = (i + loadLevel) % levels.length;\n        if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n          var _level$audioGroups, _level$subtitleGroups;\n          const levelCandidate = levels[candidate];\n          // Skip level switch if GAP tag is found in next level at same position\n          if (errorDetails === ErrorDetails.FRAG_GAP && data.frag) {\n            const levelDetails = levels[candidate].details;\n            if (levelDetails) {\n              const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n              if (fragCandidate != null && fragCandidate.gap) {\n                continue;\n              }\n            }\n          } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n            // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(groupId => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(groupId => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n            // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          }\n          nextLevel = candidate;\n          break;\n        }\n      }\n      if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n        data.levelRetry = true;\n        this.playlistError = 0;\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.None,\n          nextAutoLevel: nextLevel\n        };\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n          this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n          this.hls.recoverMediaError();\n        }\n        break;\n      case NetworkErrorAction.RetryRequest:\n        // handled by stream and playlist/level controllers\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n    }\n  }\n}\nclass BasePlaylistController {\n  constructor(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.requestScheduled = -1;\n    this.canLoad = false;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    if (this.timer !== -1) {\n      self.clearTimeout(this.timer);\n      this.timer = -1;\n    }\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.requestScheduled = -1;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    if (this.requestScheduled === -1) {\n      this.requestScheduled = self.performance.now();\n    }\n    // Loading is handled by the subclasses\n  }\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  shouldReloadPlaylist(playlist) {\n    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      details.reloaded(previousDetails);\n      if (previousDetails) {\n        this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);\n      }\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n      }\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const lastPart = lastPartSn === endSn;\n        // When low latency mode is disabled, we'll skip part requests once the last part index is found\n        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload || details.canSkipUntil) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.updated && now > this.requestScheduled + reloadInterval) {\n        this.requestScheduled = stats.loading.start;\n      }\n      if (msn !== undefined && details.canBlockReload) {\n        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n        this.requestScheduled = now;\n      } else if (this.requestScheduled - now <= 0) {\n        this.requestScheduled += reloadInterval;\n      }\n      let estimatedTimeUntilUpdate = this.requestScheduled - now;\n      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n      // this.log(\n      //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n      // reload in ${estimatedTimeUntilUpdate / 1000}\n      // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n      // diff ${\n      //   (reloadInterval -\n      //     (estimatedTimeUntilUpdate +\n      //       stats.loading.end -\n      //       stats.loading.start)) /\n      //   1000\n      // }\n      // reload interval ${reloadInterval / 1000}\n      // target duration ${details.targetduration}\n      // distance to edge ${distanceToLiveEdgeMs / 1000}`\n      // );\n\n      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n    } else {\n      this.clearTimer();\n    }\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details, msn);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      this.requestScheduled = -1;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  destroy() {}\n}\n\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */\nfunction isHdrSupported() {\n  if (typeof matchMedia === 'function') {\n    const mediaQueryList = matchMedia('(dynamic-range: high)');\n    const badQuery = matchMedia('bad query');\n    if (mediaQueryList.media !== badQuery.media) {\n      return mediaQueryList.matches === true;\n    }\n  }\n  return false;\n}\n\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */\nfunction getVideoSelectionOptions(currentVideoRange, videoPreference) {\n  let preferHDR = false;\n  let allowedVideoRanges = [];\n  if (currentVideoRange) {\n    preferHDR = currentVideoRange !== 'SDR';\n    allowedVideoRanges = [currentVideoRange];\n  }\n  if (videoPreference) {\n    allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n    preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();\n    if (preferHDR) {\n      allowedVideoRanges = allowedVideoRanges.filter(range => range !== 'SDR');\n    } else {\n      allowedVideoRanges = ['SDR'];\n    }\n  }\n  return {\n    preferHDR,\n    allowedVideoRanges\n  };\n}\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n  const codecSets = Object.keys(codecTiers);\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n  // Use first level set to determine stereo, and minimum resolution and framerate\n  let hasStereo = true;\n  let hasCurrentVideoRange = false;\n  let minHeight = Infinity;\n  let minFramerate = Infinity;\n  let minBitrate = Infinity;\n  let selectedScore = 0;\n  let videoRanges = [];\n  const {\n    preferHDR,\n    allowedVideoRanges\n  } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n  for (let i = codecSets.length; i--;) {\n    const tier = codecTiers[codecSets[i]];\n    hasStereo = tier.channels[2] > 0;\n    minHeight = Math.min(minHeight, tier.minHeight);\n    minFramerate = Math.min(minFramerate, tier.minFramerate);\n    minBitrate = Math.min(minBitrate, tier.minBitrate);\n    const matchingVideoRanges = allowedVideoRanges.filter(range => tier.videoRanges[range] > 0);\n    if (matchingVideoRanges.length > 0) {\n      hasCurrentVideoRange = true;\n      videoRanges = matchingVideoRanges;\n    }\n  }\n  minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n  minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n  const maxHeight = Math.max(1080, minHeight);\n  const maxFramerate = Math.max(30, minFramerate);\n  minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n  currentBw = Math.max(minBitrate, currentBw);\n  // If there are no variants with matching preference, set currentVideoRange to undefined\n  if (!hasCurrentVideoRange) {\n    currentVideoRange = undefined;\n    videoRanges = [];\n  }\n  const codecSet = codecSets.reduce((selected, candidate) => {\n    // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n    const candidateTier = codecTiers[candidate];\n    if (candidate === selected) {\n      return selected;\n    }\n    if (candidateTier.minBitrate > currentBw) {\n      logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n      return selected;\n    }\n    if (!candidateTier.hasDefaultAudio) {\n      logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n      return selected;\n    }\n    if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n      logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n      return selected;\n    }\n    if (channelsPreference && !preferStereo) {\n      if (!candidateTier.channels[channelsPreference]) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n        return selected;\n      }\n    } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n      logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n      return selected;\n    }\n    if (candidateTier.minHeight > maxHeight) {\n      logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n      return selected;\n    }\n    if (candidateTier.minFramerate > maxFramerate) {\n      logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n      return selected;\n    }\n    if (!videoRanges.some(range => candidateTier.videoRanges[range] > 0)) {\n      logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);\n      return selected;\n    }\n    if (candidateTier.maxScore < selectedScore) {\n      logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n      return selected;\n    }\n    // Remove candiates with less preferred codecs or more errors\n    if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n      return selected;\n    }\n    selectedScore = candidateTier.maxScore;\n    return candidate;\n  }, undefined);\n  return {\n    codecSet,\n    videoRanges,\n    preferHDR,\n    minFramerate,\n    minBitrate\n  };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n  logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n  return allAudioTracks.reduce((audioTracksByGroup, track) => {\n    let trackGroup = audioTracksByGroup.groups[track.groupId];\n    if (!trackGroup) {\n      trackGroup = audioTracksByGroup.groups[track.groupId] = {\n        tracks: [],\n        channels: {\n          2: 0\n        },\n        hasDefault: false,\n        hasAutoSelect: false\n      };\n    }\n    trackGroup.tracks.push(track);\n    const channelsKey = track.channels || '2';\n    trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n    trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n    trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n    if (trackGroup.hasDefault) {\n      audioTracksByGroup.hasDefaultAudio = true;\n    }\n    if (trackGroup.hasAutoSelect) {\n      audioTracksByGroup.hasAutoSelectAudio = true;\n    }\n    return audioTracksByGroup;\n  }, {\n    hasDefaultAudio: false,\n    hasAutoSelectAudio: false,\n    groups: {}\n  });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n  return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level) => {\n    if (!level.codecSet) {\n      return tiers;\n    }\n    const audioGroups = level.audioGroups;\n    let tier = tiers[level.codecSet];\n    if (!tier) {\n      tiers[level.codecSet] = tier = {\n        minBitrate: Infinity,\n        minHeight: Infinity,\n        minFramerate: Infinity,\n        maxScore: 0,\n        videoRanges: {\n          SDR: 0\n        },\n        channels: {\n          '2': 0\n        },\n        hasDefaultAudio: !audioGroups,\n        fragmentError: 0\n      };\n    }\n    tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n    const lesserWidthOrHeight = Math.min(level.height, level.width);\n    tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n    tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n    tier.maxScore = Math.max(tier.maxScore, level.score);\n    tier.fragmentError += level.fragmentError;\n    tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n    if (audioGroups) {\n      audioGroups.forEach(audioGroupId => {\n        if (!audioGroupId) {\n          return;\n        }\n        const audioGroup = audioTracksByGroup.groups[audioGroupId];\n        // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n        tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n        Object.keys(audioGroup.channels).forEach(channels => {\n          tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n        });\n      });\n    }\n    return tiers;\n  }, {});\n}\nclass AbrController {\n  constructor(_hls) {\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this._nextAutoLevel = -1;\n    this.nextAutoLevelKey = '';\n    this.audioTracksByGroup = null;\n    this.codecTiers = null;\n    this.timer = -1;\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */\n    this._abandonRulesCheck = () => {\n      const {\n        fragCurrent: frag,\n        partCurrent: part,\n        hls\n      } = this;\n      const {\n        autoLevelEnabled,\n        media\n      } = hls;\n      if (!frag || !media) {\n        return;\n      }\n      const now = performance.now();\n      const stats = part ? part.stats : frag.stats;\n      const duration = part ? part.duration : frag.duration;\n      const timeLoading = now - stats.loading.start;\n      const minAutoLevel = hls.minAutoLevel;\n      // If frag loading is aborted, complete, or from lowest level, stop timer and return\n      if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n        return;\n      }\n\n      // This check only runs if we're in ABR mode and actually playing\n      if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n        return;\n      }\n      const bufferInfo = hls.mainForwardBufferInfo;\n      if (bufferInfo === null) {\n        return;\n      }\n      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n      const playbackRate = Math.abs(media.playbackRate);\n      // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n      if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n        return;\n      }\n\n      // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n      const bufferStarvationDelay = bufferInfo.len / playbackRate;\n      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n      const loadedFirstByte = stats.loaded && ttfb > -1;\n      const bwEstimate = this.getBwEstimate();\n      const levels = hls.levels;\n      const level = levels[frag.level];\n      const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));\n      let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n      if (timeStreaming < 1 && loadedFirstByte) {\n        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n      }\n      const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n      // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n      // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n      if (fragLoadedDelay <= bufferStarvationDelay) {\n        return;\n      }\n      const bwe = loadRate ? loadRate * 8 : bwEstimate;\n      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n      let nextLoadLevel;\n      // Iterate through lower level and try to find the largest one that avoids rebuffering\n      for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n        // compute time to load next fragment at lower level\n        // 8 = bits per byte (bps/Bps)\n        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n          break;\n        }\n      }\n      // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n      // to load the current one\n      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n        return;\n      }\n\n      // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n      if (fragLevelNextLoadedDelay > duration * 10) {\n        return;\n      }\n      hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n      if (loadedFirstByte) {\n        // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n      } else {\n        // If there has been no loading progress, sample TTFB\n        this.bwEstimator.sampleTTFB(timeLoading);\n      }\n      const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n      if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {\n        this.resetEstimator(nextLoadLevelBitrate);\n      }\n      this.clearTimer();\n      logger.warn(`[abr] Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown'} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n        frag,\n        part,\n        stats\n      });\n    };\n    this.hls = _hls;\n    this.bwEstimator = this.initEstimator();\n    this.registerListeners();\n  }\n  resetEstimator(abrEwmaDefaultEstimate) {\n    if (abrEwmaDefaultEstimate) {\n      logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n      this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n    }\n    this.firstSelection = -1;\n    this.bwEstimator = this.initEstimator();\n  }\n  initEstimator() {\n    const config = this.hls.config;\n    return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this._abandonRulesCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onManifestLoading(event, data) {\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this.lastLevelLoadSec = 0;\n    this.fragCurrent = this.partCurrent = null;\n    this.onLevelsUpdated();\n    this.clearTimer();\n  }\n  onLevelsUpdated() {\n    if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n      this.lastLoadedFragLevel = this.fragCurrent.level;\n    }\n    this._nextAutoLevel = -1;\n    this.onMaxAutoLevelUpdated();\n    this.codecTiers = null;\n    this.audioTracksByGroup = null;\n  }\n  onMaxAutoLevelUpdated() {\n    this.firstSelection = -1;\n    this.nextAutoLevelKey = '';\n  }\n  onFragLoading(event, data) {\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    if (!frag.bitrateTest) {\n      var _data$part;\n      this.fragCurrent = frag;\n      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    }\n    this.clearTimer();\n    this.timer = self.setInterval(this._abandonRulesCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  onError(event, data) {\n    if (data.fatal) {\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        break;\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        {\n          const frag = data.frag;\n          const {\n            fragCurrent,\n            partCurrent: part\n          } = this;\n          if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const timeLoading = now - stats.loading.start;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            if (loadedFirstByte) {\n              const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n              this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n              this.bwEstimator.sampleTTFB(timeLoading);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      loading\n    } = data.stats;\n    const timeLoadingMs = loading.end - loading.start;\n    if (isFiniteNumber(timeLoadingMs)) {\n      this.lastLevelLoadSec = timeLoadingMs / 1000;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // reset forced auto level value so that next level will be selected\n    if (frag.level === this._nextAutoLevel) {\n      this._nextAutoLevel = -1;\n    }\n    this.firstSelection = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    } else {\n      // store level id after successful fragment load for playback\n      this.lastLoadedFragLevel = frag.level;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.getBwEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    if (this.timer > -1) {\n      self.clearInterval(this.timer);\n      this.timer = -1;\n    }\n  }\n  get firstAutoLevel() {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    const bwEstimate = this.getBwEstimate();\n    const maxStartDelay = this.hls.config.maxStarvationDelay;\n    const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n    if (abrAutoLevel > -1) {\n      return abrAutoLevel;\n    }\n    const firstLevel = this.hls.firstLevel;\n    const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n    logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n    return clamped;\n  }\n  get forcedAutoLevel() {\n    if (this.nextAutoLevelKey) {\n      return -1;\n    }\n    return this._nextAutoLevel;\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this.forcedAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    const useEstimate = bwEstimator.canEstimate();\n    const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n    // use forced auto level while it hasn't errored more than ABR selection\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n\n    // save result until state has changed\n    this._nextAutoLevel = nextABRAutoLevel;\n    this.nextAutoLevelKey = this.getAutoLevelKey();\n    return nextABRAutoLevel;\n  }\n  getAutoLevelKey() {\n    var _this$hls$mainForward;\n    return `${this.getBwEstimate()}_${(_this$hls$mainForward = this.hls.mainForwardBufferInfo) == null ? void 0 : _this$hls$mainForward.len}`;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel,\n      media\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const avgbw = this.getBwEstimate();\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferInfo = hls.mainForwardBufferInfo;\n    const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    if (bufferStarvationDelay) {\n      const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n      if (_bestLevel >= 0) {\n        return _bestLevel;\n      }\n    }\n    // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n    logger.info(`[abr] ${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${bestLevel}`);\n    if (bestLevel > -1) {\n      return bestLevel;\n    }\n    // If no matching level found, see if min auto level would be a better option\n    const minLevel = hls.levels[minAutoLevel];\n    const autoLevel = hls.levels[hls.loadLevel];\n    if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {\n      return minAutoLevel;\n    }\n    // or if bitrate is not lower, continue to use loadLevel\n    return hls.loadLevel;\n  }\n  getBwEstimate() {\n    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n    var _level$details;\n    const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n    const lastLoadedFragLevel = this.lastLoadedFragLevel;\n    const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n    const {\n      fragCurrent,\n      partCurrent\n    } = this;\n    const {\n      levels,\n      allAudioTracks,\n      loadLevel,\n      config\n    } = this.hls;\n    if (levels.length === 1) {\n      return 0;\n    }\n    const level = levels[selectionBaseLevel];\n    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n    const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n    let currentCodecSet;\n    let currentVideoRange = 'SDR';\n    let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n    const {\n      audioPreference,\n      videoPreference\n    } = config;\n    const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n    if (firstSelection) {\n      if (this.firstSelection !== -1) {\n        return this.firstSelection;\n      }\n      const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n      const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n      const {\n        codecSet,\n        videoRanges,\n        minFramerate,\n        minBitrate,\n        preferHDR\n      } = startTier;\n      currentCodecSet = codecSet;\n      currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n      currentFrameRate = minFramerate;\n      currentBw = Math.max(currentBw, minBitrate);\n      logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);\n    } else {\n      currentCodecSet = level == null ? void 0 : level.codecSet;\n      currentVideoRange = level == null ? void 0 : level.videoRange;\n    }\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    const levelsSkipped = [];\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var _levelInfo$supportedR;\n      const levelInfo = levels[i];\n      const upSwitch = i > selectionBaseLevel;\n      if (!levelInfo) {\n        continue;\n      }\n\n      // skip candidates which change codec-family or video-range,\n      // and which decrease or increase frame-rate for up and down-switch respectfully\n      if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {\n        levelsSkipped.push(i);\n        continue;\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (!upSwitch) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n      const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      const canSwitchWithinTolerance =\n      // if adjusted bw is greater than level bitrate AND\n      adjustedbw >= bitrate && (\n      // no level change, or new level has no error history\n      i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n      if (canSwitchWithinTolerance) {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n          if (levelsSkipped.length) {\n            logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(',')} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${level.codecs}\" ${currentVideoRange}`);\n          }\n          logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);\n        }\n        if (firstSelection) {\n          this.firstSelection = i;\n        }\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    const value = Math.max(this.hls.minAutoLevel, nextLevel);\n    if (this._nextAutoLevel != value) {\n      this.nextAutoLevelKey = '';\n      this._nextAutoLevel = value;\n    }\n  }\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    try {\n      if (media) {\n        const buffered = BufferHelper.getBuffered(media);\n        for (let i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return false;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        const vbuffered = BufferHelper.getBuffered(media);\n        const buffered = [];\n        let i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    buffered.sort(function (a, b) {\n      const diff = a.start - b.start;\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n\n    // bufferStartNext can possibly be undefined based on the conditional logic below\n    let bufferStartNext;\n\n    // bufferStart and bufferEnd are buffer boundaries around current video position\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n  append(operation, type, pending) {\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && !pending) {\n      this.executeNext(type);\n    }\n  }\n  insertAbort(operation, type) {\n    const queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  }\n  appendBlocker(type) {\n    let execute;\n    const promise = new Promise(resolve => {\n      execute = resolve;\n    });\n    const operation = {\n      execute,\n      onStart: () => {},\n      onComplete: () => {},\n      onError: () => {}\n    };\n    this.append(operation, type);\n    return promise;\n  }\n  executeNext(type) {\n    const queue = this.queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (error) {\n        logger.warn(`[buffer-operation-queue]: Exception executing \"${type}\" SourceBuffer operation: ${error}`);\n        operation.onError(error);\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        const sb = this.buffers[type];\n        if (!(sb != null && sb.updating)) {\n          this.shiftAndExecuteNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    return this.queues[type][0];\n  }\n}\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nclass BufferController {\n  constructor(hls) {\n    // The level details used to determine duration, target-duration and live\n    this.details = null;\n    // cache the self generated object url to detect hijack of video tag\n    this._objectUrl = null;\n    // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n    this.operationQueue = void 0;\n    // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n    this.listeners = void 0;\n    this.hls = void 0;\n    // The number of BUFFER_CODEC events received before any sourceBuffers are created\n    this.bufferCodecEventsExpected = 0;\n    // The total number of BUFFER_CODEC events received\n    this._bufferCodecEventsTotal = 0;\n    // A reference to the attached media element\n    this.media = null;\n    // A reference to the active media source\n    this.mediaSource = null;\n    // Last MP3 audio chunk appended\n    this.lastMpegAudioChunk = null;\n    this.appendSource = void 0;\n    // counters\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this._onEndStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.pauseBuffering();\n    };\n    this._onStartStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.resumeBuffering();\n    };\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = () => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      this.log('Media source opened');\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        this.updateMediaElementDuration();\n        this.hls.trigger(Events.MEDIA_ATTACHED, {\n          media,\n          mediaSource: mediaSource\n        });\n      }\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      }\n      this.checkPendingTracks();\n    };\n    this._onMediaSourceClose = () => {\n      this.log('Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      this.log('Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        mediaSrc,\n        _objectUrl\n      } = this;\n      if (mediaSrc !== _objectUrl) {\n        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n      }\n    };\n    this.hls = hls;\n    const logPrefix = '[buffer-controller]';\n    this.appendSource = hls.config.preferManagedMediaSource;\n    this.log = logger.log.bind(logger, logPrefix);\n    this.warn = logger.warn.bind(logger, logPrefix);\n    this.error = logger.error.bind(logger, logPrefix);\n    this._initSourceBuffer();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    this.lastMpegAudioChunk = null;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio || !false) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    const MediaSource = getMediaSource(this.appendSource);\n    if (media && MediaSource) {\n      var _ms$constructor;\n      const ms = this.mediaSource = new MediaSource();\n      this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      ms.addEventListener('startstreaming', this._onStartStreaming);\n      ms.addEventListener('endstreaming', this._onEndStreaming);\n\n      // cache the locally generated object url\n      const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n      // link video and media Source\n      if (this.appendSource) {\n        try {\n          media.removeAttribute('src');\n          // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n          const MMS = self.ManagedMediaSource;\n          media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n          removeSourceChildren(media);\n          addSource(media, objectUrl);\n          media.load();\n        } catch (error) {\n          media.src = objectUrl;\n        }\n      } else {\n        media.src = objectUrl;\n      }\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  onMediaDetaching() {\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      this.log('media source detaching');\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n        }\n      }\n      // Clean up the SourceBuffers by invoking onBufferReset\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n      mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n      mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (this.mediaSrc === _objectUrl) {\n          media.removeAttribute('src');\n          if (this.appendSource) {\n            removeSourceChildren(media);\n          }\n          media.load();\n        } else {\n          this.warn('media|source.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n  }\n  onBufferReset() {\n    this.getSourceBufferTypes().forEach(type => {\n      this.resetBuffer(type);\n    });\n    this._initSourceBuffer();\n  }\n  resetBuffer(type) {\n    const sb = this.sourceBuffer[type];\n    try {\n      if (sb) {\n        var _this$mediaSource;\n        this.removeBufferListeners(type);\n        // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n        // accessing it\n        this.sourceBuffer[type] = undefined;\n        if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n          this.mediaSource.removeSourceBuffer(sb);\n        }\n      }\n    } catch (err) {\n      this.warn(`onBufferReset ${type}`, err);\n    }\n  }\n  onBufferCodecs(event, data) {\n    const sourceBufferCount = this.getSourceBufferTypes().length;\n    const trackNames = Object.keys(data);\n    trackNames.forEach(trackName => {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        const track = this.tracks[trackName];\n        if (track && typeof track.buffer.changeType === 'function') {\n          var _trackCodec;\n          const {\n            id,\n            codec,\n            levelCodec,\n            container,\n            metadata\n          } = data[trackName];\n          const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);\n          const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n          let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n          const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n          if (trackCodec && currentCodec !== nextCodec) {\n            if (trackName.slice(0, 5) === 'audio') {\n              trackCodec = getCodecCompatibleName(trackCodec, this.hls.config.preferManagedMediaSource);\n            }\n            const mimeType = `${container};codecs=${trackCodec}`;\n            this.appendChangeType(trackName, mimeType);\n            this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);\n            this.tracks[trackName] = {\n              buffer: track.buffer,\n              codec,\n              container,\n              levelCodec,\n              metadata,\n              id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        this.pendingTracks[trackName] = data[trackName];\n      }\n    });\n\n    // if sourcebuffers already created, do nothing ...\n    if (sourceBufferCount) {\n      return;\n    }\n    const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n    if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {\n      this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(',')}`);\n      this.bufferCodecEventsExpected = bufferCodecEventsExpected;\n    }\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  }\n  appendChangeType(type, mimeType) {\n    const {\n      operationQueue\n    } = this;\n    const operation = {\n      execute: () => {\n        const sb = this.sourceBuffer[type];\n        if (sb) {\n          this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n          sb.changeType(mimeType);\n        }\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn(`Failed to change ${type} SourceBuffer type`, error);\n      }\n    };\n    operationQueue.append(operation, type, !!this.pendingTracks[type]);\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      hls,\n      operationQueue,\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      frag,\n      part,\n      chunkMeta\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n    const fragStart = frag.start;\n    const operation = {\n      execute: () => {\n        chunkStats.executeStart = self.performance.now();\n        if (checkTimestampOffset) {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            const delta = fragStart - sb.timestampOffset;\n            if (Math.abs(delta) >= 0.1) {\n              this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n              sb.timestampOffset = fragStart;\n            }\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const {\n          sourceBuffer\n        } = this;\n        const timeRanges = {};\n        for (const type in sourceBuffer) {\n          timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n        }\n        this.appendErrors[type] = 0;\n        if (type === 'audio' || type === 'video') {\n          this.appendErrors.audiovideo = 0;\n        } else {\n          this.appendErrors.audio = 0;\n          this.appendErrors.video = 0;\n        }\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: error => {\n        // in case any error occured while appending, put back segment in segments table\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          sourceBufferName: type,\n          frag,\n          part,\n          chunkMeta,\n          error,\n          err: error,\n          fatal: false\n        };\n        if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else {\n          const appendErrorCount = ++this.appendErrors[type];\n          event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer`);\n          if (appendErrorCount >= hls.config.appendErrorMaxRetry) {\n            event.fatal = true;\n          }\n        }\n        hls.trigger(Events.ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type, !!this.pendingTracks[type]);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      operationQueue\n    } = this;\n    const flushOperation = type => ({\n      execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: error => {\n        this.warn(`Failed to remove from ${type} SourceBuffer`, error);\n      }\n    });\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(type => {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  }\n  onFragChanged(event, data) {\n    this.trimBuffers();\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    const ended = this.getSourceBufferTypes().reduce((acc, type) => {\n      const sb = this.sourceBuffer[type];\n      if (sb && (!data.type || data.type === type)) {\n        sb.ending = true;\n        if (!sb.ended) {\n          sb.ended = true;\n          this.log(`${type} sourceBuffer now EOS`);\n        }\n      }\n      return acc && !!(!sb || sb.ended);\n    }, true);\n    if (ended) {\n      this.log(`Queueing mediaSource.endOfStream()`);\n      this.blockBuffers(() => {\n        this.getSourceBufferTypes().forEach(type => {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            sb.ending = false;\n          }\n        });\n        const {\n          mediaSource\n        } = this;\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          if (mediaSource) {\n            this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n          }\n          return;\n        }\n        this.log(`Calling mediaSource.endOfStream()`);\n        // Allow this to throw and be caught by the enqueueing function\n        mediaSource.endOfStream();\n      });\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  }\n  trimBuffers() {\n    const {\n      hls,\n      details,\n      media\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    if (!sourceBufferTypes.length) {\n      return;\n    }\n    const config = hls.config;\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n    if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {\n      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n      this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n    }\n    if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n      const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n      const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n      const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n      this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n    }\n  }\n  flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n    const {\n      details,\n      sourceBuffer\n    } = this;\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          if (details != null && details.live) {\n            this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n            this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          this.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n  flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n    const {\n      sourceBuffer\n    } = this;\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        const numBufferedRanges = buffered.length;\n        // The buffer is either empty or contiguous\n        if (numBufferedRanges < 2) {\n          return;\n        }\n        const bufferStart = buffered.start(numBufferedRanges - 1);\n        const bufferEnd = buffered.end(numBufferedRanges - 1);\n        // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n        if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n          return;\n        } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {\n          this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);\n          return;\n        }\n        this.hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: bufferStart,\n          endOffset: Infinity,\n          type\n        });\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    const {\n      details,\n      hls,\n      media,\n      mediaSource\n    } = this;\n    const levelDuration = details.fragments[0].start + details.totalduration;\n    const mediaDuration = media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n      mediaSource.duration = levelDuration;\n    }\n  }\n  updateSeekableRange(levelDetails) {\n    const mediaSource = this.mediaSource;\n    const fragments = levelDetails.fragments;\n    const len = fragments.length;\n    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n      const start = Math.max(0, fragments[0].start);\n      const end = Math.max(start, start + levelDetails.totalduration);\n      this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsExpected,\n      operationQueue,\n      pendingTracks\n    } = this;\n\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    const pendingTracksCount = Object.keys(pendingTracks).length;\n    if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || 'audiovideo' in pendingTracks)) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {};\n      // append any pending segments now !\n      const buffers = this.getSourceBufferTypes();\n      if (buffers.length) {\n        this.hls.trigger(Events.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n        buffers.forEach(type => {\n          operationQueue.executeNext(type);\n        });\n      } else {\n        const error = new Error('could not create source buffer for media codec(s)');\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          error,\n          reason: error.message\n        });\n      }\n    }\n  }\n  createSourceBuffers(tracks) {\n    const {\n      sourceBuffer,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        const track = tracks[trackName];\n        if (!track) {\n          throw Error(`source buffer exists for track ${trackName}, however track does not`);\n        }\n        // use levelCodec as first priority\n        let codec = track.levelCodec || track.codec;\n        if (codec) {\n          if (trackName.slice(0, 5) === 'audio') {\n            codec = getCodecCompatibleName(codec, this.hls.config.preferManagedMediaSource);\n          }\n        }\n        const mimeType = `${track.container};codecs=${codec}`;\n        this.log(`creating sourceBuffer(${mimeType})`);\n        try {\n          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          const sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          // ManagedSourceBuffer bufferedchange event\n          this.addBufferListener(sbName, 'bufferedchange', (type, event) => {\n            // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n            const removedRanges = event.removedRanges;\n            if (removedRanges != null && removedRanges.length) {\n              this.hls.trigger(Events.BUFFER_FLUSHED, {\n                type: trackName\n              });\n            }\n          });\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n        } catch (err) {\n          this.error(`error while trying to add sourceBuffer: ${err.message}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            sourceBufferName: trackName,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n  }\n  get mediaSrc() {\n    var _this$media;\n    const media = ((_this$media = this.media) == null ? void 0 : _this$media.firstChild) || this.media;\n    return media == null ? void 0 : media.src;\n  }\n  _onSBUpdateStart(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onStart();\n  }\n  _onSBUpdateEnd(type) {\n    var _this$mediaSource2;\n    if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === 'closed') {\n      this.resetBuffer(type);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  }\n  _onSBUpdateError(type, event) {\n    var _this$mediaSource3;\n    const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState}`);\n    this.error(`${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      sourceBufferName: type,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.operationQueue.current(type);\n    if (operation) {\n      operation.onError(error);\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource,\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!media || !mediaSource || !sb) {\n      this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && (!sb.ending || sb.ended)) {\n      sb.ended = false;\n      this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const sb = this.sourceBuffer[type];\n    if (!sb) {\n      if (!this.pendingTracks[type]) {\n        throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n      }\n      return;\n    }\n    sb.ended = false;\n    sb.appendBuffer(data);\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n    if (!buffers.length) {\n      this.log('Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = buffers.map(type => operationQueue.appendBlocker(type));\n    Promise.all(blockingOperations).then(() => {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(type => {\n        const sb = this.sourceBuffer[type];\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!(sb != null && sb.updating)) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  }\n  getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  }\n  addBufferListener(type, event, fn) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    this.listeners[type].forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  }\n}\nfunction removeSourceChildren(node) {\n  const sourceChildren = node.querySelectorAll('source');\n  [].slice.call(sourceChildren).forEach(source => {\n    node.removeChild(source);\n  });\n}\nfunction addSource(media, url) {\n  const source = self.document.createElement('source');\n  source.type = 'video/mp4';\n  source.src = url;\n  media.appendChild(source);\n}\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    if (this.hls) {\n      this.unregisterListener();\n    }\n    if (this.timer) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n    if (this.timer && this.hls.levels.length) {\n      this.detectPlayerSize();\n    }\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n      this.detectPlayerSize();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n  }\n  detectPlayerSize() {\n    if (this.media) {\n      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n        this.clientRect = null;\n        return;\n      }\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        const maxLevel = this.getMaxLevel(levels.length - 1);\n        if (maxLevel !== this.autoLevelCapping) {\n          logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n        }\n        hls.autoLevelCapping = maxLevel;\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return pixelRatio;\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n    const squareSize = Math.max(width, height);\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\nclass FPSController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    // stream controller must be provided as a dependency!\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.log = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[content-steering]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  startLoad() {\n    this.started = true;\n    this.clearTimeout();\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n        if (ttl > 0) {\n          this.scheduleRefresh(this.uri, ttl);\n          return;\n        }\n      }\n      this.loadSteeringManifest(this.uri);\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    this.clearTimeout();\n  }\n  clearTimeout() {\n    if (this.reloadTimer !== -1) {\n      self.clearTimeout(this.reloadTimer);\n      this.reloadTimer = -1;\n    }\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      const levels = this.levels;\n      let pathwayPriority = this.pathwayPriority;\n      let errorPathway = this.pathwayId;\n      if (data.context) {\n        const {\n          groupId,\n          pathwayId,\n          type\n        } = data.context;\n        if (groupId && levels) {\n          errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n        } else if (pathwayId) {\n          errorPathway = pathwayId;\n        }\n      }\n      if (!(errorPathway in this.penalizedPathways)) {\n        this.penalizedPathways[errorPathway] = performance.now();\n      }\n      if (!pathwayPriority && levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = levels.reduce((pathways, level) => {\n          if (pathways.indexOf(level.pathwayId) === -1) {\n            pathways.push(level.pathwayId);\n          }\n          return pathways;\n        }, []);\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== errorPathway;\n      }\n      if (!errorAction.resolved) {\n        logger.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n      return pathwayLevels;\n    }\n    return levels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this.pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (pathwayId in penalizedPathways) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        reassignFragmentLevelIndexes(levels);\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  getPathwayForGroupId(groupId, type, defaultPathway) {\n    const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n    for (let i = 0; i < levels.length; i++) {\n      if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n        return levels[i].pathwayId;\n      }\n    }\n    return defaultPathway;\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        const url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const clonedLevel = new Level({\n          attrs: attributes,\n          audioCodec: baseLevel.audioCodec,\n          bitrate: baseLevel.bitrate,\n          height: baseLevel.height,\n          name: baseLevel.name,\n          url,\n          videoCodec: baseLevel.videoCodec,\n          width: baseLevel.width\n        });\n        if (baseLevel.audioGroups) {\n          for (let i = 1; i < baseLevel.audioGroups.length; i++) {\n            clonedLevel.addGroupId('audio', `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        if (baseLevel.subtitleGroups) {\n          for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {\n            clonedLevel.addGroupId('text', `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if (steeringData.VERSION !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        const loadedSteeringData = {\n          steeringManifest: steeringData,\n          url: url.toString()\n        };\n        this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    this.clearTimeout();\n    this.reloadTimer = self.setTimeout(() => {\n      var _this$hls;\n      const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n      if (media && !media.ended) {\n        this.loadSteeringManifest(uri);\n        return;\n      }\n      this.scheduleRefresh(uri, this.timeToLoad * 1000);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = null;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n    this.context = null;\n    this.xhrSetup = null;\n    // @ts-ignore\n    this.stats = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config || !context) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        this.callbacks.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponse = xhr.responseType !== 'text';\n        if (status >= 200 && status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          const data = useResponse ? xhr.response : xhr.responseText;\n          const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n          stats.loaded = stats.total = len;\n          stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n          if (!this.callbacks) {\n            return;\n          }\n          const onProgress = this.callbacks.onProgress;\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n          if (!this.callbacks) {\n            return;\n          }\n          const response = {\n            url: xhr.responseURL,\n            data: data,\n            code: status\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          const retryConfig = config.loadPolicy.errorRetry;\n          const retryCount = stats.retry;\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          const response = {\n            url: context.url,\n            data: undefined,\n            code: status\n          };\n          if (shouldRetry(retryConfig, retryCount, false, response)) {\n            this.retry(retryConfig);\n          } else {\n            logger.error(`${status} while loading ${context.url}`);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr, stats);\n          }\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    var _this$config;\n    const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      var _this$context;\n      logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config /* HlsConfig */) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = null;\n    this.response = null;\n    this.controller = void 0;\n    this.context = null;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = this.context = this.config = this.request = null;\n    this.abortInternal();\n    this.response = null;\n    // @ts-ignore\n    this.fetchSetup = this.controller = this.stats = null;\n  }\n  abortInternal() {\n    if (this.controller && !this.stats.loading.end) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const onProgress = callbacks.onProgress;\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      this.abortInternal();\n      callbacks.onTimeout(stats, context, this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(response => {\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        this.abortInternal();\n        callbacks.onTimeout(stats, context, this.response);\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      const response = this.response;\n      if (!response) {\n        throw new Error('loader destroyed');\n      }\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      callbacks.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  preferManagedMediaSource: true,\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  frontBufferFlushThreshold: Infinity,\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrEwmaDefaultEstimateMax: 5e6,\n  // 5 mbps\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: null,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true,\n  useMediaCapabilities: false,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: undefined,\n  subtitleTrackController: undefined,\n  timelineController: undefined,\n  audioStreamController: undefined,\n  audioTrackController: undefined,\n  emeController: undefined,\n  cmcdController: undefined,\n  contentSteeringController: ContentSteeringController\n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: false,\n    // used by timeline-controller\n    enableIMSC1: false,\n    // used by timeline-controller\n    enableCEA708Captions: false,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, '[level-controller]');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._maxAutoLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  stopLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.stopLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n    this._maxAutoLevel = -1;\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n    const levels = [];\n    const redundantSet = {};\n    const generatePathwaySet = {};\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n    data.levels.forEach(levelParsed => {\n      var _audioCodec, _videoCodec;\n      const attributes = levelParsed.attrs;\n\n      // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n      let {\n        audioCodec,\n        videoCodec\n      } = levelParsed;\n      if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf('mp4a.40.34')) !== -1) {\n        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n        if (chromeOrFirefox) {\n          levelParsed.audioCodec = audioCodec = undefined;\n        }\n      }\n      if (audioCodec) {\n        levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);\n      }\n      if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf('avc1')) === 0) {\n        videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n      }\n\n      // only keep levels with supported audio/video codecs\n      const {\n        width,\n        height,\n        unknownCodecs\n      } = levelParsed;\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, 'audio', preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, 'video', preferManagedMediaSource)) {\n        return;\n      }\n      const {\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'HDCP-LEVEL': HDCP,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        'VIDEO-RANGE': VIDEO_RANGE\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-`;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n      if (!redundantSet[levelKey]) {\n        const level = new Level(levelParsed);\n        redundantSet[levelKey] = level;\n        generatePathwaySet[levelKey] = 1;\n        levels.push(level);\n      } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n        // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n        // Content Steering controller to handles Pathway fallback on error\n        const pathwayCount = generatePathwaySet[levelKey] += 1;\n        levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n        const level = new Level(levelParsed);\n        redundantSet[levelKey] = level;\n        levels.push(level);\n      } else {\n        redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n        redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n      }\n    });\n    this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n  }\n  filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let levels = filteredLevels;\n\n    // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        videoRange,\n        width,\n        height\n      }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          if (data.levels.length) {\n            this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);\n          }\n          const error = new Error('no level with compatible codecs found in manifest');\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason: error.message\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      const {\n        preferManagedMediaSource\n      } = this.hls.config;\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, 'audio', preferManagedMediaSource));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      // sort on height before bitrate for cap-level-controller\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      if (a.frameRate !== b.frameRate) {\n        return a.frameRate - b.frameRate;\n      }\n      if (a.videoRange !== b.videoRange) {\n        return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n      }\n      if (a.videoCodec !== b.videoCodec) {\n        const valueA = videoCodecPreferenceValue(a.videoCodec);\n        const valueB = videoCodecPreferenceValue(b.videoCodec);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n        const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n        const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.averageBitrate !== b.averageBitrate) {\n        return a.averageBitrate - b.averageBitrate;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        var _this$hls$userConfig;\n        this._firstLevel = i;\n        const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n        const bandwidthEstimate = this.hls.bandwidthEstimate;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n        // Update default bwe to first variant bitrate as long it has not been configured or set\n        if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n          const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n          if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {\n            this.hls.bandwidthEstimate = startingBwEstimate;\n          }\n        }\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n    // Initiate loading after all controllers have received MANIFEST_PARSED\n    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n      this.hls.startLoad(this.hls.config.startPosition);\n    }\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel} (${level.height ? level.height + 'p ' : ''}${level.videoRange ? level.videoRange + ' ' : ''}${level.codecSet ? level.codecSet + ' ' : ''}@${level.bitrate})${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = {\n      level: newLevel,\n      attrs: level.attrs,\n      details: level.details,\n      bitrate: level.bitrate,\n      averageBitrate: level.averageBitrate,\n      maxBitrate: level.maxBitrate,\n      realBitrate: level.realBitrate,\n      width: level.width,\n      height: level.height,\n      codecSet: level.codecSet,\n      audioCodec: level.audioCodec,\n      videoCodec: level.videoCodec,\n      audioGroups: level.audioGroups,\n      subtitleGroups: level.subtitleGroups,\n      loaded: level.loaded,\n      loadError: level.loadError,\n      fragmentError: level.fragmentError,\n      name: level.name,\n      id: level.id,\n      uri: level.uri,\n      url: level.url,\n      urlId: 0,\n      audioGroupIds: level.audioGroupIds,\n      textGroupIds: level.textGroupIds\n    };\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      }\n      return this.hls.firstAutoLevel;\n    }\n    return this._startLevel;\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragBuffered(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const el = frag.elementaryStreams;\n      if (!Object.keys(el).some(type => !!el[type])) {\n        return;\n      }\n      const level = this._levels[frag.level];\n      if (level != null && level.loadError) {\n        this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = this._levels[level];\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentLevelIndex = this.currentLevelIndex;\n    const currentLevel = this.currentLevel;\n    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n      let url = currentLevel.uri;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''} with${pathwayId ? ' Pathway ' + pathwayId : ''} ${url}`);\n\n      // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n      this.clearTimer();\n      this.hls.trigger(Events.LEVEL_LOADING, {\n        url,\n        level: currentLevelIndex,\n        pathwayId: currentLevel.attrs['PATHWAY-ID'],\n        id: 0,\n        // Deprecated Level urlId\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex) {\n    var _this$currentLevel;\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      if (level === this.currentLevel) {\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        if (level.details) {\n          level.details.fragments.forEach(f => f.level = -1);\n        }\n      }\n      return false;\n    });\n    reassignFragmentLevelIndexes(levels);\n    this._levels = levels;\n    if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n      this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n    }\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    this._levels = levels;\n  }\n  checkMaxAutoUpdated() {\n    const {\n      autoLevelCapping,\n      maxAutoLevel,\n      maxHdcpLevel\n    } = this.hls;\n    if (this._maxAutoLevel !== maxAutoLevel) {\n      this._maxAutoLevel = maxAutoLevel;\n      this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n        autoLevelCapping,\n        levels: this.levels,\n        maxAutoLevel,\n        minAutoLevel: this.hls.minAutoLevel,\n        maxHdcpLevel\n      });\n    }\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    const {\n      frag,\n      part\n    } = data;\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = activeParts.filter(part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        const start = Math.max(startPTS, timeRange.start(i));\n        const end = Math.min(endPTS, timeRange.end(i));\n        if (end > start) {\n          buffered.partial = true;\n          // Check for intersection with buffer\n          // Get playable sections of the fragment\n          buffered.time.push({\n            startPTS: start,\n            endPTS: end\n          });\n        }\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (frag.sn === 'initSegment' || frag.bitrateTest) {\n      return;\n    }\n\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const timeRange = timeRanges[elementaryStream];\n      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n    });\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = activeParts.filter(part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        },\n        onProgress: (stats, context, data, networkDetails) => {\n          if (onProgress) {\n            onProgress({\n              frag,\n              part: null,\n              payload: data,\n              networkDetails\n            });\n          }\n        }\n      });\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n      // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        var _loader$context;\n        if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments) {\n    if (this.emeController && this.config.emeEnabled) {\n      // access key-system with nearest key on start (loaidng frag is unencrypted)\n      const {\n        sn,\n        cc\n      } = loadingFrag;\n      for (let i = 0; i < encryptedFragments.length; i++) {\n        const frag = encryptedFragments[i];\n        if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n          this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n            frag.setKeyFormat(keySystemFormat);\n          });\n          break;\n        }\n      }\n    }\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop {\n  constructor() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\nfunction findFirstFragWithCC(fragments, cc) {\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    var _fragments$i;\n    if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n      return fragments[i];\n    }\n  }\n  return null;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {\n  if (switchDetails) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n  const prevFrags = prevDetails.fragments;\n  const curFrags = curDetails.fragments;\n  if (!curFrags.length || !prevFrags.length) {\n    logger.log('No fragments to align');\n    return;\n  }\n  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    logger.log('No frag in previous level to align on');\n    return;\n  }\n  return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\nfunction alignStream(lastFrag, switchDetails, details) {\n  if (!switchDetails) {\n    return;\n  }\n  alignDiscontinuities(lastFrag, details, switchDetails);\n  if (!details.alignedSliding && switchDetails) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignMediaPlaylistByPDT(details, switchDetails);\n  }\n  if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(switchDetails, details);\n  }\n}\n\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(lastFrag, details, switchDetails) {\n  if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {\n    const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);\n    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  let refFrag;\n  let frag;\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n    refFrag = findFirstFragWithCC(refFragments, targetCC);\n    frag = findFirstFragWithCC(fragments, targetCC);\n  }\n  if (!refFrag || !frag) {\n    refFrag = refFragments[Math.floor(refFragments.length / 2)];\n    frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n  }\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (!refPDT || !targetPDT) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\nclass AESCrypto {\n  constructor(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n  decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  }\n}\nclass FastAESKey {\n  constructor(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n  expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    if (this.subtle === null) {\n      this.useSoftware = true;\n    }\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv) {\n    const subtle = this.subtle;\n    if (this.key !== key || !this.fastAesKey) {\n      this.key = key;\n      this.fastAesKey = new FastAESKey(subtle, key);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(subtle, new Uint8Array(iv));\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv);\n    });\n  }\n  onWebCryptoError(data, key, iv) {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    const decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = sliceUint8(data, 0, splitPoint);\n      this.remainderData = sliceUint8(data, splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super();\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.loadedmetadata = false;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.onvseeking = null;\n    this.onvended = null;\n    this.logPrefix = '';\n    this.log = void 0;\n    this.warn = void 0;\n    this.playlistType = playlistType;\n    this.logPrefix = logPrefix;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n    // of nothing loading/loaded return false\n    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levelLastLoaded;\n      return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n    }\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching() {\n    const media = this.media;\n    if (media != null && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    if (media && this.onvseeking && this.onvended) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n    if (this.keyLoader) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onMediaSeeking() {\n    const {\n      config,\n      fragCurrent,\n      media,\n      mediaBuffer,\n      state\n    } = this;\n    const currentTime = media ? media.currentTime : 0;\n    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent) {\n      // Seeking while frag load is in progress\n      const tolerance = config.maxFragLookUpTolerance;\n      const fragStartOffset = fragCurrent.start - tolerance;\n      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      // if seeking out of buffered range or into new one\n      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n        const pastFragment = currentTime > fragEndOffset;\n        // if the seek position is outside the current fragment range\n        if (currentTime < fragStartOffset || pastFragment) {\n          if (pastFragment && fragCurrent.loader) {\n            this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n            fragCurrent.abortRequests();\n            this.resetLoadingState();\n          }\n          this.fragPrevious = null;\n        }\n      }\n    }\n    if (media) {\n      // Remove gap fragments\n      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n      this.lastCurrentTime = currentTime;\n    }\n\n    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    }\n\n    // Async tick to speed up processing\n    this.tickImmediate();\n  }\n  onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  }\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n    this.initPTS = [];\n  }\n  onHandlerDestroying() {\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.stopLoad();\n    super.onHandlerDestroying();\n    // @ts-ignore\n    this.hls = null;\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(frag, level, targetBufferTime) {\n    const progressCallback = data => {\n      if (this.fragContextChanged(frag)) {\n        this.warn(`Fragment ${frag.sn}${data.part ? ' p: ' + data.part.index : ''} of level ${frag.level} was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the buffer size and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  checkLiveUpdate(details) {\n    if (details.updated && !details.live) {\n      // Live stream ended, update fragment tracker\n      const lastFragment = details.fragments[details.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: lastFragment,\n        part: null,\n        stats: lastFragment.stats,\n        id: lastFragment.type\n      });\n    }\n    if (!details.fragments[0]) {\n      details.deltaUpdateFailed = true;\n    }\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(frag, level) {\n    this._doFragLoad(frag, level).then(data => {\n      if (!data || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return this.completeInitSegmentLoad(data);\n        });\n      }\n      return this.completeInitSegmentLoad(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  completeInitSegmentLoad(data) {\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      throw new Error('init load aborted, missing levels');\n    }\n    const stats = data.frag.stats;\n    this.state = State.IDLE;\n    data.frag.data = new Uint8Array(data.payload);\n    stats.parsing.start = stats.buffering.start = self.performance.now();\n    stats.parsing.end = stats.buffering.end = self.performance.now();\n    this.tick();\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n  }\n  fragBufferedComplete(frag, part) {\n    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track'} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    if (frag.sn !== 'initSegment') {\n      var _this$levels;\n      if (frag.type !== PlaylistLevelType.SUBTITLE) {\n        const el = frag.elementaryStreams;\n        if (!Object.keys(el).some(type => !!el[type])) {\n          // empty segment\n          this.state = State.IDLE;\n          return;\n        }\n      }\n      const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n      if (level != null && level.fragmentError) {\n        this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n        level.fragmentError = 0;\n      }\n    }\n    this.state = State.IDLE;\n    if (!media) {\n      return;\n    }\n    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    }\n    this.tick();\n  }\n  seekToStartPos() {}\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted && details.encryptedFragments.length) {\n      this.keyLoader.loadClear(frag, details.encryptedFragments);\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type) {\n    const {\n      config: {\n        maxBufferHole\n      }\n    } = this;\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold) {\n    const config = this.config;\n    const minLength = threshold || config.maxBufferLength;\n    if (config.maxMaxBufferLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength /= 2;\n      this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    let frag;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(frag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    const gapStart = frag.gap;\n    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    if (nextFragment === null) {\n      return nextFragment;\n    }\n    frag = nextFragment;\n    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n      // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n        // Returning here might result in not finding an audio and video candiate to skip to\n        this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n        return null;\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails, fragments) {\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findFragWithCC(fragments, fragPrevious.cc);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const tolerance = config.maxFragLookUpTolerance;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = media.currentTime;\n    const start = levelDetails.fragments[0].start;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  }\n  alignPlaylists(details, previousDetails, switchDetails) {\n    // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragments[0].start;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      const {\n        fragPrevious\n      } = this;\n      alignStream(fragPrevious, switchDetails, details);\n      const alignedSlidingStart = details.fragments[0].start;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : 'na'} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist, adjust startPosition to ${startPosition}`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition;\n    }\n    this.nextLoadPosition = startPosition;\n  }\n  getLoadPosition() {\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent2;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n          errorAction.resolved = true;\n        }\n      } else {\n        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n        return;\n      }\n    } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (data.frag) {\n        this.fragmentTracker.removeFragment(data.frag);\n        this.nextLoadPosition = data.frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      const details = level ? level.details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded(this.levelLastLoaded);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    var _this$transmuxer;\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        level.fragmentError++;\n        frag.gap = true;\n        this.fragmentTracker.removeFragment(frag);\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        frag,\n        reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n      });\n      if (!this.hls) {\n        return;\n      }\n      this.resetTransmuxer();\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n    this.state = State.PARSED;\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      this.fragmentTracker.removeAllFragments();\n      this.resetTransmuxer();\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBuffer = getSourceBuffer();\n  return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n}\nfunction isSupported() {\n  if (!isMSESupported()) {\n    return false;\n  }\n  const mediaSource = getMediaSource();\n  return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(codecsForVideoContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'))) || ['mp4a.40.2', 'fLaC'].some(codecForAudioContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'))));\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  return {\n    worker,\n    objectURL\n  };\n}\nfunction loadWorker(path) {\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  return {\n    worker,\n    scriptURL\n  };\n}\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getID3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParse$2(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = getID3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = sliceUint8(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {}\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  let adtsObjectType;\n  let adtsExtensionSamplingIndex;\n  let adtsChannelConfig;\n  let config;\n  const userAgent = navigator.userAgent.toLowerCase();\n  const manifestCodec = audioCodec;\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      error,\n      reason: error.message\n    });\n    return;\n  }\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n  // byte 3\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChannelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSamplingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return {\n    config,\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\n    channelCount: adtsChannelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\nfunction appendFrame(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getID3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n    if (probe(data, offset)) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    return hasMoofData(data);\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {}\n}\nconst getAudioBSID = (data, offset) => {\n  // check the bsid to confirm ac-3 | ec-3\n  let bsid = 0;\n  let numBits = 5;\n  offset += numBits;\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n  while (numBits > 0) {\n    byte[0] = data[offset];\n    // read remaining bits, upto 8 bits at a time\n    const bits = Math.min(numBits, 8);\n    const shift = 8 - bits;\n    mask[0] = 0xff000000 >>> 24 + shift << shift;\n    temp[0] = (byte[0] & mask[0]) >> shift;\n    bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n    offset += 1;\n    numBits -= bits;\n  }\n  return bsid;\n};\nclass BaseVideoParser {\n  constructor() {\n    this.VideoSample = null;\n  }\n  createVideoSample(key, pts, dts, debug) {\n    return {\n      key,\n      frame: false,\n      pts,\n      dts,\n      units: [],\n      debug,\n      length: 0\n    };\n  }\n  getLastNalUnit(samples) {\n    var _VideoSample;\n    let VideoSample = this.VideoSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!VideoSample || VideoSample.units.length === 0) {\n      VideoSample = samples[samples.length - 1];\n    }\n    if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n      const units = VideoSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    if (VideoSample.units.length && VideoSample.frame) {\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n      if (VideoSample.pts === undefined) {\n        const samples = videoTrack.samples;\n        const nbSamples = samples.length;\n        if (nbSamples) {\n          const lastSample = samples[nbSamples - 1];\n          VideoSample.pts = lastSample.pts;\n          VideoSample.dts = lastSample.dts;\n        } else {\n          // dropping samples, no timestamp found\n          videoTrack.dropped++;\n          return;\n        }\n      }\n      videoTrack.samples.push(VideoSample);\n    }\n    if (VideoSample.debug.length) {\n      logger.log(VideoSample.pts + '/' + VideoSample.dts + ':' + VideoSample.debug);\n    }\n  }\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS() {\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = this.readUByte.bind(this);\n    const readBits = this.readBits.bind(this);\n    const readUEG = this.readUEG.bind(this);\n    const readBoolean = this.readBoolean.bind(this);\n    const skipBits = this.skipBits.bind(this);\n    const skipEG = this.skipEG.bind(this);\n    const skipUEG = this.skipUEG.bind(this);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n  readSliceType() {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  }\n}\nclass AvcVideoParser extends BaseVideoParser {\n  parseAVCPES(track, textTrack, pes, last, duration) {\n    const units = this.parseAVCNALu(track, pes.data);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');\n    }\n    units.forEach(unit => {\n      var _VideoSample2;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = new ExpGolomb(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _VideoSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                this.pushAccessUnit(VideoSample, track);\n                VideoSample = this.VideoSample = null;\n              }\n            }\n            if (!VideoSample) {\n              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');\n            }\n            VideoSample.frame = true;\n            VideoSample.key = iskey;\n            break;\n            // IDR\n          }\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n        case 7:\n          {\n            var _track$pixelRatio, _track$pixelRatio2;\n            push = true;\n            spsfound = true;\n            const sps = unit.data;\n            const expGolombDecoder = new ExpGolomb(sps);\n            const config = expGolombDecoder.readSPS();\n            if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [sps];\n              track.duration = duration;\n              const codecarray = sps.subarray(1, 4);\n              let codecstring = 'avc1.';\n              for (let i = 0; i < 3; i++) {\n                let h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          }\n        // PPS\n        case 8:\n          push = true;\n          track.pps = [unit.data];\n          break;\n        // AUD\n        case 9:\n          push = true;\n          track.audFound = true;\n          if (VideoSample) {\n            this.pushAccessUnit(VideoSample, track);\n          }\n          VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          if (VideoSample) {\n            VideoSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  parseAVCNALu(track, array) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        overflow = i - state - 1;\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, overflow),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._videoTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.videoParser = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.videoParser = new AvcVideoParser();\n  }\n  static probe(data) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._videoTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _videoTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_videoTrack) {\n      _videoTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._videoTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let videoPid = videoTrack.pid;\n    let videoData = videoTrack.pesData;\n    let audioPid = audioTrack.pid;\n    let id3Pid = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case videoPid:\n            if (stt) {\n              if (videoData && (pes = parsePES(videoData))) {\n                this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);\n              }\n              videoData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (videoData) {\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              videoData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioPid:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Pid:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              videoPid = parsedPIDs.videoPid;\n              if (videoPid > 0) {\n                videoTrack.pid = videoPid;\n                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n              }\n              audioPid = parsedPIDs.audioPid;\n              if (audioPid > 0) {\n                audioTrack.pid = audioPid;\n                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n              }\n              id3Pid = parsedPIDs.id3Pid;\n              if (id3Pid > 0) {\n                id3Track.pid = id3Pid;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        reason: error.message\n      });\n    }\n    videoTrack.pesData = videoData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._videoTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const videoData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (videoData && (pes = parsePES(videoData))) {\n      this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = videoData;\n    }\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    this._duration = 0;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      const error = new Error(reason);\n      logger.warn(`parsing error: ${reason}`);\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        levelRetry: recoverable,\n        error,\n        reason\n      });\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$1(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseAC3PES(track, pes) {}\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n  const result = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: 'avc',\n    segmentAudioCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC');\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audioPid === -1) {\n          result.audioPid = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3Pid === -1) {\n          result.id3Pid = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('H.264');\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.videoPid === -1) {\n          result.videoPid = pid;\n          result.segmentVideoCodec = 'avc';\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audioPid === -1) {\n          result.audioPid = pid;\n          result.segmentAudioCodec = 'mp3';\n        }\n        break;\n      case 0xc1:\n        // SAMPLE-AES AC3\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3');\n          break;\n        }\n      /* falls through */\n      case 0x81:\n        {\n          logger.warn('AC-3 in M2TS support not included in build');\n        }\n        break;\n      case 0x06:\n        // stream_type 6 can mean a lot of different things in case of DVB.\n        // We need to look at the descriptors. Right now, we're only interested\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\n        // an audio PID yet.\n        if (result.audioPid === -1 && esInfoLength > 0) {\n          let parsePos = offset + 5;\n          let remaining = esInfoLength;\n          while (remaining > 2) {\n            const descriptorId = data[parsePos];\n            switch (descriptorId) {\n              case 0x6a:\n                // DVB Descriptor for AC-3\n                {\n                  logger.warn('AC-3 in M2TS support not included in build');\n                }\n                break;\n            }\n            const descriptorLen = data[parsePos + 1] + 2;\n            parsePos += descriptorLen;\n            remaining -= descriptorLen;\n          }\n        }\n        break;\n      case 0xc2: // SAMPLE-AES EC3\n      /* falls through */\n      case 0x87:\n        logger.warn('Unsupported EC-3 in M2TS found');\n        break;\n      case 0x24:\n        logger.warn('Unsupported HEVC in M2TS found');\n        break;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += esInfoLength + 5;\n  }\n  return result;\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type) {\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    data[0] = appendUint8Array(data[0], data[1]);\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getID3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n    // Check for ac-3|ec-3 sync bytes and return false if present\n    if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3 or ec-3 (not mp3)\n    getAudioBSID(data, offset) <= 16) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      dac3: [],\n      'ac-3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const configlen = track.config.length;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x17 + configlen,\n    // length\n    0x00, 0x01,\n    // es_id\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x0f + configlen,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  }\n  static audioStsd(track) {\n    const samplerate = track.samplerate;\n    return new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]);\n  }\n  static mp4a(track) {\n    return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n  }\n  static ac3(track) {\n    return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n  }\n  static stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n      if (track.segmentCodec === 'ac3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n      }\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = track.duration * track.timescale;\n    const width = track.width;\n    const height = track.height;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = appendUint8Array(MP4.FTYP, movie);\n    return result;\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n  constructor(observer, config, typeSupported, vendor = '') {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.videoTrackConfig = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n  resetTimeStamp(defaultTimeStamp) {\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n    this.videoTrackConfig = undefined;\n  }\n  getVideoStartPts(videoSamples) {\n    let rolloverDetected = false;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      const delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (this.ISGenerated) {\n        var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n        const config = this.videoTrackConfig;\n        if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {\n          this.resetInitSegment();\n        }\n      } else {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n        case 'ac3':\n          audioTrack.codec = 'ac-3';\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n      this.videoTrackConfig = {\n        width: videoTrack.width,\n        height: videoTrack.height,\n        pixelRatio: videoTrack.pixelRatio\n      };\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    let nextAvcDts = this.nextAvcDts;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      const pts = timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n        contiguous = true;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextAvcDts = pts - cts;\n      }\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextAvcDts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n        } else {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n        }\n        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {\n          firstDTS = nextAvcDts;\n          const firstPTS = inputSamples[0].pts - delta;\n          if (foundHole) {\n            inputSamples[0].dts = firstDTS;\n            inputSamples[0].pts = firstPTS;\n          } else {\n            for (let i = 0; i < inputSamples.length; i++) {\n              if (inputSamples[i].dts > firstPTS) {\n                break;\n              }\n              inputSamples[i].dts -= delta;\n              inputSamples[i].pts -= delta;\n            }\n          }\n          logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    let dtsStep = firstDTS;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      if (sample.dts < dtsStep) {\n        sample.dts = dtsStep;\n        dtsStep += averageSampleDuration / 4 | 0 || 1;\n      } else {\n        dtsStep = sample.dts;\n      }\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const VideoSample = inputSamples[i];\n      const VideoSampleUnits = VideoSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\n        const unit = VideoSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  getSamplesPerFrame(track) {\n    switch (track.segmentCodec) {\n      case 'mp3':\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\n      case 'ac3':\n        return AC3_SAMPLES_PER_FRAME;\n      default:\n        return AAC_SAMPLES_PER_FRAME;\n    }\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = this.getSamplesPerFrame(track);\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioPts = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            const newStamp = Math.max(nextPts, 0);\n            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = firstPTS / inputTimeScale;\n    const end = nextAudioPts / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const nextAudioPts = this.nextAudioPts;\n    // sync with video's timestamp\n    const initDTS = this._initDTS;\n    const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n    // one sample's duration value\n    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n    const samples = [];\n    for (let i = 0; i < nbSamples; i++) {\n      const stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nclass Mp4Sample {\n  constructor(isKeyframe, duration, size, cts) {\n    this.size = void 0;\n    this.duration = void 0;\n    this.cts = void 0;\n    this.flags = void 0;\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1\n    };\n  }\n}\nclass PassThroughRemuxer {\n  constructor() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndTime = null;\n  }\n  resetNextTimestamp() {\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment or fallback to default\n    if (initData.audio) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n    }\n    if (initData.video) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const duration = getDuration(data, initData);\n    const startDTS = getStartDTS(initData, data);\n    const decodeTime = startDTS === null ? timeOffset : startDTS;\n    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      if (initPTS && initPTS.timescale === 1) {\n        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      logger.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  if (type === ElementaryStreamTypes.AUDIO) {\n    if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n      return parsedCodec;\n    }\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n      const preferManagedMediaSource = false;\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n    }\n    const result = 'mp4a.40.5';\n    logger.info(`Parsed audio codec \"${parsedCodec}\" or audio object type not handled. Using \"${result}\"`);\n    return result;\n  }\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  logger.warn(`Unhandled video codec \"${parsedCodec}\"`);\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.6.L120.90';\n  }\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n  return 'avc1.42e01e';\n}\n\n/** returns `undefined` is `self` is missing, e.g. in node */\nconst optionalSelf = typeof self !== 'undefined' ? self : undefined;\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  logger.debug('Unable to use Performance API on this environment');\n  now = optionalSelf == null ? void 0 : optionalSelf.Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id) {\n    this.async = false;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      const decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''} of level ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported,\n      vendor\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      var _muxConfig$i$demux;\n      if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\nvar eventemitter3 = {\n  exports: {}\n};\n(function (module) {\n  var has = Object.prototype.hasOwnProperty,\n    prefix = '~';\n\n  /**\n   * Constructor to create a storage for our `EE` objects.\n   * An `Events` instance is a plain object whose properties are event names.\n   *\n   * @constructor\n   * @private\n   */\n  function Events() {}\n\n  //\n  // We try to not inherit from `Object.prototype`. In some engines creating an\n  // instance in this way is faster than calling `Object.create(null)` directly.\n  // If `Object.create(null)` is not supported we prefix the event names with a\n  // character to make sure that the built-in object properties are not\n  // overridden or used as an attack vector.\n  //\n  if (Object.create) {\n    Events.prototype = Object.create(null);\n\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new Events().__proto__) prefix = false;\n  }\n\n  /**\n   * Representation of a single event listener.\n   *\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n   * @constructor\n   * @private\n   */\n  function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n  }\n\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} context The context to invoke the listener with.\n   * @param {Boolean} once Specify if the listener is a one-time listener.\n   * @returns {EventEmitter}\n   * @private\n   */\n  function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('The listener must be a function');\n    }\n    var listener = new EE(fn, context || emitter, once),\n      evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];\n    return emitter;\n  }\n\n  /**\n   * Clear event by name.\n   *\n   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n   * @param {(String|Symbol)} evt The Event name.\n   * @private\n   */\n  function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];\n  }\n\n  /**\n   * Minimal `EventEmitter` interface that is molded against the Node.js\n   * `EventEmitter` interface.\n   *\n   * @constructor\n   * @public\n   */\n  function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  /**\n   * Return an array listing the events for which the emitter has registered\n   * listeners.\n   *\n   * @returns {Array}\n   * @public\n   */\n  EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [],\n      events,\n      name;\n    if (this._eventsCount === 0) return names;\n    for (name in events = this._events) {\n      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n      return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n  };\n\n  /**\n   * Return the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Array} The registered listeners.\n   * @public\n   */\n  EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event,\n      handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [handlers.fn];\n    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n      ee[i] = handlers[i].fn;\n    }\n    return ee;\n  };\n\n  /**\n   * Return the number of listeners listening to a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Number} The number of listeners.\n   * @public\n   */\n  EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event,\n      listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n  };\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @returns {Boolean} `true` if the event had listeners, else `false`.\n   * @public\n   */\n  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt],\n      len = arguments.length,\n      args,\n      i;\n    if (listeners.fn) {\n      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n      switch (len) {\n        case 1:\n          return listeners.fn.call(listeners.context), true;\n        case 2:\n          return listeners.fn.call(listeners.context, a1), true;\n        case 3:\n          return listeners.fn.call(listeners.context, a1, a2), true;\n        case 4:\n          return listeners.fn.call(listeners.context, a1, a2, a3), true;\n        case 5:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n        case 6:\n          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n      }\n      for (i = 1, args = new Array(len - 1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n      listeners.fn.apply(listeners.context, args);\n    } else {\n      var length = listeners.length,\n        j;\n      for (i = 0; i < length; i++) {\n        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n        switch (len) {\n          case 1:\n            listeners[i].fn.call(listeners[i].context);\n            break;\n          case 2:\n            listeners[i].fn.call(listeners[i].context, a1);\n            break;\n          case 3:\n            listeners[i].fn.call(listeners[i].context, a1, a2);\n            break;\n          case 4:\n            listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n            break;\n          default:\n            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n              args[j - 1] = arguments[j];\n            }\n            listeners[i].fn.apply(listeners[i].context, args);\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Add a listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n  EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n  };\n\n  /**\n   * Add a one-time listener for a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn The listener function.\n   * @param {*} [context=this] The context to invoke the listener with.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n  EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n  };\n\n  /**\n   * Remove the listeners of a given event.\n   *\n   * @param {(String|Symbol)} event The event name.\n   * @param {Function} fn Only remove the listeners that match this function.\n   * @param {*} context Only remove the listeners that have this context.\n   * @param {Boolean} once Only remove one-time listeners.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n      clearEvent(this, evt);\n      return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n        clearEvent(this, evt);\n      }\n    } else {\n      for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      }\n\n      //\n      // Reset the array, or remove it completely if we have no more listeners.\n      //\n      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);\n    }\n    return this;\n  };\n\n  /**\n   * Remove all listeners, or those of the specified event.\n   *\n   * @param {(String|Symbol)} [event] The event name.\n   * @returns {EventEmitter} `this`.\n   * @public\n   */\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n      evt = prefix ? prefix + event : event;\n      if (this._events[evt]) clearEvent(this, evt);\n    } else {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n    return this;\n  };\n\n  //\n  // Alias methods names because people roll like that.\n  //\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  //\n  // Expose the prefix.\n  //\n  EventEmitter.prefixed = prefix;\n\n  //\n  // Allow `EventEmitter` to be imported as module namespace.\n  //\n  EventEmitter.EventEmitter = EventEmitter;\n\n  //\n  // Expose the module.\n  //\n  {\n    module.exports = EventEmitter;\n  }\n})(eventemitter3);\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\nclass TransmuxerInterface {\n  constructor(hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    const config = hls.config;\n    this.hls = hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      if (ev === Events.ERROR) {\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const MediaSource = getMediaSource(config.preferManagedMediaSource) || {\n      isTypeSupported: () => false\n    };\n    const m2tsTypeSupported = {\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n      ac3: false\n    };\n\n    // navigator.vendor is not always available in Web Worker\n    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n    const vendor = navigator.vendor;\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          this.onwmsg = ev => this.onWorkerMessage(ev);\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onwmsg);\n          worker.onerror = event => {\n            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n            config.enableWorker = false;\n            logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: 'demuxerWorker',\n              error\n            });\n          };\n          worker.postMessage({\n            cmd: 'init',\n            typeSupported: m2tsTypeSupported,\n            vendor: vendor,\n            id: id,\n            config: JSON.stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.resetWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n  }\n  resetWorker() {\n    if (this.workerContext) {\n      const {\n        worker,\n        objectURL\n      } = this.workerContext;\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.removeEventListener('message', this.onwmsg);\n      worker.onerror = null;\n      worker.terminate();\n      this.workerContext = null;\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.resetWorker();\n      this.onwmsg = undefined;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxer.async = true;\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        transmuxer.async = false;\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      let transmuxResult = transmuxer.flush(chunkMeta);\n      const asyncFlush = isPromise(transmuxResult);\n      if (asyncFlush || transmuxer.async) {\n        if (!isPromise(transmuxResult)) {\n          transmuxResult = Promise.resolve(transmuxResult);\n        }\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  onWorkerMessage(ev) {\n    const data = ev.data;\n    const hls = this.hls;\n    switch (data.event) {\n      case 'init':\n        {\n          var _this$workerContext;\n          const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          break;\n        }\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      // pass logs from the worker thread to the main logger\n      case 'workerLog':\n        if (logger[data.data.logType]) {\n          logger[data.data.logType](data.data.message);\n        }\n        break;\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  }\n  configureTransmuxer(config) {\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n  constructor(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n  destroy() {\n    this.media = null;\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(lastCurrentTime, activeFrag) {\n    const {\n      config,\n      media,\n      stalled\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const {\n      currentTime,\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n      if (!seeking) {\n        this.nudgeRetry = 0;\n      }\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          const _stalledDuration = self.performance.now() - stalled;\n          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n          this.stallReported = false;\n        }\n        this.stalled = null;\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      this.stalled = null;\n      return;\n    }\n\n    // The playhead should not be moving\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n      this.nudgeRetry = 0;\n      return;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const nextStart = bufferInfo.nextStart || 0;\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n      // There is no playable buffer (seeked, waiting for buffer)\n      const isBuffered = bufferInfo.len > 0;\n      if (!isBuffered && !nextStart) {\n        return;\n      }\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        if (!media.paused) {\n          this._trySkipBufferHole(partialOrGap);\n        }\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const tnow = self.performance.now();\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    const {\n      config,\n      fragmentTracker,\n      media\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      logger.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n      this.stalled = null;\n      this._tryNudgeBuffer();\n    }\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported\n    } = this;\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n      logger.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    const {\n      config,\n      hls,\n      media\n    } = this;\n    if (media === null) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          const {\n            fragmentTracker\n          } = this;\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n        if (partial && !partial.gap) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer() {\n    const {\n      config,\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      logger.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      logger.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true\n      });\n    }\n  }\n}\nconst TICK_INTERVAL = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.gapController = null;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this.altAudio = false;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.onvplaying = null;\n    this.onvseeked = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    super.onHandlerDestroying();\n  }\n  startLoad(startPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.firstAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        this.level = hls.nextLoadLevel = startLevel;\n        this.loadedmetadata = false;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          const {\n            levels,\n            level\n          } = this;\n          const currentLevel = levels == null ? void 0 : levels[level];\n          const details = currentLevel == null ? void 0 : currentLevel.details;\n          if (details && (!details.live || this.levelLastLoaded === currentLevel)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              level\n            } = this;\n            const currentLevel = levels == null ? void 0 : levels[level];\n            this.resetStartWhenNotLoaded(currentLevel || null);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    super.onTickEnd();\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n    const {\n      config,\n      nextLoadLevel: level\n    } = hls;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n  }\n  onMediaDetaching() {\n    const {\n      media\n    } = this;\n    if (media && this.onvplaying && this.onvseeked) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n    this.fragPlaying = null;\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n    super.onMediaDetaching();\n  }\n  onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onMediaSeeked() {\n    const media = this.media;\n    const currentTime = media ? media.currentTime : null;\n    if (isFiniteNumber(currentTime)) {\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n    }\n\n    // If seeked was issued before buffer was appended do not tick immediately\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null || bufferInfo.len === 0) {\n      this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n      return;\n    }\n\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = false;\n    this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;\n    this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;\n    this.altAudio = this.audioOnly = this.startFragRequested = false;\n  }\n  onManifestParsed(event, data) {\n    // detect if we have different kind of audio codecs used amongst playlists\n    let aac = false;\n    let heaac = false;\n    data.levels.forEach(level => {\n      const codec = level.audioCodec;\n      if (codec) {\n        aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n        heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = levels[data.level];\n    if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = levels[newLevelId];\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      var _this$levelLastLoaded;\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = curLevel;\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio;\n    const altAudio = !!data.url;\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      const hls = this.hls;\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        this.fragmentTracker.removeAllFragments();\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const trackId = data.id;\n    const altAudio = !!this.hls.audioTracks[trackId].url;\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag && frag.type !== PlaylistLevelType.MAIN) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n      if (this.state === State.PARSED) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'main') {\n          return;\n        }\n        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n          this.resetLoadingState();\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n\n  // Checks the health of the buffer and attempts to resolve playback stalls.\n  checkBuffer() {\n    const {\n      media,\n      gapController\n    } = this;\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n      this.tick();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.level > -1 && this.fragCurrent) {\n      this.level = this.fragCurrent.level;\n    }\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n      media.currentTime = startPosition;\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(frag, level) {\n    frag.bitrateTest = true;\n    this._doFragLoad(frag, level).then(data => {\n      const {\n        hls\n      } = this;\n      if (!data || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'main';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const initPTS = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      if (isFiniteNumber(initPTS)) {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details && frag.sn !== 'initSegment') {\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {\n            // Mark segment with a gap to skip large start gap\n            frag.gap = true;\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      let audioCodec = currentLevel.audioCodec;\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        if (audio.metadata.channelCount !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${currentLevel.audioCodec || ''}/${audio.codec}]`);\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${video.codec}]`);\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    // loop through tracks that are going to be provided to bufferController\n    Object.keys(tracks).forEach(trackName => {\n      const track = tracks[trackName];\n      const initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        this.hls.trigger(Events.BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag,\n          part: null,\n          chunkMeta,\n          parent: frag.type\n        });\n      }\n    });\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    const media = this.media;\n    if (media) {\n      return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    const media = this.media;\n    if (media) {\n      const currentTime = media.currentTime;\n      const frag = this.currentFrag;\n      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n        return new Date(epocMs);\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return \"1.5.3\";\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isMSESupported() {\n    return isMSESupported();\n  }\n\n  /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n\n  /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */\n  static getMediaSource() {\n    return getMediaSource();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */\n    this.config = void 0;\n    /**\n     * The configuration object provided on player instantiation.\n     */\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this.started = false;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    this.triggeringException = void 0;\n    enableLogs(userConfig.debug || false, 'Hls instance');\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    if (config.progressive) {\n      enableStreamingMode(config);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: ConfigAbrController,\n      bufferController: ConfigBufferController,\n      capLevelController: ConfigCapLevelController,\n      errorController: ConfigErrorController,\n      fpsController: ConfigFpsController\n    } = config;\n    const errorController = new ConfigErrorController(this);\n    const abrController = this.abrController = new ConfigAbrController(this);\n    const bufferController = this.bufferController = new ConfigBufferController(this);\n    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    const fpsController = new ConfigFpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const id3TrackController = new ID3TrackController(this);\n    const ConfigContentSteeringController = config.contentSteeringController;\n    // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (error) {\n        logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n        // Prevent recursion in error event handlers that throw #5497\n        if (!this.triggeringException) {\n          this.triggeringException = true;\n          const fatal = event === Events.ERROR;\n          this.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            fatal,\n            event,\n            error\n          });\n          this.triggeringException = false;\n        }\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(media) {\n    logger.log('attachMedia');\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this.url;\n    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1) {\n    logger.log(`startLoad(${startPosition})`);\n    this.started = true;\n    this.networkControllers.forEach(controller => {\n      controller.startLoad(startPosition);\n    });\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    logger.log('stopLoad');\n    this.started = false;\n    this.networkControllers.forEach(controller => {\n      controller.stopLoad();\n    });\n  }\n\n  /**\n   * Resumes stream controller segment loading if previously started.\n   */\n  resumeBuffering() {\n    if (this.started) {\n      this.networkControllers.forEach(controller => {\n        if ('fragmentLoader' in controller) {\n          controller.startLoad(-1);\n        }\n      });\n    }\n  }\n\n  /**\n   * Stops stream controller segment loading without changing 'started' state like stopLoad().\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */\n  pauseBuffering() {\n    this.networkControllers.forEach(controller => {\n      if ('fragmentLoader' in controller) {\n        controller.stopLoad();\n      }\n    });\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    logger.log('recoverMediaError');\n    const media = this._media;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n    }\n  }\n  removeLevel(levelIndex) {\n    this.levelController.removeLevel(levelIndex);\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    logger.log(`set currentLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */\n  get startLevel() {\n    const startLevel = this.levelController.startLevel;\n    if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n      return this.abrController.forcedAutoLevel;\n    }\n    return startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n  set bandwidthEstimate(abrEwmaDefaultEstimate) {\n    this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n      this._maxHdcpLevel = value;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels != null && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n  get firstAutoLevel() {\n    return this.abrController.firstAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    return this.abrController.nextAutoLevel;\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = nextLevel;\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n\n  /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setAudioOption(audioOption) {\n    var _this$audioTrackContr;\n    return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);\n  }\n  /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setSubtitleOption(subtitleOption) {\n    var _this$subtitleTrackCo;\n    (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);\n    return null;\n  }\n\n  /**\n   * Get the complete list of audio tracks across all media groups\n   */\n  get allAudioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.allAudioTracks : [];\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get the complete list of subtitle tracks across all media groups\n   */\n  get allSubtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n}\nHls.defaultConfig = void 0;\nvar KeySystemFormats = empty.KeySystemFormats;\nvar KeySystems = empty.KeySystems;\nvar SubtitleStreamController = empty.SubtitleStreamController;\nvar TimelineController = empty.TimelineController;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLmxpZ2h0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7QUFJQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBU0E7QUFHQTtBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0tBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUN1Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF1SEE7QUFDQTtBQUNBOztBQzlLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQ3BGQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBOztBQWFBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBTUE7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FDN0hBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQ0pBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtQkE7QUFlQTtBQUFBO0FBZEE7QUFHQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTBEQTtBQUNBO0FBQUE7QUExREE7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBT0E7QUFBQTtBQWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQ3pUQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQStDQTtBQUFBO0FBOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTs7QUNGQTtBQUtBO0FBQ0E7QUFDQTtBQUdBOztBQ1JBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUMxWkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzQkE7QUFDQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBYUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDL3NDQTtBQVlBO0FBSUE7QUFNQTtBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQW9GQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFHQTtBQUtBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFNQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBSUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBTUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQzFLQTtBQUVBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFLQTtBQWFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBZUE7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBaUJBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQW1CQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FDNXVCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDeklBO0FBR0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQUE7QUFOQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFPQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFRQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQ2xFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFhQTtBQUFBO0FBWkE7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdlpBO0FBVUE7QUFBQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5TkE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQUE7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUF5QkE7QUFBQTtBQXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDemVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUlBO0FBRUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFTQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5QkE7QUFRQTtBQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5ZUE7QUFRQTtBQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFNQTtBQUVBO0FBR0E7QUFLQTtBQUVBO0FBS0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU1BO0FBQ0E7QUFBQTtBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFTQTtBQUtBO0FBYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDakNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDblFBO0FBZ0JBO0FBQUE7QUFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtTEE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbFVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3SkE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXFEQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFTQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNwS0E7QUFRQTtBQUFBO0FBUEE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQ2pEQTtBQVFBO0FBNENBO0FBM0NBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUlBO0FBQUE7QUFHQTtBQUFBO0FBR0E7QUFBQTtBQUdBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQXdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdXVCQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUF6NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUVBO0FBSUE7QUFLQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBRUE7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMxb0NBO0FBVUE7QUFBQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FDclRBO0FBV0E7QUFBQTtBQVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUMxRkE7QUFFQTtBQWlCQTtBQUFBO0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN2tCQTtBQUVBO0FBY0E7QUFBQTtBQWJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqVkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBWUE7QUFBQTtBQVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7O0FBMkJBO0FBQ0E7QUFDQTs7QUFnS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFHQTtBQUVBO0FBTUE7QUFHQTtBQUVBO0FBS0E7QUFHQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlvQkE7QUFFQTtBQVlBO0FBSUE7QUFBQTtBQWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBRUE7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBOztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9wQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFpQkE7QUFBQTtBQWZBO0FBRUE7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FDM2VBOztBQUVBO0FBS0E7QUFBQTtBQUpBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUNsV0E7QUFLQTtBQUFBO0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQVFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFLQTtBQUNBO0FBUUE7QUFFQTtBQUtBO0FBQ0E7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JIQTtBQWlCQTtBQU9BO0FBdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQ3ZDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FDNUxBO0FBSUE7QUFBQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUNaQTtBQUlBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXlCQTtBQUFBO0FBdEJBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQU1BO0FBTUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQ3hVQTs7QUFFQTtBQVlBO0FBQUE7QUFBQTtBQUFBO0FBWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQ3lDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFvQ0E7QUFPQTtBQUFBO0FBdkNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFLQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBYUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBUUE7QUFDQTs7QUFFQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FDdnZEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFjQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBSUE7O0FDckRBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDS0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQXdCQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFTQTtBQUlBO0FBQ0E7QUFBQTtBQUpBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pFQTtBQUVBO0FBU0E7QUFBQTtBQVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBTUE7QUFJQTtBQUlBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUdBO0FBRUE7QUFDQTtBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNaQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBOztBQUlBO0FBTUE7QUFBQTtBQUxBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3pWQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalZBO0FBQ0E7QUFDQTs7QUFjQTtBQUlBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFJQTtBQUVBO0FBb0JBO0FBSUE7QUF2QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQU1BO0FBS0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FDaCtCQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTs7QUFTQTtBQUVBO0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBWUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFZQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQVNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQW1DQTtBQUNBO0FBdUJBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUdBOztBQUVBO0FBQUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFPQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1DQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFhQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeGxDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FDYkE7QUFPQTtBQU1BO0FBQ0E7QUFDQTtBQVdBO0FBSUE7QUFDQTtBQ0NBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBa0JBO0FBS0E7QUF0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQVFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFLQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFNQTtBQUtBO0FBVkE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1cUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUNvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBT0E7QUFlQTtBQU1BO0FBcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBR0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFPQTtBQU1BO0FBWkE7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBUUE7QUFPQTtBQWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BoQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOzs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUtBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZUQTtBQWNBO0FBS0E7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVdBO0FBQUE7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDN1VBOztBQUVBO0FBbUJBO0FBS0E7QUFNQTtBQTFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFRQTtBQUVBO0FBWUE7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBRUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FDbDRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1RkE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0VBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBU0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTU1QkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9ub2RlX21vZHVsZXMvdXJsLXRvb2xraXQvc3JjL3VybC10b29sa2l0LmpzPzAxYjQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3BvbHlmaWxscy9udW1iZXIudHM/NzJjZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnRzLnRzPzMxNTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2Vycm9ycy50cz9iNmIxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9sb2dnZXIudHM/OWRkMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvYXR0ci1saXN0LnRzPzM2ZjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9kYXRlLXJhbmdlLnRzPzQxOWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9sb2FkLXN0YXRzLnRzPzg0NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9mcmFnbWVudC50cz9mZmIzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvbGV2ZWwtZGV0YWlscy50cz9jYmRkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9lbXB0eS5qcz8yMDM0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90eXBlZC1hcnJheS50cz9kZmUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9pZDMudHM/YjE4NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvaGV4LnRzPzkyYzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL21wNC10b29scy50cz8xMzE5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvbGV2ZWwta2V5LnRzPzgzMmYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL21lZGlhc291cmNlLWhlbHBlci50cz8wYWY3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9jb2RlY3MudHM/ZmZjMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvbG9hZGVyL20zdTgtcGFyc2VyLnRzPzViMzciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3R5cGVzL2xvYWRlci50cz8zYWVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvcGxheWxpc3QtbG9hZGVyLnRzPzY4NTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3RleHR0cmFjay11dGlscy50cz9jOGEzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90eXBlcy9kZW11eGVyLnRzPzgwMGMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXIudHM/OWUyNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXIudHM/Y2FlNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdHlwZXMvbGV2ZWwudHM/NDc3NSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvbGV2ZWwtaGVscGVyLnRzP2Y1ZjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2Vycm9yLWhlbHBlci50cz9lNjQ1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9iaW5hcnktc2VhcmNoLnRzP2ViYmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtZmluZGVycy50cz9hYzY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXIudHM/ZGI3NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9iYXNlLXBsYXlsaXN0LWNvbnRyb2xsZXIudHM/NDdkZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvZXdtYS50cz9mYmM4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9ld21hLWJhbmR3aWR0aC1lc3RpbWF0b3IudHM/NmEwZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbHMvaGRyLnRzPzI4ZGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL3JlbmRpdGlvbi1oZWxwZXIudHM/MTU0MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9hYnItY29udHJvbGxlci50cz8yMmQ5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy9idWZmZXItaGVscGVyLnRzPzQ2NTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZS50cz9hMzkwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyLnRzPzIwNWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXIudHM/NWM3MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9mcHMtY29udHJvbGxlci50cz9lNDBjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2NvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlci50cz9lMjhlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy94aHItbG9hZGVyLnRzPzIzOTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2NodW5rLWNhY2hlLnRzPzFjYzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2ZldGNoLWxvYWRlci50cz84Y2YyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb25maWcudHM/ZWE3NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9sZXZlbC1jb250cm9sbGVyLnRzPzQxOGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlci50cz8wNzBkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9sb2FkZXIvZnJhZ21lbnQtbG9hZGVyLnRzPzU0YzQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2xvYWRlci9rZXktbG9hZGVyLnRzPzQ2NWQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3Rhc2stbG9vcC50cz83ODQyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90eXBlcy90cmFuc211eGVyLnRzPzdhZDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2Rpc2NvbnRpbnVpdGllcy50cz9kYTUyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9hZXMtY3J5cHRvLnRzPzQwZDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NyeXB0L2Zhc3QtYWVzLWtleS50cz8zMWE1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jcnlwdC9hZXMtZGVjcnlwdG9yLnRzP2QxYzAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NyeXB0L2RlY3J5cHRlci50cz9kMTE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90aW1lLXJhbmdlcy50cz85MTMxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL2Jhc2Utc3RyZWFtLWNvbnRyb2xsZXIudHM/N2Q3OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaXMtc3VwcG9ydGVkLnRzP2I5OTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2luamVjdC13b3JrZXIudHM/Yjk2MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvZHVtbXktZGVtdXhlZC10cmFjay50cz9iMDUwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9hdWRpby9iYXNlLWF1ZGlvLWRlbXV4ZXIudHM/YmEzMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvYXVkaW8vYWR0cy50cz8yZGM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9hdWRpby9tcGVnYXVkaW8udHM/ZTI2OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvYXVkaW8vYWFjZGVtdXhlci50cz82M2QyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9tcDRkZW11eGVyLnRzPzRlMmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L2F1ZGlvL2RvbGJ5LnRzP2ViN2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3ZpZGVvL2Jhc2UtdmlkZW8tcGFyc2VyLnRzP2M1ZjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3ZpZGVvL2V4cC1nb2xvbWIudHM/NTE3NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvdmlkZW8vYXZjLXZpZGVvLXBhcnNlci50cz8yNGQzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9zYW1wbGUtYWVzLnRzP2UwYjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RlbXV4L3RzZGVtdXhlci50cz9kZDNmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC9hdWRpby9tcDNkZW11eGVyLnRzPzNhN2EiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlbXV4L2FhYy1oZWxwZXIudHM/N2YyNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVtdXgvbXA0LWdlbmVyYXRvci50cz8yZTY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbi50cz9jNjI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZW11eC9tcDQtcmVtdXhlci50cz8yM2U4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyLnRzPzMxNDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWxzL2dsb2JhbC50cz85ODJhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kZW11eC90cmFuc211eGVyLnRzPzIxOWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/NGJhYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGVtdXgvdHJhbnNtdXhlci1pbnRlcmZhY2UudHM/NzBiNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29udHJvbGxlci9nYXAtY29udHJvbGxlci50cz84MGVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyLnRzPzE2NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2hscy50cz8yMGQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTgwOFxuXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgdmFyIFVSTF9SRUdFWCA9XG4gICAgL14oPz0oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKVxcMSg/PSgoPzpcXC9cXC9bXlxcLz8jXSopPykpXFwyKD89KCg/Oig/OltePyNcXC9dKlxcLykqW147PyNcXC9dKik/KSlcXDMoKD86O1tePyNdKik/KShcXD9bXiNdKik/KCNbXl0qKT8kLztcbiAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuICB2YXIgU0xBU0hfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLig/PVxcLykvZztcbiAgdmFyIFNMQVNIX0RPVF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2c7XG5cbiAgdmFyIFVSTFRvb2xraXQgPSB7XG4gICAgLy8gSWYgb3B0cy5hbHdheXNOb3JtYWxpemUgaXMgdHJ1ZSB0aGVuIHRoZSBwYXRoIHdpbGwgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgZXZlbiB3aGVuIGl0IHN0YXJ0cyB3aXRoIC8gb3IgLy9cbiAgICAvLyBFLmdcbiAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgIC8vIGh0dHA6Ly9hLmNvbS9iL2NkICsgL2UvZi8uLi9nID0+IGh0dHA6Ly9hLmNvbS9lL2YvLi4vZ1xuICAgIC8vIFdpdGggb3B0cy5hbHdheXNOb3JtYWxpemUgPSB0cnVlIChub3Qgc3BlYyBjb21wbGlhbnQpXG4gICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgIGJ1aWxkQWJzb2x1dGVVUkw6IGZ1bmN0aW9uIChiYXNlVVJMLCByZWxhdGl2ZVVSTCwgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuICAgICAgYmFzZVVSTCA9IGJhc2VVUkwudHJpbSgpO1xuICAgICAgcmVsYXRpdmVVUkwgPSByZWxhdGl2ZVVSTC50cmltKCk7XG4gICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG4gICAgICAgIC8vIDJhKSBJZiB0aGUgZW1iZWRkZWQgVVJMIGlzIGVudGlyZWx5IGVtcHR5LCBpdCBpbmhlcml0cyB0aGVcbiAgICAgICAgLy8gZW50aXJlIGJhc2UgVVJMIChpLmUuLCBpcyBzZXQgZXF1YWwgdG8gdGhlIGJhc2UgVVJMKVxuICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG4gICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVVSTDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVBhcnRzRm9yTm9ybWFsaXNlID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgICAgaWYgKCFiYXNlUGFydHNGb3JOb3JtYWxpc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChcbiAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhiYXNlUGFydHNGb3JOb3JtYWxpc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbGF0aXZlUGFydHMgPSBVUkxUb29sa2l0LnBhcnNlVVJMKHJlbGF0aXZlVVJMKTtcbiAgICAgIGlmICghcmVsYXRpdmVQYXJ0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQYXJ0cy5zY2hlbWUpIHtcbiAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcbiAgICAgICAgLy8gaW50ZXJwcmV0ZWQgYXMgYW4gYWJzb2x1dGUgVVJMIGFuZCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcbiAgICAgICAgfVxuICAgICAgICByZWxhdGl2ZVBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgYmFzZVBhcnRzID0gVVJMVG9vbGtpdC5wYXJzZVVSTChiYXNlVVJMKTtcbiAgICAgIGlmICghYmFzZVBhcnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGJhc2UgVVJMLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgLy8gSWYgbmV0TG9jIG1pc3NpbmcgYW5kIHBhdGggZG9lc24ndCBzdGFydCB3aXRoICcvJywgYXNzdW1lIGV2ZXJ0aGluZyBiZWZvcmUgdGhlIGZpcnN0ICcvJyBpcyB0aGUgbmV0TG9jXG4gICAgICAgIC8vIFRoaXMgY2F1c2VzICdleGFtcGxlLmNvbS9hJyB0byBiZSBoYW5kbGVkIGFzICcvL2V4YW1wbGUuY29tL2EnIGluc3RlYWQgb2YgJy9leGFtcGxlLmNvbS9hJ1xuICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcbiAgICAgICAgYmFzZVBhcnRzLm5ldExvYyA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSBwYXRoUGFydHNbMl07XG4gICAgICB9XG4gICAgICBpZiAoYmFzZVBhcnRzLm5ldExvYyAmJiAhYmFzZVBhcnRzLnBhdGgpIHtcbiAgICAgICAgYmFzZVBhcnRzLnBhdGggPSAnLyc7XG4gICAgICB9XG4gICAgICB2YXIgYnVpbHRQYXJ0cyA9IHtcbiAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cbiAgICAgICAgc2NoZW1lOiBiYXNlUGFydHMuc2NoZW1lLFxuICAgICAgICBuZXRMb2M6IHJlbGF0aXZlUGFydHMubmV0TG9jLFxuICAgICAgICBwYXRoOiBudWxsLFxuICAgICAgICBwYXJhbXM6IHJlbGF0aXZlUGFydHMucGFyYW1zLFxuICAgICAgICBxdWVyeTogcmVsYXRpdmVQYXJ0cy5xdWVyeSxcbiAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG4gICAgICB9O1xuICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLm5ldExvYykge1xuICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuICAgICAgICAvLyBTdGVwIDcuICBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIDxuZXRfbG9jPlxuICAgICAgICAvLyAoaWYgYW55KSBvZiB0aGUgYmFzZSBVUkwuXG4gICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcbiAgICAgICAgLy8gNCkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIHByZWNlZGVkIGJ5IGEgc2xhc2ggXCIvXCIsIHRoZVxuICAgICAgICAvLyBwYXRoIGlzIG5vdCByZWxhdGl2ZSBhbmQgd2Ugc2tpcCB0byBTdGVwIDcuXG4gICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXRoKSB7XG4gICAgICAgICAgICAvLyA1KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgZW1wdHkgKGFuZCBub3QgcHJlY2VkZWQgYnkgYVxuICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuICAgICAgICAgICAgLy8gNWEpIGlmIHRoZSBlbWJlZGRlZCBVUkwncyA8cGFyYW1zPiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cbiAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2VcbiAgICAgICAgICAgIC8vIFVSTCAoaWYgYW55KSBhbmRcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuICAgICAgICAgICAgICAvLyA1YikgaWYgdGhlIGVtYmVkZGVkIFVSTCdzIDxxdWVyeT4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG4gICAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHF1ZXJ5PiBvZiB0aGUgYmFzZVxuICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucXVlcnkpIHtcbiAgICAgICAgICAgICAgICBidWlsdFBhcnRzLnF1ZXJ5ID0gYmFzZVBhcnRzLnF1ZXJ5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgcmlnaHRtb3N0IHNsYXNoIFwiL1wiLCBvciB0aGUgZW50aXJlIHBhdGggaWYgbm9cbiAgICAgICAgICAgIC8vIHNsYXNoIGlzIHByZXNlbnQpIGlzIHJlbW92ZWQgYW5kIHRoZSBlbWJlZGRlZCBVUkwncyBwYXRoIGlzXG4gICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgICB2YXIgYmFzZVVSTFBhdGggPSBiYXNlUGFydHMucGF0aDtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoID1cbiAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG4gICAgICAgICAgICAgIHJlbGF0aXZlUGFydHMucGF0aDtcbiAgICAgICAgICAgIGJ1aWx0UGFydHMucGF0aCA9IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChuZXdQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gb3B0cy5hbHdheXNOb3JtYWxpemVcbiAgICAgICAgICA/IFVSTFRvb2xraXQubm9ybWFsaXplUGF0aChyZWxhdGl2ZVBhcnRzLnBhdGgpXG4gICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gVVJMVG9vbGtpdC5idWlsZFVSTEZyb21QYXJ0cyhidWlsdFBhcnRzKTtcbiAgICB9LFxuICAgIHBhcnNlVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBVUkxfUkVHRVguZXhlYyh1cmwpO1xuICAgICAgaWYgKCFwYXJ0cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFydHNbMV0gfHwgJycsXG4gICAgICAgIG5ldExvYzogcGFydHNbMl0gfHwgJycsXG4gICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuICAgICAgICBwYXJhbXM6IHBhcnRzWzRdIHx8ICcnLFxuICAgICAgICBxdWVyeTogcGFydHNbNV0gfHwgJycsXG4gICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcbiAgICAgIH07XG4gICAgfSxcbiAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyBvcGVyYXRpb25zIGFyZVxuICAgICAgLy8gdGhlbiBhcHBsaWVkLCBpbiBvcmRlciwgdG8gdGhlIG5ldyBwYXRoOlxuICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuICAgICAgLy8gc2VnbWVudCwgYXJlIHJlbW92ZWQuXG4gICAgICAvLyA2YikgSWYgdGhlIHBhdGggZW5kcyB3aXRoIFwiLlwiIGFzIGEgY29tcGxldGUgcGF0aCBzZWdtZW50LFxuICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKS5yZXBsYWNlKFNMQVNIX0RPVF9SRUdFWCwgJycpO1xuICAgICAgLy8gNmMpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIjxzZWdtZW50Pi8uLi9cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cbiAgICAgIC8vIFJlbW92YWwgb2YgdGhlc2UgcGF0aCBzZWdtZW50cyBpcyBwZXJmb3JtZWQgaXRlcmF0aXZlbHksXG4gICAgICAvLyByZW1vdmluZyB0aGUgbGVmdG1vc3QgbWF0Y2hpbmcgcGF0dGVybiBvbiBlYWNoIGl0ZXJhdGlvbixcbiAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cbiAgICAgIC8vIDZkKSBJZiB0aGUgcGF0aCBlbmRzIHdpdGggXCI8c2VnbWVudD4vLi5cIiwgd2hlcmUgPHNlZ21lbnQ+IGlzIGFcbiAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCB0aGF0XG4gICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG4gICAgICB3aGlsZSAoXG4gICAgICAgIHBhdGgubGVuZ3RoICE9PSAocGF0aCA9IHBhdGgucmVwbGFjZShTTEFTSF9ET1RfRE9UX1JFR0VYLCAnJykpLmxlbmd0aFxuICAgICAgKSB7fVxuICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhcnRzLnNjaGVtZSArXG4gICAgICAgIHBhcnRzLm5ldExvYyArXG4gICAgICAgIHBhcnRzLnBhdGggK1xuICAgICAgICBwYXJ0cy5wYXJhbXMgK1xuICAgICAgICBwYXJ0cy5xdWVyeSArXG4gICAgICAgIHBhcnRzLmZyYWdtZW50XG4gICAgICApO1xuICAgIH0sXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFVSTFRvb2xraXQ7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBVUkxUb29sa2l0O1xuICAgIH0pO1xuICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIGV4cG9ydHNbJ1VSTFRvb2xraXQnXSA9IFVSTFRvb2xraXQ7XG4gIGVsc2Ugcm9vdFsnVVJMVG9vbGtpdCddID0gVVJMVG9vbGtpdDtcbn0pKHRoaXMpO1xuIiwiLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNmaW5pdGVcbmV4cG9ydCBjb25zdCBpc0Zpbml0ZU51bWJlciA9XG4gIE51bWJlci5pc0Zpbml0ZSB8fFxuICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG4gIH07XG5cbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfbnVtYmVyX2lzc2FmZWludGVnZXJcbmV4cG9ydCBjb25zdCBpc1NhZmVJbnRlZ2VyID1cbiAgTnVtYmVyLmlzU2FmZUludGVnZXIgfHxcbiAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTWF0aC5hYnModmFsdWUpIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gIH07XG5cbmV4cG9ydCBjb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbiIsImltcG9ydCB7XG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RMb2FkaW5nRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG4gIE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgTGV2ZWxMb2FkaW5nRGF0YSxcbiAgTGV2ZWxMb2FkZWREYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIExldmVsVXBkYXRlZERhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSxcbiAgRnJhZ0RlY3J5cHRlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBJbml0UFRTRm91bmREYXRhLFxuICBDdWVzUGFyc2VkRGF0YSxcbiAgU3VidGl0bGVGcmFnUHJvY2Vzc2VkRGF0YSxcbiAgTm9uTmF0aXZlVGV4dFRyYWNrc0RhdGEsXG4gIEZyYWdMb2FkaW5nRGF0YSxcbiAgQXVkaW9UcmFja0xvYWRlZERhdGEsXG4gIFN1YnRpdGxlVHJhY2tMb2FkZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhLFxuICBBdWRpb1RyYWNrU3dpdGNoZWREYXRhLFxuICBLZXlMb2FkZWREYXRhLFxuICBLZXlMb2FkaW5nRGF0YSxcbiAgU3VidGl0bGVUcmFja1N3aXRjaERhdGEsXG4gIFN1YnRpdGxlVHJhY2tzVXBkYXRlZERhdGEsXG4gIExldmVsU3dpdGNoZWREYXRhLFxuICBGcmFnQ2hhbmdlZERhdGEsXG4gIEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gIEJ1ZmZlckNvZGVjc0RhdGEsXG4gIEZyYWdQYXJzaW5nTWV0YWRhdGFEYXRhLFxuICBGcmFnUGFyc2luZ0luaXRTZWdtZW50RGF0YSxcbiAgRnJhZ0J1ZmZlcmVkRGF0YSxcbiAgQnVmZmVyRmx1c2hpbmdEYXRhLFxuICBCdWZmZXJFT1NEYXRhLFxuICBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gIE1heEF1dG9MZXZlbFVwZGF0ZWREYXRhLFxuICBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YSxcbiAgRlBTRHJvcERhdGEsXG4gIEJ1ZmZlckNyZWF0ZWREYXRhLFxuICBCdWZmZXJBcHBlbmRlZERhdGEsXG4gIExldmVsUFRTVXBkYXRlZERhdGEsXG4gIEZyYWdQYXJzZWREYXRhLFxuICBBdWRpb1RyYWNrc1VwZGF0ZWREYXRhLFxuICBGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWREYXRhLFxuICBCYWNrQnVmZmVyRGF0YSxcbiAgTGl2ZUJhY2tCdWZmZXJEYXRhLFxuICBUcmFja0xvYWRpbmdEYXRhLFxuICBCdWZmZXJGbHVzaGVkRGF0YSxcbiAgU3RlZXJpbmdNYW5pZmVzdExvYWRlZERhdGEsXG59IGZyb20gJy4vdHlwZXMvZXZlbnRzJztcblxuZXhwb3J0IGVudW0gRXZlbnRzIHtcbiAgLy8gRmlyZWQgYmVmb3JlIE1lZGlhU291cmNlIGlzIGF0dGFjaGluZyB0byBtZWRpYSBlbGVtZW50XG4gIE1FRElBX0FUVEFDSElORyA9ICdobHNNZWRpYUF0dGFjaGluZycsXG4gIC8vIEZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRcbiAgTUVESUFfQVRUQUNIRUQgPSAnaGxzTWVkaWFBdHRhY2hlZCcsXG4gIC8vIEZpcmVkIGJlZm9yZSBkZXRhY2hpbmcgTWVkaWFTb3VyY2UgZnJvbSBtZWRpYSBlbGVtZW50XG4gIE1FRElBX0RFVEFDSElORyA9ICdobHNNZWRpYURldGFjaGluZycsXG4gIC8vIEZpcmVkIHdoZW4gTWVkaWFTb3VyY2UgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSBtZWRpYSBlbGVtZW50XG4gIE1FRElBX0RFVEFDSEVEID0gJ2hsc01lZGlhRGV0YWNoZWQnLFxuICAvLyBGaXJlZCB3aGVuIHRoZSBidWZmZXIgaXMgZ29pbmcgdG8gYmUgcmVzZXRcbiAgQlVGRkVSX1JFU0VUID0gJ2hsc0J1ZmZlclJlc2V0JyxcbiAgLy8gRmlyZWQgd2hlbiB3ZSBrbm93IGFib3V0IHRoZSBjb2RlY3MgdGhhdCB3ZSBuZWVkIGJ1ZmZlcnMgZm9yIHRvIHB1c2ggaW50byAtIGRhdGE6IHt0cmFja3MgOiB7IGNvbnRhaW5lciwgY29kZWMsIGxldmVsQ29kZWMsIGluaXRTZWdtZW50LCBtZXRhZGF0YSB9fVxuICBCVUZGRVJfQ09ERUNTID0gJ2hsc0J1ZmZlckNvZGVjcycsXG4gIC8vIGZpcmVkIHdoZW4gc291cmNlYnVmZmVycyBoYXZlIGJlZW4gY3JlYXRlZCAtIGRhdGE6IHsgdHJhY2tzIDogdHJhY2tzIH1cbiAgQlVGRkVSX0NSRUFURUQgPSAnaGxzQnVmZmVyQ3JlYXRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gd2UgYXBwZW5kIGEgc2VnbWVudCB0byB0aGUgYnVmZmVyIC0gZGF0YTogeyBzZWdtZW50OiBzZWdtZW50IG9iamVjdCB9XG4gIEJVRkZFUl9BUFBFTkRJTkcgPSAnaGxzQnVmZmVyQXBwZW5kaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiB3ZSBhcmUgZG9uZSB3aXRoIGFwcGVuZGluZyBhIG1lZGlhIHNlZ21lbnQgdG8gdGhlIGJ1ZmZlciAtIGRhdGEgOiB7IHBhcmVudCA6IHNlZ21lbnQgcGFyZW50IHRoYXQgdHJpZ2dlcmVkIEJVRkZFUl9BUFBFTkRJTkcsIHBlbmRpbmcgOiBuYiBvZiBzZWdtZW50cyB3YWl0aW5nIGZvciBhcHBlbmRpbmcgZm9yIHRoaXMgc2VnbWVudCBwYXJlbnR9XG4gIEJVRkZFUl9BUFBFTkRFRCA9ICdobHNCdWZmZXJBcHBlbmRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmaW5pc2hlZCBhbmQgd2Ugd2FudCB0byBub3RpZnkgdGhlIG1lZGlhIGJ1ZmZlciB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gbW9yZSBkYXRhIC0gZGF0YTogeyB9XG4gIEJVRkZFUl9FT1MgPSAnaGxzQnVmZmVyRW9zJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgbWVkaWEgYnVmZmVyIHNob3VsZCBiZSBmbHVzaGVkIC0gZGF0YSB7IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQgfVxuICBCVUZGRVJfRkxVU0hJTkcgPSAnaGxzQnVmZmVyRmx1c2hpbmcnLFxuICAvLyBmaXJlZCB3aGVuIHRoZSBtZWRpYSBidWZmZXIgaGFzIGJlZW4gZmx1c2hlZCAtIGRhdGE6IHsgfVxuICBCVUZGRVJfRkxVU0hFRCA9ICdobHNCdWZmZXJGbHVzaGVkJyxcbiAgLy8gZmlyZWQgdG8gc2lnbmFsIHRoYXQgYSBtYW5pZmVzdCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgdXJsIDogbWFuaWZlc3RVUkx9XG4gIE1BTklGRVNUX0xPQURJTkcgPSAnaGxzTWFuaWZlc3RMb2FkaW5nJyxcbiAgLy8gZmlyZWQgYWZ0ZXIgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBsZXZlbHMgOiBbYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXSwgYXVkaW9UcmFja3MgOiBbIGF2YWlsYWJsZSBhdWRpbyB0cmFja3MgXSwgdXJsIDogbWFuaWZlc3RVUkwsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBNQU5JRkVTVF9MT0FERUQgPSAnaGxzTWFuaWZlc3RMb2FkZWQnLFxuICAvLyBmaXJlZCBhZnRlciBtYW5pZmVzdCBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdLCBmaXJzdExldmVsIDogaW5kZXggb2YgZmlyc3QgcXVhbGl0eSBsZXZlbCBhcHBlYXJpbmcgaW4gTWFuaWZlc3R9XG4gIE1BTklGRVNUX1BBUlNFRCA9ICdobHNNYW5pZmVzdFBhcnNlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgcmVxdWVzdGVkIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSElORyA9ICdobHNMZXZlbFN3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCBzd2l0Y2ggaXMgZWZmZWN0aXZlIC0gZGF0YTogeyBsZXZlbCA6IGlkIG9mIG5ldyBsZXZlbCB9XG4gIExFVkVMX1NXSVRDSEVEID0gJ2hsc0xldmVsU3dpdGNoZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwgcGxheWxpc3QgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGxldmVsIFVSTCwgbGV2ZWwgOiBpZCBvZiBsZXZlbCBiZWluZyBsb2FkZWR9XG4gIExFVkVMX0xPQURJTkcgPSAnaGxzTGV2ZWxMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGxldmVsIHBsYXlsaXN0IGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIGxvYWRlZCBsZXZlbCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIExFVkVMX0xPQURFRCA9ICdobHNMZXZlbExvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBsZXZlbCdzIGRldGFpbHMgaGF2ZSBiZWVuIHVwZGF0ZWQgYmFzZWQgb24gcHJldmlvdXMgZGV0YWlscywgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkIC0gZGF0YTogeyBkZXRhaWxzIDogbGV2ZWxEZXRhaWxzIG9iamVjdCwgbGV2ZWwgOiBpZCBvZiB1cGRhdGVkIGxldmVsIH1cbiAgTEVWRUxfVVBEQVRFRCA9ICdobHNMZXZlbFVwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgbGV2ZWwncyBQVFMgaW5mb3JtYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhZnRlciBwYXJzaW5nIGEgZnJhZ21lbnQgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBsZXZlbCA6IGlkIG9mIHVwZGF0ZWQgbGV2ZWwsIGRyaWZ0OiBQVFMgZHJpZnQgb2JzZXJ2ZWQgd2hlbiBwYXJzaW5nIGxhc3QgZnJhZ21lbnQgfVxuICBMRVZFTF9QVFNfVVBEQVRFRCA9ICdobHNMZXZlbFB0c1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBsZXZlbHMgaGF2ZSBjaGFuZ2VkIGFmdGVyIHJlbW92aW5nIGEgbGV2ZWwgLSBkYXRhOiB7IGxldmVscyA6IFthdmFpbGFibGUgcXVhbGl0eSBsZXZlbHNdIH1cbiAgTEVWRUxTX1VQREFURUQgPSAnaGxzTGV2ZWxzVXBkYXRlZCcsXG4gIC8vIGZpcmVkIHRvIG5vdGlmeSB0aGF0IGF1ZGlvIHRyYWNrIGxpc3RzIGhhcyBiZWVuIHVwZGF0ZWQgLSBkYXRhOiB7IGF1ZGlvVHJhY2tzIDogYXVkaW9UcmFja3MgfVxuICBBVURJT19UUkFDS1NfVVBEQVRFRCA9ICdobHNBdWRpb1RyYWNrc1VwZGF0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIHN3aXRjaGluZyBpcyByZXF1ZXN0ZWQgLSBkYXRhOiB7IGlkIDogYXVkaW8gdHJhY2sgaWQgfVxuICBBVURJT19UUkFDS19TV0lUQ0hJTkcgPSAnaGxzQXVkaW9UcmFja1N3aXRjaGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgc3dpdGNoIGFjdHVhbGx5IG9jY3VycyAtIGRhdGE6IHsgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX1NXSVRDSEVEID0gJ2hsc0F1ZGlvVHJhY2tTd2l0Y2hlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYW4gYXVkaW8gdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IGF1ZGlvIHRyYWNrIFVSTCwgaWQgOiBhdWRpbyB0cmFjayBpZCB9XG4gIEFVRElPX1RSQUNLX0xPQURJTkcgPSAnaGxzQXVkaW9UcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGFuIGF1ZGlvIHRyYWNrIGxvYWRpbmcgZmluaXNoZXMgLSBkYXRhOiB7IGRldGFpbHMgOiBsZXZlbERldGFpbHMgb2JqZWN0LCBpZCA6IGF1ZGlvIHRyYWNrIGlkLCBzdGF0cyA6IExvYWRlclN0YXRzIH1cbiAgQVVESU9fVFJBQ0tfTE9BREVEID0gJ2hsc0F1ZGlvVHJhY2tMb2FkZWQnLFxuICAvLyBmaXJlZCB0byBub3RpZnkgdGhhdCBzdWJ0aXRsZSB0cmFjayBsaXN0cyBoYXMgYmVlbiB1cGRhdGVkIC0gZGF0YTogeyBzdWJ0aXRsZVRyYWNrcyA6IHN1YnRpdGxlVHJhY2tzIH1cbiAgU1VCVElUTEVfVFJBQ0tTX1VQREFURUQgPSAnaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkJyxcbiAgLy8gZmlyZWQgdG8gbm90aWZ5IHRoYXQgc3VidGl0bGUgdHJhY2tzIHdlcmUgY2xlYXJlZCBhcyBhIHJlc3VsdCBvZiBzdG9wcGluZyB0aGUgbWVkaWFcbiAgU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQgPSAnaGxzU3VidGl0bGVUcmFja3NDbGVhcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhbiBzdWJ0aXRsZSB0cmFjayBzd2l0Y2ggb2NjdXJzIC0gZGF0YTogeyBpZCA6IHN1YnRpdGxlIHRyYWNrIGlkIH1cbiAgU1VCVElUTEVfVFJBQ0tfU1dJVENIID0gJ2hsc1N1YnRpdGxlVHJhY2tTd2l0Y2gnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IHVybCA6IHN1YnRpdGxlIHRyYWNrIFVSTCwgaWQgOiBzdWJ0aXRsZSB0cmFjayBpZCB9XG4gIFNVQlRJVExFX1RSQUNLX0xPQURJTkcgPSAnaGxzU3VidGl0bGVUcmFja0xvYWRpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgc3VidGl0bGUgdHJhY2sgbG9hZGluZyBmaW5pc2hlcyAtIGRhdGE6IHsgZGV0YWlscyA6IGxldmVsRGV0YWlscyBvYmplY3QsIGlkIDogc3VidGl0bGUgdHJhY2sgaWQsIHN0YXRzIDogTG9hZGVyU3RhdHMgfVxuICBTVUJUSVRMRV9UUkFDS19MT0FERUQgPSAnaGxzU3VidGl0bGVUcmFja0xvYWRlZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBzdWJ0aXRsZSBmcmFnbWVudCBoYXMgYmVlbiBwcm9jZXNzZWQgLSBkYXRhOiB7IHN1Y2Nlc3MgOiBib29sZWFuLCBmcmFnIDogdGhlIHByb2Nlc3NlZCBmcmFnIH1cbiAgU1VCVElUTEVfRlJBR19QUk9DRVNTRUQgPSAnaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIHNldCBvZiBWVFRDdWVzIHRvIGJlIG1hbmFnZWQgZXh0ZXJuYWxseSBoYXMgYmVlbiBwYXJzZWQgLSBkYXRhOiB7IHR5cGU6IHN0cmluZywgdHJhY2s6IHN0cmluZywgY3VlczogWyBWVFRDdWUgXSB9XG4gIENVRVNfUEFSU0VEID0gJ2hsc0N1ZXNQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgdGV4dCB0cmFjayB0byBiZSBtYW5hZ2VkIGV4dGVybmFsbHkgaXMgZm91bmQgLSBkYXRhOiB7IHRyYWNrczogWyB7IGxhYmVsOiBzdHJpbmcsIGtpbmQ6IHN0cmluZywgZGVmYXVsdDogYm9vbGVhbiB9IF0gfVxuICBOT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5EID0gJ2hsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gdGhlIGZpcnN0IHRpbWVzdGFtcCBpcyBmb3VuZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBpbml0UFRTOiBpbml0UFRTLCB0aW1lc2NhbGU6IHRpbWVzY2FsZSwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIElOSVRfUFRTX0ZPVU5EID0gJ2hsc0luaXRQdHNGb3VuZCcsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIHN0YXJ0cyAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfTE9BRElORyA9ICdobHNGcmFnTG9hZGluZycsXG4gIC8vIGZpcmVkIHdoZW4gYSBmcmFnbWVudCBsb2FkaW5nIGlzIHByb2dyZXNzaW5nIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCB7IHRyZXF1ZXN0LCB0Zmlyc3QsIGxvYWRlZCB9IH1cbiAgLy8gRlJBR19MT0FEX1BST0dSRVNTID0gJ2hsc0ZyYWdMb2FkUHJvZ3Jlc3MnLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIGFib3J0aW5nIGZvciBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQgPSAnaGxzRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGZyYWdtZW50IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEZSQUdfTE9BREVEID0gJ2hsc0ZyYWdMb2FkZWQnLFxuICAvLyBmaXJlZCB3aGVuIGEgZnJhZ21lbnQgaGFzIGZpbmlzaGVkIGRlY3J5cHRpbmcgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZzogZnJhZ21lbnQgb2JqZWN0LCBwYXlsb2FkIDogZnJhZ21lbnQgcGF5bG9hZCwgc3RhdHMgOiB7IHRzdGFydCwgdGRlY3J5cHQgfSB9XG4gIEZSQUdfREVDUllQVEVEID0gJ2hsc0ZyYWdEZWNyeXB0ZWQnLFxuICAvLyBmaXJlZCB3aGVuIEluaXQgU2VnbWVudCBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBmcmFnbWVudCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIG1vb3YgOiBtb292IE1QNCBib3gsIGNvZGVjcyA6IGNvZGVjcyBmb3VuZCB3aGlsZSBwYXJzaW5nIGZyYWdtZW50IH1cbiAgRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCA9ICdobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50JyxcbiAgLy8gZmlyZWQgd2hlbiBwYXJzaW5nIHNlaSB0ZXh0IGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIHNlaSBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX1VTRVJEQVRBID0gJ2hsc0ZyYWdQYXJzaW5nVXNlcmRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIHBhcnNpbmcgaWQzIGlzIGNvbXBsZXRlZCAtIGRhdGE6IHsgaWQgOiBkZW11eGVyIGlkLCBmcmFnOiBmcmFnbWVudCBvYmplY3QsIHNhbXBsZXMgOiBbIGlkMyBzYW1wbGVzIHBlcyBdIH1cbiAgRlJBR19QQVJTSU5HX01FVEFEQVRBID0gJ2hsc0ZyYWdQYXJzaW5nTWV0YWRhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGRhdGEgaGF2ZSBiZWVuIGV4dHJhY3RlZCBmcm9tIGZyYWdtZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCwgZGF0YTEgOiBtb29mIE1QNCBib3ggb3IgVFMgZnJhZ21lbnRzLCBkYXRhMiA6IG1kYXQgTVA0IGJveCBvciBudWxsfVxuICAvLyBGUkFHX1BBUlNJTkdfREFUQSA9ICdobHNGcmFnUGFyc2luZ0RhdGEnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHBhcnNpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWc6IGZyYWdtZW50IG9iamVjdCB9XG4gIEZSQUdfUEFSU0VEID0gJ2hsc0ZyYWdQYXJzZWQnLFxuICAvLyBmaXJlZCB3aGVuIGZyYWdtZW50IHJlbXV4ZWQgTVA0IGJveGVzIGhhdmUgYWxsIGJlZW4gYXBwZW5kZWQgaW50byBTb3VyY2VCdWZmZXIgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBpZCwgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgc3RhdHMgOiBMb2FkZXJTdGF0cyB9XG4gIEZSQUdfQlVGRkVSRUQgPSAnaGxzRnJhZ0J1ZmZlcmVkJyxcbiAgLy8gZmlyZWQgd2hlbiBmcmFnbWVudCBtYXRjaGluZyB3aXRoIGN1cnJlbnQgbWVkaWEgcG9zaXRpb24gaXMgY2hhbmdpbmcgLSBkYXRhIDogeyBpZCA6IGRlbXV4ZXIgaWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBGUkFHX0NIQU5HRUQgPSAnaGxzRnJhZ0NoYW5nZWQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIEZQUyBkcm9wIGV2ZW50IC0gZGF0YTogeyBjdXJyZW50RHJvcHBlZCwgY3VycmVudERlY29kZWQsIHRvdGFsRHJvcHBlZEZyYW1lcyB9XG4gIEZQU19EUk9QID0gJ2hsc0Zwc0Ryb3AnLFxuICAvLyB0cmlnZ2VyZWQgd2hlbiBGUFMgZHJvcCB0cmlnZ2VycyBhdXRvIGxldmVsIGNhcHBpbmcgLSBkYXRhOiB7IGxldmVsLCBkcm9wcGVkTGV2ZWwgfVxuICBGUFNfRFJPUF9MRVZFTF9DQVBQSU5HID0gJ2hsc0Zwc0Ryb3BMZXZlbENhcHBpbmcnLFxuICAvLyB0cmlnZ2VyZWQgd2hlbiBtYXhBdXRvTGV2ZWwgY2hhbmdlcyAtIGRhdGEgeyBhdXRvTGV2ZWxDYXBwaW5nLCBsZXZlbHMsIG1heEF1dG9MZXZlbCwgbWluQXV0b0xldmVsLCBtYXhIZGNwTGV2ZWwgfVxuICBNQVhfQVVUT19MRVZFTF9VUERBVEVEID0gJ2hsc01heEF1dG9MZXZlbFVwZGF0ZWQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBlcnJvciBldmVudCAtIGRhdGE6IHsgdHlwZSA6IGVycm9yIHR5cGUsIGRldGFpbHMgOiBlcnJvciBkZXRhaWxzLCBmYXRhbCA6IGlmIHRydWUsIGhscy5qcyBjYW5ub3Qvd2lsbCBub3QgdHJ5IHRvIHJlY292ZXIsIGlmIGZhbHNlLCBobHMuanMgd2lsbCB0cnkgdG8gcmVjb3ZlcixvdGhlciBlcnJvciBzcGVjaWZpYyBkYXRhIH1cbiAgRVJST1IgPSAnaGxzRXJyb3InLFxuICAvLyBmaXJlZCB3aGVuIGhscy5qcyBpbnN0YW5jZSBzdGFydHMgZGVzdHJveWluZy4gRGlmZmVyZW50IGZyb20gTUVESUFfREVUQUNIRUQgYXMgb25lIGNvdWxkIHdhbnQgdG8gZGV0YWNoIGFuZCByZWF0dGFjaCBhIG1lZGlhIHRvIHRoZSBpbnN0YW5jZSBvZiBobHMuanMgdG8gaGFuZGxlIG1pZC1yb2xscyBmb3IgZXhhbXBsZSAtIGRhdGE6IHsgfVxuICBERVNUUk9ZSU5HID0gJ2hsc0Rlc3Ryb3lpbmcnLFxuICAvLyBmaXJlZCB3aGVuIGEgZGVjcnlwdCBrZXkgbG9hZGluZyBzdGFydHMgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3QgfVxuICBLRVlfTE9BRElORyA9ICdobHNLZXlMb2FkaW5nJyxcbiAgLy8gZmlyZWQgd2hlbiBhIGRlY3J5cHQga2V5IGxvYWRpbmcgaXMgY29tcGxldGVkIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0LCBrZXlJbmZvIDogS2V5TG9hZGVySW5mbyB9XG4gIEtFWV9MT0FERUQgPSAnaGxzS2V5TG9hZGVkJyxcbiAgLy8gZGVwcmVjYXRlZDsgcGxlYXNlIHVzZSBCQUNLX0JVRkZFUl9SRUFDSEVEIC0gZGF0YSA6IHsgYnVmZmVyRW5kOiBudW1iZXIgfVxuICBMSVZFX0JBQ0tfQlVGRkVSX1JFQUNIRUQgPSAnaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkJyxcbiAgLy8gZmlyZWQgd2hlbiB0aGUgYmFjayBidWZmZXIgaXMgcmVhY2hlZCBhcyBkZWZpbmVkIGJ5IHRoZSBiYWNrQnVmZmVyTGVuZ3RoIGNvbmZpZyBvcHRpb24gLSBkYXRhIDogeyBidWZmZXJFbmQ6IG51bWJlciB9XG4gIEJBQ0tfQlVGRkVSX1JFQUNIRUQgPSAnaGxzQmFja0J1ZmZlclJlYWNoZWQnLFxuICAvLyBmaXJlZCBhZnRlciBzdGVlcmluZyBtYW5pZmVzdCBoYXMgYmVlbiBsb2FkZWQgLSBkYXRhOiB7IHN0ZWVyaW5nTWFuaWZlc3Q6IFN0ZWVyaW5nTWFuaWZlc3Qgb2JqZWN0LCB1cmw6IHN0ZWVyaW5nIG1hbmlmZXN0IFVSTCB9XG4gIFNURUVSSU5HX01BTklGRVNUX0xPQURFRCA9ICdobHNTdGVlcmluZ01hbmlmZXN0TG9hZGVkJyxcbn1cblxuLyoqXG4gKiBEZWZpbmVzIGVhY2ggRXZlbnQgdHlwZSBhbmQgcGF5bG9hZCBieSBFdmVudCBuYW1lLiBVc2VkIGluIHtAbGluayBobHMuanMjSGxzRXZlbnRFbWl0dGVyfSB0byBzdHJvbmdseSB0eXBlIHRoZSBldmVudCBsaXN0ZW5lciBBUEkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGxzTGlzdGVuZXJzIHtcbiAgW0V2ZW50cy5NRURJQV9BVFRBQ0hJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUVESUFfQVRUQUNIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hFRCxcbiAgICBkYXRhOiBNZWRpYUF0dGFjaGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1FRElBX0RFVEFDSElOR106IChldmVudDogRXZlbnRzLk1FRElBX0RFVEFDSElORykgPT4gdm9pZDtcbiAgW0V2ZW50cy5NRURJQV9ERVRBQ0hFRF06IChldmVudDogRXZlbnRzLk1FRElBX0RFVEFDSEVEKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9SRVNFVF06IChldmVudDogRXZlbnRzLkJVRkZFUl9SRVNFVCkgPT4gdm9pZDtcbiAgW0V2ZW50cy5CVUZGRVJfQ09ERUNTXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NPREVDUyxcbiAgICBkYXRhOiBCdWZmZXJDb2RlY3NEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0NSRUFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCxcbiAgICBkYXRhOiBCdWZmZXJDcmVhdGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLFxuICAgIGRhdGE6IEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5CVUZGRVJfQVBQRU5ERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsXG4gICAgZGF0YTogQnVmZmVyQXBwZW5kZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0VPU106IChldmVudDogRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGE6IEJ1ZmZlckVPU0RhdGEpID0+IHZvaWQ7XG4gIFtFdmVudHMuQlVGRkVSX0ZMVVNISU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0ZMVVNISU5HLFxuICAgIGRhdGE6IEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkJVRkZFUl9GTFVTSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0ZMVVNIRUQsXG4gICAgZGF0YTogQnVmZmVyRmx1c2hlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5NQU5JRkVTVF9MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BRElORyxcbiAgICBkYXRhOiBNYW5pZmVzdExvYWRpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUFOSUZFU1RfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BREVELFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLk1BTklGRVNUX1BBUlNFRF06IChcbiAgICBldmVudDogRXZlbnRzLk1BTklGRVNUX1BBUlNFRCxcbiAgICBkYXRhOiBNYW5pZmVzdFBhcnNlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5MRVZFTF9TV0lUQ0hJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsXG4gICAgZGF0YTogTGV2ZWxTd2l0Y2hpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfU1dJVENIRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9TV0lUQ0hFRCxcbiAgICBkYXRhOiBMZXZlbFN3aXRjaGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FESU5HLFxuICAgIGRhdGE6IExldmVsTG9hZGluZ0RhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5MRVZFTF9MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsXG4gICAgZGF0YTogTGV2ZWxMb2FkZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTEVWRUxfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsXG4gICAgZGF0YTogTGV2ZWxVcGRhdGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMX1BUU19VUERBVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxfUFRTX1VQREFURUQsXG4gICAgZGF0YTogTGV2ZWxQVFNVcGRhdGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxFVkVMU19VUERBVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxTX1VQREFURUQsXG4gICAgZGF0YTogTGV2ZWxzVXBkYXRlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLU19VUERBVEVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tzVXBkYXRlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsXG4gICAgZGF0YTogQXVkaW9UcmFja1N3aXRjaGluZ0RhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRF06IChcbiAgICBldmVudDogRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tTd2l0Y2hlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5BVURJT19UUkFDS19MT0FESU5HXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORyxcbiAgICBkYXRhOiBUcmFja0xvYWRpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tMb2FkZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCxcbiAgICBkYXRhOiBTdWJ0aXRsZVRyYWNrc1VwZGF0ZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSF06IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX1RSQUNLX1NXSVRDSCxcbiAgICBkYXRhOiBTdWJ0aXRsZVRyYWNrU3dpdGNoRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLFxuICAgIGRhdGE6IFRyYWNrTG9hZGluZ0RhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsXG4gICAgZGF0YTogU3VidGl0bGVUcmFja0xvYWRlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRF06IChcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELFxuICAgIGRhdGE6IFN1YnRpdGxlRnJhZ1Byb2Nlc3NlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5DVUVTX1BBUlNFRF06IChcbiAgICBldmVudDogRXZlbnRzLkNVRVNfUEFSU0VELFxuICAgIGRhdGE6IEN1ZXNQYXJzZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORF06IChcbiAgICBldmVudDogRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsXG4gICAgZGF0YTogTm9uTmF0aXZlVGV4dFRyYWNrc0RhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5JTklUX1BUU19GT1VORF06IChcbiAgICBldmVudDogRXZlbnRzLklOSVRfUFRTX0ZPVU5ELFxuICAgIGRhdGE6IEluaXRQVFNGb3VuZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURJTkcsXG4gICAgZGF0YTogRnJhZ0xvYWRpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIC8vIFtFdmVudHMuRlJBR19MT0FEX1BST0dSRVNTXTogVG9kb0V2ZW50VHlwZVxuICBbRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRF06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCxcbiAgICBkYXRhOiBGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19MT0FERURdOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURFRCxcbiAgICBkYXRhOiBGcmFnTG9hZGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfREVDUllQVEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19ERUNSWVBURUQsXG4gICAgZGF0YTogRnJhZ0RlY3J5cHRlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ0luaXRTZWdtZW50RGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQV06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ1VzZXJkYXRhRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQV06IChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSxcbiAgICBkYXRhOiBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSxcbiAgKSA9PiB2b2lkO1xuICAvLyBbRXZlbnRzLkZSQUdfUEFSU0lOR19EQVRBXTogVG9kb0V2ZW50VHlwZVxuICBbRXZlbnRzLkZSQUdfUEFSU0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19QQVJTRUQsXG4gICAgZGF0YTogRnJhZ1BhcnNlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5GUkFHX0JVRkZFUkVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19CVUZGRVJFRCxcbiAgICBkYXRhOiBGcmFnQnVmZmVyZWREYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuRlJBR19DSEFOR0VEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuRlJBR19DSEFOR0VELFxuICAgIGRhdGE6IEZyYWdDaGFuZ2VkRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZQU19EUk9QXTogKGV2ZW50OiBFdmVudHMuRlBTX0RST1AsIGRhdGE6IEZQU0Ryb3BEYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgIGRhdGE6IEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhLFxuICApID0+IHZvaWQ7XG4gIFtFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRF06IChcbiAgICBldmVudDogRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsXG4gICAgZGF0YTogTWF4QXV0b0xldmVsVXBkYXRlZERhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5FUlJPUl06IChldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpID0+IHZvaWQ7XG4gIFtFdmVudHMuREVTVFJPWUlOR106IChldmVudDogRXZlbnRzLkRFU1RST1lJTkcpID0+IHZvaWQ7XG4gIFtFdmVudHMuS0VZX0xPQURJTkddOiAoXG4gICAgZXZlbnQ6IEV2ZW50cy5LRVlfTE9BRElORyxcbiAgICBkYXRhOiBLZXlMb2FkaW5nRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLktFWV9MT0FERURdOiAoZXZlbnQ6IEV2ZW50cy5LRVlfTE9BREVELCBkYXRhOiBLZXlMb2FkZWREYXRhKSA9PiB2b2lkO1xuICBbRXZlbnRzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRF06IChcbiAgICBldmVudDogRXZlbnRzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCxcbiAgICBkYXRhOiBMaXZlQmFja0J1ZmZlckRhdGEsXG4gICkgPT4gdm9pZDtcbiAgW0V2ZW50cy5CQUNLX0JVRkZFUl9SRUFDSEVEXTogKFxuICAgIGV2ZW50OiBFdmVudHMuQkFDS19CVUZGRVJfUkVBQ0hFRCxcbiAgICBkYXRhOiBCYWNrQnVmZmVyRGF0YSxcbiAgKSA9PiB2b2lkO1xuICBbRXZlbnRzLlNURUVSSU5HX01BTklGRVNUX0xPQURFRF06IChcbiAgICBldmVudDogRXZlbnRzLlNURUVSSU5HX01BTklGRVNUX0xPQURFRCxcbiAgICBkYXRhOiBTdGVlcmluZ01hbmlmZXN0TG9hZGVkRGF0YSxcbiAgKSA9PiB2b2lkO1xufVxuZXhwb3J0IGludGVyZmFjZSBIbHNFdmVudEVtaXR0ZXIge1xuICBvbjxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzLCBDb250ZXh0ID0gdW5kZWZpbmVkPihcbiAgICBldmVudDogRSxcbiAgICBsaXN0ZW5lcjogSGxzTGlzdGVuZXJzW0VdLFxuICAgIGNvbnRleHQ/OiBDb250ZXh0LFxuICApOiB2b2lkO1xuICBvbmNlPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnMsIENvbnRleHQgPSB1bmRlZmluZWQ+KFxuICAgIGV2ZW50OiBFLFxuICAgIGxpc3RlbmVyOiBIbHNMaXN0ZW5lcnNbRV0sXG4gICAgY29udGV4dD86IENvbnRleHQsXG4gICk6IHZvaWQ7XG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50PzogRSk6IHZvaWQ7XG4gIG9mZjxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzLCBDb250ZXh0ID0gdW5kZWZpbmVkPihcbiAgICBldmVudDogRSxcbiAgICBsaXN0ZW5lcj86IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0PzogQ29udGV4dCxcbiAgICBvbmNlPzogYm9vbGVhbixcbiAgKTogdm9pZDtcblxuICBsaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBIbHNMaXN0ZW5lcnNbRV1bXTtcbiAgZW1pdDxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzPihcbiAgICBldmVudDogRSxcbiAgICBuYW1lOiBFLFxuICAgIGV2ZW50T2JqZWN0OiBQYXJhbWV0ZXJzPEhsc0xpc3RlbmVyc1tFXT5bMV0sXG4gICk6IGJvb2xlYW47XG4gIGxpc3RlbmVyQ291bnQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBudW1iZXI7XG59XG4iLCJleHBvcnQgZW51bSBFcnJvclR5cGVzIHtcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBuZXR3b3JrIGVycm9yIChsb2FkaW5nIGVycm9yIC8gdGltZW91dCAuLi4pXG4gIE5FVFdPUktfRVJST1IgPSAnbmV0d29ya0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtZWRpYSBFcnJvciAodmlkZW8vcGFyc2luZy9tZWRpYXNvdXJjZSBlcnJvcilcbiAgTUVESUFfRVJST1IgPSAnbWVkaWFFcnJvcicsXG4gIC8vIEVNRSAoZW5jcnlwdGVkIG1lZGlhIGV4dGVuc2lvbnMpIGVycm9yc1xuICBLRVlfU1lTVEVNX0VSUk9SID0gJ2tleVN5c3RlbUVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBtdXggRXJyb3IgKGRlbXV4aW5nL3JlbXV4aW5nKVxuICBNVVhfRVJST1IgPSAnbXV4RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbGwgb3RoZXIgZXJyb3JzXG4gIE9USEVSX0VSUk9SID0gJ290aGVyRXJyb3InLFxufVxuXG5leHBvcnQgZW51bSBFcnJvckRldGFpbHMge1xuICBLRVlfU1lTVEVNX05PX0tFWVMgPSAna2V5U3lzdGVtTm9LZXlzJyxcbiAgS0VZX1NZU1RFTV9OT19BQ0NFU1MgPSAna2V5U3lzdGVtTm9BY2Nlc3MnLFxuICBLRVlfU1lTVEVNX05PX1NFU1NJT04gPSAna2V5U3lzdGVtTm9TZXNzaW9uJyxcbiAgS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UgPSAna2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZScsXG4gIEtFWV9TWVNURU1fTElDRU5TRV9SRVFVRVNUX0ZBSUxFRCA9ICdrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZCcsXG4gIEtFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEID0gJ2tleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZCcsXG4gIEtFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQgPSAna2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWQnLFxuICBLRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCA9ICdrZXlTeXN0ZW1TZXNzaW9uVXBkYXRlRmFpbGVkJyxcbiAgS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQgPSAna2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZCcsXG4gIEtFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SID0gJ2tleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIE1BTklGRVNUX0xPQURfRVJST1IgPSAnbWFuaWZlc3RMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IGxvYWQgdGltZW91dCAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTUFOSUZFU1RfTE9BRF9USU1FT1VUID0gJ21hbmlmZXN0TG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIG1hbmlmZXN0IHBhcnNpbmcgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfUEFSU0lOR19FUlJPUiA9ICdtYW5pZmVzdFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbWFuaWZlc3Qgd2l0aCBvbmx5IGluY29tcGF0aWJsZSBjb2RlY3MgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlYXNvbiA6IGVycm9yIHJlYXNvbn1cbiAgTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9ICdtYW5pZmVzdEluY29tcGF0aWJsZUNvZGVjc0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBsZXZlbCB3aGljaCBjb250YWlucyBubyBmcmFnbWVudHMgLSBkYXRhOiB7IHVybDogZmF1bHR5IFVSTCwgcmVhc29uOiBcIm5vIGZyYWdtZW50cyBmb3VuZCBpbiBsZXZlbFwiLCBsZXZlbDogaW5kZXggb2YgdGhlIGJhZCBsZXZlbCB9XG4gIExFVkVMX0VNUFRZX0VSUk9SID0gJ2xldmVsRW1wdHlFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCBlcnJvciAtIGRhdGE6IHsgdXJsIDogZmF1bHR5IFVSTCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgTEVWRUxfTE9BRF9FUlJPUiA9ICdsZXZlbExvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBMRVZFTF9MT0FEX1RJTUVPVVQgPSAnbGV2ZWxMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgcGFyc2UgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIGVycm9yOiBFcnJvciwgcmVhc29uOiBlcnJvciBtZXNzYWdlIH1cbiAgTEVWRUxfUEFSU0lOR19FUlJPUiA9ICdsZXZlbFBhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgbGV2ZWwgc3dpdGNoIGVycm9yIC0gZGF0YTogeyBsZXZlbCA6IGZhdWx0eSBsZXZlbCBJZCwgZXZlbnQgOiBlcnJvciBkZXNjcmlwdGlvbn1cbiAgTEVWRUxfU1dJVENIX0VSUk9SID0gJ2xldmVsU3dpdGNoRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIGVycm9yIC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBBVURJT19UUkFDS19MT0FEX0VSUk9SID0gJ2F1ZGlvVHJhY2tMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBhdWRpbyB0cmFjayBsb2FkIHRpbWVvdXQgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIEFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA9ICdhdWRpb1RyYWNrTG9hZFRpbWVPdXQnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHN1YnRpdGxlIHRyYWNrIGxvYWQgZXJyb3IgLSBkYXRhOiB7IHVybCA6IGZhdWx0eSBVUkwsIHJlc3BvbnNlIDogeyBjb2RlOiBlcnJvciBjb2RlLCB0ZXh0OiBlcnJvciB0ZXh0IH19XG4gIFNVQlRJVExFX0xPQURfRVJST1IgPSAnc3VidGl0bGVUcmFja0xvYWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgc3VidGl0bGUgdHJhY2sgbG9hZCB0aW1lb3V0IC0gZGF0YTogeyB1cmwgOiBmYXVsdHkgVVJMLCByZXNwb25zZSA6IHsgY29kZTogZXJyb3IgY29kZSwgdGV4dDogZXJyb3IgdGV4dCB9fVxuICBTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgPSAnc3VidGl0bGVUcmFja0xvYWRUaW1lT3V0JyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZnJhZ21lbnQgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgRlJBR19MT0FEX0VSUk9SID0gJ2ZyYWdMb2FkRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBmcmFnbWVudCBsb2FkIHRpbWVvdXQgZXJyb3IgLSBkYXRhOiB7IGZyYWcgOiBmcmFnbWVudCBvYmplY3R9XG4gIEZSQUdfTE9BRF9USU1FT1VUID0gJ2ZyYWdMb2FkVGltZU91dCcsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgZGVjcnlwdGlvbiBlcnJvciBldmVudCAtIGRhdGE6IHtpZCA6IGRlbXV4ZXIgSWQsZnJhZzogZnJhZ21lbnQgb2JqZWN0LCByZWFzb24gOiBwYXJzaW5nIGVycm9yIGRlc2NyaXB0aW9uIH1cbiAgRlJBR19ERUNSWVBUX0VSUk9SID0gJ2ZyYWdEZWNyeXB0RXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGZyYWdtZW50IHBhcnNpbmcgZXJyb3IgZXZlbnQgLSBkYXRhOiB7IGlkIDogZGVtdXhlciBJZCwgcmVhc29uIDogcGFyc2luZyBlcnJvciBkZXNjcmlwdGlvbiB9XG4gIC8vIHdpbGwgYmUgcmVuYW1lZCBERU1VWF9QQVJTSU5HX0VSUk9SIGFuZCBzd2l0Y2hlZCB0byBNVVhfRVJST1IgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxuICBGUkFHX1BBUlNJTkdfRVJST1IgPSAnZnJhZ1BhcnNpbmdFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgZnJhZ21lbnQgb3IgcGFydCBsb2FkIHNraXBwZWQgYmVjYXVzZSBvZiBhIEdBUCB0YWcgb3IgYXR0cmlidXRlXG4gIEZSQUdfR0FQID0gJ2ZyYWdHYXAnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIHJlbXV4IGFsbG9jIGVycm9yIGV2ZW50IC0gZGF0YTogeyBpZCA6IGRlbXV4ZXIgSWQsIGZyYWcgOiBmcmFnbWVudCBvYmplY3QsIGJ5dGVzIDogbmIgb2YgYnl0ZXMgb24gd2hpY2ggYWxsb2NhdGlvbiBmYWlsZWQgLCByZWFzb24gOiBlcnJvciB0ZXh0IH1cbiAgUkVNVVhfQUxMT0NfRVJST1IgPSAncmVtdXhBbGxvY0Vycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCBlcnJvciAtIGRhdGE6IHsgZnJhZyA6IGZyYWdtZW50IG9iamVjdCwgcmVzcG9uc2UgOiB7IGNvZGU6IGVycm9yIGNvZGUsIHRleHQ6IGVycm9yIHRleHQgfX1cbiAgS0VZX0xPQURfRVJST1IgPSAna2V5TG9hZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgZGVjcnlwdCBrZXkgbG9hZCB0aW1lb3V0IGVycm9yIC0gZGF0YTogeyBmcmFnIDogZnJhZ21lbnQgb2JqZWN0fVxuICBLRVlfTE9BRF9USU1FT1VUID0gJ2tleUxvYWRUaW1lT3V0JyxcbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gZXhjZXB0aW9uIG9jY3VycyB3aGlsZSBhZGRpbmcgYSBzb3VyY2VCdWZmZXIgdG8gTWVkaWFTb3VyY2UgLSBkYXRhIDogeyBlcnJvciA6IGV4Y2VwdGlvbiAsIG1pbWVUeXBlIDogbWltZVR5cGUgfVxuICBCVUZGRVJfQUREX0NPREVDX0VSUk9SID0gJ2J1ZmZlckFkZENvZGVjRXJyb3InLFxuICAvLyBUcmlnZ2VyZWQgd2hlbiBzb3VyY2UgYnVmZmVyKHMpIGNvdWxkIG5vdCBiZSBjcmVhdGVkIHVzaW5nIGxldmVsIChtYW5pZmVzdCBDT0RFQ1MgYXR0cmlidXRlKSwgcGFyc2VkIG1lZGlhLCBvciBiZXN0IGd1ZXNzIGNvZGVjKHMpIC0gZGF0YTogeyByZWFzb24gOiBlcnJvciByZWFzb24gfVxuICBCVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9ICdidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGFwcGVuZCBlcnJvciAtIGRhdGE6IGFwcGVuZCBlcnJvciBkZXNjcmlwdGlvblxuICBCVUZGRVJfQVBQRU5EX0VSUk9SID0gJ2J1ZmZlckFwcGVuZEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgYXBwZW5kaW5nIGVycm9yIGV2ZW50IC0gZGF0YTogYXBwZW5kaW5nIGVycm9yIGRlc2NyaXB0aW9uXG4gIEJVRkZFUl9BUFBFTkRJTkdfRVJST1IgPSAnYnVmZmVyQXBwZW5kaW5nRXJyb3InLFxuICAvLyBJZGVudGlmaWVyIGZvciBhIGJ1ZmZlciBzdGFsbGVkIGVycm9yIGV2ZW50XG4gIEJVRkZFUl9TVEFMTEVEX0VSUk9SID0gJ2J1ZmZlclN0YWxsZWRFcnJvcicsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIGZ1bGwgZXZlbnRcbiAgQlVGRkVSX0ZVTExfRVJST1IgPSAnYnVmZmVyRnVsbEVycm9yJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYSBidWZmZXIgc2VlayBvdmVyIGhvbGUgZXZlbnRcbiAgQlVGRkVSX1NFRUtfT1ZFUl9IT0xFID0gJ2J1ZmZlclNlZWtPdmVySG9sZScsXG4gIC8vIElkZW50aWZpZXIgZm9yIGEgYnVmZmVyIG51ZGdlIG9uIHN0YWxsIChwbGF5YmFjayBpcyBzdHVjayBhbHRob3VnaCBjdXJyZW50VGltZSBpcyBpbiBhIGJ1ZmZlcmVkIGFyZWEpXG4gIEJVRkZFUl9OVURHRV9PTl9TVEFMTCA9ICdidWZmZXJOdWRnZU9uU3RhbGwnLFxuICAvLyBJZGVudGlmaWVyIGZvciBhbiBpbnRlcm5hbCBleGNlcHRpb24gaGFwcGVuaW5nIGluc2lkZSBobHMuanMgd2hpbGUgaGFuZGxpbmcgYW4gZXZlbnRcbiAgSU5URVJOQUxfRVhDRVBUSU9OID0gJ2ludGVybmFsRXhjZXB0aW9uJyxcbiAgLy8gSWRlbnRpZmllciBmb3IgYW4gaW50ZXJuYWwgY2FsbCB0byBhYm9ydCBhIGxvYWRlclxuICBJTlRFUk5BTF9BQk9SVEVEID0gJ2Fib3J0ZWQnLFxuICAvLyBVbmNhdGVnb3JpemVkIGVycm9yXG4gIFVOS05PV04gPSAndW5rbm93bicsXG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIElMb2dGdW5jdGlvbiB7XG4gIChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElMb2dnZXIge1xuICB0cmFjZTogSUxvZ0Z1bmN0aW9uO1xuICBkZWJ1ZzogSUxvZ0Z1bmN0aW9uO1xuICBsb2c6IElMb2dGdW5jdGlvbjtcbiAgd2FybjogSUxvZ0Z1bmN0aW9uO1xuICBpbmZvOiBJTG9nRnVuY3Rpb247XG4gIGVycm9yOiBJTG9nRnVuY3Rpb247XG59XG5cbmNvbnN0IG5vb3A6IElMb2dGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG5jb25zdCBmYWtlTG9nZ2VyOiBJTG9nZ2VyID0ge1xuICB0cmFjZTogbm9vcCxcbiAgZGVidWc6IG5vb3AsXG4gIGxvZzogbm9vcCxcbiAgd2Fybjogbm9vcCxcbiAgaW5mbzogbm9vcCxcbiAgZXJyb3I6IG5vb3AsXG59O1xuXG5sZXQgZXhwb3J0ZWRMb2dnZXI6IElMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuXG4vLyBsZXQgbGFzdENhbGxUaW1lO1xuLy8gZnVuY3Rpb24gZm9ybWF0TXNnV2l0aFRpbWVJbmZvKHR5cGUsIG1zZykge1xuLy8gICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuLy8gICBjb25zdCBkaWZmID0gbGFzdENhbGxUaW1lID8gJysnICsgKG5vdyAtIGxhc3RDYWxsVGltZSkgOiAnMCc7XG4vLyAgIGxhc3RDYWxsVGltZSA9IG5vdztcbi8vICAgbXNnID0gKG5ldyBEYXRlKG5vdykpLnRvSVNPU3RyaW5nKCkgKyAnIHwgWycgKyAgdHlwZSArICddID4gJyArIG1zZyArICcgKCAnICsgZGlmZiArICcgbXMgKSc7XG4vLyAgIHJldHVybiBtc2c7XG4vLyB9XG5cbmZ1bmN0aW9uIGNvbnNvbGVQcmludEZuKHR5cGU6IHN0cmluZyk6IElMb2dGdW5jdGlvbiB7XG4gIGNvbnN0IGZ1bmM6IElMb2dGdW5jdGlvbiA9IHNlbGYuY29uc29sZVt0eXBlXTtcbiAgaWYgKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYy5iaW5kKHNlbGYuY29uc29sZSwgYFske3R5cGV9XSA+YCk7XG4gIH1cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhcbiAgZGVidWdDb25maWc6IGJvb2xlYW4gfCBJTG9nZ2VyLFxuICAuLi5mdW5jdGlvbnM6IHN0cmluZ1tdXG4pOiB2b2lkIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdXG4gICAgICA/IGRlYnVnQ29uZmlnW3R5cGVdLmJpbmQoZGVidWdDb25maWcpXG4gICAgICA6IGNvbnNvbGVQcmludEZuKHR5cGUpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ3MoZGVidWdDb25maWc6IGJvb2xlYW4gfCBJTG9nZ2VyLCBpZDogc3RyaW5nKTogdm9pZCB7XG4gIC8vIGNoZWNrIHRoYXQgY29uc29sZSBpcyBhdmFpbGFibGVcbiAgaWYgKFxuICAgICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgZGVidWdDb25maWcgPT09IHRydWUpIHx8XG4gICAgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0J1xuICApIHtcbiAgICBleHBvcnRMb2dnZXJGdW5jdGlvbnMoXG4gICAgICBkZWJ1Z0NvbmZpZyxcbiAgICAgIC8vIFJlbW92ZSBvdXQgZnJvbSBsaXN0IGhlcmUgdG8gaGFyZC1kaXNhYmxlIGEgbG9nLWxldmVsXG4gICAgICAvLyAndHJhY2UnLFxuICAgICAgJ2RlYnVnJyxcbiAgICAgICdsb2cnLFxuICAgICAgJ2luZm8nLFxuICAgICAgJ3dhcm4nLFxuICAgICAgJ2Vycm9yJyxcbiAgICApO1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3QgYWxsb3cgdG8gdXNlIGJpbmQgb24gY29uc29sZSBvYmplY3QgYW55d2F5XG4gICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBpZiBuZWVkZWRcbiAgICB0cnkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIubG9nKFxuICAgICAgICBgRGVidWcgbG9ncyBlbmFibGVkIGZvciBcIiR7aWR9XCIgaW4gaGxzLmpzIHZlcnNpb24gJHtfX1ZFUlNJT05fX31gLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9nZ2VyOiBJTG9nZ2VyID0gZXhwb3J0ZWRMb2dnZXI7XG4iLCJjb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5leHBvcnQgY2xhc3MgQXR0ckxpc3Qge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoYXR0cnM6IHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuICAgICAgYXR0cnMgPSBBdHRyTGlzdC5wYXJzZUF0dHJMaXN0KGF0dHJzKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRycyk7XG4gIH1cblxuICBnZXQgY2xpZW50QXR0cnMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5maWx0ZXIoKGF0dHIpID0+IGF0dHIuc3Vic3RyaW5nKDAsIDIpID09PSAnWC0nKTtcbiAgfVxuXG4gIGRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBpbnRWYWx1ZTtcbiAgfVxuXG4gIGhleGFkZWNpbWFsSW50ZWdlcihhdHRyTmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nVmFsdWUubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YWx1ZVtpXSA9IHBhcnNlSW50KHN0cmluZ1ZhbHVlLnNsaWNlKGkgKiAyLCBpICogMiArIDIpLCAxNik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0aGlzW2F0dHJOYW1lXSwgMTYpO1xuICAgIGlmIChpbnRWYWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG5cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoYXR0ck5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG5cbiAgb3B0aW9uYWxGbG9hdChhdHRyTmFtZTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzW2F0dHJOYW1lXTtcbiAgICByZXR1cm4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIGVudW1lcmF0ZWRTdHJpbmcoYXR0ck5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdO1xuICB9XG5cbiAgYm9vbChhdHRyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdID09PSAnWUVTJztcbiAgfVxuXG4gIGRlY2ltYWxSZXNvbHV0aW9uKGF0dHJOYW1lOiBzdHJpbmcpOlxuICAgIHwge1xuICAgICAgICB3aWR0aDogbnVtYmVyO1xuICAgICAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICAgIH1cbiAgICB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcmVzID0gREVDSU1BTF9SRVNPTFVUSU9OX1JFR0VYLmV4ZWModGhpc1thdHRyTmFtZV0pO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwYXJzZUludChyZXNbMV0sIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQocmVzWzJdLCAxMCksXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZUF0dHJMaXN0KGlucHV0OiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmXG4gICAgICAgIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMVxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhdHRycztcbiAgfVxufVxuIiwiaW1wb3J0IHsgQXR0ckxpc3QgfSBmcm9tICcuLi91dGlscy9hdHRyLWxpc3QnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcblxuLy8gQXZvaWQgZXhwb3J0aW5nIGNvbnN0IGVudW0gc28gdGhhdCB0aGVzZSB2YWx1ZXMgY2FuIGJlIGlubGluZWRcbmNvbnN0IGVudW0gRGF0ZVJhbmdlQXR0cmlidXRlIHtcbiAgSUQgPSAnSUQnLFxuICBDTEFTUyA9ICdDTEFTUycsXG4gIFNUQVJUX0RBVEUgPSAnU1RBUlQtREFURScsXG4gIERVUkFUSU9OID0gJ0RVUkFUSU9OJyxcbiAgRU5EX0RBVEUgPSAnRU5ELURBVEUnLFxuICBFTkRfT05fTkVYVCA9ICdFTkQtT04tTkVYVCcsXG4gIFBMQU5ORURfRFVSQVRJT04gPSAnUExBTk5FRC1EVVJBVElPTicsXG4gIFNDVEUzNV9PVVQgPSAnU0NURTM1LU9VVCcsXG4gIFNDVEUzNV9JTiA9ICdTQ1RFMzUtSU4nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoYXR0ck5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuSUQgJiZcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLkNMQVNTICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TVEFSVF9EQVRFICYmXG4gICAgYXR0ck5hbWUgIT09IERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTiAmJlxuICAgIGF0dHJOYW1lICE9PSBEYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX0RBVEUgJiZcbiAgICBhdHRyTmFtZSAhPT0gRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9PTl9ORVhUXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NDVEUzNUF0dHJpYnV0ZShhdHRyTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgYXR0ck5hbWUgPT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TQ1RFMzVfT1VUIHx8XG4gICAgYXR0ck5hbWUgPT09IERhdGVSYW5nZUF0dHJpYnV0ZS5TQ1RFMzVfSU5cbiAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIERhdGVSYW5nZSB7XG4gIHB1YmxpYyBhdHRyOiBBdHRyTGlzdDtcbiAgcHJpdmF0ZSBfc3RhcnREYXRlOiBEYXRlO1xuICBwcml2YXRlIF9lbmREYXRlPzogRGF0ZTtcbiAgcHJpdmF0ZSBfYmFkVmFsdWVGb3JTYW1lSWQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoZGF0ZVJhbmdlQXR0cjogQXR0ckxpc3QsIGRhdGVSYW5nZVdpdGhTYW1lSWQ/OiBEYXRlUmFuZ2UpIHtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJlxuICAgICAgICAgIGRhdGVSYW5nZUF0dHJba2V5XSAhPT0gcHJldmlvdXNBdHRyW2tleV1cbiAgICAgICAgKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgREFURVJBTkdFIHRhZyBhdHRyaWJ1dGU6IFwiJHtrZXl9XCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXCIke2RhdGVSYW5nZUF0dHIuSUR9XCJgLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICBwcmV2aW91c0F0dHIsXG4gICAgICAgIGRhdGVSYW5nZUF0dHIsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmF0dHIgPSBkYXRlUmFuZ2VBdHRyO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGVSYW5nZUF0dHJbRGF0ZVJhbmdlQXR0cmlidXRlLlNUQVJUX0RBVEVdKTtcbiAgICBpZiAoRGF0ZVJhbmdlQXR0cmlidXRlLkVORF9EQVRFIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKHRoaXMuYXR0cltEYXRlUmFuZ2VBdHRyaWJ1dGUuRU5EX0RBVEVdKTtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZW5kRGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHRoaXMuX2VuZERhdGUgPSBlbmREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmF0dHIuSUQ7XG4gIH1cblxuICBnZXQgY2xhc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLkNMQVNTO1xuICB9XG5cbiAgZ2V0IHN0YXJ0RGF0ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnREYXRlO1xuICB9XG5cbiAgZ2V0IGVuZERhdGUoKTogRGF0ZSB8IG51bGwge1xuICAgIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5kRGF0ZTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xuICAgIGlmIChkdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyBkdXJhdGlvbiAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBkdXJhdGlvbigpOiBudW1iZXIgfCBudWxsIHtcbiAgICBpZiAoRGF0ZVJhbmdlQXR0cmlidXRlLkRVUkFUSU9OIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXG4gICAgICAgIERhdGVSYW5nZUF0dHJpYnV0ZS5EVVJBVElPTixcbiAgICAgICk7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2VuZERhdGUuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBwbGFubmVkRHVyYXRpb24oKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKERhdGVSYW5nZUF0dHJpYnV0ZS5QTEFOTkVEX0RVUkFUSU9OIGluIHRoaXMuYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcbiAgICAgICAgRGF0ZVJhbmdlQXR0cmlidXRlLlBMQU5ORURfRFVSQVRJT04sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBlbmRPbk5leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5ib29sKERhdGVSYW5nZUF0dHJpYnV0ZS5FTkRfT05fTkVYVCk7XG4gIH1cblxuICBnZXQgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgISF0aGlzLmlkICYmXG4gICAgICAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiZcbiAgICAgIE51bWJlci5pc0Zpbml0ZSh0aGlzLnN0YXJ0RGF0ZS5nZXRUaW1lKCkpICYmXG4gICAgICAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmXG4gICAgICAoIXRoaXMuZW5kT25OZXh0IHx8ICEhdGhpcy5jbGFzcylcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIEhsc1BlcmZvcm1hbmNlVGltaW5nLFxuICBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nLFxuICBMb2FkZXJTdGF0cyxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcblxuZXhwb3J0IGNsYXNzIExvYWRTdGF0cyBpbXBsZW1lbnRzIExvYWRlclN0YXRzIHtcbiAgYWJvcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBsb2FkZWQ6IG51bWJlciA9IDA7XG4gIHJldHJ5OiBudW1iZXIgPSAwO1xuICB0b3RhbDogbnVtYmVyID0gMDtcbiAgY2h1bmtDb3VudDogbnVtYmVyID0gMDtcbiAgYndFc3RpbWF0ZTogbnVtYmVyID0gMDtcbiAgbG9hZGluZzogSGxzUHJvZ3Jlc3NpdmVQZXJmb3JtYW5jZVRpbWluZyA9IHsgc3RhcnQ6IDAsIGZpcnN0OiAwLCBlbmQ6IDAgfTtcbiAgcGFyc2luZzogSGxzUGVyZm9ybWFuY2VUaW1pbmcgPSB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbiAgYnVmZmVyaW5nOiBIbHNQcm9ncmVzc2l2ZVBlcmZvcm1hbmNlVGltaW5nID0geyBzdGFydDogMCwgZmlyc3Q6IDAsIGVuZDogMCB9O1xufVxuIiwiaW1wb3J0IHsgYnVpbGRBYnNvbHV0ZVVSTCB9IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCB7IExldmVsS2V5IH0gZnJvbSAnLi9sZXZlbC1rZXknO1xuaW1wb3J0IHsgTG9hZFN0YXRzIH0gZnJvbSAnLi9sb2FkLXN0YXRzJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIHtcbiAgRnJhZ21lbnRMb2FkZXJDb250ZXh0LFxuICBLZXlMb2FkZXJDb250ZXh0LFxuICBMb2FkZXIsXG4gIFBsYXlsaXN0TGV2ZWxUeXBlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBLZXlTeXN0ZW1Gb3JtYXRzIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB7XG4gIEFVRElPID0gJ2F1ZGlvJyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBBVURJT1ZJREVPID0gJ2F1ZGlvdmlkZW8nLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRhcnlTdHJlYW1JbmZvIHtcbiAgc3RhcnRQVFM6IG51bWJlcjtcbiAgZW5kUFRTOiBudW1iZXI7XG4gIHN0YXJ0RFRTOiBudW1iZXI7XG4gIGVuZERUUzogbnVtYmVyO1xuICBwYXJ0aWFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgRWxlbWVudGFyeVN0cmVhbXMgPSBSZWNvcmQ8XG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgRWxlbWVudGFyeVN0cmVhbUluZm8gfCBudWxsXG4+O1xuXG5leHBvcnQgY2xhc3MgQmFzZVNlZ21lbnQge1xuICBwcml2YXRlIF9ieXRlUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gIHB1YmxpYyByZWFkb25seSBiYXNldXJsOiBzdHJpbmc7XG4gIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICBwdWJsaWMgcmVsdXJsPzogc3RyaW5nO1xuICAvLyBIb2xkcyB0aGUgdHlwZXMgb2YgZGF0YSB0aGlzIGZyYWdtZW50IHN1cHBvcnRzXG4gIHB1YmxpYyBlbGVtZW50YXJ5U3RyZWFtczogRWxlbWVudGFyeVN0cmVhbXMgPSB7XG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT106IG51bGwsXG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT106IG51bGwsXG4gICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXTogbnVsbCxcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihiYXNldXJsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmJhc2V1cmwgPSBiYXNldXJsO1xuICB9XG5cbiAgLy8gc2V0Qnl0ZVJhbmdlIGNvbnZlcnRzIGEgRVhULVgtQllURVJBTkdFIGF0dHJpYnV0ZSBpbnRvIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgc2V0Qnl0ZVJhbmdlKHZhbHVlOiBzdHJpbmcsIHByZXZpb3VzPzogQmFzZVNlZ21lbnQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB2YWx1ZS5zcGxpdCgnQCcsIDIpO1xuICAgIGxldCBzdGFydDogbnVtYmVyO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzdGFydCA9IHByZXZpb3VzPy5ieXRlUmFuZ2VFbmRPZmZzZXQgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBwYXJzZUludChwYXJhbXNbMV0pO1xuICAgIH1cbiAgICB0aGlzLl9ieXRlUmFuZ2UgPSBbc3RhcnQsIHBhcnNlSW50KHBhcmFtc1swXSkgKyBzdGFydF07XG4gIH1cblxuICBnZXQgYnl0ZVJhbmdlKCk6IFtudW1iZXIsIG51bWJlcl0gfCBbXSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlO1xuICB9XG5cbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0KCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG5cbiAgZ2V0IGJ5dGVSYW5nZUVuZE9mZnNldCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuXG4gIGdldCB1cmwoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwpIHtcbiAgICAgIHRoaXMuX3VybCA9IGJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCwge1xuICAgICAgICBhbHdheXNOb3JtYWxpemU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuXG4gIHNldCB1cmwodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX3VybCA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyBwYXJzZWQgZGF0YSBmcm9tIGFuIEhMUyBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5mcmFnbWVudHN9LlxuICovXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIHByaXZhdGUgX2RlY3J5cHRkYXRhOiBMZXZlbEtleSB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyByYXdQcm9ncmFtRGF0ZVRpbWU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgcHJvZ3JhbURhdGVUaW1lOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIHRhZ0xpc3Q6IEFycmF5PHN0cmluZ1tdPiA9IFtdO1xuXG4gIC8vIEVYVElORiBoYXMgdG8gYmUgcHJlc2VudCBmb3IgYSBtM3U4IHRvIGJlIGNvbnNpZGVyZWQgdmFsaWRcbiAgcHVibGljIGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICAvLyBzbiBub3RhdGVzIHRoZSBzZXF1ZW5jZSBudW1iZXIgZm9yIGEgc2VnbWVudCwgYW5kIGlmIHNldCB0byBhIHN0cmluZyBjYW4gYmUgJ2luaXRTZWdtZW50J1xuICBwdWJsaWMgc246IG51bWJlciB8ICdpbml0U2VnbWVudCcgPSAwO1xuICAvLyBsZXZlbGtleXMgYXJlIHRoZSBFWFQtWC1LRVkgdGFncyB0aGF0IGFwcGx5IHRvIHRoaXMgc2VnbWVudCBmb3IgZGVjcnlwdGlvblxuICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gIC8vIF9kZWNyeXB0ZGF0YSB3aWxsIHNldCB0aGUgSVYgZm9yIHRoaXMgc2VnbWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCBudW1iZXIgaW4gdGhlIGZyYWdtZW50XG4gIHB1YmxpYyBsZXZlbGtleXM/OiB7IFtrZXk6IHN0cmluZ106IExldmVsS2V5IH07XG4gIC8vIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZnJhZ21lbnQgdHlwZVxuICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogUGxheWxpc3RMZXZlbFR5cGU7XG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBsb2FkZXIuIFNldCB3aGlsZSB0aGUgZnJhZ21lbnQgaXMgbG9hZGluZywgYW5kIHJlbW92ZWQgYWZ0ZXJ3YXJkcy4gVXNlZCB0byBhYm9ydCBmcmFnbWVudCBsb2FkaW5nXG4gIHB1YmxpYyBsb2FkZXI6IExvYWRlcjxGcmFnbWVudExvYWRlckNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG4gIC8vIEEgcmVmZXJlbmNlIHRvIHRoZSBrZXkgbG9hZGVyLiBTZXQgd2hpbGUgdGhlIGtleSBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGtleSBsb2FkaW5nXG4gIHB1YmxpYyBrZXlMb2FkZXI6IExvYWRlcjxLZXlMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICAvLyBUaGUgbGV2ZWwvdHJhY2sgaW5kZXggdG8gd2hpY2ggdGhlIGZyYWdtZW50IGJlbG9uZ3NcbiAgcHVibGljIGxldmVsOiBudW1iZXIgPSAtMTtcbiAgLy8gVGhlIGNvbnRpbnVpdHkgY291bnRlciBvZiB0aGUgZnJhZ21lbnRcbiAgcHVibGljIGNjOiBudW1iZXIgPSAwO1xuICAvLyBUaGUgc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBzdGFydFBUUz86IG51bWJlcjtcbiAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIGVuZFBUUz86IG51bWJlcjtcbiAgLy8gVGhlIHN0YXJ0aW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgc3RhcnREVFMhOiBudW1iZXI7XG4gIC8vIFRoZSBlbmRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gIHB1YmxpYyBlbmREVFMhOiBudW1iZXI7XG4gIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIHN0YXJ0OiBudW1iZXIgPSAwO1xuICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICBwdWJsaWMgZGVsdGFQVFM/OiBudW1iZXI7XG4gIC8vIFRoZSBtYXhpbXVtIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChhdWRpby92aWRlbyBQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICBwdWJsaWMgbWF4U3RhcnRQVFM/OiBudW1iZXI7XG4gIC8vIFRoZSBtaW5pbXVtIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoYXVkaW8vdmlkZW8gUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgcHVibGljIG1pbkVuZFBUUz86IG51bWJlcjtcbiAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgcHVibGljIHN0YXRzOiBMb2FkU3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gIC8vIEluaXQgU2VnbWVudCBieXRlcyAodW5zZXQgZm9yIG1lZGlhIHNlZ21lbnRzKVxuICBwdWJsaWMgZGF0YT86IFVpbnQ4QXJyYXk7XG4gIC8vIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNlZ21lbnQgd2FzIGRvd25sb2FkZWQgaW4gb3JkZXIgdG8gdGVzdCBiaXRyYXRlLCBhbmQgd2FzIG5vdCBidWZmZXJlZFxuICBwdWJsaWMgYml0cmF0ZVRlc3Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICBwdWJsaWMgdGl0bGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAvLyBUaGUgTWVkaWEgSW5pdGlhbGl6YXRpb24gU2VjdGlvbiBmb3IgdGhpcyBzZWdtZW50XG4gIHB1YmxpYyBpbml0U2VnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgLy8gRnJhZ21lbnQgaXMgdGhlIGxhc3QgZnJhZ21lbnQgaW4gdGhlIG1lZGlhIHBsYXlsaXN0XG4gIHB1YmxpYyBlbmRMaXN0PzogYm9vbGVhbjtcbiAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgcHVibGljIGdhcD86IGJvb2xlYW47XG4gIC8vIERlcHJlY2F0ZWRcbiAgcHVibGljIHVybElkOiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLCBiYXNldXJsOiBzdHJpbmcpIHtcbiAgICBzdXBlcihiYXNldXJsKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRlY3J5cHRkYXRhKCk6IExldmVsS2V5IHwgbnVsbCB7XG4gICAgY29uc3QgeyBsZXZlbGtleXMgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RlY3J5cHRkYXRhICYmIHRoaXMubGV2ZWxrZXlzICYmICF0aGlzLmxldmVsa2V5cy5OT05FKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmxldmVsa2V5cy5pZGVudGl0eTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBrZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlGb3JtYXRzID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgICBpZiAoa2V5Rm9ybWF0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNbXG4gICAgICAgICAgICBrZXlGb3JtYXRzWzBdXG4gICAgICAgICAgXS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTXVsdGlwbGUga2V5cy4ga2V5LWxvYWRlciB0byBjYWxsIEZyYWdtZW50LnNldEtleUZvcm1hdCBiYXNlZCBvbiBzZWxlY3RlZCBrZXktc3lzdGVtLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG5cbiAgZ2V0IGVuZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcbiAgfVxuXG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gIU51bWJlci5pc0Zpbml0ZSh0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuXG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgZHVyYXRpb24gKiAxMDAwO1xuICB9XG5cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICAvLyBBdCB0aGUgbTN1OC1wYXJzZXIgbGV2ZWwgd2UgbmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbWFuaWZlc3Qgc2lnbmFsbGVkIGtleWZvcm1hdHNcbiAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIGZyYWdtZW50IHRvIHN0YXJ0IHJlcG9ydGluZyB0aGF0IGl0IGlzIGVuY3J5cHRlZC5cbiAgICAvLyBDdXJyZW50bHksIGtleUZvcm1hdCB3aWxsIG9ubHkgYmUgc2V0IGZvciBpZGVudGl0eSBrZXlzXG4gICAgaWYgKHRoaXMuX2RlY3J5cHRkYXRhPy5lbmNyeXB0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyh0aGlzLmxldmVsa2V5cyk7XG4gICAgICBjb25zdCBsZW4gPSBrZXlGb3JtYXRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW4gPiAxIHx8IChsZW4gPT09IDEgJiYgdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZW5jcnlwdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzZXRLZXlGb3JtYXQoa2V5Rm9ybWF0OiBLZXlTeXN0ZW1Gb3JtYXRzKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxrZXlzKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmxldmVsa2V5c1trZXlGb3JtYXRdO1xuICAgICAgaWYgKGtleSAmJiAhdGhpcy5fZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBrZXkuZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWJvcnRSZXF1ZXN0cygpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRlcj8uYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlcj8uYWJvcnQoKTtcbiAgfVxuXG4gIHNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKFxuICAgIHR5cGU6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgICBzdGFydFBUUzogbnVtYmVyLFxuICAgIGVuZFBUUzogbnVtYmVyLFxuICAgIHN0YXJ0RFRTOiBudW1iZXIsXG4gICAgZW5kRFRTOiBudW1iZXIsXG4gICAgcGFydGlhbDogYm9vbGVhbiA9IGZhbHNlLFxuICApIHtcbiAgICBjb25zdCB7IGVsZW1lbnRhcnlTdHJlYW1zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGluZm8gPSBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zW3R5cGVdID0ge1xuICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTLFxuICAgICAgICBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmZvLnN0YXJ0UFRTID0gTWF0aC5taW4oaW5mby5zdGFydFBUUywgc3RhcnRQVFMpO1xuICAgIGluZm8uZW5kUFRTID0gTWF0aC5tYXgoaW5mby5lbmRQVFMsIGVuZFBUUyk7XG4gICAgaW5mby5zdGFydERUUyA9IE1hdGgubWluKGluZm8uc3RhcnREVFMsIHN0YXJ0RFRTKTtcbiAgICBpbmZvLmVuZERUUyA9IE1hdGgubWF4KGluZm8uZW5kRFRTLCBlbmREVFMpO1xuICB9XG5cbiAgY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpIHtcbiAgICBjb25zdCB7IGVsZW1lbnRhcnlTdHJlYW1zIH0gPSB0aGlzO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10gPSBudWxsO1xuICAgIGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFBhcnRpYWwgU2VnbWVudC4gRm91bmQgaW4ge0BsaW5rIGhscy5qcyNMZXZlbERldGFpbHMucGFydExpc3R9LlxuICovXG5leHBvcnQgY2xhc3MgUGFydCBleHRlbmRzIEJhc2VTZWdtZW50IHtcbiAgcHVibGljIHJlYWRvbmx5IGZyYWdPZmZzZXQ6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBkdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgcHVibGljIHJlYWRvbmx5IGdhcDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgaW5kZXBlbmRlbnQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHJlYWRvbmx5IHJlbHVybDogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgZnJhZ21lbnQ6IEZyYWdtZW50O1xuICBwdWJsaWMgcmVhZG9ubHkgaW5kZXg6IG51bWJlcjtcbiAgcHVibGljIHN0YXRzOiBMb2FkU3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcGFydEF0dHJzOiBBdHRyTGlzdCxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBiYXNldXJsOiBzdHJpbmcsXG4gICAgaW5kZXg6IG51bWJlcixcbiAgICBwcmV2aW91cz86IFBhcnQsXG4gICkge1xuICAgIHN1cGVyKGJhc2V1cmwpO1xuICAgIHRoaXMuZHVyYXRpb24gPSBwYXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ0RVUkFUSU9OJyk7XG4gICAgdGhpcy5nYXAgPSBwYXJ0QXR0cnMuYm9vbCgnR0FQJyk7XG4gICAgdGhpcy5pbmRlcGVuZGVudCA9IHBhcnRBdHRycy5ib29sKCdJTkRFUEVOREVOVCcpO1xuICAgIHRoaXMucmVsdXJsID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1VSSScpIGFzIHN0cmluZztcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhcnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudC5zdGFydCArIHRoaXMuZnJhZ09mZnNldDtcbiAgfVxuXG4gIGdldCBlbmQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cblxuICBnZXQgbG9hZGVkKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgZWxlbWVudGFyeVN0cmVhbXMgfSA9IHRoaXM7XG4gICAgcmV0dXJuICEhKFxuICAgICAgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHxcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zLnZpZGVvIHx8XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFydCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBBdHRyTGlzdCB9IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgdHlwZSB7IERhdGVSYW5nZSB9IGZyb20gJy4vZGF0ZS1yYW5nZSc7XG5pbXBvcnQgdHlwZSB7IFZhcmlhYmxlTWFwIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuXG5jb25zdCBERUZBVUxUX1RBUkdFVF9EVVJBVElPTiA9IDEwO1xuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgTWVkaWEgUGxheWxpc3QuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWwuZGV0YWlsc30uXG4gKi9cbmV4cG9ydCBjbGFzcyBMZXZlbERldGFpbHMge1xuICBwdWJsaWMgUFRTS25vd246IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGFsaWduZWRTbGlkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBhdmVyYWdldGFyZ2V0ZHVyYXRpb24/OiBudW1iZXI7XG4gIHB1YmxpYyBlbmRDQzogbnVtYmVyID0gMDtcbiAgcHVibGljIGVuZFNOOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgZnJhZ21lbnRzOiBGcmFnbWVudFtdO1xuICBwdWJsaWMgZnJhZ21lbnRIaW50PzogRnJhZ21lbnQ7XG4gIHB1YmxpYyBwYXJ0TGlzdDogUGFydFtdIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBkYXRlUmFuZ2VzOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+O1xuICBwdWJsaWMgbGl2ZTogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhZ2VIZWFkZXI6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBhZHZhbmNlZERhdGVUaW1lPzogbnVtYmVyO1xuICBwdWJsaWMgdXBkYXRlZDogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhZHZhbmNlZDogYm9vbGVhbiA9IHRydWU7XG4gIHB1YmxpYyBhdmFpbGFiaWxpdHlEZWxheT86IG51bWJlcjsgLy8gTWFuaWZlc3QgcmVsb2FkIHN5bmNocm9uaXphdGlvblxuICBwdWJsaWMgbWlzc2VzOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgc3RhcnRDQzogbnVtYmVyID0gMDtcbiAgcHVibGljIHN0YXJ0U046IG51bWJlciA9IDA7XG4gIHB1YmxpYyBzdGFydFRpbWVPZmZzZXQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgdGFyZ2V0ZHVyYXRpb246IG51bWJlciA9IDA7XG4gIHB1YmxpYyB0b3RhbGR1cmF0aW9uOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgdHlwZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyB1cmw6IHN0cmluZztcbiAgcHVibGljIG0zdTg6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgdmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBjYW5CbG9ja1JlbG9hZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgY2FuU2tpcFVudGlsOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgY2FuU2tpcERhdGVSYW5nZXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIHNraXBwZWRTZWdtZW50czogbnVtYmVyID0gMDtcbiAgcHVibGljIHJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXM/OiBzdHJpbmdbXTtcbiAgcHVibGljIHBhcnRIb2xkQmFjazogbnVtYmVyID0gMDtcbiAgcHVibGljIGhvbGRCYWNrOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgcGFydFRhcmdldDogbnVtYmVyID0gMDtcbiAgcHVibGljIHByZWxvYWRIaW50PzogQXR0ckxpc3Q7XG4gIHB1YmxpYyByZW5kaXRpb25SZXBvcnRzPzogQXR0ckxpc3RbXTtcbiAgcHVibGljIHR1bmVJbkdvYWw6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBkZWx0YVVwZGF0ZUZhaWxlZD86IGJvb2xlYW47XG4gIHB1YmxpYyBkcmlmdFN0YXJ0VGltZTogbnVtYmVyID0gMDtcbiAgcHVibGljIGRyaWZ0RW5kVGltZTogbnVtYmVyID0gMDtcbiAgcHVibGljIGRyaWZ0U3RhcnQ6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBkcmlmdEVuZDogbnVtYmVyID0gMDtcbiAgcHVibGljIGVuY3J5cHRlZEZyYWdtZW50czogRnJhZ21lbnRbXTtcbiAgcHVibGljIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgdmFyaWFibGVMaXN0OiBWYXJpYWJsZU1hcCB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoYmFzZVVybDogc3RyaW5nKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuXG4gIHJlbG9hZGVkKHByZXZpb3VzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICB0aGlzLmFkdmFuY2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnRTbkRpZmYgPSB0aGlzLmxhc3RQYXJ0U24gLSBwcmV2aW91cy5sYXN0UGFydFNuO1xuICAgIGNvbnN0IHBhcnRJbmRleERpZmYgPSB0aGlzLmxhc3RQYXJ0SW5kZXggLSBwcmV2aW91cy5sYXN0UGFydEluZGV4O1xuICAgIHRoaXMudXBkYXRlZCA9XG4gICAgICB0aGlzLmVuZFNOICE9PSBwcmV2aW91cy5lbmRTTiB8fFxuICAgICAgISFwYXJ0SW5kZXhEaWZmIHx8XG4gICAgICAhIXBhcnRTbkRpZmYgfHxcbiAgICAgICF0aGlzLmxpdmU7XG4gICAgdGhpcy5hZHZhbmNlZCA9XG4gICAgICB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHxcbiAgICAgIHBhcnRTbkRpZmYgPiAwIHx8XG4gICAgICAocGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMCk7XG4gICAgaWYgKHRoaXMudXBkYXRlZCB8fCB0aGlzLmFkdmFuY2VkKSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IE1hdGguZmxvb3IocHJldmlvdXMubWlzc2VzICogMC42KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5taXNzZXMgPSBwcmV2aW91cy5taXNzZXMgKyAxO1xuICAgIH1cbiAgICB0aGlzLmF2YWlsYWJpbGl0eURlbGF5ID0gcHJldmlvdXMuYXZhaWxhYmlsaXR5RGVsYXk7XG4gIH1cblxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUoXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzW3RoaXMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnByb2dyYW1EYXRlVGltZSBhcyBudW1iZXIsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXQgbGV2ZWxUYXJnZXREdXJhdGlvbigpOiBudW1iZXIge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fFxuICAgICAgdGhpcy50YXJnZXRkdXJhdGlvbiB8fFxuICAgICAgREVGQVVMVF9UQVJHRVRfRFVSQVRJT05cbiAgICApO1xuICB9XG5cbiAgZ2V0IGRyaWZ0KCk6IG51bWJlciB7XG4gICAgY29uc3QgcnVuVGltZSA9IHRoaXMuZHJpZnRFbmRUaW1lIC0gdGhpcy5kcmlmdFN0YXJ0VGltZTtcbiAgICBpZiAocnVuVGltZSA+IDApIHtcbiAgICAgIGNvbnN0IHJ1bkR1cmF0aW9uID0gdGhpcy5kcmlmdEVuZCAtIHRoaXMuZHJpZnRTdGFydDtcbiAgICAgIHJldHVybiAocnVuRHVyYXRpb24gKiAxMDAwKSAvIHJ1blRpbWU7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgZ2V0IGVkZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0RW5kIHx8IHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cblxuICBnZXQgcGFydEVuZCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnBhcnRMaXN0Py5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuXG4gIGdldCBmcmFnbWVudEVuZCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cz8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBhZ2UoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5hZHZhbmNlZERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoRGF0ZS5ub3coKSAtIHRoaXMuYWR2YW5jZWREYXRlVGltZSwgMCkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBsYXN0UGFydEluZGV4KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMucGFydExpc3Q/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZ2V0IGxhc3RQYXJ0U24oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5wYXJ0TGlzdD8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuIGFzIG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5kU047XG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBpbnNlcnRlZCBhcyBhIHNoaW0gZm9yIG1vZHVsZXMgd2hpY2ggd2UgZG8gbm90IHdhbnQgdG8gaW5jbHVkZSBpbnRvIHRoZSBkaXN0cm8uXG4vLyBUaGlzIHJlcGxhY2VtZW50IGlzIGRvbmUgaW4gdGhlIFwiYWxpYXNcIiBwbHVnaW4gb2YgdGhlIHJvbGx1cCBjb25maWcuXG5tb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbiIsImV4cG9ydCBmdW5jdGlvbiBzbGljZVVpbnQ4KFxuICBhcnJheTogVWludDhBcnJheSxcbiAgc3RhcnQ/OiBudW1iZXIsXG4gIGVuZD86IG51bWJlcixcbik6IFVpbnQ4QXJyYXkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgcG9seWZpbGxzIElFMTEgdXNhZ2Ugb2YgVWludDhBcnJheSBzbGljZS5cbiAgLy8gSXQgYWx3YXlzIGV4aXN0cyBpbiB0aGUgVHlwZVNjcmlwdCBkZWZpbml0aW9uIHNvIGZhaWxzLCBidXQgaXQgZmFpbHMgYXQgcnVudGltZSBvbiBJRTExLlxuICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheSwgc3RhcnQsIGVuZCkpO1xufVxuIiwidHlwZSBSYXdGcmFtZSA9IHsgdHlwZTogc3RyaW5nOyBzaXplOiBudW1iZXI7IGRhdGE6IFVpbnQ4QXJyYXkgfTtcblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG50eXBlIERlY29kZWRGcmFtZTxUPiA9IHsga2V5OiBzdHJpbmc7IGRhdGE6IFQ7IGluZm8/OiBhbnkgfTtcbmV4cG9ydCB0eXBlIEZyYW1lID0gRGVjb2RlZEZyYW1lPEFycmF5QnVmZmVyIHwgc3RyaW5nPjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gSUQzIGhlYWRlciBjYW4gYmUgZm91bmQgYXQgb2Zmc2V0IGluIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGlzSGVhZGVyID0gKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChcbiAgICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHg0OSAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHgzM1xuICAgICkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJRDMgZm9vdGVyIGNhbiBiZSBmb3VuZCBhdCBvZmZzZXQgaW4gZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2hcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICovXG5leHBvcnQgY29uc3QgaXNGb290ZXIgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgLypcbiAgICogVGhlIGZvb3RlciBpcyBhIGNvcHkgb2YgdGhlIGhlYWRlciwgYnV0IHdpdGggYSBkaWZmZXJlbnQgaWRlbnRpZmllclxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJzNESScgaWRlbnRpZmllclxuICAgIGlmIChcbiAgICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9PT0gMHg0OVxuICAgICkge1xuICAgICAgLy8gY2hlY2sgdmVyc2lvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkYXRhW29mZnNldCArIDNdIDwgMHhmZiAmJiBkYXRhW29mZnNldCArIDRdIDwgMHhmZikge1xuICAgICAgICAvLyBjaGVjayBzaXplIGlzIHdpdGhpbiByYW5nZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA2XSA8IDB4ODAgJiZcbiAgICAgICAgICBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJlxuICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmXG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyA5XSA8IDB4ODBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW55IGFkamFjZW50IElEMyB0YWdzIGZvdW5kIGluIGRhdGEgc3RhcnRpbmcgYXQgb2Zmc2V0LCBhcyBvbmUgYmxvY2sgb2YgZGF0YVxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xuICogQHJldHVybnMgdGhlIGJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBhbnkgSUQzIHRhZ3MgZm91bmRcbiAqIG9yICp1bmRlZmluZWQqIGlmIG5vIGhlYWRlciBpcyBmb3VuZCBhdCB0aGUgc3RhcnRpbmcgb2Zmc2V0XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJRDNEYXRhID0gKFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbik6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgbGVuZ3RoICs9IDEwO1xuXG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpO1xuICAgIGxlbmd0aCArPSBzaXplO1xuXG4gICAgaWYgKGlzRm9vdGVyKGRhdGEsIG9mZnNldCArIDEwKSkge1xuICAgICAgLy8gSUQzIGZvb3RlciBpcyAxMCBieXRlc1xuICAgICAgbGVuZ3RoICs9IDEwO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cblxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkYXRhLnN1YmFycmF5KGZyb250LCBmcm9udCArIGxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgcmVhZFNpemUgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICBsZXQgc2l6ZSA9IDA7XG4gIHNpemUgPSAoZGF0YVtvZmZzZXRdICYgMHg3ZikgPDwgMjE7XG4gIHNpemUgfD0gKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDdmKSA8PCAxNDtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4N2YpIDw8IDc7XG4gIHNpemUgfD0gZGF0YVtvZmZzZXQgKyAzXSAmIDB4N2Y7XG4gIHJldHVybiBzaXplO1xufTtcblxuZXhwb3J0IGNvbnN0IGNhblBhcnNlID0gKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiAoXG4gICAgaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSAmJlxuICAgIHJlYWRTaXplKGRhdGEsIG9mZnNldCArIDYpICsgMTAgPD0gZGF0YS5sZW5ndGggLSBvZmZzZXRcbiAgKTtcbn07XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBFbGVtZW50YXJ5IFN0cmVhbSB0aW1lc3RhbXAgZm91bmQgaW4gdGhlIElEMyBkYXRhIGNodW5rXG4gKiBAcGFyYW0gZGF0YSAtIEJsb2NrIG9mIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICovXG5leHBvcnQgY29uc3QgZ2V0VGltZVN0YW1wID0gKGRhdGE6IFVpbnQ4QXJyYXkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBmcmFtZXM6IEZyYW1lW10gPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmcmFtZSA9IGZyYW1lc1tpXTtcblxuICAgIGlmIChpc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgcmV0dXJuIHJlYWRUaW1lU3RhbXAoZnJhbWUgYXMgRGVjb2RlZEZyYW1lPEFycmF5QnVmZmVyPik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBJRDMgZnJhbWUgaXMgYW4gRWxlbWVudGFyeSBTdHJlYW0gdGltZXN0YW1wIGZyYW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc1RpbWVTdGFtcEZyYW1lID0gKGZyYW1lOiBGcmFtZSk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gKFxuICAgIGZyYW1lICYmXG4gICAgZnJhbWUua2V5ID09PSAnUFJJVicgJiZcbiAgICBmcmFtZS5pbmZvID09PSAnY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXAnXG4gICk7XG59O1xuXG5jb25zdCBnZXRGcmFtZURhdGEgPSAoZGF0YTogVWludDhBcnJheSk6IFJhd0ZyYW1lID0+IHtcbiAgLypcbiAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgKi9cbiAgY29uc3QgdHlwZTogc3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgY29uc3Qgc2l6ZTogbnVtYmVyID0gcmVhZFNpemUoZGF0YSwgNCk7XG5cbiAgLy8gc2tpcCBmcmFtZSBpZCwgc2l6ZSwgYW5kIGZsYWdzXG4gIGNvbnN0IG9mZnNldCA9IDEwO1xuXG4gIHJldHVybiB7IHR5cGUsIHNpemUsIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKSB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICogQHBhcmFtIGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICovXG5leHBvcnQgY29uc3QgZ2V0SUQzRnJhbWVzID0gKGlkM0RhdGE6IFVpbnQ4QXJyYXkpOiBGcmFtZVtdID0+IHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZyYW1lczogRnJhbWVbXSA9IFtdO1xuXG4gIHdoaWxlIChpc0hlYWRlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgb2Zmc2V0ICs9IDEwO1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICBjb25zdCBmcmFtZURhdGE6IFJhd0ZyYW1lID0gZ2V0RnJhbWVEYXRhKGlkM0RhdGEuc3ViYXJyYXkob2Zmc2V0KSk7XG4gICAgICBjb25zdCBmcmFtZTogRnJhbWUgfCB1bmRlZmluZWQgPSBkZWNvZGVGcmFtZShmcmFtZURhdGEpO1xuICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCBmcmFtZSBoZWFkZXIgYW5kIGZyYW1lIGRhdGFcbiAgICAgIG9mZnNldCArPSBmcmFtZURhdGEuc2l6ZSArIDEwO1xuICAgIH1cblxuICAgIGlmIChpc0Zvb3RlcihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgICBvZmZzZXQgKz0gMTA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZyYW1lcztcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvZGVGcmFtZSA9IChmcmFtZTogUmF3RnJhbWUpOiBGcmFtZSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnUFJJVicpIHtcbiAgICByZXR1cm4gZGVjb2RlUHJpdkZyYW1lKGZyYW1lKTtcbiAgfSBlbHNlIGlmIChmcmFtZS50eXBlWzBdID09PSAnVycpIHtcbiAgICByZXR1cm4gZGVjb2RlVVJMRnJhbWUoZnJhbWUpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuXG5jb25zdCBkZWNvZGVQcml2RnJhbWUgPSAoXG4gIGZyYW1lOiBSYXdGcmFtZSxcbik6IERlY29kZWRGcmFtZTxBcnJheUJ1ZmZlcj4gfCB1bmRlZmluZWQgPT4ge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBvd25lciA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEsIHRydWUpO1xuICBjb25zdCBwcml2YXRlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZyYW1lLmRhdGEuc3ViYXJyYXkob3duZXIubGVuZ3RoICsgMSkpO1xuXG4gIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgaW5mbzogb3duZXIsIGRhdGE6IHByaXZhdGVEYXRhLmJ1ZmZlciB9O1xufTtcblxuY29uc3QgZGVjb2RlVGV4dEZyYW1lID0gKGZyYW1lOiBSYXdGcmFtZSk6IERlY29kZWRGcmFtZTxzdHJpbmc+IHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG5cbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCkpO1xuXG4gICAgcmV0dXJuIHsga2V5OiBmcmFtZS50eXBlLCBpbmZvOiBkZXNjcmlwdGlvbiwgZGF0YTogdmFsdWUgfTtcbiAgfVxuICAvKlxuICBGb3JtYXQ6XG4gIFswXSAgID0ge1RleHQgRW5jb2Rpbmd9XG4gIFsxLT9dID0ge1ZhbHVlfVxuICAqL1xuICBjb25zdCB0ZXh0ID0gdXRmOEFycmF5VG9TdHIoZnJhbWUuZGF0YS5zdWJhcnJheSgxKSk7XG4gIHJldHVybiB7IGtleTogZnJhbWUudHlwZSwgZGF0YTogdGV4dCB9O1xufTtcblxuY29uc3QgZGVjb2RlVVJMRnJhbWUgPSAoZnJhbWU6IFJhd0ZyYW1lKTogRGVjb2RlZEZyYW1lPHN0cmluZz4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoZnJhbWUudHlwZSA9PT0gJ1dYWFgnKSB7XG4gICAgLypcbiAgICBGb3JtYXQ6XG4gICAgWzBdICAgPSB7VGV4dCBFbmNvZGluZ31cbiAgICBbMS0/XSA9IHtEZXNjcmlwdGlvbn1cXDB7VVJMfVxuICAgICovXG4gICAgaWYgKGZyYW1lLnNpemUgPCAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb246IHN0cmluZyA9IHV0ZjhBcnJheVRvU3RyKFxuICAgICAgZnJhbWUuZGF0YS5zdWJhcnJheShpbmRleCksXG4gICAgICB0cnVlLFxuICAgICk7XG5cbiAgICBpbmRleCArPSBkZXNjcmlwdGlvbi5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHZhbHVlOiBzdHJpbmcgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSk7XG5cbiAgICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGluZm86IGRlc2NyaXB0aW9uLCBkYXRhOiB2YWx1ZSB9O1xuICB9XG4gIC8qXG4gIEZvcm1hdDpcbiAgWzAtP10gPSB7VVJMfVxuICAqL1xuICBjb25zdCB1cmw6IHN0cmluZyA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4geyBrZXk6IGZyYW1lLnR5cGUsIGRhdGE6IHVybCB9O1xufTtcblxuY29uc3QgcmVhZFRpbWVTdGFtcCA9IChcbiAgdGltZVN0YW1wRnJhbWU6IERlY29kZWRGcmFtZTxBcnJheUJ1ZmZlcj4sXG4pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgbGV0IHRpbWVzdGFtcCA9XG4gICAgICAoZGF0YVs0XSA8PCAyMykgKyAoZGF0YVs1XSA8PCAxNSkgKyAoZGF0YVs2XSA8PCA3KSArIGRhdGFbN107XG4gICAgdGltZXN0YW1wIC89IDQ1O1xuXG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84OTM2OTg0L3VpbnQ4YXJyYXktdG8tc3RyaW5nLWluLWphdmFzY3JpcHQvMjIzNzMxOTdcbi8vIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC91dGYudHh0XG4vKiB1dGYuanMgLSBVVEYtOCA8PT4gVVRGLTE2IGNvbnZlcnRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxuICogVmVyc2lvbjogMS4wXG4gKiBMYXN0TW9kaWZpZWQ6IERlYyAyNSAxOTk5XG4gKiBUaGlzIGxpYnJhcnkgaXMgZnJlZS4gIFlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXQuXG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4QXJyYXlUb1N0ciA9IChcbiAgYXJyYXk6IFVpbnQ4QXJyYXksXG4gIGV4aXRPbk51bGw6IGJvb2xlYW4gPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xuICBpZiAoZGVjb2Rlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG5cbiAgICBpZiAoZXhpdE9uTnVsbCkge1xuICAgICAgLy8gZ3JhYiB1cCB0byB0aGUgZmlyc3QgbnVsbFxuICAgICAgY29uc3QgaWR4ID0gZGVjb2RlZC5pbmRleE9mKCdcXDAnKTtcbiAgICAgIHJldHVybiBpZHggIT09IC0xID8gZGVjb2RlZC5zdWJzdHJpbmcoMCwgaWR4KSA6IGRlY29kZWQ7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFueSBudWxsIGNoYXJhY3RlcnNcbiAgICByZXR1cm4gZGVjb2RlZC5yZXBsYWNlKC9cXDAvZywgJycpO1xuICB9XG5cbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICBsZXQgYztcbiAgbGV0IGNoYXIyO1xuICBsZXQgY2hhcjM7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGMgPSBhcnJheVtpKytdO1xuICAgIGlmIChjID09PSAweDAwICYmIGV4aXRPbk51bGwpIHtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDAwIHx8IGMgPT09IDB4MDMpIHtcbiAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgMyAoRU5EX09GX1RFWFQpIG9yIDAgKE5VTEwpIHRoZW4gc2tpcCBpdFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHN3aXRjaCAoYyA+PiA0KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIC8vIDB4eHh4eHh4XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICAvLyAxMTB4IHh4eHggICAxMHh4IHh4eHhcbiAgICAgICAgY2hhcjIgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFmKSA8PCA2KSB8IChjaGFyMiAmIDB4M2YpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICAvLyAxMTEwIHh4eHggIDEweHggeHh4eCAgMTB4eCB4eHh4XG4gICAgICAgIGNoYXIyID0gYXJyYXlbaSsrXTtcbiAgICAgICAgY2hhcjMgPSBhcnJheVtpKytdO1xuICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgICAoKGMgJiAweDBmKSA8PCAxMikgfCAoKGNoYXIyICYgMHgzZikgPDwgNikgfCAoKGNoYXIzICYgMHgzZikgPDwgMCksXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydCBjb25zdCB0ZXN0YWJsZXMgPSB7XG4gIGRlY29kZVRleHRGcmFtZTogZGVjb2RlVGV4dEZyYW1lLFxufTtcblxubGV0IGRlY29kZXI6IFRleHREZWNvZGVyO1xuXG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgLy8gT24gUGxheSBTdGF0aW9uIDQsIFRleHREZWNvZGVyIGlzIGRlZmluZWQgYnV0IHBhcnRpYWxseSBpbXBsZW1lbnRlZC5cbiAgLy8gTWFudWFsIGRlY29kaW5nIG9wdGlvbiBpcyBwcmVmZXJhYmxlXG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdQbGF5U3RhdGlvbiA0JykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWRlY29kZXIgJiYgdHlwZW9mIHNlbGYuVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVjb2RlciA9IG5ldyBzZWxmLlRleHREZWNvZGVyKCd1dGYtOCcpO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZXI7XG59XG4iLCIvKipcbiAqICBoZXggZHVtcCBoZWxwZXIgY2xhc3NcbiAqL1xuXG5jb25zdCBIZXggPSB7XG4gIGhleER1bXA6IGZ1bmN0aW9uIChhcnJheTogVWludDhBcnJheSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaCA9IGFycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSBoO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgSGV4O1xuIiwiaW1wb3J0IHsgRWxlbWVudGFyeVN0cmVhbVR5cGVzIH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuL3R5cGVkLWFycmF5JztcbmltcG9ydCB7IHV0ZjhBcnJheVRvU3RyIH0gZnJvbSAnLi4vZGVtdXgvaWQzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgSGV4IGZyb20gJy4vaGV4JztcbmltcG9ydCB0eXBlIHsgUGFzc3Rocm91Z2hUcmFjaywgVXNlcmRhdGFTYW1wbGUgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHsgRGVjcnlwdERhdGEgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwta2V5JztcblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmV4cG9ydCBjb25zdCBSZW11eGVyVHJhY2tJZENvbmZpZyA9IHtcbiAgdmlkZW86IDEsXG4gIGF1ZGlvOiAyLFxuICBpZDM6IDMsXG4gIHRleHQ6IDQsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmluMnN0cihkYXRhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDE2KGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB2YWwgPSAoYnVmZmVyW29mZnNldF0gPDwgOCkgfCBidWZmZXJbb2Zmc2V0ICsgMV07XG4gIHJldHVybiB2YWwgPCAwID8gNjU1MzYgKyB2YWwgOiB2YWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkVWludDMyKGJ1ZmZlcjogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCB2YWwgPSByZWFkU2ludDMyKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA0Mjk0OTY3Mjk2ICsgdmFsIDogdmFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFNpbnQzMihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChcbiAgICAoYnVmZmVyW29mZnNldF0gPDwgMjQpIHxcbiAgICAoYnVmZmVyW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKGJ1ZmZlcltvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgYnVmZmVyW29mZnNldCArIDNdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVpbnQzMihidWZmZXI6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdmFsdWUgPj4gMjQ7XG4gIGJ1ZmZlcltvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+PiAxNikgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4gOCkgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG59XG5cbi8vIEZpbmQgXCJtb29mXCIgYm94XG5leHBvcnQgZnVuY3Rpb24gaGFzTW9vZkRhdGEoZGF0YTogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICBjb25zdCBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyApIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFVpbnQzMihkYXRhLCBpKTtcbiAgICBpZiAoXG4gICAgICBzaXplID4gOCAmJlxuICAgICAgZGF0YVtpICsgNF0gPT09IDB4NmQgJiZcbiAgICAgIGRhdGFbaSArIDVdID09PSAweDZmICYmXG4gICAgICBkYXRhW2kgKyA2XSA9PT0gMHg2ZiAmJlxuICAgICAgZGF0YVtpICsgN10gPT09IDB4NjZcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpID0gc2l6ZSA+IDEgPyBpICsgc2l6ZSA6IGVuZDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGRhdGEgZm9yIGEgYm94IHNwZWNpZmllZCBieSBpdHMgcGF0aFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRCb3goZGF0YTogVWludDhBcnJheSwgcGF0aDogc3RyaW5nW10pOiBVaW50OEFycmF5W10ge1xuICBjb25zdCByZXN1bHRzID0gW10gYXMgVWludDhBcnJheVtdO1xuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGNvbnN0IGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgY29uc3QgdHlwZSA9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICBjb25zdCBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgY29uc3Qgc3VicmVzdWx0cyA9IGZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc3VicmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGVuZGJveDtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxudHlwZSBTaWR4SW5mbyA9IHtcbiAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBudW1iZXI7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIHJlZmVyZW5jZXNDb3VudDogbnVtYmVyO1xuICByZWZlcmVuY2VzOiBhbnlbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNlZ21lbnRJbmRleChzaWR4OiBVaW50OEFycmF5KTogU2lkeEluZm8gfCBudWxsIHtcbiAgY29uc3QgcmVmZXJlbmNlczogYW55W10gPSBbXTtcblxuICBjb25zdCB2ZXJzaW9uID0gc2lkeFswXTtcblxuICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgbGV0IGluZGV4ID0gODtcblxuICBjb25zdCB0aW1lc2NhbGUgPSByZWFkVWludDMyKHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gNDtcblxuICAvLyBUT0RPOiBwYXJzZSBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgYW5kIGZpcnN0T2Zmc2V0XG4gIC8vIHVzdWFsbHkgemVybyBpbiBvdXIgY2FzZVxuICBjb25zdCBlYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgPSAwO1xuICBjb25zdCBmaXJzdE9mZnNldCA9IDA7XG5cbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICBpbmRleCArPSA4O1xuICB9IGVsc2Uge1xuICAgIGluZGV4ICs9IDE2O1xuICB9XG5cbiAgLy8gc2tpcCByZXNlcnZlZFxuICBpbmRleCArPSAyO1xuXG4gIGxldCBzdGFydEJ5dGUgPSBzaWR4Lmxlbmd0aCArIGZpcnN0T2Zmc2V0O1xuXG4gIGNvbnN0IHJlZmVyZW5jZXNDb3VudCA9IHJlYWRVaW50MTYoc2lkeCwgaW5kZXgpO1xuICBpbmRleCArPSAyO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlc0NvdW50OyBpKyspIHtcbiAgICBsZXQgcmVmZXJlbmNlSW5kZXggPSBpbmRleDtcblxuICAgIGNvbnN0IHJlZmVyZW5jZUluZm8gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgY29uc3QgcmVmZXJlbmNlU2l6ZSA9IHJlZmVyZW5jZUluZm8gJiAweDdmZmZmZmZmO1xuICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSAocmVmZXJlbmNlSW5mbyAmIDB4ODAwMDAwMDApID4+PiAzMTtcblxuICAgIGlmIChyZWZlcmVuY2VUeXBlID09PSAxKSB7XG4gICAgICBsb2dnZXIud2FybignU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzZWdtZW50RHVyYXRpb24gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgIHJlZmVyZW5jZVNpemUsXG4gICAgICBzdWJzZWdtZW50RHVyYXRpb24sIC8vIHVuc2NhbGVkXG4gICAgICBpbmZvOiB7XG4gICAgICAgIGR1cmF0aW9uOiBzdWJzZWdtZW50RHVyYXRpb24gLyB0aW1lc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEJ5dGUsXG4gICAgICAgIGVuZDogc3RhcnRCeXRlICsgcmVmZXJlbmNlU2l6ZSAtIDEsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgc3RhcnRCeXRlICs9IHJlZmVyZW5jZVNpemU7XG5cbiAgICAvLyBTa2lwcGluZyAxIGJpdCBmb3IgfHN0YXJ0c1dpdGhTYXB8LCAzIGJpdHMgZm9yIHxzYXBUeXBlfCwgYW5kIDI4IGJpdHNcbiAgICAvLyBmb3IgfHNhcERlbHRhfC5cbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuXG4gICAgLy8gc2tpcCB0byBuZXh0IHJlZlxuICAgIGluZGV4ID0gcmVmZXJlbmNlSW5kZXg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSxcbiAgICB0aW1lc2NhbGUsXG4gICAgdmVyc2lvbixcbiAgICByZWZlcmVuY2VzQ291bnQsXG4gICAgcmVmZXJlbmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gTVA0IGluaXRpYWxpemF0aW9uIHNlZ21lbnQgYW5kIGV4dHJhY3RzIHN0cmVhbSB0eXBlIGFuZFxuICogdGltZXNjYWxlIHZhbHVlcyBmb3IgYW55IGRlY2xhcmVkIHRyYWNrcy4gVGltZXNjYWxlIHZhbHVlcyBpbmRpY2F0ZSB0aGVcbiAqIG51bWJlciBvZiBjbG9jayB0aWNrcyBwZXIgc2Vjb25kIHRvIGFzc3VtZSBmb3IgdGltZS1iYXNlZCB2YWx1ZXNcbiAqIGVsc2V3aGVyZSBpbiB0aGUgTVA0LlxuICpcbiAqIFRvIGRldGVybWluZSB0aGUgc3RhcnQgdGltZSBvZiBhbiBNUDQsIHlvdSBuZWVkIHR3byBwaWVjZXMgb2ZcbiAqIGluZm9ybWF0aW9uOiB0aGUgdGltZXNjYWxlIHVuaXQgYW5kIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZVxuICogdGltZS4gTXVsdGlwbGUgdGltZXNjYWxlcyBjYW4gYmUgc3BlY2lmaWVkIHdpdGhpbiBhbiBNUDQgYnV0IHRoZVxuICogYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBpcyBhbHdheXMgZXhwcmVzc2VkIGluIHRoZSB0aW1lc2NhbGUgZnJvbVxuICogdGhlIG1lZGlhIGhlYWRlciBib3ggZm9yIHRoZSB0cmFjazpcbiAqIGBgYFxuICogbW9vdiA+IHRyYWsgPiBtZGlhID4gbWRoZC50aW1lc2NhbGVcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IGhkbHJcbiAqIGBgYFxuICogQHBhcmFtIGluaXRTZWdtZW50IHRoZSBieXRlcyBvZiB0aGUgaW5pdCBzZWdtZW50XG4gKiBAcmV0dXJucyBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzIG9yIG51bGwgaWZcbiAqIHRoZSBpbml0IHNlZ21lbnQgaXMgbWFsZm9ybWVkLlxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdERhdGFUcmFjayB7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICBpZDogbnVtYmVyO1xuICBjb2RlYzogc3RyaW5nO1xufVxuXG50eXBlIEhkbHJUeXBlID0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluaXREYXRhIGV4dGVuZHMgQXJyYXk8YW55PiB7XG4gIFtpbmRleDogbnVtYmVyXTpcbiAgICB8IHtcbiAgICAgICAgdGltZXNjYWxlOiBudW1iZXI7XG4gICAgICAgIHR5cGU6IEhkbHJUeXBlO1xuICAgICAgICBkZWZhdWx0Pzoge1xuICAgICAgICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgICAgICAgZmxhZ3M6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB8IHVuZGVmaW5lZDtcbiAgYXVkaW8/OiBJbml0RGF0YVRyYWNrO1xuICB2aWRlbz86IEluaXREYXRhVHJhY2s7XG4gIGNhcHRpb24/OiBJbml0RGF0YVRyYWNrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudDogVWludDhBcnJheSk6IEluaXREYXRhIHtcbiAgY29uc3QgcmVzdWx0OiBJbml0RGF0YSA9IFtdO1xuICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhayA9IHRyYWtzW2ldO1xuICAgIGNvbnN0IHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICBpZiAodGtoZCkge1xuICAgICAgbGV0IHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgdmVyc2lvbiA9PT0gMCA/IDEyIDogMjApO1xuICAgICAgY29uc3QgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICBpZiAobWRoZCkge1xuICAgICAgICB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgICAgY29uc3QgdGltZXNjYWxlID0gcmVhZFVpbnQzMihtZGhkLCB2ZXJzaW9uID09PSAwID8gMTIgOiAyMCk7XG4gICAgICAgIGNvbnN0IGhkbHIgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgIGNvbnN0IGhkbHJUeXBlID0gYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgY29uc3QgdHlwZTogSGRsclR5cGUgfCB1bmRlZmluZWQgPSB7XG4gICAgICAgICAgICBzb3VuOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gYXMgY29uc3QsXG4gICAgICAgICAgICB2aWRlOiBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gYXMgY29uc3QsXG4gICAgICAgICAgfVtoZGxyVHlwZV07XG4gICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvZGVjIGRldGFpbHNcbiAgICAgICAgICAgIGNvbnN0IHN0c2QgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdtaW5mJywgJ3N0YmwnLCAnc3RzZCddKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHN0c2REYXRhID0gcGFyc2VTdHNkKHN0c2QpO1xuICAgICAgICAgICAgcmVzdWx0W3RyYWNrSWRdID0geyB0aW1lc2NhbGUsIHR5cGUgfTtcbiAgICAgICAgICAgIHJlc3VsdFt0eXBlXSA9IHsgdGltZXNjYWxlLCBpZDogdHJhY2tJZCwgLi4uc3RzZERhdGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB0cmV4ID0gZmluZEJveChpbml0U2VnbWVudCwgWydtb292JywgJ212ZXgnLCAndHJleCddKTtcbiAgdHJleC5mb3JFYWNoKCh0cmV4KSA9PiB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKSxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0c2Qoc3RzZDogVWludDhBcnJheSk6IHsgY29kZWM6IHN0cmluZzsgZW5jcnlwdGVkOiBib29sZWFuIH0ge1xuICBjb25zdCBzYW1wbGVFbnRyaWVzID0gc3RzZC5zdWJhcnJheSg4KTtcbiAgY29uc3Qgc2FtcGxlRW50cmllc0VuZCA9IHNhbXBsZUVudHJpZXMuc3ViYXJyYXkoOCArIDc4KTtcbiAgY29uc3QgZm91ckNDID0gYmluMnN0cihzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDQsIDgpKTtcbiAgbGV0IGNvZGVjID0gZm91ckNDO1xuICBjb25zdCBlbmNyeXB0ZWQgPSBmb3VyQ0MgPT09ICdlbmNhJyB8fCBmb3VyQ0MgPT09ICdlbmN2JztcbiAgaWYgKGVuY3J5cHRlZCkge1xuICAgIGNvbnN0IGVuY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gZW5jQm94LnN1YmFycmF5KGZvdXJDQyA9PT0gJ2VuY2EnID8gMjggOiA3OCk7XG4gICAgY29uc3Qgc2luZnMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgc2luZnMuZm9yRWFjaCgoc2luZikgPT4ge1xuICAgICAgY29uc3Qgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICAgICAgaWYgKHNjaG0pIHtcbiAgICAgICAgY29uc3Qgc2NoZW1lID0gYmluMnN0cihzY2htLnN1YmFycmF5KDQsIDgpKTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gJ2NiY3MnIHx8IHNjaGVtZSA9PT0gJ2NlbmMnKSB7XG4gICAgICAgICAgY29uc3QgZnJtYSA9IGZpbmRCb3goc2luZiwgWydmcm1hJ10pWzBdO1xuICAgICAgICAgIGlmIChmcm1hKSB7XG4gICAgICAgICAgICAvLyBmb3IgZW5jcnlwdGVkIGNvbnRlbnQgY29kZWMgZm91ckNDIHdpbGwgYmUgaW4gZnJtYVxuICAgICAgICAgICAgY29kZWMgPSBiaW4yc3RyKGZybWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN3aXRjaCAoY29kZWMpIHtcbiAgICBjYXNlICdhdmMxJzpcbiAgICBjYXNlICdhdmMyJzpcbiAgICBjYXNlICdhdmMzJzpcbiAgICBjYXNlICdhdmM0Jzoge1xuICAgICAgLy8gZXh0cmFjdCBwcm9maWxlICsgY29tcGF0aWJpbGl0eSArIGxldmVsIG91dCBvZiBhdmNDIGJveFxuICAgICAgY29uc3QgYXZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydhdmNDJ10pWzBdO1xuICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgoYXZjQ0JveFsxXSkgKyB0b0hleChhdmNDQm94WzJdKSArIHRvSGV4KGF2Y0NCb3hbM10pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ21wNGEnOiB7XG4gICAgICBjb25zdCBjb2RlY0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllcywgW2ZvdXJDQ10pWzBdO1xuICAgICAgY29uc3QgZXNkc0JveCA9IGZpbmRCb3goY29kZWNCb3guc3ViYXJyYXkoMjgpLCBbJ2VzZHMnXSlbMF07XG4gICAgICBpZiAoZXNkc0JveCAmJiBlc2RzQm94Lmxlbmd0aCA+IDEyKSB7XG4gICAgICAgIGxldCBpID0gNDtcbiAgICAgICAgLy8gRVMgRGVzY3JpcHRvciB0YWdcbiAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwMykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgaSArPSAyOyAvLyBza2lwIGVzX2lkO1xuICAgICAgICBjb25zdCBmbGFncyA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgaWYgKGZsYWdzICYgMHg4MCkge1xuICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBkZXBlbmRlbmN5IGVzX2lkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMHg0MCkge1xuICAgICAgICAgIGkgKz0gZXNkc0JveFtpKytdOyAvLyBza2lwIFVSTFxuICAgICAgICB9XG4gICAgICAgIC8vIERlY29kZXIgY29uZmlnIGRlc2NyaXB0b3JcbiAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0VHlwZSA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgaWYgKG9iamVjdFR5cGUgPT09IDB4NDApIHtcbiAgICAgICAgICBjb2RlYyArPSAnLicgKyB0b0hleChvYmplY3RUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpICs9IDEyO1xuICAgICAgICAvLyBEZWNvZGVyIHNwZWNpZmljIGluZm9cbiAgICAgICAgaWYgKGVzZHNCb3hbaSsrXSAhPT0gMHgwNSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkgPSBza2lwQkVSSW50ZWdlcihlc2RzQm94LCBpKTtcbiAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZXNkc0JveFtpKytdO1xuICAgICAgICBsZXQgYXVkaW9PYmplY3RUeXBlID0gKGZpcnN0Qnl0ZSAmIDB4ZjgpID4+IDM7XG4gICAgICAgIGlmIChhdWRpb09iamVjdFR5cGUgPT09IDMxKSB7XG4gICAgICAgICAgYXVkaW9PYmplY3RUeXBlICs9XG4gICAgICAgICAgICAxICsgKChmaXJzdEJ5dGUgJiAweDcpIDw8IDMpICsgKChlc2RzQm94W2ldICYgMHhlMCkgPj4gNSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZWMgKz0gJy4nICsgYXVkaW9PYmplY3RUeXBlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ2h2YzEnOlxuICAgIGNhc2UgJ2hldjEnOiB7XG4gICAgICBjb25zdCBodmNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2h2Y0MnXSlbMF07XG4gICAgICBjb25zdCBwcm9maWxlQnl0ZSA9IGh2Y0NCb3hbMV07XG4gICAgICBjb25zdCBwcm9maWxlU3BhY2UgPSBbJycsICdBJywgJ0InLCAnQyddW3Byb2ZpbGVCeXRlID4+IDZdO1xuICAgICAgY29uc3QgZ2VuZXJhbFByb2ZpbGVJZGMgPSBwcm9maWxlQnl0ZSAmIDB4MWY7XG4gICAgICBjb25zdCBwcm9maWxlQ29tcGF0ID0gcmVhZFVpbnQzMihodmNDQm94LCAyKTtcbiAgICAgIGNvbnN0IHRpZXJGbGFnID0gKHByb2ZpbGVCeXRlICYgMHgyMCkgPj4gNSA/ICdIJyA6ICdMJztcbiAgICAgIGNvbnN0IGxldmVsSURDID0gaHZjQ0JveFsxMl07XG4gICAgICBjb25zdCBjb25zdHJhaW50SW5kaWNhdG9yID0gaHZjQ0JveC5zdWJhcnJheSg2LCAxMik7XG4gICAgICBjb2RlYyArPSAnLicgKyBwcm9maWxlU3BhY2UgKyBnZW5lcmFsUHJvZmlsZUlkYztcbiAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGVDb21wYXQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjb2RlYyArPSAnLicgKyB0aWVyRmxhZyArIGxldmVsSURDO1xuICAgICAgbGV0IGNvbnN0cmFpbnRTdHJpbmcgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSBjb25zdHJhaW50SW5kaWNhdG9yLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGNvbnN0cmFpbnRJbmRpY2F0b3JbaV07XG4gICAgICAgIGlmIChieXRlIHx8IGNvbnN0cmFpbnRTdHJpbmcpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkQnl0ZSA9IGJ5dGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3RyYWludFN0cmluZyA9ICcuJyArIGVuY29kZWRCeXRlICsgY29uc3RyYWludFN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29kZWMgKz0gY29uc3RyYWludFN0cmluZztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdkdmgxJzpcbiAgICBjYXNlICdkdmhlJzoge1xuICAgICAgY29uc3QgZHZjQ0JveCA9IGZpbmRCb3goc2FtcGxlRW50cmllc0VuZCwgWydkdmNDJ10pWzBdO1xuICAgICAgY29uc3QgcHJvZmlsZSA9IChkdmNDQm94WzJdID4+IDEpICYgMHg3ZjtcbiAgICAgIGNvbnN0IGxldmVsID0gKChkdmNDQm94WzJdIDw8IDUpICYgMHgyMCkgfCAoKGR2Y0NCb3hbM10gPj4gMykgJiAweDFmKTtcbiAgICAgIGNvZGVjICs9ICcuJyArIGFkZExlYWRpbmdaZXJvKHByb2ZpbGUpICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ3ZwMDknOiB7XG4gICAgICBjb25zdCB2cGNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ3ZwY0MnXSlbMF07XG4gICAgICBjb25zdCBwcm9maWxlID0gdnBjQ0JveFs0XTtcbiAgICAgIGNvbnN0IGxldmVsID0gdnBjQ0JveFs1XTtcbiAgICAgIGNvbnN0IGJpdERlcHRoID0gKHZwY0NCb3hbNl0gPj4gNCkgJiAweDBmO1xuICAgICAgY29kZWMgKz1cbiAgICAgICAgJy4nICtcbiAgICAgICAgYWRkTGVhZGluZ1plcm8ocHJvZmlsZSkgK1xuICAgICAgICAnLicgK1xuICAgICAgICBhZGRMZWFkaW5nWmVybyhsZXZlbCkgK1xuICAgICAgICAnLicgK1xuICAgICAgICBhZGRMZWFkaW5nWmVybyhiaXREZXB0aCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnYXYwMSc6IHtcbiAgICAgIGNvbnN0IGF2MUNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnYXYxQyddKVswXTtcbiAgICAgIGNvbnN0IHByb2ZpbGUgPSBhdjFDQm94WzFdID4+PiA1O1xuICAgICAgY29uc3QgbGV2ZWwgPSBhdjFDQm94WzFdICYgMHgxZjtcbiAgICAgIGNvbnN0IHRpZXJGbGFnID0gYXYxQ0JveFsyXSA+Pj4gNyA/ICdIJyA6ICdNJztcbiAgICAgIGNvbnN0IGhpZ2hCaXREZXB0aCA9IChhdjFDQm94WzJdICYgMHg0MCkgPj4gNjtcbiAgICAgIGNvbnN0IHR3ZWx2ZUJpdCA9IChhdjFDQm94WzJdICYgMHgyMCkgPj4gNTtcbiAgICAgIGNvbnN0IGJpdERlcHRoID1cbiAgICAgICAgcHJvZmlsZSA9PT0gMiAmJiBoaWdoQml0RGVwdGhcbiAgICAgICAgICA/IHR3ZWx2ZUJpdFxuICAgICAgICAgICAgPyAxMlxuICAgICAgICAgICAgOiAxMFxuICAgICAgICAgIDogaGlnaEJpdERlcHRoXG4gICAgICAgICAgICA/IDEwXG4gICAgICAgICAgICA6IDg7XG4gICAgICBjb25zdCBtb25vY2hyb21lID0gKGF2MUNCb3hbMl0gJiAweDEwKSA+PiA0O1xuICAgICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdYID0gKGF2MUNCb3hbMl0gJiAweDA4KSA+PiAzO1xuICAgICAgY29uc3QgY2hyb21hU3Vic2FtcGxpbmdZID0gKGF2MUNCb3hbMl0gJiAweDA0KSA+PiAyO1xuICAgICAgY29uc3QgY2hyb21hU2FtcGxlUG9zaXRpb24gPSBhdjFDQm94WzJdICYgMHgwMztcbiAgICAgIC8vIFRPRE86IHBhcnNlIGNvbG9yX2Rlc2NyaXB0aW9uX3ByZXNlbnRfZmxhZ1xuICAgICAgLy8gZGVmYXVsdCBpdCB0byBCVC43MDkvbGltaXRlZCByYW5nZSBmb3Igbm93XG4gICAgICAvLyBtb3JlIGluZm8gaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1pc29ibWZmLyNhdjFjb2RlY2NvbmZpZ3VyYXRpb25ib3gtc3ludGF4XG4gICAgICBjb25zdCBjb2xvclByaW1hcmllcyA9IDE7XG4gICAgICBjb25zdCB0cmFuc2ZlckNoYXJhY3RlcmlzdGljcyA9IDE7XG4gICAgICBjb25zdCBtYXRyaXhDb2VmZmljaWVudHMgPSAxO1xuICAgICAgY29uc3QgdmlkZW9GdWxsUmFuZ2VGbGFnID0gMDtcbiAgICAgIGNvZGVjICs9XG4gICAgICAgICcuJyArXG4gICAgICAgIHByb2ZpbGUgK1xuICAgICAgICAnLicgK1xuICAgICAgICBhZGRMZWFkaW5nWmVybyhsZXZlbCkgK1xuICAgICAgICB0aWVyRmxhZyArXG4gICAgICAgICcuJyArXG4gICAgICAgIGFkZExlYWRpbmdaZXJvKGJpdERlcHRoKSArXG4gICAgICAgICcuJyArXG4gICAgICAgIG1vbm9jaHJvbWUgK1xuICAgICAgICAnLicgK1xuICAgICAgICBjaHJvbWFTdWJzYW1wbGluZ1ggK1xuICAgICAgICBjaHJvbWFTdWJzYW1wbGluZ1kgK1xuICAgICAgICBjaHJvbWFTYW1wbGVQb3NpdGlvbiArXG4gICAgICAgICcuJyArXG4gICAgICAgIGFkZExlYWRpbmdaZXJvKGNvbG9yUHJpbWFyaWVzKSArXG4gICAgICAgICcuJyArXG4gICAgICAgIGFkZExlYWRpbmdaZXJvKHRyYW5zZmVyQ2hhcmFjdGVyaXN0aWNzKSArXG4gICAgICAgICcuJyArXG4gICAgICAgIGFkZExlYWRpbmdaZXJvKG1hdHJpeENvZWZmaWNpZW50cykgK1xuICAgICAgICAnLicgK1xuICAgICAgICB2aWRlb0Z1bGxSYW5nZUZsYWc7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAnYWMtMyc6XG4gICAgY2FzZSAnZWMtMyc6XG4gICAgY2FzZSAnYWxhYyc6XG4gICAgY2FzZSAnZkxhQyc6XG4gICAgY2FzZSAnT3B1cyc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB7IGNvZGVjLCBlbmNyeXB0ZWQgfTtcbn1cblxuZnVuY3Rpb24gc2tpcEJFUkludGVnZXIoYnl0ZXM6IFVpbnQ4QXJyYXksIGk6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IGxpbWl0ID0gaSArIDU7XG4gIHdoaWxlIChieXRlc1tpKytdICYgMHg4MCAmJiBpIDwgbGltaXQpIHt9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiB0b0hleCh4OiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gKCcwJyArIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbn1cblxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gKG51bSA8IDEwID8gJzAnIDogJycpICsgbnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hFbmN5cHRpb25EYXRhKFxuICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbik6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xuICBpZiAoIWluaXRTZWdtZW50IHx8ICFkZWNyeXB0ZGF0YSkge1xuICAgIHJldHVybiBpbml0U2VnbWVudDtcbiAgfVxuICBjb25zdCBrZXlJZCA9IGRlY3J5cHRkYXRhLmtleUlkO1xuICBpZiAoa2V5SWQgJiYgZGVjcnlwdGRhdGEuaXNDb21tb25FbmNyeXB0aW9uKSB7XG4gICAgY29uc3QgdHJha3MgPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAndHJhayddKTtcbiAgICB0cmFrcy5mb3JFYWNoKCh0cmFrKSA9PiB7XG4gICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG5cbiAgICAgIC8vIHNraXAgdGhlIHNhbXBsZSBlbnRyeSBjb3VudFxuICAgICAgY29uc3Qgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gICAgICBsZXQgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jYSddKTtcbiAgICAgIGNvbnN0IGlzQXVkaW8gPSBlbmNCb3hlcy5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc0F1ZGlvKSB7XG4gICAgICAgIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY3YnXSk7XG4gICAgICB9XG4gICAgICBlbmNCb3hlcy5mb3JFYWNoKChlbmMpID0+IHtcbiAgICAgICAgY29uc3QgZW5jQm94Q2hpbGRyZW4gPSBpc0F1ZGlvID8gZW5jLnN1YmFycmF5KDI4KSA6IGVuYy5zdWJhcnJheSg3OCk7XG4gICAgICAgIGNvbnN0IHNpbmZCb3hlcyA9IGZpbmRCb3goZW5jQm94Q2hpbGRyZW4sIFsnc2luZiddKTtcbiAgICAgICAgc2luZkJveGVzLmZvckVhY2goKHNpbmYpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZW5jID0gcGFyc2VTaW5mKHNpbmYpO1xuICAgICAgICAgIGlmICh0ZW5jKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBkZWZhdWx0IGtleSBpZCAoa2V5SUQgb2Zmc2V0IGlzIGFsd2F5cyA4IHdpdGhpbiB0aGUgdGVuYyBib3gpOlxuICAgICAgICAgICAgY29uc3QgdGVuY0tleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgICAgICBpZiAoIXRlbmNLZXlJZC5zb21lKChiKSA9PiBiICE9PSAwKSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgICAgIGBbZW1lXSBQYXRjaGluZyBrZXlJZCBpbiAnZW5jJHtcbiAgICAgICAgICAgICAgICAgIGlzQXVkaW8gPyAnYScgOiAndidcbiAgICAgICAgICAgICAgICB9PnNpbmY+PnRlbmMnIGJveDogJHtIZXguaGV4RHVtcCh0ZW5jS2V5SWQpfSAtPiAke0hleC5oZXhEdW1wKFxuICAgICAgICAgICAgICAgICAga2V5SWQsXG4gICAgICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0ZW5jLnNldChrZXlJZCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluaXRTZWdtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaW5mKHNpbmY6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gIGNvbnN0IHNjaG0gPSBmaW5kQm94KHNpbmYsIFsnc2NobSddKVswXTtcbiAgaWYgKHNjaG0pIHtcbiAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgIGlmIChzY2hlbWUgPT09ICdjYmNzJyB8fCBzY2hlbWUgPT09ICdjZW5jJykge1xuICAgICAgcmV0dXJuIGZpbmRCb3goc2luZiwgWydzY2hpJywgJ3RlbmMnXSlbMF07XG4gICAgfVxuICB9XG4gIGxvZ2dlci5lcnJvcihgW2VtZV0gbWlzc2luZyAnc2NobScgYm94YCk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSwgaW4gc2Vjb25kcywgZm9yIGFuIE1QNFxuICogZnJhZ21lbnQuIElmIG11bHRpcGxlIGZyYWdtZW50cyBhcmUgc3BlY2lmaWVkLCB0aGUgZWFybGllc3QgdGltZSBpc1xuICogcmV0dXJuZWQuXG4gKlxuICogVGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgY2FuIGJlIHBhcnNlZCBmcm9tIHRyYWNrIGZyYWdtZW50XG4gKiBtZXRhZGF0YTpcbiAqIGBgYFxuICogbW9vZiA+IHRyYWYgPiB0ZmR0LmJhc2VNZWRpYURlY29kZVRpbWVcbiAqIGBgYFxuICogSXQgcmVxdWlyZXMgdGhlIHRpbWVzY2FsZSB2YWx1ZSBmcm9tIHRoZSBtZGhkIHRvIGludGVycHJldC5cbiAqXG4gKiBAcGFyYW0gaW5pdERhdGEgLSBhIGhhc2ggb2YgdHJhY2sgdHlwZSB0byB0aW1lc2NhbGUgdmFsdWVzXG4gKiBAcGFyYW0gZm1wNCAtIHRoZSBieXRlcyBvZiB0aGUgbXA0IGZyYWdtZW50XG4gKiBAcmV0dXJucyB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGUgc3RhcnQgdGltZSBmb3IgdGhlXG4gKiBmcmFnbWVudCwgaW4gc2Vjb25kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnREVFMoXG4gIGluaXREYXRhOiBJbml0RGF0YSxcbiAgZm1wNDogVWludDhBcnJheSxcbik6IG51bWJlciB8IG51bGwge1xuICAvLyB3ZSBuZWVkIGluZm8gZnJvbSB0d28gY2hpbGRyZW4gb2YgZWFjaCB0cmFjayBmcmFnbWVudCBib3hcbiAgcmV0dXJuIGZpbmRCb3goZm1wNCwgWydtb29mJywgJ3RyYWYnXSkucmVkdWNlKFxuICAgIChyZXN1bHQ6IG51bWJlciB8IG51bGwsIHRyYWYpID0+IHtcbiAgICAgIGNvbnN0IHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB0ZmR0WzBdO1xuICAgICAgY29uc3Qgc3RhcnQgPSBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5yZWR1Y2UoXG4gICAgICAgIChyZXN1bHQ6IG51bWJlciB8IG51bGwsIHRmaGQpID0+IHtcbiAgICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBpbml0RGF0YVtpZF07XG4gICAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsZXQgYmFzZVRpbWUgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgdG9vIGxhcmdlLCBhc3N1bWUgc2lnbmVkIDY0LWJpdC4gTmVnYXRpdmUgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVzIGFyZSBpbnZhbGlkLCBidXQgdGhleSBleGlzdCBpbiB0aGUgd2lsZC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBsYXJnZSB2YWx1ZXMgZnJvbSBiZWluZyB1c2VkIGZvciBpbml0UFRTLCB3aGljaCBjYW4gY2F1c2UgcGxheWxpc3Qgc3luYyBpc3N1ZXMuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy81MzAzXG4gICAgICAgICAgICAgIGlmIChiYXNlVGltZSA9PT0gVUlOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgICAgYFttcDQtZGVtdXhlcl06IElnbm9yaW5nIGFzc3VtZWQgaW52YWxpZCBzaWduZWQgNjQtYml0IHRyYWNrIGZyYWdtZW50IGRlY29kZSB0aW1lYCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmFzZVRpbWUgKj0gVUlOVDMyX01BWCArIDE7XG4gICAgICAgICAgICAgIGJhc2VUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0cmFjay50aW1lc2NhbGUgfHwgOTBlMztcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFzZSB0aW1lIHRvIHNlY29uZHNcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIE51bWJlci5pc0Zpbml0ZShzdGFydFRpbWUpICYmXG4gICAgICAgICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIG51bGwsXG4gICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBzdGFydCAhPT0gbnVsbCAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUoc3RhcnQpICYmXG4gICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnQgPCByZXN1bHQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG51bGwsXG4gICk7XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tGcmFnbWVudEhlYWRlckJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdGZoZOKAmSwgMCwgdGZfZmxhZ3Mpe1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICB0cmFja19JRDtcbiAgICAgLy8gYWxsIHRoZSBmb2xsb3dpbmcgYXJlIG9wdGlvbmFsIGZpZWxkc1xuICAgICB1bnNpZ25lZCBpbnQoNjQpICBiYXNlX2RhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXg7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9zaXplO1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREdXJhdGlvbihkYXRhOiBVaW50OEFycmF5LCBpbml0RGF0YTogSW5pdERhdGEpIHtcbiAgbGV0IHJhd0R1cmF0aW9uID0gMDtcbiAgbGV0IHZpZGVvRHVyYXRpb24gPSAwO1xuICBsZXQgYXVkaW9EdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWYgPSB0cmFmc1tpXTtcbiAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICBjb25zdCB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0RlZmF1bHQgPSB0cmFjay5kZWZhdWx0O1xuICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgfCB0cmFja0RlZmF1bHQ/LmZsYWdzITtcbiAgICBsZXQgc2FtcGxlRHVyYXRpb246IG51bWJlciB8IHVuZGVmaW5lZCA9IHRyYWNrRGVmYXVsdD8uZHVyYXRpb247XG4gICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDA4KSB7XG4gICAgICAvLyAweDAwMDAwOCBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBmaWVsZFxuICAgICAgaWYgKHRmaGRGbGFncyAmIDB4MDAwMDAyKSB7XG4gICAgICAgIC8vIDB4MDAwMDAyIGluZGljYXRlcyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleCBmaWVsZCwgd2hpY2ggcHJlY2VkZXMgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgLy8gSWYgcHJlc2VudCwgdGhlIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uIGV4aXN0cyBhdCBieXRlIG9mZnNldCAxMlxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgMTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgZHVyYXRpb24gaXMgYXQgYnl0ZSBvZmZzZXQgOFxuICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodGZoZCwgOCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFzc3VtZSBhIDkwa0h6IGNsb2NrIGlmIG5vIHRpbWVzY2FsZSB3YXMgc3BlY2lmaWVkXG4gICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgY29uc3QgdHJ1bnMgPSBmaW5kQm94KHRyYWYsIFsndHJ1biddKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRydW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICByYXdEdXJhdGlvbiA9IGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW5zW2pdKTtcbiAgICAgIGlmICghcmF3RHVyYXRpb24gJiYgc2FtcGxlRHVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW5zW2pdLCA0KTtcbiAgICAgICAgcmF3RHVyYXRpb24gPSBzYW1wbGVEdXJhdGlvbiAqIHNhbXBsZUNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrLnR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgICB2aWRlb0R1cmF0aW9uICs9IHJhd0R1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICAgICAgYXVkaW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24gPT09IDAgJiYgYXVkaW9EdXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIElmIGR1cmF0aW9uIHNhbXBsZXMgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHRyYWYgdXNlIHNpZHggc3Vic2VnbWVudF9kdXJhdGlvblxuICAgIGxldCBzaWR4RHVyYXRpb24gPSAwO1xuICAgIGNvbnN0IHNpZHhzID0gZmluZEJveChkYXRhLCBbJ3NpZHgnXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWR4cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2lkeCA9IHBhcnNlU2VnbWVudEluZGV4KHNpZHhzW2ldKTtcbiAgICAgIGlmIChzaWR4Py5yZWZlcmVuY2VzKSB7XG4gICAgICAgIHNpZHhEdXJhdGlvbiArPSBzaWR4LnJlZmVyZW5jZXMucmVkdWNlKFxuICAgICAgICAgIChkdXIsIHJlZikgPT4gZHVyICsgcmVmLmluZm8uZHVyYXRpb24gfHwgMCxcbiAgICAgICAgICAwLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaWR4RHVyYXRpb247XG4gIH1cbiAgaWYgKHZpZGVvRHVyYXRpb24pIHtcbiAgICByZXR1cm4gdmlkZW9EdXJhdGlvbjtcbiAgfVxuICByZXR1cm4gYXVkaW9EdXJhdGlvbjtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja1J1bkJveFxuICAgICAgICAgICBleHRlbmRzIEZ1bGxCb3go4oCYdHJ1buKAmSwgdmVyc2lvbiwgdHJfZmxhZ3MpIHtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX2NvdW50O1xuICAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvcHRpb25hbCBmaWVsZHNcbiAgICAgc2lnbmVkIGludCgzMikgZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGZpcnN0X3NhbXBsZV9mbGFncztcbiAgICAgLy8gYWxsIGZpZWxkcyBpbiB0aGUgZm9sbG93aW5nIGFycmF5IGFyZSBvcHRpb25hbFxuICAgICB7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kdXJhdGlvbjtcbiAgICAgICAgdW5zaWduZWQgaW50KDMyKSAgc2FtcGxlX3NpemU7XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9mbGFnc1xuICAgICAgICBpZiAodmVyc2lvbiA9PSAwKVxuICAgICAgICAgICB7IHVuc2lnbmVkIGludCgzMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgICB7IHNpZ25lZCBpbnQoMzIpXG4gICAgIH1bIHNhbXBsZV9jb3VudCBdXG4gIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW4pOiBudW1iZXIge1xuICBjb25zdCBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCk7XG4gIC8vIEZsYWdzIGFyZSBhdCBvZmZzZXQgMCwgbm9uLW9wdGlvbmFsIHNhbXBsZV9jb3VudCBpcyBhdCBvZmZzZXQgNC4gVGhlcmVmb3JlIHdlIHN0YXJ0IDggYnl0ZXMgaW4uXG4gIC8vIEVhY2ggZmllbGQgaXMgYW4gaW50MzIsIHdoaWNoIGlzIDQgYnl0ZXNcbiAgbGV0IG9mZnNldCA9IDg7XG4gIC8vIGRhdGEtb2Zmc2V0LXByZXNlbnQgZmxhZ1xuICBpZiAoZmxhZ3MgJiAweDAwMDAwMSkge1xuICAgIG9mZnNldCArPSA0O1xuICB9XG4gIC8vIGZpcnN0LXNhbXBsZS1mbGFncy1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDQpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuXG4gIGxldCBkdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVDb3VudDsgaSsrKSB7XG4gICAgLy8gc2FtcGxlLWR1cmF0aW9uLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMTAwKSB7XG4gICAgICBjb25zdCBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgb2Zmc2V0KTtcbiAgICAgIGR1cmF0aW9uICs9IHNhbXBsZUR1cmF0aW9uO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIC8vIHNhbXBsZS1zaXplLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwMjAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLWZsYWdzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwNDAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLWNvbXBvc2l0aW9uLXRpbWUtb2Zmc2V0cy1wcmVzZW50IGZsYWdcbiAgICBpZiAoZmxhZ3MgJiAweDAwMDgwMCkge1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXJhdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldFN0YXJ0RFRTKFxuICBpbml0RGF0YTogSW5pdERhdGEsXG4gIGZtcDQ6IFVpbnQ4QXJyYXksXG4gIHRpbWVPZmZzZXQ6IG51bWJlcixcbikge1xuICBmaW5kQm94KGZtcDQsIFsnbW9vZicsICd0cmFmJ10pLmZvckVhY2goKHRyYWYpID0+IHtcbiAgICBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5mb3JFYWNoKCh0ZmhkKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaCgodGZkdCkgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGltZU9mZnNldCAqIHRpbWVzY2FsZTtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIGxldCBiYXNlTWVkaWFEZWNvZGVUaW1lID0gcmVhZFVpbnQzMih0ZmR0LCA0KTtcbiAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSBvZmZzZXQ7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCBiYXNlTWVkaWFEZWNvZGVUaW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lIC09IG9mZnNldDtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLm1heChiYXNlTWVkaWFEZWNvZGVUaW1lLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5mbG9vcihiYXNlTWVkaWFEZWNvZGVUaW1lIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgdXBwZXIpO1xuICAgICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgOCwgbG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBDaGVjayBpZiB0aGUgbGFzdCBtb29mK21kYXQgcGFpciBpcyBwYXJ0IG9mIHRoZSB2YWxpZCByYW5nZVxuZXhwb3J0IGZ1bmN0aW9uIHNlZ21lbnRWYWxpZFJhbmdlKGRhdGE6IFVpbnQ4QXJyYXkpOiBTZWdtZW50ZWRSYW5nZSB7XG4gIGNvbnN0IHNlZ21lbnRlZFJhbmdlOiBTZWdtZW50ZWRSYW5nZSA9IHtcbiAgICB2YWxpZDogbnVsbCxcbiAgICByZW1haW5kZXI6IG51bGwsXG4gIH07XG5cbiAgY29uc3QgbW9vZnMgPSBmaW5kQm94KGRhdGEsIFsnbW9vZiddKTtcbiAgaWYgKG1vb2ZzLmxlbmd0aCA8IDIpIHtcbiAgICBzZWdtZW50ZWRSYW5nZS5yZW1haW5kZXIgPSBkYXRhO1xuICAgIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbW9vZnNbbW9vZnMubGVuZ3RoIC0gMV07XG4gIC8vIE9mZnNldCBieSA4IGJ5dGVzOyBmaW5kQm94IG9mZnNldHMgdGhlIHN0YXJ0IGJ5IGFzIG11Y2hcbiAgc2VnbWVudGVkUmFuZ2UudmFsaWQgPSBzbGljZVVpbnQ4KGRhdGEsIDAsIGxhc3QuYnl0ZU9mZnNldCAtIDgpO1xuICBzZWdtZW50ZWRSYW5nZS5yZW1haW5kZXIgPSBzbGljZVVpbnQ4KGRhdGEsIGxhc3QuYnl0ZU9mZnNldCAtIDgpO1xuICByZXR1cm4gc2VnbWVudGVkUmFuZ2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VnbWVudGVkUmFuZ2Uge1xuICB2YWxpZDogVWludDhBcnJheSB8IG51bGw7XG4gIHJlbWFpbmRlcjogVWludDhBcnJheSB8IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRVaW50OEFycmF5KFxuICBkYXRhMTogVWludDhBcnJheSxcbiAgZGF0YTI6IFVpbnQ4QXJyYXksXG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50OEFycmF5KGRhdGExLmxlbmd0aCArIGRhdGEyLmxlbmd0aCk7XG4gIHRlbXAuc2V0KGRhdGExKTtcbiAgdGVtcC5zZXQoZGF0YTIsIGRhdGExLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHRlbXA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUVtc2dQYXJzaW5nRGF0YSB7XG4gIHNjaGVtZUlkVXJpOiBzdHJpbmc7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIHRpbWVTY2FsZTogbnVtYmVyO1xuICBwcmVzZW50YXRpb25UaW1lRGVsdGE/OiBudW1iZXI7XG4gIHByZXNlbnRhdGlvblRpbWU/OiBudW1iZXI7XG4gIGV2ZW50RHVyYXRpb246IG51bWJlcjtcbiAgaWQ6IG51bWJlcjtcbiAgcGF5bG9hZDogVWludDhBcnJheTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2FtcGxlcyhcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICB0cmFjazogUGFzc3Rocm91Z2hUcmFjayxcbik6IFVzZXJkYXRhU2FtcGxlW10ge1xuICBjb25zdCBzZWlTYW1wbGVzID0gW10gYXMgVXNlcmRhdGFTYW1wbGVbXTtcbiAgY29uc3QgdmlkZW9EYXRhID0gdHJhY2suc2FtcGxlcztcbiAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlO1xuICBjb25zdCB0cmFja0lkID0gdHJhY2suaWQ7XG4gIGxldCBpc0hFVkNGbGF2b3IgPSBmYWxzZTtcblxuICBjb25zdCBtb29mcyA9IGZpbmRCb3godmlkZW9EYXRhLCBbJ21vb2YnXSk7XG4gIG1vb2ZzLm1hcCgobW9vZikgPT4ge1xuICAgIGNvbnN0IG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgIGNvbnN0IHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKCh0cmFmKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgY29uc3QgYmFzZVRpbWUgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKS5tYXAoKHRmZHQpID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVWludDMyKHRmZHQsIDQpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgIHJlc3VsdCAqPSBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgICAgcmVzdWx0ICs9IHJlYWRVaW50MzIodGZkdCwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCAvIHRpbWVzY2FsZTtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaW5kQm94KHRyYWYsIFsndGZoZCddKS5tYXAoKHRmaGQpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgICAgICBjb25zdCB0ZmhkRmxhZ3MgPSByZWFkVWludDMyKHRmaGQsIDApICYgMHhmZmZmZmY7XG4gICAgICAgIGNvbnN0IGJhc2VEYXRhT2Zmc2V0UHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgIGNvbnN0IHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAyKSAhPT0gMDtcbiAgICAgICAgY29uc3QgZGVmYXVsdFNhbXBsZUR1cmF0aW9uUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMTApICE9PSAwO1xuICAgICAgICBsZXQgZGVmYXVsdFNhbXBsZVNpemUgPSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDIwKSAhPT0gMDtcbiAgICAgICAgbGV0IHRmaGRPZmZzZXQgPSA4O1xuXG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbmRCb3godHJhZiwgWyd0cnVuJ10pLm1hcCgodHJ1bikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRydW5bMF07XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IHJlYWRVaW50MzIodHJ1biwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFPZmZzZXRQcmVzZW50ID0gKGZsYWdzICYgMHgwMDAwMDEpICE9PSAwO1xuICAgICAgICAgICAgbGV0IGRhdGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwNCkgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVEdXJhdGlvblByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDEwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlU2l6ZVByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDIwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgc2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVGbGFnc1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDQwMCkgIT09IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50ID0gKGZsYWdzICYgMHgwMDA4MDApICE9PSAwO1xuICAgICAgICAgICAgbGV0IGNvbXBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuLCA0KTtcbiAgICAgICAgICAgIGxldCB0cnVuT2Zmc2V0ID0gODsgLy8gcGFzdCB2ZXJzaW9uLCBmbGFncywgYW5kIHNhbXBsZSBjb3VudFxuXG4gICAgICAgICAgICBpZiAoZGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgZGF0YU9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IHNhbXBsZUNvdW50OyBpeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVEdXJhdGlvblByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbXBsZUR1cmF0aW9uID0gZGVmYXVsdFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVTaXplUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZVNpemUgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gZGVmYXVsdFNhbXBsZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUZsYWdzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlQ29tcG9zaXRpb25PZmZzZXRzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRVaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uT2Zmc2V0ID0gcmVhZFNpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFsdVRvdGFsU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5hbHVUb3RhbFNpemUgPCBzYW1wbGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuYWx1U2l6ZSA9IHJlYWRVaW50MzIodmlkZW9EYXRhLCBzYW1wbGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTRUlNZXNzYWdlKGlzSEVWQ0ZsYXZvciwgdmlkZW9EYXRhW3NhbXBsZU9mZnNldF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB2aWRlb0RhdGEuc3ViYXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArIG5hbHVTaXplLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGlzSEVWQ0ZsYXZvciA/IDIgOiAxLFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWVPZmZzZXQgKyBjb21wb3NpdGlvbk9mZnNldCAvIHRpbWVzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICBzZWlTYW1wbGVzLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0ICs9IG5hbHVTaXplO1xuICAgICAgICAgICAgICAgICAgbmFsdVRvdGFsU2l6ZSArPSBuYWx1U2l6ZSArIDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGltZU9mZnNldCArPSBzYW1wbGVEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc2VpU2FtcGxlcztcbn1cblxuZnVuY3Rpb24gaXNIRVZDKGNvZGVjOiBzdHJpbmcpIHtcbiAgaWYgKCFjb2RlYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkZWxpbWl0ID0gY29kZWMuaW5kZXhPZignLicpO1xuICBjb25zdCBiYXNlQ29kZWMgPSBkZWxpbWl0IDwgMCA/IGNvZGVjIDogY29kZWMuc3Vic3RyaW5nKDAsIGRlbGltaXQpO1xuICByZXR1cm4gKFxuICAgIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8XG4gICAgYmFzZUNvZGVjID09PSAnaGV2MScgfHxcbiAgICAvLyBEb2xieSBWaXNpb25cbiAgICBiYXNlQ29kZWMgPT09ICdkdmgxJyB8fFxuICAgIGJhc2VDb2RlYyA9PT0gJ2R2aGUnXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3I6IGJvb2xlYW4sIG5hbHVIZWFkZXI6IG51bWJlcikge1xuICBpZiAoaXNIRVZDRmxhdm9yKSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSAobmFsdUhlYWRlciA+PiAxKSAmIDB4M2Y7XG4gICAgcmV0dXJuIG5hbHVUeXBlID09PSAzOSB8fCBuYWx1VHlwZSA9PT0gNDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFsdVR5cGUgPSBuYWx1SGVhZGVyICYgMHgxZjtcbiAgICByZXR1cm4gbmFsdVR5cGUgPT09IDY7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1KFxuICB1bmVzY2FwZWREYXRhOiBVaW50OEFycmF5LFxuICBoZWFkZXJTaXplOiBudW1iZXIsXG4gIHB0czogbnVtYmVyLFxuICBzYW1wbGVzOiBVc2VyZGF0YVNhbXBsZVtdLFxuKSB7XG4gIGNvbnN0IGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICBsZXQgc2VpUHRyID0gMDtcbiAgLy8gc2tpcCBuYWwgaGVhZGVyXG4gIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICBsZXQgcGF5bG9hZFR5cGUgPSAwO1xuICBsZXQgcGF5bG9hZFNpemUgPSAwO1xuICBsZXQgYiA9IDA7XG5cbiAgd2hpbGUgKHNlaVB0ciA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcGF5bG9hZFR5cGUgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmIChzZWlQdHIgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiID0gZGF0YVtzZWlQdHIrK107XG4gICAgICBwYXlsb2FkVHlwZSArPSBiO1xuICAgIH0gd2hpbGUgKGIgPT09IDB4ZmYpO1xuXG4gICAgLy8gUGFyc2UgcGF5bG9hZCBzaXplLlxuICAgIHBheWxvYWRTaXplID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFNpemUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgIGNvbnN0IGxlZnRPdmVyID0gZGF0YS5sZW5ndGggLSBzZWlQdHI7XG4gICAgLy8gQ3JlYXRlIGEgdmFyaWFibGUgdG8gcHJvY2VzcyB0aGUgcGF5bG9hZFxuICAgIGxldCBwYXlQdHIgPSBzZWlQdHI7XG5cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHNlaVB0ciB0byB0aGUgZW5kIG9mIHRoZSBwYXlsb2FkXG4gICAgaWYgKHBheWxvYWRTaXplIDwgbGVmdE92ZXIpIHtcbiAgICAgIHNlaVB0ciArPSBwYXlsb2FkU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRTaXplID4gbGVmdE92ZXIpIHtcbiAgICAgIC8vIFNvbWUgdHlwZSBvZiBjb3JydXB0aW9uIGhhcyBoYXBwZW5lZD9cbiAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgYE1hbGZvcm1lZCBTRUkgcGF5bG9hZC4gJHtwYXlsb2FkU2l6ZX0gaXMgdG9vIHNtYWxsLCBvbmx5ICR7bGVmdE92ZXJ9IGJ5dGVzIGxlZnQgdG8gcGFyc2UuYCxcbiAgICAgICk7XG4gICAgICAvLyBXZSBtaWdodCBiZSBhYmxlIHRvIHBhcnNlIHNvbWUgZGF0YSwgYnV0IGxldCdzIGJlIHNhZmUgYW5kIGlnbm9yZSBpdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXlsb2FkVHlwZSA9PT0gNCkge1xuICAgICAgY29uc3QgY291bnRyeUNvZGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgIGlmIChjb3VudHJ5Q29kZSA9PT0gMTgxKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyQ29kZSA9IHJlYWRVaW50MTYoZGF0YSwgcGF5UHRyKTtcbiAgICAgICAgcGF5UHRyICs9IDI7XG5cbiAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICBjb25zdCB1c2VyU3RydWN0dXJlID0gcmVhZFVpbnQzMihkYXRhLCBwYXlQdHIpO1xuICAgICAgICAgIHBheVB0ciArPSA0O1xuXG4gICAgICAgICAgaWYgKHVzZXJTdHJ1Y3R1cmUgPT09IDB4NDc0MTM5MzQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhVHlwZSA9IGRhdGFbcGF5UHRyKytdO1xuXG4gICAgICAgICAgICAvLyBSYXcgQ0VBLTYwOCBieXRlcyB3cmFwcGVkIGluIENFQS03MDggcGFja2V0XG4gICAgICAgICAgICBpZiAodXNlckRhdGFUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbENDcyA9IDB4MWYgJiBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIGNvbnN0IGVuYWJsZWQgPSAweDQwICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCB0b3RhbEJ5dGVzID0gZW5hYmxlZCA/IDIgKyB0b3RhbENDcyAqIDMgOiAwO1xuICAgICAgICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBieXRlQXJyYXlbMF0gPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0b3RhbEJ5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVBcnJheVtpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdXNlckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgIHB0cyxcbiAgICAgICAgICAgICAgICBieXRlczogYnl0ZUFycmF5LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBheWxvYWRUeXBlID09PSA1KSB7XG4gICAgICBpZiAocGF5bG9hZFNpemUgPiAxNikge1xuICAgICAgICBjb25zdCB1dWlkU3RyQXJyYXk6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgYiA9IGRhdGFbcGF5UHRyKytdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICB1dWlkU3RyQXJyYXkucHVzaChiLmxlbmd0aCA9PSAxID8gJzAnICsgYiA6IGIpO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcbiAgICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBheWxvYWRTaXplIC0gMTY7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdXNlckRhdGFCeXRlc1tpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICB9XG5cbiAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwYXlsb2FkVHlwZSxcbiAgICAgICAgICBwdHMsXG4gICAgICAgICAgdXVpZDogdXVpZFN0ckFycmF5LmpvaW4oJycpLFxuICAgICAgICAgIHVzZXJEYXRhOiB1dGY4QXJyYXlUb1N0cih1c2VyRGF0YUJ5dGVzKSxcbiAgICAgICAgICB1c2VyRGF0YUJ5dGVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2NhcmRFUEIoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGNvbnN0IEVQQlBvc2l0aW9ucyA9IFtdIGFzIEFycmF5PG51bWJlcj47XG4gIGxldCBpID0gMTtcblxuICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgY29uc3QgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIGxldCBzb3VyY2VJbmRleCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5ld0xlbmd0aDsgc291cmNlSW5kZXgrKywgaSsrKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSBFUEJQb3NpdGlvbnNbMF0pIHtcbiAgICAgIC8vIFNraXAgdGhpcyBieXRlXG4gICAgICBzb3VyY2VJbmRleCsrO1xuICAgICAgLy8gUmVtb3ZlIHRoaXMgcG9zaXRpb24gaW5kZXhcbiAgICAgIEVQQlBvc2l0aW9ucy5zaGlmdCgpO1xuICAgIH1cbiAgICBuZXdEYXRhW2ldID0gZGF0YVtzb3VyY2VJbmRleF07XG4gIH1cbiAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUVtc2coZGF0YTogVWludDhBcnJheSk6IElFbXNnUGFyc2luZ0RhdGEge1xuICBjb25zdCB2ZXJzaW9uID0gZGF0YVswXTtcbiAgbGV0IHNjaGVtZUlkVXJpOiBzdHJpbmcgPSAnJztcbiAgbGV0IHZhbHVlOiBzdHJpbmcgPSAnJztcbiAgbGV0IHRpbWVTY2FsZTogbnVtYmVyID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWVEZWx0YTogbnVtYmVyID0gMDtcbiAgbGV0IHByZXNlbnRhdGlvblRpbWU6IG51bWJlciA9IDA7XG4gIGxldCBldmVudER1cmF0aW9uOiBudW1iZXIgPSAwO1xuICBsZXQgaWQ6IG51bWJlciA9IDA7XG4gIGxldCBvZmZzZXQ6IG51bWJlciA9IDA7XG5cbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuXG4gICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgIG9mZnNldCArPSAxO1xuXG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgMTIpO1xuICAgIHByZXNlbnRhdGlvblRpbWVEZWx0YSA9IHJlYWRVaW50MzIoZGF0YSwgMTYpO1xuICAgIGV2ZW50RHVyYXRpb24gPSByZWFkVWludDMyKGRhdGEsIDIwKTtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgMjQpO1xuICAgIG9mZnNldCA9IDI4O1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aW1lU2NhbGUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbGVmdFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgcmlnaHRQcmVzZW50YXRpb25UaW1lID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHByZXNlbnRhdGlvblRpbWUgPSAyICoqIDMyICogbGVmdFByZXNlbnRhdGlvblRpbWUgKyByaWdodFByZXNlbnRhdGlvblRpbWU7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwcmVzZW50YXRpb25UaW1lKSkge1xuICAgICAgcHJlc2VudGF0aW9uVGltZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICdQcmVzZW50YXRpb24gdGltZSBleGNlZWRzIHNhZmUgaW50ZWdlciBsaW1pdCBhbmQgd3JhcHBlZCB0byBtYXggc2FmZSBpbnRlZ2VyIGluIHBhcnNpbmcgZW1zZyBib3gnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBldmVudER1cmF0aW9uID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuXG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cblxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcblxuICAgIHdoaWxlIChiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSkgIT09ICdcXDAnKSB7XG4gICAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgICBvZmZzZXQgKz0gMTtcbiAgICB9XG5cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gIH1cbiAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB7XG4gICAgc2NoZW1lSWRVcmksXG4gICAgdmFsdWUsXG4gICAgdGltZVNjYWxlLFxuICAgIHByZXNlbnRhdGlvblRpbWUsXG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhLFxuICAgIGV2ZW50RHVyYXRpb24sXG4gICAgaWQsXG4gICAgcGF5bG9hZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1wNEJveCh0eXBlOiBBcnJheUxpa2U8bnVtYmVyPiwgLi4ucGF5bG9hZDogVWludDhBcnJheVtdKSB7XG4gIGNvbnN0IGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBsZXQgc2l6ZSA9IDg7XG4gIGxldCBpID0gbGVuO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIHJlc3VsdFswXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gIHJlc3VsdFsxXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gIHJlc3VsdC5zZXQodHlwZSwgNCk7XG4gIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgIHNpemUgKz0gcGF5bG9hZFtpXS5ieXRlTGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtcDRwc3NoKFxuICBzeXN0ZW1JZDogVWludDhBcnJheSxcbiAga2V5aWRzOiBBcnJheTxVaW50OEFycmF5PiB8IG51bGwsXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4pIHtcbiAgaWYgKHN5c3RlbUlkLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3lzdGVtIGlkJyk7XG4gIH1cbiAgbGV0IHZlcnNpb247XG4gIGxldCBraWRzO1xuICBpZiAoa2V5aWRzKSB7XG4gICAgdmVyc2lvbiA9IDE7XG4gICAga2lkcyA9IG5ldyBVaW50OEFycmF5KGtleWlkcy5sZW5ndGggKiAxNik7XG4gICAgZm9yIChsZXQgaXggPSAwOyBpeCA8IGtleWlkcy5sZW5ndGg7IGl4KyspIHtcbiAgICAgIGNvbnN0IGsgPSBrZXlpZHNbaXhdOyAvLyB1aW50OGFycmF5XG4gICAgICBpZiAoay5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgIH1cbiAgICAgIGtpZHMuc2V0KGssIGl4ICogMTYpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ZXJzaW9uID0gMDtcbiAgICBraWRzID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBsZXQga2lkQ291bnQ7XG4gIGlmICh2ZXJzaW9uID4gMCkge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgaWYgKGtleWlkcyEubGVuZ3RoID4gMCkge1xuICAgICAgbmV3IERhdGFWaWV3KGtpZENvdW50LmJ1ZmZlcikuc2V0VWludDMyKDAsIGtleWlkcyEubGVuZ3RoLCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBjb25zdCBkYXRhU2l6ZSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBpZiAoZGF0YSAmJiBkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgbmV3IERhdGFWaWV3KGRhdGFTaXplLmJ1ZmZlcikuc2V0VWludDMyKDAsIGRhdGEuYnl0ZUxlbmd0aCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBtcDRCb3goXG4gICAgWzExMiwgMTE1LCAxMTUsIDEwNF0sXG4gICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgdmVyc2lvbixcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gRmxhZ3NcbiAgICBdKSxcbiAgICBzeXN0ZW1JZCwgLy8gMTYgYnl0ZXNcbiAgICBraWRDb3VudCxcbiAgICBraWRzLFxuICAgIGRhdGFTaXplLFxuICAgIGRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHNzaChpbml0RGF0YTogQXJyYXlCdWZmZXIpIHtcbiAgaWYgKCEoaW5pdERhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgaW5pdERhdGEuYnl0ZUxlbmd0aCA8IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHZlcnNpb246IDAsXG4gICAgc3lzdGVtSWQ6ICcnLFxuICAgIGtpZHM6IG51bGwgYXMgbnVsbCB8IFVpbnQ4QXJyYXlbXSxcbiAgICBkYXRhOiBudWxsIGFzIG51bGwgfCBVaW50OEFycmF5LFxuICB9O1xuICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGluaXREYXRhKTtcbiAgY29uc3QgYm94U2l6ZSA9IHZpZXcuZ2V0VWludDMyKDApO1xuICBpZiAoaW5pdERhdGEuYnl0ZUxlbmd0aCAhPT0gYm94U2l6ZSAmJiBib3hTaXplID4gNDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0eXBlID0gdmlldy5nZXRVaW50MzIoNCk7XG4gIGlmICh0eXBlICE9PSAweDcwNzM3MzY4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnZlcnNpb24gPSB2aWV3LmdldFVpbnQzMig4KSA+Pj4gMjQ7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA+IDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN1bHQuc3lzdGVtSWQgPSBIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMTIsIDE2KSk7XG4gIGNvbnN0IGRhdGFTaXplT3JLaWRDb3VudCA9IHZpZXcuZ2V0VWludDMyKDI4KTtcbiAgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAwKSB7XG4gICAgaWYgKGJveFNpemUgLSAzMiA8IGRhdGFTaXplT3JLaWRDb3VudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDMyLCBkYXRhU2l6ZU9yS2lkQ291bnQpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC52ZXJzaW9uID09PSAxKSB7XG4gICAgcmVzdWx0LmtpZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTaXplT3JLaWRDb3VudDsgaSsrKSB7XG4gICAgICByZXN1bHQua2lkcy5wdXNoKG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiArIGkgKiAxNiwgMTYpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG4gIGNoYW5nZUVuZGlhbm5lc3MsXG4gIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzLFxufSBmcm9tICcuLi91dGlscy9rZXlzeXN0ZW0tdXRpbCc7XG5pbXBvcnQgeyBLZXlTeXN0ZW1Gb3JtYXRzIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5pbXBvcnQgeyBtcDRwc3NoIH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBiYXNlNjREZWNvZGUgfSBmcm9tICcuLi91dGlscy9udW1lcmljLWVuY29kaW5nLXV0aWxzJztcblxubGV0IGtleVVyaVRvS2V5SWRNYXA6IHsgW3VyaTogc3RyaW5nXTogVWludDhBcnJheSB9ID0ge307XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjcnlwdERhdGEge1xuICB1cmk6IHN0cmluZztcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIGtleUZvcm1hdDogc3RyaW5nO1xuICBrZXlGb3JtYXRWZXJzaW9uczogbnVtYmVyW107XG4gIGl2OiBVaW50OEFycmF5IHwgbnVsbDtcbiAga2V5OiBVaW50OEFycmF5IHwgbnVsbDtcbiAga2V5SWQ6IFVpbnQ4QXJyYXkgfCBudWxsO1xuICBwc3NoOiBVaW50OEFycmF5IHwgbnVsbDtcbiAgZW5jcnlwdGVkOiBib29sZWFuO1xuICBpc0NvbW1vbkVuY3J5cHRpb246IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBMZXZlbEtleSBpbXBsZW1lbnRzIERlY3J5cHREYXRhIHtcbiAgcHVibGljIHJlYWRvbmx5IHVyaTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgbWV0aG9kOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBrZXlGb3JtYXQ6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGtleUZvcm1hdFZlcnNpb25zOiBudW1iZXJbXTtcbiAgcHVibGljIHJlYWRvbmx5IGVuY3J5cHRlZDogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IGlzQ29tbW9uRW5jcnlwdGlvbjogYm9vbGVhbjtcbiAgcHVibGljIGl2OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBrZXk6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGtleUlkOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBwc3NoOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG5cbiAgc3RhdGljIGNsZWFyS2V5VXJpVG9LZXlJZE1hcCgpIHtcbiAgICBrZXlVcmlUb0tleUlkTWFwID0ge307XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICB1cmk6IHN0cmluZyxcbiAgICBmb3JtYXQ6IHN0cmluZyxcbiAgICBmb3JtYXR2ZXJzaW9uczogbnVtYmVyW10gPSBbMV0sXG4gICAgaXY6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbCxcbiAgKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy5rZXlGb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyA9IGZvcm1hdHZlcnNpb25zO1xuICAgIHRoaXMuaXYgPSBpdjtcbiAgICB0aGlzLmVuY3J5cHRlZCA9IG1ldGhvZCA/IG1ldGhvZCAhPT0gJ05PTkUnIDogZmFsc2U7XG4gICAgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiBtZXRob2QgIT09ICdBRVMtMTI4JztcbiAgfVxuXG4gIHB1YmxpYyBpc1N1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgICAvLyBJZiBpdCdzIFNlZ21lbnQgZW5jcnlwdGlvbiBvciBObyBlbmNyeXB0aW9uLCBqdXN0IHNlbGVjdCB0aGF0IGtleSBzeXN0ZW1cbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnIHx8IHRoaXMubWV0aG9kID09PSAnTk9ORScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgLy8gTWFpbnRhaW4gc3VwcG9ydCBmb3IgY2xlYXIgU0FNUExFLUFFUyB3aXRoIE1QRUctMyBUU1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2QgPT09ICdTQU1QTEUtQUVTJztcbiAgICAgIH0gZWxzZSBpZiAoX19VU0VfRU1FX0RSTV9fKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuRkFJUlBMQVk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdJU08tMjMwMDEtNycsXG4gICAgICAgICAgICAgICAgJ1NBTVBMRS1BRVMnLFxuICAgICAgICAgICAgICAgICdTQU1QTEUtQUVTLUNFTkMnLFxuICAgICAgICAgICAgICAgICdTQU1QTEUtQUVTLUNUUicsXG4gICAgICAgICAgICAgIF0uaW5kZXhPZih0aGlzLm1ldGhvZCkgIT09IC0xXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREZWNyeXB0RGF0YShzbjogbnVtYmVyIHwgJ2luaXRTZWdtZW50Jyk6IExldmVsS2V5IHwgbnVsbCB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0FFUy0xMjgnICYmIHRoaXMudXJpICYmICF0aGlzLml2KSB7XG4gICAgICBpZiAodHlwZW9mIHNuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBXZSBhcmUgZmV0Y2hpbmcgZGVjcnlwdGlvbiBkYXRhIGZvciBhIGluaXRpYWxpemF0aW9uIHNlZ21lbnRcbiAgICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgd2FzIGVuY3J5cHRlZCB3aXRoIEFFUy0xMjhcbiAgICAgICAgLy8gSXQgbXVzdCBoYXZlIGFuIElWIGRlZmluZWQuIFdlIGNhbm5vdCBzdWJzdGl0dXRlIHRoZSBTZWdtZW50IE51bWJlciBpbi5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgIXRoaXMuaXYpIHtcbiAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgIGBtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJHt0aGlzLm1ldGhvZH1cIiAtIGNvbXBsaWFuY2UgaXNzdWVgLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgc24gdG8gcmVzdWx0aW5nIHZhbHVlIGZyb20gaW1wbGljaXQgY29udmVyc2lvbnMgJ2luaXRTZWdtZW50JyB2YWx1ZXMgZm9yIElWIGdlbmVyYXRpb24uXG4gICAgICAgIHNuID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl2ID0gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc24pO1xuICAgICAgY29uc3QgZGVjcnlwdGRhdGEgPSBuZXcgTGV2ZWxLZXkoXG4gICAgICAgIHRoaXMubWV0aG9kLFxuICAgICAgICB0aGlzLnVyaSxcbiAgICAgICAgJ2lkZW50aXR5JyxcbiAgICAgICAgdGhpcy5rZXlGb3JtYXRWZXJzaW9ucyxcbiAgICAgICAgaXYsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY3J5cHRkYXRhO1xuICAgIH1cblxuICAgIGlmICghX19VU0VfRU1FX0RSTV9fKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGtleUlkIGlmIHBvc3NpYmxlXG4gICAgY29uc3Qga2V5Qnl0ZXMgPSBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh0aGlzLnVyaSk7XG4gICAgaWYgKGtleUJ5dGVzKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICB0aGlzLnBzc2ggPSBrZXlCeXRlcztcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIHdpZGV2aW5lIGtleUlEIGlzIGVtYmVkZGVkIGluIFBTU0ggYm94LiBSZWFkIEtleSBJRC5cbiAgICAgICAgICBpZiAoa2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5Qnl0ZXMuc3ViYXJyYXkoXG4gICAgICAgICAgICAgIGtleUJ5dGVzLmxlbmd0aCAtIDIyLFxuICAgICAgICAgICAgICBrZXlCeXRlcy5sZW5ndGggLSA2LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6IHtcbiAgICAgICAgICBjb25zdCBQbGF5UmVhZHlLZXlTeXN0ZW1VVUlEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHg5YSwgMHgwNCwgMHhmMCwgMHg3OSwgMHg5OCwgMHg0MCwgMHg0MiwgMHg4NiwgMHhhYiwgMHg5MiwgMHhlNixcbiAgICAgICAgICAgIDB4NWIsIDB4ZTAsIDB4ODgsIDB4NWYsIDB4OTUsXG4gICAgICAgICAgXSk7XG5cbiAgICAgICAgICB0aGlzLnBzc2ggPSBtcDRwc3NoKFBsYXlSZWFkeUtleVN5c3RlbVVVSUQsIG51bGwsIGtleUJ5dGVzKTtcblxuICAgICAgICAgIGNvbnN0IGtleUJ5dGVzVXRmMTYgPSBuZXcgVWludDE2QXJyYXkoXG4gICAgICAgICAgICBrZXlCeXRlcy5idWZmZXIsXG4gICAgICAgICAgICBrZXlCeXRlcy5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAga2V5Qnl0ZXMuYnl0ZUxlbmd0aCAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBrZXlCeXRlU3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBBcnJheS5mcm9tKGtleUJ5dGVzVXRmMTYpLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBQYXJzZSBQbGF5cmVhZHkgV1JNSGVhZGVyIFhNTFxuICAgICAgICAgIGNvbnN0IHhtbEtleUJ5dGVzID0ga2V5Qnl0ZVN0ci5zdWJzdHJpbmcoXG4gICAgICAgICAgICBrZXlCeXRlU3RyLmluZGV4T2YoJzwnKSxcbiAgICAgICAgICAgIGtleUJ5dGVTdHIubGVuZ3RoLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgIGNvbnN0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sS2V5Qnl0ZXMsICd0ZXh0L3htbCcpO1xuICAgICAgICAgIGNvbnN0IGtleURhdGEgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0tJRCcpWzBdO1xuICAgICAgICAgIGlmIChrZXlEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlJZCA9IGtleURhdGEuY2hpbGROb2Rlc1swXVxuICAgICAgICAgICAgICA/IGtleURhdGEuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWVcbiAgICAgICAgICAgICAgOiBrZXlEYXRhLmdldEF0dHJpYnV0ZSgnVkFMVUUnKTtcbiAgICAgICAgICAgIGlmIChrZXlJZCkge1xuICAgICAgICAgICAgICBjb25zdCBrZXlJZEFycmF5ID0gYmFzZTY0RGVjb2RlKGtleUlkKS5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICAgIC8vIEtJRCB2YWx1ZSBpbiBQUk8gaXMgYSBiYXNlNjQtZW5jb2RlZCBsaXR0bGUgZW5kaWFuIEdVSUQgaW50ZXJwcmV0YXRpb24gb2YgVVVJRFxuICAgICAgICAgICAgICAvLyBLSUQgdmFsdWUgaW4g4oCYdGVuY+KAmSBpcyBhIGJpZyBlbmRpYW4gVVVJRCBHVUlEIGludGVycHJldGF0aW9uIG9mIFVVSURcbiAgICAgICAgICAgICAgY2hhbmdlRW5kaWFubmVzcyhrZXlJZEFycmF5KTtcbiAgICAgICAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBsZXQga2V5ZGF0YSA9IGtleUJ5dGVzLnN1YmFycmF5KDAsIDE2KTtcbiAgICAgICAgICBpZiAoa2V5ZGF0YS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBwYWRkZWQuc2V0KGtleWRhdGEsIDE2IC0ga2V5ZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAga2V5ZGF0YSA9IHBhZGRlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5rZXlJZCA9IGtleWRhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBhc3NpZ24gYSBuZXcga2V5SWQgZm9yIGVhY2ggdXJpXG4gICAgaWYgKCF0aGlzLmtleUlkIHx8IHRoaXMua2V5SWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGxldCBrZXlJZCA9IGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldO1xuICAgICAgaWYgKCFrZXlJZCkge1xuICAgICAgICBjb25zdCB2YWwgPVxuICAgICAgICAgIE9iamVjdC5rZXlzKGtleVVyaVRvS2V5SWRNYXApLmxlbmd0aCAlIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBrZXlJZCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoa2V5SWQuYnVmZmVyLCAxMiwgNCk7IC8vIEp1c3Qgc2V0IHRoZSBsYXN0IDQgYnl0ZXNcbiAgICAgICAgZHYuc2V0VWludDMyKDAsIHZhbCk7XG4gICAgICAgIGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldID0ga2V5SWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmtleUlkID0ga2V5SWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcjogbnVtYmVyKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgZm9yIChsZXQgaSA9IDEyOyBpIDwgMTY7IGkrKykge1xuICAgIHVpbnQ4Vmlld1tpXSA9IChzZWdtZW50TnVtYmVyID4+ICg4ICogKDE1IC0gaSkpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4Vmlldztcbn1cbiIsIi8qKlxuICogTWVkaWFTb3VyY2UgaGVscGVyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhU291cmNlKFxuICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlLFxuKTogdHlwZW9mIE1lZGlhU291cmNlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgbW1zID1cbiAgICAocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlIHx8ICFzZWxmLk1lZGlhU291cmNlKSAmJlxuICAgICgoc2VsZiBhcyBhbnkpLk1hbmFnZWRNZWRpYVNvdXJjZSBhcyB1bmRlZmluZWQgfCB0eXBlb2YgTWVkaWFTb3VyY2UpO1xuICByZXR1cm4gKFxuICAgIG1tcyB8fFxuICAgIHNlbGYuTWVkaWFTb3VyY2UgfHxcbiAgICAoKHNlbGYgYXMgYW55KS5XZWJLaXRNZWRpYVNvdXJjZSBhcyB0eXBlb2YgTWVkaWFTb3VyY2UpXG4gICk7XG59XG4iLCJpbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4vbWVkaWFzb3VyY2UtaGVscGVyJztcblxuLy8gZnJvbSBodHRwOi8vbXA0cmEub3JnL2NvZGVjcy5odG1sXG4vLyB2YWx1ZXMgaW5kaWNhdGUgY29kZWMgc2VsZWN0aW9uIHByZWZlcmVuY2UgKGxvd2VyIGlzIGhpZ2hlciBwcmlvcml0eSlcbmNvbnN0IHNhbXBsZUVudHJ5Q29kZXNJU08gPSB7XG4gIGF1ZGlvOiB7XG4gICAgYTNkczogMSxcbiAgICAnYWMtMyc6IDAuOTUsXG4gICAgJ2FjLTQnOiAxLFxuICAgIGFsYWM6IDAuOSxcbiAgICBhbGF3OiAxLFxuICAgIGRyYTE6IDEsXG4gICAgJ2R0cysnOiAxLFxuICAgICdkdHMtJzogMSxcbiAgICBkdHNjOiAxLFxuICAgIGR0c2U6IDEsXG4gICAgZHRzaDogMSxcbiAgICAnZWMtMyc6IDAuOSxcbiAgICBlbmNhOiAxLFxuICAgIGZMYUM6IDAuOSwgLy8gTVA0LVJBIGxpc3RlZCBjb2RlYyBlbnRyeSBmb3IgRkxBQ1xuICAgIGZsYWM6IDAuOSwgLy8gbGVnYWN5IGJyb3dzZXIgY29kZWMgbmFtZSBmb3IgRkxBQ1xuICAgIEZMQUM6IDAuOSwgLy8gc29tZSBtYW5pZmVzdHMgbWF5IGxpc3QgXCJGTEFDXCIgd2l0aCBBcHBsZSdzIHRvb2xzXG4gICAgZzcxOTogMSxcbiAgICBnNzI2OiAxLFxuICAgIG00YWU6IDEsXG4gICAgbWhhMTogMSxcbiAgICBtaGEyOiAxLFxuICAgIG1obTE6IDEsXG4gICAgbWhtMjogMSxcbiAgICBtbHBhOiAxLFxuICAgIG1wNGE6IDEsXG4gICAgJ3JhdyAnOiAxLFxuICAgIE9wdXM6IDEsXG4gICAgb3B1czogMSwgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiAxLFxuICAgIHNhd2I6IDEsXG4gICAgc2F3cDogMSxcbiAgICBzZXZjOiAxLFxuICAgIHNxY3A6IDEsXG4gICAgc3NtdjogMSxcbiAgICB0d29zOiAxLFxuICAgIHVsYXc6IDEsXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgYXZjMTogMSxcbiAgICBhdmMyOiAxLFxuICAgIGF2YzM6IDEsXG4gICAgYXZjNDogMSxcbiAgICBhdmNwOiAxLFxuICAgIGF2MDE6IDAuOCxcbiAgICBkcmFjOiAxLFxuICAgIGR2YTE6IDEsXG4gICAgZHZhdjogMSxcbiAgICBkdmgxOiAwLjcsXG4gICAgZHZoZTogMC43LFxuICAgIGVuY3Y6IDEsXG4gICAgaGV2MTogMC43NSxcbiAgICBodmMxOiAwLjc1LFxuICAgIG1qcDI6IDEsXG4gICAgbXA0djogMSxcbiAgICBtdmMxOiAxLFxuICAgIG12YzI6IDEsXG4gICAgbXZjMzogMSxcbiAgICBtdmM0OiAxLFxuICAgIHJlc3Y6IDEsXG4gICAgcnY2MDogMSxcbiAgICBzMjYzOiAxLFxuICAgIHN2YzE6IDEsXG4gICAgc3ZjMjogMSxcbiAgICAndmMtMSc6IDEsXG4gICAgdnAwODogMSxcbiAgICB2cDA5OiAwLjksXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBzdHBwOiAxLFxuICAgIHd2dHQ6IDEsXG4gIH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBDb2RlY1R5cGUgPSAnYXVkaW8nIHwgJ3ZpZGVvJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29kZWNUeXBlKGNvZGVjOiBzdHJpbmcsIHR5cGU6IENvZGVjVHlwZSk6IGJvb2xlYW4ge1xuICBjb25zdCB0eXBlQ29kZXMgPSBzYW1wbGVFbnRyeUNvZGVzSVNPW3R5cGVdO1xuICByZXR1cm4gISF0eXBlQ29kZXMgJiYgISF0eXBlQ29kZXNbY29kZWMuc2xpY2UoMCwgNCldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQoXG4gIGNvZGVjczogc3RyaW5nLFxuICB0eXBlOiBDb2RlY1R5cGUsXG4gIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUsXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuICFjb2RlY3NcbiAgICAuc3BsaXQoJywnKVxuICAgIC5zb21lKFxuICAgICAgKGNvZGVjKSA9PlxuICAgICAgICAhaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjLCB0eXBlLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpLFxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChcbiAgY29kZWM6IHN0cmluZyxcbiAgdHlwZTogQ29kZWNUeXBlLFxuICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlLFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UocHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgcmV0dXJuIE1lZGlhU291cmNlPy5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlYywgdHlwZSkpID8/IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWltZVR5cGVGb3JDb2RlYyhjb2RlYzogc3RyaW5nLCB0eXBlOiBDb2RlY1R5cGUpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7dHlwZX0vbXA0O2NvZGVjcz1cIiR7Y29kZWN9XCJgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShcbiAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogbnVtYmVyIHtcbiAgaWYgKHZpZGVvQ29kZWMpIHtcbiAgICBjb25zdCBmb3VyQ0MgPSB2aWRlb0NvZGVjLnN1YnN0cmluZygwLCA0KTtcbiAgICByZXR1cm4gc2FtcGxlRW50cnlDb2Rlc0lTTy52aWRlb1tmb3VyQ0NdO1xuICB9XG4gIHJldHVybiAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNvZGVjU2V0OiBzdHJpbmcpOiBudW1iZXIge1xuICByZXR1cm4gY29kZWNTZXQuc3BsaXQoJywnKS5yZWR1Y2UoKG51bSwgZm91ckNDKSA9PiB7XG4gICAgY29uc3QgcHJlZmVyZW5jZVZhbHVlID0gc2FtcGxlRW50cnlDb2Rlc0lTTy52aWRlb1tmb3VyQ0NdO1xuICAgIGlmIChwcmVmZXJlbmNlVmFsdWUpIHtcbiAgICAgIHJldHVybiAocHJlZmVyZW5jZVZhbHVlICogMiArIG51bSkgLyAobnVtID8gMyA6IDIpO1xuICAgIH1cbiAgICByZXR1cm4gKHNhbXBsZUVudHJ5Q29kZXNJU08uYXVkaW9bZm91ckNDXSArIG51bSkgLyAobnVtID8gMiA6IDEpO1xuICB9LCAwKTtcbn1cblxuaW50ZXJmYWNlIENvZGVjTmFtZUNhY2hlIHtcbiAgZmxhYz86IHN0cmluZztcbiAgb3B1cz86IHN0cmluZztcbn1cblxuY29uc3QgQ09ERUNfQ09NUEFUSUJMRV9OQU1FUzogQ29kZWNOYW1lQ2FjaGUgPSB7fTtcblxudHlwZSBMb3dlckNhc2VDb2RlY1R5cGUgPSAnZmxhYycgfCAnb3B1cyc7XG5cbmZ1bmN0aW9uIGdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlcihcbiAgbG93ZXJDYXNlQ29kZWM6IExvd2VyQ2FzZUNvZGVjVHlwZSxcbiAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSxcbik6IHN0cmluZyB7XG4gIGlmIChDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXSkge1xuICAgIHJldHVybiBDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXSE7XG4gIH1cblxuICAvLyBJZGVhbHkgZkxhQyBhbmQgT3B1cyB3b3VsZCBiZSBmaXJzdCAoc3BlYy1jb21wbGlhbnQpIGJ1dFxuICAvLyBzb21lIGJyb3dzZXJzIHdpbGwgcmVwb3J0IHRoYXQgZkxhQyBpcyBzdXBwb3J0ZWQgdGhlbiBmYWlsLlxuICAvLyBzZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE0MjI3MjhcbiAgY29uc3QgY29kZWNzVG9DaGVjayA9IHtcbiAgICBmbGFjOiBbJ2ZsYWMnLCAnZkxhQycsICdGTEFDJ10sXG4gICAgb3B1czogWydvcHVzJywgJ09wdXMnXSxcbiAgfVtsb3dlckNhc2VDb2RlY107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlY3NUb0NoZWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKFxuICAgICAgICBjb2RlY3NUb0NoZWNrW2ldLFxuICAgICAgICAnYXVkaW8nLFxuICAgICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UsXG4gICAgICApXG4gICAgKSB7XG4gICAgICBDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXSA9IGNvZGVjc1RvQ2hlY2tbaV07XG4gICAgICByZXR1cm4gY29kZWNzVG9DaGVja1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG93ZXJDYXNlQ29kZWM7XG59XG5cbmNvbnN0IEFVRElPX0NPREVDX1JFR0VYUCA9IC9mbGFjfG9wdXMvaTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKFxuICBjb2RlYzogc3RyaW5nLFxuICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGNvZGVjLnJlcGxhY2UoQVVESU9fQ09ERUNfUkVHRVhQLCAobSkgPT5cbiAgICBnZXRDb2RlY0NvbXBhdGlibGVOYW1lTG93ZXIoXG4gICAgICBtLnRvTG93ZXJDYXNlKCkgYXMgTG93ZXJDYXNlQ29kZWNUeXBlLFxuICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlLFxuICAgICksXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKFxuICBwYXJzZWRDb2RlYzogc3RyaW5nLFxuICBsZXZlbENvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBQYXJzaW5nIG9mIG1wNGEgY29kZWNzIHN0cmluZ3MgaW4gbXA0LXRvb2xzIGZyb20gbWVkaWEgaXMgaW5jb21wbGV0ZSBhcyBvZiBkOGM2YzdhXG4gIC8vIHNvIHVzZSBsZXZlbCBjb2RlYyBpcyBwYXJzZWQgY29kZWMgaXMgdW5hdmFpbGFibGUgb3IgaW5jb21wbGV0ZVxuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMgIT09ICdtcDRhJykge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICByZXR1cm4gbGV2ZWxDb2RlYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRBVkMxVG9BVkNPVEkoY29kZWM6IHN0cmluZykge1xuICAvLyBDb252ZXJ0IGF2YzEgY29kZWMgc3RyaW5nIGZyb20gUkZDLTQyODEgdG8gUkZDLTYzODEgZm9yIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZFxuICBjb25zdCBhdmNkYXRhID0gY29kZWMuc3BsaXQoJy4nKTtcbiAgaWYgKGF2Y2RhdGEubGVuZ3RoID4gMikge1xuICAgIGxldCByZXN1bHQgPSBhdmNkYXRhLnNoaWZ0KCkgKyAnLic7XG4gICAgcmVzdWx0ICs9IHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSBhcyBzdHJpbmcpLnRvU3RyaW5nKDE2KTtcbiAgICByZXN1bHQgKz0gKCcwMDAnICsgcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpIGFzIHN0cmluZykudG9TdHJpbmcoMTYpKS5zbGljZShcbiAgICAgIC00LFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gY29kZWM7XG59XG4iLCJpbXBvcnQgeyBidWlsZEFic29sdXRlVVJMIH0gZnJvbSAndXJsLXRvb2xraXQnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlLXJhbmdlJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHsgTGV2ZWxLZXkgfSBmcm9tICcuL2xldmVsLWtleSc7XG5pbXBvcnQgeyBBdHRyTGlzdCB9IGZyb20gJy4uL3V0aWxzL2F0dHItbGlzdCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtcbiAgYWRkVmFyaWFibGVEZWZpbml0aW9uLFxuICBoYXNWYXJpYWJsZVJlZmVyZW5jZXMsXG4gIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbixcbiAgc3Vic3RpdHV0ZVZhcmlhYmxlcyxcbiAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyxcbn0gZnJvbSAnLi4vdXRpbHMvdmFyaWFibGUtc3Vic3RpdHV0aW9uJztcbmltcG9ydCB7IGlzQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB0eXBlIHsgQ29kZWNUeXBlIH0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFQbGF5bGlzdCwgTWVkaWFBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsQXR0cmlidXRlcywgTGV2ZWxQYXJzZWQsIFZhcmlhYmxlTWFwIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBDb250ZW50U3RlZXJpbmdPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcblxudHlwZSBNM1U4UGFyc2VyRnJhZ21lbnRzID0gQXJyYXk8RnJhZ21lbnQgfCBudWxsPjtcblxuZXhwb3J0IHR5cGUgUGFyc2VkTXVsdGl2YXJpYW50UGxheWxpc3QgPSB7XG4gIGNvbnRlbnRTdGVlcmluZzogQ29udGVudFN0ZWVyaW5nT3B0aW9ucyB8IG51bGw7XG4gIGxldmVsczogTGV2ZWxQYXJzZWRbXTtcbiAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IEVycm9yIHwgbnVsbDtcbiAgc2Vzc2lvbkRhdGE6IFJlY29yZDxzdHJpbmcsIEF0dHJMaXN0PiB8IG51bGw7XG4gIHNlc3Npb25LZXlzOiBMZXZlbEtleVtdIHwgbnVsbDtcbiAgc3RhcnRUaW1lT2Zmc2V0OiBudW1iZXIgfCBudWxsO1xuICB2YXJpYWJsZUxpc3Q6IFZhcmlhYmxlTWFwIHwgbnVsbDtcbiAgaGFzVmFyaWFibGVSZWZzOiBib29sZWFuO1xufTtcblxudHlwZSBQYXJzZWRNdWx0aXZhcmlhbnRNZWRpYU9wdGlvbnMgPSB7XG4gIEFVRElPPzogTWVkaWFQbGF5bGlzdFtdO1xuICBTVUJUSVRMRVM/OiBNZWRpYVBsYXlsaXN0W107XG4gICdDTE9TRUQtQ0FQVElPTlMnPzogTWVkaWFQbGF5bGlzdFtdO1xufTtcblxuY29uc3QgTUFTVEVSX1BMQVlMSVNUX1JFR0VYID1cbiAgLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC0oU0VTU0lPTi1EQVRBfFNFU1NJT04tS0VZfERFRklORXxDT05URU5ULVNURUVSSU5HfFNUQVJUKTooW15cXHJcXG5dKilbXFxyXFxuXSsvZztcbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWCA9IC8jRVhULVgtTUVESUE6KC4qKS9nO1xuXG5jb25zdCBJU19NRURJQV9QTEFZTElTVCA9IC9eI0VYVCg/OklORnwtWC1UQVJHRVREVVJBVElPTik6L207IC8vIEhhbmRsZSBlbXB0eSBNZWRpYSBQbGF5bGlzdCAoZmlyc3QgRVhUSU5GIG5vdCBzaWduYWxlZCwgYnV0IFRBUkdFVERVUkFUSU9OIHByZXNlbnQpXG5cbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QgPSBuZXcgUmVnRXhwKFxuICBbXG4gICAgLyNFWFRJTkY6XFxzKihcXGQqKD86XFwuXFxkKyk/KSg/OiwoLiopXFxzKyk/Ly5zb3VyY2UsIC8vIGR1cmF0aW9uICgjRVhUSU5GOjxkdXJhdGlvbj4sPHRpdGxlPiksIGdyb3VwIDEgPT4gZHVyYXRpb24sIGdyb3VwIDIgPT4gdGl0bGVcbiAgICAvKD8hIykgKihcXFNbXFxTIF0qKS8uc291cmNlLCAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAgIC8jRVhULVgtQllURVJBTkdFOiooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIGJ5dGVyYW5nZSwgZ3JvdXAgNCA9PiByYW5nZSBzcGVjICh4QHkpXG4gICAgLyNFWFQtWC1QUk9HUkFNLURBVEUtVElNRTooLispLy5zb3VyY2UsIC8vIG5leHQgc2VnbWVudCdzIHByb2dyYW0gZGF0ZS90aW1lIGdyb3VwIDUgPT4gdGhlIGRhdGV0aW1lIHNwZWNcbiAgICAvIy4qLy5zb3VyY2UsIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG4gIF0uam9pbignfCcpLFxuICAnZycsXG4pO1xuXG5jb25zdCBMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XID0gbmV3IFJlZ0V4cChcbiAgW1xuICAgIC8jKEVYVE0zVSkvLnNvdXJjZSxcbiAgICAvI0VYVC1YLShEQVRFUkFOR0V8REVGSU5FfEtFWXxNQVB8UEFSVHxQQVJULUlORnxQTEFZTElTVC1UWVBFfFBSRUxPQUQtSElOVHxSRU5ESVRJT04tUkVQT1JUfFNFUlZFUi1DT05UUk9MfFNLSVB8U1RBUlQpOiguKykvXG4gICAgICAuc291cmNlLFxuICAgIC8jRVhULVgtKEJJVFJBVEV8RElTQ09OVElOVUlUWS1TRVFVRU5DRXxNRURJQS1TRVFVRU5DRXxUQVJHRVREVVJBVElPTnxWRVJTSU9OKTogKihcXGQrKS9cbiAgICAgIC5zb3VyY2UsXG4gICAgLyNFWFQtWC0oRElTQ09OVElOVUlUWXxFTkRMSVNUfEdBUHxJTkRFUEVOREVOVC1TRUdNRU5UUykvLnNvdXJjZSxcbiAgICAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsXG4gICAgLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlLFxuICBdLmpvaW4oJ3wnKSxcbik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE0zVThQYXJzZXIge1xuICBzdGF0aWMgZmluZEdyb3VwKFxuICAgIGdyb3VwczogKFxuICAgICAgfCB7IGlkPzogc3RyaW5nOyBhdWRpb0NvZGVjPzogc3RyaW5nIH1cbiAgICAgIHwgeyBpZD86IHN0cmluZzsgdGV4dENvZGVjPzogc3RyaW5nIH1cbiAgICApW10sXG4gICAgbWVkaWFHcm91cElkOiBzdHJpbmcsXG4gICk6XG4gICAgfCB7IGlkPzogc3RyaW5nOyBhdWRpb0NvZGVjPzogc3RyaW5nIH1cbiAgICB8IHsgaWQ/OiBzdHJpbmc7IHRleHRDb2RlYz86IHN0cmluZyB9XG4gICAgfCB1bmRlZmluZWQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZSh1cmwsIGJhc2VVcmwpIHtcbiAgICByZXR1cm4gYnVpbGRBYnNvbHV0ZVVSTChiYXNlVXJsLCB1cmwsIHsgYWx3YXlzTm9ybWFsaXplOiB0cnVlIH0pO1xuICB9XG5cbiAgc3RhdGljIGlzTWVkaWFQbGF5bGlzdChzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBJU19NRURJQV9QTEFZTElTVC50ZXN0KHN0cik7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdChcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBiYXNldXJsOiBzdHJpbmcsXG4gICk6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0IHtcbiAgICBjb25zdCBoYXNWYXJpYWJsZVJlZnMgPSBfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fX1xuICAgICAgPyBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKVxuICAgICAgOiBmYWxzZTtcbiAgICBjb25zdCBwYXJzZWQ6IFBhcnNlZE11bHRpdmFyaWFudFBsYXlsaXN0ID0ge1xuICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgbGV2ZWxzOiBbXSxcbiAgICAgIHBsYXlsaXN0UGFyc2luZ0Vycm9yOiBudWxsLFxuICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgIHZhcmlhYmxlTGlzdDogbnVsbCxcbiAgICAgIGhhc1ZhcmlhYmxlUmVmcyxcbiAgICB9O1xuICAgIGNvbnN0IGxldmVsc1dpdGhLbm93bkNvZGVjczogTGV2ZWxQYXJzZWRbXSA9IFtdO1xuXG4gICAgTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG5cbiAgICBsZXQgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsO1xuICAgIHdoaWxlICgocmVzdWx0ID0gTUFTVEVSX1BMQVlMSVNUX1JFR0VYLmV4ZWMoc3RyaW5nKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKHJlc3VsdFsxXSkge1xuICAgICAgICAvLyAnI0VYVC1YLVNUUkVBTS1JTkYnIGlzIGZvdW5kLCBwYXJzZSBsZXZlbCB0YWcgIGluIGdyb3VwIDFcbiAgICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKSBhcyBMZXZlbEF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBhdHRycywgW1xuICAgICAgICAgICAgJ0NPREVDUycsXG4gICAgICAgICAgICAnU1VQUExFTUVOVEFMLUNPREVDUycsXG4gICAgICAgICAgICAnQUxMT1dFRC1DUEMnLFxuICAgICAgICAgICAgJ1BBVEhXQVktSUQnLFxuICAgICAgICAgICAgJ1NUQUJMRS1WQVJJQU5ULUlEJyxcbiAgICAgICAgICAgICdBVURJTycsXG4gICAgICAgICAgICAnVklERU8nLFxuICAgICAgICAgICAgJ1NVQlRJVExFUycsXG4gICAgICAgICAgICAnQ0xPU0VELUNBUFRJT05TJyxcbiAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fX1xuICAgICAgICAgID8gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHJlc3VsdFsyXSlcbiAgICAgICAgICA6IHJlc3VsdFsyXTtcbiAgICAgICAgY29uc3QgbGV2ZWw6IExldmVsUGFyc2VkID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6XG4gICAgICAgICAgICBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJykgfHxcbiAgICAgICAgICAgIGF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpLFxuICAgICAgICAgIG5hbWU6IGF0dHJzLk5BTUUsXG4gICAgICAgICAgdXJsOiBNM1U4UGFyc2VyLnJlc29sdmUodXJpLCBiYXNldXJsKSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gYXR0cnMuZGVjaW1hbFJlc29sdXRpb24oJ1JFU09MVVRJT04nKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICBsZXZlbC53aWR0aCA9IHJlc29sdXRpb24ud2lkdGg7XG4gICAgICAgICAgbGV2ZWwuaGVpZ2h0ID0gcmVzb2x1dGlvbi5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDb2RlY3MoYXR0cnMuQ09ERUNTLCBsZXZlbCk7XG5cbiAgICAgICAgaWYgKCFsZXZlbC51bmtub3duQ29kZWNzPy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXZlbHNXaXRoS25vd25Db2RlY3MucHVzaChsZXZlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWQubGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgY29uc3QgdGFnID0gcmVzdWx0WzNdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzdWx0WzRdO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ1NFU1NJT04tREFUQSc6IHtcbiAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLURBVEFcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25BdHRycyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgc2Vzc2lvbkF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ0RBVEEtSUQnLFxuICAgICAgICAgICAgICAgICdMQU5HVUFHRScsXG4gICAgICAgICAgICAgICAgJ1ZBTFVFJyxcbiAgICAgICAgICAgICAgICAnVVJJJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhSWQgPSBzZXNzaW9uQXR0cnNbJ0RBVEEtSUQnXTtcbiAgICAgICAgICAgIGlmIChkYXRhSWQpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YVtkYXRhSWRdID0gc2Vzc2lvbkF0dHJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1NFU1NJT04tS0VZJzoge1xuICAgICAgICAgICAgLy8gI0VYVC1YLVNFU1NJT04tS0VZXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uS2V5ID0gcGFyc2VLZXkoYXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKTtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uS2V5LmVuY3J5cHRlZCAmJiBzZXNzaW9uS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZC5zZXNzaW9uS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cy5wdXNoKHNlc3Npb25LZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICAgYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLVNFU1NJT04tS0VZIHRhZzogXCIke2F0dHJpYnV0ZXN9XCJgLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6IHtcbiAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFtcbiAgICAgICAgICAgICAgICAnTkFNRScsXG4gICAgICAgICAgICAgICAgJ1ZBTFVFJyxcbiAgICAgICAgICAgICAgICAnUVVFUllQQVJBTScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0NPTlRFTlQtU1RFRVJJTkcnOiB7XG4gICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgY29uc3QgY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHBhcnNlZCxcbiAgICAgICAgICAgICAgICBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFsnU0VSVkVSLVVSSScsICdQQVRIV0FZLUlEJ10sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWQuY29udGVudFN0ZWVyaW5nID0ge1xuICAgICAgICAgICAgICB1cmk6IE0zVThQYXJzZXIucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydTRVJWRVItVVJJJ10sXG4gICAgICAgICAgICAgICAgYmFzZXVybCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgcGF0aHdheUlkOiBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10gfHwgJy4nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6IHtcbiAgICAgICAgICAgIC8vICNFWFQtWC1TVEFSVFxuICAgICAgICAgICAgcGFyc2VkLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaWx0ZXIgb3V0IGxldmVscyB3aXRoIHVua25vd24gY29kZWNzIGlmIGl0IGRvZXMgbm90IHJlbW92ZSBhbGwgbGV2ZWxzXG4gICAgY29uc3Qgc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPVxuICAgICAgbGV2ZWxzV2l0aEtub3duQ29kZWNzLmxlbmd0aCA+IDAgJiZcbiAgICAgIGxldmVsc1dpdGhLbm93bkNvZGVjcy5sZW5ndGggPCBwYXJzZWQubGV2ZWxzLmxlbmd0aDtcblxuICAgIHBhcnNlZC5sZXZlbHMgPSBzdHJpcFVua25vd25Db2RlY0xldmVsc1xuICAgICAgPyBsZXZlbHNXaXRoS25vd25Db2RlY3NcbiAgICAgIDogcGFyc2VkLmxldmVscztcbiAgICBpZiAocGFyc2VkLmxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignbm8gbGV2ZWxzIGZvdW5kIGluIG1hbmlmZXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgYmFzZXVybDogc3RyaW5nLFxuICAgIHBhcnNlZDogUGFyc2VkTXVsdGl2YXJpYW50UGxheWxpc3QsXG4gICk6IFBhcnNlZE11bHRpdmFyaWFudE1lZGlhT3B0aW9ucyB7XG4gICAgbGV0IHJlc3VsdDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbDtcbiAgICBjb25zdCByZXN1bHRzOiBQYXJzZWRNdWx0aXZhcmlhbnRNZWRpYU9wdGlvbnMgPSB7fTtcbiAgICBjb25zdCBsZXZlbHMgPSBwYXJzZWQubGV2ZWxzO1xuICAgIGNvbnN0IGdyb3Vwc0J5VHlwZSA9IHtcbiAgICAgIEFVRElPOiBsZXZlbHMubWFwKChsZXZlbDogTGV2ZWxQYXJzZWQpID0+ICh7XG4gICAgICAgIGlkOiBsZXZlbC5hdHRycy5BVURJTyxcbiAgICAgICAgYXVkaW9Db2RlYzogbGV2ZWwuYXVkaW9Db2RlYyxcbiAgICAgIH0pKSxcbiAgICAgIFNVQlRJVExFUzogbGV2ZWxzLm1hcCgobGV2ZWw6IExldmVsUGFyc2VkKSA9PiAoe1xuICAgICAgICBpZDogbGV2ZWwuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGxldmVsLnRleHRDb2RlYyxcbiAgICAgIH0pKSxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXSxcbiAgICB9O1xuICAgIGxldCBpZCA9IDA7XG4gICAgTUFTVEVSX1BMQVlMSVNUX01FRElBX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVguZXhlYyhzdHJpbmcpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYXR0cnMgPSBuZXcgQXR0ckxpc3QocmVzdWx0WzFdKSBhcyBNZWRpYUF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCB0eXBlID0gYXR0cnMuVFlQRTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwczogKHR5cGVvZiBncm91cHNCeVR5cGUpW2tleW9mIHR5cGVvZiBncm91cHNCeVR5cGVdID1cbiAgICAgICAgICBncm91cHNCeVR5cGVbdHlwZV07XG4gICAgICAgIGNvbnN0IG1lZGlhczogTWVkaWFQbGF5bGlzdFtdID0gcmVzdWx0c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgcmVzdWx0c1t0eXBlXSA9IG1lZGlhcztcbiAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHJzLCBbXG4gICAgICAgICAgICAnVVJJJyxcbiAgICAgICAgICAgICdHUk9VUC1JRCcsXG4gICAgICAgICAgICAnTEFOR1VBR0UnLFxuICAgICAgICAgICAgJ0FTU09DLUxBTkdVQUdFJyxcbiAgICAgICAgICAgICdTVEFCTEUtUkVORElUSU9OLUlEJyxcbiAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICAgICdJTlNUUkVBTS1JRCcsXG4gICAgICAgICAgICAnQ0hBUkFDVEVSSVNUSUNTJyxcbiAgICAgICAgICAgICdDSEFOTkVMUycsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICBjb25zdCBhc3NvY0xhbmcgPSBhdHRyc1snQVNTT0MtTEFOR1VBR0UnXTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBhdHRycy5DSEFOTkVMUztcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gYXR0cnMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgIGNvbnN0IG1lZGlhOiBNZWRpYVBsYXlsaXN0ID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSB8fCBsYW5nIHx8ICcnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGF0dHJzLmJvb2woJ0FVVE9TRUxFQ1QnKSxcbiAgICAgICAgICBmb3JjZWQ6IGF0dHJzLmJvb2woJ0ZPUkNFRCcpLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXNzb2NMYW5nKSB7XG4gICAgICAgICAgbWVkaWEuYXNzb2NMYW5nID0gYXNzb2NMYW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVscykge1xuICAgICAgICAgIG1lZGlhLmNoYW5uZWxzID0gY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlcmlzdGljcykge1xuICAgICAgICAgIG1lZGlhLmNoYXJhY3RlcmlzdGljcyA9IGNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdHJlYW1JZCkge1xuICAgICAgICAgIG1lZGlhLmluc3RyZWFtSWQgPSBpbnN0cmVhbUlkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyb3Vwcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGF1ZGlvIG9yIHRleHQgZ3JvdXBzIHNpZ25hbGxlZCBpbiB0aGUgbWFuaWZlc3QsIGxldCdzIGxvb2sgZm9yIGEgbWF0Y2hpbmcgY29kZWMgc3RyaW5nIGZvciB0aGlzIHRyYWNrXG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZmluZCB0aGUgdHJhY2sgc2lnbmFsbGVkLCBsZXRzIHVzZSB0aGUgZmlyc3QgYXVkaW8gZ3JvdXBzIGNvZGVjIHdlIGhhdmVcbiAgICAgICAgICAvLyBBY3RpbmcgYXMgYSBiZXN0IGd1ZXNzXG4gICAgICAgICAgY29uc3QgZ3JvdXBDb2RlYyA9XG4gICAgICAgICAgICBNM1U4UGFyc2VyLmZpbmRHcm91cChncm91cHMsIG1lZGlhLmdyb3VwSWQgYXMgc3RyaW5nKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICdhdWRpb0NvZGVjJyk7XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICd0ZXh0Q29kZWMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lZGlhcy5wdXNoKG1lZGlhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VMZXZlbFBsYXlsaXN0KFxuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIGJhc2V1cmw6IHN0cmluZyxcbiAgICBpZDogbnVtYmVyLFxuICAgIHR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIGxldmVsVXJsSWQ6IG51bWJlcixcbiAgICBtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3Q6IFZhcmlhYmxlTWFwIHwgbnVsbCxcbiAgKTogTGV2ZWxEZXRhaWxzIHtcbiAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbERldGFpbHMoYmFzZXVybCk7XG4gICAgY29uc3QgZnJhZ21lbnRzOiBNM1U4UGFyc2VyRnJhZ21lbnRzID0gbGV2ZWwuZnJhZ21lbnRzO1xuICAgIC8vIFRoZSBtb3N0IHJlY2VudCBpbml0IHNlZ21lbnQgc2VlbiAoYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBzZWdtZW50cylcbiAgICBsZXQgY3VycmVudEluaXRTZWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBjdXJyZW50U04gPSAwO1xuICAgIGxldCBjdXJyZW50UGFydCA9IDA7XG4gICAgbGV0IHRvdGFsZHVyYXRpb24gPSAwO1xuICAgIGxldCBkaXNjb250aW51aXR5Q291bnRlciA9IDA7XG4gICAgbGV0IHByZXZGcmFnOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCBmcmFnOiBGcmFnbWVudCA9IG5ldyBGcmFnbWVudCh0eXBlLCBiYXNldXJsKTtcbiAgICBsZXQgcmVzdWx0OiBSZWdFeHBFeGVjQXJyYXkgfCBSZWdFeHBNYXRjaEFycmF5IHwgbnVsbDtcbiAgICBsZXQgaTogbnVtYmVyO1xuICAgIGxldCBsZXZlbGtleXM6IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIGxldCBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgIGxldCBuZXh0Qnl0ZVJhbmdlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgIExFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QubGFzdEluZGV4ID0gMDtcbiAgICBsZXZlbC5tM3U4ID0gc3RyaW5nO1xuICAgIGxldmVsLmhhc1ZhcmlhYmxlUmVmcyA9IF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fXG4gICAgICA/IGhhc1ZhcmlhYmxlUmVmZXJlbmNlcyhzdHJpbmcpXG4gICAgICA6IGZhbHNlO1xuXG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChjcmVhdGVOZXh0RnJhZykge1xuICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG4gICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICAgIGlmIChuZXh0Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShuZXh0Qnl0ZVJhbmdlKTtcbiAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHJlc3VsdFsxXTtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAvLyBJTkZcbiAgICAgICAgZnJhZy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb24pO1xuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKCcgJyArIHJlc3VsdFsyXSkuc2xpY2UoMSk7XG4gICAgICAgIGZyYWcudGl0bGUgPSB0aXRsZSB8fCBudWxsO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaCh0aXRsZSA/IFsnSU5GJywgZHVyYXRpb24sIHRpdGxlXSA6IFsnSU5GJywgZHVyYXRpb25dKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WzNdKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICBjb25zdCB1cmkgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnJlbHVybCA9IF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fXG4gICAgICAgICAgICA/IHN1YnN0aXR1dGVWYXJpYWJsZXMobGV2ZWwsIHVyaSlcbiAgICAgICAgICAgIDogdXJpO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICBjdXJyZW50UGFydCA9IDA7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs0XSkge1xuICAgICAgICAvLyBYLUJZVEVSQU5HRVxuICAgICAgICBjb25zdCBkYXRhID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEsIHByZXZGcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHtcbiAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcbiAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZmlyc3RQZHRJbmRleCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHJlc3VsdFtpICsgMl0gPyAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSkgOiAnJztcblxuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ1BMQVlMSVNULVRZUEUnOlxuICAgICAgICAgICAgbGV2ZWwudHlwZSA9IHZhbHVlMS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUVESUEtU0VRVUVOQ0UnOlxuICAgICAgICAgICAgY3VycmVudFNOID0gbGV2ZWwuc3RhcnRTTiA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdTS0lQJzoge1xuICAgICAgICAgICAgY29uc3Qgc2tpcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgc2tpcEF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUycsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID1cbiAgICAgICAgICAgICAgc2tpcEF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdTS0lQUEVELVNFR01FTlRTJyk7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHNraXBwZWRTZWdtZW50cykpIHtcbiAgICAgICAgICAgICAgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzID0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVzdWx0IGluIGZyYWdtZW50c1tdIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHZhbHVlcywgd2hpY2ggd2Ugd2lsbCBmaWxsIGluIHdpdGggYG1lcmdlRGV0YWlsc2BcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNraXBwZWRTZWdtZW50czsgaS0tOyApIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudHMudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50U04gKz0gc2tpcHBlZFNlZ21lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHNraXBBdHRycy5lbnVtZXJhdGVkU3RyaW5nKFxuICAgICAgICAgICAgICAnUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICBsZXZlbC5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID1cbiAgICAgICAgICAgICAgICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHZhbHVlMSksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0lOREVQRU5ERU5ULVNFR01FTlRTJzpcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzoge1xuICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlQXR0ciA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgaWYgKF9fVVNFX1ZBUklBQkxFX1NVQlNUSVRVVElPTl9fKSB7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIGRhdGVSYW5nZUF0dHIsIFtcbiAgICAgICAgICAgICAgICAnSUQnLFxuICAgICAgICAgICAgICAgICdDTEFTUycsXG4gICAgICAgICAgICAgICAgJ1NUQVJULURBVEUnLFxuICAgICAgICAgICAgICAgICdFTkQtREFURScsXG4gICAgICAgICAgICAgICAgJ1NDVEUzNS1DTUQnLFxuICAgICAgICAgICAgICAgICdTQ1RFMzUtT1VUJyxcbiAgICAgICAgICAgICAgICAnU0NURTM1LUlOJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgZGF0ZVJhbmdlQXR0cixcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2VBdHRyLmNsaWVudEF0dHJzLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShcbiAgICAgICAgICAgICAgZGF0ZVJhbmdlQXR0cixcbiAgICAgICAgICAgICAgbGV2ZWwuZGF0ZVJhbmdlc1tkYXRlUmFuZ2VBdHRyLklEXSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmlzVmFsaWQgfHwgbGV2ZWwuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlLmlkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBJZ25vcmluZyBpbnZhbGlkIERBVEVSQU5HRSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0byBmcmFnbWVudCB0YWcgbGlzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKDwgdjEuMi4wKVxuICAgICAgICAgICAgZnJhZy50YWdMaXN0LnB1c2goWydFWFQtWC1EQVRFUkFOR0UnLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdERUZJTkUnOiB7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFyaWFibGVBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgW1xuICAgICAgICAgICAgICAgICdOQU1FJyxcbiAgICAgICAgICAgICAgICAnVkFMVUUnLFxuICAgICAgICAgICAgICAgICdJTVBPUlQnLFxuICAgICAgICAgICAgICAgICdRVUVSWVBBUkFNJyxcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIGlmICgnSU1QT1JUJyBpbiB2YXJpYWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICAgIHZhcmlhYmxlQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIG11bHRpdmFyaWFudFZhcmlhYmxlTGlzdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFZhcmlhYmxlRGVmaW5pdGlvbihsZXZlbCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBiYXNldXJsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnRElTQ09OVElOVUlUWS1TRVFVRU5DRSc6XG4gICAgICAgICAgICBkaXNjb250aW51aXR5Q291bnRlciA9IHBhcnNlSW50KHZhbHVlMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdLRVknOiB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbEtleSA9IHBhcnNlS2V5KHZhbHVlMSwgYmFzZXVybCwgbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsS2V5LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsS2V5Lm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghbGV2ZWxrZXlzKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0ge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxldmVsa2V5c1tsZXZlbEtleS5rZXlGb3JtYXRdKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxrZXlzID0gT2JqZWN0LmFzc2lnbih7fSwgbGV2ZWxrZXlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSA9IGxldmVsS2V5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFtLZXlzXSBJZ25vcmluZyBpbnZhbGlkIEVYVC1YLUtFWSB0YWc6IFwiJHt2YWx1ZTF9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTVEFSVCc6XG4gICAgICAgICAgICBsZXZlbC5zdGFydFRpbWVPZmZzZXQgPSBwYXJzZVN0YXJ0VGltZU9mZnNldCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTUFQJzoge1xuICAgICAgICAgICAgY29uc3QgbWFwQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBtYXBBdHRycywgW1xuICAgICAgICAgICAgICAgICdCWVRFUkFOR0UnLFxuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIEluaXRpYWwgc2VnbWVudCB0YWcgaXMgYWZ0ZXIgc2VnbWVudCBkdXJhdGlvbiB0YWcuXG4gICAgICAgICAgICAgIC8vICAgI0VYVElORjogNi4wXG4gICAgICAgICAgICAgIC8vICAgI0VYVC1YLU1BUDpVUkk9XCJpbml0Lm1wNFxuICAgICAgICAgICAgICBjb25zdCBpbml0ID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChpbml0LCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lICYmXG4gICAgICAgICAgICAgICAgIWZyYWcucmF3UHJvZ3JhbURhdGVUaW1lXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgRVhULVgtTUFQIGlzIGRlY2xhcmVkIGFmdGVyIEVYVC1YLUJZVEVSQU5HRVxuICAgICAgICAgICAgICBjb25zdCBlbmQgPSBmcmFnLmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnJhZy5ieXRlUmFuZ2VTdGFydE9mZnNldCBhcyBudW1iZXI7XG4gICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IGAke2VuZCAtIHN0YXJ0fUAke3N0YXJ0fWA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBmcmFnO1xuICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOiB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGxldmVsLmNhbkJsb2NrUmVsb2FkID0gc2VydmVyQ29udHJvbEF0dHJzLmJvb2woJ0NBTi1CTE9DSy1SRUxPQUQnKTtcbiAgICAgICAgICAgIGxldmVsLmNhblNraXBVbnRpbCA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KFxuICAgICAgICAgICAgICAnQ0FOLVNLSVAtVU5USUwnLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldmVsLmNhblNraXBEYXRlUmFuZ2VzID1cbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcFVudGlsID4gMCAmJlxuICAgICAgICAgICAgICBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLVNLSVAtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgbGV2ZWwucGFydEhvbGRCYWNrID0gc2VydmVyQ29udHJvbEF0dHJzLm9wdGlvbmFsRmxvYXQoXG4gICAgICAgICAgICAgICdQQVJULUhPTEQtQkFDSycsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGV2ZWwuaG9sZEJhY2sgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnSE9MRC1CQUNLJywgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVC1JTkYnOiB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGxldmVsLnBhcnRUYXJnZXQgPSBwYXJ0SW5mQXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1BBUlQtVEFSR0VUJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVCc6IHtcbiAgICAgICAgICAgIGxldCBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgaWYgKCFwYXJ0TGlzdCkge1xuICAgICAgICAgICAgICBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZyYWdtZW50UGFydCA9XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJ0ID4gMCA/IHBhcnRMaXN0W3BhcnRMaXN0Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjdXJyZW50UGFydCsrO1xuICAgICAgICAgICAgY29uc3QgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgcGFydEF0dHJzLCBbXG4gICAgICAgICAgICAgICAgJ0JZVEVSQU5HRScsXG4gICAgICAgICAgICAgICAgJ1VSSScsXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydCA9IG5ldyBQYXJ0KFxuICAgICAgICAgICAgICBwYXJ0QXR0cnMsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGJhc2V1cmwsXG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBwcmV2aW91c0ZyYWdtZW50UGFydCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgZnJhZy5kdXJhdGlvbiArPSBwYXJ0LmR1cmF0aW9uO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwcmVsb2FkSGludEF0dHJzLCBbJ1VSSSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdSRU5ESVRJT04tUkVQT1JUJzoge1xuICAgICAgICAgICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgIGlmIChfX1VTRV9WQVJJQUJMRV9TVUJTVElUVVRJT05fXykge1xuICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCByZW5kaXRpb25SZXBvcnRBdHRycywgW1xuICAgICAgICAgICAgICAgICdVUkknLFxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMgPSBsZXZlbC5yZW5kaXRpb25SZXBvcnRzIHx8IFtdO1xuICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cy5wdXNoKHJlbmRpdGlvblJlcG9ydEF0dHJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYGxpbmUgcGFyc2VkIGJ1dCBub3QgaGFuZGxlZDogJHtyZXN1bHR9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldkZyYWcgJiYgIXByZXZGcmFnLnJlbHVybCkge1xuICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgdG90YWxkdXJhdGlvbiAtPSBwcmV2RnJhZy5kdXJhdGlvbjtcbiAgICAgIGlmIChsZXZlbC5wYXJ0TGlzdCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBwcmV2RnJhZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpO1xuICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgbGV2ZWwuZnJhZ21lbnRIaW50ID0gZnJhZztcbiAgICAgIGlmIChsZXZlbGtleXMpIHtcbiAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRMZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0RnJhZ21lbnQgPSBmcmFnbWVudHNbMF07XG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZnJhZ21lbnRzW2ZyYWdtZW50TGVuZ3RoIC0gMV07XG4gICAgdG90YWxkdXJhdGlvbiArPSBsZXZlbC5za2lwcGVkU2VnbWVudHMgKiBsZXZlbC50YXJnZXRkdXJhdGlvbjtcbiAgICBpZiAodG90YWxkdXJhdGlvbiA+IDAgJiYgZnJhZ21lbnRMZW5ndGggJiYgbGFzdEZyYWdtZW50KSB7XG4gICAgICBsZXZlbC5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB0b3RhbGR1cmF0aW9uIC8gZnJhZ21lbnRMZW5ndGg7XG4gICAgICBjb25zdCBsYXN0U24gPSBsYXN0RnJhZ21lbnQuc247XG4gICAgICBsZXZlbC5lbmRTTiA9IGxhc3RTbiAhPT0gJ2luaXRTZWdtZW50JyA/IGxhc3RTbiA6IDA7XG4gICAgICBpZiAoIWxldmVsLmxpdmUpIHtcbiAgICAgICAgbGFzdEZyYWdtZW50LmVuZExpc3QgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0RnJhZ21lbnQpIHtcbiAgICAgICAgbGV2ZWwuc3RhcnRDQyA9IGZpcnN0RnJhZ21lbnQuY2M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldmVsLmVuZFNOID0gMDtcbiAgICAgIGxldmVsLnN0YXJ0Q0MgPSAwO1xuICAgIH1cbiAgICBpZiAobGV2ZWwuZnJhZ21lbnRIaW50KSB7XG4gICAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLmZyYWdtZW50SGludC5kdXJhdGlvbjtcbiAgICB9XG4gICAgbGV2ZWwudG90YWxkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb247XG4gICAgbGV2ZWwuZW5kQ0MgPSBkaXNjb250aW51aXR5Q291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIEJhY2tmaWxsIGFueSBtaXNzaW5nIFBEVCB2YWx1ZXNcbiAgICAgKiBcIklmIHRoZSBmaXJzdCBFWFQtWC1QUk9HUkFNLURBVEUtVElNRSB0YWcgaW4gYSBQbGF5bGlzdCBhcHBlYXJzIGFmdGVyXG4gICAgICogb25lIG9yIG1vcmUgTWVkaWEgU2VnbWVudCBVUklzLCB0aGUgY2xpZW50IFNIT1VMRCBleHRyYXBvbGF0ZVxuICAgICAqIGJhY2t3YXJkIGZyb20gdGhhdCB0YWcgKHVzaW5nIEVYVElORiBkdXJhdGlvbnMgYW5kL29yIG1lZGlhXG4gICAgICogdGltZXN0YW1wcykgdG8gYXNzb2NpYXRlIGRhdGVzIHdpdGggdGhvc2Ugc2VnbWVudHMuXCJcbiAgICAgKiBXZSBoYXZlIGFscmVhZHkgZXh0cmFwb2xhdGVkIGZvcndhcmQsIGJ1dCBhbGwgZnJhZ21lbnRzIHVwIHRvIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBQRFQgZG8gbm90IGhhdmUgdGhlaXIgUERUc1xuICAgICAqIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIGlmIChmaXJzdFBkdEluZGV4ID4gMCkge1xuICAgICAgYmFja2ZpbGxQcm9ncmFtRGF0ZVRpbWVzKGZyYWdtZW50cywgZmlyc3RQZHRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5KFxuICBrZXlUYWdBdHRyaWJ1dGVzOiBzdHJpbmcsXG4gIGJhc2V1cmw6IHN0cmluZyxcbiAgcGFyc2VkOiBQYXJzZWRNdWx0aXZhcmlhbnRQbGF5bGlzdCB8IExldmVsRGV0YWlscyxcbik6IExldmVsS2V5IHtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzgyMTYjc2VjdGlvbi00LjMuMi40XG4gIGNvbnN0IGtleUF0dHJzID0gbmV3IEF0dHJMaXN0KGtleVRhZ0F0dHJpYnV0ZXMpO1xuICBpZiAoX19VU0VfVkFSSUFCTEVfU1VCU1RJVFVUSU9OX18pIHtcbiAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwga2V5QXR0cnMsIFtcbiAgICAgICdLRVlGT1JNQVQnLFxuICAgICAgJ0tFWUZPUk1BVFZFUlNJT05TJyxcbiAgICAgICdVUkknLFxuICAgICAgJ0lWJyxcbiAgICAgICdVUkknLFxuICAgIF0pO1xuICB9XG4gIGNvbnN0IGRlY3J5cHRtZXRob2QgPSBrZXlBdHRycy5NRVRIT0QgPz8gJyc7XG4gIGNvbnN0IGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gIGNvbnN0IGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuS0VZRk9STUFUVkVSU0lPTlM7XG4gIC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdCA9IGtleUF0dHJzLktFWUZPUk1BVCA/PyAnaWRlbnRpdHknO1xuXG4gIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgSVY6ICR7a2V5QXR0cnMuSVZ9YCk7XG4gIH1cbiAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gIC8vIE5vIHVyaSBpcyBhbGxvd2VkIHdoZW4gTUVUSE9EIGlzIE5PTkVcbiAgY29uc3QgcmVzb2x2ZWRVcmkgPSBkZWNyeXB0dXJpID8gTTNVOFBhcnNlci5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpIDogJyc7XG4gIGNvbnN0IGtleUZvcm1hdFZlcnNpb25zID0gKFxuICAgIGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA/IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA6ICcxJ1xuICApXG4gICAgLnNwbGl0KCcvJylcbiAgICAubWFwKE51bWJlcilcbiAgICAuZmlsdGVyKE51bWJlci5pc0Zpbml0ZSk7XG5cbiAgcmV0dXJuIG5ldyBMZXZlbEtleShcbiAgICBkZWNyeXB0bWV0aG9kLFxuICAgIHJlc29sdmVkVXJpLFxuICAgIGRlY3J5cHRrZXlmb3JtYXQsXG4gICAga2V5Rm9ybWF0VmVyc2lvbnMsXG4gICAgZGVjcnlwdGl2LFxuICApO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0YXJ0VGltZU9mZnNldChzdGFydEF0dHJpYnV0ZXM6IHN0cmluZyk6IG51bWJlciB8IG51bGwge1xuICBjb25zdCBzdGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHN0YXJ0QXR0cmlidXRlcyk7XG4gIGNvbnN0IHN0YXJ0VGltZU9mZnNldCA9IHN0YXJ0QXR0cnMuZGVjaW1hbEZsb2F0aW5nUG9pbnQoJ1RJTUUtT0ZGU0VUJyk7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldENvZGVjcyhcbiAgY29kZWNzQXR0cmlidXRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgbGV2ZWw6IExldmVsUGFyc2VkLFxuKSB7XG4gIGxldCBjb2RlY3MgPSAoY29kZWNzQXR0cmlidXRlVmFsdWUgfHwgJycpLnNwbGl0KC9bICxdKy8pLmZpbHRlcigoYykgPT4gYyk7XG4gIFsndmlkZW8nLCAnYXVkaW8nLCAndGV4dCddLmZvckVhY2goKHR5cGU6IENvZGVjVHlwZSkgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcigoY29kZWMpID0+IGlzQ29kZWNUeXBlKGNvZGVjLCB0eXBlKSk7XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCkge1xuICAgICAgLy8gQ29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgYWxsIGNvZGVjcyBmb3IgdHlwZVxuICAgICAgbGV2ZWxbYCR7dHlwZX1Db2RlY2BdID0gZmlsdGVyZWQuam9pbignLCcpO1xuICAgICAgLy8gUmVtb3ZlIGtub3duIGNvZGVjcyBzbyB0aGF0IG9ubHkgdW5rbm93bkNvZGVjcyBhcmUgbGVmdCBhZnRlciBpdGVyYXRpbmcgdGhyb3VnaCBlYWNoIHR5cGVcbiAgICAgIGNvZGVjcyA9IGNvZGVjcy5maWx0ZXIoKGNvZGVjKSA9PiBmaWx0ZXJlZC5pbmRleE9mKGNvZGVjKSA9PT0gLTEpO1xuICAgIH1cbiAgfSk7XG4gIGxldmVsLnVua25vd25Db2RlY3MgPSBjb2RlY3M7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKFxuICBtZWRpYTogTWVkaWFQbGF5bGlzdCxcbiAgZ3JvdXBJdGVtOiB7IGF1ZGlvQ29kZWM/OiBzdHJpbmc7IHRleHRDb2RlYz86IHN0cmluZyB9LFxuICBjb2RlY1Byb3BlcnR5OiAnYXVkaW9Db2RlYycgfCAndGV4dENvZGVjJyxcbikge1xuICBjb25zdCBjb2RlY1ZhbHVlID0gZ3JvdXBJdGVtW2NvZGVjUHJvcGVydHldO1xuICBpZiAoY29kZWNWYWx1ZSkge1xuICAgIG1lZGlhW2NvZGVjUHJvcGVydHldID0gY29kZWNWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoXG4gIGZyYWdtZW50czogTTNVOFBhcnNlckZyYWdtZW50cyxcbiAgZmlyc3RQZHRJbmRleDogbnVtYmVyLFxuKSB7XG4gIGxldCBmcmFnUHJldiA9IGZyYWdtZW50c1tmaXJzdFBkdEluZGV4XSBhcyBGcmFnbWVudDtcbiAgZm9yIChsZXQgaSA9IGZpcnN0UGR0SW5kZXg7IGktLTsgKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tpXTtcbiAgICAvLyBFeGl0IG9uIGRlbHRhLXBsYXlsaXN0IHNraXBwZWQgc2VnbWVudHNcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPVxuICAgICAgKGZyYWdQcmV2LnByb2dyYW1EYXRlVGltZSBhcyBudW1iZXIpIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZykge1xuICBpZiAoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IERhdGUucGFyc2UoZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICB9IGVsc2UgaWYgKHByZXZGcmFnPy5wcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICBmcmFnLnByb2dyYW1EYXRlVGltZSA9IHByZXZGcmFnLmVuZFByb2dyYW1EYXRlVGltZTtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoXG4gIGZyYWc6IEZyYWdtZW50LFxuICBtYXBBdHRyczogQXR0ckxpc3QsXG4gIGlkOiBudW1iZXIsXG4gIGxldmVsa2V5czogeyBba2V5OiBzdHJpbmddOiBMZXZlbEtleSB9IHwgdW5kZWZpbmVkLFxuKSB7XG4gIGZyYWcucmVsdXJsID0gbWFwQXR0cnMuVVJJO1xuICBpZiAobWFwQXR0cnMuQllURVJBTkdFKSB7XG4gICAgZnJhZy5zZXRCeXRlUmFuZ2UobWFwQXR0cnMuQllURVJBTkdFKTtcbiAgfVxuICBmcmFnLmxldmVsID0gaWQ7XG4gIGZyYWcuc24gPSAnaW5pdFNlZ21lbnQnO1xuICBpZiAobGV2ZWxrZXlzKSB7XG4gICAgZnJhZy5sZXZlbGtleXMgPSBsZXZlbGtleXM7XG4gIH1cbiAgZnJhZy5pbml0U2VnbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoXG4gIGZyYWc6IEZyYWdtZW50LFxuICBsZXZlbGtleXM6IHsgW2tleTogc3RyaW5nXTogTGV2ZWxLZXkgfSxcbiAgbGV2ZWw6IExldmVsRGV0YWlscyxcbikge1xuICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgY29uc3QgeyBlbmNyeXB0ZWRGcmFnbWVudHMgfSA9IGxldmVsO1xuICBpZiAoXG4gICAgKCFlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoIHx8XG4gICAgICBlbmNyeXB0ZWRGcmFnbWVudHNbZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT1cbiAgICAgICAgbGV2ZWxrZXlzKSAmJlxuICAgIE9iamVjdC5rZXlzKGxldmVsa2V5cykuc29tZShcbiAgICAgIChmb3JtYXQpID0+IGxldmVsa2V5cyFbZm9ybWF0XS5pc0NvbW1vbkVuY3J5cHRpb24sXG4gICAgKVxuICApIHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHMucHVzaChmcmFnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBMb2FkZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBLZXlMb2FkZXJJbmZvIH0gZnJvbSAnLi4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IEhsc1VybFBhcmFtZXRlcnMgfSBmcm9tICcuL2xldmVsJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXJDb250ZXh0IHtcbiAgLy8gdGFyZ2V0IFVSTFxuICB1cmw6IHN0cmluZztcbiAgLy8gbG9hZGVyIHJlc3BvbnNlIHR5cGUgKGFycmF5YnVmZmVyIG9yIGRlZmF1bHQgcmVzcG9uc2UgdHlwZSBmb3IgcGxheWxpc3QpXG4gIHJlc3BvbnNlVHlwZTogc3RyaW5nO1xuICAvLyBoZWFkZXJzXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAvLyBzdGFydCBieXRlIHJhbmdlIG9mZnNldFxuICByYW5nZVN0YXJ0PzogbnVtYmVyO1xuICAvLyBlbmQgYnl0ZSByYW5nZSBvZmZzZXRcbiAgcmFuZ2VFbmQ/OiBudW1iZXI7XG4gIC8vIHRydWUgaWYgb25Qcm9ncmVzcyBzaG91bGQgcmVwb3J0IHBhcnRpYWwgY2h1bmsgb2YgbG9hZGVkIGNvbnRlbnRcbiAgcHJvZ3Jlc3NEYXRhPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmFnbWVudExvYWRlckNvbnRleHQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0IHtcbiAgZnJhZzogRnJhZ21lbnQ7XG4gIHBhcnQ6IFBhcnQgfCBudWxsO1xuICByZXNldElWPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBLZXlMb2FkZXJDb250ZXh0IGV4dGVuZHMgTG9hZGVyQ29udGV4dCB7XG4gIGtleUluZm86IEtleUxvYWRlckluZm87XG4gIGZyYWc6IEZyYWdtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckNvbmZpZ3VyYXRpb24ge1xuICAvLyBMb2FkZXJDb25maWcgcG9saWN5IHRoYXQgb3ZlcnJpZGVzIHJlcXVpcmVkIHNldHRpbmdzXG4gIGxvYWRQb2xpY3k6IExvYWRlckNvbmZpZztcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBMb2FkZXJDb25maWcgdGltZW91dFJldHJ5IGFuZCBlcnJvclJldHJ5IG1heE51bVJldHJ5XG4gICAqL1xuICAvLyBNYXggbnVtYmVyIG9mIGxvYWQgcmV0cmllc1xuICBtYXhSZXRyeTogbnVtYmVyO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIExvYWRlckNvbmZpZyBtYXhUaW1lVG9GaXJzdEJ5dGVNcyBhbmQgbWF4TG9hZFRpbWVNc1xuICAgKi9cbiAgLy8gVGltZW91dCBhZnRlciB3aGljaCBgb25UaW1lT3V0YCBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZFxuICAvLyAgd2hlbiBsb2FkaW5nIGhhcyBub3QgZmluaXNoZWQgYWZ0ZXIgdGhhdCBkZWxheVxuICB0aW1lb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgTG9hZGVyQ29uZmlnIHRpbWVvdXRSZXRyeSBhbmQgZXJyb3JSZXRyeSByZXRyeURlbGF5TXNcbiAgICovXG4gIC8vIERlbGF5IGJldHdlZW4gYW4gSS9PIGVycm9yIGFuZCBmb2xsb3dpbmcgY29ubmVjdGlvbiByZXRyeSAobXMpLlxuICAvLyBUaGlzIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBzZXJ2ZXJcbiAgcmV0cnlEZWxheTogbnVtYmVyO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIExvYWRlckNvbmZpZyB0aW1lb3V0UmV0cnkgYW5kIGVycm9yUmV0cnkgbWF4UmV0cnlEZWxheU1zXG4gICAqL1xuICAvLyBtYXggY29ubmVjdGlvbiByZXRyeSBkZWxheSAobXMpXG4gIG1heFJldHJ5RGVsYXk6IG51bWJlcjtcbiAgLy8gV2hlbiBzdHJlYW1pbmcgcHJvZ3Jlc3NpdmVseSwgdGhpcyBpcyB0aGUgbWluaW11bSBjaHVuayBzaXplIHJlcXVpcmVkIHRvIGVtaXQgYSBQUk9HUkVTUyBldmVudFxuICBoaWdoV2F0ZXJNYXJrPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlclJlc3BvbnNlIHtcbiAgdXJsOiBzdHJpbmc7XG4gIGRhdGE/OiBzdHJpbmcgfCBBcnJheUJ1ZmZlciB8IE9iamVjdDtcbiAgLy8gRXJyb3JzIGNhbiBpbmNsdWRlIEhUVFAgc3RhdHVzIGNvZGUgYW5kIGVycm9yIG1lc3NhZ2VcbiAgLy8gU3VjY2Vzc2Z1bCByZXNwb25zZXMgc2hvdWxkIGluY2x1ZGUgc3RhdHVzIGNvZGUgMjAwXG4gIGNvZGU/OiBudW1iZXI7XG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVyU3RhdHMge1xuICBhYm9ydGVkOiBib29sZWFuO1xuICBsb2FkZWQ6IG51bWJlcjtcbiAgcmV0cnk6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbiAgY2h1bmtDb3VudDogbnVtYmVyO1xuICBid0VzdGltYXRlOiBudW1iZXI7XG4gIGxvYWRpbmc6IEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmc7XG4gIHBhcnNpbmc6IEhsc1BlcmZvcm1hbmNlVGltaW5nO1xuICBidWZmZXJpbmc6IEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGxzUGVyZm9ybWFuY2VUaW1pbmcge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nIGV4dGVuZHMgSGxzUGVyZm9ybWFuY2VUaW1pbmcge1xuICBleGVjdXRlU3RhcnQ6IG51bWJlcjtcbiAgZXhlY3V0ZUVuZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmcgZXh0ZW5kcyBIbHNQZXJmb3JtYW5jZVRpbWluZyB7XG4gIGZpcnN0OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExvYWRlck9uU3VjY2VzczxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4gPSAoXG4gIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55LFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2FkZXJPblByb2dyZXNzPFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBkYXRhOiBzdHJpbmcgfCBBcnJheUJ1ZmZlcixcbiAgbmV0d29ya0RldGFpbHM6IGFueSxcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgTG9hZGVyT25FcnJvcjxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4gPSAoXG4gIGVycm9yOiB7XG4gICAgLy8gZXJyb3Igc3RhdHVzIGNvZGVcbiAgICBjb2RlOiBudW1iZXI7XG4gICAgLy8gZXJyb3IgZGVzY3JpcHRpb25cbiAgICB0ZXh0OiBzdHJpbmc7XG4gIH0sXG4gIGNvbnRleHQ6IFQsXG4gIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gIHN0YXRzOiBMb2FkZXJTdGF0cyxcbikgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgTG9hZGVyT25UaW1lb3V0PFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55LFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBMb2FkZXJPbkFib3J0PFQgZXh0ZW5kcyBMb2FkZXJDb250ZXh0PiA9IChcbiAgc3RhdHM6IExvYWRlclN0YXRzLFxuICBjb250ZXh0OiBULFxuICBuZXR3b3JrRGV0YWlsczogYW55LFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvYWRlckNhbGxiYWNrczxUIGV4dGVuZHMgTG9hZGVyQ29udGV4dD4ge1xuICBvblN1Y2Nlc3M6IExvYWRlck9uU3VjY2VzczxUPjtcbiAgb25FcnJvcjogTG9hZGVyT25FcnJvcjxUPjtcbiAgb25UaW1lb3V0OiBMb2FkZXJPblRpbWVvdXQ8VD47XG4gIG9uQWJvcnQ/OiBMb2FkZXJPbkFib3J0PFQ+O1xuICBvblByb2dyZXNzPzogTG9hZGVyT25Qcm9ncmVzczxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZXI8VCBleHRlbmRzIExvYWRlckNvbnRleHQ+IHtcbiAgZGVzdHJveSgpOiB2b2lkO1xuICBhYm9ydCgpOiB2b2lkO1xuICBsb2FkKFxuICAgIGNvbnRleHQ6IFQsXG4gICAgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uLFxuICAgIGNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPFQ+LFxuICApOiB2b2lkO1xuICAvKipcbiAgICogYGdldENhY2hlQWdlKClgIGlzIGNhbGxlZCBieSBobHMuanMgdG8gZ2V0IHRoZSBkdXJhdGlvbiB0aGF0IGEgZ2l2ZW4gb2JqZWN0XG4gICAqIGhhcyBiZWVuIHNpdHRpbmcgaW4gYSBjYWNoZSBwcm94eSB3aGVuIHBsYXlpbmcgbGl2ZS4gIElmIGltcGxlbWVudGVkLFxuICAgKiB0aGlzIHNob3VsZCByZXR1cm4gYSB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBGb3IgSFRUUCBiYXNlZCBsb2FkZXJzLCB0aGlzIHNob3VsZCByZXR1cm4gdGhlIGNvbnRlbnRzIG9mIHRoZSBcImFnZVwiIGhlYWRlci5cbiAgICpcbiAgICogQHJldHVybnMgdGltZSBvYmplY3QgYmVpbmcgbG9kYWRlZFxuICAgKi9cbiAgZ2V0Q2FjaGVBZ2U/OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICBnZXRSZXNwb25zZUhlYWRlcj86IChuYW1lOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGw7XG4gIGNvbnRleHQ6IFQgfCBudWxsO1xuICBzdGF0czogTG9hZGVyU3RhdHM7XG59XG5cbmV4cG9ydCBjb25zdCBlbnVtIFBsYXlsaXN0Q29udGV4dFR5cGUge1xuICBNQU5JRkVTVCA9ICdtYW5pZmVzdCcsXG4gIExFVkVMID0gJ2xldmVsJyxcbiAgQVVESU9fVFJBQ0sgPSAnYXVkaW9UcmFjaycsXG4gIFNVQlRJVExFX1RSQUNLID0gJ3N1YnRpdGxlVHJhY2snLFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBQbGF5bGlzdExldmVsVHlwZSB7XG4gIE1BSU4gPSAnbWFpbicsXG4gIEFVRElPID0gJ2F1ZGlvJyxcbiAgU1VCVElUTEUgPSAnc3VidGl0bGUnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBsYXlsaXN0TG9hZGVyQ29udGV4dCBleHRlbmRzIExvYWRlckNvbnRleHQge1xuICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlO1xuICAvLyB0aGUgbGV2ZWwgaW5kZXggdG8gbG9hZFxuICBsZXZlbDogbnVtYmVyIHwgbnVsbDtcbiAgLy8gbGV2ZWwgb3IgdHJhY2sgaWQgZnJvbSBMZXZlbExvYWRpbmdEYXRhIC8gVHJhY2tMb2FkaW5nRGF0YVxuICBpZDogbnVtYmVyIHwgbnVsbDtcbiAgLy8gTWVkaWEgUGxheWxpc3QgR3JvdXAgSURcbiAgZ3JvdXBJZD86IHN0cmluZztcbiAgLy8gQ29udGVudCBTdGVlcmluZyBQYXRod2F5IElEIChvciB1bmRlZmluZWQgZm9yIGRlZmF1bHQgUGF0aHdheSBcIi5cIilcbiAgcGF0aHdheUlkPzogc3RyaW5nO1xuICAvLyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHBhcnNlZCBtM3U4IGxldmVsIHBsYXlsaXN0XG4gIGxldmVsRGV0YWlscz86IExldmVsRGV0YWlscztcbiAgLy8gQmxvY2tpbmcgcGxheWxpc3QgcmVxdWVzdCBkZWxpdmVyeSBkaXJlY3RpdmVzIChvciBudWxsIGlkIG5vbmUgd2VyZSBhZGRlZCB0byBwbGF5bGlzdCB1cmxcbiAgZGVsaXZlcnlEaXJlY3RpdmVzOiBIbHNVcmxQYXJhbWV0ZXJzIHwgbnVsbDtcbn1cbiIsIi8qKlxuICogUGxheWxpc3RMb2FkZXIgLSBkZWxlZ2F0ZSBmb3IgbWVkaWEgbWFuaWZlc3QvcGxheWxpc3QgbG9hZGluZyB0YXNrcy4gVGFrZXMgY2FyZSBvZiBwYXJzaW5nIG1lZGlhIHRvIGludGVybmFsIGRhdGEtbW9kZWxzLlxuICpcbiAqIE9uY2UgbG9hZGVkLCBkaXNwYXRjaGVzIGV2ZW50cyB3aXRoIHBhcnNlZCBkYXRhLW1vZGVscyBvZiBtYW5pZmVzdC9sZXZlbHMvYXVkaW8vc3VidGl0bGUgdHJhY2tzLlxuICpcbiAqIFVzZXMgbG9hZGVyKHMpIHNldCBpbiBjb25maWcgdG8gZG8gYWN0dWFsIGludGVybmFsIGxvYWRpbmcgb2YgcmVzb3VyY2UgdGFza3MuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yRGV0YWlscywgRXJyb3JUeXBlcyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE0zVThQYXJzZXIgZnJvbSAnLi9tM3U4LXBhcnNlcic7XG5pbXBvcnQgdHlwZSB7IExldmVsUGFyc2VkLCBWYXJpYWJsZU1hcCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHtcbiAgTG9hZGVyLFxuICBMb2FkZXJDYWxsYmFja3MsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIExvYWRlckNvbnRleHQsXG4gIExvYWRlclJlc3BvbnNlLFxuICBMb2FkZXJTdGF0cyxcbiAgUGxheWxpc3RMb2FkZXJDb250ZXh0LFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUge1xuICBFcnJvckRhdGEsXG4gIExldmVsTG9hZGluZ0RhdGEsXG4gIE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gIFRyYWNrTG9hZGluZ0RhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IE5ldHdvcmtDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIHsgTWVkaWFBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBMb2FkZXJDb25maWcsIFJldHJ5Q29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKFxuICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4pOiBQbGF5bGlzdExldmVsVHlwZSB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gY29udGV4dDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuQVVESU87XG4gICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgcmV0dXJuIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuTUFJTjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChcbiAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4pOiBzdHJpbmcge1xuICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5jbGFzcyBQbGF5bGlzdExvYWRlciBpbXBsZW1lbnRzIE5ldHdvcmtDb21wb25lbnRBUEkge1xuICBwcml2YXRlIHJlYWRvbmx5IGhsczogSGxzO1xuICBwcml2YXRlIHJlYWRvbmx5IGxvYWRlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBMb2FkZXI8TG9hZGVyQ29udGV4dD47XG4gIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBwcml2YXRlIHZhcmlhYmxlTGlzdDogVmFyaWFibGVNYXAgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydExvYWQoc3RhcnRQb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7fVxuXG4gIHB1YmxpYyBzdG9wTG9hZCgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZywgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVJbnRlcm5hbExvYWRlcihcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gICk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IFBMb2FkZXIgPSBjb25maWcucExvYWRlcjtcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGNvbnN0IEludGVybmFsTG9hZGVyID0gUExvYWRlciB8fCBMb2FkZXI7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEludGVybmFsTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPFBsYXlsaXN0TG9hZGVyQ29udGV4dD47XG5cbiAgICB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXSA9IGxvYWRlcjtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRJbnRlcm5hbExvYWRlcihcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gICk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgcHJpdmF0ZSBkZXN0cm95SW50ZXJuYWxMb2FkZXJzKCk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgY29udGV4dFR5cGUgaW4gdGhpcy5sb2FkZXJzKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gICkge1xuICAgIGNvbnN0IHsgdXJsIH0gPSBkYXRhO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25MZXZlbExvYWRpbmcoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FESU5HLCBkYXRhOiBMZXZlbExvYWRpbmdEYXRhKSB7XG4gICAgY29uc3QgeyBpZCwgbGV2ZWwsIHBhdGh3YXlJZCwgdXJsLCBkZWxpdmVyeURpcmVjdGl2ZXMgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICBwYXRod2F5SWQsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uQXVkaW9UcmFja0xvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLFxuICAgIGRhdGE6IFRyYWNrTG9hZGluZ0RhdGEsXG4gICkge1xuICAgIGNvbnN0IHsgaWQsIGdyb3VwSWQsIHVybCwgZGVsaXZlcnlEaXJlY3RpdmVzIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhcbiAgICBldmVudDogRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURJTkcsXG4gICAgZGF0YTogVHJhY2tMb2FkaW5nRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgeyBpZCwgZ3JvdXBJZCwgdXJsLCBkZWxpdmVyeURpcmVjdGl2ZXMgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkKGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IExvYWRpbmcgcGxheWxpc3Qgb2YgdHlwZSAke2NvbnRleHQudHlwZX0sIGxldmVsOiAke2NvbnRleHQubGV2ZWx9LCBpZDogJHtjb250ZXh0LmlkfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgYSBsb2FkZXIgZm9yIHRoaXMgY29udGV4dCBhbHJlYWR5IGV4aXN0c1xuICAgIGxldCBsb2FkZXIgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBsb2FkZXIuY29udGV4dCBhcyBQbGF5bGlzdExvYWRlckNvbnRleHQ7XG4gICAgICBpZiAoXG4gICAgICAgIGxvYWRlckNvbnRleHQgJiZcbiAgICAgICAgbG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsICYmXG4gICAgICAgIGxvYWRlckNvbnRleHQubGV2ZWwgPT09IGNvbnRleHQubGV2ZWxcbiAgICAgICkge1xuICAgICAgICAvLyBzYW1lIFVSTCBjYW4ndCBvdmVybGFwXG4gICAgICAgIGxvZ2dlci50cmFjZSgnW3BsYXlsaXN0LWxvYWRlcl06IHBsYXlsaXN0IHJlcXVlc3Qgb25nb2luZycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICBgW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YCxcbiAgICAgICk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgbGV0IGxvYWRQb2xpY3k6IExvYWRlckNvbmZpZztcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUKSB7XG4gICAgICBsb2FkUG9saWN5ID0gY29uZmlnLm1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkUG9saWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICAgIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgICAgICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkZXIgPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGNvbnRleHQpO1xuXG4gICAgLy8gT3ZlcnJpZGUgbGV2ZWwvdHJhY2sgdGltZW91dCBmb3IgTEwtSExTIHJlcXVlc3RzXG4gICAgLy8gKHRoZSBkZWZhdWx0IG9mIDEwMDAwbXMgaXMgY291bnRlciBwcm9kdWN0aXZlIHRvIGJsb2NraW5nIHBsYXlsaXN0IHJlbG9hZCByZXF1ZXN0cylcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzPy5wYXJ0KSkge1xuICAgICAgbGV0IGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKFxuICAgICAgICBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiZcbiAgICAgICAgY29udGV4dC5sZXZlbCAhPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIGxldmVsRGV0YWlscyA9IHRoaXMuaGxzLmxldmVsc1tjb250ZXh0LmxldmVsXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICAgIGNvbnRleHQuaWQgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmXG4gICAgICAgIGNvbnRleHQuaWQgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tjb250ZXh0LmlkXS5kZXRhaWxzO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICBjb25zdCBwYXJ0VGFyZ2V0ID0gbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IHRhcmdldER1cmF0aW9uID0gbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgICAgICBpZiAocGFydFRhcmdldCAmJiB0YXJnZXREdXJhdGlvbikge1xuICAgICAgICAgIGNvbnN0IG1heExvd0xhdGVuY3lQbGF5bGlzdFJlZnJlc2ggPVxuICAgICAgICAgICAgTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgbG9hZFBvbGljeSA9IE9iamVjdC5hc3NpZ24oe30sIGxvYWRQb2xpY3ksIHtcbiAgICAgICAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCxcbiAgICAgICAgICAgICAgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihcbiAgICAgICAgICAgICAgbWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCxcbiAgICAgICAgICAgICAgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHk6IFJldHJ5Q29uZmlnIHwgUmVjb3JkPHN0cmluZywgdm9pZD4gPVxuICAgICAgbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgIGxvYWRQb2xpY3ksXG4gICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICByZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4UmV0cnlEZWxheU1zIHx8IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPFBsYXlsaXN0TG9hZGVyQ29udGV4dD4gPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCkgYXNcbiAgICAgICAgICB8IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+XG4gICAgICAgICAgfCB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGEgYXMgc3RyaW5nO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5ldyBFcnJvcignbm8gRVhUTTNVIGRlbGltaXRlcicpLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMgfHwgbnVsbCxcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsXG4gICAgICAgICAgICBsb2FkZXIsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW3BsYXlsaXN0LWxvYWRlcl06IENhbGxpbmcgaW50ZXJuYWwgbG9hZGVyIGRlbGVnYXRlIGZvciBVUkw6ICR7Y29udGV4dC51cmx9YCk7XG5cbiAgICBsb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1hc3RlclBsYXlsaXN0KFxuICAgIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IHN0cmluZyA9IHJlc3BvbnNlLmRhdGEgYXMgc3RyaW5nO1xuXG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuXG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcblxuICAgIGlmIChwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IoXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0cyxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICAgbGV2ZWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdCxcbiAgICB9ID0gcGFyc2VkUmVzdWx0O1xuXG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3Q7XG5cbiAgICBjb25zdCB7XG4gICAgICBBVURJTzogYXVkaW9UcmFja3MgPSBbXSxcbiAgICAgIFNVQlRJVExFUzogc3VidGl0bGVzLFxuICAgICAgJ0NMT1NFRC1DQVBUSU9OUyc6IGNhcHRpb25zLFxuICAgIH0gPSBNM1U4UGFyc2VyLnBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIHVybCwgcGFyc2VkUmVzdWx0KTtcblxuICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgZm91bmQgYW4gYXVkaW8gdHJhY2sgZW1iZWRkZWQgaW4gbWFpbiBwbGF5bGlzdCAoYXVkaW8gdHJhY2sgd2l0aG91dCBVUkkgYXR0cmlidXRlKVxuICAgICAgY29uc3QgZW1iZWRkZWRBdWRpb0ZvdW5kOiBib29sZWFuID0gYXVkaW9UcmFja3Muc29tZShcbiAgICAgICAgKGF1ZGlvVHJhY2spID0+ICFhdWRpb1RyYWNrLnVybCxcbiAgICAgICk7XG5cbiAgICAgIC8vIGlmIG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIGRlZmluZWQsIGJ1dCBhdWRpbyBjb2RlYyBzaWduYWxlZCBpbiBxdWFsaXR5IGxldmVsLFxuICAgICAgLy8gd2UgbmVlZCB0byBzaWduYWwgdGhpcyBtYWluIGF1ZGlvIHRyYWNrIHRoaXMgY291bGQgaGFwcGVuIHdpdGggcGxheWxpc3RzIHdpdGhcbiAgICAgIC8vIGFsdCBhdWRpbyByZW5kaXRpb24gaW4gd2hpY2ggcXVhbGl0eSBsZXZlbHMgKG1haW4pXG4gICAgICAvLyBjb250YWlucyBib3RoIGF1ZGlvK3ZpZGVvLiBidXQgd2l0aCBtaXhlZCBhdWRpbyB0cmFjayBub3Qgc2lnbmFsZWRcbiAgICAgIGlmIChcbiAgICAgICAgIWVtYmVkZGVkQXVkaW9Gb3VuZCAmJlxuICAgICAgICBsZXZlbHNbMF0uYXVkaW9Db2RlYyAmJlxuICAgICAgICAhbGV2ZWxzWzBdLmF0dHJzLkFVRElPXG4gICAgICApIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAnW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZScsXG4gICAgICAgICk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZ3JvdXBJZDogJ21haW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlZDogZmFsc2UsXG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pIGFzIE1lZGlhQXR0cmlidXRlcyxcbiAgICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICAgIHVybDogJycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVzLFxuICAgICAgY2FwdGlvbnMsXG4gICAgICBjb250ZW50U3RlZXJpbmcsXG4gICAgICB1cmwsXG4gICAgICBzdGF0cyxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc2Vzc2lvbkRhdGEsXG4gICAgICBzZXNzaW9uS2V5cyxcbiAgICAgIHN0YXJ0VGltZU9mZnNldCxcbiAgICAgIHZhcmlhYmxlTGlzdCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QoXG4gICAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICBsb2FkZXI6IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+IHwgdW5kZWZpbmVkLFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCB7IGlkLCBsZXZlbCwgdHlwZSB9ID0gY29udGV4dDtcblxuICAgIGNvbnN0IHVybCA9IGdldFJlc3BvbnNlVXJsKHJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbFVybElkID0gMDtcbiAgICBjb25zdCBsZXZlbElkID0gTnVtYmVyLmlzRmluaXRlKGxldmVsIGFzIG51bWJlcilcbiAgICAgID8gKGxldmVsIGFzIG51bWJlcilcbiAgICAgIDogTnVtYmVyLmlzRmluaXRlKGlkIGFzIG51bWJlcilcbiAgICAgICAgPyAoaWQgYXMgbnVtYmVyKVxuICAgICAgICA6IDA7XG4gICAgY29uc3QgbGV2ZWxUeXBlID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzID0gTTNVOFBhcnNlci5wYXJzZUxldmVsUGxheWxpc3QoXG4gICAgICByZXNwb25zZS5kYXRhIGFzIHN0cmluZyxcbiAgICAgIHVybCxcbiAgICAgIGxldmVsSWQsXG4gICAgICBsZXZlbFR5cGUsXG4gICAgICBsZXZlbFVybElkLFxuICAgICAgdGhpcy52YXJpYWJsZUxpc3QsXG4gICAgKTtcblxuICAgIC8vIFdlIGhhdmUgZG9uZSBvdXIgZmlyc3QgcmVxdWVzdCAoTWFuaWZlc3QtdHlwZSkgYW5kIHJlY2VpdmVcbiAgICAvLyBub3QgYSBtYXN0ZXIgcGxheWxpc3QgYnV0IGEgY2h1bmstbGlzdCAodHJhY2svbGV2ZWwpXG4gICAgLy8gV2UgZmlyZSB0aGUgbWFuaWZlc3QtbG9hZGVkIGV2ZW50IGFueXdheSB3aXRoIHRoZSBwYXJzZWQgbGV2ZWwtZGV0YWlsc1xuICAgIC8vIGJ5IGNyZWF0aW5nIGEgc2luZ2xlLWxldmVsIHN0cnVjdHVyZSBmb3IgaXQuXG4gICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUxldmVsOiBMZXZlbFBhcnNlZCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBBdHRyTGlzdCh7fSksXG4gICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIHVybCxcbiAgICAgIH07XG5cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbc2luZ2xlTGV2ZWxdLFxuICAgICAgICBhdWRpb1RyYWNrczogW10sXG4gICAgICAgIHVybCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICAgIGNvbnRlbnRTdGVlcmluZzogbnVsbCxcbiAgICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgICB2YXJpYWJsZUxpc3Q6IG51bGwsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuXG4gICAgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZChcbiAgICAgIGxldmVsRGV0YWlscyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHMsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBsb2FkZXIsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IoXG4gICAgcmVzcG9uc2U6IExvYWRlclJlc3BvbnNlLFxuICAgIGNvbnRleHQ6IFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgICBlcnJvcjogRXJyb3IsXG4gICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICk6IHZvaWQge1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1QsXG4gICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICBlcnJvcixcbiAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgY29udGV4dCxcbiAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgc3RhdHMsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU5ldHdvcmtFcnJvcihcbiAgICBjb250ZXh0OiBQbGF5bGlzdExvYWRlckNvbnRleHQsXG4gICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgcmVzcG9uc2U6IHsgY29kZTogbnVtYmVyOyB0ZXh0OiBzdHJpbmcgfSB8IHVuZGVmaW5lZCxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICk6IHZvaWQge1xuICAgIGxldCBtZXNzYWdlID0gYEEgbmV0d29yayAke1xuICAgICAgdGltZW91dFxuICAgICAgICA/ICd0aW1lb3V0J1xuICAgICAgICA6ICdlcnJvcicgKyAocmVzcG9uc2UgPyAnIChzdGF0dXMgJyArIHJlc3BvbnNlLmNvZGUgKyAnKScgOiAnJylcbiAgICB9IG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnR5cGV9YDtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICBtZXNzYWdlICs9IGA6ICR7Y29udGV4dC5sZXZlbH0gaWQ6ICR7Y29udGV4dC5pZH1gO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHxcbiAgICAgIGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDS1xuICAgICkge1xuICAgICAgbWVzc2FnZSArPSBgIGlkOiAke2NvbnRleHQuaWR9IGdyb3VwLWlkOiBcIiR7Y29udGV4dC5ncm91cElkfVwiYDtcbiAgICB9XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgbG9nZ2VyLndhcm4oYFtwbGF5bGlzdC1sb2FkZXJdOiAke21lc3NhZ2V9YCk7XG4gICAgbGV0IGRldGFpbHMgPSBFcnJvckRldGFpbHMuVU5LTk9XTjtcbiAgICBsZXQgZmF0YWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNUOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dFxuICAgICAgICAgID8gRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfVElNRU9VVFxuICAgICAgICAgIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0XG4gICAgICAgICAgPyBFcnJvckRldGFpbHMuU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUXG4gICAgICAgICAgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgdGhpcy5yZXNldEludGVybmFsTG9hZGVyKGNvbnRleHQudHlwZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JEYXRhOiBFcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0cyxcbiAgICB9O1xuXG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXR3b3JrRGV0YWlscz8udXJsIHx8IGNvbnRleHQudXJsO1xuICAgICAgZXJyb3JEYXRhLnJlc3BvbnNlID0geyB1cmwsIGRhdGE6IHVuZGVmaW5lZCBhcyBhbnksIC4uLnJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGVycm9yRGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVBsYXlsaXN0TG9hZGVkKFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSxcbiAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgY29udGV4dDogUGxheWxpc3RMb2FkZXJDb250ZXh0LFxuICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgbG9hZGVyOiBMb2FkZXI8UGxheWxpc3RMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZCxcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgeyB0eXBlLCBsZXZlbCwgaWQsIGdyb3VwSWQsIGRlbGl2ZXJ5RGlyZWN0aXZlcyB9ID0gY29udGV4dDtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyZW50ID0gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpO1xuICAgIGNvbnN0IGxldmVsSW5kZXggPVxuICAgICAgdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInICYmIHBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICAgICA/IChsZXZlbCBhcyBudW1iZXIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdObyBTZWdtZW50cyBmb3VuZCBpbiBQbGF5bGlzdCcpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0cyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIFRhcmdldCBEdXJhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0cyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBsb2FkZXIpIHtcbiAgICAgIGlmIChsb2FkZXIuZ2V0Q2FjaGVBZ2UpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IGxvYWRlci5nZXRDYWNoZUFnZSgpIHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoIWxvYWRlci5nZXRDYWNoZUFnZSB8fCBpc05hTihsZXZlbERldGFpbHMuYWdlSGVhZGVyKSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTDpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCB8fCAwLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgaWQ6IGlkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZCB8fCAnJyxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxheWxpc3RMb2FkZXI7XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQWRkVHJhY2tFdmVudCh0cmFjazogVGV4dFRyYWNrLCB2aWRlb0VsOiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gIGxldCBldmVudDogRXZlbnQ7XG4gIHRyeSB7XG4gICAgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHRyYWNrJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGZvciBJRTExXG4gICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBldmVudC5pbml0RXZlbnQoJ2FkZHRyYWNrJywgZmFsc2UsIGZhbHNlKTtcbiAgfVxuICAoZXZlbnQgYXMgYW55KS50cmFjayA9IHRyYWNrO1xuICB2aWRlb0VsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ3VlVG9UcmFjayh0cmFjazogVGV4dFRyYWNrLCBjdWU6IFZUVEN1ZSkge1xuICAvLyBTb21ldGltZXMgdGhlcmUgYXJlIGN1ZSBvdmVybGFwcyBvbiBzZWdtZW50ZWQgdnR0cyBzbyB0aGUgc2FtZVxuICAvLyBjdWUgY2FuIGFwcGVhciBtb3JlIHRoYW4gb25jZSBpbiBkaWZmZXJlbnQgdnR0IGZpbGVzLlxuICAvLyBUaGlzIGF2b2lkIHNob3dpbmcgZHVwbGljYXRlZCBjdWVzIHdpdGggc2FtZSB0aW1lY29kZSBhbmQgdGV4dC5cbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG4gIGlmICh0cmFjay5jdWVzICYmICF0cmFjay5jdWVzLmdldEN1ZUJ5SWQoY3VlLmlkKSkge1xuICAgIHRyeSB7XG4gICAgICB0cmFjay5hZGRDdWUoY3VlKTtcbiAgICAgIGlmICghdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRDdWUgaXMgZmFpbGVkIGZvcjogJHtjdWV9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYFt0ZXh0dHJhY2stdXRpbHNdOiAke2Vycn1gKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRleHRUcmFja0N1ZSA9IG5ldyAoc2VsZi5UZXh0VHJhY2tDdWUgYXMgYW55KShcbiAgICAgICAgICBjdWUuc3RhcnRUaW1lLFxuICAgICAgICAgIGN1ZS5lbmRUaW1lLFxuICAgICAgICAgIGN1ZS50ZXh0LFxuICAgICAgICApO1xuICAgICAgICB0ZXh0VHJhY2tDdWUuaWQgPSBjdWUuaWQ7XG4gICAgICAgIHRyYWNrLmFkZEN1ZSh0ZXh0VHJhY2tDdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgYFt0ZXh0dHJhY2stdXRpbHNdOiBMZWdhY3kgVGV4dFRyYWNrQ3VlIGZhbGxiYWNrIGZhaWxlZDogJHtlcnIyfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9IG1vZGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ3VycmVudEN1ZXModHJhY2s6IFRleHRUcmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAobGV0IGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgIHRyYWNrLnJlbW92ZUN1ZSh0cmFjay5jdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3Vlc0luUmFuZ2UoXG4gIHRyYWNrOiBUZXh0VHJhY2ssXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBwcmVkaWNhdGU/OiAoY3VlOiBUZXh0VHJhY2tDdWUpID0+IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgbW9kZSA9IHRyYWNrLm1vZGU7XG4gIGlmIChtb2RlID09PSAnZGlzYWJsZWQnKSB7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICB9XG5cbiAgaWYgKHRyYWNrLmN1ZXMgJiYgdHJhY2suY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VlcyA9IGdldEN1ZXNJblJhbmdlKHRyYWNrLmN1ZXMsIHN0YXJ0LCBlbmQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKGN1ZXNbaV0pKSB7XG4gICAgICAgIHRyYWNrLnJlbW92ZUN1ZShjdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuXG4vLyBGaW5kIGZpcnN0IGN1ZSBzdGFydGluZyBhZnRlciBnaXZlbiB0aW1lLlxuLy8gTW9kaWZpZWQgdmVyc2lvbiBvZiBiaW5hcnkgc2VhcmNoIE8obG9nKG4pKS5cbmZ1bmN0aW9uIGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoXG4gIGN1ZXM6IFRleHRUcmFja0N1ZUxpc3QgfCBUZXh0VHJhY2tDdWVbXSxcbiAgdGltZTogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgLy8gSWYgZmlyc3QgY3VlIHN0YXJ0cyBhZnRlciB0aW1lLCBzdGFydCB0aGVyZVxuICBpZiAodGltZSA8IGN1ZXNbMF0uc3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gSWYgdGhlIGxhc3QgY3VlIGVuZHMgYmVmb3JlIHRpbWUgdGhlcmUgaXMgbm8gb3ZlcmxhcFxuICBjb25zdCBsZW4gPSBjdWVzLmxlbmd0aCAtIDE7XG4gIGlmICh0aW1lID4gY3Vlc1tsZW5dLmVuZFRpbWUpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGxlbjtcblxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcblxuICAgIGlmICh0aW1lIDwgY3Vlc1ttaWRdLnN0YXJ0VGltZSkge1xuICAgICAgcmlnaHQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSBpZiAodGltZSA+IGN1ZXNbbWlkXS5zdGFydFRpbWUgJiYgbGVmdCA8IGxlbikge1xuICAgICAgbGVmdCA9IG1pZCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3Mgbm90IGxvd2VyIG9yIGhpZ2hlciwgaXQgbXVzdCBiZSBlcXVhbC5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQsIGxlZnQgYW5kIHJpZ2h0IGhhdmUgc3dhcHBlZC5cbiAgLy8gTm8gZGlyZWN0IG1hdGNoIHdhcyBmb3VuZCwgbGVmdCBvciByaWdodCBlbGVtZW50IG11c3QgYmUgdGhlIGNsb3Nlc3QuIENoZWNrIHdoaWNoIG9uZSBoYXMgdGhlIHNtYWxsZXN0IGRpZmYuXG4gIHJldHVybiBjdWVzW2xlZnRdLnN0YXJ0VGltZSAtIHRpbWUgPCB0aW1lIC0gY3Vlc1tyaWdodF0uc3RhcnRUaW1lXG4gICAgPyBsZWZ0XG4gICAgOiByaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKFxuICBjdWVzOiBUZXh0VHJhY2tDdWVMaXN0IHwgVGV4dFRyYWNrQ3VlW10sXG4gIHN0YXJ0OiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuKTogVGV4dFRyYWNrQ3VlW10ge1xuICBjb25zdCBjdWVzRm91bmQ6IFRleHRUcmFja0N1ZVtdID0gW107XG4gIGNvbnN0IGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZXNGb3VuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKFxuICB0ZXh0VHJhY2tMaXN0OiBUZXh0VHJhY2tMaXN0LFxuKTogVGV4dFRyYWNrW10ge1xuICBjb25zdCB0cmFja3M6IFRleHRUcmFja1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKFxuICAgICAgKHRyYWNrLmtpbmQgPT09ICdzdWJ0aXRsZXMnIHx8IHRyYWNrLmtpbmQgPT09ICdjYXB0aW9ucycpICYmXG4gICAgICB0cmFjay5sYWJlbFxuICAgICkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJhdGlvbmFsVGltZXN0YW1wIH0gZnJvbSAnLi4vdXRpbHMvdGltZXNjYWxlLWNvbnZlcnNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZXIge1xuICBkZW11eChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBpc1NhbXBsZUFlcz86IGJvb2xlYW4sXG4gICAgZmx1c2g/OiBib29sZWFuLFxuICApOiBEZW11eGVyUmVzdWx0O1xuICBkZW11eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+O1xuICBmbHVzaCh0aW1lT2Zmc2V0PzogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB8IFByb21pc2U8RGVtdXhlclJlc3VsdD47XG4gIGRlc3Ryb3koKTogdm9pZDtcbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlcixcbiAgKTtcbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFM/OiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwpOiB2b2lkO1xuICByZXNldENvbnRpZ3VpdHkoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVyUmVzdWx0IHtcbiAgYXVkaW9UcmFjazogRGVtdXhlZEF1ZGlvVHJhY2s7XG4gIHZpZGVvVHJhY2s6IERlbXV4ZWRWaWRlb1RyYWNrQmFzZTtcbiAgaWQzVHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRUcmFjayB7XG4gIHR5cGU6IHN0cmluZztcbiAgaWQ6IG51bWJlcjtcbiAgcGlkOiBudW1iZXI7XG4gIGlucHV0VGltZVNjYWxlOiBudW1iZXI7XG4gIHNlcXVlbmNlTnVtYmVyOiBudW1iZXI7XG4gIHNhbXBsZXM6XG4gICAgfCBBdWRpb1NhbXBsZVtdXG4gICAgfCBWaWRlb1NhbXBsZVtdXG4gICAgfCBNZXRhZGF0YVNhbXBsZVtdXG4gICAgfCBVc2VyZGF0YVNhbXBsZVtdXG4gICAgfCBVaW50OEFycmF5O1xuICB0aW1lc2NhbGU/OiBudW1iZXI7XG4gIGNvbnRhaW5lcj86IHN0cmluZztcbiAgZHJvcHBlZDogbnVtYmVyO1xuICBkdXJhdGlvbj86IG51bWJlcjtcbiAgcGVzRGF0YT86IEVsZW1lbnRhcnlTdHJlYW1EYXRhIHwgbnVsbDtcbiAgY29kZWM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFzc3Rocm91Z2hUcmFjayBleHRlbmRzIERlbXV4ZWRUcmFjayB7XG4gIHNhbXBsZUR1cmF0aW9uOiBudW1iZXI7XG4gIHNhbXBsZXM6IFVpbnQ4QXJyYXk7XG4gIHRpbWVzY2FsZTogbnVtYmVyO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBjb2RlYzogc3RyaW5nO1xufVxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVkQXVkaW9UcmFjayBleHRlbmRzIERlbXV4ZWRUcmFjayB7XG4gIGNvbmZpZz86IG51bWJlcltdIHwgVWludDhBcnJheTtcbiAgc2FtcGxlcmF0ZT86IG51bWJlcjtcbiAgc2VnbWVudENvZGVjPzogc3RyaW5nO1xuICBjaGFubmVsQ291bnQ/OiBudW1iZXI7XG4gIG1hbmlmZXN0Q29kZWM/OiBzdHJpbmc7XG4gIHNhbXBsZXM6IEF1ZGlvU2FtcGxlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZFZpZGVvVHJhY2tCYXNlIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgcGl4ZWxSYXRpbz86IFtudW1iZXIsIG51bWJlcl07XG4gIGF1ZEZvdW5kPzogYm9vbGVhbjtcbiAgcHBzPzogVWludDhBcnJheVtdO1xuICBzcHM/OiBVaW50OEFycmF5W107XG4gIG5hbHVTdGF0ZT86IG51bWJlcjtcbiAgc2VnbWVudENvZGVjPzogc3RyaW5nO1xuICBtYW5pZmVzdENvZGVjPzogc3RyaW5nO1xuICBzYW1wbGVzOiBWaWRlb1NhbXBsZVtdIHwgVWludDhBcnJheTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZW11eGVkVmlkZW9UcmFjayBleHRlbmRzIERlbXV4ZWRWaWRlb1RyYWNrQmFzZSB7XG4gIHNhbXBsZXM6IFZpZGVvU2FtcGxlW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVtdXhlZE1ldGFkYXRhVHJhY2sgZXh0ZW5kcyBEZW11eGVkVHJhY2sge1xuICBzYW1wbGVzOiBNZXRhZGF0YVNhbXBsZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlbXV4ZWRVc2VyZGF0YVRyYWNrIGV4dGVuZHMgRGVtdXhlZFRyYWNrIHtcbiAgc2FtcGxlczogVXNlcmRhdGFTYW1wbGVbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gTWV0YWRhdGFTY2hlbWEge1xuICBhdWRpb0lkMyA9ICdvcmcuaWQzJyxcbiAgZGF0ZVJhbmdlID0gJ2NvbS5hcHBsZS5xdWlja3RpbWUuSExTJyxcbiAgZW1zZyA9ICdodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzJyxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFTYW1wbGUge1xuICBwdHM6IG51bWJlcjtcbiAgZHRzOiBudW1iZXI7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIGxlbj86IG51bWJlcjtcbiAgZGF0YTogVWludDhBcnJheTtcbiAgdHlwZTogTWV0YWRhdGFTY2hlbWE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlcmRhdGFTYW1wbGUge1xuICBwdHM6IG51bWJlcjtcbiAgYnl0ZXM/OiBVaW50OEFycmF5O1xuICB0eXBlPzogbnVtYmVyO1xuICBwYXlsb2FkVHlwZT86IG51bWJlcjtcbiAgdXVpZD86IHN0cmluZztcbiAgdXNlckRhdGE/OiBzdHJpbmc7XG4gIHVzZXJEYXRhQnl0ZXM/OiBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvU2FtcGxlIHtcbiAgZHRzOiBudW1iZXI7XG4gIHB0czogbnVtYmVyO1xuICBrZXk6IGJvb2xlYW47XG4gIGZyYW1lOiBib29sZWFuO1xuICB1bml0czogVmlkZW9TYW1wbGVVbml0W107XG4gIGRlYnVnOiBzdHJpbmc7XG4gIGxlbmd0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvU2FtcGxlVW5pdCB7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIHR5cGU6IG51bWJlcjtcbiAgc3RhdGU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEF1ZGlvU2FtcGxlID0ge1xuICB1bml0OiBVaW50OEFycmF5O1xuICBwdHM6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEF1ZGlvRnJhbWUgPSB7XG4gIHNhbXBsZTogQXVkaW9TYW1wbGU7XG4gIGxlbmd0aDogbnVtYmVyO1xuICBtaXNzaW5nOiBudW1iZXI7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRhcnlTdHJlYW1EYXRhIHtcbiAgZGF0YTogVWludDhBcnJheVtdO1xuICBzaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5RGF0YSB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBrZXk6IFVpbnQ4QXJyYXk7XG4gIGl2OiBVaW50OEFycmF5O1xufVxuIiwiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7XG4gIHNlbmRBZGRUcmFja0V2ZW50LFxuICBjbGVhckN1cnJlbnRDdWVzLFxuICByZW1vdmVDdWVzSW5SYW5nZSxcbn0gZnJvbSAnLi4vdXRpbHMvdGV4dHRyYWNrLXV0aWxzJztcbmltcG9ydCAqIGFzIElEMyBmcm9tICcuLi9kZW11eC9pZDMnO1xuaW1wb3J0IHtcbiAgRGF0ZVJhbmdlLFxuICBpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZSxcbiAgaXNTQ1RFMzVBdHRyaWJ1dGUsXG59IGZyb20gJy4uL2xvYWRlci9kYXRlLXJhbmdlJztcbmltcG9ydCB7IE1ldGFkYXRhU2NoZW1hIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGEsXG4gIExldmVsVXBkYXRlZERhdGEsXG4gIE1lZGlhQXR0YWNoZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIFdlYktpdERhdGFDdWU6IFZUVEN1ZSB8IHZvaWQ7XG4gIH1cbn1cblxuY29uc3QgTUlOX0NVRV9EVVJBVElPTiA9IDAuMjU7XG5cbmZ1bmN0aW9uIGdldEN1ZUNsYXNzKCk6IHR5cGVvZiBWVFRDdWUgfCB0eXBlb2YgVGV4dFRyYWNrQ3VlIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIHNlbGYuVlRUQ3VlIHx8IHNlbGYuVGV4dFRyYWNrQ3VlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhcbiAgQ3VlOiB0eXBlb2YgVlRUQ3VlIHwgdHlwZW9mIFRleHRUcmFja0N1ZSxcbiAgc3RhcnRUaW1lOiBudW1iZXIsXG4gIGVuZFRpbWU6IG51bWJlcixcbiAgZGF0YTogT2JqZWN0LFxuICB0eXBlPzogc3RyaW5nLFxuKTogVlRUQ3VlIHwgVGV4dFRyYWNrQ3VlIHwgdW5kZWZpbmVkIHtcbiAgbGV0IGN1ZSA9IG5ldyBDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCAnJyk7XG4gIHRyeSB7XG4gICAgKGN1ZSBhcyBhbnkpLnZhbHVlID0gZGF0YTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgKGN1ZSBhcyBhbnkpLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGN1ZSA9IG5ldyBDdWUoXG4gICAgICBzdGFydFRpbWUsXG4gICAgICBlbmRUaW1lLFxuICAgICAgSlNPTi5zdHJpbmdpZnkodHlwZSA/IHsgdHlwZSwgLi4uZGF0YSB9IDogZGF0YSksXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3VlO1xufVxuXG4vLyBWVFRDdWUgbGF0ZXN0IGRyYWZ0IGFsbG93cyBhbiBpbmZpbml0ZSBkdXJhdGlvbiwgZmFsbGJhY2tcbi8vIHRvIE1BWF9WQUxVRSBpZiBuZWNlc3NhcnlcbmNvbnN0IE1BWF9DVUVfRU5EVElNRSA9ICgoKSA9PiB7XG4gIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gIHRyeSB7XG4gICAgQ3VlICYmIG5ldyBDdWUoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xufSkoKTtcblxuZnVuY3Rpb24gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGRhdGU6IERhdGUsIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gaGV4VG9BcnJheUJ1ZmZlcihzdHIpOiBBcnJheUJ1ZmZlciB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oXG4gICAgc3RyXG4gICAgICAucmVwbGFjZSgvXjB4LywgJycpXG4gICAgICAucmVwbGFjZSgvKFtcXGRhLWZBLUZdezJ9KSA/L2csICcweCQxICcpXG4gICAgICAucmVwbGFjZSgvICskLywgJycpXG4gICAgICAuc3BsaXQoJyAnKSxcbiAgKS5idWZmZXI7XG59XG5jbGFzcyBJRDNUcmFja0NvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGlkM1RyYWNrOiBUZXh0VHJhY2sgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBtZWRpYTogSFRNTE1lZGlhRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZDogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7XG4gICAgICBjdWVzOiBSZWNvcmQ8c3RyaW5nLCBWVFRDdWUgfCBUZXh0VHJhY2tDdWU+O1xuICAgICAgZGF0ZVJhbmdlOiBEYXRlUmFuZ2U7XG4gICAgICBkdXJhdGlvbktub3duOiBib29sZWFuO1xuICAgIH1cbiAgPiA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hlZERhdGEsXG4gICk6IHZvaWQge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyQ3VycmVudEN1ZXModGhpcy5pZDNUcmFjayk7XG4gICAgdGhpcy5pZDNUcmFjayA9IG51bGw7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgfVxuXG4gIGNyZWF0ZVRyYWNrKG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50KTogVGV4dFRyYWNrIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcykgYXMgVGV4dFRyYWNrO1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgICByZXR1cm4gdHJhY2s7XG4gIH1cblxuICBnZXRJRDNUcmFjayh0ZXh0VHJhY2tzOiBUZXh0VHJhY2tMaXN0KTogVGV4dFRyYWNrIHwgdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrOiBUZXh0VHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xuICAgICAgaWYgKHRleHRUcmFjay5raW5kID09PSAnbWV0YWRhdGEnICYmIHRleHRUcmFjay5sYWJlbCA9PT0gJ2lkMycpIHtcbiAgICAgICAgLy8gc2VuZCAnYWRkdHJhY2snIHdoZW4gcmV1c2luZyB0aGUgdGV4dFRyYWNrIGZvciBtZXRhZGF0YSxcbiAgICAgICAgLy8gc2FtZSBhcyB3aGF0IHdlIGRvIGZvciBjYXB0aW9uc1xuICAgICAgICBzZW5kQWRkVHJhY2tFdmVudCh0ZXh0VHJhY2ssIHRoaXMubWVkaWEpO1xuXG4gICAgICAgIHJldHVybiB0ZXh0VHJhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnLCAnaWQzJyk7XG4gIH1cblxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsXG4gICAgZGF0YTogRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGEsXG4gICkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGhsczoge1xuICAgICAgICBjb25maWc6IHsgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcywgZW5hYmxlSUQzTWV0YWRhdGFDdWVzIH0sXG4gICAgICB9LFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyAmJiAhZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBzYW1wbGVzIH0gPSBkYXRhO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIGR5bmFtaWNhbGx5XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG5cbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGlmICghQ3VlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2FtcGxlc1tpXS50eXBlO1xuICAgICAgaWYgKFxuICAgICAgICAodHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiAhZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcykgfHxcbiAgICAgICAgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlc1xuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmcmFtZXMgPSBJRDMuZ2V0SUQzRnJhbWVzKHNhbXBsZXNbaV0uZGF0YSk7XG4gICAgICBpZiAoZnJhbWVzKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNhbXBsZXNbaV0ucHRzO1xuICAgICAgICBsZXQgZW5kVGltZTogbnVtYmVyID0gc3RhcnRUaW1lICsgc2FtcGxlc1tpXS5kdXJhdGlvbjtcblxuICAgICAgICBpZiAoZW5kVGltZSA+IE1BWF9DVUVfRU5EVElNRSkge1xuICAgICAgICAgIGVuZFRpbWUgPSBNQVhfQ1VFX0VORFRJTUU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIGlmICh0aW1lRGlmZiA8PSAwKSB7XG4gICAgICAgICAgZW5kVGltZSA9IHN0YXJ0VGltZSArIE1JTl9DVUVfRFVSQVRJT047XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcbiAgICAgICAgICBpZiAoIUlEMy5pc1RpbWVTdGFtcEZyYW1lKGZyYW1lKSkge1xuICAgICAgICAgICAgLy8gYWRkIGEgYm91bmRzIHRvIGFueSB1bmJvdW5kZWQgY3Vlc1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZSwgdHlwZSk7XG4gICAgICAgICAgICBjb25zdCBjdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhcbiAgICAgICAgICAgICAgQ3VlLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoY3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVJZDNDdWVFbmRzKHN0YXJ0VGltZTogbnVtYmVyLCB0eXBlOiBNZXRhZGF0YVNjaGVtYSkge1xuICAgIGNvbnN0IGN1ZXMgPSB0aGlzLmlkM1RyYWNrPy5jdWVzO1xuICAgIGlmIChjdWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gY3Vlcy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV0gYXMgYW55O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VlLnR5cGUgPT09IHR5cGUgJiZcbiAgICAgICAgICBjdWUuc3RhcnRUaW1lIDwgc3RhcnRUaW1lICYmXG4gICAgICAgICAgY3VlLmVuZFRpbWUgPT09IE1BWF9DVUVfRU5EVElNRVxuICAgICAgICApIHtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQnVmZmVyRmx1c2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsXG4gICAgeyBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0eXBlIH06IEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgeyBpZDNUcmFjaywgaGxzIH0gPSB0aGlzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB7IGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsIGVuYWJsZUlEM01ldGFkYXRhQ3VlcyB9LFxuICAgIH0gPSBobHM7XG4gICAgaWYgKGlkM1RyYWNrICYmIChlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8IGVuYWJsZUlEM01ldGFkYXRhQ3VlcykpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IChjdWUpID0+XG4gICAgICAgICAgKGN1ZSBhcyBhbnkpLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmXG4gICAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IChjdWUpID0+XG4gICAgICAgICAgKGN1ZSBhcyBhbnkpLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IChjdWUpID0+XG4gICAgICAgICAgKChjdWUgYXMgYW55KS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyAmJlxuICAgICAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzKSB8fFxuICAgICAgICAgICgoY3VlIGFzIGFueSkudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuZW1zZyAmJiBlbmFibGVFbXNnTWV0YWRhdGFDdWVzKTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUN1ZXNJblJhbmdlKGlkM1RyYWNrLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBwcmVkaWNhdGUpO1xuICAgIH1cbiAgfVxuXG4gIG9uTGV2ZWxVcGRhdGVkKGV2ZW50OiBFdmVudHMuTEVWRUxfVVBEQVRFRCwgeyBkZXRhaWxzIH06IExldmVsVXBkYXRlZERhdGEpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8XG4gICAgICAhdGhpcy5obHMuY29uZmlnLmVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3Vlc1xuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCwgaWQzVHJhY2sgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkYXRlUmFuZ2VzIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgIC8vIFJlbW92ZSBjdWVzIGZyb20gdHJhY2sgbm90IGZvdW5kIGluIGRldGFpbHMuZGF0ZVJhbmdlc1xuICAgIGlmIChpZDNUcmFjaykge1xuICAgICAgY29uc3QgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihcbiAgICAgICAgKGlkKSA9PiAhaWRzLmluY2x1ZGVzKGlkKSxcbiAgICAgICk7XG4gICAgICBmb3IgKGxldCBpID0gaWRzVG9SZW1vdmUubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb25zdCBpZCA9IGlkc1RvUmVtb3ZlW2ldO1xuICAgICAgICBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBpZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBEYXRlIFJhbmdlcyBvciBkb2VzIG5vdCBoYXZlIFByb2dyYW0gRGF0ZSBUaW1lXG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIU51bWJlci5pc0Zpbml0ZShsYXN0RnJhZ21lbnQ/LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGVUaW1lT2Zmc2V0ID1cbiAgICAgIChsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lIGFzIG51bWJlcikgLyAxMDAwIC0gbGFzdEZyYWdtZW50LnN0YXJ0O1xuICAgIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaWQgPSBpZHNbaV07XG4gICAgICBjb25zdCBkYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhcbiAgICAgICAgZGF0ZVJhbmdlLnN0YXJ0RGF0ZSxcbiAgICAgICAgZGF0ZVRpbWVPZmZzZXQsXG4gICAgICApO1xuXG4gICAgICAvLyBQcm9jZXNzIERhdGVSYW5nZXMgdG8gZGV0ZXJtaW5lIGVuZC10aW1lIChrbm93biBEVVJBVElPTiwgRU5ELURBVEUsIG9yIEVORC1PTi1ORVhUKVxuICAgICAgY29uc3QgYXBwZW5kZWREYXRlUmFuZ2VDdWVzID0gZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIGNvbnN0IGN1ZXMgPSBhcHBlbmRlZERhdGVSYW5nZUN1ZXM/LmN1ZXMgfHwge307XG4gICAgICBsZXQgZHVyYXRpb25Lbm93biA9IGFwcGVuZGVkRGF0ZVJhbmdlQ3Vlcz8uZHVyYXRpb25Lbm93biB8fCBmYWxzZTtcbiAgICAgIGxldCBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IGRhdGVSYW5nZS5lbmREYXRlO1xuICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgZW5kVGltZSA9IGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhlbmREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgIGR1cmF0aW9uS25vd24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlUmFuZ2UuZW5kT25OZXh0ICYmICFkdXJhdGlvbktub3duKSB7XG4gICAgICAgIGNvbnN0IG5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzID0gaWRzLnJlZHVjZShcbiAgICAgICAgICAoY2FuZGlkYXRlRGF0ZVJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsLCBpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkICE9PSBkYXRlUmFuZ2UuaWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3RoZXJEYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG90aGVyRGF0ZVJhbmdlLmNsYXNzID09PSBkYXRlUmFuZ2UuY2xhc3MgJiZcbiAgICAgICAgICAgICAgICBvdGhlckRhdGVSYW5nZS5zdGFydERhdGUgPiBkYXRlUmFuZ2Uuc3RhcnREYXRlICYmXG4gICAgICAgICAgICAgICAgKCFjYW5kaWRhdGVEYXRlUmFuZ2UgfHxcbiAgICAgICAgICAgICAgICAgIGRhdGVSYW5nZS5zdGFydERhdGUgPCBjYW5kaWRhdGVEYXRlUmFuZ2Uuc3RhcnREYXRlKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJEYXRlUmFuZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVEYXRlUmFuZ2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICApO1xuICAgICAgICBpZiAobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3MpIHtcbiAgICAgICAgICBlbmRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKFxuICAgICAgICAgICAgbmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLFxuICAgICAgICAgICAgZGF0ZVRpbWVPZmZzZXQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgVGV4dFRyYWNrIEN1ZXMgZm9yIGVhY2ggTWV0YWRhdGFHcm91cCBJdGVtIChzZWxlY3QgRGF0ZVJhbmdlIGF0dHJpYnV0ZSlcbiAgICAgIC8vIFRoaXMgaXMgdG8gZW11bGF0ZSBTYWZhcmkgSExTIHBsYXliYWNrIGhhbmRsaW5nIG9mIERhdGVSYW5nZSB0YWdzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZGF0ZVJhbmdlLmF0dHIpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF0dHJpYnV0ZXNbal07XG4gICAgICAgIGlmICghaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNba2V5XTtcbiAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgIGlmIChkdXJhdGlvbktub3duICYmICFhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikge1xuICAgICAgICAgICAgY3VlLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChDdWUpIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGRhdGVSYW5nZS5hdHRyW2tleV07XG4gICAgICAgICAgaWYgKGlzU0NURTM1QXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBoZXhUb0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjdWUgPSBjcmVhdGVDdWVXaXRoRGF0YUZpZWxkcyhcbiAgICAgICAgICAgIEN1ZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB7IGtleSwgZGF0YSB9LFxuICAgICAgICAgICAgTWV0YWRhdGFTY2hlbWEuZGF0ZVJhbmdlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGN1ZSkge1xuICAgICAgICAgICAgY3VlLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLmlkM1RyYWNrLmFkZEN1ZShjdWUpO1xuICAgICAgICAgICAgY3Vlc1trZXldID0gY3VlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHByb2Nlc3NlZCBEYXRlUmFuZ2VzIGJ5IElEIGZvciB1cGRhdGluZyBjdWVzIHdpdGggbmV3IERhdGVSYW5nZSB0YWcgYXR0cmlidXRlc1xuICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSA9IHtcbiAgICAgICAgY3VlcyxcbiAgICAgICAgZGF0ZVJhbmdlLFxuICAgICAgICBkdXJhdGlvbktub3duLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSUQzVHJhY2tDb250cm9sbGVyO1xuIiwiaW1wb3J0IHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7XG4gIEVycm9yRGF0YSxcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF0ZW5jeUNvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50VGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBzdGFsbENvdW50OiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9sYXRlbmN5OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0aW1ldXBkYXRlSGFuZGxlciA9ICgpID0+IHRoaXMudGltZXVwZGF0ZSgpO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGdldCBsYXRlbmN5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVuY3kgfHwgMDtcbiAgfVxuXG4gIGdldCBtYXhMYXRlbmN5KCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBjb25maWcsIGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAoY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzXG4gICAgICA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb25cbiAgICAgIDogMDtcbiAgfVxuXG4gIGdldCB0YXJnZXRMYXRlbmN5KCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IGhvbGRCYWNrLCBwYXJ0SG9sZEJhY2ssIHRhcmdldGR1cmF0aW9uIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3QgeyBsaXZlU3luY0R1cmF0aW9uLCBsaXZlU3luY0R1cmF0aW9uQ291bnQsIGxvd0xhdGVuY3lNb2RlIH0gPVxuICAgICAgdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgIGlmIChcbiAgICAgIHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbiB8fFxuICAgICAgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHxcbiAgICAgIHRhcmdldExhdGVuY3kgPT09IDBcbiAgICApIHtcbiAgICAgIHRhcmdldExhdGVuY3kgPVxuICAgICAgICBsaXZlU3luY0R1cmF0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGxpdmVTeW5jRHVyYXRpb25cbiAgICAgICAgICA6IGxpdmVTeW5jRHVyYXRpb25Db3VudCAqIHRhcmdldGR1cmF0aW9uO1xuICAgIH1cbiAgICBjb25zdCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IHRhcmdldGR1cmF0aW9uO1xuICAgIGNvbnN0IGxpdmVTeW5jT25TdGFsbEluY3JlYXNlID0gMS4wO1xuICAgIHJldHVybiAoXG4gICAgICB0YXJnZXRMYXRlbmN5ICtcbiAgICAgIE1hdGgubWluKFxuICAgICAgICB0aGlzLnN0YWxsQ291bnQgKiBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSxcbiAgICAgICAgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UsXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGdldCBsaXZlU3luY1Bvc2l0aW9uKCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgY29uc3QgdGFyZ2V0TGF0ZW5jeSA9IHRoaXMudGFyZ2V0TGF0ZW5jeTtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAobGl2ZUVkZ2UgPT09IG51bGwgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gbnVsbCB8fCBsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGdlID0gbGV2ZWxEZXRhaWxzLmVkZ2U7XG4gICAgY29uc3Qgc3luY1Bvc2l0aW9uID0gbGl2ZUVkZ2UgLSB0YXJnZXRMYXRlbmN5IC0gdGhpcy5lZGdlU3RhbGxlZDtcbiAgICBjb25zdCBtaW4gPSBlZGdlIC0gbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgY29uc3QgbWF4ID1cbiAgICAgIGVkZ2UgLVxuICAgICAgKCh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCkgfHxcbiAgICAgICAgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBzeW5jUG9zaXRpb24pLCBtYXgpO1xuICB9XG5cbiAgZ2V0IGRyaWZ0KCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBsZXZlbERldGFpbHMgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZHJpZnQ7XG4gIH1cblxuICBnZXQgZWRnZVN0YWxsZWQoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAobGV2ZWxEZXRhaWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgbWF4TGV2ZWxVcGRhdGVBZ2UgPVxuICAgICAgKCh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCkgfHxcbiAgICAgICAgbGV2ZWxEZXRhaWxzLnRhcmdldGR1cmF0aW9uKSAqIDM7XG4gICAgcmV0dXJuIE1hdGgubWF4KGxldmVsRGV0YWlscy5hZ2UgLSBtYXhMZXZlbFVwZGF0ZUFnZSwgMCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBmb3J3YXJkQnVmZmVyTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBtZWRpYSwgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkUmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQubGVuZ3RoO1xuICAgIHJldHVybiAoXG4gICAgICAoYnVmZmVyZWRSYW5nZXNcbiAgICAgICAgPyBtZWRpYS5idWZmZXJlZC5lbmQoYnVmZmVyZWRSYW5nZXMgLSAxKVxuICAgICAgICA6IGxldmVsRGV0YWlscy5lZGdlKSAtIHRoaXMuY3VycmVudFRpbWVcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gICAgdGhpcy5sZXZlbERldGFpbHMgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hpbmdEYXRhLFxuICApIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGhpcy50aW1ldXBkYXRlSGFuZGxlcik7XG4gICAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLl9sYXRlbmN5ID0gbnVsbDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsVXBkYXRlZChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsXG4gICAgeyBkZXRhaWxzIH06IExldmVsVXBkYXRlZERhdGEsXG4gICkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfVxuICAgIGlmICghZGV0YWlscy5saXZlICYmIHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25FcnJvcihldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgaWYgKHRoaXMubGV2ZWxEZXRhaWxzPy5saXZlKSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5JyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0aW1ldXBkYXRlKCkge1xuICAgIGNvbnN0IHsgbWVkaWEsIGxldmVsRGV0YWlscyB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuXG4gICAgY29uc3QgbGF0ZW5jeSA9IHRoaXMuY29tcHV0ZUxhdGVuY3koKTtcbiAgICBpZiAobGF0ZW5jeSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9sYXRlbmN5ID0gbGF0ZW5jeTtcblxuICAgIC8vIEFkYXB0IHBsYXliYWNrUmF0ZSB0byBtZWV0IHRhcmdldCBsYXRlbmN5IGluIGxvdy1sYXRlbmN5IG1vZGVcbiAgICBjb25zdCB7IGxvd0xhdGVuY3lNb2RlLCBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSB9ID0gdGhpcy5jb25maWc7XG4gICAgaWYgKFxuICAgICAgIWxvd0xhdGVuY3lNb2RlIHx8XG4gICAgICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSA9PT0gMSB8fFxuICAgICAgIWxldmVsRGV0YWlscy5saXZlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldExhdGVuY3kgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKHRhcmdldExhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tVGFyZ2V0ID0gbGF0ZW5jeSAtIHRhcmdldExhdGVuY3k7XG4gICAgLy8gT25seSBhZGp1c3QgcGxheWJhY2tSYXRlIHdoZW4gd2l0aGluIG9uZSB0YXJnZXQgZHVyYXRpb24gb2YgdGFyZ2V0TGF0ZW5jeVxuICAgIC8vIGFuZCBtb3JlIHRoYW4gb25lIHNlY29uZCBmcm9tIHVuZGVyLWJ1ZmZlcmluZy5cbiAgICAvLyBQbGF5YmFjayBmdXJ0aGVyIHRoYW4gb25lIHRhcmdldCBkdXJhdGlvbiBmcm9tIHRhcmdldCBjYW4gYmUgY29uc2lkZXJlZCBEVlIgcGxheWJhY2suXG4gICAgY29uc3QgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbiA9IE1hdGgubWluKFxuICAgICAgdGhpcy5tYXhMYXRlbmN5LFxuICAgICAgdGFyZ2V0TGF0ZW5jeSArIGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbixcbiAgICApO1xuICAgIGNvbnN0IGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcblxuICAgIGlmIChcbiAgICAgIGluTGl2ZVJhbmdlICYmXG4gICAgICBkaXN0YW5jZUZyb21UYXJnZXQgPiAwLjA1ICYmXG4gICAgICB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxXG4gICAgKSB7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICBjb25zdCByYXRlID1cbiAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBkaXN0YW5jZUZyb21UYXJnZXQgLSB0aGlzLmVkZ2VTdGFsbGVkKSkpICpcbiAgICAgICAgICAgIDIwLFxuICAgICAgICApIC8gMjA7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDEsIHJhdGUpKTtcbiAgICB9IGVsc2UgaWYgKG1lZGlhLnBsYXliYWNrUmF0ZSAhPT0gMSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDApIHtcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlc3RpbWF0ZUxpdmVFZGdlKCk6IG51bWJlciB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxEZXRhaWxzIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmVkZ2UgKyBsZXZlbERldGFpbHMuYWdlO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlTGF0ZW5jeSgpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBsaXZlRWRnZSA9IHRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsaXZlRWRnZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgTWVkaWFQbGF5bGlzdCB9IGZyb20gJy4vbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB0eXBlIHsgTWVkaWFEZWNvZGluZ0luZm8gfSBmcm9tICcuLi91dGlscy9tZWRpYWNhcGFiaWxpdGllcy1oZWxwZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIExldmVsUGFyc2VkIHtcbiAgYXR0cnM6IExldmVsQXR0cmlidXRlcztcbiAgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgYml0cmF0ZTogbnVtYmVyO1xuICBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIGlkPzogbnVtYmVyO1xuICBuYW1lOiBzdHJpbmc7XG4gIHRleHRDb2RlYz86IHN0cmluZztcbiAgdW5rbm93bkNvZGVjcz86IHN0cmluZ1tdO1xuICB1cmw6IHN0cmluZztcbiAgdmlkZW9Db2RlYz86IHN0cmluZztcbiAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGV2ZWxBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0ckxpc3Qge1xuICAnQUxMT1dFRC1DUEMnPzogc3RyaW5nO1xuICBBVURJTz86IHN0cmluZztcbiAgJ0FWRVJBR0UtQkFORFdJRFRIJz86IHN0cmluZztcbiAgQkFORFdJRFRIPzogc3RyaW5nO1xuICAnQ0xPU0VELUNBUFRJT05TJz86IHN0cmluZztcbiAgQ09ERUNTPzogc3RyaW5nO1xuICAnRlJBTUUtUkFURSc/OiBzdHJpbmc7XG4gICdIRENQLUxFVkVMJz86ICdUWVBFLTAnIHwgJ1RZUEUtMScgfCAnTk9ORSc7XG4gICdQQVRIV0FZLUlEJz86IHN0cmluZztcbiAgUkVTT0xVVElPTj86IHN0cmluZztcbiAgU0NPUkU/OiBzdHJpbmc7XG4gICdTVEFCTEUtVkFSSUFOVC1JRCc/OiBzdHJpbmc7XG4gIFNVQlRJVExFUz86IHN0cmluZztcbiAgJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnPzogc3RyaW5nO1xuICBWSURFTz86IHN0cmluZztcbiAgJ1ZJREVPLVJBTkdFJz86IFZpZGVvUmFuZ2U7XG59XG5cbmV4cG9ydCBjb25zdCBIZGNwTGV2ZWxzID0gWydOT05FJywgJ1RZUEUtMCcsICdUWVBFLTEnLCBudWxsXSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIEhkY3BMZXZlbCA9ICh0eXBlb2YgSGRjcExldmVscylbbnVtYmVyXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGRjcExldmVsKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBIZGNwTGV2ZWwge1xuICByZXR1cm4gSGRjcExldmVscy5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxuXG5leHBvcnQgY29uc3QgVmlkZW9SYW5nZVZhbHVlcyA9IFsnU0RSJywgJ1BRJywgJ0hMRyddIGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgVmlkZW9SYW5nZSA9ICh0eXBlb2YgVmlkZW9SYW5nZVZhbHVlcylbbnVtYmVyXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmlkZW9SYW5nZSh2YWx1ZTogYW55KTogdmFsdWUgaXMgVmlkZW9SYW5nZSB7XG4gIHJldHVybiAhIXZhbHVlICYmIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbn1cblxuZXhwb3J0IHR5cGUgVmFyaWFibGVNYXAgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG5leHBvcnQgY29uc3QgZW51bSBIbHNTa2lwIHtcbiAgTm8gPSAnJyxcbiAgWWVzID0gJ1lFUycsXG4gIHYyID0gJ3YyJyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNraXBWYWx1ZShkZXRhaWxzOiBMZXZlbERldGFpbHMsIG1zbj86IG51bWJlcik6IEhsc1NraXAge1xuICBjb25zdCB7IGNhblNraXBVbnRpbCwgY2FuU2tpcERhdGVSYW5nZXMsIGVuZFNOIH0gPSBkZXRhaWxzO1xuICBjb25zdCBzbkNoYW5nZUdvYWwgPSBtc24gIT09IHVuZGVmaW5lZCA/IG1zbiAtIGVuZFNOIDogMDtcbiAgaWYgKGNhblNraXBVbnRpbCAmJiBzbkNoYW5nZUdvYWwgPCBjYW5Ta2lwVW50aWwpIHtcbiAgICBpZiAoY2FuU2tpcERhdGVSYW5nZXMpIHtcbiAgICAgIHJldHVybiBIbHNTa2lwLnYyO1xuICAgIH1cbiAgICByZXR1cm4gSGxzU2tpcC5ZZXM7XG4gIH1cbiAgcmV0dXJuIEhsc1NraXAuTm87XG59XG5cbmV4cG9ydCBjbGFzcyBIbHNVcmxQYXJhbWV0ZXJzIHtcbiAgbXNuPzogbnVtYmVyO1xuICBwYXJ0PzogbnVtYmVyO1xuICBza2lwPzogSGxzU2tpcDtcblxuICBjb25zdHJ1Y3Rvcihtc24/OiBudW1iZXIsIHBhcnQ/OiBudW1iZXIsIHNraXA/OiBIbHNTa2lwKSB7XG4gICAgdGhpcy5tc24gPSBtc247XG4gICAgdGhpcy5wYXJ0ID0gcGFydDtcbiAgICB0aGlzLnNraXAgPSBza2lwO1xuICB9XG5cbiAgYWRkRGlyZWN0aXZlcyh1cmk6IHN0cmluZyk6IHN0cmluZyB8IG5ldmVyIHtcbiAgICBjb25zdCB1cmw6IFVSTCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19za2lwJywgdGhpcy5za2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMZXZlbCB7XG4gIHB1YmxpYyByZWFkb25seSBfYXR0cnM6IExldmVsQXR0cmlidXRlc1tdO1xuICBwdWJsaWMgcmVhZG9ubHkgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwdWJsaWMgcmVhZG9ubHkgYml0cmF0ZTogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgY29kZWNTZXQ6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHVybDogc3RyaW5nW107XG4gIHB1YmxpYyByZWFkb25seSBmcmFtZVJhdGU6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgcHVibGljIHJlYWRvbmx5IHdpZHRoOiBudW1iZXI7XG4gIHB1YmxpYyBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xuICBwdWJsaWMgZnJhZ21lbnRFcnJvcjogbnVtYmVyID0gMDtcbiAgcHVibGljIGxvYWRFcnJvcjogbnVtYmVyID0gMDtcbiAgcHVibGljIGxvYWRlZD86IHsgYnl0ZXM6IG51bWJlcjsgZHVyYXRpb246IG51bWJlciB9O1xuICBwdWJsaWMgcmVhbEJpdHJhdGU6IG51bWJlciA9IDA7XG4gIHB1YmxpYyBzdXBwb3J0ZWRQcm9taXNlPzogUHJvbWlzZTxNZWRpYURlY29kaW5nSW5mbz47XG4gIHB1YmxpYyBzdXBwb3J0ZWRSZXN1bHQ/OiBNZWRpYURlY29kaW5nSW5mbztcbiAgcHJpdmF0ZSBfYXZnQml0cmF0ZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfYXVkaW9Hcm91cHM/OiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdO1xuICBwcml2YXRlIF9zdWJ0aXRsZUdyb3Vwcz86IChzdHJpbmcgfCB1bmRlZmluZWQpW107XG4gIC8vIERlcHJlY2F0ZWQgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgcHJpdmF0ZSByZWFkb25seSBfdXJsSWQ6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGV2ZWxQYXJzZWQgfCBNZWRpYVBsYXlsaXN0KSB7XG4gICAgdGhpcy51cmwgPSBbZGF0YS51cmxdO1xuICAgIHRoaXMuX2F0dHJzID0gW2RhdGEuYXR0cnNdO1xuICAgIHRoaXMuYml0cmF0ZSA9IGRhdGEuYml0cmF0ZTtcbiAgICBpZiAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBkYXRhLmlkIHx8IDA7XG4gICAgdGhpcy5uYW1lID0gZGF0YS5uYW1lO1xuICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoIHx8IDA7XG4gICAgdGhpcy5oZWlnaHQgPSBkYXRhLmhlaWdodCB8fCAwO1xuICAgIHRoaXMuZnJhbWVSYXRlID0gZGF0YS5hdHRycy5vcHRpb25hbEZsb2F0KCdGUkFNRS1SQVRFJywgMCk7XG4gICAgdGhpcy5fYXZnQml0cmF0ZSA9IGRhdGEuYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJyk7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gZGF0YS5hdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IGRhdGEudmlkZW9Db2RlYztcbiAgICB0aGlzLmNvZGVjU2V0ID0gW2RhdGEudmlkZW9Db2RlYywgZGF0YS5hdWRpb0NvZGVjXVxuICAgICAgLmZpbHRlcigoYykgPT4gISFjKVxuICAgICAgLm1hcCgoczogc3RyaW5nKSA9PiBzLnN1YnN0cmluZygwLCA0KSlcbiAgICAgIC5qb2luKCcsJyk7XG4gICAgdGhpcy5hZGRHcm91cElkKCdhdWRpbycsIGRhdGEuYXR0cnMuQVVESU8pO1xuICAgIHRoaXMuYWRkR3JvdXBJZCgndGV4dCcsIGRhdGEuYXR0cnMuU1VCVElUTEVTKTtcbiAgfVxuXG4gIGdldCBtYXhCaXRyYXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmVhbEJpdHJhdGUsIHRoaXMuYml0cmF0ZSk7XG4gIH1cblxuICBnZXQgYXZlcmFnZUJpdHJhdGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fYXZnQml0cmF0ZSB8fCB0aGlzLnJlYWxCaXRyYXRlIHx8IHRoaXMuYml0cmF0ZTtcbiAgfVxuXG4gIGdldCBhdHRycygpOiBMZXZlbEF0dHJpYnV0ZXMge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc1swXTtcbiAgfVxuXG4gIGdldCBjb2RlY3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5DT0RFQ1MgfHwgJyc7XG4gIH1cblxuICBnZXQgcGF0aHdheUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnNbJ1BBVEhXQVktSUQnXSB8fCAnLic7XG4gIH1cblxuICBnZXQgdmlkZW9SYW5nZSgpOiBWaWRlb1JhbmdlIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snVklERU8tUkFOR0UnXSB8fCAnU0RSJztcbiAgfVxuXG4gIGdldCBzY29yZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLm9wdGlvbmFsRmxvYXQoJ1NDT1JFJywgMCk7XG4gIH1cblxuICBnZXQgdXJpKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudXJsWzBdIHx8ICcnO1xuICB9XG5cbiAgaGFzQXVkaW9Hcm91cChncm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fYXVkaW9Hcm91cHMsIGdyb3VwSWQpO1xuICB9XG5cbiAgaGFzU3VidGl0bGVHcm91cChncm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fc3VidGl0bGVHcm91cHMsIGdyb3VwSWQpO1xuICB9XG5cbiAgZ2V0IGF1ZGlvR3JvdXBzKCk6IChzdHJpbmcgfCB1bmRlZmluZWQpW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9hdWRpb0dyb3VwcztcbiAgfVxuXG4gIGdldCBzdWJ0aXRsZUdyb3VwcygpOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVHcm91cHM7XG4gIH1cblxuICBhZGRHcm91cElkKHR5cGU6IHN0cmluZywgZ3JvdXBJZDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFncm91cElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBsZXQgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcztcbiAgICAgIGlmICghYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgYXVkaW9Hcm91cHMgPSB0aGlzLl9hdWRpb0dyb3VwcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGF1ZGlvR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzLnB1c2goZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGxldCBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICAgICAgaWYgKCFzdWJ0aXRsZUdyb3Vwcykge1xuICAgICAgICBzdWJ0aXRsZUdyb3VwcyA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoc3VidGl0bGVHcm91cHMuaW5kZXhPZihncm91cElkKSA9PT0gLTEpIHtcbiAgICAgICAgc3VidGl0bGVHcm91cHMucHVzaChncm91cElkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXByZWNhdGVkIG1ldGhvZHMgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgZ2V0IHVybElkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBzZXQgdXJsSWQodmFsdWU6IG51bWJlcikge31cblxuICBnZXQgYXVkaW9Hcm91cElkcygpOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0dyb3VwcyA/IFt0aGlzLmF1ZGlvR3JvdXBJZF0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgdGV4dEdyb3VwSWRzKCk6IChzdHJpbmcgfCB1bmRlZmluZWQpW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN1YnRpdGxlR3JvdXBzID8gW3RoaXMudGV4dEdyb3VwSWRdIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvR3JvdXBzPy5bMF07XG4gIH1cblxuICBnZXQgdGV4dEdyb3VwSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0aXRsZUdyb3Vwcz8uWzBdO1xuICB9XG5cbiAgYWRkRmFsbGJhY2soKSB7fVxufVxuXG5mdW5jdGlvbiBoYXNHcm91cChcbiAgZ3JvdXBzOiAoc3RyaW5nIHwgdW5kZWZpbmVkKVtdIHwgdW5kZWZpbmVkLFxuICBncm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgaWYgKCFncm91cElkIHx8ICFncm91cHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpICE9PSAtMTtcbn1cbiIsIi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggcGxheWxpc3Qgc2xpZGluZyBhbmQgZHJpZnRcbiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vbG9hZGVyL2RhdGUtcmFuZ2UnO1xuXG50eXBlIEZyYWdtZW50SW50ZXJzZWN0aW9uID0gKG9sZEZyYWc6IEZyYWdtZW50LCBuZXdGcmFnOiBGcmFnbWVudCkgPT4gdm9pZDtcbnR5cGUgUGFydEludGVyc2VjdGlvbiA9IChvbGRQYXJ0OiBQYXJ0LCBuZXdQYXJ0OiBQYXJ0KSA9PiB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUFRTKFxuICBmcmFnbWVudHM6IEZyYWdtZW50W10sXG4gIGZyb21JZHg6IG51bWJlcixcbiAgdG9JZHg6IG51bWJlcixcbik6IHZvaWQge1xuICBjb25zdCBmcmFnRnJvbSA9IGZyYWdtZW50c1tmcm9tSWR4XTtcbiAgY29uc3QgZnJhZ1RvID0gZnJhZ21lbnRzW3RvSWR4XTtcbiAgdXBkYXRlRnJvbVRvUFRTKGZyYWdGcm9tLCBmcmFnVG8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb206IEZyYWdtZW50LCBmcmFnVG86IEZyYWdtZW50KSB7XG4gIGNvbnN0IGZyYWdUb1BUUyA9IGZyYWdUby5zdGFydFBUUyBhcyBudW1iZXI7XG4gIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZnJhZ1RvUFRTKSkge1xuICAgIC8vIHVwZGF0ZSBmcmFnbWVudCBkdXJhdGlvbi5cbiAgICAvLyBpdCBoZWxwcyB0byBmaXggZHJpZnRzIGJldHdlZW4gcGxheWxpc3QgcmVwb3J0ZWQgZHVyYXRpb24gYW5kIGZyYWdtZW50IHJlYWwgZHVyYXRpb25cbiAgICBsZXQgZHVyYXRpb246IG51bWJlciA9IDA7XG4gICAgbGV0IGZyYWc6IEZyYWdtZW50O1xuICAgIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgICAgZHVyYXRpb24gPSBmcmFnVG9QVFMgLSBmcmFnRnJvbS5zdGFydDtcbiAgICAgIGZyYWcgPSBmcmFnRnJvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSBmcmFnRnJvbS5zdGFydCAtIGZyYWdUb1BUUztcbiAgICAgIGZyYWcgPSBmcmFnVG87XG4gICAgfVxuICAgIGlmIChmcmFnLmR1cmF0aW9uICE9PSBkdXJhdGlvbikge1xuICAgICAgZnJhZy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIH1cbiAgICAvLyB3ZSBkb250IGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIH0gZWxzZSBpZiAoZnJhZ1RvLnNuID4gZnJhZ0Zyb20uc24pIHtcbiAgICBjb25zdCBjb250aWd1b3VzID0gZnJhZ0Zyb20uY2MgPT09IGZyYWdUby5jYztcbiAgICAvLyBUT0RPOiBXaXRoIHBhcnQtbG9hZGluZyBlbmQvZHVyYXRpb25zIHdlIG5lZWQgdG8gY29uZmlybSB0aGUgd2hvbGUgZnJhZ21lbnQgaXMgbG9hZGVkIGJlZm9yZSB1c2luZyAob3Igc2V0dGluZykgbWluRW5kUFRTXG4gICAgaWYgKGNvbnRpZ3VvdXMgJiYgZnJhZ0Zyb20ubWluRW5kUFRTKSB7XG4gICAgICBmcmFnVG8uc3RhcnQgPSBmcmFnRnJvbS5zdGFydCArIChmcmFnRnJvbS5taW5FbmRQVFMgLSBmcmFnRnJvbS5zdGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgZnJhZ0Zyb20uZHVyYXRpb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyYWdUby5zdGFydCA9IE1hdGgubWF4KGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvLmR1cmF0aW9uLCAwKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlRnJhZ1BUU0RUUyhcbiAgZGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkLFxuICBmcmFnOiBGcmFnbWVudCxcbiAgc3RhcnRQVFM6IG51bWJlcixcbiAgZW5kUFRTOiBudW1iZXIsXG4gIHN0YXJ0RFRTOiBudW1iZXIsXG4gIGVuZERUUzogbnVtYmVyLFxuKTogbnVtYmVyIHtcbiAgY29uc3QgcGFyc2VkTWVkaWFEdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBsZXQgbWluRW5kUFRTID0gZW5kUFRTO1xuICBjb25zdCBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTIGFzIG51bWJlcjtcbiAgY29uc3QgZnJhZ0VuZFB0cyA9IGZyYWcuZW5kUFRTIGFzIG51bWJlcjtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnU3RhcnRQdHMpKSB7XG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgY29uc3QgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnU3RhcnRQdHMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhZy5kZWx0YVBUUyBhcyBudW1iZXIpKSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gZGVsdGFQVFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcuZGVsdGFQVFMgPSBNYXRoLm1heChkZWx0YVBUUywgZnJhZy5kZWx0YVBUUyBhcyBudW1iZXIpO1xuICAgIH1cblxuICAgIG1heFN0YXJ0UFRTID0gTWF0aC5tYXgoc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnRQVFMgPSBNYXRoLm1pbihzdGFydFBUUywgZnJhZ1N0YXJ0UHRzKTtcbiAgICBzdGFydERUUyA9IE1hdGgubWluKHN0YXJ0RFRTLCBmcmFnLnN0YXJ0RFRTKTtcblxuICAgIG1pbkVuZFBUUyA9IE1hdGgubWluKGVuZFBUUywgZnJhZ0VuZFB0cyk7XG4gICAgZW5kUFRTID0gTWF0aC5tYXgoZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmREVFMgPSBNYXRoLm1heChlbmREVFMsIGZyYWcuZW5kRFRTKTtcbiAgfVxuXG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgIGZyYWcuc3RhcnQgPSBzdGFydFBUUztcbiAgfVxuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gIGZyYWcubWluRW5kUFRTID0gbWluRW5kUFRTO1xuICBmcmFnLmVuZERUUyA9IGVuZERUUztcblxuICBjb25zdCBzbiA9IGZyYWcuc24gYXMgbnVtYmVyOyAvLyAnaW5pdFNlZ21lbnQnXG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgaTtcbiAgY29uc3QgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gIH1cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgfVxuXG4gIGRldGFpbHMuUFRTS25vd24gPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgcmV0dXJuIGRyaWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZXRhaWxzKFxuICBvbGREZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlscyxcbik6IHZvaWQge1xuICAvLyBUcmFjayB0aGUgbGFzdCBpbml0U2VnbWVudCBwcm9jZXNzZWQuIEluaXRpYWxpemUgaXQgdG8gdGhlIGxhc3Qgb25lIG9uIHRoZSB0aW1lbGluZS5cbiAgbGV0IGN1cnJlbnRJbml0U2VnbWVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSBvbGRGcmFnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvbGRJbml0ID0gb2xkRnJhZ21lbnRzW2ldLmluaXRTZWdtZW50O1xuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgLy8gcHJldmVudCBQVFMgYW5kIGR1cmF0aW9uIGZyb20gYmVpbmcgYWRqdXN0ZWQgb24gdGhlIG5leHQgaGludFxuICAgIGRlbGV0ZSBvbGREZXRhaWxzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIH1cbiAgLy8gY2hlY2sgaWYgb2xkL25ldyBwbGF5bGlzdHMgaGF2ZSBmcmFnbWVudHMgaW4gY29tbW9uXG4gIC8vIGxvb3AgdGhyb3VnaCBvdmVybGFwcGluZyBTTiBhbmQgdXBkYXRlIHN0YXJ0UFRTICwgY2MsIGFuZCBkdXJhdGlvbiBpZiBhbnkgZm91bmRcbiAgbGV0IGNjT2Zmc2V0ID0gMDtcbiAgbGV0IFBUU0ZyYWc7XG4gIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIG9sZERldGFpbHMsXG4gICAgbmV3RGV0YWlscyxcbiAgICAob2xkRnJhZzogRnJhZ21lbnQsIG5ld0ZyYWc6IEZyYWdtZW50KSA9PiB7XG4gICAgICBpZiAob2xkRnJhZy5yZWx1cmwpIHtcbiAgICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgICAvLyBJdCBtYXliZSBiZSBvZmYgYnkgMSBpZiBpdCB3YXMgY3JlYXRlZCBiZWZvcmUgYW55IHBhcnRzIG9yIGRpc2NvbnRpbnVpdHkgdGFncyB3ZXJlIGFwcGVuZGVkIHRvIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHBsYXlsaXN0LlxuICAgICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUob2xkRnJhZy5zdGFydFBUUykgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKG9sZEZyYWcuZW5kUFRTKVxuICAgICAgKSB7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnQgPSBuZXdGcmFnLnN0YXJ0UFRTID0gb2xkRnJhZy5zdGFydFBUUyBhcyBudW1iZXI7XG4gICAgICAgIG5ld0ZyYWcuc3RhcnREVFMgPSBvbGRGcmFnLnN0YXJ0RFRTO1xuICAgICAgICBuZXdGcmFnLm1heFN0YXJ0UFRTID0gb2xkRnJhZy5tYXhTdGFydFBUUztcblxuICAgICAgICBuZXdGcmFnLmVuZFBUUyA9IG9sZEZyYWcuZW5kUFRTO1xuICAgICAgICBuZXdGcmFnLmVuZERUUyA9IG9sZEZyYWcuZW5kRFRTO1xuICAgICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgICBuZXdGcmFnLmR1cmF0aW9uID1cbiAgICAgICAgICAob2xkRnJhZy5lbmRQVFMgYXMgbnVtYmVyKSAtIChvbGRGcmFnLnN0YXJ0UFRTIGFzIG51bWJlcik7XG5cbiAgICAgICAgaWYgKG5ld0ZyYWcuZHVyYXRpb24pIHtcbiAgICAgICAgICBQVFNGcmFnID0gbmV3RnJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBUUyBpcyBrbm93biB3aGVuIGFueSBzZWdtZW50IGhhcyBzdGFydFBUUyBhbmQgZW5kUFRTXG4gICAgICAgIG5ld0RldGFpbHMuUFRTS25vd24gPSBuZXdEZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5ld0ZyYWcuZWxlbWVudGFyeVN0cmVhbXMgPSBvbGRGcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgbmV3RnJhZy5sb2FkZXIgPSBvbGRGcmFnLmxvYWRlcjtcbiAgICAgIG5ld0ZyYWcuc3RhdHMgPSBvbGRGcmFnLnN0YXRzO1xuICAgICAgaWYgKG9sZEZyYWcuaW5pdFNlZ21lbnQpIHtcbiAgICAgICAgbmV3RnJhZy5pbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSxcbiAgKTtcblxuICBpZiAoY3VycmVudEluaXRTZWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ21lbnRzVG9DaGVjayA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50XG4gICAgICA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludClcbiAgICAgIDogbmV3RGV0YWlscy5mcmFnbWVudHM7XG4gICAgZnJhZ21lbnRzVG9DaGVjay5mb3JFYWNoKChmcmFnKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGZyYWcgJiZcbiAgICAgICAgKCFmcmFnLmluaXRTZWdtZW50IHx8XG4gICAgICAgICAgZnJhZy5pbml0U2VnbWVudC5yZWx1cmwgPT09IGN1cnJlbnRJbml0U2VnbWVudD8ucmVsdXJsKVxuICAgICAgKSB7XG4gICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAobmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMpIHtcbiAgICBuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gbmV3RGV0YWlscy5mcmFnbWVudHMuc29tZSgoZnJhZykgPT4gIWZyYWcpO1xuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBsb2dnZXIud2FybihcbiAgICAgICAgJ1tsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdCcsXG4gICAgICApO1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzOyBpLS07ICkge1xuICAgICAgICBuZXdEZXRhaWxzLmZyYWdtZW50cy5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgbmV3RGV0YWlscy5zdGFydFNOID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uc24gYXMgbnVtYmVyO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMoXG4gICAgICAgIG9sZERldGFpbHMuZGF0ZVJhbmdlcyxcbiAgICAgICAgbmV3RGV0YWlscy5kYXRlUmFuZ2VzLFxuICAgICAgICBuZXdEZXRhaWxzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoY2NPZmZzZXQpIHtcbiAgICBsb2dnZXIud2FybignZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gIH1cblxuICAvLyBNZXJnZSBwYXJ0c1xuICBtYXBQYXJ0SW50ZXJzZWN0aW9uKFxuICAgIG9sZERldGFpbHMucGFydExpc3QsXG4gICAgbmV3RGV0YWlscy5wYXJ0TGlzdCxcbiAgICAob2xkUGFydDogUGFydCwgbmV3UGFydDogUGFydCkgPT4ge1xuICAgICAgbmV3UGFydC5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZFBhcnQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBuZXdQYXJ0LnN0YXRzID0gb2xkUGFydC5zdGF0cztcbiAgICB9LFxuICApO1xuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMoXG4gICAgICBuZXdEZXRhaWxzLFxuICAgICAgUFRTRnJhZyxcbiAgICAgIFBUU0ZyYWcuc3RhcnRQVFMsXG4gICAgICBQVFNGcmFnLmVuZFBUUyxcbiAgICAgIFBUU0ZyYWcuc3RhcnREVFMsXG4gICAgICBQVFNGcmFnLmVuZERUUyxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGVuc3VyZSB0aGF0IGRlbHRhIGlzIHdpdGhpbiBvbGRGcmFnbWVudHMgcmFuZ2VcbiAgICAvLyBhbHNvIGFkanVzdCBzbGlkaW5nIGluIGNhc2UgZGVsdGEgaXMgMCAod2UgY291bGQgaGF2ZSBvbGQ9WzUwLTYwXSBhbmQgbmV3PW9sZD1bNTAtNjFdKVxuICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBhbHNvIG5lZWQgdG8gYWRqdXN0IHN0YXJ0IG9mZnNldCBvZiBhbGwgZnJhZ21lbnRzXG4gICAgYWRqdXN0U2xpZGluZyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKTtcbiAgfVxuXG4gIGlmIChuZXdGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgbmV3RGV0YWlscy50b3RhbGR1cmF0aW9uID0gbmV3RGV0YWlscy5lZGdlIC0gbmV3RnJhZ21lbnRzWzBdLnN0YXJ0O1xuICB9XG5cbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IG9sZERldGFpbHMuZHJpZnRTdGFydFRpbWU7XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgY29uc3QgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgaWYgKG5ld0RldGFpbHMuYWR2YW5jZWQgJiYgYWR2YW5jZWREYXRlVGltZSkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGF0ZVJhbmdlcyhcbiAgb2xkRGF0ZVJhbmdlczogUmVjb3JkPHN0cmluZywgRGF0ZVJhbmdlPixcbiAgZGVsdGFEYXRlUmFuZ2VzOiBSZWNvcmQ8c3RyaW5nLCBEYXRlUmFuZ2U+LFxuICByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCxcbik6IFJlY29yZDxzdHJpbmcsIERhdGVSYW5nZT4ge1xuICBjb25zdCBkYXRlUmFuZ2VzID0gT2JqZWN0LmFzc2lnbih7fSwgb2xkRGF0ZVJhbmdlcyk7XG4gIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgZGVsZXRlIGRhdGVSYW5nZXNbaWRdO1xuICAgIH0pO1xuICB9XG4gIE9iamVjdC5rZXlzKGRlbHRhRGF0ZVJhbmdlcykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjb25zdCBkYXRlUmFuZ2UgPSBuZXcgRGF0ZVJhbmdlKGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0ciwgZGF0ZVJhbmdlc1tpZF0pO1xuICAgIGlmIChkYXRlUmFuZ2UuaXNWYWxpZCkge1xuICAgICAgZGF0ZVJhbmdlc1tpZF0gPSBkYXRlUmFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgSWdub3JpbmcgaW52YWxpZCBQbGF5bGlzdCBEZWx0YSBVcGRhdGUgREFURVJBTkdFIHRhZzogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGRlbHRhRGF0ZVJhbmdlc1tpZF0uYXR0cixcbiAgICAgICAgKX1cImAsXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRlUmFuZ2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwUGFydEludGVyc2VjdGlvbihcbiAgb2xkUGFydHM6IFBhcnRbXSB8IG51bGwsXG4gIG5ld1BhcnRzOiBQYXJ0W10gfCBudWxsLFxuICBpbnRlcnNlY3Rpb25GbjogUGFydEludGVyc2VjdGlvbixcbikge1xuICBpZiAob2xkUGFydHMgJiYgbmV3UGFydHMpIHtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvbGRQYXJ0cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IG9sZFBhcnQgPSBvbGRQYXJ0c1tpXTtcbiAgICAgIGNvbnN0IG5ld1BhcnQgPSBuZXdQYXJ0c1tpICsgZGVsdGFdO1xuICAgICAgaWYgKFxuICAgICAgICBvbGRQYXJ0ICYmXG4gICAgICAgIG5ld1BhcnQgJiZcbiAgICAgICAgb2xkUGFydC5pbmRleCA9PT0gbmV3UGFydC5pbmRleCAmJlxuICAgICAgICBvbGRQYXJ0LmZyYWdtZW50LnNuID09PSBuZXdQYXJ0LmZyYWdtZW50LnNuXG4gICAgICApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkUGFydCwgbmV3UGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YS0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwRnJhZ21lbnRJbnRlcnNlY3Rpb24oXG4gIG9sZERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgbmV3RGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBpbnRlcnNlY3Rpb25GbjogRnJhZ21lbnRJbnRlcnNlY3Rpb24sXG4pOiB2b2lkIHtcbiAgY29uc3Qgc2tpcHBlZFNlZ21lbnRzID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7XG4gIGNvbnN0IHN0YXJ0ID1cbiAgICBNYXRoLm1heChvbGREZXRhaWxzLnN0YXJ0U04sIG5ld0RldGFpbHMuc3RhcnRTTikgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGVuZCA9XG4gICAgKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICtcbiAgICAoc2tpcHBlZFNlZ21lbnRzXG4gICAgICA/IG5ld0RldGFpbHMuZW5kU05cbiAgICAgIDogTWF0aC5taW4ob2xkRGV0YWlscy5lbmRTTiwgbmV3RGV0YWlscy5lbmRTTikpIC1cbiAgICBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50XG4gICAgPyBuZXdEZXRhaWxzLmZyYWdtZW50cy5jb25jYXQobmV3RGV0YWlscy5mcmFnbWVudEhpbnQpXG4gICAgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3Qgb2xkRnJhZ3MgPSBvbGREZXRhaWxzLmZyYWdtZW50SGludFxuICAgID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KVxuICAgIDogb2xkRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgY29uc3Qgb2xkRnJhZyA9IG9sZEZyYWdzW2RlbHRhICsgaV07XG4gICAgbGV0IG5ld0ZyYWcgPSBuZXdGcmFnc1tpXTtcbiAgICBpZiAoc2tpcHBlZFNlZ21lbnRzICYmICFuZXdGcmFnICYmIGkgPCBza2lwcGVkU2VnbWVudHMpIHtcbiAgICAgIC8vIEZpbGwgaW4gc2tpcHBlZCBzZWdtZW50cyBpbiBkZWx0YSBwbGF5bGlzdFxuICAgICAgbmV3RnJhZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzW2ldID0gb2xkRnJhZztcbiAgICB9XG4gICAgaWYgKG9sZEZyYWcgJiYgbmV3RnJhZykge1xuICAgICAgaW50ZXJzZWN0aW9uRm4ob2xkRnJhZywgbmV3RnJhZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RTbGlkaW5nKFxuICBvbGREZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIG5ld0RldGFpbHM6IExldmVsRGV0YWlscyxcbik6IHZvaWQge1xuICBjb25zdCBkZWx0YSA9XG4gICAgbmV3RGV0YWlscy5zdGFydFNOICsgbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHMgLSBvbGREZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IG9sZEZyYWdtZW50cyA9IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoZGVsdGEgPCAwIHx8IGRlbHRhID49IG9sZEZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWRkU2xpZGluZyhuZXdEZXRhaWxzLCBvbGRGcmFnbWVudHNbZGVsdGFdLnN0YXJ0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNsaWRpbmcoZGV0YWlsczogTGV2ZWxEZXRhaWxzLCBzdGFydDogbnVtYmVyKSB7XG4gIGlmIChzdGFydCkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKFxuICBuZXdEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGRpc3RhbmNlVG9MaXZlRWRnZU1zOiBudW1iZXIgPSBJbmZpbml0eSxcbik6IG51bWJlciB7XG4gIGxldCByZWxvYWRJbnRlcnZhbCA9IDEwMDAgKiBuZXdEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuXG4gIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAvLyBVc2UgbGFzdCBzZWdtZW50IGR1cmF0aW9uIHdoZW4gc2hvcnRlciB0aGFuIHRhcmdldCBkdXJhdGlvbiBhbmQgbmVhciBsaXZlIGVkZ2VcbiAgICBjb25zdCBmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA9IDQ7XG4gICAgaWYgKFxuICAgICAgZnJhZ21lbnRzLmxlbmd0aCAmJlxuICAgICAgcmVsb2FkSW50ZXJ2YWwgKiBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA+IGRpc3RhbmNlVG9MaXZlRWRnZU1zXG4gICAgKSB7XG4gICAgICBjb25zdCBsYXN0U2VnbWVudER1cmF0aW9uID1cbiAgICAgICAgZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHJlbG9hZEludGVydmFsID0gbGFzdFNlZ21lbnREdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgucm91bmQocmVsb2FkSW50ZXJ2YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRXaXRoU04oXG4gIGxldmVsOiBMZXZlbCxcbiAgc246IG51bWJlcixcbiAgZnJhZ0N1cnJlbnQ6IEZyYWdtZW50IHwgbnVsbCxcbik6IEZyYWdtZW50IHwgbnVsbCB7XG4gIGlmICghbGV2ZWw/LmRldGFpbHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICBsZXQgZnJhZ21lbnQ6IEZyYWdtZW50IHwgdW5kZWZpbmVkID1cbiAgICBsZXZlbERldGFpbHMuZnJhZ21lbnRzW3NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICBpZiAoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgZnJhZ21lbnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRIaW50O1xuICBpZiAoZnJhZ21lbnQgJiYgZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGlmIChzbiA8IGxldmVsRGV0YWlscy5zdGFydFNOICYmIGZyYWdDdXJyZW50ICYmIGZyYWdDdXJyZW50LnNuID09PSBzbikge1xuICAgIHJldHVybiBmcmFnQ3VycmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnRXaXRoKFxuICBsZXZlbDogTGV2ZWwsXG4gIHNuOiBudW1iZXIsXG4gIHBhcnRJbmRleDogbnVtYmVyLFxuKTogUGFydCB8IG51bGwge1xuICBpZiAoIWxldmVsPy5kZXRhaWxzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRQYXJ0KGxldmVsLmRldGFpbHM/LnBhcnRMaXN0LCBzbiwgcGFydEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJ0KFxuICBwYXJ0TGlzdDogUGFydFtdIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgc246IG51bWJlcixcbiAgcGFydEluZGV4OiBudW1iZXIsXG4pOiBQYXJ0IHwgbnVsbCB7XG4gIGlmIChwYXJ0TGlzdCkge1xuICAgIGZvciAobGV0IGkgPSBwYXJ0TGlzdC5sZW5ndGg7IGktLTsgKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpZiAocGFydC5pbmRleCA9PT0gcGFydEluZGV4ICYmIHBhcnQuZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzOiBMZXZlbFtdKSB7XG4gIGxldmVscy5mb3JFYWNoKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB7IGRldGFpbHMgfSA9IGxldmVsO1xuICAgIGlmIChkZXRhaWxzPy5mcmFnbWVudHMpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgIGZyYWdtZW50LmxldmVsID0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgTG9hZFBvbGljeSwgTG9hZGVyQ29uZmlnLCBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEVycm9yRGF0YSB9IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvYWRlclJlc3BvbnNlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVGltZW91dEVycm9yKGVycm9yOiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcoXG4gIGxvYWRQb2xpY3k6IExvYWRQb2xpY3ksXG4gIGVycm9yOiBFcnJvckRhdGEsXG4pOiBSZXRyeUNvbmZpZyB8IG51bGwge1xuICBjb25zdCBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvcik7XG4gIHJldHVybiBsb2FkUG9saWN5LmRlZmF1bHRbYCR7aXNUaW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJ31SZXRyeWBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShcbiAgcmV0cnlDb25maWc6IFJldHJ5Q29uZmlnLFxuICByZXRyeUNvdW50OiBudW1iZXIsXG4pOiBudW1iZXIge1xuICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmIGNhcHBlZCB0byBtYXggcmV0cnkgZGVsYXlcbiAgY29uc3QgYmFja29mZkZhY3RvciA9XG4gICAgcmV0cnlDb25maWcuYmFja29mZiA9PT0gJ2xpbmVhcicgPyAxIDogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBiYWNrb2ZmRmFjdG9yICogcmV0cnlDb25maWcucmV0cnlEZWxheU1zLFxuICAgIHJldHJ5Q29uZmlnLm1heFJldHJ5RGVsYXlNcyxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoXG4gIGxvZGVyQ29uZmlnOiBMb2FkZXJDb25maWcsXG4pOiBMb2FkZXJDb25maWcge1xuICByZXR1cm4ge1xuICAgIC4uLmxvZGVyQ29uZmlnLFxuICAgIC4uLntcbiAgICAgIGVycm9yUmV0cnk6IG51bGwsXG4gICAgICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFJldHJ5KFxuICByZXRyeUNvbmZpZzogUmV0cnlDb25maWcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICByZXRyeUNvdW50OiBudW1iZXIsXG4gIGlzVGltZW91dDogYm9vbGVhbixcbiAgbG9hZGVyUmVzcG9uc2U/OiBMb2FkZXJSZXNwb25zZSB8IHVuZGVmaW5lZCxcbik6IHJldHJ5Q29uZmlnIGlzIFJldHJ5Q29uZmlnICYgYm9vbGVhbiB7XG4gIGlmICghcmV0cnlDb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaHR0cFN0YXR1cyA9IGxvYWRlclJlc3BvbnNlPy5jb2RlO1xuICBjb25zdCByZXRyeSA9XG4gICAgcmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5ICYmXG4gICAgKHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWlzVGltZW91dCk7XG4gIHJldHVybiByZXRyeUNvbmZpZy5zaG91bGRSZXRyeVxuICAgID8gcmV0cnlDb25maWcuc2hvdWxkUmV0cnkoXG4gICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICByZXRyeUNvdW50LFxuICAgICAgICBpc1RpbWVvdXQsXG4gICAgICAgIGxvYWRlclJlc3BvbnNlLFxuICAgICAgICByZXRyeSxcbiAgICAgIClcbiAgICA6IHJldHJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlGb3JIdHRwU3RhdHVzKGh0dHBTdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCkge1xuICAvLyBEbyBub3QgcmV0cnkgb24gc3RhdHVzIDR4eCwgc3RhdHVzIDAgKENPUlMgZXJyb3IpLCBvciB1bmRlZmluZWQgKGRlY3J5cHQvZ2FwL3BhcnNlIGVycm9yKVxuICByZXR1cm4gKFxuICAgIChodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB8fFxuICAgICghIWh0dHBTdGF0dXMgJiYgKGh0dHBTdGF0dXMgPCA0MDAgfHwgaHR0cFN0YXR1cyA+IDQ5OSkpXG4gICk7XG59XG4iLCJ0eXBlIEJpbmFyeVNlYXJjaENvbXBhcmlzb248VD4gPSAoY2FuZGlkYXRlOiBUKSA9PiAtMSB8IDAgfCAxO1xuXG5jb25zdCBCaW5hcnlTZWFyY2ggPSB7XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3IgYW4gaXRlbSBpbiBhbiBhcnJheSB3aGljaCBtYXRjaGVzIGEgY2VydGFpbiBjb25kaXRpb24uXG4gICAqIFRoaXMgcmVxdWlyZXMgdGhlIGNvbmRpdGlvbiB0byBvbmx5IG1hdGNoIG9uZSBpdGVtIGluIHRoZSBhcnJheSxcbiAgICogYW5kIGZvciB0aGUgYXJyYXkgdG8gYmUgb3JkZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIGxpc3QgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIGNvbXBhcmlzb25GblxuICAgKiAgICAgIENhbGxlZCBhbmQgcHJvdmlkZWQgYSBjYW5kaWRhdGUgaXRlbSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAqICAgICAgU2hvdWxkIHJldHVybjpcbiAgICogICAgICAgICAgPiAtMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGxvd2VyIGluZGV4IHRoYW4gdGhlIHByb3ZpZGVkIGl0ZW0uXG4gICAqICAgICAgICAgID4gMSBpZiB0aGUgaXRlbSBzaG91bGQgYmUgbG9jYXRlZCBhdCBhIGhpZ2hlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDAgaWYgdGhlIGl0ZW0gaXMgdGhlIGl0ZW0geW91J3JlIGxvb2tpbmcgZm9yLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgb2JqZWN0IGlmIGZvdW5kLCBvdGhlcndpc2UgcmV0dXJucyBudWxsXG4gICAqL1xuICBzZWFyY2g6IGZ1bmN0aW9uIDxUPihcbiAgICBsaXN0OiBUW10sXG4gICAgY29tcGFyaXNvbkZuOiBCaW5hcnlTZWFyY2hDb21wYXJpc29uPFQ+LFxuICApOiBUIHwgbnVsbCB7XG4gICAgbGV0IG1pbkluZGV4OiBudW1iZXIgPSAwO1xuICAgIGxldCBtYXhJbmRleDogbnVtYmVyID0gbGlzdC5sZW5ndGggLSAxO1xuICAgIGxldCBjdXJyZW50SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIGxldCBjdXJyZW50RWxlbWVudDogVCB8IG51bGwgPSBudWxsO1xuXG4gICAgd2hpbGUgKG1pbkluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICBjdXJyZW50SW5kZXggPSAoKG1pbkluZGV4ICsgbWF4SW5kZXgpIC8gMikgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG5cbiAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJpc29uRm4oY3VycmVudEVsZW1lbnQpO1xuICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgIG1pbkluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQmluYXJ5U2VhcmNoO1xuIiwiaW1wb3J0IEJpbmFyeVNlYXJjaCBmcm9tICcuLi91dGlscy9iaW5hcnktc2VhcmNoJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcblxuLyoqXG4gKiBSZXR1cm5zIGZpcnN0IGZyYWdtZW50IHdob3NlIGVuZFBkdCB2YWx1ZSBleGNlZWRzIHRoZSBnaXZlbiBQRFQsIG9yIG51bGwuXG4gKiBAcGFyYW0gZnJhZ21lbnRzIC0gVGhlIGFycmF5IG9mIGNhbmRpZGF0ZSBmcmFnbWVudHNcbiAqIEBwYXJhbSBQRFRWYWx1ZSAtIFRoZSBQRFQgdmFsdWUgd2hpY2ggbXVzdCBiZSBleGNlZWRlZFxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVChcbiAgZnJhZ21lbnRzOiBBcnJheTxGcmFnbWVudD4sXG4gIFBEVFZhbHVlOiBudW1iZXIgfCBudWxsLFxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiBudW1iZXIsXG4pOiBGcmFnbWVudCB8IG51bGwge1xuICBpZiAoXG4gICAgUERUVmFsdWUgPT09IG51bGwgfHxcbiAgICAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8XG4gICAgIWZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKFBEVFZhbHVlKVxuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZW5kUERUID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA+PSAoZW5kUERUIHx8IDApKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlID0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSB8fCAwO1xuICBmb3IgKGxldCBzZWcgPSAwOyBzZWcgPCBmcmFnbWVudHMubGVuZ3RoOyArK3NlZykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbc2VnXTtcbiAgICBpZiAocGR0V2l0aGluVG9sZXJhbmNlVGVzdChQRFRWYWx1ZSwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZykpIHtcbiAgICAgIHJldHVybiBmcmFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyBhIG1hdGNoaW5nIGZyYWdtZW50IG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnbWVudEJ5UFRTKFxuICBmcmFnUHJldmlvdXM6IEZyYWdtZW50IHwgbnVsbCxcbiAgZnJhZ21lbnRzOiBBcnJheTxGcmFnbWVudD4sXG4gIGJ1ZmZlckVuZDogbnVtYmVyID0gMCxcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyID0gMCxcbik6IEZyYWdtZW50IHwgbnVsbCB7XG4gIGxldCBmcmFnTmV4dDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgaWYgKGZyYWdQcmV2aW91cykge1xuICAgIGZyYWdOZXh0ID1cbiAgICAgIGZyYWdtZW50c1tcbiAgICAgICAgKGZyYWdQcmV2aW91cy5zbiBhcyBudW1iZXIpIC0gKGZyYWdtZW50c1swXS5zbiBhcyBudW1iZXIpICsgMVxuICAgICAgXSB8fCBudWxsO1xuICAgIC8vIGNoZWNrIGZvciBidWZmZXItZW5kIHJvdW5kaW5nIGVycm9yXG4gICAgY29uc3QgYnVmZmVyRWRnZUVycm9yID0gZnJhZ1ByZXZpb3VzLmVuZERUUyAtIGJ1ZmZlckVuZDtcbiAgICBpZiAoYnVmZmVyRWRnZUVycm9yID4gMCAmJiBidWZmZXJFZGdlRXJyb3IgPCAwLjAwMDAwMTUpIHtcbiAgICAgIGJ1ZmZlckVuZCArPSAwLjAwMDAwMTU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfVxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChcbiAgICBmcmFnTmV4dCAmJlxuICAgICghZnJhZ1ByZXZpb3VzIHx8IGZyYWdQcmV2aW91cy5sZXZlbCA9PT0gZnJhZ05leHQubGV2ZWwpICYmXG4gICAgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwgZnJhZ05leHQpID09PVxuICAgICAgMFxuICApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuICBjb25zdCBmb3VuZEZyYWdtZW50ID0gQmluYXJ5U2VhcmNoLnNlYXJjaChcbiAgICBmcmFnbWVudHMsXG4gICAgZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0LmJpbmQobnVsbCwgYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSxcbiAgKTtcbiAgaWYgKGZvdW5kRnJhZ21lbnQgJiYgKGZvdW5kRnJhZ21lbnQgIT09IGZyYWdQcmV2aW91cyB8fCAhZnJhZ05leHQpKSB7XG4gICAgcmV0dXJuIGZvdW5kRnJhZ21lbnQ7XG4gIH1cbiAgLy8gSWYgbm8gbWF0Y2ggd2FzIGZvdW5kIHJldHVybiB0aGUgbmV4dCBmcmFnbWVudCBhZnRlciBmcmFnUHJldmlvdXMsIG9yIG51bGxcbiAgcmV0dXJuIGZyYWdOZXh0O1xufVxuXG4vKipcbiAqIFRoZSB0ZXN0IGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGZpbmRGcmFnbWVudEJ5U24ncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBidWZmZXJFbmQgLSBUaGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlIHRoZSBwbGF5aGVhZCBpcyBjdXJyZW50bHkgd2l0aGluXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgMCBpZiBpdCBtYXRjaGVzLCAxIGlmIHRvbyBsb3csIC0xIGlmIHRvbyBoaWdoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoXG4gIGJ1ZmZlckVuZCA9IDAsXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLFxuICBjYW5kaWRhdGU6IEZyYWdtZW50LFxuKSB7XG4gIC8vIGVhZ2VybHkgYWNjZXB0IGFuIGFjY3VyYXRlIG1hdGNoIChubyB0b2xlcmFuY2UpXG4gIGlmIChcbiAgICBjYW5kaWRhdGUuc3RhcnQgPD0gYnVmZmVyRW5kICYmXG4gICAgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uID4gYnVmZmVyRW5kXG4gICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIG9mZnNldCBzaG91bGQgYmUgd2l0aGluIGZyYWdtZW50IGJvdW5kYXJ5IC0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2VcbiAgLy8gdGhpcyBpcyB0byBjb3BlIHdpdGggc2l0dWF0aW9ucyBsaWtlXG4gIC8vIGJ1ZmZlckVuZCA9IDkuOTkxXG4gIC8vIGZyYWdbw5hdIDogWzAsMTBdXG4gIC8vIGZyYWdbMV0gOiBbMTAsMjBdXG4gIC8vIGJ1ZmZlckVuZCBpcyB3aXRoaW4gZnJhZ1swXSByYW5nZSAuLi4gYWx0aG91Z2ggd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIGlzIHRvIHJldHVybiBmcmFnWzFdIGhlcmVcbiAgLy8gICAgICAgICAgICAgIGZyYWcgc3RhcnQgICAgICAgICAgICAgICBmcmFnIHN0YXJ0K2R1cmF0aW9uXG4gIC8vICAgICAgICAgICAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAvLyAgICAgICAgICAgICAgPC0tLT4gICAgICAgICAgICAgICAgICAgICAgICAgPC0tLT5cbiAgLy8gIC4uLi0tLS0tLS0tPjwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT48LS0tLS0tLS0tLi4uLlxuICAvLyBwcmV2aW91cyBmcmFnICAgICAgICAgbWF0Y2hpbmcgZnJhZ21lbnQgICAgICAgICBuZXh0IGZyYWdcbiAgLy8gIHJldHVybiAtMSAgICAgICAgICAgICByZXR1cm4gMCAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgLy8gbG9nZ2VyLmxvZyhgbGV2ZWwvc24vc3RhcnQvZW5kL2J1ZkVuZDoke2xldmVsfS8ke2NhbmRpZGF0ZS5zbn0vJHtjYW5kaWRhdGUuc3RhcnR9LyR7KGNhbmRpZGF0ZS5zdGFydCtjYW5kaWRhdGUuZHVyYXRpb24pfS8ke2J1ZmZlckVuZH1gKTtcbiAgLy8gU2V0IHRoZSBsb29rdXAgdG9sZXJhbmNlIHRvIGJlIHNtYWxsIGVub3VnaCB0byBkZXRlY3QgdGhlIGN1cnJlbnQgc2VnbWVudCAtIGVuc3VyZXMgd2UgZG9uJ3Qgc2tpcCBvdmVyIHZlcnkgc21hbGwgc2VnbWVudHNcbiAgY29uc3QgY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID0gTWF0aC5taW4oXG4gICAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxcbiAgICBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCksXG4gICk7XG4gIGlmIChcbiAgICBjYW5kaWRhdGUuc3RhcnQgKyBjYW5kaWRhdGUuZHVyYXRpb24gLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPD1cbiAgICBidWZmZXJFbmRcbiAgKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoXG4gICAgY2FuZGlkYXRlLnN0YXJ0IC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlID4gYnVmZmVyRW5kICYmXG4gICAgY2FuZGlkYXRlLnN0YXJ0XG4gICkge1xuICAgIC8vIGlmIG1heEZyYWdMb29rVXBUb2xlcmFuY2Ugd2lsbCBoYXZlIG5lZ2F0aXZlIHZhbHVlIHRoZW4gZG9uJ3QgcmV0dXJuIC0xIGZvciBmaXJzdCBlbGVtZW50XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlQZHQncyBCaW5hcnlTZWFyY2ggdG8gbG9vayBmb3IgdGhlIGJlc3QgbWF0Y2ggdG8gdGhlIGN1cnJlbnQgYnVmZmVyIGNvbmRpdGlvbnMuXG4gKiBUaGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBjYW5kaWRhdGUncyBwcm9ncmFtIGRhdGUgdGltZSB2YWx1ZXMsIGFzIHJlcHJlc2VudGVkIGluIFVuaXggdGltZVxuICogQHBhcmFtIGNhbmRpZGF0ZSAtIFRoZSBmcmFnbWVudCB0byB0ZXN0XG4gKiBAcGFyYW0gcGR0QnVmZmVyRW5kIC0gVGhlIFVuaXggdGltZSByZXByZXNlbnRpbmcgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXJlZCByYW5nZVxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQgY2FuIGJlIHdpdGhpbiBpbiBvcmRlciB0byBiZSBjb25zaWRlcmVkIGNvbnRpZ3VvdXNcbiAqIEByZXR1cm5zIHRydWUgaWYgY29udGlndW91cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFxuICBwZHRCdWZmZXJFbmQ6IG51bWJlcixcbiAgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTogbnVtYmVyLFxuICBjYW5kaWRhdGU6IEZyYWdtZW50LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA9XG4gICAgTWF0aC5taW4oXG4gICAgICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgY2FuZGlkYXRlLmR1cmF0aW9uICsgKGNhbmRpZGF0ZS5kZWx0YVBUUyA/IGNhbmRpZGF0ZS5kZWx0YVBUUyA6IDApLFxuICAgICkgKiAxMDAwO1xuXG4gIC8vIGVuZFByb2dyYW1EYXRlVGltZSBjYW4gYmUgbnVsbCwgZGVmYXVsdCB0byB6ZXJvXG4gIGNvbnN0IGVuZFByb2dyYW1EYXRlVGltZSA9IGNhbmRpZGF0ZS5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMDtcbiAgcmV0dXJuIGVuZFByb2dyYW1EYXRlVGltZSAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IHBkdEJ1ZmZlckVuZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGcmFnV2l0aENDKFxuICBmcmFnbWVudHM6IEZyYWdtZW50W10sXG4gIGNjOiBudW1iZXIsXG4pOiBGcmFnbWVudCB8IG51bGwge1xuICByZXR1cm4gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIChjYW5kaWRhdGUpID0+IHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgUGxheWxpc3RDb250ZXh0VHlwZSwgUGxheWxpc3RMZXZlbFR5cGUgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHtcbiAgZ2V0UmV0cnlDb25maWcsXG4gIGlzVGltZW91dEVycm9yLFxuICBzaG91bGRSZXRyeSxcbn0gZnJvbSAnLi4vdXRpbHMvZXJyb3ItaGVscGVyJztcbmltcG9ydCB7IGZpbmRGcmFnbWVudEJ5UFRTIH0gZnJvbSAnLi9mcmFnbWVudC1maW5kZXJzJztcbmltcG9ydCB7IEhkY3BMZXZlbCwgSGRjcExldmVscyB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgUmV0cnlDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7IEVycm9yRGF0YSB9IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuXG5leHBvcnQgY29uc3QgZW51bSBOZXR3b3JrRXJyb3JBY3Rpb24ge1xuICBEb05vdGhpbmcgPSAwLFxuICBTZW5kRW5kQ2FsbGJhY2sgPSAxLCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICBTZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94ID0gMixcbiAgUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHkgPSAzLCAvLyBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICBJbnNlcnREaXNjb250aW51aXR5ID0gNCwgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2VcbiAgUmV0cnlSZXF1ZXN0ID0gNSxcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRXJyb3JBY3Rpb25GbGFncyB7XG4gIE5vbmUgPSAwLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCA9IDEsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQID0gMSA8PCAxLFxuICBTd2l0Y2hUb1NEUiA9IDEgPDwgMiwgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2Vcbn1cblxuZXhwb3J0IHR5cGUgSUVycm9yQWN0aW9uID0ge1xuICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbjtcbiAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3M7XG4gIHJldHJ5Q291bnQ/OiBudW1iZXI7XG4gIHJldHJ5Q29uZmlnPzogUmV0cnlDb25maWc7XG4gIGhkY3BMZXZlbD86IEhkY3BMZXZlbDtcbiAgbmV4dEF1dG9MZXZlbD86IG51bWJlcjtcbiAgcmVzb2x2ZWQ/OiBib29sZWFuO1xufTtcblxudHlwZSBQZW5hbGl6ZWRSZW5kaXRpb24gPSB7XG4gIGxhc3RFcnJvclBlcmZNczogbnVtYmVyO1xuICBlcnJvcnM6IEVycm9yRGF0YVtdO1xuICBkZXRhaWxzPzogTGV2ZWxEZXRhaWxzO1xufTtcblxudHlwZSBQZW5hbGl6ZWRSZW5kaXRpb25zID0geyBba2V5OiBudW1iZXJdOiBQZW5hbGl6ZWRSZW5kaXRpb24gfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JDb250cm9sbGVyIGltcGxlbWVudHMgTmV0d29ya0NvbXBvbmVudEFQSSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGxzOiBIbHM7XG4gIHByaXZhdGUgcGxheWxpc3RFcnJvcjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBwZW5hbGl6ZWRSZW5kaXRpb25zOiBQZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gIHByaXZhdGUgbG9nOiAobXNnOiBhbnkpID0+IHZvaWQ7XG4gIHByaXZhdGUgd2FybjogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcml2YXRlIGVycm9yOiAobXNnOiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbaW5mb106YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGBbd2FybmluZ106YCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgYFtlcnJvcl06YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBpZiAoIWhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yT3V0LCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgc3RvcExvYWQoKTogdm9pZCB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VmFyaWFudExldmVsSW5kZXgoZnJhZzogRnJhZ21lbnQgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICAgIHJldHVybiBmcmFnPy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOXG4gICAgICA/IGZyYWcubGV2ZWxcbiAgICAgIDogdGhpcy5obHMubG9hZExldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsVXBkYXRlZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBkYXRhLmNvbnRleHQ7XG5cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzZWdtZW50IGVycm9ycyBtYXJrZWQgYXMgZ2FwXG4gICAgICAgIGlmIChkYXRhLmZyYWc/LmdhcCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB7XG4gICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5Eb05vdGhpbmcsXG4gICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0dBUDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUjoge1xuICAgICAgICAvLyBTd2l0Y2ggbGV2ZWwgaWYgcG9zc2libGUsIG90aGVyd2lzZSBhbGxvdyByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhKTtcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5hY3Rpb24gPSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfRU1QVFlfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gT25seSByZXRyeSB3aGVuIGVtcHR5IGFuZCBsaXZlXG4gICAgICAgICAgY29uc3QgbGV2ZWxJbmRleCA9XG4gICAgICAgICAgICBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTlxuICAgICAgICAgICAgICA/IChkYXRhLmxldmVsIGFzIG51bWJlcilcbiAgICAgICAgICAgICAgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkxFVkVMX0VNUFRZX0VSUk9SICYmXG4gICAgICAgICAgICAhIWRhdGEuY29udGV4dD8ubGV2ZWxEZXRhaWxzPy5saXZlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oXG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIGxldmVsSW5kZXgsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFc2NhbGF0ZSB0byBmYXRhbCBpZiBub3QgcmV0cnlpbmcgb3Igc3dpdGNoaW5nXG4gICAgICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQ/LmxldmVsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb250ZXh0LmxldmVsLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW2hscy5sb2FkTGV2ZWxdO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxldmVsICYmXG4gICAgICAgICAgICAoKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJlxuICAgICAgICAgICAgICBsZXZlbC5oYXNBdWRpb0dyb3VwKGNvbnRleHQuZ3JvdXBJZCkpIHx8XG4gICAgICAgICAgICAgIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiZcbiAgICAgICAgICAgICAgICBsZXZlbC5oYXNTdWJ0aXRsZUdyb3VwKGNvbnRleHQuZ3JvdXBJZCkpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gUGVyZm9ybSBQYXRod2F5IHN3aXRjaCBvciBSZWR1bmRhbnQgZmFpbG92ZXIgaWYgcG9zc2libGUgZm9yIGZhc3Rlc3QgcmVjb3ZlcnlcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhbGxvdyBwbGF5bGlzdCByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBobHMubG9hZExldmVsLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID1cbiAgICAgICAgICAgICAgTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmZsYWdzID1cbiAgICAgICAgICAgICAgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEhkY3BMZXZlbCA9IGxldmVsPy5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICAgIGlmIChyZXN0cmljdGVkSGRjcExldmVsKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUCxcbiAgICAgICAgICAgICAgaGRjcExldmVsOiByZXN0cmljdGVkSGRjcExldmVsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkYXRhLmxldmVsID8/IGhscy5sb2FkTGV2ZWwsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SKSB7XG4gICAgICB0aGlzLmtleVN5c3RlbUVycm9yKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUga2V5U3lzdGVtRXJyb3IoZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIEVzY2FsYXRlIHRvIGZhdGFsIGlmIHN3aXRjaGluZyBsZXZlbHMgZmFpbHMuXG4gICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gIH1cblxuICBwcml2YXRlIGdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihcbiAgICBkYXRhOiBFcnJvckRhdGEsXG4gICAgbGV2ZWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgKTogSUVycm9yQWN0aW9uIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShcbiAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgcmV0cnlDb3VudCxcbiAgICAgIGlzVGltZW91dEVycm9yKGRhdGEpLFxuICAgICAgZGF0YS5yZXNwb25zZSxcbiAgICApO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgcmV0cnlDb3VudCxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KTtcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gcmV0cnlDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yQWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbihkYXRhOiBFcnJvckRhdGEpOiBJRXJyb3JBY3Rpb24ge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICBjb25zdCB2YXJpYW50TGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgIGNvbnN0IHsgZnJhZ0xvYWRQb2xpY3ksIGtleUxvYWRQb2xpY3kgfSA9IGhscy5jb25maWc7XG4gICAgY29uc3QgcmV0cnlDb25maWcgPSBnZXRSZXRyeUNvbmZpZyhcbiAgICAgIGRhdGEuZGV0YWlscy5zdGFydHNXaXRoKCdrZXknKSA/IGtleUxvYWRQb2xpY3kgOiBmcmFnTG9hZFBvbGljeSxcbiAgICAgIGRhdGEsXG4gICAgKTtcbiAgICBjb25zdCBmcmFnbWVudEVycm9ycyA9IGhscy5sZXZlbHMucmVkdWNlKFxuICAgICAgKGFjYywgbGV2ZWwpID0+IGFjYyArIGxldmVsLmZyYWdtZW50RXJyb3IsXG4gICAgICAwLFxuICAgICk7XG4gICAgLy8gU3dpdGNoIGxldmVscyB3aGVuIG91dCBvZiByZXRyaWVkIG9yIGxldmVsIGluZGV4IG91dCBvZiBib3VuZHNcbiAgICBpZiAobGV2ZWwpIHtcbiAgICAgIGlmIChkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICBjb25zdCByZXRyeSA9IHNob3VsZFJldHJ5KFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgZnJhZ21lbnRFcnJvcnMsXG4gICAgICAgIGlzVGltZW91dEVycm9yKGRhdGEpLFxuICAgICAgICBkYXRhLnJlc3BvbnNlLFxuICAgICAgKTtcbiAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIHJldHJ5Q29uZmlnLFxuICAgICAgICAgIHJldHJ5Q291bnQ6IGZyYWdtZW50RXJyb3JzLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWFjaCBtYXggcmV0cnkgY291bnQsIG9yIE1pc3NpbmcgbGV2ZWwgcmVmZXJlbmNlXG4gICAgLy8gU3dpdGNoIHRvIHZhbGlkIGluZGV4XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIHZhcmlhbnRMZXZlbEluZGV4KTtcbiAgICAvLyBBZGQgcmV0cnkgZGV0YWlscyB0byBhbGxvdyBza2lwcGluZyBvZiBGUkFHX1BBUlNJTkdfRVJST1JcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gZnJhZ21lbnRFcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oXG4gICAgZGF0YTogRXJyb3JEYXRhLFxuICAgIGxldmVsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsXG4gICk6IElFcnJvckFjdGlvbiB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVsSW5kZXggPT09IG51bGwgfHwgbGV2ZWxJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXZlbEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKGxldmVsKSB7XG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgICBsZXZlbC5sb2FkRXJyb3IrKztcbiAgICAgIGlmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIH1cbiAgICAgIC8vIFNlYXJjaCBmb3IgbmV4dCBsZXZlbCB0byByZXRyeVxuICAgICAgbGV0IG5leHRMZXZlbCA9IC0xO1xuICAgICAgY29uc3QgeyBsZXZlbHMsIGxvYWRMZXZlbCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwgfSA9IGhscztcbiAgICAgIGlmICghaGxzLmF1dG9MZXZlbEVuYWJsZWQpIHtcbiAgICAgICAgaGxzLmxvYWRMZXZlbCA9IC0xO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZ0Vycm9yVHlwZSA9IGRhdGEuZnJhZz8udHlwZTtcbiAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIGF1ZGlvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiBhdWRpbyBjb2RlYyBlcnJvclxuICAgICAgY29uc3QgaXNBdWRpb0NvZGVjRXJyb3IgPVxuICAgICAgICAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8gJiZcbiAgICAgICAgICBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IpIHx8XG4gICAgICAgIChkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgPT09ICdhdWRpbycgJiZcbiAgICAgICAgICAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fFxuICAgICAgICAgICAgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikpO1xuICAgICAgY29uc3QgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgPVxuICAgICAgICBpc0F1ZGlvQ29kZWNFcnJvciAmJlxuICAgICAgICBsZXZlbHMuc29tZSgoeyBhdWRpb0NvZGVjIH0pID0+IGxldmVsLmF1ZGlvQ29kZWMgIT09IGF1ZGlvQ29kZWMpO1xuICAgICAgLy8gRmluZCBhbHRlcm5hdGUgdmlkZW8gY29kZWMgaWYgYXZhaWxhYmxlIG9uIHZpZGVvIGNvZGVjIGVycm9yXG4gICAgICBjb25zdCBpc1ZpZGVvQ29kZWNFcnJvciA9XG4gICAgICAgIGRhdGEuc291cmNlQnVmZmVyTmFtZSA9PT0gJ3ZpZGVvJyAmJlxuICAgICAgICAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fFxuICAgICAgICAgIGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpO1xuICAgICAgY29uc3QgZmluZFZpZGVvQ29kZWNBbHRlcm5hdGUgPVxuICAgICAgICBpc1ZpZGVvQ29kZWNFcnJvciAmJlxuICAgICAgICBsZXZlbHMuc29tZShcbiAgICAgICAgICAoeyBjb2RlY1NldCwgYXVkaW9Db2RlYyB9KSA9PlxuICAgICAgICAgICAgbGV2ZWwuY29kZWNTZXQgIT09IGNvZGVjU2V0ICYmIGxldmVsLmF1ZGlvQ29kZWMgPT09IGF1ZGlvQ29kZWMsXG4gICAgICAgICk7XG4gICAgICBjb25zdCB7IHR5cGU6IHBsYXlsaXN0RXJyb3JUeXBlLCBncm91cElkOiBwbGF5bGlzdEVycm9yR3JvdXBJZCB9ID1cbiAgICAgICAgZGF0YS5jb250ZXh0ID8/IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IGxldmVscy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IChpICsgbG9hZExldmVsKSAlIGxldmVscy5sZW5ndGg7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjYW5kaWRhdGUgIT09IGxvYWRMZXZlbCAmJlxuICAgICAgICAgIGNhbmRpZGF0ZSA+PSBtaW5BdXRvTGV2ZWwgJiZcbiAgICAgICAgICBjYW5kaWRhdGUgPD0gbWF4QXV0b0xldmVsICYmXG4gICAgICAgICAgbGV2ZWxzW2NhbmRpZGF0ZV0ubG9hZEVycm9yID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGxldmVsQ2FuZGlkYXRlID0gbGV2ZWxzW2NhbmRpZGF0ZV07XG4gICAgICAgICAgLy8gU2tpcCBsZXZlbCBzd2l0Y2ggaWYgR0FQIHRhZyBpcyBmb3VuZCBpbiBuZXh0IGxldmVsIGF0IHNhbWUgcG9zaXRpb25cbiAgICAgICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuRlJBR19HQVAgJiYgZGF0YS5mcmFnKSB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERldGFpbHMgPSBsZXZlbHNbY2FuZGlkYXRlXS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKGxldmVsRGV0YWlscykge1xuICAgICAgICAgICAgICBjb25zdCBmcmFnQ2FuZGlkYXRlID0gZmluZEZyYWdtZW50QnlQVFMoXG4gICAgICAgICAgICAgICAgZGF0YS5mcmFnLFxuICAgICAgICAgICAgICAgIGxldmVsRGV0YWlscy5mcmFnbWVudHMsXG4gICAgICAgICAgICAgICAgZGF0YS5mcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoZnJhZ0NhbmRpZGF0ZT8uZ2FwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmXG4gICAgICAgICAgICAgIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpKSB8fFxuICAgICAgICAgICAgKHBsYXlsaXN0RXJyb3JUeXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmXG4gICAgICAgICAgICAgIGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAocGxheWxpc3RFcnJvckdyb3VwSWQpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgcGxheWxpc3QgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgKGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPICYmXG4gICAgICAgICAgICAgIGxldmVsLmF1ZGlvR3JvdXBzPy5zb21lKChncm91cElkKSA9PlxuICAgICAgICAgICAgICAgIGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCksXG4gICAgICAgICAgICAgICkpIHx8XG4gICAgICAgICAgICAoZnJhZ0Vycm9yVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUgJiZcbiAgICAgICAgICAgICAgbGV2ZWwuc3VidGl0bGVHcm91cHM/LnNvbWUoKGdyb3VwSWQpID0+XG4gICAgICAgICAgICAgICAgbGV2ZWxDYW5kaWRhdGUuaGFzU3VidGl0bGVHcm91cChncm91cElkKSxcbiAgICAgICAgICAgICAgKSkgfHxcbiAgICAgICAgICAgIChmaW5kQXVkaW9Db2RlY0FsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjID09PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0NvZGVjKSB8fFxuICAgICAgICAgICAgKCFmaW5kQXVkaW9Db2RlY0FsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICBsZXZlbC5hdWRpb0NvZGVjICE9PSBsZXZlbENhbmRpZGF0ZS5hdWRpb0NvZGVjKSB8fFxuICAgICAgICAgICAgKGZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgIGxldmVsLmNvZGVjU2V0ID09PSBsZXZlbENhbmRpZGF0ZS5jb2RlY1NldClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEZvciB2aWRlby9hdWRpby9zdWJzIGZyYWcgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dExldmVsID0gY2FuZGlkYXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV4dExldmVsID4gLTEgJiYgaGxzLmxvYWRMZXZlbCAhPT0gbmV4dExldmVsKSB7XG4gICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IG5leHRMZXZlbCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbGV2ZWxzIHRvIHN3aXRjaCAvIE1hbnVhbCBsZXZlbCBzZWxlY3Rpb24gLyBMZXZlbCBub3QgZm91bmRcbiAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRXJyb3JPdXQoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmVycm9yQWN0aW9uPy5hY3Rpb24pIHtcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OlxuICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCAmJlxuICAgICAgICAgIGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQXG4gICAgICAgICkge1xuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdChkYXRhLmVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgICAgYE1lZGlhU291cmNlIGVuZGVkIGFmdGVyIFwiJHtkYXRhLnNvdXJjZUJ1ZmZlck5hbWV9XCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuYCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGxzLnJlY292ZXJNZWRpYUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3Q6XG4gICAgICAgIC8vIGhhbmRsZWQgYnkgc3RyZWFtIGFuZCBwbGF5bGlzdC9sZXZlbCBjb250cm9sbGVyc1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5obHMuc3RvcExvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSBkYXRhLmVycm9yQWN0aW9uO1xuICAgIGlmICghZXJyb3JBY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmbGFncywgaGRjcExldmVsLCBuZXh0QXV0b0xldmVsIH0gPSBlcnJvckFjdGlvbjtcblxuICAgIHN3aXRjaCAoZmxhZ3MpIHtcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Ob25lOlxuICAgICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDpcbiAgICAgICAgaWYgKGhkY3BMZXZlbCkge1xuICAgICAgICAgIGhscy5tYXhIZGNwTGV2ZWwgPSBIZGNwTGV2ZWxzW0hkY3BMZXZlbHMuaW5kZXhPZihoZGNwTGV2ZWwpIC0gMV07XG4gICAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcIiR7aGxzLm1heEhkY3BMZXZlbH1cIiBvciBsb3dlcmAsXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBJZiBub3QgcmVzb2x2ZWQgYnkgcHJldmlvdXMgYWN0aW9ucyB0cnkgdG8gc3dpdGNoIHRvIG5leHQgbGV2ZWxcbiAgICBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICB0aGlzLnN3aXRjaExldmVsKGRhdGEsIG5leHRBdXRvTGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3dpdGNoTGV2ZWwoZGF0YTogRXJyb3JEYXRhLCBsZXZlbEluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMud2Fybihgc3dpdGNoaW5nIHRvIGxldmVsICR7bGV2ZWxJbmRleH0gYWZ0ZXIgJHtkYXRhLmRldGFpbHN9YCk7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHsgZ2V0U2tpcFZhbHVlLCBIbHNTa2lwLCBIbHNVcmxQYXJhbWV0ZXJzLCBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IGNvbXB1dGVSZWxvYWRJbnRlcnZhbCwgbWVyZ2VEZXRhaWxzIH0gZnJvbSAnLi4vdXRpbHMvbGV2ZWwtaGVscGVyJztcbmltcG9ydCB7IEVycm9yRGF0YSB9IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgeyBnZXRSZXRyeURlbGF5LCBpc1RpbWVvdXRFcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9yLWhlbHBlcic7XG5pbXBvcnQgeyBOZXR3b3JrRXJyb3JBY3Rpb24gfSBmcm9tICcuL2Vycm9yLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxEZXRhaWxzIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYVBsYXlsaXN0IH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1RyYWNrTG9hZGVkRGF0YSxcbiAgTGV2ZWxMb2FkZWREYXRhLFxuICBUcmFja0xvYWRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIgaW1wbGVtZW50cyBOZXR3b3JrQ29tcG9uZW50QVBJIHtcbiAgcHJvdGVjdGVkIGhsczogSGxzO1xuICBwcm90ZWN0ZWQgdGltZXI6IG51bWJlciA9IC0xO1xuICBwcm90ZWN0ZWQgcmVxdWVzdFNjaGVkdWxlZDogbnVtYmVyID0gLTE7XG4gIHByb3RlY3RlZCBjYW5Mb2FkOiBib29sZWFuID0gZmFsc2U7XG4gIHByb3RlY3RlZCBsb2c6IChtc2c6IGFueSkgPT4gdm9pZDtcbiAgcHJvdGVjdGVkIHdhcm46IChtc2c6IGFueSkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscywgbG9nUHJlZml4OiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy53YXJuID0gbG9nZ2VyLndhcm4uYmluZChsb2dnZXIsIGAke2xvZ1ByZWZpeH06YCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2xlYXJUaW1lcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50aW1lciAhPT0gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgdGhpcy50aW1lciA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGFydExvYWQoKTogdm9pZCB7XG4gICAgdGhpcy5jYW5Mb2FkID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICB9XG5cbiAgcHVibGljIHN0b3BMb2FkKCk6IHZvaWQge1xuICAgIHRoaXMuY2FuTG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN3aXRjaFBhcmFtcyhcbiAgICBwbGF5bGlzdFVyaTogc3RyaW5nLFxuICAgIHByZXZpb3VzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQsXG4gICk6IEhsc1VybFBhcmFtZXRlcnMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydHMgPSBwcmV2aW91cz8ucmVuZGl0aW9uUmVwb3J0cztcbiAgICBpZiAocmVuZGl0aW9uUmVwb3J0cykge1xuICAgICAgbGV0IGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGl0aW9uUmVwb3J0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhdHRyID0gcmVuZGl0aW9uUmVwb3J0c1tpXTtcbiAgICAgICAgbGV0IHVyaTogc3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtlcnJvcn1gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgdXJpID0gYXR0ci5VUkkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGV4YWN0IG1hdGNoLiBPdGhlcndpc2UsIHRoZSBsYXN0IHBhcnRpYWwgbWF0Y2gsIGlmIGFueSwgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIChQbGF5bGlzdCBVUkkgaW5jbHVkZXMgYSBxdWVyeSBzdHJpbmcgdGhhdCB0aGUgUmVuZGl0aW9uIFJlcG9ydCBkb2VzIG5vdClcbiAgICAgICAgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpLnN1YnN0cmluZygwLCB1cmkubGVuZ3RoKSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHJlbmRpdGlvblJlcG9ydHNbZm91bmRJbmRleF07XG4gICAgICAgIGNvbnN0IG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pIHx8IHByZXZpb3VzPy5sYXN0UGFydFNuO1xuICAgICAgICBsZXQgcGFydCA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtUEFSVCddKSB8fCBwcmV2aW91cz8ubGFzdFBhcnRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRHb2FsID0gTWF0aC5taW4oXG4gICAgICAgICAgICBwcmV2aW91cy5hZ2UgLSBwcmV2aW91cy5wYXJ0VGFyZ2V0LFxuICAgICAgICAgICAgcHJldmlvdXMudGFyZ2V0ZHVyYXRpb24sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgcGFydCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMoXG4gICAgICAgICAgbXNuLFxuICAgICAgICAgIHBhcnQgPj0gMCA/IHBhcnQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgSGxzU2tpcC5ObyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnM/OiBIbHNVcmxQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEpIHtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICAgIC8vIExvYWRpbmcgaXMgaGFuZGxlZCBieSB0aGUgc3ViY2xhc3Nlc1xuICB9XG5cbiAgcHJvdGVjdGVkIHNob3VsZExvYWRQbGF5bGlzdChcbiAgICBwbGF5bGlzdDogTGV2ZWwgfCBNZWRpYVBsYXlsaXN0IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuY2FuTG9hZCAmJlxuICAgICAgISFwbGF5bGlzdCAmJlxuICAgICAgISFwbGF5bGlzdC51cmwgJiZcbiAgICAgICghcGxheWxpc3QuZGV0YWlscyB8fCBwbGF5bGlzdC5kZXRhaWxzLmxpdmUpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzaG91bGRSZWxvYWRQbGF5bGlzdChcbiAgICBwbGF5bGlzdDogTGV2ZWwgfCBNZWRpYVBsYXlsaXN0IHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudGltZXIgPT09IC0xICYmXG4gICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xICYmXG4gICAgICB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChwbGF5bGlzdClcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIHBsYXlsaXN0TG9hZGVkKFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgZGF0YTogTGV2ZWxMb2FkZWREYXRhIHwgQXVkaW9UcmFja0xvYWRlZERhdGEgfCBUcmFja0xvYWRlZERhdGEsXG4gICAgcHJldmlvdXNEZXRhaWxzPzogTGV2ZWxEZXRhaWxzLFxuICApIHtcbiAgICBjb25zdCB7IGRldGFpbHMsIHN0YXRzIH0gPSBkYXRhO1xuXG4gICAgLy8gU2V0IGxhc3QgdXBkYXRlZCBkYXRlLXRpbWVcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0XG4gICAgICA/IE1hdGgubWF4KDAsIG5vdyAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpXG4gICAgICA6IDA7XG4gICAgZGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gRGF0ZS5ub3coKSAtIGVsYXBzZWQ7XG5cbiAgICAvLyBpZiBjdXJyZW50IHBsYXlsaXN0IGlzIGEgbGl2ZSBwbGF5bGlzdCwgYXJtIGEgdGltZXIgdG8gcmVsb2FkIGl0XG4gICAgaWYgKGRldGFpbHMubGl2ZSB8fCBwcmV2aW91c0RldGFpbHM/LmxpdmUpIHtcbiAgICAgIGRldGFpbHMucmVsb2FkZWQocHJldmlvdXNEZXRhaWxzKTtcbiAgICAgIGlmIChwcmV2aW91c0RldGFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYGxpdmUgcGxheWxpc3QgJHtpbmRleH0gJHtcbiAgICAgICAgICAgIGRldGFpbHMuYWR2YW5jZWRcbiAgICAgICAgICAgICAgPyAnUkVGUkVTSEVEICcgKyBkZXRhaWxzLmxhc3RQYXJ0U24gKyAnLScgKyBkZXRhaWxzLmxhc3RQYXJ0SW5kZXhcbiAgICAgICAgICAgICAgOiBkZXRhaWxzLnVwZGF0ZWRcbiAgICAgICAgICAgICAgICA/ICdVUERBVEVEJ1xuICAgICAgICAgICAgICAgIDogJ01JU1NFRCdcbiAgICAgICAgICB9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIGxpdmUgcGxheWxpc3RzIHRvIGFkanVzdCBmcmFnbWVudCBzdGFydHMgYW5kIGZpbGwgaW4gZGVsdGEgcGxheWxpc3Qgc2tpcHBlZCBzZWdtZW50c1xuICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1lcmdlRGV0YWlscyhwcmV2aW91c0RldGFpbHMsIGRldGFpbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNhbkxvYWQgfHwgIWRldGFpbHMubGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVsaXZlcnlEaXJlY3RpdmVzOiBIbHNVcmxQYXJhbWV0ZXJzIHwgdW5kZWZpbmVkO1xuICAgICAgbGV0IG1zbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IHBhcnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMuZW5kU04gJiYgZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgICAvLyBMb2FkIGxldmVsIHdpdGggTEwtSExTIGRlbGl2ZXJ5IGRpcmVjdGl2ZXNcbiAgICAgICAgY29uc3QgbG93TGF0ZW5jeU1vZGUgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0U24gPSBkZXRhaWxzLmxhc3RQYXJ0U247XG4gICAgICAgIGNvbnN0IGVuZFNuID0gZGV0YWlscy5lbmRTTjtcbiAgICAgICAgY29uc3QgbGFzdFBhcnRJbmRleCA9IGRldGFpbHMubGFzdFBhcnRJbmRleDtcbiAgICAgICAgY29uc3QgaGFzUGFydHMgPSBsYXN0UGFydEluZGV4ICE9PSAtMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBsYXN0UGFydFNuID09PSBlbmRTbjtcbiAgICAgICAgLy8gV2hlbiBsb3cgbGF0ZW5jeSBtb2RlIGlzIGRpc2FibGVkLCB3ZSdsbCBza2lwIHBhcnQgcmVxdWVzdHMgb25jZSB0aGUgbGFzdCBwYXJ0IGluZGV4IGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IG5leHRTblN0YXJ0SW5kZXggPSBsb3dMYXRlbmN5TW9kZSA/IDAgOiBsYXN0UGFydEluZGV4O1xuICAgICAgICBpZiAoaGFzUGFydHMpIHtcbiAgICAgICAgICBtc24gPSBsYXN0UGFydCA/IGVuZFNuICsgMSA6IGxhc3RQYXJ0U247XG4gICAgICAgICAgcGFydCA9IGxhc3RQYXJ0ID8gbmV4dFNuU3RhcnRJbmRleCA6IGxhc3RQYXJ0SW5kZXggKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zbiA9IGVuZFNuICsgMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbjogXCJhZ2VcIiBoZWFkZXIgYW5kIHRpbWUgc2luY2UgbG9hZCBpbmRpY2F0ZXMgd2UncmUgYmVoaW5kIGJ5IG1vcmUgdGhhbiBvbmUgcGFydFxuICAgICAgICAvLyBVcGRhdGUgZGlyZWN0aXZlcyB0byBvYnRhaW4gdGhlIFBsYXlsaXN0IHRoYXQgaGFzIHRoZSBlc3RpbWF0ZWQgYWRkaXRpb25hbCBkdXJhdGlvbiBvZiBtZWRpYVxuICAgICAgICBjb25zdCBsYXN0QWR2YW5jZWQgPSBkZXRhaWxzLmFnZTtcbiAgICAgICAgY29uc3QgY2RuQWdlID0gbGFzdEFkdmFuY2VkICsgZGV0YWlscy5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBjdXJyZW50R29hbCA9IE1hdGgubWluKFxuICAgICAgICAgIGNkbkFnZSAtIGRldGFpbHMucGFydFRhcmdldCxcbiAgICAgICAgICBkZXRhaWxzLnRhcmdldGR1cmF0aW9uICogMS41LFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAgIGBDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiAke3ByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsfSB0bzogJHtjdXJyZW50R29hbH0gd2l0aCBwbGF5bGlzdCBhZ2U6ICR7ZGV0YWlscy5hZ2V9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50R29hbCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gTWF0aC5mbG9vcihjdXJyZW50R29hbCAvIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgICAgbXNuICs9IHNlZ21lbnRzO1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgKGN1cnJlbnRHb2FsICUgZGV0YWlscy50YXJnZXRkdXJhdGlvbikgLyBkZXRhaWxzLnBhcnRUYXJnZXQsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHBhcnQgKz0gcGFydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgYENETiBUdW5lLWluIGFnZTogJHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzLmFnZUhlYWRlclxuICAgICAgICAgICAgICB9cyBsYXN0IGFkdmFuY2VkICR7bGFzdEFkdmFuY2VkLnRvRml4ZWQoXG4gICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgKX1zIGdvYWw6ICR7Y3VycmVudEdvYWx9IHNraXAgc24gJHtzZWdtZW50c30gdG8gcGFydCAke3BhcnR9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRldGFpbHMudHVuZUluR29hbCA9IGN1cnJlbnRHb2FsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKFxuICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgICAgbXNuLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChsb3dMYXRlbmN5TW9kZSB8fCAhbGFzdFBhcnQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXRhaWxzLmNhbkJsb2NrUmVsb2FkIHx8IGRldGFpbHMuY2FuU2tpcFVudGlsKSB7XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKFxuICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMsXG4gICAgICAgICAgbXNuLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5obHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgLSBidWZmZXJJbmZvLmxlbiA6IDA7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyA9IChkZXRhaWxzLmVkZ2UgLSBwb3NpdGlvbikgKiAxMDAwO1xuICAgICAgY29uc3QgcmVsb2FkSW50ZXJ2YWwgPSBjb21wdXRlUmVsb2FkSW50ZXJ2YWwoXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIGRpc3RhbmNlVG9MaXZlRWRnZU1zLFxuICAgICAgKTtcbiAgICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgbm93ID4gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkICsgcmVsb2FkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zbiAhPT0gdW5kZWZpbmVkICYmIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID1cbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ICtcbiAgICAgICAgICByZWxvYWRJbnRlcnZhbCAtXG4gICAgICAgICAgKGRldGFpbHMucGFydFRhcmdldCAqIDEwMDAgfHwgMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPT09IC0xIHx8XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsIDwgbm93XG4gICAgICApIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gbm93O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVlc3RTY2hlZHVsZWQgLSBub3cgPD0gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKz0gcmVsb2FkSW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBsZXQgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gdGhpcy5yZXF1ZXN0U2NoZWR1bGVkIC0gbm93O1xuICAgICAgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlID0gTWF0aC5tYXgoMCwgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgcmVsb2FkIGxpdmUgcGxheWxpc3QgJHtpbmRleH0gaW4gJHtNYXRoLnJvdW5kKFxuICAgICAgICAgIGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSxcbiAgICAgICAgKX0gbXNgLFxuICAgICAgKTtcbiAgICAgIC8vIHRoaXMubG9nKFxuICAgICAgLy8gICBgbGl2ZSByZWxvYWQgJHtkZXRhaWxzLnVwZGF0ZWQgPyAnUkVGUkVTSEVEJyA6ICdNSVNTRUQnfVxuICAgICAgLy8gcmVsb2FkIGluICR7ZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlIC8gMTAwMH1cbiAgICAgIC8vIHJvdW5kIHRyaXAgJHsoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSAvIDEwMDB9XG4gICAgICAvLyBkaWZmICR7XG4gICAgICAvLyAgIChyZWxvYWRJbnRlcnZhbCAtXG4gICAgICAvLyAgICAgKGVzdGltYXRlZFRpbWVVbnRpbFVwZGF0ZSArXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCAtXG4gICAgICAvLyAgICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0KSkgL1xuICAgICAgLy8gICAxMDAwXG4gICAgICAvLyB9XG4gICAgICAvLyByZWxvYWQgaW50ZXJ2YWwgJHtyZWxvYWRJbnRlcnZhbCAvIDEwMDB9XG4gICAgICAvLyB0YXJnZXQgZHVyYXRpb24gJHtkZXRhaWxzLnRhcmdldGR1cmF0aW9ufVxuICAgICAgLy8gZGlzdGFuY2UgdG8gZWRnZSAke2Rpc3RhbmNlVG9MaXZlRWRnZU1zIC8gMTAwMH1gXG4gICAgICAvLyApO1xuXG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdChkZWxpdmVyeURpcmVjdGl2ZXMpLFxuICAgICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldERlbGl2ZXJ5RGlyZWN0aXZlcyhcbiAgICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gICAgcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXM6IEhsc1VybFBhcmFtZXRlcnMgfCBudWxsLFxuICAgIG1zbj86IG51bWJlcixcbiAgICBwYXJ0PzogbnVtYmVyLFxuICApOiBIbHNVcmxQYXJhbWV0ZXJzIHtcbiAgICBsZXQgc2tpcCA9IGdldFNraXBWYWx1ZShkZXRhaWxzLCBtc24pO1xuICAgIGlmIChwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcz8uc2tpcCAmJiBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBtc24gPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5tc247XG4gICAgICBwYXJ0ID0gcHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMucGFydDtcbiAgICAgIHNraXAgPSBIbHNTa2lwLk5vO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0LCBza2lwKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja1JldHJ5KGVycm9yRXZlbnQ6IEVycm9yRGF0YSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICBjb25zdCBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvckV2ZW50KTtcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGVycm9yRXZlbnQuZXJyb3JBY3Rpb247XG4gICAgY29uc3QgeyBhY3Rpb24sIHJldHJ5Q291bnQgPSAwLCByZXRyeUNvbmZpZyB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgY29uc3QgcmV0cnkgPVxuICAgICAgISFlcnJvckFjdGlvbiAmJlxuICAgICAgISFyZXRyeUNvbmZpZyAmJlxuICAgICAgKGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCB8fFxuICAgICAgICAoIWVycm9yQWN0aW9uLnJlc29sdmVkICYmXG4gICAgICAgICAgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCkpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICBpZiAocmV0cnlDb3VudCA+PSByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNUaW1lb3V0ICYmIGVycm9yRXZlbnQuY29udGV4dD8uZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtcbiAgICAgICAgICAgIHJldHJ5Q29uZmlnLm1heE51bVJldHJ5XG4gICAgICAgICAgfSBhZnRlciBcIiR7ZXJyb3JEZXRhaWxzfVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2AsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpO1xuICAgICAgICAvLyBTY2hlZHVsZSBsZXZlbC90cmFjayByZWxvYWRcbiAgICAgICAgdGhpcy50aW1lciA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB0aGlzLmxvYWRQbGF5bGlzdCgpLCBkZWxheSk7XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke3JldHJ5Q291bnQgKyAxfS8ke1xuICAgICAgICAgICAgcmV0cnlDb25maWcubWF4TnVtUmV0cnlcbiAgICAgICAgICB9IGFmdGVyIFwiJHtlcnJvckRldGFpbHN9XCIgaW4gJHtkZWxheX1tc2AsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBgbGV2ZWxSZXRyeSA9IHRydWVgIHVzZWQgdG8gaW5mb3JtIG90aGVyIGNvbnRyb2xsZXJzIHRoYXQgYSByZXRyeSBpcyBoYXBwZW5pbmdcbiAgICAgIGVycm9yRXZlbnQubGV2ZWxSZXRyeSA9IHRydWU7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXRyeTtcbiAgfVxufVxuIiwiLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG5jbGFzcyBFV01BIHtcbiAgcHVibGljIHJlYWRvbmx5IGhhbGZMaWZlOiBudW1iZXI7XG4gIHByaXZhdGUgYWxwaGFfOiBudW1iZXI7XG4gIHByaXZhdGUgZXN0aW1hdGVfOiBudW1iZXI7XG4gIHByaXZhdGUgdG90YWxXZWlnaHRfOiBudW1iZXI7XG5cbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmU6IG51bWJlciwgZXN0aW1hdGU6IG51bWJlciA9IDAsIHdlaWdodDogbnVtYmVyID0gMCkge1xuICAgIHRoaXMuaGFsZkxpZmUgPSBoYWxmTGlmZTtcbiAgICAvLyBMYXJnZXIgdmFsdWVzIG9mIGFscGhhIGV4cGlyZSBoaXN0b3JpY2FsIGRhdGEgbW9yZSBzbG93bHkuXG4gICAgdGhpcy5hbHBoYV8gPSBoYWxmTGlmZSA/IE1hdGguZXhwKE1hdGgubG9nKDAuNSkgLyBoYWxmTGlmZSkgOiAwO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gZXN0aW1hdGU7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB3ZWlnaHQ7XG4gIH1cblxuICBzYW1wbGUod2VpZ2h0OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBhZGpBbHBoYSA9IE1hdGgucG93KHRoaXMuYWxwaGFfLCB3ZWlnaHQpO1xuICAgIHRoaXMuZXN0aW1hdGVfID0gdmFsdWUgKiAoMSAtIGFkakFscGhhKSArIGFkakFscGhhICogdGhpcy5lc3RpbWF0ZV87XG4gICAgdGhpcy50b3RhbFdlaWdodF8gKz0gd2VpZ2h0O1xuICB9XG5cbiAgZ2V0VG90YWxXZWlnaHQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgY29uc3QgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgaWYgKHplcm9GYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVXTUE7XG4iLCIvKlxuICogRVdNQSBCYW5kd2lkdGggRXN0aW1hdG9yXG4gKiAgLSBoZWF2aWx5IGluc3BpcmVkIGZyb20gc2hha2EtcGxheWVyXG4gKiBUcmFja3MgYmFuZHdpZHRoIHNhbXBsZXMgYW5kIGVzdGltYXRlcyBhdmFpbGFibGUgYmFuZHdpZHRoLlxuICogQmFzZWQgb24gdGhlIG1pbmltdW0gb2YgdHdvIGV4cG9uZW50aWFsbHktd2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VzIHdpdGhcbiAqIGRpZmZlcmVudCBoYWxmLWxpdmVzLlxuICovXG5cbmltcG9ydCBFV01BIGZyb20gJy4uL3V0aWxzL2V3bWEnO1xuXG5jbGFzcyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgcHJpdmF0ZSBkZWZhdWx0RXN0aW1hdGVfOiBudW1iZXI7XG4gIHByaXZhdGUgbWluV2VpZ2h0XzogbnVtYmVyO1xuICBwcml2YXRlIG1pbkRlbGF5TXNfOiBudW1iZXI7XG4gIHByaXZhdGUgc2xvd186IEVXTUE7XG4gIHByaXZhdGUgZmFzdF86IEVXTUE7XG4gIHByaXZhdGUgZGVmYXVsdFRURkJfOiBudW1iZXI7XG4gIHByaXZhdGUgdHRmYl86IEVXTUE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc2xvdzogbnVtYmVyLFxuICAgIGZhc3Q6IG51bWJlcixcbiAgICBkZWZhdWx0RXN0aW1hdGU6IG51bWJlcixcbiAgICBkZWZhdWx0VFRGQjogbnVtYmVyID0gMTAwLFxuICApIHtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSBkZWZhdWx0RXN0aW1hdGU7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gMC4wMDE7XG4gICAgdGhpcy5taW5EZWxheU1zXyA9IDUwO1xuICAgIHRoaXMuc2xvd18gPSBuZXcgRVdNQShzbG93KTtcbiAgICB0aGlzLmZhc3RfID0gbmV3IEVXTUEoZmFzdCk7XG4gICAgdGhpcy5kZWZhdWx0VFRGQl8gPSBkZWZhdWx0VFRGQjtcbiAgICB0aGlzLnR0ZmJfID0gbmV3IEVXTUEoc2xvdyk7XG4gIH1cblxuICB1cGRhdGUoc2xvdzogbnVtYmVyLCBmYXN0OiBudW1iZXIpIHtcbiAgICBjb25zdCB7IHNsb3dfLCBmYXN0XywgdHRmYl8gfSA9IHRoaXM7XG4gICAgaWYgKHNsb3dfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdywgc2xvd18uZ2V0RXN0aW1hdGUoKSwgc2xvd18uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmIChmYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAodHRmYl8uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93LCB0dGZiXy5nZXRFc3RpbWF0ZSgpLCB0dGZiXy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH1cblxuICBzYW1wbGUoZHVyYXRpb25NczogbnVtYmVyLCBudW1CeXRlczogbnVtYmVyKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIGNvbnN0IG51bUJpdHMgPSA4ICogbnVtQnl0ZXM7XG4gICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICBjb25zdCBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAvLyB2YWx1ZSBpcyBiYW5kd2lkdGggaW4gYml0cy9zXG4gICAgY29uc3QgYmFuZHdpZHRoSW5CcHMgPSBudW1CaXRzIC8gZHVyYXRpb25TO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICB9XG5cbiAgc2FtcGxlVFRGQih0dGZiOiBudW1iZXIpIHtcbiAgICAvLyB3ZWlnaHQgaXMgZnJlcXVlbmN5IGN1cnZlIGFwcGxpZWQgdG8gVFRGQiBpbiBzZWNvbmRzXG4gICAgLy8gKGxvbmdlciB0aW1lcyBoYXZlIGxlc3Mgd2VpZ2h0IHdpdGggZXhwZWN0ZWQgaW5wdXQgdW5kZXIgMSBzZWNvbmQpXG4gICAgY29uc3Qgc2Vjb25kcyA9IHR0ZmIgLyAxMDAwO1xuICAgIGNvbnN0IHdlaWdodCA9IE1hdGguc3FydCgyKSAqIE1hdGguZXhwKC1NYXRoLnBvdyhzZWNvbmRzLCAyKSAvIDIpO1xuICAgIHRoaXMudHRmYl8uc2FtcGxlKHdlaWdodCwgTWF0aC5tYXgodHRmYiwgNSkpO1xuICB9XG5cbiAgY2FuRXN0aW1hdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF87XG4gIH1cblxuICBnZXRFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmNhbkVzdGltYXRlKCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzbG93IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZmFzdCBlc3RpbWF0ZTonKyBNYXRoLnJvdW5kKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSkpO1xuICAgICAgLy8gVGFrZSB0aGUgbWluaW11bSBvZiB0aGVzZSB0d28gZXN0aW1hdGVzLiAgVGhpcyBzaG91bGQgaGF2ZSB0aGUgZWZmZWN0IG9mXG4gICAgICAvLyBhZGFwdGluZyBkb3duIHF1aWNrbHksIGJ1dCB1cCBtb3JlIHNsb3dseS5cbiAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gICAgfVxuICB9XG5cbiAgZ2V0RXN0aW1hdGVUVEZCKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMudHRmYl8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldEVzdGltYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRUVEZCXztcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge31cbn1cbmV4cG9ydCBkZWZhdWx0IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3I7XG4iLCJpbXBvcnQgeyB0eXBlIFZpZGVvUmFuZ2UsIFZpZGVvUmFuZ2VWYWx1ZXMgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvU2VsZWN0aW9uT3B0aW9uIH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuXG4vKipcbiAqIEByZXR1cm5zIFdoZXRoZXIgd2UgY2FuIGRldGVjdCBhbmQgdmFsaWRhdGUgSERSIGNhcGFiaWxpdHkgd2l0aGluIHRoZSB3aW5kb3cgY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIZHJTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IG1lZGlhUXVlcnlMaXN0ID0gbWF0Y2hNZWRpYSgnKGR5bmFtaWMtcmFuZ2U6IGhpZ2gpJyk7XG4gICAgY29uc3QgYmFkUXVlcnkgPSBtYXRjaE1lZGlhKCdiYWQgcXVlcnknKTtcbiAgICBpZiAobWVkaWFRdWVyeUxpc3QubWVkaWEgIT09IGJhZFF1ZXJ5Lm1lZGlhKSB7XG4gICAgICByZXR1cm4gbWVkaWFRdWVyeUxpc3QubWF0Y2hlcyA9PT0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFNhbml0aXplcyBpbnB1dHMgdG8gcmV0dXJuIHRoZSBhY3RpdmUgdmlkZW8gc2VsZWN0aW9uIG9wdGlvbnMgZm9yIEhEUi9TRFIuXG4gKiBXaGVuIGJvdGggaW5wdXRzIGFyZSBudWxsOlxuICpcbiAqICAgIGB7IHByZWZlckhEUjogZmFsc2UsIGFsbG93ZWRWaWRlb1JhbmdlczogW10gfWBcbiAqXG4gKiBXaGVuIGBjdXJyZW50VmlkZW9SYW5nZWAgbm9uLW51bGwsIG1haW50YWluIHRoZSBhY3RpdmUgcmFuZ2U6XG4gKlxuICogICAgYHsgcHJlZmVySERSOiBjdXJyZW50VmlkZW9SYW5nZSAhPT0gJ1NEUicsIGFsbG93ZWRWaWRlb1JhbmdlczogW2N1cnJlbnRWaWRlb1JhbmdlXSB9YFxuICpcbiAqIFdoZW4gVmlkZW9TZWxlY3Rpb25PcHRpb24gbm9uLW51bGw6XG4gKlxuICogIC0gQWxsb3cgYWxsIHZpZGVvIHJhbmdlcyBpZiBgYWxsb3dlZFZpZGVvUmFuZ2VzYCB1bnNwZWNpZmllZC5cbiAqICAtIElmIGBwcmVmZXJIRFJgIGlzIG5vbi1udWxsIHVzZSB0aGUgdmFsdWUgdG8gZmlsdGVyIGBhbGxvd2VkVmlkZW9SYW5nZXNgLlxuICogIC0gRWxzZSBjaGVjayB3aW5kb3cgZm9yIEhEUiBzdXBwb3J0IGFuZCBzZXQgYHByZWZlckhEUmAgdG8gdGhlIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gY3VycmVudFZpZGVvUmFuZ2VcbiAqIEBwYXJhbSB2aWRlb1ByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyhcbiAgY3VycmVudFZpZGVvUmFuZ2U6IFZpZGVvUmFuZ2UgfCB1bmRlZmluZWQsXG4gIHZpZGVvUHJlZmVyZW5jZTogVmlkZW9TZWxlY3Rpb25PcHRpb24gfCB1bmRlZmluZWQsXG4pIHtcbiAgbGV0IHByZWZlckhEUiA9IGZhbHNlO1xuICBsZXQgYWxsb3dlZFZpZGVvUmFuZ2VzOiBBcnJheTxWaWRlb1JhbmdlPiA9IFtdO1xuXG4gIGlmIChjdXJyZW50VmlkZW9SYW5nZSkge1xuICAgIHByZWZlckhEUiA9IGN1cnJlbnRWaWRlb1JhbmdlICE9PSAnU0RSJztcbiAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbY3VycmVudFZpZGVvUmFuZ2VdO1xuICB9XG5cbiAgaWYgKHZpZGVvUHJlZmVyZW5jZSkge1xuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9XG4gICAgICB2aWRlb1ByZWZlcmVuY2UuYWxsb3dlZFZpZGVvUmFuZ2VzIHx8IFZpZGVvUmFuZ2VWYWx1ZXMuc2xpY2UoMCk7XG4gICAgcHJlZmVySERSID1cbiAgICAgIHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHZpZGVvUHJlZmVyZW5jZS5wcmVmZXJIRFJcbiAgICAgICAgOiBpc0hkclN1cHBvcnRlZCgpO1xuXG4gICAgaWYgKHByZWZlckhEUikge1xuICAgICAgYWxsb3dlZFZpZGVvUmFuZ2VzID0gYWxsb3dlZFZpZGVvUmFuZ2VzLmZpbHRlcihcbiAgICAgICAgKHJhbmdlOiBWaWRlb1JhbmdlKSA9PiByYW5nZSAhPT0gJ1NEUicsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbJ1NEUiddO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJlZmVySERSLFxuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZSB9IGZyb20gJy4vY29kZWNzJztcbmltcG9ydCB7IGdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyB9IGZyb20gJy4vaGRyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwsIFZpZGVvUmFuZ2UgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvU2VsZWN0aW9uT3B0aW9uLFxuICBNZWRpYVBsYXlsaXN0LFxuICBTdWJ0aXRsZVNlbGVjdGlvbk9wdGlvbixcbiAgVmlkZW9TZWxlY3Rpb25PcHRpb24sXG59IGZyb20gJy4uL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcblxuZXhwb3J0IHR5cGUgQ29kZWNTZXRUaWVyID0ge1xuICBtaW5CaXRyYXRlOiBudW1iZXI7XG4gIG1pbkhlaWdodDogbnVtYmVyO1xuICBtaW5GcmFtZXJhdGU6IG51bWJlcjtcbiAgbWF4U2NvcmU6IG51bWJlcjtcbiAgdmlkZW9SYW5nZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGNoYW5uZWxzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICBoYXNEZWZhdWx0QXVkaW86IGJvb2xlYW47XG4gIGZyYWdtZW50RXJyb3I6IG51bWJlcjtcbn07XG5cbnR5cGUgQXVkaW9UcmFja0dyb3VwID0ge1xuICB0cmFja3M6IE1lZGlhUGxheWxpc3RbXTtcbiAgY2hhbm5lbHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIGhhc0RlZmF1bHQ6IGJvb2xlYW47XG4gIGhhc0F1dG9TZWxlY3Q6IGJvb2xlYW47XG59O1xudHlwZSBTdGFydFBhcmFtZXRlcnMgPSB7XG4gIGNvZGVjU2V0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHZpZGVvUmFuZ2VzOiBBcnJheTxWaWRlb1JhbmdlPjtcbiAgcHJlZmVySERSOiBib29sZWFuO1xuICBtaW5GcmFtZXJhdGU6IG51bWJlcjtcbiAgbWluQml0cmF0ZTogbnVtYmVyO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXJ0Q29kZWNUaWVyKFxuICBjb2RlY1RpZXJzOiBSZWNvcmQ8c3RyaW5nLCBDb2RlY1NldFRpZXI+LFxuICBjdXJyZW50VmlkZW9SYW5nZTogVmlkZW9SYW5nZSB8IHVuZGVmaW5lZCxcbiAgY3VycmVudEJ3OiBudW1iZXIsXG4gIGF1ZGlvUHJlZmVyZW5jZTogQXVkaW9TZWxlY3Rpb25PcHRpb24gfCB1bmRlZmluZWQsXG4gIHZpZGVvUHJlZmVyZW5jZTogVmlkZW9TZWxlY3Rpb25PcHRpb24gfCB1bmRlZmluZWQsXG4pOiBTdGFydFBhcmFtZXRlcnMge1xuICBjb25zdCBjb2RlY1NldHMgPSBPYmplY3Qua2V5cyhjb2RlY1RpZXJzKTtcbiAgY29uc3QgY2hhbm5lbHNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlPy5jaGFubmVscztcbiAgY29uc3QgYXVkaW9Db2RlY1ByZWZlcmVuY2UgPSBhdWRpb1ByZWZlcmVuY2U/LmF1ZGlvQ29kZWM7XG4gIGNvbnN0IHByZWZlclN0ZXJlbyA9IGNoYW5uZWxzUHJlZmVyZW5jZSAmJiBwYXJzZUludChjaGFubmVsc1ByZWZlcmVuY2UpID09PSAyO1xuICAvLyBVc2UgZmlyc3QgbGV2ZWwgc2V0IHRvIGRldGVybWluZSBzdGVyZW8sIGFuZCBtaW5pbXVtIHJlc29sdXRpb24gYW5kIGZyYW1lcmF0ZVxuICBsZXQgaGFzU3RlcmVvID0gdHJ1ZTtcbiAgbGV0IGhhc0N1cnJlbnRWaWRlb1JhbmdlID0gZmFsc2U7XG4gIGxldCBtaW5IZWlnaHQgPSBJbmZpbml0eTtcbiAgbGV0IG1pbkZyYW1lcmF0ZSA9IEluZmluaXR5O1xuICBsZXQgbWluQml0cmF0ZSA9IEluZmluaXR5O1xuICBsZXQgc2VsZWN0ZWRTY29yZSA9IDA7XG4gIGxldCB2aWRlb1JhbmdlczogQXJyYXk8VmlkZW9SYW5nZT4gPSBbXTtcblxuICBjb25zdCB7IHByZWZlckhEUiwgYWxsb3dlZFZpZGVvUmFuZ2VzIH0gPSBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoXG4gICAgY3VycmVudFZpZGVvUmFuZ2UsXG4gICAgdmlkZW9QcmVmZXJlbmNlLFxuICApO1xuXG4gIGZvciAobGV0IGkgPSBjb2RlY1NldHMubGVuZ3RoOyBpLS07ICkge1xuICAgIGNvbnN0IHRpZXIgPSBjb2RlY1RpZXJzW2NvZGVjU2V0c1tpXV07XG4gICAgaGFzU3RlcmVvID0gdGllci5jaGFubmVsc1syXSA+IDA7XG4gICAgbWluSGVpZ2h0ID0gTWF0aC5taW4obWluSGVpZ2h0LCB0aWVyLm1pbkhlaWdodCk7XG4gICAgbWluRnJhbWVyYXRlID0gTWF0aC5taW4obWluRnJhbWVyYXRlLCB0aWVyLm1pbkZyYW1lcmF0ZSk7XG4gICAgbWluQml0cmF0ZSA9IE1hdGgubWluKG1pbkJpdHJhdGUsIHRpZXIubWluQml0cmF0ZSk7XG4gICAgY29uc3QgbWF0Y2hpbmdWaWRlb1JhbmdlcyA9IGFsbG93ZWRWaWRlb1Jhbmdlcy5maWx0ZXIoXG4gICAgICAocmFuZ2UpID0+IHRpZXIudmlkZW9SYW5nZXNbcmFuZ2VdID4gMCxcbiAgICApO1xuICAgIGlmIChtYXRjaGluZ1ZpZGVvUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhc0N1cnJlbnRWaWRlb1JhbmdlID0gdHJ1ZTtcbiAgICAgIHZpZGVvUmFuZ2VzID0gbWF0Y2hpbmdWaWRlb1JhbmdlcztcbiAgICB9XG4gIH1cbiAgbWluSGVpZ2h0ID0gTnVtYmVyLmlzRmluaXRlKG1pbkhlaWdodCkgPyBtaW5IZWlnaHQgOiAwO1xuICBtaW5GcmFtZXJhdGUgPSBOdW1iZXIuaXNGaW5pdGUobWluRnJhbWVyYXRlKSA/IG1pbkZyYW1lcmF0ZSA6IDA7XG4gIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KDEwODAsIG1pbkhlaWdodCk7XG4gIGNvbnN0IG1heEZyYW1lcmF0ZSA9IE1hdGgubWF4KDMwLCBtaW5GcmFtZXJhdGUpO1xuICBtaW5CaXRyYXRlID0gTnVtYmVyLmlzRmluaXRlKG1pbkJpdHJhdGUpID8gbWluQml0cmF0ZSA6IGN1cnJlbnRCdztcbiAgY3VycmVudEJ3ID0gTWF0aC5tYXgobWluQml0cmF0ZSwgY3VycmVudEJ3KTtcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIHZhcmlhbnRzIHdpdGggbWF0Y2hpbmcgcHJlZmVyZW5jZSwgc2V0IGN1cnJlbnRWaWRlb1JhbmdlIHRvIHVuZGVmaW5lZFxuICBpZiAoIWhhc0N1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgY3VycmVudFZpZGVvUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdmlkZW9SYW5nZXMgPSBbXTtcbiAgfVxuICBjb25zdCBjb2RlY1NldCA9IGNvZGVjU2V0cy5yZWR1Y2UoXG4gICAgKHNlbGVjdGVkOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNhbmRpZGF0ZTogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgY2FuZGlhdGVzIHdoaWNoIGRvIG5vdCBtZWV0IGJpdHJhdGUsIGRlZmF1bHQgYXVkaW8sIHN0ZXJlbyBvciBjaGFubmVscyBwcmVmZXJlbmNlLCAxMDgwcCBvciBsb3dlciwgMzBmcHMgb3IgbG93ZXIsIG9yIFNEUi9IRFIgc2VsZWN0aW9uIGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVRpZXIgPSBjb2RlY1RpZXJzW2NhbmRpZGF0ZV07XG4gICAgICBpZiAoY2FuZGlkYXRlID09PSBzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5CaXRyYXRlID4gY3VycmVudEJ3KSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKFxuICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICBgbWluIGJpdHJhdGUgb2YgJHtjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGV9ID4gY3VycmVudCBlc3RpbWF0ZSBvZiAke2N1cnJlbnRCd31gLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWNhbmRpZGF0ZVRpZXIuaGFzRGVmYXVsdEF1ZGlvKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKFxuICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICBgbm8gcmVuZGl0aW9ucyB3aXRoIGRlZmF1bHQgb3IgYXV0by1zZWxlY3Qgc291bmQgZm91bmRgLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGF1ZGlvQ29kZWNQcmVmZXJlbmNlICYmXG4gICAgICAgIGNhbmRpZGF0ZS5pbmRleE9mKGF1ZGlvQ29kZWNQcmVmZXJlbmNlLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoXG4gICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgIGBhdWRpbyBjb2RlYyBwcmVmZXJlbmNlIFwiJHthdWRpb0NvZGVjUHJlZmVyZW5jZX1cIiBub3QgZm91bmRgLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbHNQcmVmZXJlbmNlICYmICFwcmVmZXJTdGVyZW8pIHtcbiAgICAgICAgaWYgKCFjYW5kaWRhdGVUaWVyLmNoYW5uZWxzW2NoYW5uZWxzUHJlZmVyZW5jZV0pIHtcbiAgICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIGBubyByZW5kaXRpb25zIHdpdGggJHtjaGFubmVsc1ByZWZlcmVuY2V9IGNoYW5uZWwgc291bmQgZm91bmQgKGNoYW5uZWxzIG9wdGlvbnM6ICR7T2JqZWN0LmtleXMoXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZVRpZXIuY2hhbm5lbHMsXG4gICAgICAgICAgICApfSlgLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoIWF1ZGlvQ29kZWNQcmVmZXJlbmNlIHx8IHByZWZlclN0ZXJlbykgJiZcbiAgICAgICAgaGFzU3RlcmVvICYmXG4gICAgICAgIGNhbmRpZGF0ZVRpZXIuY2hhbm5lbHNbJzInXSA9PT0gMFxuICAgICAgKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKFxuICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICBgbm8gcmVuZGl0aW9ucyB3aXRoIHN0ZXJlbyBzb3VuZCBmb3VuZGAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGVUaWVyLm1pbkhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChcbiAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgYG1pbiByZXNvbHV0aW9uIG9mICR7Y2FuZGlkYXRlVGllci5taW5IZWlnaHR9ID4gbWF4aW11bSBvZiAke21heEhlaWdodH1gLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5taW5GcmFtZXJhdGUgPiBtYXhGcmFtZXJhdGUpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoXG4gICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgIGBtaW4gZnJhbWVyYXRlIG9mICR7Y2FuZGlkYXRlVGllci5taW5GcmFtZXJhdGV9ID4gbWF4aW11bSBvZiAke21heEZyYW1lcmF0ZX1gLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIXZpZGVvUmFuZ2VzLnNvbWUoKHJhbmdlKSA9PiBjYW5kaWRhdGVUaWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApKSB7XG4gICAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKFxuICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICBgbm8gdmFyaWFudHMgd2l0aCBWSURFTy1SQU5HRSBvZiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgdmlkZW9SYW5nZXMsXG4gICAgICAgICAgKX0gZm91bmRgLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoY2FuZGlkYXRlVGllci5tYXhTY29yZSA8IHNlbGVjdGVkU2NvcmUpIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoXG4gICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgIGBtYXggc2NvcmUgb2YgJHtjYW5kaWRhdGVUaWVyLm1heFNjb3JlfSA8IHNlbGVjdGVkIG1heCBvZiAke3NlbGVjdGVkU2NvcmV9YCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNhbmRpYXRlcyB3aXRoIGxlc3MgcHJlZmVycmVkIGNvZGVjcyBvciBtb3JlIGVycm9yc1xuICAgICAgaWYgKFxuICAgICAgICBzZWxlY3RlZCAmJlxuICAgICAgICAoY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNhbmRpZGF0ZSkgPj1cbiAgICAgICAgICBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoc2VsZWN0ZWQpIHx8XG4gICAgICAgICAgY2FuZGlkYXRlVGllci5mcmFnbWVudEVycm9yID4gY29kZWNUaWVyc1tzZWxlY3RlZF0uZnJhZ21lbnRFcnJvcilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZFNjb3JlID0gY2FuZGlkYXRlVGllci5tYXhTY29yZTtcbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfSxcbiAgICB1bmRlZmluZWQsXG4gICk7XG4gIHJldHVybiB7XG4gICAgY29kZWNTZXQsXG4gICAgdmlkZW9SYW5nZXMsXG4gICAgcHJlZmVySERSLFxuICAgIG1pbkZyYW1lcmF0ZSxcbiAgICBtaW5CaXRyYXRlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjb2RlU2V0OiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKSB7XG4gIGxvZ2dlci5sb2coXG4gICAgYFthYnJdIHN0YXJ0IGNhbmRpZGF0ZXMgd2l0aCBcIiR7Y29kZVNldH1cIiBpZ25vcmVkIGJlY2F1c2UgJHtyZWFzb259YCxcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgQXVkaW9UcmFja3NCeUdyb3VwID0ge1xuICBoYXNEZWZhdWx0QXVkaW86IGJvb2xlYW47XG4gIGhhc0F1dG9TZWxlY3RBdWRpbzogYm9vbGVhbjtcbiAgZ3JvdXBzOiBSZWNvcmQ8c3RyaW5nLCBBdWRpb1RyYWNrR3JvdXA+O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrczogTWVkaWFQbGF5bGlzdFtdKSB7XG4gIHJldHVybiBhbGxBdWRpb1RyYWNrcy5yZWR1Y2UoXG4gICAgKGF1ZGlvVHJhY2tzQnlHcm91cDogQXVkaW9UcmFja3NCeUdyb3VwLCB0cmFjaykgPT4ge1xuICAgICAgbGV0IHRyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW3RyYWNrLmdyb3VwSWRdO1xuICAgICAgaWYgKCF0cmFja0dyb3VwKSB7XG4gICAgICAgIHRyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW3RyYWNrLmdyb3VwSWRdID0ge1xuICAgICAgICAgIHRyYWNrczogW10sXG4gICAgICAgICAgY2hhbm5lbHM6IHsgMjogMCB9LFxuICAgICAgICAgIGhhc0RlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGhhc0F1dG9TZWxlY3Q6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdHJhY2tHcm91cC50cmFja3MucHVzaCh0cmFjayk7XG4gICAgICBjb25zdCBjaGFubmVsc0tleSA9IHRyYWNrLmNoYW5uZWxzIHx8ICcyJztcbiAgICAgIHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldID1cbiAgICAgICAgKHRyYWNrR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNLZXldIHx8IDApICsgMTtcbiAgICAgIHRyYWNrR3JvdXAuaGFzRGVmYXVsdCA9IHRyYWNrR3JvdXAuaGFzRGVmYXVsdCB8fCB0cmFjay5kZWZhdWx0O1xuICAgICAgdHJhY2tHcm91cC5oYXNBdXRvU2VsZWN0ID0gdHJhY2tHcm91cC5oYXNBdXRvU2VsZWN0IHx8IHRyYWNrLmF1dG9zZWxlY3Q7XG4gICAgICBpZiAodHJhY2tHcm91cC5oYXNEZWZhdWx0KSB7XG4gICAgICAgIGF1ZGlvVHJhY2tzQnlHcm91cC5oYXNEZWZhdWx0QXVkaW8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRyYWNrR3JvdXAuaGFzQXV0b1NlbGVjdCkge1xuICAgICAgICBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzQXV0b1NlbGVjdEF1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdWRpb1RyYWNrc0J5R3JvdXA7XG4gICAgfSxcbiAgICB7XG4gICAgICBoYXNEZWZhdWx0QXVkaW86IGZhbHNlLFxuICAgICAgaGFzQXV0b1NlbGVjdEF1ZGlvOiBmYWxzZSxcbiAgICAgIGdyb3Vwczoge30sXG4gICAgfSxcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvZGVjVGllcnMoXG4gIGxldmVsczogTGV2ZWxbXSxcbiAgYXVkaW9UcmFja3NCeUdyb3VwOiBBdWRpb1RyYWNrc0J5R3JvdXAsXG4gIG1pbkF1dG9MZXZlbDogbnVtYmVyLFxuICBtYXhBdXRvTGV2ZWw6IG51bWJlcixcbik6IFJlY29yZDxzdHJpbmcsIENvZGVjU2V0VGllcj4ge1xuICByZXR1cm4gbGV2ZWxzXG4gICAgLnNsaWNlKG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsICsgMSlcbiAgICAucmVkdWNlKCh0aWVyczogUmVjb3JkPHN0cmluZywgQ29kZWNTZXRUaWVyPiwgbGV2ZWwpID0+IHtcbiAgICAgIGlmICghbGV2ZWwuY29kZWNTZXQpIHtcbiAgICAgICAgcmV0dXJuIHRpZXJzO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICAgIGxldCB0aWVyID0gdGllcnNbbGV2ZWwuY29kZWNTZXRdO1xuICAgICAgaWYgKCF0aWVyKSB7XG4gICAgICAgIHRpZXJzW2xldmVsLmNvZGVjU2V0XSA9IHRpZXIgPSB7XG4gICAgICAgICAgbWluQml0cmF0ZTogSW5maW5pdHksXG4gICAgICAgICAgbWluSGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgICBtaW5GcmFtZXJhdGU6IEluZmluaXR5LFxuICAgICAgICAgIG1heFNjb3JlOiAwLFxuICAgICAgICAgIHZpZGVvUmFuZ2VzOiB7IFNEUjogMCB9LFxuICAgICAgICAgIGNoYW5uZWxzOiB7ICcyJzogMCB9LFxuICAgICAgICAgIGhhc0RlZmF1bHRBdWRpbzogIWF1ZGlvR3JvdXBzLFxuICAgICAgICAgIGZyYWdtZW50RXJyb3I6IDAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aWVyLm1pbkJpdHJhdGUgPSBNYXRoLm1pbih0aWVyLm1pbkJpdHJhdGUsIGxldmVsLmJpdHJhdGUpO1xuICAgICAgY29uc3QgbGVzc2VyV2lkdGhPckhlaWdodCA9IE1hdGgubWluKGxldmVsLmhlaWdodCwgbGV2ZWwud2lkdGgpO1xuICAgICAgdGllci5taW5IZWlnaHQgPSBNYXRoLm1pbih0aWVyLm1pbkhlaWdodCwgbGVzc2VyV2lkdGhPckhlaWdodCk7XG4gICAgICB0aWVyLm1pbkZyYW1lcmF0ZSA9IE1hdGgubWluKHRpZXIubWluRnJhbWVyYXRlLCBsZXZlbC5mcmFtZVJhdGUpO1xuICAgICAgdGllci5tYXhTY29yZSA9IE1hdGgubWF4KHRpZXIubWF4U2NvcmUsIGxldmVsLnNjb3JlKTtcbiAgICAgIHRpZXIuZnJhZ21lbnRFcnJvciArPSBsZXZlbC5mcmFnbWVudEVycm9yO1xuICAgICAgdGllci52aWRlb1Jhbmdlc1tsZXZlbC52aWRlb1JhbmdlXSA9XG4gICAgICAgICh0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdIHx8IDApICsgMTtcbiAgICAgIGlmIChhdWRpb0dyb3Vwcykge1xuICAgICAgICBhdWRpb0dyb3Vwcy5mb3JFYWNoKChhdWRpb0dyb3VwSWQpID0+IHtcbiAgICAgICAgICBpZiAoIWF1ZGlvR3JvdXBJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdWRpb0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3VwSWRdO1xuICAgICAgICAgIC8vIERlZmF1bHQgYXVkaW8gaXMgYW55IGdyb3VwIHdpdGggREVGQVVMVD1ZRVMsIG9yIGlmIG1pc3NpbmcgdGhlbiBhbnkgZ3JvdXAgd2l0aCBBVVRPU0VMRUNUPVlFUywgb3IgYWxsIHZhcmlhbnRzXG4gICAgICAgICAgdGllci5oYXNEZWZhdWx0QXVkaW8gPVxuICAgICAgICAgICAgdGllci5oYXNEZWZhdWx0QXVkaW8gfHwgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpb1xuICAgICAgICAgICAgICA/IGF1ZGlvR3JvdXAuaGFzRGVmYXVsdFxuICAgICAgICAgICAgICA6IGF1ZGlvR3JvdXAuaGFzQXV0b1NlbGVjdCB8fFxuICAgICAgICAgICAgICAgICghYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyAmJlxuICAgICAgICAgICAgICAgICAgIWF1ZGlvVHJhY2tzQnlHcm91cC5oYXNBdXRvU2VsZWN0QXVkaW8pO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvR3JvdXAuY2hhbm5lbHMpLmZvckVhY2goKGNoYW5uZWxzKSA9PiB7XG4gICAgICAgICAgICB0aWVyLmNoYW5uZWxzW2NoYW5uZWxzXSA9XG4gICAgICAgICAgICAgICh0aWVyLmNoYW5uZWxzW2NoYW5uZWxzXSB8fCAwKSArIGF1ZGlvR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aWVycztcbiAgICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdPcHRpb24oXG4gIG9wdGlvbjogTWVkaWFQbGF5bGlzdCB8IEF1ZGlvU2VsZWN0aW9uT3B0aW9uIHwgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24sXG4gIHRyYWNrczogTWVkaWFQbGF5bGlzdFtdLFxuICBtYXRjaFByZWRpY2F0ZT86IChcbiAgICBvcHRpb246IE1lZGlhUGxheWxpc3QgfCBBdWRpb1NlbGVjdGlvbk9wdGlvbiB8IFN1YnRpdGxlU2VsZWN0aW9uT3B0aW9uLFxuICAgIHRyYWNrOiBNZWRpYVBsYXlsaXN0LFxuICApID0+IGJvb2xlYW4sXG4pOiBudW1iZXIge1xuICBpZiAoJ2F0dHJzJyBpbiBvcHRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRyYWNrcy5pbmRleE9mKG9wdGlvbik7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgIGlmIChtYXRjaGVzT3B0aW9uKG9wdGlvbiwgdHJhY2ssIG1hdGNoUHJlZGljYXRlKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXNPcHRpb24oXG4gIG9wdGlvbjogTWVkaWFQbGF5bGlzdCB8IEF1ZGlvU2VsZWN0aW9uT3B0aW9uIHwgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24sXG4gIHRyYWNrOiBNZWRpYVBsYXlsaXN0LFxuICBtYXRjaFByZWRpY2F0ZT86IChcbiAgICBvcHRpb246IE1lZGlhUGxheWxpc3QgfCBBdWRpb1NlbGVjdGlvbk9wdGlvbiB8IFN1YnRpdGxlU2VsZWN0aW9uT3B0aW9uLFxuICAgIHRyYWNrOiBNZWRpYVBsYXlsaXN0LFxuICApID0+IGJvb2xlYW4sXG4pOiBib29sZWFuIHtcbiAgY29uc3Qge1xuICAgIGdyb3VwSWQsXG4gICAgbmFtZSxcbiAgICBsYW5nLFxuICAgIGFzc29jTGFuZyxcbiAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgZGVmYXVsdDogaXNEZWZhdWx0LFxuICB9ID0gb3B0aW9uO1xuICBjb25zdCBmb3JjZWQgPSAob3B0aW9uIGFzIFN1YnRpdGxlU2VsZWN0aW9uT3B0aW9uKS5mb3JjZWQ7XG4gIHJldHVybiAoXG4gICAgKGdyb3VwSWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5ncm91cElkID09PSBncm91cElkKSAmJlxuICAgIChuYW1lID09PSB1bmRlZmluZWQgfHwgdHJhY2submFtZSA9PT0gbmFtZSkgJiZcbiAgICAobGFuZyA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmxhbmcgPT09IGxhbmcpICYmXG4gICAgKGxhbmcgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5hc3NvY0xhbmcgPT09IGFzc29jTGFuZykgJiZcbiAgICAoaXNEZWZhdWx0ID09PSB1bmRlZmluZWQgfHwgdHJhY2suZGVmYXVsdCA9PT0gaXNEZWZhdWx0KSAmJlxuICAgIChmb3JjZWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5mb3JjZWQgPT09IGZvcmNlZCkgJiZcbiAgICAoY2hhcmFjdGVyaXN0aWNzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGNoYXJhY3RlcmlzdGljc01hdGNoKGNoYXJhY3RlcmlzdGljcywgdHJhY2suY2hhcmFjdGVyaXN0aWNzKSkgJiZcbiAgICAobWF0Y2hQcmVkaWNhdGUgPT09IHVuZGVmaW5lZCB8fCBtYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2hhcmFjdGVyaXN0aWNzTWF0Y2goXG4gIGNoYXJhY3RlcmlzdGljc0E6IHN0cmluZyxcbiAgY2hhcmFjdGVyaXN0aWNzQjogc3RyaW5nID0gJycsXG4pOiBib29sZWFuIHtcbiAgY29uc3QgYXJyQSA9IGNoYXJhY3RlcmlzdGljc0Euc3BsaXQoJywnKTtcbiAgY29uc3QgYXJyQiA9IGNoYXJhY3RlcmlzdGljc0Iuc3BsaXQoJywnKTtcbiAgLy8gRXhwZWN0cyBlYWNoIGl0ZW0gdG8gYmUgdW5pcXVlOlxuICByZXR1cm4gKFxuICAgIGFyckEubGVuZ3RoID09PSBhcnJCLmxlbmd0aCAmJiAhYXJyQS5zb21lKChlbCkgPT4gYXJyQi5pbmRleE9mKGVsKSA9PT0gLTEpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdWRpb01hdGNoUHJlZGljYXRlKFxuICBvcHRpb246IE1lZGlhUGxheWxpc3QgfCBBdWRpb1NlbGVjdGlvbk9wdGlvbixcbiAgdHJhY2s6IE1lZGlhUGxheWxpc3QsXG4pIHtcbiAgY29uc3QgeyBhdWRpb0NvZGVjLCBjaGFubmVscyB9ID0gb3B0aW9uO1xuICByZXR1cm4gKFxuICAgIChhdWRpb0NvZGVjID09PSB1bmRlZmluZWQgfHxcbiAgICAgICh0cmFjay5hdWRpb0NvZGVjIHx8ICcnKS5zdWJzdHJpbmcoMCwgNCkgPT09XG4gICAgICAgIGF1ZGlvQ29kZWMuc3Vic3RyaW5nKDAsIDQpKSAmJlxuICAgIChjaGFubmVscyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5uZWxzID09PSAodHJhY2suY2hhbm5lbHMgfHwgJzInKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDbG9zZXN0TGV2ZWxXaXRoQXVkaW9Hcm91cChcbiAgb3B0aW9uOiBNZWRpYVBsYXlsaXN0IHwgQXVkaW9TZWxlY3Rpb25PcHRpb24sXG4gIGxldmVsczogTGV2ZWxbXSxcbiAgYWxsQXVkaW9UcmFja3M6IE1lZGlhUGxheWxpc3RbXSxcbiAgc2VhcmNoSW5kZXg6IG51bWJlcixcbiAgbWF0Y2hQcmVkaWNhdGU6IChcbiAgICBvcHRpb246IE1lZGlhUGxheWxpc3QgfCBBdWRpb1NlbGVjdGlvbk9wdGlvbixcbiAgICB0cmFjazogTWVkaWFQbGF5bGlzdCxcbiAgKSA9PiBib29sZWFuLFxuKTogbnVtYmVyIHtcbiAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW3NlYXJjaEluZGV4XTtcbiAgLy8gQXJlIHRoZXJlIHZhcmlhbnRzIHdpdGggc2FtZSBVUkkgYXMgY3VycmVudCBsZXZlbD9cbiAgLy8gSWYgc28sIGZpbmQgYSBtYXRjaCB0aGF0IGRvZXMgbm90IHJlcXVpcmUgYW55IGxldmVsIFVSSSBjaGFuZ2VcbiAgY29uc3QgdmFyaWFudHMgPSBsZXZlbHMucmVkdWNlKFxuICAgICh2YXJpYW50TWFwOiB7IFt1cmk6IHN0cmluZ106IG51bWJlcltdIH0sIGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgdXJpID0gbGV2ZWwudXJpO1xuICAgICAgY29uc3QgcmVuZGl0aW9ucyA9IHZhcmlhbnRNYXBbdXJpXSB8fCAodmFyaWFudE1hcFt1cmldID0gW10pO1xuICAgICAgcmVuZGl0aW9ucy5wdXNoKGluZGV4KTtcbiAgICAgIHJldHVybiB2YXJpYW50TWFwO1xuICAgIH0sXG4gICAge30sXG4gICk7XG4gIGNvbnN0IHJlbmRpdGlvbnMgPSB2YXJpYW50c1tjdXJyZW50TGV2ZWwudXJpXTtcbiAgaWYgKHJlbmRpdGlvbnMubGVuZ3RoID4gMSkge1xuICAgIHNlYXJjaEluZGV4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcmVuZGl0aW9ucyk7XG4gIH1cbiAgLy8gRmluZCBiZXN0IG1hdGNoXG4gIGNvbnN0IGN1cnJlbnRWaWRlb1JhbmdlID0gY3VycmVudExldmVsLnZpZGVvUmFuZ2U7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZVJhdGUgPSBjdXJyZW50TGV2ZWwuZnJhbWVSYXRlO1xuICBjb25zdCBjdXJyZW50VmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCk7XG4gIGNvbnN0IG1hdGNoaW5nVmlkZW8gPSBzZWFyY2hEb3duQW5kVXBMaXN0KFxuICAgIGxldmVscyxcbiAgICBzZWFyY2hJbmRleCxcbiAgICAobGV2ZWw6IExldmVsKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGxldmVsLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8XG4gICAgICAgIGxldmVsLmZyYW1lUmF0ZSAhPT0gY3VycmVudEZyYW1lUmF0ZSB8fFxuICAgICAgICBsZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCkgIT09IGN1cnJlbnRWaWRlb0NvZGVjXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICAgIGNvbnN0IHRyYWNrcyA9IGFsbEF1ZGlvVHJhY2tzLmZpbHRlcihcbiAgICAgICAgKHRyYWNrKTogYm9vbGVhbiA9PlxuICAgICAgICAgICFhdWRpb0dyb3VwcyB8fCBhdWRpb0dyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMSxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgICB9LFxuICApO1xuICBpZiAobWF0Y2hpbmdWaWRlbyA+IC0xKSB7XG4gICAgcmV0dXJuIG1hdGNoaW5nVmlkZW87XG4gIH1cbiAgcmV0dXJuIHNlYXJjaERvd25BbmRVcExpc3QobGV2ZWxzLCBzZWFyY2hJbmRleCwgKGxldmVsOiBMZXZlbCkgPT4ge1xuICAgIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgY29uc3QgdHJhY2tzID0gYWxsQXVkaW9UcmFja3MuZmlsdGVyKFxuICAgICAgKHRyYWNrKTogYm9vbGVhbiA9PlxuICAgICAgICAhYXVkaW9Hcm91cHMgfHwgYXVkaW9Hcm91cHMuaW5kZXhPZih0cmFjay5ncm91cElkKSAhPT0gLTEsXG4gICAgKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlYXJjaERvd25BbmRVcExpc3QoXG4gIGFycjogYW55W10sXG4gIHNlYXJjaEluZGV4OiBudW1iZXIsXG4gIHByZWRpY2F0ZTogKGl0ZW06IGFueSkgPT4gYm9vbGVhbixcbik6IG51bWJlciB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hJbmRleDsgaTsgaS0tKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IHNlYXJjaEluZGV4ICsgMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsImltcG9ydCBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIGZyb20gJy4uL3V0aWxzL2V3bWEtYmFuZHdpZHRoLWVzdGltYXRvcic7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQge1xuICBTVVBQT1JURURfSU5GT19ERUZBVUxULFxuICBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UsXG4gIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8sXG59IGZyb20gJy4uL3V0aWxzL21lZGlhY2FwYWJpbGl0aWVzLWhlbHBlcic7XG5pbXBvcnQge1xuICBnZXRBdWRpb1RyYWNrc0J5R3JvdXAsXG4gIGdldENvZGVjVGllcnMsXG4gIGdldFN0YXJ0Q29kZWNUaWVyLFxuICB0eXBlIEF1ZGlvVHJhY2tzQnlHcm91cCxcbiAgdHlwZSBDb2RlY1NldFRpZXIsXG59IGZyb20gJy4uL3V0aWxzL3JlbmRpdGlvbi1oZWxwZXInO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnQgfSBmcm9tICcuLi9sb2FkZXIvZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbCwgVmlkZW9SYW5nZSB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgTG9hZGVyU3RhdHMgfSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7XG4gIEZyYWdMb2FkaW5nRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgTGV2ZWxTd2l0Y2hpbmdEYXRhLFxuICBNYW5pZmVzdExvYWRpbmdEYXRhLFxuICBFcnJvckRhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEFickNvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuXG5jbGFzcyBBYnJDb250cm9sbGVyIGltcGxlbWVudHMgQWJyQ29tcG9uZW50QVBJIHtcbiAgcHJvdGVjdGVkIGhsczogSGxzO1xuICBwcml2YXRlIGxhc3RMZXZlbExvYWRTZWM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgbGFzdExvYWRlZEZyYWdMZXZlbDogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgZmlyc3RTZWxlY3Rpb246IG51bWJlciA9IC0xO1xuICBwcml2YXRlIF9uZXh0QXV0b0xldmVsOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBuZXh0QXV0b0xldmVsS2V5OiBzdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBhdWRpb1RyYWNrc0J5R3JvdXA6IEF1ZGlvVHJhY2tzQnlHcm91cCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvZGVjVGllcnM6IFJlY29yZDxzdHJpbmcsIENvZGVjU2V0VGllcj4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0aW1lcjogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgZnJhZ0N1cnJlbnQ6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcGFydEN1cnJlbnQ6IFBhcnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBiaXRyYXRlVGVzdERlbGF5OiBudW1iZXIgPSAwO1xuXG4gIHB1YmxpYyBid0VzdGltYXRvcjogRXdtYUJhbmRXaWR0aEVzdGltYXRvcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZT86IG51bWJlcikge1xuICAgIGlmIChhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICBsb2dnZXIubG9nKGBzZXR0aW5nIGluaXRpYWwgYndlIHRvICR7YWJyRXdtYURlZmF1bHRFc3RpbWF0ZX1gKTtcbiAgICAgIHRoaXMuaGxzLmNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlID0gYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdEVzdGltYXRvcigpOiBFd21hQmFuZFdpZHRoRXN0aW1hdG9yIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmhscy5jb25maWc7XG4gICAgcmV0dXJuIG5ldyBFd21hQmFuZFdpZHRoRXN0aW1hdG9yKFxuICAgICAgY29uZmlnLmFickV3bWFTbG93Vm9ELFxuICAgICAgY29uZmlnLmFickV3bWFGYXN0Vm9ELFxuICAgICAgY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gbnVsbDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NYW5pZmVzdExvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gICkge1xuICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcbiAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSAwO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLm9uTGV2ZWxzVXBkYXRlZCgpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsc1VwZGF0ZWQoKSB7XG4gICAgaWYgKHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpO1xuICAgIHRoaXMuY29kZWNUaWVycyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1heEF1dG9MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ0xvYWRpbmcoZXZlbnQ6IEV2ZW50cy5GUkFHX0xPQURJTkcsIGRhdGE6IEZyYWdMb2FkaW5nRGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIHRoaXMucGFydEN1cnJlbnQgPSBkYXRhLnBhcnQgPz8gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2ssIDEwMCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb25MZXZlbFN3aXRjaGluZyhcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1NXSVRDSElORyxcbiAgICBkYXRhOiBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uRXJyb3IoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAvLyBSZXNldCBsYXN0IGxvYWRlZCBsZXZlbCBzbyB0aGF0IGEgbmV3IHNlbGVjdGlvbiBjYW4gYmUgbWFkZSBhZnRlciBjYWxsaW5nIHJlY292ZXJNZWRpYUVycm9yXG4gICAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6IHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAgICAgY29uc3QgeyBmcmFnQ3VycmVudCwgcGFydEN1cnJlbnQ6IHBhcnQgfSA9IHRoaXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBmcmFnICYmXG4gICAgICAgICAgZnJhZ0N1cnJlbnQgJiZcbiAgICAgICAgICBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJlxuICAgICAgICAgIGZyYWcubGV2ZWwgPT09IGZyYWdDdXJyZW50LmxldmVsXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IHN0YXRzOiBMb2FkZXJTdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgICBjb25zdCB0aW1lTG9hZGluZyA9IG5vdyAtIHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgdHRmYiA9IHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgICAgICAgID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnRcbiAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgY29uc3QgbG9hZGVkRmlyc3RCeXRlID0gc3RhdHMubG9hZGVkICYmIHR0ZmIgPiAtMTtcbiAgICAgICAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgICAgICBjb25zdCB0dGZiRXN0aW1hdGUgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUoXG4gICAgICAgICAgICAgIHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSxcbiAgICAgICAgICAgICAgc3RhdHMubG9hZGVkLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHRpbWVMb2FkaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRUaW1lVG9Mb2FkRnJhZyhcbiAgICB0aW1lVG9GaXJzdEJ5dGVTZWM6IG51bWJlcixcbiAgICBiYW5kd2lkdGg6IG51bWJlcixcbiAgICBmcmFnU2l6ZUJpdHM6IG51bWJlcixcbiAgICBpc1N3aXRjaDogYm9vbGVhbixcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBmcmFnTG9hZFNlYyA9IHRpbWVUb0ZpcnN0Qnl0ZVNlYyArIGZyYWdTaXplQml0cyAvIGJhbmR3aWR0aDtcbiAgICBjb25zdCBwbGF5bGlzdExvYWRTZWMgPSBpc1N3aXRjaCA/IHRoaXMubGFzdExldmVsTG9hZFNlYyA6IDA7XG4gICAgcmV0dXJuIGZyYWdMb2FkU2VjICsgcGxheWxpc3RMb2FkU2VjO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTGV2ZWxMb2FkZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsIGRhdGE6IExldmVsTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCB7IGxvYWRpbmcgfSA9IGRhdGEuc3RhdHM7XG4gICAgY29uc3QgdGltZUxvYWRpbmdNcyA9IGxvYWRpbmcuZW5kIC0gbG9hZGluZy5zdGFydDtcbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHRpbWVMb2FkaW5nTXMpKSB7XG4gICAgICB0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSB0aW1lTG9hZGluZ01zIC8gMTAwMDtcbiAgICB9XG4gICAgaWYgKGRhdGEuZGV0YWlscy5saXZlKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShjb25maWcuYWJyRXdtYVNsb3dMaXZlLCBjb25maWcuYWJyRXdtYUZhc3RMaXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICBUaGlzIG1ldGhvZCBtb25pdG9ycyB0aGUgZG93bmxvYWQgcmF0ZSBvZiB0aGUgY3VycmVudCBmcmFnbWVudCwgYW5kIHdpbGwgZG93bnN3aXRjaCBpZiB0aGF0IGZyYWdtZW50IHdpbGwgbm90IGxvYWRcbiAgICAgIHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgdW5kZXJidWZmZXJpbmdcbiAgICAqL1xuICBwcml2YXRlIF9hYmFuZG9uUnVsZXNDaGVjayA9ICgpID0+IHtcbiAgICBjb25zdCB7IGZyYWdDdXJyZW50OiBmcmFnLCBwYXJ0Q3VycmVudDogcGFydCwgaGxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYXV0b0xldmVsRW5hYmxlZCwgbWVkaWEgfSA9IGhscztcbiAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RhdHM6IExvYWRlclN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgIGNvbnN0IHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICBjb25zdCBtaW5BdXRvTGV2ZWwgPSBobHMubWluQXV0b0xldmVsO1xuICAgIC8vIElmIGZyYWcgbG9hZGluZyBpcyBhYm9ydGVkLCBjb21wbGV0ZSwgb3IgZnJvbSBsb3dlc3QgbGV2ZWwsIHN0b3AgdGltZXIgYW5kIHJldHVyblxuICAgIGlmIChcbiAgICAgIHN0YXRzLmFib3J0ZWQgfHxcbiAgICAgIChzdGF0cy5sb2FkZWQgJiYgc3RhdHMubG9hZGVkID09PSBzdGF0cy50b3RhbCkgfHxcbiAgICAgIGZyYWcubGV2ZWwgPD0gbWluQXV0b0xldmVsXG4gICAgKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjaGVjayBvbmx5IHJ1bnMgaWYgd2UncmUgaW4gQUJSIG1vZGUgYW5kIGFjdHVhbGx5IHBsYXlpbmdcbiAgICBpZiAoXG4gICAgICAhYXV0b0xldmVsRW5hYmxlZCB8fFxuICAgICAgbWVkaWEucGF1c2VkIHx8XG4gICAgICAhbWVkaWEucGxheWJhY2tSYXRlIHx8XG4gICAgICAhbWVkaWEucmVhZHlTdGF0ZVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBobHMubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdHRmYkVzdGltYXRlID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKTtcbiAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpO1xuICAgIC8vIFRvIG1haW50YWluIHN0YWJsZSBhZGFwdGl2ZSBwbGF5YmFjaywgb25seSBiZWdpbiBtb25pdG9yaW5nIGZyYWcgbG9hZGluZyBhZnRlciBoYWxmIG9yIG1vcmUgb2YgaXRzIHBsYXliYWNrIGR1cmF0aW9uIGhhcyBwYXNzZWRcbiAgICBpZiAoXG4gICAgICB0aW1lTG9hZGluZyA8PVxuICAgICAgTWF0aC5tYXgodHRmYkVzdGltYXRlLCAxMDAwICogKGR1cmF0aW9uIC8gKHBsYXliYWNrUmF0ZSAqIDIpKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBidWZmZXJTdGFydmF0aW9uRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIGFtb3VudCB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gZXhoYXVzdCB0aGUgYnVmZmVyXG4gICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gYnVmZmVySW5mby5sZW4gLyBwbGF5YmFja1JhdGU7XG4gICAgY29uc3QgdHRmYiA9IHN0YXRzLmxvYWRpbmcuZmlyc3RcbiAgICAgID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnRcbiAgICAgIDogLTE7XG4gICAgY29uc3QgbG9hZGVkRmlyc3RCeXRlID0gc3RhdHMubG9hZGVkICYmIHR0ZmIgPiAtMTtcbiAgICBjb25zdCBid0VzdGltYXRlOiBudW1iZXIgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICBjb25zdCBsZXZlbHMgPSBobHMubGV2ZWxzO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIGNvbnN0IGV4cGVjdGVkTGVuID1cbiAgICAgIHN0YXRzLnRvdGFsIHx8XG4gICAgICBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoKGR1cmF0aW9uICogbGV2ZWwuYXZlcmFnZUJpdHJhdGUpIC8gOCkpO1xuICAgIGxldCB0aW1lU3RyZWFtaW5nID0gbG9hZGVkRmlyc3RCeXRlID8gdGltZUxvYWRpbmcgLSB0dGZiIDogdGltZUxvYWRpbmc7XG4gICAgaWYgKHRpbWVTdHJlYW1pbmcgPCAxICYmIGxvYWRlZEZpcnN0Qnl0ZSkge1xuICAgICAgdGltZVN0cmVhbWluZyA9IE1hdGgubWluKHRpbWVMb2FkaW5nLCAoc3RhdHMubG9hZGVkICogOCkgLyBid0VzdGltYXRlKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGVcbiAgICAgID8gKHN0YXRzLmxvYWRlZCAqIDEwMDApIC8gdGltZVN0cmVhbWluZ1xuICAgICAgOiAwO1xuICAgIC8vIGZyYWdMb2FkRGVsYXkgaXMgYW4gZXN0aW1hdGUgb2YgdGhlIHRpbWUgKGluIHNlY29uZHMpIGl0IHdpbGwgdGFrZSB0byBidWZmZXIgdGhlIHJlbWFpbmRlciBvZiB0aGUgZnJhZ21lbnRcbiAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZVxuICAgICAgPyAoZXhwZWN0ZWRMZW4gLSBzdGF0cy5sb2FkZWQpIC8gbG9hZFJhdGVcbiAgICAgIDogKGV4cGVjdGVkTGVuICogOCkgLyBid0VzdGltYXRlICsgdHRmYkVzdGltYXRlIC8gMTAwMDtcbiAgICAvLyBPbmx5IGRvd25zd2l0Y2ggaWYgdGhlIHRpbWUgdG8gZmluaXNoIGxvYWRpbmcgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBhbW91bnQgb2YgYnVmZmVyIGxlZnRcbiAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ3ZSA9IGxvYWRSYXRlID8gbG9hZFJhdGUgKiA4IDogYndFc3RpbWF0ZTtcbiAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG5leHRMb2FkTGV2ZWw6IG51bWJlcjtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBsYXJnZXN0IG9uZSB0aGF0IGF2b2lkcyByZWJ1ZmZlcmluZ1xuICAgIGZvciAoXG4gICAgICBuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7XG4gICAgICBuZXh0TG9hZExldmVsID4gbWluQXV0b0xldmVsO1xuICAgICAgbmV4dExvYWRMZXZlbC0tXG4gICAgKSB7XG4gICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAvLyA4ID0gYml0cyBwZXIgYnl0ZSAoYnBzL0JwcylcbiAgICAgIGNvbnN0IGxldmVsTmV4dEJpdHJhdGUgPSBsZXZlbHNbbmV4dExvYWRMZXZlbF0ubWF4Qml0cmF0ZTtcbiAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcoXG4gICAgICAgIHR0ZmJFc3RpbWF0ZSAvIDEwMDAsXG4gICAgICAgIGJ3ZSxcbiAgICAgICAgZHVyYXRpb24gKiBsZXZlbE5leHRCaXRyYXRlLFxuICAgICAgICAhbGV2ZWxzW25leHRMb2FkTGV2ZWxdLmRldGFpbHMsXG4gICAgICApO1xuICAgICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA8IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWQgb2YgY29udGludWluZ1xuICAgIC8vIHRvIGxvYWQgdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA+PSBmcmFnTG9hZGVkRGVsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBlc3RpbWF0ZWQgbG9hZCB0aW1lIG9mIG5ldyBzZWdtZW50IGlzIGNvbXBsZXRlbHkgdW5yZWFzb25hYmxlLCBpZ25vcmUgYW5kIGRvIG5vdCBlbWVyZ2VuY3kgc3dpdGNoIGRvd25cbiAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID4gZHVyYXRpb24gKiAxMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBobHMubmV4dExvYWRMZXZlbCA9IGhscy5uZXh0QXV0b0xldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBsb2FkaW5nIHByb2dyZXNzLCBzYW1wbGUgYmFuZHdpZHRoIHVzaW5nIGxvYWRpbmcgdGltZSBvZmZzZXQgYnkgbWluaW11bSBUVEZCIHRpbWVcbiAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKFxuICAgICAgICB0aW1lTG9hZGluZyAtIE1hdGgubWluKHR0ZmJFc3RpbWF0ZSwgdHRmYiksXG4gICAgICAgIHN0YXRzLmxvYWRlZCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIodGltZUxvYWRpbmcpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0TG9hZExldmVsQml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgIGlmIChcbiAgICAgIHRoaXMuZ2V0QndFc3RpbWF0ZSgpICogdGhpcy5obHMuY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yID5cbiAgICAgIG5leHRMb2FkTGV2ZWxCaXRyYXRlXG4gICAgKSB7XG4gICAgICB0aGlzLnJlc2V0RXN0aW1hdG9yKG5leHRMb2FkTGV2ZWxCaXRyYXRlKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICBsb2dnZXIud2FybihgW2Ficl0gRnJhZ21lbnQgJHtmcmFnLnNufSR7XG4gICAgICBwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJydcbiAgICB9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgbG9hZGluZyB0b28gc2xvd2x5O1xuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogJHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgY3VycmVudCBmcmFnbWVudDogJHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgZG93biBzd2l0Y2ggZnJhZ21lbnQ6ICR7ZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoXG4gICAgICAgIDMsXG4gICAgICApfSBzXG4gICAgICBUVEZCIGVzdGltYXRlOiAke3R0ZmIgfCAwfSBtc1xuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogJHtcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKGJ3RXN0aW1hdGUpID8gYndFc3RpbWF0ZSB8IDAgOiAnVW5rbm93bidcbiAgICAgIH0gYnBzXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7dGhpcy5nZXRCd0VzdGltYXRlKCkgfCAwfSBicHNcbiAgICAgIFN3aXRjaGluZyB0byBsZXZlbCAke25leHRMb2FkTGV2ZWx9IEAgJHtuZXh0TG9hZExldmVsQml0cmF0ZSB8IDB9IGJwc2ApO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHsgZnJhZywgcGFydCwgc3RhdHMgfSk7XG4gIH07XG5cbiAgcHJvdGVjdGVkIG9uRnJhZ0xvYWRlZChcbiAgICBldmVudDogRXZlbnRzLkZSQUdfTE9BREVELFxuICAgIHsgZnJhZywgcGFydCB9OiBGcmFnTG9hZGVkRGF0YSxcbiAgKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGVUVEZCKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc3RvcCBtb25pdG9yaW5nIGJ3IG9uY2UgZnJhZyBsb2FkZWRcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgIGlmIChmcmFnLmxldmVsID09PSB0aGlzLl9uZXh0QXV0b0xldmVsKSB7XG4gICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMTtcblxuICAgIC8vIGNvbXB1dGUgbGV2ZWwgYXZlcmFnZSBiaXRyYXRlXG4gICAgaWYgKHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGFydCA/IHBhcnQuZHVyYXRpb24gOiBmcmFnLmR1cmF0aW9uO1xuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBjb25zdCBsb2FkZWRCeXRlcyA9XG4gICAgICAgIChsZXZlbC5sb2FkZWQgPyBsZXZlbC5sb2FkZWQuYnl0ZXMgOiAwKSArIHN0YXRzLmxvYWRlZDtcbiAgICAgIGNvbnN0IGxvYWRlZER1cmF0aW9uID1cbiAgICAgICAgKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgZHVyYXRpb247XG4gICAgICBsZXZlbC5sb2FkZWQgPSB7IGJ5dGVzOiBsb2FkZWRCeXRlcywgZHVyYXRpb246IGxvYWRlZER1cmF0aW9uIH07XG4gICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoKDggKiBsb2FkZWRCeXRlcykgLyBsb2FkZWREdXJhdGlvbik7XG4gICAgfVxuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICBjb25zdCBmcmFnQnVmZmVyZWREYXRhOiBGcmFnQnVmZmVyZWREYXRhID0ge1xuICAgICAgICBzdGF0cyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgaWQ6IGZyYWcudHlwZSxcbiAgICAgIH07XG4gICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKEV2ZW50cy5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkIGZvciBwbGF5YmFja1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnQnVmZmVyZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0JVRkZFUkVELFxuICAgIGRhdGE6IEZyYWdCdWZmZXJlZERhdGEsXG4gICkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCB9ID0gZGF0YTtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQ/LnN0YXRzLmxvYWRlZCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuXG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgIGNvbnN0IHByb2Nlc3NpbmdNcyA9XG4gICAgICBzdGF0cy5wYXJzaW5nLmVuZCAtXG4gICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0IC1cbiAgICAgIE1hdGgubWluKFxuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCxcbiAgICAgICAgdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSxcbiAgICAgICk7XG4gICAgdGhpcy5id0VzdGltYXRvci5zYW1wbGUocHJvY2Vzc2luZ01zLCBzdGF0cy5sb2FkZWQpO1xuICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKTtcbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gcHJvY2Vzc2luZ01zIC8gMTAwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlnbm9yZUZyYWdtZW50KGZyYWc6IEZyYWdtZW50KTogYm9vbGVhbiB7XG4gICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgIHJldHVybiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JztcbiAgfVxuXG4gIHB1YmxpYyBjbGVhclRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyID4gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZpcnN0QXV0b0xldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBtYXhBdXRvTGV2ZWwsIG1pbkF1dG9MZXZlbCB9ID0gdGhpcy5obHM7XG4gICAgY29uc3QgYndFc3RpbWF0ZSA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIGNvbnN0IG1heFN0YXJ0RGVsYXkgPSB0aGlzLmhscy5jb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGNvbnN0IGFickF1dG9MZXZlbCA9IHRoaXMuZmluZEJlc3RMZXZlbChcbiAgICAgIGJ3RXN0aW1hdGUsXG4gICAgICBtaW5BdXRvTGV2ZWwsXG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICAwLFxuICAgICAgbWF4U3RhcnREZWxheSxcbiAgICAgIDEsXG4gICAgICAxLFxuICAgICk7XG4gICAgaWYgKGFickF1dG9MZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gYWJyQXV0b0xldmVsO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdExldmVsID0gdGhpcy5obHMuZmlyc3RMZXZlbDtcbiAgICBjb25zdCBjbGFtcGVkID0gTWF0aC5taW4oTWF0aC5tYXgoZmlyc3RMZXZlbCwgbWluQXV0b0xldmVsKSwgbWF4QXV0b0xldmVsKTtcbiAgICBsb2dnZXIud2FybihcbiAgICAgIGBbYWJyXSBDb3VsZCBub3QgZmluZCBiZXN0IHN0YXJ0aW5nIGF1dG8gbGV2ZWwuIERlZmF1bHRpbmcgdG8gZmlyc3QgaW4gcGxheWxpc3QgJHtmaXJzdExldmVsfSBjbGFtcGVkIHRvICR7Y2xhbXBlZH1gLFxuICAgICk7XG4gICAgcmV0dXJuIGNsYW1wZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZvcmNlZEF1dG9MZXZlbCgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLm5leHRBdXRvTGV2ZWxLZXkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gIH1cblxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIHB1YmxpYyBnZXQgbmV4dEF1dG9MZXZlbCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICBjb25zdCB1c2VFc3RpbWF0ZSA9IGJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCk7XG4gICAgY29uc3QgbG9hZGVkRmlyc3RGcmFnID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID4gLTE7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICBpZiAoXG4gICAgICBmb3JjZWRBdXRvTGV2ZWwgIT09IC0xICYmXG4gICAgICAoIXVzZUVzdGltYXRlIHx8XG4gICAgICAgICFsb2FkZWRGaXJzdEZyYWcgfHxcbiAgICAgICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID09PSB0aGlzLmdldEF1dG9MZXZlbEtleSgpKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgY29uc3QgbmV4dEFCUkF1dG9MZXZlbCA9XG4gICAgICB1c2VFc3RpbWF0ZSAmJiBsb2FkZWRGaXJzdEZyYWdcbiAgICAgICAgPyB0aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKVxuICAgICAgICA6IHRoaXMuZmlyc3RBdXRvTGV2ZWw7XG5cbiAgICAvLyB1c2UgZm9yY2VkIGF1dG8gbGV2ZWwgd2hpbGUgaXQgaGFzbid0IGVycm9yZWQgbW9yZSB0aGFuIEFCUiBzZWxlY3Rpb25cbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSkge1xuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKFxuICAgICAgICBsZXZlbHMubGVuZ3RoID4gTWF0aC5tYXgoZm9yY2VkQXV0b0xldmVsLCBuZXh0QUJSQXV0b0xldmVsKSAmJlxuICAgICAgICBsZXZlbHNbZm9yY2VkQXV0b0xldmVsXS5sb2FkRXJyb3IgPD0gbGV2ZWxzW25leHRBQlJBdXRvTGV2ZWxdLmxvYWRFcnJvclxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmb3JjZWRBdXRvTGV2ZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2F2ZSByZXN1bHQgdW50aWwgc3RhdGUgaGFzIGNoYW5nZWRcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gbmV4dEFCUkF1dG9MZXZlbDtcbiAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSB0aGlzLmdldEF1dG9MZXZlbEtleSgpO1xuXG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGdldEF1dG9MZXZlbEtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmdldEJ3RXN0aW1hdGUoKX1fJHt0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm8/Lmxlbn1gO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXROZXh0QUJSQXV0b0xldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCwgcGFydEN1cnJlbnQsIGhscyB9ID0gdGhpcztcbiAgICBjb25zdCB7IG1heEF1dG9MZXZlbCwgY29uZmlnLCBtaW5BdXRvTGV2ZWwsIG1lZGlhIH0gPSBobHM7XG4gICAgY29uc3QgY3VycmVudEZyYWdEdXJhdGlvbiA9IHBhcnRDdXJyZW50XG4gICAgICA/IHBhcnRDdXJyZW50LmR1cmF0aW9uXG4gICAgICA6IGZyYWdDdXJyZW50XG4gICAgICAgID8gZnJhZ0N1cnJlbnQuZHVyYXRpb25cbiAgICAgICAgOiAwO1xuXG4gICAgLy8gcGxheWJhY2tSYXRlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgcGxheWJhY2sgcmF0ZTsgaWYgbWVkaWEucGxheWJhY2tSYXRlIGlzIDAsIHdlIHVzZSAxIHRvIGxvYWQgYXNcbiAgICAvLyBpZiB3ZSdyZSBwbGF5aW5nIGJhY2sgYXQgdGhlIG5vcm1hbCByYXRlLlxuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9XG4gICAgICBtZWRpYSAmJiBtZWRpYS5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpIDogMS4wO1xuICAgIGNvbnN0IGF2Z2J3ID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIHRoZSB3YWxsLWNsb2NrIHRpbWUgbGVmdCB1bnRpbCB0aGUgcGxheWJhY2sgYnVmZmVyIGlzIGV4aGF1c3RlZC5cbiAgICBjb25zdCBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICBjb25zdCBidWZmZXJTdGFydmF0aW9uRGVsYXkgPVxuICAgICAgKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6IDApIC8gcGxheWJhY2tSYXRlO1xuXG4gICAgbGV0IGJ3RmFjdG9yID0gY29uZmlnLmFickJhbmRXaWR0aEZhY3RvcjtcbiAgICBsZXQgYndVcEZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhVcEZhY3RvcjtcblxuICAgIC8vIEZpcnN0LCBsb29rIHRvIHNlZSBpZiB3ZSBjYW4gZmluZCBhIGxldmVsIG1hdGNoaW5nIHdpdGggb3VyIGF2ZyBiYW5kd2lkdGggQU5EIHRoYXQgY291bGQgYWxzbyBndWFyYW50ZWUgbm8gcmVidWZmZXJpbmcgYXQgYWxsXG4gICAgaWYgKGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgY29uc3QgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKFxuICAgICAgICBhdmdidyxcbiAgICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICAgIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSxcbiAgICAgICAgMCxcbiAgICAgICAgYndGYWN0b3IsXG4gICAgICAgIGJ3VXBGYWN0b3IsXG4gICAgICApO1xuICAgICAgaWYgKGJlc3RMZXZlbCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nLi4uIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uXG4gICAgICA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXkpXG4gICAgICA6IGNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG5cbiAgICBpZiAoIWJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgLy8gaW4gY2FzZSBidWZmZXIgaXMgZW1wdHksIGxldCdzIGNoZWNrIGlmIHByZXZpb3VzIGZyYWdtZW50IHdhcyBsb2FkZWQgdG8gcGVyZm9ybSBhIGJpdHJhdGUgdGVzdFxuICAgICAgY29uc3QgYml0cmF0ZVRlc3REZWxheSA9IHRoaXMuYml0cmF0ZVRlc3REZWxheTtcbiAgICAgIGlmIChiaXRyYXRlVGVzdERlbGF5KSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLCB0aGVuIHdlIG5lZWQgdG8gYWRqdXN0IG91ciBtYXggc3RhcnZhdGlvbiBkZWxheSB1c2luZyBtYXhMb2FkaW5nRGVsYXkgY29uZmlnIHZhbHVlXG4gICAgICAgIC8vIG1heCB2aWRlbyBsb2FkaW5nIGRlbGF5IHVzZWQgaW4gIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24gOlxuICAgICAgICAvLyBpbiB0aGF0IG1vZGUgQUJSIGNvbnRyb2xsZXIgd2lsbCBlbnN1cmUgdGhhdCB2aWRlbyBsb2FkaW5nIHRpbWUgKGllIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmaXJzdCBmcmFnbWVudCBhdCBsb3dlc3QgcXVhbGl0eSBsZXZlbCArXG4gICAgICAgIC8vIHRoZSB0aW1lIHRvIGZldGNoIHRoZSBmcmFnbWVudCBhdCB0aGUgYXBwcm9wcmlhdGUgcXVhbGl0eSBsZXZlbCBpcyBsZXNzIHRoYW4gYGBgbWF4TG9hZGluZ0RlbGF5YGBgIClcbiAgICAgICAgLy8gY2FwIG1heExvYWRpbmdEZWxheSBhbmQgZW5zdXJlIGl0IGlzIG5vdCBiaWdnZXIgJ3RoYW4gYml0cmF0ZSB0ZXN0JyBmcmFnIGR1cmF0aW9uXG4gICAgICAgIGNvbnN0IG1heExvYWRpbmdEZWxheSA9IGN1cnJlbnRGcmFnRHVyYXRpb25cbiAgICAgICAgICA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpXG4gICAgICAgICAgOiBjb25maWcubWF4TG9hZGluZ0RlbGF5O1xuICAgICAgICBtYXhTdGFydmF0aW9uRGVsYXkgPSBtYXhMb2FkaW5nRGVsYXkgLSBiaXRyYXRlVGVzdERlbGF5O1xuICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICBgW2Ficl0gYml0cmF0ZSB0ZXN0IHRvb2sgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgMTAwMCAqIGJpdHJhdGVUZXN0RGVsYXksXG4gICAgICAgICAgKX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgIDEwMDAgKiBtYXhTdGFydmF0aW9uRGVsYXksXG4gICAgICAgICAgKX0gbXNgLFxuICAgICAgICApO1xuICAgICAgICAvLyBkb24ndCB1c2UgY29uc2VydmF0aXZlIGZhY3RvciBvbiBiaXRyYXRlIHRlc3RcbiAgICAgICAgYndGYWN0b3IgPSBid1VwRmFjdG9yID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmVzdExldmVsID0gdGhpcy5maW5kQmVzdExldmVsKFxuICAgICAgYXZnYncsXG4gICAgICBtaW5BdXRvTGV2ZWwsXG4gICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXksXG4gICAgICBtYXhTdGFydmF0aW9uRGVsYXksXG4gICAgICBid0ZhY3RvcixcbiAgICAgIGJ3VXBGYWN0b3IsXG4gICAgKTtcbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIGBbYWJyXSAke1xuICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPyAncmVidWZmZXJpbmcgZXhwZWN0ZWQnIDogJ2J1ZmZlciBpcyBlbXB0eSdcbiAgICAgIH0sIG9wdGltYWwgcXVhbGl0eSBsZXZlbCAke2Jlc3RMZXZlbH1gLFxuICAgICk7XG4gICAgaWYgKGJlc3RMZXZlbCA+IC0xKSB7XG4gICAgICByZXR1cm4gYmVzdExldmVsO1xuICAgIH1cbiAgICAvLyBJZiBubyBtYXRjaGluZyBsZXZlbCBmb3VuZCwgc2VlIGlmIG1pbiBhdXRvIGxldmVsIHdvdWxkIGJlIGEgYmV0dGVyIG9wdGlvblxuICAgIGNvbnN0IG1pbkxldmVsID0gaGxzLmxldmVsc1ttaW5BdXRvTGV2ZWxdO1xuICAgIGNvbnN0IGF1dG9MZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgaWYgKG1pbkxldmVsPy5iaXRyYXRlIDwgYXV0b0xldmVsPy5iaXRyYXRlKSB7XG4gICAgICByZXR1cm4gbWluQXV0b0xldmVsO1xuICAgIH1cbiAgICAvLyBvciBpZiBiaXRyYXRlIGlzIG5vdCBsb3dlciwgY29udGludWUgdG8gdXNlIGxvYWRMZXZlbFxuICAgIHJldHVybiBobHMubG9hZExldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCd0VzdGltYXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYndFc3RpbWF0b3IuY2FuRXN0aW1hdGUoKVxuICAgICAgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKClcbiAgICAgIDogdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gIH1cblxuICBwcml2YXRlIGZpbmRCZXN0TGV2ZWwoXG4gICAgY3VycmVudEJ3OiBudW1iZXIsXG4gICAgbWluQXV0b0xldmVsOiBudW1iZXIsXG4gICAgbWF4QXV0b0xldmVsOiBudW1iZXIsXG4gICAgYnVmZmVyU3RhcnZhdGlvbkRlbGF5OiBudW1iZXIsXG4gICAgbWF4U3RhcnZhdGlvbkRlbGF5OiBudW1iZXIsXG4gICAgYndGYWN0b3I6IG51bWJlcixcbiAgICBid1VwRmFjdG9yOiBudW1iZXIsXG4gICk6IG51bWJlciB7XG4gICAgY29uc3QgbWF4RmV0Y2hEdXJhdGlvbjogbnVtYmVyID0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGNvbnN0IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgY29uc3Qgc2VsZWN0aW9uQmFzZUxldmVsID1cbiAgICAgIGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xID8gdGhpcy5obHMuZmlyc3RMZXZlbCA6IGxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCwgcGFydEN1cnJlbnQgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsZXZlbHMsIGFsbEF1ZGlvVHJhY2tzLCBsb2FkTGV2ZWwsIGNvbmZpZyB9ID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbDogTGV2ZWwgfCB1bmRlZmluZWQgPSBsZXZlbHNbc2VsZWN0aW9uQmFzZUxldmVsXTtcbiAgICBjb25zdCBsaXZlID0gISFsZXZlbD8uZGV0YWlscz8ubGl2ZTtcbiAgICBjb25zdCBmaXJzdFNlbGVjdGlvbiA9IGxvYWRMZXZlbCA9PT0gLTEgfHwgbGFzdExvYWRlZEZyYWdMZXZlbCA9PT0gLTE7XG4gICAgbGV0IGN1cnJlbnRDb2RlY1NldDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGxldCBjdXJyZW50VmlkZW9SYW5nZTogVmlkZW9SYW5nZSB8IHVuZGVmaW5lZCA9ICdTRFInO1xuICAgIGxldCBjdXJyZW50RnJhbWVSYXRlID0gbGV2ZWw/LmZyYW1lUmF0ZSB8fCAwO1xuXG4gICAgY29uc3QgeyBhdWRpb1ByZWZlcmVuY2UsIHZpZGVvUHJlZmVyZW5jZSB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzQnlHcm91cCA9XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCB8fFxuICAgICAgKHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gZ2V0QXVkaW9UcmFja3NCeUdyb3VwKGFsbEF1ZGlvVHJhY2tzKSk7XG4gICAgaWYgKGZpcnN0U2VsZWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5maXJzdFNlbGVjdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBjb25zdCBjb2RlY1RpZXJzID1cbiAgICAgICAgdGhpcy5jb2RlY1RpZXJzIHx8XG4gICAgICAgICh0aGlzLmNvZGVjVGllcnMgPSBnZXRDb2RlY1RpZXJzKFxuICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICBhdWRpb1RyYWNrc0J5R3JvdXAsXG4gICAgICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgICAgKSk7XG4gICAgICBjb25zdCBzdGFydFRpZXIgPSBnZXRTdGFydENvZGVjVGllcihcbiAgICAgICAgY29kZWNUaWVycyxcbiAgICAgICAgY3VycmVudFZpZGVvUmFuZ2UsXG4gICAgICAgIGN1cnJlbnRCdyxcbiAgICAgICAgYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgICB2aWRlb1ByZWZlcmVuY2UsXG4gICAgICApO1xuICAgICAgY29uc3QgeyBjb2RlY1NldCwgdmlkZW9SYW5nZXMsIG1pbkZyYW1lcmF0ZSwgbWluQml0cmF0ZSwgcHJlZmVySERSIH0gPVxuICAgICAgICBzdGFydFRpZXI7XG4gICAgICBjdXJyZW50Q29kZWNTZXQgPSBjb2RlY1NldDtcbiAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gcHJlZmVySERSXG4gICAgICAgID8gdmlkZW9SYW5nZXNbdmlkZW9SYW5nZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgOiB2aWRlb1Jhbmdlc1swXTtcbiAgICAgIGN1cnJlbnRGcmFtZVJhdGUgPSBtaW5GcmFtZXJhdGU7XG4gICAgICBjdXJyZW50QncgPSBNYXRoLm1heChjdXJyZW50QncsIG1pbkJpdHJhdGUpO1xuICAgICAgbG9nZ2VyLmxvZyhgW2Ficl0gcGlja2VkIHN0YXJ0IHRpZXIgJHtKU09OLnN0cmluZ2lmeShzdGFydFRpZXIpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q29kZWNTZXQgPSBsZXZlbD8uY29kZWNTZXQ7XG4gICAgICBjdXJyZW50VmlkZW9SYW5nZSA9IGxldmVsPy52aWRlb1JhbmdlO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudFxuICAgICAgPyBwYXJ0Q3VycmVudC5kdXJhdGlvblxuICAgICAgOiBmcmFnQ3VycmVudFxuICAgICAgICA/IGZyYWdDdXJyZW50LmR1cmF0aW9uXG4gICAgICAgIDogMDtcblxuICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZVNlYyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxMDAwO1xuICAgIGNvbnN0IGxldmVsc1NraXBwZWQ6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaSA+PSBtaW5BdXRvTGV2ZWw7IGktLSkge1xuICAgICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW2ldO1xuICAgICAgY29uc3QgdXBTd2l0Y2ggPSBpID4gc2VsZWN0aW9uQmFzZUxldmVsO1xuICAgICAgaWYgKCFsZXZlbEluZm8pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIF9fVVNFX01FRElBX0NBUEFCSUxJVElFU19fICYmXG4gICAgICAgIGNvbmZpZy51c2VNZWRpYUNhcGFiaWxpdGllcyAmJlxuICAgICAgICAhbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCAmJlxuICAgICAgICAhbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2VcbiAgICAgICkge1xuICAgICAgICBjb25zdCBtZWRpYUNhcGFiaWxpdGllcyA9IG5hdmlnYXRvci5tZWRpYUNhcGFiaWxpdGllcyBhc1xuICAgICAgICAgIHwgTWVkaWFDYXBhYmlsaXRpZXNcbiAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBtZWRpYUNhcGFiaWxpdGllcz8uZGVjb2RpbmdJbmZvID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgcmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyhcbiAgICAgICAgICAgIGxldmVsSW5mbyxcbiAgICAgICAgICAgIGF1ZGlvVHJhY2tzQnlHcm91cCxcbiAgICAgICAgICAgIGN1cnJlbnRWaWRlb1JhbmdlLFxuICAgICAgICAgICAgY3VycmVudEZyYW1lUmF0ZSxcbiAgICAgICAgICAgIGN1cnJlbnRCdyxcbiAgICAgICAgICAgIGF1ZGlvUHJlZmVyZW5jZSxcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRQcm9taXNlID0gZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlKFxuICAgICAgICAgICAgbGV2ZWxJbmZvLFxuICAgICAgICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLFxuICAgICAgICAgICAgbWVkaWFDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKChkZWNvZGluZ0luZm8pID0+IHtcbiAgICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBkZWNvZGluZ0luZm87XG4gICAgICAgICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxldmVscy5pbmRleE9mKGxldmVsSW5mbyk7XG4gICAgICAgICAgICBpZiAoZGVjb2RpbmdJbmZvLmVycm9yKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIGBbYWJyXSBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gZXJyb3I6IFwiJHtcbiAgICAgICAgICAgICAgICAgIGRlY29kaW5nSW5mby5lcnJvclxuICAgICAgICAgICAgICAgIH1cIiBmb3IgbGV2ZWwgJHtpbmRleH0gJHtKU09OLnN0cmluZ2lmeShkZWNvZGluZ0luZm8pfWAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWNvZGluZ0luZm8uc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICAgIGBbYWJyXSBVbnN1cHBvcnRlZCBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gcmVzdWx0IGZvciBsZXZlbCAke2luZGV4fSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgZGVjb2RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgbGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBbYWJyXSBSZW1vdmluZyB1bnN1cHBvcnRlZCBsZXZlbCAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgIHRoaXMuaGxzLnJlbW92ZUxldmVsKGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgPSBTVVBQT1JURURfSU5GT19ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgY2FuZGlkYXRlcyB3aGljaCBjaGFuZ2UgY29kZWMtZmFtaWx5IG9yIHZpZGVvLXJhbmdlLFxuICAgICAgLy8gYW5kIHdoaWNoIGRlY3JlYXNlIG9yIGluY3JlYXNlIGZyYW1lLXJhdGUgZm9yIHVwIGFuZCBkb3duLXN3aXRjaCByZXNwZWN0ZnVsbHlcbiAgICAgIGlmIChcbiAgICAgICAgKGN1cnJlbnRDb2RlY1NldCAmJiBsZXZlbEluZm8uY29kZWNTZXQgIT09IGN1cnJlbnRDb2RlY1NldCkgfHxcbiAgICAgICAgKGN1cnJlbnRWaWRlb1JhbmdlICYmIGxldmVsSW5mby52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSkgfHxcbiAgICAgICAgKHVwU3dpdGNoICYmIGN1cnJlbnRGcmFtZVJhdGUgPiBsZXZlbEluZm8uZnJhbWVSYXRlKSB8fFxuICAgICAgICAoIXVwU3dpdGNoICYmXG4gICAgICAgICAgY3VycmVudEZyYW1lUmF0ZSA+IDAgJiZcbiAgICAgICAgICBjdXJyZW50RnJhbWVSYXRlIDwgbGV2ZWxJbmZvLmZyYW1lUmF0ZSkgfHxcbiAgICAgICAgKGxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgJiZcbiAgICAgICAgICAhbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdC5kZWNvZGluZ0luZm9SZXN1bHRzPy5bMF0uc21vb3RoKVxuICAgICAgKSB7XG4gICAgICAgIGxldmVsc1NraXBwZWQucHVzaChpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsSW5mby5kZXRhaWxzO1xuICAgICAgY29uc3QgYXZnRHVyYXRpb24gPVxuICAgICAgICAocGFydEN1cnJlbnRcbiAgICAgICAgICA/IGxldmVsRGV0YWlscz8ucGFydFRhcmdldFxuICAgICAgICAgIDogbGV2ZWxEZXRhaWxzPy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG5cbiAgICAgIGxldCBhZGp1c3RlZGJ3OiBudW1iZXI7XG4gICAgICAvLyBmb2xsb3cgYWxnb3JpdGhtIGNhcHR1cmVkIGZyb20gc3RhZ2VmcmlnaHQgOlxuICAgICAgLy8gaHR0cHM6Ly9hbmRyb2lkLmdvb2dsZXNvdXJjZS5jb20vcGxhdGZvcm0vZnJhbWV3b3Jrcy9hdi8rL21hc3Rlci9tZWRpYS9saWJzdGFnZWZyaWdodC9odHRwbGl2ZS9MaXZlU2Vzc2lvbi5jcHBcbiAgICAgIC8vIFBpY2sgdGhlIGhpZ2hlc3QgYmFuZHdpZHRoIHN0cmVhbSBiZWxvdyBvciBlcXVhbCB0byBlc3RpbWF0ZWQgYmFuZHdpZHRoLlxuICAgICAgLy8gY29uc2lkZXIgb25seSA4MCUgb2YgdGhlIGF2YWlsYWJsZSBiYW5kd2lkdGgsIGJ1dCBpZiB3ZSBhcmUgc3dpdGNoaW5nIHVwLFxuICAgICAgLy8gYmUgZXZlbiBtb3JlIGNvbnNlcnZhdGl2ZSAoNzAlKSB0byBhdm9pZCBvdmVyZXN0aW1hdGluZyBhbmQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIHN3aXRjaGluZyBiYWNrLlxuICAgICAgaWYgKCF1cFN3aXRjaCkge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndGYWN0b3IgKiBjdXJyZW50Qnc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGp1c3RlZGJ3ID0gYndVcEZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH1cblxuICAgICAgLy8gVXNlIGF2ZXJhZ2UgYml0cmF0ZSB3aGVuIHN0YXJ2YXRpb24gZGVsYXkgKGJ1ZmZlciBsZW5ndGgpIGlzIGd0IG9yIGVxIHR3byBzZWdtZW50IGR1cmF0aW9ucyBhbmQgcmVidWZmZXJpbmcgaXMgbm90IGV4cGVjdGVkIChtYXhTdGFydmF0aW9uRGVsYXkgPiAwKVxuICAgICAgY29uc3QgYml0cmF0ZTogbnVtYmVyID1cbiAgICAgICAgY3VycmVudEZyYWdEdXJhdGlvbiAmJlxuICAgICAgICBidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gY3VycmVudEZyYWdEdXJhdGlvbiAqIDIgJiZcbiAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID09PSAwXG4gICAgICAgICAgPyBsZXZlbHNbaV0uYXZlcmFnZUJpdHJhdGVcbiAgICAgICAgICA6IGxldmVsc1tpXS5tYXhCaXRyYXRlO1xuICAgICAgY29uc3QgZmV0Y2hEdXJhdGlvbjogbnVtYmVyID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyhcbiAgICAgICAgdHRmYkVzdGltYXRlU2VjLFxuICAgICAgICBhZGp1c3RlZGJ3LFxuICAgICAgICBiaXRyYXRlICogYXZnRHVyYXRpb24sXG4gICAgICAgIGxldmVsRGV0YWlscyA9PT0gdW5kZWZpbmVkLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlID1cbiAgICAgICAgLy8gaWYgYWRqdXN0ZWQgYncgaXMgZ3JlYXRlciB0aGFuIGxldmVsIGJpdHJhdGUgQU5EXG4gICAgICAgIGFkanVzdGVkYncgPj0gYml0cmF0ZSAmJlxuICAgICAgICAvLyBubyBsZXZlbCBjaGFuZ2UsIG9yIG5ldyBsZXZlbCBoYXMgbm8gZXJyb3IgaGlzdG9yeVxuICAgICAgICAoaSA9PT0gbGFzdExvYWRlZEZyYWdMZXZlbCB8fFxuICAgICAgICAgIChsZXZlbEluZm8ubG9hZEVycm9yID09PSAwICYmIGxldmVsSW5mby5mcmFnbWVudEVycm9yID09PSAwKSkgJiZcbiAgICAgICAgLy8gZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiB1bmtub3duIE9SIGxpdmUgc3RyZWFtIE9SIGZyYWdtZW50IGZldGNoRHVyYXRpb24gbGVzcyB0aGFuIG1heCBhbGxvd2VkIGZldGNoIGR1cmF0aW9uLCB0aGVuIHRoaXMgbGV2ZWwgbWF0Y2hlc1xuICAgICAgICAvLyB3ZSBkb24ndCBhY2NvdW50IGZvciBtYXggRmV0Y2ggRHVyYXRpb24gZm9yIGxpdmUgc3RyZWFtcywgdGhpcyBpcyB0byBhdm9pZCBzd2l0Y2hpbmcgZG93biB3aGVuIG5lYXIgdGhlIGVkZ2Ugb2YgbGl2ZSBzbGlkaW5nIHdpbmRvdyAuLi5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgICAoZmV0Y2hEdXJhdGlvbiA8PSB0dGZiRXN0aW1hdGVTZWMgfHxcbiAgICAgICAgICAhTnVtYmVyLmlzRmluaXRlKGZldGNoRHVyYXRpb24pIHx8XG4gICAgICAgICAgKGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSkgfHxcbiAgICAgICAgICBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbik7XG4gICAgICBpZiAoY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaSAhPT0gbG9hZExldmVsICYmXG4gICAgICAgICAgKGZvcmNlZEF1dG9MZXZlbCA9PT0gLTEgfHwgZm9yY2VkQXV0b0xldmVsICE9PSBsb2FkTGV2ZWwpXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChsZXZlbHNTa2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKFxuICAgICAgICAgICAgICBgW2Ficl0gU2tpcHBlZCBsZXZlbChzKSAke2xldmVsc1NraXBwZWQuam9pbihcbiAgICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAgICl9IG9mICR7bWF4QXV0b0xldmVsfSBtYXggd2l0aCBDT0RFQ1MgYW5kIFZJREVPLVJBTkdFOlwiJHtcbiAgICAgICAgICAgICAgICBsZXZlbHNbbGV2ZWxzU2tpcHBlZFswXV0uY29kZWNzXG4gICAgICAgICAgICAgIH1cIiAke2xldmVsc1tsZXZlbHNTa2lwcGVkWzBdXS52aWRlb1JhbmdlfTsgbm90IGNvbXBhdGlibGUgd2l0aCBcIiR7XG4gICAgICAgICAgICAgICAgbGV2ZWwuY29kZWNzXG4gICAgICAgICAgICAgIH1cIiAke2N1cnJlbnRWaWRlb1JhbmdlfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIGBbYWJyXSBzd2l0Y2ggY2FuZGlkYXRlOiR7c2VsZWN0aW9uQmFzZUxldmVsfS0+JHtpfSBhZGp1c3RlZGJ3KCR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgYWRqdXN0ZWRidyxcbiAgICAgICAgICAgICl9KS1iaXRyYXRlPSR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgYWRqdXN0ZWRidyAtIGJpdHJhdGUsXG4gICAgICAgICAgICApfSB0dGZiOiR7dHRmYkVzdGltYXRlU2VjLnRvRml4ZWQoXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICApfSBhdmdEdXJhdGlvbjoke2F2Z0R1cmF0aW9uLnRvRml4ZWQoXG4gICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICApfSBtYXhGZXRjaER1cmF0aW9uOiR7bWF4RmV0Y2hEdXJhdGlvbi50b0ZpeGVkKFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgKX0gZmV0Y2hEdXJhdGlvbjoke2ZldGNoRHVyYXRpb24udG9GaXhlZChcbiAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICl9IGZpcnN0U2VsZWN0aW9uOiR7Zmlyc3RTZWxlY3Rpb259IGNvZGVjU2V0OiR7Y3VycmVudENvZGVjU2V0fSB2aWRlb1JhbmdlOiR7Y3VycmVudFZpZGVvUmFuZ2V9IGhscy5sb2FkTGV2ZWw6JHtsb2FkTGV2ZWx9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSBpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzIHdlIGFyZSBsb29waW5nIGZyb20gaGlnaGVzdCB0byBsb3dlc3QsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGJlc3QgYWNoaWV2YWJsZSBxdWFsaXR5IGxldmVsXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBub3QgZW5vdWdoIHRpbWUgYnVkZ2V0IGV2ZW4gd2l0aCBxdWFsaXR5IGxldmVsIDAgLi4uIHJlYnVmZmVyaW5nIG1pZ2h0IGhhcHBlblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IHZhbHVlID0gTWF0aC5tYXgodGhpcy5obHMubWluQXV0b0xldmVsLCBuZXh0TGV2ZWwpO1xuICAgIGlmICh0aGlzLl9uZXh0QXV0b0xldmVsICE9IHZhbHVlKSB7XG4gICAgICB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSAnJztcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWJyQ29udHJvbGxlcjtcbiIsIi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbnR5cGUgQnVmZmVyVGltZVJhbmdlID0ge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIEJ1ZmZlcmFibGUgPSB7XG4gIGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzO1xufTtcblxuZXhwb3J0IHR5cGUgQnVmZmVySW5mbyA9IHtcbiAgbGVuOiBudW1iZXI7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBuZXh0U3RhcnQ/OiBudW1iZXI7XG59O1xuXG5jb25zdCBub29wQnVmZmVyZWQ6IFRpbWVSYW5nZXMgPSB7XG4gIGxlbmd0aDogMCxcbiAgc3RhcnQ6ICgpID0+IDAsXG4gIGVuZDogKCkgPT4gMCxcbn07XG5cbmV4cG9ydCBjbGFzcyBCdWZmZXJIZWxwZXIge1xuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgYG1lZGlhYCdzIGJ1ZmZlcmVkIGluY2x1ZGUgYHBvc2l0aW9uYFxuICAgKi9cbiAgc3RhdGljIGlzQnVmZmVyZWQobWVkaWE6IEJ1ZmZlcmFibGUsIHBvc2l0aW9uOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgYnVmZmVySW5mbyhcbiAgICBtZWRpYTogQnVmZmVyYWJsZSB8IG51bGwsXG4gICAgcG9zOiBudW1iZXIsXG4gICAgbWF4SG9sZUR1cmF0aW9uOiBudW1iZXIsXG4gICk6IEJ1ZmZlckluZm8ge1xuICAgIHRyeSB7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgY29uc3QgdmJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQ6IEJ1ZmZlclRpbWVSYW5nZVtdID0gW107XG4gICAgICAgIGxldCBpOiBudW1iZXI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJlZC5wdXNoKHsgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSwgZW5kOiB2YnVmZmVyZWQuZW5kKGkpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyZWRJbmZvKGJ1ZmZlcmVkLCBwb3MsIG1heEhvbGVEdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIHRoaXMgaXMgdG8gY2F0Y2hcbiAgICAgIC8vIEludmFsaWRTdGF0ZUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2J1ZmZlcmVkJyBwcm9wZXJ0eSBmcm9tICdTb3VyY2VCdWZmZXInOlxuICAgICAgLy8gVGhpcyBTb3VyY2VCdWZmZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgbWVkaWEgc291cmNlXG4gICAgfVxuICAgIHJldHVybiB7IGxlbjogMCwgc3RhcnQ6IHBvcywgZW5kOiBwb3MsIG5leHRTdGFydDogdW5kZWZpbmVkIH07XG4gIH1cblxuICBzdGF0aWMgYnVmZmVyZWRJbmZvKFxuICAgIGJ1ZmZlcmVkOiBCdWZmZXJUaW1lUmFuZ2VbXSxcbiAgICBwb3M6IG51bWJlcixcbiAgICBtYXhIb2xlRHVyYXRpb246IG51bWJlcixcbiAgKToge1xuICAgIGxlbjogbnVtYmVyO1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG4gICAgbmV4dFN0YXJ0PzogbnVtYmVyO1xuICB9IHtcbiAgICBwb3MgPSBNYXRoLm1heCgwLCBwb3MpO1xuICAgIC8vIHNvcnQgb24gYnVmZmVyLnN0YXJ0L3NtYWxsZXIgZW5kIChJRSBkb2VzIG5vdCBhbHdheXMgcmV0dXJuIHNvcnRlZCBidWZmZXJlZCByYW5nZSlcbiAgICBidWZmZXJlZC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBjb25zdCBkaWZmID0gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLmVuZCAtIGEuZW5kO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IGJ1ZmZlcmVkMjogQnVmZmVyVGltZVJhbmdlW10gPSBbXTtcbiAgICBpZiAobWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgICAvLyB0aGVyZSBtaWdodCBiZSBzb21lIHNtYWxsIGhvbGVzIGJldHdlZW4gYnVmZmVyIHRpbWUgcmFuZ2VcbiAgICAgIC8vIGNvbnNpZGVyIHRoYXQgaG9sZXMgc21hbGxlciB0aGFuIG1heEhvbGVEdXJhdGlvbiBhcmUgaXJyZWxldmFudCBhbmQgYnVpbGQgYW5vdGhlclxuICAgICAgLy8gYnVmZmVyIHRpbWUgcmFuZ2UgcmVwcmVzZW50YXRpb25zIHRoYXQgZGlzY2FyZHMgdGhvc2UgaG9sZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmMmxlbiA9IGJ1ZmZlcmVkMi5sZW5ndGg7XG4gICAgICAgIGlmIChidWYybGVuKSB7XG4gICAgICAgICAgY29uc3QgYnVmMmVuZCA9IGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kO1xuICAgICAgICAgIC8vIGlmIHNtYWxsIGhvbGUgKHZhbHVlIGJldHdlZW4gMCBvciBtYXhIb2xlRHVyYXRpb24gKSBvciBvdmVybGFwcGluZyAobmVnYXRpdmUpXG4gICAgICAgICAgaWYgKGJ1ZmZlcmVkW2ldLnN0YXJ0IC0gYnVmMmVuZCA8IG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gbWVyZ2Ugb3ZlcmxhcHBpbmcgdGltZSByYW5nZXNcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsYXN0UmFuZ2UuZW5kIG9ubHkgaWYgc21hbGxlciB0aGFuIGl0ZW0uZW5kXG4gICAgICAgICAgICAvLyBlLmcuICBbIDEsIDE1XSB3aXRoICBbIDIsOF0gPT4gWyAxLDE1XSAobm8gbmVlZCB0byBtb2RpZnkgbGFzdFJhbmdlLmVuZClcbiAgICAgICAgICAgIC8vIHdoZXJlYXMgWyAxLCA4XSB3aXRoICBbIDIsMTVdID0+IFsgMSwxNV0gKCBsYXN0UmFuZ2Ugc2hvdWxkIHN3aXRjaCBmcm9tIFsxLDhdIHRvIFsxLDE1XSlcbiAgICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5lbmQgPiBidWYyZW5kKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcmVkMltidWYybGVuIC0gMV0uZW5kID0gYnVmZmVyZWRbaV0uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBiaWcgaG9sZVxuICAgICAgICAgICAgYnVmZmVyZWQyLnB1c2goYnVmZmVyZWRbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaXJzdCB2YWx1ZVxuICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJlZDIgPSBidWZmZXJlZDtcbiAgICB9XG5cbiAgICBsZXQgYnVmZmVyTGVuID0gMDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0TmV4dCBjYW4gcG9zc2libHkgYmUgdW5kZWZpbmVkIGJhc2VkIG9uIHRoZSBjb25kaXRpb25hbCBsb2dpYyBiZWxvd1xuICAgIGxldCBidWZmZXJTdGFydE5leHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgbGV0IGJ1ZmZlclN0YXJ0OiBudW1iZXIgPSBwb3M7XG4gICAgbGV0IGJ1ZmZlckVuZDogbnVtYmVyID0gcG9zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGJ1ZmZlcmVkMltpXS5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IGJ1ZmZlcmVkMltpXS5lbmQ7XG4gICAgICAvLyBsb2dnZXIubG9nKCdidWYgc3RhcnQvZW5kOicgKyBidWZmZXJlZC5zdGFydChpKSArICcvJyArIGJ1ZmZlcmVkLmVuZChpKSk7XG4gICAgICBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uID49IHN0YXJ0ICYmIHBvcyA8IGVuZCkge1xuICAgICAgICAvLyBwbGF5IHBvc2l0aW9uIGlzIGluc2lkZSB0aGlzIGJ1ZmZlciBUaW1lUmFuZ2UsIHJldHJpZXZlIGVuZCBvZiBidWZmZXIgcG9zaXRpb24gYW5kIGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgYnVmZmVyU3RhcnQgPSBzdGFydDtcbiAgICAgICAgYnVmZmVyRW5kID0gZW5kO1xuICAgICAgICBidWZmZXJMZW4gPSBidWZmZXJFbmQgLSBwb3M7XG4gICAgICB9IGVsc2UgaWYgKHBvcyArIG1heEhvbGVEdXJhdGlvbiA8IHN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlclN0YXJ0TmV4dCA9IHN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogYnVmZmVyTGVuLFxuICAgICAgc3RhcnQ6IGJ1ZmZlclN0YXJ0IHx8IDAsXG4gICAgICBlbmQ6IGJ1ZmZlckVuZCB8fCAwLFxuICAgICAgbmV4dFN0YXJ0OiBidWZmZXJTdGFydE5leHQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byBnZXQgYnVmZmVyZWQgcHJvcGVydHkuXG4gICAqIFNvdXJjZUJ1ZmZlci5idWZmZXJlZCBtYXkgdGhyb3cgaWYgU291cmNlQnVmZmVyIGlzIHJlbW92ZWQgZnJvbSBpdCdzIE1lZGlhU291cmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0QnVmZmVyZWQobWVkaWE6IEJ1ZmZlcmFibGUpOiBUaW1lUmFuZ2VzIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG1lZGlhLmJ1ZmZlcmVkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5sb2coJ2ZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWQnLCBlKTtcbiAgICAgIHJldHVybiBub29wQnVmZmVyZWQ7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUge1xuICBCdWZmZXJPcGVyYXRpb24sXG4gIEJ1ZmZlck9wZXJhdGlvblF1ZXVlcyxcbiAgU291cmNlQnVmZmVycyxcbiAgU291cmNlQnVmZmVyTmFtZSxcbn0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyT3BlcmF0aW9uUXVldWUge1xuICBwcml2YXRlIGJ1ZmZlcnM6IFNvdXJjZUJ1ZmZlcnM7XG4gIHByaXZhdGUgcXVldWVzOiBCdWZmZXJPcGVyYXRpb25RdWV1ZXMgPSB7XG4gICAgdmlkZW86IFtdLFxuICAgIGF1ZGlvOiBbXSxcbiAgICBhdWRpb3ZpZGVvOiBbXSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2VCdWZmZXJSZWZlcmVuY2U6IFNvdXJjZUJ1ZmZlcnMpIHtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBzb3VyY2VCdWZmZXJSZWZlcmVuY2U7XG4gIH1cblxuICBwdWJsaWMgYXBwZW5kKFxuICAgIG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uLFxuICAgIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUsXG4gICAgcGVuZGluZz86IGJvb2xlYW4sXG4gICkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5xdWV1ZXNbdHlwZV07XG4gICAgcXVldWUucHVzaChvcGVyYXRpb24pO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIXBlbmRpbmcpIHtcbiAgICAgIHRoaXMuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGluc2VydEFib3J0KG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uLCB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBlbmRCbG9ja2VyKHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpOiBQcm9taXNlPHt9PiB7XG4gICAgbGV0IGV4ZWN1dGU7XG4gICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZTx7fT4gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgZXhlY3V0ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgb3BlcmF0aW9uOiBCdWZmZXJPcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlLFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6ICgpID0+IHt9LFxuICAgIH07XG5cbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHVibGljIGV4ZWN1dGVOZXh0KHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0gcXVldWVbMF07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBPcGVyYXRpb25zIGFyZSBleHBlY3RlZCB0byByZXN1bHQgaW4gYW4gJ3VwZGF0ZWVuZCcgZXZlbnQgYmVpbmcgZmlyZWQuIElmIG5vdCwgdGhlIHF1ZXVlIHdpbGwgbG9jay4gT3BlcmF0aW9uc1xuICAgICAgICAvLyB3aGljaCBkbyBub3QgZW5kIHdpdGggdGhpcyBldmVudCBtdXN0IGNhbGwgX29uU0JVcGRhdGVFbmQgbWFudWFsbHlcbiAgICAgICAgb3BlcmF0aW9uLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgIGBbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IEV4Y2VwdGlvbiBleGVjdXRpbmcgXCIke3R5cGV9XCIgU291cmNlQnVmZmVyIG9wZXJhdGlvbjogJHtlcnJvcn1gLFxuICAgICAgICApO1xuICAgICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG5cbiAgICAgICAgLy8gT25seSBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmLCBvdGhlcndpc2UgdGhlIHVwZGF0ZWVuZCBoYW5kbGVyIHdpbGwgZG8gdGhpcyBmb3IgdXNcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLmJ1ZmZlcnNbdHlwZV07XG4gICAgICAgIGlmICghc2I/LnVwZGF0aW5nKSB7XG4gICAgICAgICAgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIHRoaXMucXVldWVzW3R5cGVdLnNoaWZ0KCk7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuXG4gIHB1YmxpYyBjdXJyZW50KHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZXNbdHlwZV1bMF07XG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzLCBFcnJvclR5cGVzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHtcbiAgZ2V0Q29kZWNDb21wYXRpYmxlTmFtZSxcbiAgcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZSxcbn0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvbWVkaWFzb3VyY2UtaGVscGVyJztcbmltcG9ydCB7IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IEJ1ZmZlck9wZXJhdGlvblF1ZXVlIGZyb20gJy4vYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZSc7XG5pbXBvcnQge1xuICBCdWZmZXJPcGVyYXRpb24sXG4gIFNvdXJjZUJ1ZmZlcnMsXG4gIFNvdXJjZUJ1ZmZlck5hbWUsXG4gIFNvdXJjZUJ1ZmZlckxpc3RlbmVycyxcbn0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcbmltcG9ydCB0eXBlIHtcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgQnVmZmVyQXBwZW5kaW5nRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIEJ1ZmZlckNvZGVjc0RhdGEsXG4gIEJ1ZmZlckVPU0RhdGEsXG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgRnJhZ1BhcnNlZERhdGEsXG4gIEZyYWdDaGFuZ2VkRGF0YSxcbiAgRXJyb3JEYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRBUEkgfSBmcm9tICcuLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmltcG9ydCB0eXBlIHsgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuY29uc3QgVklERU9fQ09ERUNfUFJPRklMRV9SRVBMQUNFID1cbiAgLyhhdmNbMTIzNF18aHZjMXxoZXYxfGR2aFsxZV18dnAwOXxhdjAxKSg/OlxcLlteLixdKykrLztcblxuaW50ZXJmYWNlIEJ1ZmZlcmVkQ2hhbmdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHJlYWRvbmx5IGFkZGVkUmFuZ2VzPzogVGltZVJhbmdlcztcbiAgcmVhZG9ubHkgcmVtb3ZlZFJhbmdlcz86IFRpbWVSYW5nZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlckNvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICAvLyBUaGUgbGV2ZWwgZGV0YWlscyB1c2VkIHRvIGRldGVybWluZSBkdXJhdGlvbiwgdGFyZ2V0LWR1cmF0aW9uIGFuZCBsaXZlXG4gIHByaXZhdGUgZGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgbnVsbCA9IG51bGw7XG4gIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gIHByaXZhdGUgX29iamVjdFVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gIC8vIEEgcXVldWUgb2YgYnVmZmVyIG9wZXJhdGlvbnMgd2hpY2ggcmVxdWlyZSB0aGUgU291cmNlQnVmZmVyIHRvIG5vdCBiZSB1cGRhdGluZyB1cG9uIGV4ZWN1dGlvblxuICBwcml2YXRlIG9wZXJhdGlvblF1ZXVlITogQnVmZmVyT3BlcmF0aW9uUXVldWU7XG4gIC8vIFJlZmVyZW5jZXMgdG8gZXZlbnQgbGlzdGVuZXJzIGZvciBlYWNoIFNvdXJjZUJ1ZmZlciwgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGZvciBldmVudCByZW1vdmFsXG4gIHByaXZhdGUgbGlzdGVuZXJzITogU291cmNlQnVmZmVyTGlzdGVuZXJzO1xuXG4gIHByaXZhdGUgaGxzOiBIbHM7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuICBwdWJsaWMgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZDogbnVtYmVyID0gMDtcblxuICAvLyBUaGUgdG90YWwgbnVtYmVyIG9mIEJVRkZFUl9DT0RFQyBldmVudHMgcmVjZWl2ZWRcbiAgcHJpdmF0ZSBfYnVmZmVyQ29kZWNFdmVudHNUb3RhbDogbnVtYmVyID0gMDtcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYXR0YWNoZWQgbWVkaWEgZWxlbWVudFxuICBwdWJsaWMgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuICBwdWJsaWMgbWVkaWFTb3VyY2U6IE1lZGlhU291cmNlIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gTGFzdCBNUDMgYXVkaW8gY2h1bmsgYXBwZW5kZWRcbiAgcHJpdmF0ZSBsYXN0TXBlZ0F1ZGlvQ2h1bms6IENodW5rTWV0YWRhdGEgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIGFwcGVuZFNvdXJjZTogYm9vbGVhbjtcblxuICAvLyBjb3VudGVyc1xuICBwdWJsaWMgYXBwZW5kRXJyb3JzID0ge1xuICAgIGF1ZGlvOiAwLFxuICAgIHZpZGVvOiAwLFxuICAgIGF1ZGlvdmlkZW86IDAsXG4gIH07XG5cbiAgcHVibGljIHRyYWNrczogVHJhY2tTZXQgPSB7fTtcbiAgcHVibGljIHBlbmRpbmdUcmFja3M6IFRyYWNrU2V0ID0ge307XG4gIHB1YmxpYyBzb3VyY2VCdWZmZXIhOiBTb3VyY2VCdWZmZXJzO1xuXG4gIHByb3RlY3RlZCBsb2c6IChtc2c6IGFueSkgPT4gdm9pZDtcbiAgcHJvdGVjdGVkIHdhcm46IChtc2c6IGFueSwgb2JqPzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgZXJyb3I6IChtc2c6IGFueSwgb2JqPzogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGhsczogSGxzKSB7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgY29uc3QgbG9nUHJlZml4ID0gJ1tidWZmZXItY29udHJvbGxlcl0nO1xuICAgIHRoaXMuYXBwZW5kU291cmNlID0gaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIGxvZ1ByZWZpeCk7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNTb3VyY2VUeXBlcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHxcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucGVuZGluZ1RyYWNrcykubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgQnVmZmVyT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW10sXG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZEVycm9ycyA9IHtcbiAgICAgIGF1ZGlvOiAwLFxuICAgICAgdmlkZW86IDAsXG4gICAgICBhdWRpb3ZpZGVvOiAwLFxuICAgIH07XG4gICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWFuaWZlc3RQYXJzZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsXG4gICAgZGF0YTogTWFuaWZlc3RQYXJzZWREYXRhLFxuICApIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICBsZXQgY29kZWNFdmVudHM6IG51bWJlciA9IDI7XG4gICAgaWYgKChkYXRhLmF1ZGlvICYmICFkYXRhLnZpZGVvKSB8fCAhZGF0YS5hbHRBdWRpbyB8fCAhX19VU0VfQUxUX0FVRElPX18pIHtcbiAgICAgIGNvZGVjRXZlbnRzID0gMTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IGNvZGVjRXZlbnRzO1xuICAgIHRoaXMubG9nKGAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWRgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhQXR0YWNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgbWVkaWEgPSAodGhpcy5tZWRpYSA9IGRhdGEubWVkaWEpO1xuICAgIGNvbnN0IE1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UodGhpcy5hcHBlbmRTb3VyY2UpO1xuICAgIGlmIChtZWRpYSAmJiBNZWRpYVNvdXJjZSkge1xuICAgICAgY29uc3QgbXMgPSAodGhpcy5tZWRpYVNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpKTtcbiAgICAgIHRoaXMubG9nKGBjcmVhdGVkIG1lZGlhIHNvdXJjZTogJHttcy5jb25zdHJ1Y3Rvcj8ubmFtZX1gKTtcbiAgICAgIC8vIE1lZGlhU291cmNlIGxpc3RlbmVycyBhcmUgYXJyb3cgZnVuY3Rpb25zIHdpdGggYSBsZXhpY2FsIHNjb3BlLCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgYm91bmRcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VlbmRlZCcsIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VjbG9zZScsIHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSk7XG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzdGFydHN0cmVhbWluZycsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignZW5kc3RyZWFtaW5nJywgdGhpcy5fb25FbmRTdHJlYW1pbmcpO1xuXG4gICAgICAvLyBjYWNoZSB0aGUgbG9jYWxseSBnZW5lcmF0ZWQgb2JqZWN0IHVybFxuICAgICAgY29uc3Qgb2JqZWN0VXJsID0gKHRoaXMuX29iamVjdFVybCA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChtcykpO1xuICAgICAgLy8gbGluayB2aWRlbyBhbmQgbWVkaWEgU291cmNlXG4gICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtZWRpYS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgIC8vIE1hbmFnZWRNZWRpYVNvdXJjZSB3aWxsIG5vdCBvcGVuIHdpdGhvdXQgZGlzYWJsZVJlbW90ZVBsYXliYWNrIHNldCB0byBmYWxzZSBvciBzb3VyY2UgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgY29uc3QgTU1TID0gKHNlbGYgYXMgYW55KS5NYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgICAgICAgbWVkaWEuZGlzYWJsZVJlbW90ZVBsYXliYWNrID1cbiAgICAgICAgICAgIG1lZGlhLmRpc2FibGVSZW1vdGVQbGF5YmFjayB8fCAoTU1TICYmIG1zIGluc3RhbmNlb2YgTU1TKTtcbiAgICAgICAgICByZW1vdmVTb3VyY2VDaGlsZHJlbihtZWRpYSk7XG4gICAgICAgICAgYWRkU291cmNlKG1lZGlhLCBvYmplY3RVcmwpO1xuICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBtZWRpYS5zcmMgPSBvYmplY3RVcmw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lZGlhLnNyYyA9IG9iamVjdFVybDtcbiAgICAgIH1cbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgX29uRW5kU3RyZWFtaW5nID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhscy5wYXVzZUJ1ZmZlcmluZygpO1xuICB9O1xuICBwcml2YXRlIF9vblN0YXJ0U3RyZWFtaW5nID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7IG1lZGlhLCBtZWRpYVNvdXJjZSwgX29iamVjdFVybCB9ID0gdGhpcztcbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIHRoaXMubG9nKCdtZWRpYSBzb3VyY2UgZGV0YWNoaW5nJyk7XG4gICAgICBpZiAobWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZW5kT2ZTdHJlYW0gY291bGQgdHJpZ2dlciBleGNlcHRpb24gaWYgYW55IHNvdXJjZWJ1ZmZlciBpcyBpbiB1cGRhdGluZyBzdGF0ZVxuICAgICAgICAgIC8vIHdlIGRvbid0IHJlYWxseSBjYXJlIGFib3V0IGNoZWNraW5nIHNvdXJjZWJ1ZmZlciBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGFzIHdlIGFyZSBhbnl3YXkgZGV0YWNoaW5nIHRoZSBNZWRpYVNvdXJjZVxuICAgICAgICAgIC8vIGxldCdzIGp1c3QgYXZvaWQgdGhpcyBleGNlcHRpb24gdG8gcHJvcGFnYXRlXG4gICAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgICAgYG9uTWVkaWFEZXRhY2hpbmc6ICR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENsZWFuIHVwIHRoZSBTb3VyY2VCdWZmZXJzIGJ5IGludm9raW5nIG9uQnVmZmVyUmVzZXRcbiAgICAgIHRoaXMub25CdWZmZXJSZXNldCgpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWVuZGVkJywgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZWNsb3NlJywgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXJ0c3RyZWFtaW5nJywgdGhpcy5fb25TdGFydFN0cmVhbWluZyk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRzdHJlYW1pbmcnLCB0aGlzLl9vbkVuZFN0cmVhbWluZyk7XG5cbiAgICAgIC8vIERldGFjaCBwcm9wZXJseSB0aGUgTWVkaWFTb3VyY2UgZnJvbSB0aGUgSFRNTE1lZGlhRWxlbWVudCBhc1xuICAgICAgLy8gc3VnZ2VzdGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvbWVkaWEtc291cmNlL2lzc3Vlcy81My5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbXB0aWVkJywgdGhpcy5fb25NZWRpYUVtcHRpZWQpO1xuICAgICAgICBpZiAoX29iamVjdFVybCkge1xuICAgICAgICAgIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChfb2JqZWN0VXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFuIHVwIHZpZGVvIHRhZyBzcmMgb25seSBpZiBpdCdzIG91ciBvd24gdXJsLiBzb21lIGV4dGVybmFsIGxpYnJhcmllcyBtaWdodFxuICAgICAgICAvLyBoaWphY2sgdGhlIHZpZGVvIHRhZyBhbmQgY2hhbmdlIGl0cyAnc3JjJyB3aXRob3V0IGRlc3Ryb3lpbmcgdGhlIEhscyBpbnN0YW5jZSBmaXJzdFxuICAgICAgICBpZiAodGhpcy5tZWRpYVNyYyA9PT0gX29iamVjdFVybCkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgaWYgKHRoaXMuYXBwZW5kU291cmNlKSB7XG4gICAgICAgICAgICByZW1vdmVTb3VyY2VDaGlsZHJlbihtZWRpYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lZGlhLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAnbWVkaWF8c291cmNlLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hFRCwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgIH0pO1xuICAgIHRoaXMuX2luaXRTb3VyY2VCdWZmZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRCdWZmZXIodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzYikge1xuICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgLy8gU3luY2hyb25vdXNseSByZW1vdmUgdGhlIFNCIGZyb20gdGhlIG1hcCBiZWZvcmUgdGhlIG5leHQgY2FsbCBpbiBvcmRlciB0byBwcmV2ZW50IGFuIGFzeW5jIGZ1bmN0aW9uIGZyb21cbiAgICAgICAgLy8gYWNjZXNzaW5nIGl0XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZT8uc291cmNlQnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcihzYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMud2Fybihgb25CdWZmZXJSZXNldCAke3R5cGV9YCwgZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25CdWZmZXJDb2RlY3MoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ09ERUNTLFxuICAgIGRhdGE6IEJ1ZmZlckNvZGVjc0RhdGEsXG4gICkge1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlckNvdW50ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aDtcbiAgICBjb25zdCB0cmFja05hbWVzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdHJhY2tOYW1lcy5mb3JFYWNoKCh0cmFja05hbWUpID0+IHtcbiAgICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgICAvLyBjaGVjayBpZiBTb3VyY2VCdWZmZXIgY29kZWMgbmVlZHMgdG8gY2hhbmdlXG4gICAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKHRyYWNrICYmIHR5cGVvZiB0cmFjay5idWZmZXIuY2hhbmdlVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnN0IHsgaWQsIGNvZGVjLCBsZXZlbENvZGVjLCBjb250YWluZXIsIG1ldGFkYXRhIH0gPVxuICAgICAgICAgICAgZGF0YVt0cmFja05hbWVdO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlY0Z1bGwgPSBwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lKFxuICAgICAgICAgICAgdHJhY2suY29kZWMsXG4gICAgICAgICAgICB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgY3VycmVudENvZGVjID0gY3VycmVudENvZGVjRnVsbD8ucmVwbGFjZShcbiAgICAgICAgICAgIFZJREVPX0NPREVDX1BST0ZJTEVfUkVQTEFDRSxcbiAgICAgICAgICAgICckMScsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgdHJhY2tDb2RlYyA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUoY29kZWMsIGxldmVsQ29kZWMpO1xuICAgICAgICAgIGNvbnN0IG5leHRDb2RlYyA9IHRyYWNrQ29kZWM/LnJlcGxhY2UoXG4gICAgICAgICAgICBWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UsXG4gICAgICAgICAgICAnJDEnLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRyYWNrQ29kZWMgJiYgY3VycmVudENvZGVjICE9PSBuZXh0Q29kZWMpIHtcbiAgICAgICAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdHJhY2tDb2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUoXG4gICAgICAgICAgICAgICAgdHJhY2tDb2RlYyxcbiAgICAgICAgICAgICAgICB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHtjb250YWluZXJ9O2NvZGVjcz0ke3RyYWNrQ29kZWN9YDtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hhbmdlVHlwZSh0cmFja05hbWUsIG1pbWVUeXBlKTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBzd2l0Y2hpbmcgY29kZWMgJHtjdXJyZW50Q29kZWNGdWxsfSB0byAke3RyYWNrQ29kZWN9YCk7XG4gICAgICAgICAgICB0aGlzLnRyYWNrc1t0cmFja05hbWVdID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IHRyYWNrLmJ1ZmZlcixcbiAgICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgbGV2ZWxDb2RlYyxcbiAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IGRhdGFbdHJhY2tOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAtIDEsXG4gICAgICAwLFxuICAgICk7XG4gICAgaWYgKHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAhPT0gYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCkge1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGAke2J1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWR9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkICR7dHJhY2tOYW1lcy5qb2luKFxuICAgICAgICAgICcsJyxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm1lZGlhU291cmNlICYmIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRDaGFuZ2VUeXBlKHR5cGUsIG1pbWVUeXBlKSB7XG4gICAgY29uc3QgeyBvcGVyYXRpb25RdWV1ZSB9ID0gdGhpcztcbiAgICBjb25zdCBvcGVyYXRpb246IEJ1ZmZlck9wZXJhdGlvbiA9IHtcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgdGhpcy5sb2coYGNoYW5naW5nICR7dHlwZX0gc291cmNlQnVmZmVyIHR5cGUgdG8gJHttaW1lVHlwZX1gKTtcbiAgICAgICAgICBzYi5jaGFuZ2VUeXBlKG1pbWVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHt9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge30sXG4gICAgICBvbkVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMud2FybihgRmFpbGVkIHRvIGNoYW5nZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciB0eXBlYCwgZXJyb3IpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgISF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyQXBwZW5kaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0FQUEVORElORyxcbiAgICBldmVudERhdGE6IEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gICkge1xuICAgIGNvbnN0IHsgaGxzLCBvcGVyYXRpb25RdWV1ZSwgdHJhY2tzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGF0YSwgdHlwZSwgZnJhZywgcGFydCwgY2h1bmtNZXRhIH0gPSBldmVudERhdGE7XG4gICAgY29uc3QgY2h1bmtTdGF0cyA9IGNodW5rTWV0YS5idWZmZXJpbmdbdHlwZV07XG5cbiAgICBjb25zdCBidWZmZXJBcHBlbmRpbmdTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIGNvbnN0IGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICBjb25zdCBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cbiAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBsZXQgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiBhdWRpb1RyYWNrPy5jb250YWluZXIgPT09ICdhdWRpby9tcGVnJykge1xuICAgICAgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPVxuICAgICAgICAhdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgfHxcbiAgICAgICAgY2h1bmtNZXRhLmlkID09PSAxIHx8XG4gICAgICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjaHVua01ldGEuc247XG4gICAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGNodW5rTWV0YTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuICAgIGNvbnN0IG9wZXJhdGlvbjogQnVmZmVyT3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGZyYWdTdGFydCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICAgIGBVcGRhdGluZyBhdWRpbyBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvICR7ZnJhZ1N0YXJ0fSAoZGVsdGE6ICR7ZGVsdGF9KSBzbjogJHtmcmFnLnNufSlgLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzYi50aW1lc3RhbXBPZmZzZXQgPSBmcmFnU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kRXhlY3V0b3IoZGF0YSwgdHlwZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZXN0YXJ0YCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06ICR7dHlwZX0gU291cmNlQnVmZmVyIHVwZGF0ZWVuZGApO1xuICAgICAgICBjb25zdCBlbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVFbmQgPSBjaHVua1N0YXRzLmVuZCA9IGVuZDtcbiAgICAgICAgaWYgKGZyYWdCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBmcmFnQnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0QnVmZmVyaW5nICYmIHBhcnRCdWZmZXJpbmcuZmlyc3QgPT09IDApIHtcbiAgICAgICAgICBwYXJ0QnVmZmVyaW5nLmZpcnN0ID0gZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzb3VyY2VCdWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIGluIHNvdXJjZUJ1ZmZlcikge1xuICAgICAgICAgIHRpbWVSYW5nZXNbdHlwZV0gPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc291cmNlQnVmZmVyW3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEVycm9yc1t0eXBlXSA9IDA7XG4gICAgICAgIGlmICh0eXBlID09PSAnYXVkaW8nIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpb3ZpZGVvID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZEVycm9ycy5hdWRpbyA9IDA7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnMudmlkZW8gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBwYXJ0LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzLFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgIGNvbnN0IGV2ZW50OiBFcnJvckRhdGEgPSB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgZXJyOiBlcnJvcixcbiAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKChlcnJvciBhcyBET01FeGNlcHRpb24pLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICAgICAgICAvLyBRdW90YUV4Y2VlZGVkRXJyb3I6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcXVvdGFleGNlZWRlZGVycm9yXG4gICAgICAgICAgLy8gbGV0J3Mgc3RvcCBhcHBlbmRpbmcgYW55IHNlZ21lbnRzLCBhbmQgcmVwb3J0IEJVRkZFUl9GVUxMX0VSUk9SIGVycm9yXG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhcHBlbmRFcnJvckNvdW50ID0gKyt0aGlzLmFwcGVuZEVycm9yc1t0eXBlXTtcbiAgICAgICAgICBldmVudC5kZXRhaWxzID0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I7XG4gICAgICAgICAgLyogd2l0aCBVSEQgY29udGVudCwgd2UgY291bGQgZ2V0IGxvb3Agb2YgcXVvdGEgZXhjZWVkZWQgZXJyb3IgdW50aWxcbiAgICAgICAgICAgIGJyb3dzZXIgaXMgYWJsZSB0byBldmljdCBzb21lIGRhdGEgZnJvbSBzb3VyY2VidWZmZXIuIFJldHJ5aW5nIGNhbiBoZWxwIHJlY292ZXIuXG4gICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICBgRmFpbGVkICR7YXBwZW5kRXJyb3JDb3VudH0vJHtobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnl9IHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIFwiJHt0eXBlfVwiIHNvdXJjZUJ1ZmZlcmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYXBwZW5kRXJyb3JDb3VudCA+PSBobHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkpIHtcbiAgICAgICAgICAgIGV2ZW50LmZhdGFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBldmVudCk7XG4gICAgICB9LFxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgISF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uQnVmZmVyRmx1c2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsXG4gICAgZGF0YTogQnVmZmVyRmx1c2hpbmdEYXRhLFxuICApIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZsdXNoT3BlcmF0aW9uID0gKHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpOiBCdWZmZXJPcGVyYXRpb24gPT4gKHtcbiAgICAgIGV4ZWN1dGU6IHRoaXMucmVtb3ZlRXhlY3V0b3IuYmluZChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZGF0YS5zdGFydE9mZnNldCxcbiAgICAgICAgZGF0YS5lbmRPZmZzZXQsXG4gICAgICApLFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IFN0YXJ0ZWQgZmx1c2hpbmcgJHtkYXRhLnN0YXJ0T2Zmc2V0fSAtPiAke2RhdGEuZW5kT2Zmc2V0fSBmb3IgJHt0eXBlfSBTb3VyY2UgQnVmZmVyYCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEZpbmlzaGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgeyB0eXBlIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGBGYWlsZWQgdG8gcmVtb3ZlIGZyb20gJHt0eXBlfSBTb3VyY2VCdWZmZXJgLCBlcnJvcik7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKGRhdGEudHlwZSksIGRhdGEudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChmbHVzaE9wZXJhdGlvbih0eXBlKSwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnUGFyc2VkKGV2ZW50OiBFdmVudHMuRlJBR19QQVJTRUQsIGRhdGE6IEZyYWdQYXJzZWREYXRhKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0IH0gPSBkYXRhO1xuICAgIGNvbnN0IGJ1ZmZlcnNBcHBlbmRlZFRvOiBBcnJheTxTb3VyY2VCdWZmZXJOYW1lPiA9IFtdO1xuICAgIGNvbnN0IGVsZW1lbnRhcnlTdHJlYW1zID0gcGFydFxuICAgICAgPyBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zXG4gICAgICA6IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT1ZJREVPXSkge1xuICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgnYXVkaW92aWRlbycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpbycpO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRhcnlTdHJlYW1zW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT10pIHtcbiAgICAgICAgYnVmZmVyc0FwcGVuZGVkVG8ucHVzaCgndmlkZW8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvblVuYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGUsXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiAke2ZyYWcudHlwZX0gbGV2ZWw6ICR7ZnJhZy5sZXZlbH0gc246ICR7ZnJhZy5zbn1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVyc0FwcGVuZGVkVG8pO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdDaGFuZ2VkKGV2ZW50OiBFdmVudHMuRlJBR19DSEFOR0VELCBkYXRhOiBGcmFnQ2hhbmdlZERhdGEpIHtcbiAgICB0aGlzLnRyaW1CdWZmZXJzKCk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICBwcm90ZWN0ZWQgb25CdWZmZXJFb3MoZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhOiBCdWZmZXJFT1NEYXRhKSB7XG4gICAgY29uc3QgZW5kZWQgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IgJiYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICBzYi5lbmRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIXNiLmVuZGVkKSB7XG4gICAgICAgICAgc2IuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMubG9nKGAke3R5cGV9IHNvdXJjZUJ1ZmZlciBub3cgRU9TYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgJiYgISEoIXNiIHx8IHNiLmVuZGVkKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIGlmIChlbmRlZCkge1xuICAgICAgdGhpcy5sb2coYFF1ZXVlaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClgKTtcbiAgICAgIHRoaXMuYmxvY2tCdWZmZXJzKCgpID0+IHtcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFtZWRpYVNvdXJjZSB8fCBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlICE9PSAnb3BlbicpIHtcbiAgICAgICAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICBgQ291bGQgbm90IGNhbGwgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKS4gbWVkaWFTb3VyY2UucmVhZHlTdGF0ZTogJHttZWRpYVNvdXJjZS5yZWFkeVN0YXRlfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2coYENhbGxpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgICAvLyBBbGxvdyB0aGlzIHRvIHRocm93IGFuZCBiZSBjYXVnaHQgYnkgdGhlIGVucXVldWVpbmcgZnVuY3Rpb25cbiAgICAgICAgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbkxldmVsVXBkYXRlZChcbiAgICBldmVudDogRXZlbnRzLkxFVkVMX1VQREFURUQsXG4gICAgeyBkZXRhaWxzIH06IExldmVsVXBkYXRlZERhdGEsXG4gICkge1xuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG5cbiAgICBpZiAodGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCkge1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIHRyaW1CdWZmZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzLCBkZXRhaWxzLCBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8IGRldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlclR5cGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZzogUmVhZG9ubHk8SGxzQ29uZmlnPiA9IGhscy5jb25maWc7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGRldGFpbHMubGV2ZWxUYXJnZXREdXJhdGlvbjtcblxuICAgIC8vIFN1cHBvcnQgZm9yIGRlcHJlY2F0ZWQgbGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICBjb25zdCBiYWNrQnVmZmVyTGVuZ3RoID1cbiAgICAgIGRldGFpbHMubGl2ZSAmJiBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGxcbiAgICAgICAgPyBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGhcbiAgICAgICAgOiBjb25maWcuYmFja0J1ZmZlckxlbmd0aDtcblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoYmFja0J1ZmZlckxlbmd0aCkgJiYgYmFja0J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1heEJhY2tCdWZmZXJMZW5ndGggPSBNYXRoLm1heChiYWNrQnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICBjb25zdCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPVxuICAgICAgICBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLVxuICAgICAgICBtYXhCYWNrQnVmZmVyTGVuZ3RoO1xuXG4gICAgICB0aGlzLmZsdXNoQmFja0J1ZmZlcihcbiAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgIHRhcmdldER1cmF0aW9uLFxuICAgICAgICB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIE51bWJlci5pc0Zpbml0ZShjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCkgJiZcbiAgICAgIGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkID4gMFxuICAgICkge1xuICAgICAgY29uc3QgZnJvbnRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgY29uZmlnLm1heEJ1ZmZlckxlbmd0aCxcbiAgICAgICAgY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtYXhGcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGZyb250QnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICBjb25zdCB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uID1cbiAgICAgICAgTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uICtcbiAgICAgICAgbWF4RnJvbnRCdWZmZXJMZW5ndGg7XG5cbiAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihcbiAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgIHRhcmdldER1cmF0aW9uLFxuICAgICAgICB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaEJhY2tCdWZmZXIoXG4gICAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgICB0YXJnZXREdXJhdGlvbjogbnVtYmVyLFxuICAgIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbjogbnVtYmVyLFxuICApIHtcbiAgICBjb25zdCB7IGRldGFpbHMsIHNvdXJjZUJ1ZmZlciB9ID0gdGhpcztcbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcblxuICAgIHNvdXJjZUJ1ZmZlclR5cGVzLmZvckVhY2goKHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgLy8gd2hlbiB0YXJnZXQgYnVmZmVyIHN0YXJ0IGV4Y2VlZHMgYWN0dWFsIGJ1ZmZlciBzdGFydFxuICAgICAgICBpZiAoXG4gICAgICAgICAgYnVmZmVyZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgIHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlcmVkLnN0YXJ0KDApXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJBQ0tfQlVGRkVSX1JFQUNIRUQsIHtcbiAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcbiAgICAgICAgICBpZiAoZGV0YWlscz8ubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHNiLmVuZGVkICYmXG4gICAgICAgICAgICBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkgLSBjdXJyZW50VGltZSA8IHRhcmdldER1cmF0aW9uICogMlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgIGBDYW5ub3QgZmx1c2ggJHt0eXBlfSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24sXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmbHVzaEZyb250QnVmZmVyKFxuICAgIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gICAgdGFyZ2V0RHVyYXRpb246IG51bWJlcixcbiAgICB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uOiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IHsgc291cmNlQnVmZmVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuXG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaCgodHlwZTogU291cmNlQnVmZmVyTmFtZSkgPT4ge1xuICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQoc2IpO1xuICAgICAgICBjb25zdCBudW1CdWZmZXJlZFJhbmdlcyA9IGJ1ZmZlcmVkLmxlbmd0aDtcbiAgICAgICAgLy8gVGhlIGJ1ZmZlciBpcyBlaXRoZXIgZW1wdHkgb3IgY29udGlndW91c1xuICAgICAgICBpZiAobnVtQnVmZmVyZWRSYW5nZXMgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQobnVtQnVmZmVyZWRSYW5nZXMgLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRW5kID0gYnVmZmVyZWQuZW5kKG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgIC8vIE5vIGZsdXNoIGlmIHdlIGNhbiB0b2xlcmF0ZSB0aGUgY3VycmVudCBidWZmZXIgbGVuZ3RoIG9yIHRoZSBjdXJyZW50IGJ1ZmZlciByYW5nZSB3ZSB3b3VsZCBmbHVzaCBpcyBjb250aWd1b3VzIHdpdGggY3VycmVudCBwb3NpdGlvblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGFyZ2V0RnJvbnRCdWZmZXJQb3NpdGlvbiA+IGJ1ZmZlclN0YXJ0IHx8XG4gICAgICAgICAgKGN1cnJlbnRUaW1lID49IGJ1ZmZlclN0YXJ0ICYmIGN1cnJlbnRUaW1lIDw9IGJ1ZmZlckVuZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHNiLmVuZGVkICYmIGN1cnJlbnRUaW1lIC0gYnVmZmVyRW5kIDwgMiAqIHRhcmdldER1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICBgQ2Fubm90IGZsdXNoICR7dHlwZX0gZnJvbnQgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogYnVmZmVyU3RhcnQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBJbmZpbml0eSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIGN1cnJlbnQgbGV2ZWwgZHVyYXRpb24gb3Igb3ZlcnJpZGUgdG8gSW5maW5pdHkgaWYgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJcbiAgICogJ2xpdmVEdXJhdGlvbkluZmluaXR5YCBpcyBzZXQgdG8gYHRydWVgXG4gICAqIE1vcmUgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzM1NVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5kZXRhaWxzIHx8XG4gICAgICAhdGhpcy5tZWRpYSB8fFxuICAgICAgIXRoaXMubWVkaWFTb3VyY2UgfHxcbiAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSAhPT0gJ29wZW4nXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGV0YWlscywgaGxzLCBtZWRpYSwgbWVkaWFTb3VyY2UgfSA9IHRoaXM7XG4gICAgY29uc3QgbGV2ZWxEdXJhdGlvbiA9IGRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0ICsgZGV0YWlscy50b3RhbGR1cmF0aW9uO1xuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBtZWRpYS5kdXJhdGlvbjtcbiAgICBjb25zdCBtc0R1cmF0aW9uID0gTnVtYmVyLmlzRmluaXRlKG1lZGlhU291cmNlLmR1cmF0aW9uKVxuICAgICAgPyBtZWRpYVNvdXJjZS5kdXJhdGlvblxuICAgICAgOiAwO1xuXG4gICAgaWYgKGRldGFpbHMubGl2ZSAmJiBobHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICAvLyBPdmVycmlkZSBkdXJhdGlvbiB0byBJbmZpbml0eVxuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMudXBkYXRlU2Vla2FibGVSYW5nZShkZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGxldmVsRHVyYXRpb24gPiBtc0R1cmF0aW9uICYmIGxldmVsRHVyYXRpb24gPiBtZWRpYUR1cmF0aW9uKSB8fFxuICAgICAgIU51bWJlci5pc0Zpbml0ZShtZWRpYUR1cmF0aW9uKVxuICAgICkge1xuICAgICAgLy8gbGV2ZWxEdXJhdGlvbiB3YXMgdGhlIGxhc3QgdmFsdWUgd2Ugc2V0LlxuICAgICAgLy8gbm90IHVzaW5nIG1lZGlhU291cmNlLmR1cmF0aW9uIGFzIHRoZSBicm93c2VyIG1heSB0d2VhayB0aGlzIHZhbHVlXG4gICAgICAvLyBvbmx5IHVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaWYgaXRzIHZhbHVlIGluY3JlYXNlLCB0aGlzIGlzIHRvIGF2b2lkXG4gICAgICAvLyBmbHVzaGluZyBhbHJlYWR5IGJ1ZmZlcmVkIHBvcnRpb24gd2hlbiBzd2l0Y2hpbmcgYmV0d2VlbiBxdWFsaXR5IGxldmVsXG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvICR7bGV2ZWxEdXJhdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgbWVkaWFTb3VyY2UuZHVyYXRpb24gPSBsZXZlbER1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVNlZWthYmxlUmFuZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGxldmVsRGV0YWlscy5saXZlICYmIG1lZGlhU291cmNlPy5zZXRMaXZlU2Vla2FibGVSYW5nZSkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBmcmFnbWVudHNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgoc3RhcnQsIHN0YXJ0ICsgbGV2ZWxEZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvICR7bWVkaWFTb3VyY2UuZHVyYXRpb259LiBTZXR0aW5nIHNlZWthYmxlIHJhbmdlIHRvICR7c3RhcnR9LSR7ZW5kfS5gLFxuICAgICAgKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgY29uc3QgeyBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLCBvcGVyYXRpb25RdWV1ZSwgcGVuZGluZ1RyYWNrcyB9ID0gdGhpcztcblxuICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlY2VpdmVkIGFsbCBvZiB0aGUgZXhwZWN0ZWQgYnVmZmVyQ29kZWMgZXZlbnRzLiBXaGVuIG5vbmUgcmVtYWluLCBjcmVhdGUgYWxsIHRoZSBzb3VyY2VCdWZmZXJzIGF0IG9uY2UuXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgTVNFIHNwZWMgYWxsb3dzIGltcGxlbWVudGF0aW9ucyB0byB0aHJvdyBRdW90YUV4Y2VlZGVkRXJyb3JzIGlmIGNyZWF0aW5nIG5ldyBzb3VyY2VCdWZmZXJzIGFmdGVyXG4gICAgLy8gZGF0YSBoYXMgYmVlbiBhcHBlbmRlZCB0byBleGlzdGluZyBvbmVzLlxuICAgIC8vIDIgdHJhY2tzIGlzIHRoZSBtYXggKG9uZSBmb3IgYXVkaW8sIG9uZSBmb3IgdmlkZW8pLiBJZiB3ZSd2ZSByZWFjaCB0aGlzIG1heCBnbyBhaGVhZCBhbmQgY3JlYXRlIHRoZSBidWZmZXJzLlxuICAgIGNvbnN0IHBlbmRpbmdUcmFja3NDb3VudCA9IE9iamVjdC5rZXlzKHBlbmRpbmdUcmFja3MpLmxlbmd0aDtcbiAgICBpZiAoXG4gICAgICBwZW5kaW5nVHJhY2tzQ291bnQgJiZcbiAgICAgICghYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCB8fFxuICAgICAgICBwZW5kaW5nVHJhY2tzQ291bnQgPT09IDIgfHxcbiAgICAgICAgJ2F1ZGlvdmlkZW8nIGluIHBlbmRpbmdUcmFja3MpXG4gICAgKSB7XG4gICAgICAvLyBvaywgbGV0J3MgY3JlYXRlIHRoZW0gbm93ICFcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlQnVmZmVycyhwZW5kaW5nVHJhY2tzKTtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgLy8gYXBwZW5kIGFueSBwZW5kaW5nIHNlZ21lbnRzIG5vdyAhXG4gICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB7IHRyYWNrczogdGhpcy50cmFja3MgfSk7XG4gICAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgodHlwZTogU291cmNlQnVmZmVyTmFtZSkgPT4ge1xuICAgICAgICAgIG9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICdjb3VsZCBub3QgY3JlYXRlIHNvdXJjZSBidWZmZXIgZm9yIG1lZGlhIGNvZGVjKHMpJyxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBjcmVhdGVTb3VyY2VCdWZmZXJzKHRyYWNrczogVHJhY2tTZXQpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJ1ZmZlciwgbWVkaWFTb3VyY2UgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGwnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0cmFja05hbWUgaW4gdHJhY2tzKSB7XG4gICAgICBpZiAoIXNvdXJjZUJ1ZmZlclt0cmFja05hbWVdKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZSBhcyBrZXlvZiBUcmFja1NldF07XG4gICAgICAgIGlmICghdHJhY2spIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBzb3VyY2UgYnVmZmVyIGV4aXN0cyBmb3IgdHJhY2sgJHt0cmFja05hbWV9LCBob3dldmVyIHRyYWNrIGRvZXMgbm90YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBsZXZlbENvZGVjIGFzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgIGxldCBjb2RlYyA9IHRyYWNrLmxldmVsQ29kZWMgfHwgdHJhY2suY29kZWM7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgIGlmICh0cmFja05hbWUuc2xpY2UoMCwgNSkgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIGNvZGVjID0gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShcbiAgICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICAgIHRoaXMuaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGAke3RyYWNrLmNvbnRhaW5lcn07Y29kZWNzPSR7Y29kZWN9YDtcbiAgICAgICAgdGhpcy5sb2coYGNyZWF0aW5nIHNvdXJjZUJ1ZmZlcigke21pbWVUeXBlfSlgKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzYiA9IChzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9XG4gICAgICAgICAgICBtZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIobWltZVR5cGUpKTtcbiAgICAgICAgICBjb25zdCBzYk5hbWUgPSB0cmFja05hbWUgYXMgU291cmNlQnVmZmVyTmFtZTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZXN0YXJ0JywgdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KTtcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKHNiTmFtZSwgJ3VwZGF0ZWVuZCcsIHRoaXMuX29uU0JVcGRhdGVFbmQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnZXJyb3InLCB0aGlzLl9vblNCVXBkYXRlRXJyb3IpO1xuICAgICAgICAgIC8vIE1hbmFnZWRTb3VyY2VCdWZmZXIgYnVmZmVyZWRjaGFuZ2UgZXZlbnRcbiAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKFxuICAgICAgICAgICAgc2JOYW1lLFxuICAgICAgICAgICAgJ2J1ZmZlcmVkY2hhbmdlJyxcbiAgICAgICAgICAgICh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lLCBldmVudDogQnVmZmVyZWRDaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAvLyBJZiBtZWRpYSB3YXMgZWplY3RlZCBjaGVjayBmb3IgYSBjaGFuZ2UuIEFkZGVkIHJhbmdlcyBhcmUgcmVkdW5kYW50IHdpdGggY2hhbmdlcyBvbiAndXBkYXRlZW5kJyBldmVudC5cbiAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFJhbmdlcyA9IGV2ZW50LnJlbW92ZWRSYW5nZXM7XG4gICAgICAgICAgICAgIGlmIChyZW1vdmVkUmFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogdHJhY2tOYW1lIGFzIFNvdXJjZUJ1ZmZlck5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuZXJyb3IoYGVycm9yIHdoaWxlIHRyeWluZyB0byBhZGQgc291cmNlQnVmZmVyOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHJhY2tOYW1lIGFzIFNvdXJjZUJ1ZmZlck5hbWUsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBLZWVwIGFzIGFycm93IGZ1bmN0aW9ucyBzbyB0aGF0IHdlIGNhbiBkaXJlY3RseSByZWZlcmVuY2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGFzIGV2ZW50IGxpc3RlbmVyc1xuICBwcml2YXRlIF9vbk1lZGlhU291cmNlT3BlbiA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1lZGlhLCBtZWRpYVNvdXJjZSB9ID0gdGhpcztcbiAgICB0aGlzLmxvZygnTWVkaWEgc291cmNlIG9wZW5lZCcpO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgIHRoaXMudXBkYXRlTWVkaWFFbGVtZW50RHVyYXRpb24oKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB7XG4gICAgICAgIG1lZGlhLFxuICAgICAgICBtZWRpYVNvdXJjZTogbWVkaWFTb3VyY2UgYXMgTWVkaWFTb3VyY2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWVkaWFTb3VyY2UpIHtcbiAgICAgIC8vIG9uY2UgcmVjZWl2ZWQsIGRvbid0IGxpc3RlbiBhbnltb3JlIHRvIHNvdXJjZW9wZW4gZXZlbnRcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tQZW5kaW5nVHJhY2tzKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xuICAgIHRoaXMubG9nKCdNZWRpYSBzb3VyY2UgY2xvc2VkJyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBfb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgIHRoaXMubG9nKCdNZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgfTtcblxuICBwcml2YXRlIF9vbk1lZGlhRW1wdGllZCA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1lZGlhU3JjLCBfb2JqZWN0VXJsIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYVNyYyAhPT0gX29iamVjdFVybCkge1xuICAgICAgbG9nZ2VyLmVycm9yKFxuICAgICAgICBgTWVkaWEgZWxlbWVudCBzcmMgd2FzIHNldCB3aGlsZSBhdHRhY2hpbmcgTWVkaWFTb3VyY2UgKCR7X29iamVjdFVybH0gPiAke21lZGlhU3JjfSlgLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXQgbWVkaWFTcmMoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBtZWRpYSA9XG4gICAgICAodGhpcy5tZWRpYT8uZmlyc3RDaGlsZCBhcyBIVE1MU291cmNlRWxlbWVudCB8IG51bGwpIHx8IHRoaXMubWVkaWE7XG4gICAgcmV0dXJuIG1lZGlhPy5zcmM7XG4gIH1cblxuICBwcml2YXRlIF9vblNCVXBkYXRlU3RhcnQodHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfb25TQlVwZGF0ZUVuZCh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgaWYgKHRoaXMubWVkaWFTb3VyY2U/LnJlYWR5U3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG9wZXJhdGlvblF1ZXVlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfb25TQlVwZGF0ZUVycm9yKHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUsIGV2ZW50OiBFdmVudCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgYCR7dHlwZX0gU291cmNlQnVmZmVyIGVycm9yLiBNZWRpYVNvdXJjZSByZWFkeVN0YXRlOiAke3RoaXMubWVkaWFTb3VyY2U/LnJlYWR5U3RhdGV9YCxcbiAgICApO1xuICAgIHRoaXMuZXJyb3IoYCR7ZXJyb3J9YCwgZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLFxuICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgIGVycm9yLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgIH0pO1xuICAgIC8vIHVwZGF0ZWVuZCBpcyBhbHdheXMgZmlyZWQgYWZ0ZXIgZXJyb3IsIHNvIHdlJ2xsIGFsbG93IHRoYXQgdG8gc2hpZnQgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIG9mZiBvZiB0aGUgcXVldWVcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLm9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgb3BlcmF0aW9uLm9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgcmVtb3ZlIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIHByaXZhdGUgcmVtb3ZlRXhlY3V0b3IoXG4gICAgdHlwZTogU291cmNlQnVmZmVyTmFtZSxcbiAgICBzdGFydE9mZnNldDogbnVtYmVyLFxuICAgIGVuZE9mZnNldDogbnVtYmVyLFxuICApIHtcbiAgICBjb25zdCB7IG1lZGlhLCBtZWRpYVNvdXJjZSwgb3BlcmF0aW9uUXVldWUsIHNvdXJjZUJ1ZmZlciB9ID0gdGhpcztcbiAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICBpZiAoIW1lZGlhIHx8ICFtZWRpYVNvdXJjZSB8fCAhc2IpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGZyb20gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgLFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvblF1ZXVlLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBOdW1iZXIuaXNGaW5pdGUobWVkaWEuZHVyYXRpb24pXG4gICAgICA/IG1lZGlhLmR1cmF0aW9uXG4gICAgICA6IEluZmluaXR5O1xuICAgIGNvbnN0IG1zRHVyYXRpb24gPSBOdW1iZXIuaXNGaW5pdGUobWVkaWFTb3VyY2UuZHVyYXRpb24pXG4gICAgICA/IG1lZGlhU291cmNlLmR1cmF0aW9uXG4gICAgICA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnRPZmZzZXQpO1xuICAgIGNvbnN0IHJlbW92ZUVuZCA9IE1hdGgubWluKGVuZE9mZnNldCwgbWVkaWFEdXJhdGlvbiwgbXNEdXJhdGlvbik7XG4gICAgaWYgKHJlbW92ZUVuZCA+IHJlbW92ZVN0YXJ0ICYmICghc2IuZW5kaW5nIHx8IHNiLmVuZGVkKSkge1xuICAgICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgUmVtb3ZpbmcgWyR7cmVtb3ZlU3RhcnR9LCR7cmVtb3ZlRW5kfV0gZnJvbSB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXJgLFxuICAgICAgKTtcbiAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3ljbGUgdGhlIHF1ZXVlXG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIHByaXZhdGUgYXBwZW5kRXhlY3V0b3IoZGF0YTogVWludDhBcnJheSwgdHlwZTogU291cmNlQnVmZmVyTmFtZSkge1xuICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFzYikge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdGAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH1cblxuICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gIC8vIHJlc29sdmUsIHRoZSBvblVuYmxvY2tlZCBmdW5jdGlvbiBpcyBleGVjdXRlZC4gRnVuY3Rpb25zIGNhbGxpbmcgdGhpcyBtZXRob2QgZG8gbm90IG5lZWQgdG8gdW5ibG9jayB0aGUgcXVldWVcbiAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgcHJpdmF0ZSBibG9ja0J1ZmZlcnMoXG4gICAgb25VbmJsb2NrZWQ6ICgpID0+IHZvaWQsXG4gICAgYnVmZmVyczogQXJyYXk8U291cmNlQnVmZmVyTmFtZT4gPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCksXG4gICkge1xuICAgIGlmICghYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKCdCbG9ja2luZyBvcGVyYXRpb24gcmVxdWVzdGVkLCBidXQgbm8gU291cmNlQnVmZmVycyBleGlzdCcpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihvblVuYmxvY2tlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgb3BlcmF0aW9uUXVldWUgfSA9IHRoaXM7XG5cbiAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nICR7YnVmZmVyc30gU291cmNlQnVmZmVyYCk7XG4gICAgY29uc3QgYmxvY2tpbmdPcGVyYXRpb25zID0gYnVmZmVycy5tYXAoKHR5cGUpID0+XG4gICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmRCbG9ja2VyKHR5cGUgYXMgU291cmNlQnVmZmVyTmFtZSksXG4gICAgKTtcbiAgICBQcm9taXNlLmFsbChibG9ja2luZ09wZXJhdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVzb2x2ZWQ7IHVuYmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgIG9uVW5ibG9ja2VkKCk7XG4gICAgICBidWZmZXJzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgLy8gT25seSBjeWNsZSB0aGUgcXVldWUgaWYgdGhlIFNCIGlzIG5vdCB1cGRhdGluZy4gVGhlcmUncyBhIGJ1ZyBpbiBDaHJvbWUgd2hpY2ggc2V0cyB0aGUgU0IgdXBkYXRpbmcgZmxhZyB0b1xuICAgICAgICAvLyB0cnVlIHdoZW4gY2hhbmdpbmcgdGhlIE1lZGlhU291cmNlIGR1cmF0aW9uIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NTkzNTkmY2FuPTImcT1tZWRpYXNvdXJjZSUyMGR1cmF0aW9uKVxuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIGEgd29ya2Fyb3VuZCwgaXQncyBwcm9iYWJseSB1c2VmdWwgdG8gaGF2ZSBhcm91bmRcbiAgICAgICAgaWYgKCFzYj8udXBkYXRpbmcpIHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U291cmNlQnVmZmVyVHlwZXMoKTogQXJyYXk8U291cmNlQnVmZmVyTmFtZT4ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUJ1ZmZlcikgYXMgQXJyYXk8U291cmNlQnVmZmVyTmFtZT47XG4gIH1cblxuICBwcml2YXRlIGFkZEJ1ZmZlckxpc3RlbmVyKFxuICAgIHR5cGU6IFNvdXJjZUJ1ZmZlck5hbWUsXG4gICAgZXZlbnQ6IHN0cmluZyxcbiAgICBmbjogRnVuY3Rpb24sXG4gICkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHsgZXZlbnQsIGxpc3RlbmVyIH0pO1xuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlOiBTb3VyY2VCdWZmZXJOYW1lKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgYnVmZmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobC5ldmVudCwgbC5saXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU291cmNlQ2hpbGRyZW4obm9kZTogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3Qgc291cmNlQ2hpbGRyZW4gPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xuICBbXS5zbGljZS5jYWxsKHNvdXJjZUNoaWxkcmVuKS5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKHNvdXJjZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTb3VyY2UobWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQsIHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNlbGYuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gIHNvdXJjZS50eXBlID0gJ3ZpZGVvL21wNCc7XG4gIHNvdXJjZS5zcmMgPSB1cmw7XG4gIG1lZGlhLmFwcGVuZENoaWxkKHNvdXJjZSk7XG59XG4iLCIvKlxuICogY2FwIHN0cmVhbSBsZXZlbCB0byBtZWRpYSBzaXplIGRpbWVuc2lvbiBjb250cm9sbGVyXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7XG4gIE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgQnVmZmVyQ29kZWNzRGF0YSxcbiAgTWVkaWFBdHRhY2hpbmdEYXRhLFxuICBGUFNEcm9wTGV2ZWxDYXBwaW5nRGF0YSxcbiAgTGV2ZWxzVXBkYXRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5cbnR5cGUgUmVzdHJpY3RlZExldmVsID0geyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlcjsgYml0cmF0ZTogbnVtYmVyIH07XG5jbGFzcyBDYXBMZXZlbENvbnRyb2xsZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGF1dG9MZXZlbENhcHBpbmc6IG51bWJlcjtcbiAgcHJpdmF0ZSBmaXJzdExldmVsOiBudW1iZXI7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsO1xuICBwcml2YXRlIHJlc3RyaWN0ZWRMZXZlbHM6IFJlc3RyaWN0ZWRMZXZlbFtdO1xuICBwcml2YXRlIHRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY2xpZW50UmVjdDogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHwgbnVsbDtcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyPzogU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG5cbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyOiBTdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhscykge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLFxuICAgIGRhdGE6IEZQU0Ryb3BMZXZlbENhcHBpbmdEYXRhLFxuICApIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5kcm9wcGVkTGV2ZWxdO1xuICAgIGlmICh0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxldmVsLndpZHRoLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hpbmdEYXRhLFxuICApIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIGlmICh0aGlzLnRpbWVyICYmIHRoaXMuaGxzLmxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1hbmlmZXN0UGFyc2VkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gZGF0YS5maXJzdExldmVsO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIFN0YXJ0IGNhcHBpbmcgaW1tZWRpYXRlbHkgaWYgdGhlIG1hbmlmZXN0IGhhcyBzaWduYWxlZCB2aWRlbyBjb2RlY3NcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsc1VwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTFNfVVBEQVRFRCxcbiAgICBkYXRhOiBMZXZlbHNVcGRhdGVkRGF0YSxcbiAgKSB7XG4gICAgaWYgKHRoaXMudGltZXIgJiYgTnVtYmVyLmlzRmluaXRlKHRoaXMuYXV0b0xldmVsQ2FwcGluZykpIHtcbiAgICAgIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXG4gIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICBwcm90ZWN0ZWQgb25CdWZmZXJDb2RlY3MoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfQ09ERUNTLFxuICAgIGRhdGE6IEJ1ZmZlckNvZGVjc0RhdGEsXG4gICkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmIChobHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIGRhdGEudmlkZW8pIHtcbiAgICAgIC8vIElmIHRoZSBtYW5pZmVzdCBkaWQgbm90IHNpZ25hbCBhIHZpZGVvIGNvZGVjIGNhcHBpbmcgaGFzIGJlZW4gZGVmZXJyZWQgdW50aWwgd2UncmUgY2VydGFpbiB2aWRlbyBpcyBwcmVzZW50XG4gICAgICB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgfVxuXG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhSGVpZ2h0IDw9IDAgfHwgdGhpcy5tZWRpYVdpZHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGNvbnN0IG1heExldmVsID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChtYXhMZXZlbCAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgIGBTZXR0aW5nIGF1dG9MZXZlbENhcHBpbmcgdG8gJHttYXhMZXZlbH06ICR7bGV2ZWxzW21heExldmVsXS5oZWlnaHR9cEAke2xldmVsc1ttYXhMZXZlbF0uYml0cmF0ZX0gZm9yIG1lZGlhICR7dGhpcy5tZWRpYVdpZHRofXgke3RoaXMubWVkaWFIZWlnaHR9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gbWF4TGV2ZWw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZyAmJlxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlclxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICovXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihcbiAgICAgIChsZXZlbCwgaW5kZXgpID0+IHRoaXMuaXNMZXZlbEFsbG93ZWQobGV2ZWwpICYmIGluZGV4IDw9IGNhcExldmVsSW5kZXgsXG4gICAgKTtcblxuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgcmV0dXJuIENhcExldmVsQ29udHJvbGxlci5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplKFxuICAgICAgdmFsaWRMZXZlbHMsXG4gICAgICB0aGlzLm1lZGlhV2lkdGgsXG4gICAgICB0aGlzLm1lZGlhSGVpZ2h0LFxuICAgICk7XG4gIH1cblxuICBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cblxuICBzdG9wQ2FwcGluZygpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGltZW5zaW9ucygpOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0ge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcblxuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID1cbiAgICAgICAgICBjbGllbnRSZWN0LnJpZ2h0IC0gY2xpZW50UmVjdC5sZWZ0IHx8IG1lZGlhLndpZHRoIHx8IDA7XG4gICAgICAgIGJvdW5kc1JlY3QuaGVpZ2h0ID1cbiAgICAgICAgICBjbGllbnRSZWN0LmJvdHRvbSAtIGNsaWVudFJlY3QudG9wIHx8IG1lZGlhLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlY3QgPSBib3VuZHNSZWN0O1xuICAgIHJldHVybiBib3VuZHNSZWN0O1xuICB9XG5cbiAgZ2V0IG1lZGlhV2lkdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuXG4gIGdldCBtZWRpYUhlaWdodCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuXG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKTogbnVtYmVyIHtcbiAgICBsZXQgcGl4ZWxSYXRpbyA9IDE7XG4gICAgaWYgKCF0aGlzLmhscy5jb25maWcuaWdub3JlRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9IHNlbGYuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIHByaXZhdGUgaXNMZXZlbEFsbG93ZWQobGV2ZWw6IExldmVsKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVzdHJpY3RlZExldmVscyA9IHRoaXMucmVzdHJpY3RlZExldmVscztcbiAgICByZXR1cm4gIXJlc3RyaWN0ZWRMZXZlbHMuc29tZSgocmVzdHJpY3RlZExldmVsKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBsZXZlbC5iaXRyYXRlID09PSByZXN0cmljdGVkTGV2ZWwuYml0cmF0ZSAmJlxuICAgICAgICBsZXZlbC53aWR0aCA9PT0gcmVzdHJpY3RlZExldmVsLndpZHRoICYmXG4gICAgICAgIGxldmVsLmhlaWdodCA9PT0gcmVzdHJpY3RlZExldmVsLmhlaWdodFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKFxuICAgIGxldmVsczogQXJyYXk8TGV2ZWw+LFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICk6IG51bWJlciB7XG4gICAgaWYgKCFsZXZlbHM/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kd2lkdGggPSAoXG4gICAgICBjdXJMZXZlbDogTGV2ZWwsXG4gICAgICBuZXh0TGV2ZWw6IExldmVsIHwgdW5kZWZpbmVkLFxuICAgICkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGN1ckxldmVsLndpZHRoICE9PSBuZXh0TGV2ZWwud2lkdGggfHxcbiAgICAgICAgY3VyTGV2ZWwuaGVpZ2h0ICE9PSBuZXh0TGV2ZWwuaGVpZ2h0XG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBydW4gdGhyb3VnaCB0aGUgbG9vcCB3aXRob3V0IGJyZWFraW5nLCB0aGUgbWVkaWEncyBkaW1lbnNpb25zIGFyZSBncmVhdGVyIHRoYW4gZXZlcnkgbGV2ZWwsIHNvIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbWF4IGxldmVsXG4gICAgbGV0IG1heExldmVsSW5kZXggPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICAvLyBQcmV2ZW50IGNoYW5nZXMgaW4gYXNwZWN0LXJhdGlvIGZyb20gY2F1c2luZyBjYXBwaW5nIHRvIHRvZ2dsZSBiYWNrIGFuZCBmb3J0aFxuICAgIGNvbnN0IHNxdWFyZVNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICBpZiAoXG4gICAgICAgIChsZXZlbC53aWR0aCA+PSBzcXVhcmVTaXplIHx8IGxldmVsLmhlaWdodCA+PSBzcXVhcmVTaXplKSAmJlxuICAgICAgICBhdEdyZWF0ZXN0QmFuZHdpZHRoKGxldmVsLCBsZXZlbHNbaSArIDFdKVxuICAgICAgKSB7XG4gICAgICAgIG1heExldmVsSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXBMZXZlbENvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgTWVkaWFBdHRhY2hpbmdEYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCBTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vc3RyZWFtLWNvbnRyb2xsZXInO1xuXG5jbGFzcyBGUFNDb250cm9sbGVyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBobHM6IEhscztcbiAgcHJpdmF0ZSBpc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdGltZXI/OiBudW1iZXI7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBsYXN0VGltZTogYW55O1xuICBwcml2YXRlIGxhc3REcm9wcGVkRnJhbWVzOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGxhc3REZWNvZGVkRnJhbWVzOiBudW1iZXIgPSAwO1xuICAvLyBzdHJlYW0gY29udHJvbGxlciBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgZGVwZW5kZW5jeSFcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyITogU3RyZWFtQ29udHJvbGxlcjtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHVibGljIHNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcjogU3RyZWFtQ29udHJvbGxlcikge1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhQXR0YWNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNISU5HLFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChjb25maWcuY2FwTGV2ZWxPbkZQU0Ryb3ApIHtcbiAgICAgIGNvbnN0IG1lZGlhID1cbiAgICAgICAgZGF0YS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmIHR5cGVvZiBtZWRpYS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbChcbiAgICAgICAgdGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksXG4gICAgICAgIGNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tGUFMoXG4gICAgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQsXG4gICAgZGVjb2RlZEZyYW1lczogbnVtYmVyLFxuICAgIGRyb3BwZWRGcmFtZXM6IG51bWJlcixcbiAgKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZGVjb2RlZEZyYW1lcykge1xuICAgICAgaWYgKHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBlcmlvZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGltZTtcbiAgICAgICAgY29uc3QgY3VycmVudERyb3BwZWQgPSBkcm9wcGVkRnJhbWVzIC0gdGhpcy5sYXN0RHJvcHBlZEZyYW1lcztcbiAgICAgICAgY29uc3QgY3VycmVudERlY29kZWQgPSBkZWNvZGVkRnJhbWVzIC0gdGhpcy5sYXN0RGVjb2RlZEZyYW1lcztcbiAgICAgICAgY29uc3QgZHJvcHBlZEZQUyA9ICgxMDAwICogY3VycmVudERyb3BwZWQpIC8gY3VycmVudFBlcmlvZDtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUCwge1xuICAgICAgICAgIGN1cnJlbnREcm9wcGVkOiBjdXJyZW50RHJvcHBlZCxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZDogY3VycmVudERlY29kZWQsXG4gICAgICAgICAgdG90YWxEcm9wcGVkRnJhbWVzOiBkcm9wcGVkRnJhbWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRyb3BwZWRGUFMgPiAwKSB7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnY2hlY2tGUFMgOiBkcm9wcGVkRlBTL2RlY29kZWRGUFM6JyArIGRyb3BwZWRGUFMvKDEwMDAgKiBjdXJyZW50RGVjb2RlZCAvIGN1cnJlbnRQZXJpb2QpKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXJyZW50RHJvcHBlZCA+XG4gICAgICAgICAgICBobHMuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkICogY3VycmVudERlY29kZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSBobHMuY3VycmVudExldmVsO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID4gMCAmJlxuICAgICAgICAgICAgICAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPj0gY3VycmVudExldmVsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGN1cnJlbnRMZXZlbCAtIDE7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB7XG4gICAgICAgICAgICAgICAgbGV2ZWw6IGN1cnJlbnRMZXZlbCxcbiAgICAgICAgICAgICAgICBkcm9wcGVkTGV2ZWw6IGhscy5jdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBobHMuYXV0b0xldmVsQ2FwcGluZyA9IGN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IGRyb3BwZWRGcmFtZXM7XG4gICAgICB0aGlzLmxhc3REZWNvZGVkRnJhbWVzID0gZGVjb2RlZEZyYW1lcztcbiAgICB9XG4gIH1cblxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IHZpZGVvID0gdGhpcy5tZWRpYTtcbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUpIHtcbiAgICAgICAgY29uc3QgdmlkZW9QbGF5YmFja1F1YWxpdHkgPSB2aWRlby5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKFxuICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsXG4gICAgICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuZHJvcHBlZFZpZGVvRnJhbWVzLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSFRNTFZpZGVvRWxlbWVudCBkb2Vzbid0IGluY2x1ZGUgdGhlIHdlYmtpdCB0eXBlc1xuICAgICAgICB0aGlzLmNoZWNrRlBTKFxuICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICh2aWRlbyBhcyBhbnkpLndlYmtpdERlY29kZWRGcmFtZUNvdW50IGFzIG51bWJlcixcbiAgICAgICAgICAodmlkZW8gYXMgYW55KS53ZWJraXREcm9wcGVkRnJhbWVDb3VudCBhcyBudW1iZXIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZQU0NvbnRyb2xsZXI7XG4iLCJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgTGV2ZWwgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgeyByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzIH0gZnJvbSAnLi4vdXRpbHMvbGV2ZWwtaGVscGVyJztcbmltcG9ydCB7IEF0dHJMaXN0IH0gZnJvbSAnLi4vdXRpbHMvYXR0ci1saXN0JztcbmltcG9ydCB7IEVycm9yQWN0aW9uRmxhZ3MsIE5ldHdvcmtFcnJvckFjdGlvbiB9IGZyb20gJy4vZXJyb3ItY29udHJvbGxlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtcbiAgUGxheWxpc3RDb250ZXh0VHlwZSxcbiAgdHlwZSBMb2FkZXIsXG4gIHR5cGUgTG9hZGVyQ2FsbGJhY2tzLFxuICB0eXBlIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIHR5cGUgTG9hZGVyQ29udGV4dCxcbiAgdHlwZSBMb2FkZXJSZXNwb25zZSxcbiAgdHlwZSBMb2FkZXJTdGF0cyxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIEhscyBmcm9tICcuLi9obHMnO1xuaW1wb3J0IHR5cGUgeyBOZXR3b3JrQ29tcG9uZW50QVBJIH0gZnJvbSAnLi4vdHlwZXMvY29tcG9uZW50LWFwaSc7XG5pbXBvcnQgdHlwZSB7XG4gIFN0ZWVyaW5nTWFuaWZlc3RMb2FkZWREYXRhLFxuICBFcnJvckRhdGEsXG4gIE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgTWFuaWZlc3RQYXJzZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmltcG9ydCB0eXBlIHsgTWVkaWFBdHRyaWJ1dGVzLCBNZWRpYVBsYXlsaXN0IH0gZnJvbSAnLi4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuXG5leHBvcnQgdHlwZSBTdGVlcmluZ01hbmlmZXN0ID0ge1xuICBWRVJTSU9OOiAxO1xuICBUVEw6IG51bWJlcjtcbiAgJ1JFTE9BRC1VUkknPzogc3RyaW5nO1xuICAnUEFUSFdBWS1QUklPUklUWSc6IHN0cmluZ1tdO1xuICAnUEFUSFdBWS1DTE9ORVMnPzogUGF0aHdheUNsb25lW107XG59O1xuXG5leHBvcnQgdHlwZSBQYXRod2F5Q2xvbmUgPSB7XG4gICdCQVNFLUlEJzogc3RyaW5nO1xuICBJRDogc3RyaW5nO1xuICAnVVJJLVJFUExBQ0VNRU5UJzogVXJpUmVwbGFjZW1lbnQ7XG59O1xuXG5leHBvcnQgdHlwZSBVcmlSZXBsYWNlbWVudCA9IHtcbiAgSE9TVD86IHN0cmluZztcbiAgUEFSQU1TPzogeyBbcXVlcnlQYXJhbWV0ZXI6IHN0cmluZ106IHN0cmluZyB9O1xuICAnUEVSLVZBUklBTlQtVVJJUyc/OiB7IFtzdGFibGVWYXJpYW50SWQ6IHN0cmluZ106IHN0cmluZyB9O1xuICAnUEVSLVJFTkRJVElPTi1VUklTJz86IHsgW3N0YWJsZVJlbmRpdGlvbklkOiBzdHJpbmddOiBzdHJpbmcgfTtcbn07XG5cbmNvbnN0IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUyA9IDMwMDAwMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBpbXBsZW1lbnRzIE5ldHdvcmtDb21wb25lbnRBUEkge1xuICBwcml2YXRlIHJlYWRvbmx5IGhsczogSGxzO1xuICBwcml2YXRlIGxvZzogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcml2YXRlIGxvYWRlcjogTG9hZGVyPExvYWRlckNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdXJpOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYXRod2F5SWQ6IHN0cmluZyA9ICcuJztcbiAgcHJpdmF0ZSBwYXRod2F5UHJpb3JpdHk6IHN0cmluZ1tdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdGltZVRvTG9hZDogbnVtYmVyID0gMzAwO1xuICBwcml2YXRlIHJlbG9hZFRpbWVyOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSB1cGRhdGVkOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBlbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBsZXZlbHM6IExldmVsW10gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBhdWRpb1RyYWNrczogTWVkaWFQbGF5bGlzdFtdIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3VidGl0bGVUcmFja3M6IE1lZGlhUGxheWxpc3RbXSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBlbmFsaXplZFBhdGh3YXlzOiB7IFtwYXRod2F5SWQ6IHN0cmluZ106IG51bWJlciB9ID0ge307XG5cbiAgY29uc3RydWN0b3IoaGxzOiBIbHMpIHtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmxvZyA9IGxvZ2dlci5sb2cuYmluZChsb2dnZXIsIGBbY29udGVudC1zdGVlcmluZ106YCk7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLnVyaSkge1xuICAgICAgaWYgKHRoaXMudXBkYXRlZCkge1xuICAgICAgICBjb25zdCB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy51cGRhdGVkKTtcbiAgICAgICAgaWYgKHR0bCA+IDApIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSwgdHRsKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFN0ZWVyaW5nTWFuaWZlc3QodGhpcy51cmkpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB9XG5cbiAgY2xlYXJUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlbG9hZFRpbWVyICE9PSAtMSkge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZWxvYWRUaW1lcik7XG4gICAgICB0aGlzLnJlbG9hZFRpbWVyID0gLTE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuYXVkaW9UcmFja3MgPSB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgfVxuXG4gIHJlbW92ZUxldmVsKGxldmVsVG9SZW1vdmU6IExldmVsKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKGxldmVscykge1xuICAgICAgdGhpcy5sZXZlbHMgPSBsZXZlbHMuZmlsdGVyKChsZXZlbCkgPT4gbGV2ZWwgIT09IGxldmVsVG9SZW1vdmUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy50aW1lVG9Mb2FkID0gMzAwO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BREVELFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgeyBjb250ZW50U3RlZXJpbmcgfSA9IGRhdGE7XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhdGh3YXlJZCA9IGNvbnRlbnRTdGVlcmluZy5wYXRod2F5SWQ7XG4gICAgdGhpcy51cmkgPSBjb250ZW50U3RlZXJpbmcudXJpO1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0UGFyc2VkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgKSB7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3M7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cblxuICBwcml2YXRlIG9uRXJyb3IoZXZlbnQ6IEV2ZW50cy5FUlJPUiwgZGF0YTogRXJyb3JEYXRhKSB7XG4gICAgY29uc3QgeyBlcnJvckFjdGlvbiB9ID0gZGF0YTtcbiAgICBpZiAoXG4gICAgICBlcnJvckFjdGlvbj8uYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCAmJlxuICAgICAgZXJyb3JBY3Rpb24uZmxhZ3MgPT09IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3RcbiAgICApIHtcbiAgICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgICAgbGV0IHBhdGh3YXlQcmlvcml0eSA9IHRoaXMucGF0aHdheVByaW9yaXR5O1xuICAgICAgbGV0IGVycm9yUGF0aHdheSA9IHRoaXMucGF0aHdheUlkO1xuICAgICAgaWYgKGRhdGEuY29udGV4dCkge1xuICAgICAgICBjb25zdCB7IGdyb3VwSWQsIHBhdGh3YXlJZCwgdHlwZSB9ID0gZGF0YS5jb250ZXh0O1xuICAgICAgICBpZiAoZ3JvdXBJZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgICBlcnJvclBhdGh3YXkgPSB0aGlzLmdldFBhdGh3YXlGb3JHcm91cElkKGdyb3VwSWQsIHR5cGUsIGVycm9yUGF0aHdheSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aHdheUlkKSB7XG4gICAgICAgICAgZXJyb3JQYXRod2F5ID0gcGF0aHdheUlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIShlcnJvclBhdGh3YXkgaW4gdGhpcy5wZW5hbGl6ZWRQYXRod2F5cykpIHtcbiAgICAgICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5c1tlcnJvclBhdGh3YXldID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgICBpZiAoIXBhdGh3YXlQcmlvcml0eSAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gSWYgUEFUSFdBWS1QUklPUklUWSB3YXMgbm90IHByb3ZpZGVkLCBsaXN0IHBhdGh3YXlzIGZvciBlcnJvciBoYW5kbGluZ1xuICAgICAgICBwYXRod2F5UHJpb3JpdHkgPSBsZXZlbHMucmVkdWNlKChwYXRod2F5cywgbGV2ZWwpID0+IHtcbiAgICAgICAgICBpZiAocGF0aHdheXMuaW5kZXhPZihsZXZlbC5wYXRod2F5SWQpID09PSAtMSkge1xuICAgICAgICAgICAgcGF0aHdheXMucHVzaChsZXZlbC5wYXRod2F5SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGF0aHdheXM7XG4gICAgICAgIH0sIFtdIGFzIHN0cmluZ1tdKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkgJiYgcGF0aHdheVByaW9yaXR5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkocGF0aHdheVByaW9yaXR5KTtcbiAgICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0aGlzLnBhdGh3YXlJZCAhPT0gZXJyb3JQYXRod2F5O1xuICAgICAgfVxuICAgICAgaWYgKCFlcnJvckFjdGlvbi5yZXNvbHZlZCkge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgQ291bGQgbm90IHJlc29sdmUgJHtkYXRhLmRldGFpbHN9IChcIiR7XG4gICAgICAgICAgICBkYXRhLmVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9XCIpIHdpdGggY29udGVudC1zdGVlcmluZyBmb3IgUGF0aHdheTogJHtlcnJvclBhdGh3YXl9IGxldmVsczogJHtcbiAgICAgICAgICAgIGxldmVscyA/IGxldmVscy5sZW5ndGggOiBsZXZlbHNcbiAgICAgICAgICB9IHByaW9yaXRpZXM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBwYXRod2F5UHJpb3JpdHksXG4gICAgICAgICAgKX0gcGVuYWxpemVkOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGVuYWxpemVkUGF0aHdheXMpfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZpbHRlclBhcnNlZExldmVscyhsZXZlbHM6IExldmVsW10pOiBMZXZlbFtdIHtcbiAgICAvLyBGaWx0ZXIgbGV2ZWxzIHRvIG9ubHkgaW5jbHVkZSB0aG9zZSB0aGF0IGFyZSBpbiB0aGUgaW5pdGlhbCBwYXRod2F5XG4gICAgdGhpcy5sZXZlbHMgPSBsZXZlbHM7XG4gICAgbGV0IHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkodGhpcy5wYXRod2F5SWQpO1xuICAgIGlmIChwYXRod2F5TGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgcGF0aHdheUlkID0gbGV2ZWxzWzBdLnBhdGh3YXlJZDtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgTm8gbGV2ZWxzIGZvdW5kIGluIFBhdGh3YXkgJHt0aGlzLnBhdGh3YXlJZH0uIFNldHRpbmcgaW5pdGlhbCBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgLFxuICAgICAgKTtcbiAgICAgIHBhdGh3YXlMZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgIH1cbiAgICBpZiAocGF0aHdheUxldmVscy5sZW5ndGggIT09IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgRm91bmQgJHtwYXRod2F5TGV2ZWxzLmxlbmd0aH0vJHtsZXZlbHMubGVuZ3RofSBsZXZlbHMgaW4gUGF0aHdheSBcIiR7dGhpcy5wYXRod2F5SWR9XCJgLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXRod2F5TGV2ZWxzO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZDogc3RyaW5nKTogTGV2ZWxbXSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVscy5maWx0ZXIoKGxldmVsKSA9PiBwYXRod2F5SWQgPT09IGxldmVsLnBhdGh3YXlJZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHk6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5wYXRod2F5UHJpb3JpdHkgPSBwYXRod2F5UHJpb3JpdHk7XG4gICAgbGV0IGxldmVsczogTGV2ZWxbXSB8IHVuZGVmaW5lZDtcblxuICAgIC8vIEV2YWx1YXRlIGlmIHdlIHNob3VsZCByZW1vdmUgdGhlIHBhdGh3YXkgZnJvbSB0aGUgcGVuYWxpemVkIGxpc3RcbiAgICBjb25zdCBwZW5hbGl6ZWRQYXRod2F5cyA9IHRoaXMucGVuYWxpemVkUGF0aHdheXM7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgT2JqZWN0LmtleXMocGVuYWxpemVkUGF0aHdheXMpLmZvckVhY2goKHBhdGh3YXlJZCkgPT4ge1xuICAgICAgaWYgKG5vdyAtIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0gPiBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMpIHtcbiAgICAgICAgZGVsZXRlIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRod2F5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgIGlmIChwYXRod2F5SWQgaW4gcGVuYWxpemVkUGF0aHdheXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheUlkID09PSB0aGlzLnBhdGh3YXlJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGV2ZWw6IExldmVsID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgbGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICAgIHRoaXMucGF0aHdheUlkID0gcGF0aHdheUlkO1xuICAgICAgICByZWFzc2lnbkZyYWdtZW50TGV2ZWxJbmRleGVzKGxldmVscyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7IGxldmVscyB9KTtcbiAgICAgICAgLy8gU2V0IExldmVsQ29udHJvbGxlcidzIGxldmVsIHRvIHRyaWdnZXIgTEVWRUxfU1dJVENISU5HIHdoaWNoIGxvYWRzIHBsYXlsaXN0IGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBsZXZlbEFmdGVyQ2hhbmdlID0gdGhpcy5obHMubGV2ZWxzW3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICBpZiAoc2VsZWN0ZWRMZXZlbCAmJiBsZXZlbEFmdGVyQ2hhbmdlICYmIHRoaXMubGV2ZWxzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGV2ZWxBZnRlckNoYW5nZS5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAhPT1cbiAgICAgICAgICAgICAgc2VsZWN0ZWRMZXZlbC5hdHRyc1snU1RBQkxFLVZBUklBTlQtSUQnXSAmJlxuICAgICAgICAgICAgbGV2ZWxBZnRlckNoYW5nZS5iaXRyYXRlICE9PSBzZWxlY3RlZExldmVsLmJpdHJhdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICBgVW5zdGFibGUgUGF0aHdheXMgY2hhbmdlIGZyb20gYml0cmF0ZSAke3NlbGVjdGVkTGV2ZWwuYml0cmF0ZX0gdG8gJHtsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGV9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGF0aHdheUZvckdyb3VwSWQoXG4gICAgZ3JvdXBJZDogc3RyaW5nLFxuICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUsXG4gICAgZGVmYXVsdFBhdGh3YXk6IHN0cmluZyxcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkoZGVmYXVsdFBhdGh3YXkpLmNvbmNhdChcbiAgICAgIHRoaXMubGV2ZWxzIHx8IFtdLFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiZcbiAgICAgICAgICBsZXZlbHNbaV0uaGFzQXVkaW9Hcm91cChncm91cElkKSkgfHxcbiAgICAgICAgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0sgJiZcbiAgICAgICAgICBsZXZlbHNbaV0uaGFzU3VidGl0bGVHcm91cChncm91cElkKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbGV2ZWxzW2ldLnBhdGh3YXlJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRQYXRod2F5O1xuICB9XG5cbiAgcHJpdmF0ZSBjbG9uZVBhdGh3YXlzKHBhdGh3YXlDbG9uZXM6IFBhdGh3YXlDbG9uZVtdKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cENsb25lTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgY29uc3Qgc3VidGl0bGVHcm91cENsb25lTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgcGF0aHdheUNsb25lcy5mb3JFYWNoKChwYXRod2F5Q2xvbmUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgSUQ6IGNsb25lSWQsXG4gICAgICAgICdCQVNFLUlEJzogYmFzZUlkLFxuICAgICAgICAnVVJJLVJFUExBQ0VNRU5UJzogdXJpUmVwbGFjZW1lbnQsXG4gICAgICB9ID0gcGF0aHdheUNsb25lO1xuICAgICAgaWYgKGxldmVscy5zb21lKChsZXZlbCkgPT4gbGV2ZWwucGF0aHdheUlkID09PSBjbG9uZUlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjbG9uZWRWYXJpYW50cyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShiYXNlSWQpLm1hcChcbiAgICAgICAgKGJhc2VMZXZlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYmFzZUxldmVsLmF0dHJzKTtcbiAgICAgICAgICBhdHRyaWJ1dGVzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgICAgIGNvbnN0IGNsb25lZEF1ZGlvR3JvdXBJZDogc3RyaW5nIHwgdW5kZWZpbmVkID1cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gJiYgYCR7YXR0cmlidXRlcy5BVURJT31fY2xvbmVfJHtjbG9uZUlkfWA7XG4gICAgICAgICAgY29uc3QgY2xvbmVkU3VidGl0bGVHcm91cElkOiBzdHJpbmcgfCB1bmRlZmluZWQgPVxuICAgICAgICAgICAgYXR0cmlidXRlcy5TVUJUSVRMRVMgJiYgYCR7YXR0cmlidXRlcy5TVUJUSVRMRVN9X2Nsb25lXyR7Y2xvbmVJZH1gO1xuICAgICAgICAgIGlmIChjbG9uZWRBdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICAgIGF1ZGlvR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLkFVRElPXSA9IGNsb25lZEF1ZGlvR3JvdXBJZDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbG9uZWRTdWJ0aXRsZUdyb3VwSWQpIHtcbiAgICAgICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLlNVQlRJVExFU10gPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLlNVQlRJVExFUyA9IGNsb25lZFN1YnRpdGxlR3JvdXBJZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdXJsID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KFxuICAgICAgICAgICAgYmFzZUxldmVsLnVyaSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10sXG4gICAgICAgICAgICAnUEVSLVZBUklBTlQtVVJJUycsXG4gICAgICAgICAgICB1cmlSZXBsYWNlbWVudCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGNsb25lZExldmVsID0gbmV3IExldmVsKHtcbiAgICAgICAgICAgIGF0dHJzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXVkaW9Db2RlYzogYmFzZUxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICBiaXRyYXRlOiBiYXNlTGV2ZWwuYml0cmF0ZSxcbiAgICAgICAgICAgIGhlaWdodDogYmFzZUxldmVsLmhlaWdodCxcbiAgICAgICAgICAgIG5hbWU6IGJhc2VMZXZlbC5uYW1lLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdmlkZW9Db2RlYzogYmFzZUxldmVsLnZpZGVvQ29kZWMsXG4gICAgICAgICAgICB3aWR0aDogYmFzZUxldmVsLndpZHRoLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChiYXNlTGV2ZWwuYXVkaW9Hcm91cHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmFzZUxldmVsLmF1ZGlvR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNsb25lZExldmVsLmFkZEdyb3VwSWQoXG4gICAgICAgICAgICAgICAgJ2F1ZGlvJyxcbiAgICAgICAgICAgICAgICBgJHtiYXNlTGV2ZWwuYXVkaW9Hcm91cHNbaV19X2Nsb25lXyR7Y2xvbmVJZH1gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmFzZUxldmVsLnN1YnRpdGxlR3JvdXBzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjbG9uZWRMZXZlbC5hZGRHcm91cElkKFxuICAgICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBgJHtiYXNlTGV2ZWwuc3VidGl0bGVHcm91cHNbaV19X2Nsb25lXyR7Y2xvbmVJZH1gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2xvbmVkTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgICAgbGV2ZWxzLnB1c2goLi4uY2xvbmVkVmFyaWFudHMpO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHMoXG4gICAgICAgIHRoaXMuYXVkaW9UcmFja3MsXG4gICAgICAgIGF1ZGlvR3JvdXBDbG9uZU1hcCxcbiAgICAgICAgdXJpUmVwbGFjZW1lbnQsXG4gICAgICAgIGNsb25lSWQsXG4gICAgICApO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHMoXG4gICAgICAgIHRoaXMuc3VidGl0bGVUcmFja3MsXG4gICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcCxcbiAgICAgICAgdXJpUmVwbGFjZW1lbnQsXG4gICAgICAgIGNsb25lSWQsXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkU3RlZXJpbmdNYW5pZmVzdCh1cmk6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBMb2FkZXIgPSBjb25maWcubG9hZGVyO1xuICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlciA9IG5ldyBMb2FkZXIoY29uZmlnKSBhcyBMb2FkZXI8TG9hZGVyQ29udGV4dD47XG5cbiAgICBsZXQgdXJsOiBVUkw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgVVJJOiAke3VyaX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgY29uc3QgdGhyb3VnaHB1dCA9XG4gICAgICAgICh0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSB8fCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfcGF0aHdheScsIHRoaXMucGF0aHdheUlkKTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3Rocm91Z2hwdXQnLCAnJyArIHRocm91Z2hwdXQpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0OiBMb2FkZXJDb250ZXh0ID0ge1xuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB1cmw6IHVybC5ocmVmLFxuICAgIH07XG5cbiAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgY29uc3QgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5OiBSZXRyeUNvbmZpZyB8IFJlY29yZDxzdHJpbmcsIHZvaWQ+ID1cbiAgICAgIGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwLFxuICAgIH07XG5cbiAgICBjb25zdCBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxMb2FkZXJDb250ZXh0PiA9IHtcbiAgICAgIG9uU3VjY2VzczogKFxuICAgICAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICAgICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICAgICkgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIHN0ZWVyaW5nIG1hbmlmZXN0OiBcIiR7dXJsfVwiYCk7XG4gICAgICAgIGNvbnN0IHN0ZWVyaW5nRGF0YSA9IHJlc3BvbnNlLmRhdGEgYXMgU3RlZXJpbmdNYW5pZmVzdDtcbiAgICAgICAgaWYgKHN0ZWVyaW5nRGF0YS5WRVJTSU9OICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIFZFUlNJT04gJHtzdGVlcmluZ0RhdGEuVkVSU0lPTn0gbm90IHN1cHBvcnRlZCFgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMudGltZVRvTG9hZCA9IHN0ZWVyaW5nRGF0YS5UVEw7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAnUkVMT0FELVVSSSc6IHJlbG9hZFVyaSxcbiAgICAgICAgICAnUEFUSFdBWS1DTE9ORVMnOiBwYXRod2F5Q2xvbmVzLFxuICAgICAgICAgICdQQVRIV0FZLVBSSU9SSVRZJzogcGF0aHdheVByaW9yaXR5LFxuICAgICAgICB9ID0gc3RlZXJpbmdEYXRhO1xuICAgICAgICBpZiAocmVsb2FkVXJpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXJpID0gbmV3IHNlbGYuVVJMKHJlbG9hZFVyaSwgdXJsKS5ocmVmO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFJFTE9BRC1VUkk6ICR7cmVsb2FkVXJpfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCk7XG4gICAgICAgIGlmIChwYXRod2F5Q2xvbmVzKSB7XG4gICAgICAgICAgdGhpcy5jbG9uZVBhdGh3YXlzKHBhdGh3YXlDbG9uZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGVkU3RlZXJpbmdEYXRhOiBTdGVlcmluZ01hbmlmZXN0TG9hZGVkRGF0YSA9IHtcbiAgICAgICAgICBzdGVlcmluZ01hbmlmZXN0OiBzdGVlcmluZ0RhdGEsXG4gICAgICAgICAgdXJsOiB1cmwudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1RFRVJJTkdfTUFOSUZFU1RfTE9BREVELCBsb2FkZWRTdGVlcmluZ0RhdGEpO1xuXG4gICAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvbkVycm9yOiAoXG4gICAgICAgIGVycm9yOiB7IGNvZGU6IG51bWJlcjsgdGV4dDogc3RyaW5nIH0sXG4gICAgICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICAgICkgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgRXJyb3IgbG9hZGluZyBzdGVlcmluZyBtYW5pZmVzdDogJHtlcnJvci5jb2RlfSAke2Vycm9yLnRleHR9ICgke2NvbnRleHQudXJsfSlgLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSA0MTApIHtcbiAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gbm8gbG9uZ2VyIGF2YWlsYWJsZWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHRsID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMDtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQyOSkge1xuICAgICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVyPy5nZXRSZXNwb25zZUhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IGxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignUmV0cnktQWZ0ZXInKTtcbiAgICAgICAgICAgIGlmIChyZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgIHR0bCA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtjb250ZXh0LnVybH0gcmF0ZSBsaW1pdGVkYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHRoaXMudXJpIHx8IGNvbnRleHQudXJsLCB0dGwpO1xuICAgICAgfSxcblxuICAgICAgb25UaW1lb3V0OiAoXG4gICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICAgICAgY29udGV4dDogTG9hZGVyQ29udGV4dCxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICAgICkgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgVGltZW91dCBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0ICgke2NvbnRleHQudXJsfSlgKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgdGhpcy5sb2coYFJlcXVlc3Rpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6ICR7dXJsfWApO1xuICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgbG9hZGVyQ29uZmlnLCBjYWxsYmFja3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVJlZnJlc2godXJpOiBzdHJpbmcsIHR0bE1zOiBudW1iZXIgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwKSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB0aGlzLnJlbG9hZFRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5obHM/Lm1lZGlhO1xuICAgICAgaWYgKG1lZGlhICYmICFtZWRpYS5lbmRlZCkge1xuICAgICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHVyaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKHVyaSwgdGhpcy50aW1lVG9Mb2FkICogMTAwMCk7XG4gICAgfSwgdHRsTXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lUmVuZGl0aW9uR3JvdXBzKFxuICB0cmFja3M6IE1lZGlhUGxheWxpc3RbXSB8IG51bGwsXG4gIGdyb3VwQ2xvbmVNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXG4gIHVyaVJlcGxhY2VtZW50OiBVcmlSZXBsYWNlbWVudCxcbiAgY2xvbmVJZDogc3RyaW5nLFxuKSB7XG4gIGlmICghdHJhY2tzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5rZXlzKGdyb3VwQ2xvbmVNYXApLmZvckVhY2goKGF1ZGlvR3JvdXBJZCkgPT4ge1xuICAgIGNvbnN0IGNsb25lZFRyYWNrcyA9IHRyYWNrc1xuICAgICAgLmZpbHRlcigodHJhY2spID0+IHRyYWNrLmdyb3VwSWQgPT09IGF1ZGlvR3JvdXBJZClcbiAgICAgIC5tYXAoKHRyYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb25lZFRyYWNrID0gT2JqZWN0LmFzc2lnbih7fSwgdHJhY2spO1xuICAgICAgICBjbG9uZWRUcmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICBjbG9uZWRUcmFjay5hdHRycyA9IG5ldyBBdHRyTGlzdChjbG9uZWRUcmFjay5hdHRycykgYXMgTWVkaWFBdHRyaWJ1dGVzO1xuICAgICAgICBjbG9uZWRUcmFjay51cmwgPSBjbG9uZWRUcmFjay5hdHRycy5VUkkgPSBwZXJmb3JtVXJpUmVwbGFjZW1lbnQoXG4gICAgICAgICAgdHJhY2sudXJsLFxuICAgICAgICAgIHRyYWNrLmF0dHJzWydTVEFCTEUtUkVORElUSU9OLUlEJ10sXG4gICAgICAgICAgJ1BFUi1SRU5ESVRJT04tVVJJUycsXG4gICAgICAgICAgdXJpUmVwbGFjZW1lbnQsXG4gICAgICAgICk7XG4gICAgICAgIGNsb25lZFRyYWNrLmdyb3VwSWQgPSBjbG9uZWRUcmFjay5hdHRyc1snR1JPVVAtSUQnXSA9XG4gICAgICAgICAgZ3JvdXBDbG9uZU1hcFthdWRpb0dyb3VwSWRdO1xuICAgICAgICBjbG9uZWRUcmFjay5hdHRyc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgICAgcmV0dXJuIGNsb25lZFRyYWNrO1xuICAgICAgfSk7XG4gICAgdHJhY2tzLnB1c2goLi4uY2xvbmVkVHJhY2tzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1VcmlSZXBsYWNlbWVudChcbiAgdXJpOiBzdHJpbmcsXG4gIHN0YWJsZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHBlck9wdGlvbktleTogJ1BFUi1WQVJJQU5ULVVSSVMnIHwgJ1BFUi1SRU5ESVRJT04tVVJJUycsXG4gIHVyaVJlcGxhY2VtZW50OiBVcmlSZXBsYWNlbWVudCxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHtcbiAgICBIT1NUOiBob3N0LFxuICAgIFBBUkFNUzogcGFyYW1zLFxuICAgIFtwZXJPcHRpb25LZXldOiBwZXJPcHRpb25VcmlzLFxuICB9ID0gdXJpUmVwbGFjZW1lbnQ7XG4gIGxldCBwZXJWYXJpYW50VXJpO1xuICBpZiAoc3RhYmxlSWQpIHtcbiAgICBwZXJWYXJpYW50VXJpID0gcGVyT3B0aW9uVXJpcz8uW3N0YWJsZUlkXTtcbiAgICBpZiAocGVyVmFyaWFudFVyaSkge1xuICAgICAgdXJpID0gcGVyVmFyaWFudFVyaTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdXJsID0gbmV3IHNlbGYuVVJMKHVyaSk7XG4gIGlmIChob3N0ICYmICFwZXJWYXJpYW50VXJpKSB7XG4gICAgdXJsLmhvc3QgPSBob3N0O1xuICB9XG4gIGlmIChwYXJhbXMpIHtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAuc29ydCgpXG4gICAgICAuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHBhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVybC5ocmVmO1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB0eXBlIHtcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXJDb250ZXh0LFxuICBMb2FkZXJTdGF0cyxcbiAgTG9hZGVyLFxuICBMb2FkZXJDb25maWd1cmF0aW9uLFxuICBMb2FkZXJSZXNwb25zZSxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IExvYWRTdGF0cyB9IGZyb20gJy4uL2xvYWRlci9sb2FkLXN0YXRzJztcbmltcG9ydCB7IHR5cGUgSGxzQ29uZmlnLCBSZXRyeUNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBnZXRSZXRyeURlbGF5LCBzaG91bGRSZXRyeSB9IGZyb20gJy4vZXJyb3ItaGVscGVyJztcblxuY29uc3QgQUdFX0hFQURFUl9MSU5FX1JFR0VYID0gL15hZ2U6XFxzKltcXGQuXStcXHMqJC9pbTtcblxuY2xhc3MgWGhyTG9hZGVyIGltcGxlbWVudHMgTG9hZGVyPExvYWRlckNvbnRleHQ+IHtcbiAgcHJpdmF0ZSB4aHJTZXR1cDpcbiAgICB8ICgoeGhyOiBYTUxIdHRwUmVxdWVzdCwgdXJsOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkKVxuICAgIHwgbnVsbDtcbiAgcHJpdmF0ZSByZXF1ZXN0VGltZW91dD86IG51bWJlcjtcbiAgcHJpdmF0ZSByZXRyeVRpbWVvdXQ/OiBudW1iZXI7XG4gIHByaXZhdGUgcmV0cnlEZWxheTogbnVtYmVyO1xuICBwcml2YXRlIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPExvYWRlckNvbnRleHQ+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBjb250ZXh0OiBMb2FkZXJDb250ZXh0IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBsb2FkZXI6IFhNTEh0dHBSZXF1ZXN0IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdGF0czogTG9hZGVyU3RhdHM7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBIbHNDb25maWcpIHtcbiAgICB0aGlzLnhoclNldHVwID0gY29uZmlnID8gY29uZmlnLnhoclNldHVwIHx8IG51bGwgOiBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gICAgdGhpcy5yZXRyeURlbGF5ID0gMDtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnhoclNldHVwID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5zdGF0cyA9IG51bGw7XG4gIH1cblxuICBhYm9ydEludGVybmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIGxvYWRlci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhYm9ydCgpIHtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAodGhpcy5jYWxsYmFja3M/Lm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQoXG4gICAgICAgIHRoaXMuc3RhdHMsXG4gICAgICAgIHRoaXMuY29udGV4dCBhcyBMb2FkZXJDb250ZXh0LFxuICAgICAgICB0aGlzLmxvYWRlcixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbG9hZChcbiAgICBjb250ZXh0OiBMb2FkZXJDb250ZXh0LFxuICAgIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgICBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxMb2FkZXJDb250ZXh0PixcbiAgKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuXG4gIGxvYWRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgY29udGV4dCB9ID0gdGhpcztcbiAgICBpZiAoIWNvbmZpZyB8fCAhY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSAodGhpcy5sb2FkZXIgPSBuZXcgc2VsZi5YTUxIdHRwUmVxdWVzdCgpKTtcblxuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5zdGF0cztcbiAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gMDtcbiAgICBzdGF0cy5sb2FkZWQgPSAwO1xuICAgIHN0YXRzLmFib3J0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB4aHJTZXR1cCA9IHRoaXMueGhyU2V0dXA7XG5cbiAgICBpZiAoeGhyU2V0dXApIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0cy5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBjb250ZXh0LnVybCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgIHRoaXMub3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgIC8vIElFMTEgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiB4aHIub3BlbiBpZiBhdHRlbXB0aW5nIHRvIGFjY2VzcyBhbiBIVFRQIHJlc291cmNlIG92ZXIgSFRUUFNcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcyEub25FcnJvcihcbiAgICAgICAgICAgIHsgY29kZTogeGhyLnN0YXR1cywgdGV4dDogZXJyb3IubWVzc2FnZSB9LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuQW5kU2VuZFhocih4aHIsIGNvbnRleHQsIGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgb3BlbkFuZFNlbmRYaHIoXG4gICAgeGhyOiBYTUxIdHRwUmVxdWVzdCxcbiAgICBjb250ZXh0OiBMb2FkZXJDb250ZXh0LFxuICAgIGNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgKSB7XG4gICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIGNvbnRleHQudXJsLCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzID0gY29udGV4dC5oZWFkZXJzO1xuICAgIGNvbnN0IHsgbWF4VGltZVRvRmlyc3RCeXRlTXMsIG1heExvYWRUaW1lTXMgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgICdSYW5nZScsXG4gICAgICAgICdieXRlcz0nICsgY29udGV4dC5yYW5nZVN0YXJ0ICsgJy0nICsgKGNvbnRleHQucmFuZ2VFbmQgLSAxKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5sb2FkcHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gY29udGV4dC5yZXNwb25zZVR5cGUgYXMgWE1MSHR0cFJlcXVlc3RSZXNwb25zZVR5cGU7XG4gICAgLy8gc2V0dXAgdGltZW91dCBiZWZvcmUgd2UgcGVyZm9ybSByZXF1ZXN0XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPVxuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgTnVtYmVyLmlzRmluaXRlKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zXG4gICAgICAgIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgdGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLFxuICAgICAgY29uZmlnLnRpbWVvdXQsXG4gICAgKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG5cbiAgcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGxvYWRlcjogeGhyLCBzdGF0cyB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIXhocikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgYXMgTG9hZGVyQ29uZmlndXJhdGlvbjtcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoXG4gICAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLnN0YXJ0LFxuICAgICAgICApO1xuICAgICAgICAvLyByZWFkeVN0YXRlID49IDIgQU5EIHJlYWR5U3RhdGUgIT09NCAocmVhZHlTdGF0ZSA9IEhFQURFUlNfUkVDRUlWRUQgfHwgTE9BRElORykgcmVhcm0gdGltZW91dCBhcyB4aHIgbm90IGZpbmlzaGVkIHlldFxuICAgICAgICBpZiAoY29uZmlnLnRpbWVvdXQgIT09IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMpIHtcbiAgICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgICBjb25maWcudGltZW91dCA9IGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXM7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dChcbiAgICAgICAgICAgIHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNvbmZpZy5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgLVxuICAgICAgICAgICAgICAoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB4aHIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIC8vIGh0dHAgc3RhdHVzIGJldHdlZW4gMjAwIHRvIDI5OSBhcmUgYWxsIHN1Y2Nlc3NmdWxcbiAgICAgICAgY29uc3QgdXNlUmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlICE9PSAndGV4dCc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdGF0dXMgPj0gMjAwICYmXG4gICAgICAgICAgc3RhdHVzIDwgMzAwICYmXG4gICAgICAgICAgKCh1c2VSZXNwb25zZSAmJiB4aHIucmVzcG9uc2UpIHx8IHhoci5yZXNwb25zZVRleHQgIT09IG51bGwpXG4gICAgICAgICkge1xuICAgICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgc3RhdHMubG9hZGluZy5maXJzdCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB1c2VSZXNwb25zZSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc3QgbGVuID1cbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcicgPyBkYXRhLmJ5dGVMZW5ndGggOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IGxlbjtcbiAgICAgICAgICBzdGF0cy5id0VzdGltYXRlID1cbiAgICAgICAgICAgIChzdGF0cy50b3RhbCAqIDgwMDApIC8gKHN0YXRzLmxvYWRpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5maXJzdCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvblByb2dyZXNzID0gdGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgZGF0YSwgeGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICB1cmw6IHhoci5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uU3VjY2VzcyhyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBjb25maWcubG9hZFBvbGljeS5lcnJvclJldHJ5O1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q291bnQgPSBzdGF0cy5yZXRyeTtcbiAgICAgICAgICAvLyBpZiBtYXggbmIgb2YgcmV0cmllcyByZWFjaGVkIG9yIGlmIGh0dHAgc3RhdHVzIGJldHdlZW4gNDAwIGFuZCA0OTkgKHN1Y2ggZXJyb3IgY2Fubm90IGJlIHJlY292ZXJlZCwgcmV0cnlpbmcgaXMgdXNlbGVzcyksIHJldHVybiBlcnJvclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIGZhbHNlLCByZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCR7c3RhdHVzfSB3aGlsZSBsb2FkaW5nICR7Y29udGV4dC51cmx9YCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcyEub25FcnJvcihcbiAgICAgICAgICAgICAgeyBjb2RlOiBzdGF0dXMsIHRleHQ6IHhoci5zdGF0dXNUZXh0IH0sXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWR0aW1lb3V0KCkge1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gdGhpcy5jb25maWc/LmxvYWRQb2xpY3kudGltZW91dFJldHJ5O1xuICAgIGNvbnN0IHJldHJ5Q291bnQgPSB0aGlzLnN0YXRzLnJldHJ5O1xuICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMucmV0cnkocmV0cnlDb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybihgdGltZW91dCB3aGlsZSBsb2FkaW5nICR7dGhpcy5jb250ZXh0Py51cmx9YCk7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcztcbiAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgICAgIGNhbGxiYWNrcy5vblRpbWVvdXQoXG4gICAgICAgICAgdGhpcy5zdGF0cyxcbiAgICAgICAgICB0aGlzLmNvbnRleHQgYXMgTG9hZGVyQ29udGV4dCxcbiAgICAgICAgICB0aGlzLmxvYWRlcixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXRyeShyZXRyeUNvbmZpZzogUmV0cnlDb25maWcpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIHN0YXRzIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHN0YXRzLnJldHJ5KTtcbiAgICBzdGF0cy5yZXRyeSsrO1xuICAgIGxvZ2dlci53YXJuKFxuICAgICAgYCR7XG4gICAgICAgIHN0YXR1cyA/ICdIVFRQIFN0YXR1cyAnICsgc3RhdHVzIDogJ1RpbWVvdXQnXG4gICAgICB9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0Py51cmx9LCByZXRyeWluZyAke3N0YXRzLnJldHJ5fS8ke1xuICAgICAgICByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeVxuICAgICAgfSBpbiAke3RoaXMucmV0cnlEZWxheX1tc2AsXG4gICAgKTtcbiAgICAvLyBhYm9ydCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQoXG4gICAgICB0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5yZXRyeURlbGF5LFxuICAgICk7XG4gIH1cblxuICBsb2FkcHJvZ3Jlc3MoZXZlbnQ6IFByb2dyZXNzRXZlbnQpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG5cbiAgICBzdGF0cy5sb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgIHN0YXRzLnRvdGFsID0gZXZlbnQudG90YWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2FjaGVBZ2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgbGV0IHJlc3VsdDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgaWYgKFxuICAgICAgdGhpcy5sb2FkZXIgJiZcbiAgICAgIEFHRV9IRUFERVJfTElORV9SRUdFWC50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2FnZScpO1xuICAgICAgcmVzdWx0ID0gYWdlSGVhZGVyID8gcGFyc2VGbG9hdChhZ2VIZWFkZXIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmIChcbiAgICAgIHRoaXMubG9hZGVyICYmXG4gICAgICBuZXcgUmVnRXhwKGBeJHtuYW1lfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgJ2ltJykudGVzdChcbiAgICAgICAgdGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCksXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFhockxvYWRlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIENodW5rQ2FjaGUge1xuICBwcml2YXRlIGNodW5rczogQXJyYXk8VWludDhBcnJheT4gPSBbXTtcbiAgcHVibGljIGRhdGFMZW5ndGg6IG51bWJlciA9IDA7XG5cbiAgcHVzaChjaHVuazogVWludDhBcnJheSkge1xuICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuZGF0YUxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gIH1cblxuICBmbHVzaCgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IGNodW5rcywgZGF0YUxlbmd0aCB9ID0gdGhpcztcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghY2h1bmtzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH0gZWxzZSBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmVzdWx0ID0gY2h1bmtzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhcbiAgY2h1bmtzOiBBcnJheTxVaW50OEFycmF5PixcbiAgZGF0YUxlbmd0aDogbnVtYmVyLFxuKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGRhdGFMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICByZXN1bHQuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsImltcG9ydCB7XG4gIExvYWRlckNhbGxiYWNrcyxcbiAgTG9hZGVyQ29udGV4dCxcbiAgTG9hZGVyLFxuICBMb2FkZXJTdGF0cyxcbiAgTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgTG9hZGVyT25Qcm9ncmVzcyxcbiAgTG9hZGVyUmVzcG9uc2UsXG59IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBMb2FkU3RhdHMgfSBmcm9tICcuLi9sb2FkZXIvbG9hZC1zdGF0cyc7XG5pbXBvcnQgQ2h1bmtDYWNoZSBmcm9tICcuLi9kZW11eC9jaHVuay1jYWNoZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaFN1cHBvcnRlZCgpIHtcbiAgaWYgKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLmZldGNoICYmXG4gICAgc2VsZi5BYm9ydENvbnRyb2xsZXIgJiZcbiAgICBzZWxmLlJlYWRhYmxlU3RyZWFtICYmXG4gICAgc2VsZi5SZXF1ZXN0XG4gICkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBub29wICovXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgQllURVJBTkdFID0gLyhcXGQrKS0oXFxkKylcXC8oXFxkKykvO1xuXG5jbGFzcyBGZXRjaExvYWRlciBpbXBsZW1lbnRzIExvYWRlcjxMb2FkZXJDb250ZXh0PiB7XG4gIHByaXZhdGUgZmV0Y2hTZXR1cDogRnVuY3Rpb247XG4gIHByaXZhdGUgcmVxdWVzdFRpbWVvdXQ/OiBudW1iZXI7XG4gIHByaXZhdGUgcmVxdWVzdDogUmVxdWVzdCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHJlc3BvbnNlOiBSZXNwb25zZSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbiAgcHVibGljIGNvbnRleHQ6IExvYWRlckNvbnRleHQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjYWxsYmFja3M6IExvYWRlckNhbGxiYWNrczxMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgc3RhdHM6IExvYWRlclN0YXRzO1xuICBwcml2YXRlIGxvYWRlcjogUmVzcG9uc2UgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWcgLyogSGxzQ29uZmlnICovKSB7XG4gICAgdGhpcy5mZXRjaFNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgfHwgZ2V0UmVxdWVzdDtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgc2VsZi5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRlciA9XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9XG4gICAgICB0aGlzLmNvbnRleHQgPVxuICAgICAgdGhpcy5jb25maWcgPVxuICAgICAgdGhpcy5yZXF1ZXN0ID1cbiAgICAgICAgbnVsbDtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mZXRjaFNldHVwID0gdGhpcy5jb250cm9sbGVyID0gdGhpcy5zdGF0cyA9IG51bGw7XG4gIH1cblxuICBhYm9ydEludGVybmFsKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIgJiYgIXRoaXMuc3RhdHMubG9hZGluZy5lbmQpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBhYm9ydCgpOiB2b2lkIHtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAodGhpcy5jYWxsYmFja3M/Lm9uQWJvcnQpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQoXG4gICAgICAgIHRoaXMuc3RhdHMsXG4gICAgICAgIHRoaXMuY29udGV4dCBhcyBMb2FkZXJDb250ZXh0LFxuICAgICAgICB0aGlzLnJlc3BvbnNlLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKFxuICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgY29uZmlnOiBMb2FkZXJDb25maWd1cmF0aW9uLFxuICAgIGNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPExvYWRlckNvbnRleHQ+LFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBjb25zdCBpbml0UGFyYW1zID0gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dCwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3Qgb25Qcm9ncmVzczogTG9hZGVyT25Qcm9ncmVzczxMb2FkZXJDb250ZXh0PiB8IHVuZGVmaW5lZCA9XG4gICAgICBjYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgY29uc3QgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIGNvbnN0IHsgbWF4VGltZVRvRmlyc3RCeXRlTXMsIG1heExvYWRUaW1lTXMgfSA9IGNvbmZpZy5sb2FkUG9saWN5O1xuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLmZldGNoU2V0dXAoY29udGV4dCwgaW5pdFBhcmFtcyk7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgY29uZmlnLnRpbWVvdXQgPVxuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXMgJiYgTnVtYmVyLmlzRmluaXRlKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zXG4gICAgICAgIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuXG4gICAgc2VsZlxuICAgICAgLmZldGNoKHRoaXMucmVxdWVzdCBhcyBSZXF1ZXN0KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOiBSZXNwb25zZSk6IFByb21pc2U8c3RyaW5nIHwgQXJyYXlCdWZmZXI+ID0+IHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHRoaXMubG9hZGVyID0gcmVzcG9uc2U7XG5cbiAgICAgICAgY29uc3QgZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcblxuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgY29uZmlnLnRpbWVvdXQgPSBtYXhMb2FkVGltZU1zO1xuICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXhMb2FkVGltZU1zIC0gKGZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCksXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCBzdGF0dXNUZXh0IH0gPSByZXNwb25zZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRmV0Y2hFcnJvcihcbiAgICAgICAgICAgIHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsXG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZmlyc3QgPSBmaXJzdDtcblxuICAgICAgICBzdGF0cy50b3RhbCA9IGdldENvbnRlbnRMZW5ndGgocmVzcG9uc2UuaGVhZGVycykgfHwgc3RhdHMudG90YWw7XG5cbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgTnVtYmVyLmlzRmluaXRlKGNvbmZpZy5oaWdoV2F0ZXJNYXJrKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9ncmVzc2l2ZWx5KFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjb25maWcuaGlnaFdhdGVyTWFyayxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2VUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlRGF0YTogc3RyaW5nIHwgQXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkZXIgZGVzdHJveWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kID0gTWF0aC5tYXgoXG4gICAgICAgICAgc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0LFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHJlc3BvbnNlRGF0YVtMRU5HVEhdO1xuICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9hZGVyUmVzcG9uc2U6IExvYWRlclJlc3BvbnNlID0ge1xuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgIU51bWJlci5pc0Zpbml0ZShjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCByZXNwb25zZURhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrcy5vblN1Y2Nlc3MobG9hZGVyUmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCByZXNwb25zZSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09SUyBlcnJvcnMgcmVzdWx0IGluIGFuIHVuZGVmaW5lZCBjb2RlLiBTZXQgaXQgdG8gMCBoZXJlIHRvIGFsaWduIHdpdGggWEhSJ3MgYmVoYXZpb3JcbiAgICAgICAgLy8gd2hlbiBkZXN0cm95aW5nLCAnZXJyb3InIGl0c2VsZiBjYW4gYmUgdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGNvZGU6IG51bWJlciA9ICFlcnJvciA/IDAgOiBlcnJvci5jb2RlIHx8IDA7XG4gICAgICAgIGNvbnN0IHRleHQ6IHN0cmluZyA9ICFlcnJvciA/IG51bGwgOiBlcnJvci5tZXNzYWdlO1xuICAgICAgICBjYWxsYmFja3Mub25FcnJvcihcbiAgICAgICAgICB7IGNvZGUsIHRleHQgfSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGdldENhY2hlQWdlKCk6IG51bWJlciB8IG51bGwge1xuICAgIGxldCByZXN1bHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdhZ2UnKTtcbiAgICAgIHJlc3VsdCA9IGFnZUhlYWRlciA/IHBhcnNlRmxvYXQoYWdlSGVhZGVyKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBnZXRSZXNwb25zZUhlYWRlcihuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkUHJvZ3Jlc3NpdmVseShcbiAgICByZXNwb25zZTogUmVzcG9uc2UsXG4gICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgIGNvbnRleHQ6IExvYWRlckNvbnRleHQsXG4gICAgaGlnaFdhdGVyTWFyazogbnVtYmVyID0gMCxcbiAgICBvblByb2dyZXNzOiBMb2FkZXJPblByb2dyZXNzPExvYWRlckNvbnRleHQ+LFxuICApOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgY29uc3QgY2h1bmtDYWNoZSA9IG5ldyBDaHVua0NhY2hlKCk7XG4gICAgY29uc3QgcmVhZGVyID0gKHJlc3BvbnNlLmJvZHkgYXMgUmVhZGFibGVTdHJlYW0pLmdldFJlYWRlcigpO1xuXG4gICAgY29uc3QgcHVtcCA9ICgpOiBQcm9taXNlPEFycmF5QnVmZmVyPiA9PiB7XG4gICAgICByZXR1cm4gcmVhZGVyXG4gICAgICAgIC5yZWFkKClcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rOiBVaW50OEFycmF5ID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICBjb25zdCBsZW4gPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcbiAgICAgICAgICBpZiAobGVuIDwgaGlnaFdhdGVyTWFyayB8fCBjaHVua0NhY2hlLmRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNodW5rIGlzIHRvbyBzbWFsbCB0byB0byBiZSBlbWl0dGVkIG9yIHRoZSBjYWNoZSBhbHJlYWR5IGhhcyBkYXRhXG4gICAgICAgICAgICAvLyBQdXNoIGl0IHRvIHRoZSBjYWNoZVxuICAgICAgICAgICAgY2h1bmtDYWNoZS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGlmIChjaHVua0NhY2hlLmRhdGFMZW5ndGggPj0gaGlnaFdhdGVyTWFyaykge1xuICAgICAgICAgICAgICAvLyBmbHVzaCBpbiBvcmRlciB0byBqb2luIHRoZSB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm90aGluZyBjYWNoZWQgYWxyZWFkeSwgYW5kIHRoZSBjaGFjaGUgaXMgbGFyZ2UgZW5vdWdoXG4gICAgICAgICAgICAvLyBqdXN0IGVtaXQgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuaywgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8qIGFib3J0ZWQgKi9cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBwdW1wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVxdWVzdFBhcmFtZXRlcnMoY29udGV4dDogTG9hZGVyQ29udGV4dCwgc2lnbmFsKTogYW55IHtcbiAgY29uc3QgaW5pdFBhcmFtczogYW55ID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbW9kZTogJ2NvcnMnLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIHNpZ25hbCxcbiAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuaGVhZGVycykpLFxuICB9O1xuXG4gIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgaW5pdFBhcmFtcy5oZWFkZXJzLnNldChcbiAgICAgICdSYW5nZScsXG4gICAgICAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIFN0cmluZyhjb250ZXh0LnJhbmdlRW5kIC0gMSksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBpbml0UGFyYW1zO1xufVxuXG5mdW5jdGlvbiBnZXRCeXRlUmFuZ2VMZW5ndGgoYnl0ZVJhbmdlSGVhZGVyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCByZXN1bHQgPSBCWVRFUkFOR0UuZXhlYyhieXRlUmFuZ2VIZWFkZXIpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdFsyXSkgLSBwYXJzZUludChyZXN1bHRbMV0pICsgMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb250ZW50TGVuZ3RoKGhlYWRlcnM6IEhlYWRlcnMpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICBpZiAoY29udGVudFJhbmdlKSB7XG4gICAgY29uc3QgYnl0ZVJhbmdlTGVuZ3RoID0gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGNvbnRlbnRSYW5nZSk7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShieXRlUmFuZ2VMZW5ndGgpKSB7XG4gICAgICByZXR1cm4gYnl0ZVJhbmdlTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dDogTG9hZGVyQ29udGV4dCwgaW5pdFBhcmFtczogYW55KTogUmVxdWVzdCB7XG4gIHJldHVybiBuZXcgc2VsZi5SZXF1ZXN0KGNvbnRleHQudXJsLCBpbml0UGFyYW1zKTtcbn1cblxuY2xhc3MgRmV0Y2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcHVibGljIGNvZGU6IG51bWJlcjtcbiAgcHVibGljIGRldGFpbHM6IGFueTtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBjb2RlOiBudW1iZXIsIGRldGFpbHM6IGFueSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGZXRjaExvYWRlcjtcbiIsImltcG9ydCBBYnJDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hYnItY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9TdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby1zdHJlYW0tY29udHJvbGxlcic7XG5pbXBvcnQgQXVkaW9UcmFja0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgQnVmZmVyQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYnVmZmVyLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgVGltZWxpbmVDb250cm9sbGVyIH0gZnJvbSAnLi9jb250cm9sbGVyL3RpbWVsaW5lLWNvbnRyb2xsZXInO1xuaW1wb3J0IENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IEZQU0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Zwcy1jb250cm9sbGVyJztcbmltcG9ydCBFTUVDb250cm9sbGVyLCB7XG4gIE1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsXG59IGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgQ01DRENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlcic7XG5pbXBvcnQgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyJztcbmltcG9ydCBFcnJvckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXInO1xuaW1wb3J0IFhockxvYWRlciBmcm9tICcuL3V0aWxzL3hoci1sb2FkZXInO1xuaW1wb3J0IEZldGNoTG9hZGVyLCB7IGZldGNoU3VwcG9ydGVkIH0gZnJvbSAnLi91dGlscy9mZXRjaC1sb2FkZXInO1xuaW1wb3J0IEN1ZXMgZnJvbSAnLi91dGlscy9jdWVzJztcbmltcG9ydCB7IHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyB9IGZyb20gJy4vdXRpbHMvbWVkaWFrZXlzLWhlbHBlcic7XG5pbXBvcnQgeyBJTG9nZ2VyLCBsb2dnZXIgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5cbmltcG9ydCB0eXBlIEhscyBmcm9tICcuL2hscyc7XG5pbXBvcnQgdHlwZSB7IEN1ZXNJbnRlcmZhY2UgfSBmcm9tICcuL3V0aWxzL2N1ZXMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUtleUZ1bmMsIEtleVN5c3RlbXMgfSBmcm9tICcuL3V0aWxzL21lZGlha2V5cy1oZWxwZXInO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnbWVudExvYWRlckNvbnRleHQsXG4gIExvYWRlcixcbiAgTG9hZGVyQ29udGV4dCxcbiAgTG9hZGVyUmVzcG9uc2UsXG4gIFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbn0gZnJvbSAnLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1NlbGVjdGlvbk9wdGlvbixcbiAgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24sXG4gIFZpZGVvU2VsZWN0aW9uT3B0aW9uLFxufSBmcm9tICcuL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcblxuZXhwb3J0IHR5cGUgQUJSQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgYWJyRXdtYUZhc3RMaXZlOiBudW1iZXI7XG4gIGFickV3bWFTbG93TGl2ZTogbnVtYmVyO1xuICBhYnJFd21hRmFzdFZvRDogbnVtYmVyO1xuICBhYnJFd21hU2xvd1ZvRDogbnVtYmVyO1xuICAvKipcbiAgICogRGVmYXVsdCBiYW5kd2lkdGggZXN0aW1hdGUgaW4gYml0cy9zIHByaW9yIHRvIGNvbGxlY3RpbmcgZnJhZ21lbnQgYmFuZHdpZHRoIHNhbXBsZXNcbiAgICovXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IG51bWJlcjtcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heDogbnVtYmVyO1xuICBhYnJCYW5kV2lkdGhGYWN0b3I6IG51bWJlcjtcbiAgYWJyQmFuZFdpZHRoVXBGYWN0b3I6IG51bWJlcjtcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiBib29sZWFuO1xuICBtYXhTdGFydmF0aW9uRGVsYXk6IG51bWJlcjtcbiAgbWF4TG9hZGluZ0RlbGF5OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBCdWZmZXJDb250cm9sbGVyQ29uZmlnID0ge1xuICBhcHBlbmRFcnJvck1heFJldHJ5OiBudW1iZXI7XG4gIGJhY2tCdWZmZXJMZW5ndGg6IG51bWJlcjtcbiAgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZDogbnVtYmVyO1xuICBsaXZlRHVyYXRpb25JbmZpbml0eTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBiYWNrQnVmZmVyTGVuZ3RoXG4gICAqL1xuICBsaXZlQmFja0J1ZmZlckxlbmd0aDogbnVtYmVyIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIENhcExldmVsQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgY2FwTGV2ZWxUb1BsYXllclNpemU6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBDTUNEQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgc2Vzc2lvbklkPzogc3RyaW5nO1xuICBjb250ZW50SWQ/OiBzdHJpbmc7XG4gIHVzZUhlYWRlcnM/OiBib29sZWFuO1xuICBpbmNsdWRlS2V5cz86IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IHR5cGUgRFJNU3lzdGVtT3B0aW9ucyA9IHtcbiAgYXVkaW9Sb2J1c3RuZXNzPzogc3RyaW5nO1xuICB2aWRlb1JvYnVzdG5lc3M/OiBzdHJpbmc7XG4gIGF1ZGlvRW5jcnlwdGlvblNjaGVtZT86IHN0cmluZyB8IG51bGw7XG4gIHZpZGVvRW5jcnlwdGlvblNjaGVtZT86IHN0cmluZyB8IG51bGw7XG4gIHBlcnNpc3RlbnRTdGF0ZT86IE1lZGlhS2V5c1JlcXVpcmVtZW50O1xuICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI/OiBNZWRpYUtleXNSZXF1aXJlbWVudDtcbiAgc2Vzc2lvblR5cGVzPzogc3RyaW5nW107XG4gIHNlc3Npb25UeXBlPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgRFJNU3lzdGVtQ29uZmlndXJhdGlvbiA9IHtcbiAgbGljZW5zZVVybDogc3RyaW5nO1xuICBzZXJ2ZXJDZXJ0aWZpY2F0ZVVybD86IHN0cmluZztcbiAgZ2VuZXJhdGVSZXF1ZXN0PzogKFxuICAgIHRoaXM6IEhscyxcbiAgICBpbml0RGF0YVR5cGU6IHN0cmluZyxcbiAgICBpbml0RGF0YTogQXJyYXlCdWZmZXIgfCBudWxsLFxuICAgIGtleUNvbnRleHQ6IE1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsXG4gICkgPT5cbiAgICB8IHsgaW5pdERhdGFUeXBlOiBzdHJpbmc7IGluaXREYXRhOiBBcnJheUJ1ZmZlciB8IG51bGwgfVxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCBuZXZlcjtcbn07XG5cbmV4cG9ydCB0eXBlIERSTVN5c3RlbXNDb25maWd1cmF0aW9uID0gUGFydGlhbDxcbiAgUmVjb3JkPEtleVN5c3RlbXMsIERSTVN5c3RlbUNvbmZpZ3VyYXRpb24+XG4+O1xuXG5leHBvcnQgdHlwZSBFTUVDb250cm9sbGVyQ29uZmlnID0ge1xuICBsaWNlbnNlWGhyU2V0dXA/OiAoXG4gICAgdGhpczogSGxzLFxuICAgIHhocjogWE1MSHR0cFJlcXVlc3QsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAga2V5Q29udGV4dDogTWVkaWFLZXlTZXNzaW9uQ29udGV4dCxcbiAgICBsaWNlbnNlQ2hhbGxlbmdlOiBVaW50OEFycmF5LFxuICApID0+IHZvaWQgfCBVaW50OEFycmF5IHwgUHJvbWlzZTxVaW50OEFycmF5IHwgdm9pZD47XG4gIGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrPzogKFxuICAgIHRoaXM6IEhscyxcbiAgICB4aHI6IFhNTEh0dHBSZXF1ZXN0LFxuICAgIHVybDogc3RyaW5nLFxuICAgIGtleUNvbnRleHQ6IE1lZGlhS2V5U2Vzc2lvbkNvbnRleHQsXG4gICkgPT4gQXJyYXlCdWZmZXI7XG4gIGVtZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHdpZGV2aW5lTGljZW5zZVVybD86IHN0cmluZztcbiAgZHJtU3lzdGVtczogRFJNU3lzdGVtc0NvbmZpZ3VyYXRpb247XG4gIGRybVN5c3RlbU9wdGlvbnM6IERSTVN5c3RlbU9wdGlvbnM7XG4gIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6IE1lZGlhS2V5RnVuYyB8IG51bGw7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZyYWdtZW50TG9hZGVyQ29uc3RydWN0b3Ige1xuICBuZXcgKGNvbmZnOiBIbHNDb25maWcpOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0Pjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5leHBvcnQgdHlwZSBGcmFnbWVudExvYWRlckNvbmZpZyA9IHtcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiBudW1iZXI7XG4gIGZyYWdMb2FkaW5nTWF4UmV0cnk6IG51bWJlcjtcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiBudW1iZXI7XG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBGUFNDb250cm9sbGVyQ29uZmlnID0ge1xuICBjYXBMZXZlbE9uRlBTRHJvcDogYm9vbGVhbjtcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IG51bWJlcjtcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIExldmVsQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgc3RhcnRMZXZlbD86IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE1QNFJlbXV4ZXJDb25maWcgPSB7XG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6IGJvb2xlYW47XG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxheWxpc3RMb2FkZXJDb25zdHJ1Y3RvciB7XG4gIG5ldyAoY29uZmc6IEhsc0NvbmZpZyk6IExvYWRlcjxQbGF5bGlzdExvYWRlckNvbnRleHQ+O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBtYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdCBhbmQgcGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHRcbiAqL1xuZXhwb3J0IHR5cGUgUGxheWxpc3RMb2FkZXJDb25maWcgPSB7XG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IG51bWJlcjtcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IG51bWJlcjtcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogbnVtYmVyO1xuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IG51bWJlcjtcblxuICBsZXZlbExvYWRpbmdUaW1lT3V0OiBudW1iZXI7XG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiBudW1iZXI7XG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IG51bWJlcjtcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBIbHNMb2FkUG9saWNpZXMgPSB7XG4gIGZyYWdMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBrZXlMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBjZXJ0TG9hZFBvbGljeTogTG9hZFBvbGljeTtcbiAgcGxheWxpc3RMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xuICBtYW5pZmVzdExvYWRQb2xpY3k6IExvYWRQb2xpY3k7XG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiBMb2FkUG9saWN5O1xufTtcblxuZXhwb3J0IHR5cGUgTG9hZFBvbGljeSA9IHtcbiAgZGVmYXVsdDogTG9hZGVyQ29uZmlnO1xufTtcblxuZXhwb3J0IHR5cGUgTG9hZGVyQ29uZmlnID0ge1xuICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogbnVtYmVyOyAvLyBNYXggdGltZSB0byBmaXJzdCBieXRlXG4gIG1heExvYWRUaW1lTXM6IG51bWJlcjsgLy8gTWF4IHRpbWUgZm9yIGxvYWQgY29tcGxldGlvblxuICB0aW1lb3V0UmV0cnk6IFJldHJ5Q29uZmlnIHwgbnVsbDtcbiAgZXJyb3JSZXRyeTogUmV0cnlDb25maWcgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgUmV0cnlDb25maWcgPSB7XG4gIG1heE51bVJldHJ5OiBudW1iZXI7IC8vIE1heGltdW0gbnVtYmVyIG9mIHJldHJpZXNcbiAgcmV0cnlEZWxheU1zOiBudW1iZXI7IC8vIFJldHJ5IGRlbGF5ID0gMl5yZXRyeUNvdW50ICogcmV0cnlEZWxheU1zIChleHBvbmVudGlhbCkgb3IgcmV0cnlDb3VudCAqIHJldHJ5RGVsYXlNcyAobGluZWFyKVxuICBtYXhSZXRyeURlbGF5TXM6IG51bWJlcjsgLy8gTWF4aW11bSBkZWxheSBiZXR3ZWVuIHJldHJpZXNcbiAgYmFja29mZj86ICdleHBvbmVudGlhbCcgfCAnbGluZWFyJzsgLy8gdXNlZCB0byBkZXRlcm1pbmUgcmV0cnkgYmFja29mZiBkdXJhdGlvbiAoc2VlIHJldHJ5RGVsYXlNcylcbiAgc2hvdWxkUmV0cnk/OiAoXG4gICAgcmV0cnlDb25maWc6IFJldHJ5Q29uZmlnIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICByZXRyeUNvdW50OiBudW1iZXIsXG4gICAgaXNUaW1lb3V0OiBib29sZWFuLFxuICAgIGxvYWRlclJlc3BvbnNlOiBMb2FkZXJSZXNwb25zZSB8IHVuZGVmaW5lZCxcbiAgICByZXRyeTogYm9vbGVhbixcbiAgKSA9PiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgYXV0b1N0YXJ0TG9hZDogYm9vbGVhbjtcbiAgc3RhcnRQb3NpdGlvbjogbnVtYmVyO1xuICBkZWZhdWx0QXVkaW9Db2RlYz86IHN0cmluZztcbiAgaW5pdGlhbExpdmVNYW5pZmVzdFNpemU6IG51bWJlcjtcbiAgbWF4QnVmZmVyTGVuZ3RoOiBudW1iZXI7XG4gIG1heEJ1ZmZlclNpemU6IG51bWJlcjtcbiAgbWF4QnVmZmVySG9sZTogbnVtYmVyO1xuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IG51bWJlcjtcbiAgbnVkZ2VPZmZzZXQ6IG51bWJlcjtcbiAgbnVkZ2VNYXhSZXRyeTogbnVtYmVyO1xuICBtYXhGcmFnTG9va1VwVG9sZXJhbmNlOiBudW1iZXI7XG4gIG1heE1heEJ1ZmZlckxlbmd0aDogbnVtYmVyO1xuICBzdGFydEZyYWdQcmVmZXRjaDogYm9vbGVhbjtcbiAgdGVzdEJhbmR3aWR0aDogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIFNlbGVjdGlvblByZWZlcmVuY2VzID0ge1xuICB2aWRlb1ByZWZlcmVuY2U/OiBWaWRlb1NlbGVjdGlvbk9wdGlvbjtcbiAgYXVkaW9QcmVmZXJlbmNlPzogQXVkaW9TZWxlY3Rpb25PcHRpb247XG4gIHN1YnRpdGxlUHJlZmVyZW5jZT86IFN1YnRpdGxlU2VsZWN0aW9uT3B0aW9uO1xufTtcblxuZXhwb3J0IHR5cGUgTGF0ZW5jeUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGxpdmVTeW5jRHVyYXRpb25Db3VudDogbnVtYmVyO1xuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IG51bWJlcjtcbiAgbGl2ZVN5bmNEdXJhdGlvbj86IG51bWJlcjtcbiAgbGl2ZU1heExhdGVuY3lEdXJhdGlvbj86IG51bWJlcjtcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IG51bWJlcjtcbn07XG5cbmV4cG9ydCB0eXBlIE1ldGFkYXRhQ29udHJvbGxlckNvbmZpZyA9IHtcbiAgZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzOiBib29sZWFuO1xuICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiBib29sZWFuO1xuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBUaW1lbGluZUNvbnRyb2xsZXJDb25maWcgPSB7XG4gIGN1ZUhhbmRsZXI6IEN1ZXNJbnRlcmZhY2U7XG4gIGVuYWJsZVdlYlZUVDogYm9vbGVhbjtcbiAgZW5hYmxlSU1TQzE6IGJvb2xlYW47XG4gIGVuYWJsZUNFQTcwOENhcHRpb25zOiBib29sZWFuO1xuICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2syTGFiZWw6IHN0cmluZztcbiAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiBzdHJpbmc7XG4gIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogc3RyaW5nO1xuICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6IHN0cmluZztcbiAgcmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgVFNEZW11eGVyQ29uZmlnID0ge1xuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiBib29sZWFuO1xufTtcblxuZXhwb3J0IHR5cGUgSGxzQ29uZmlnID0ge1xuICBkZWJ1ZzogYm9vbGVhbiB8IElMb2dnZXI7XG4gIGVuYWJsZVdvcmtlcjogYm9vbGVhbjtcbiAgd29ya2VyUGF0aDogbnVsbCB8IHN0cmluZztcbiAgZW5hYmxlU29mdHdhcmVBRVM6IGJvb2xlYW47XG4gIG1pbkF1dG9CaXRyYXRlOiBudW1iZXI7XG4gIGlnbm9yZURldmljZVBpeGVsUmF0aW86IGJvb2xlYW47XG4gIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTogYm9vbGVhbjtcbiAgbG9hZGVyOiB7IG5ldyAoY29uZmc6IEhsc0NvbmZpZyk6IExvYWRlcjxMb2FkZXJDb250ZXh0PiB9O1xuICBmTG9hZGVyPzogRnJhZ21lbnRMb2FkZXJDb25zdHJ1Y3RvcjtcbiAgcExvYWRlcj86IFBsYXlsaXN0TG9hZGVyQ29uc3RydWN0b3I7XG4gIGZldGNoU2V0dXA/OiAoY29udGV4dDogTG9hZGVyQ29udGV4dCwgaW5pdFBhcmFtczogYW55KSA9PiBSZXF1ZXN0O1xuICB4aHJTZXR1cD86ICh4aHI6IFhNTEh0dHBSZXF1ZXN0LCB1cmw6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG5cbiAgLy8gQWx0IEF1ZGlvXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcj86IHR5cGVvZiBBdWRpb1N0cmVhbUNvbnRyb2xsZXI7XG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyPzogdHlwZW9mIEF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAvLyBTdWJ0aXRsZVxuICBzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI/OiB0eXBlb2YgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcj86IHR5cGVvZiBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgdGltZWxpbmVDb250cm9sbGVyPzogdHlwZW9mIFRpbWVsaW5lQ29udHJvbGxlcjtcbiAgLy8gRU1FXG4gIGVtZUNvbnRyb2xsZXI/OiB0eXBlb2YgRU1FQ29udHJvbGxlcjtcbiAgLy8gQ01DRFxuICBjbWNkPzogQ01DRENvbnRyb2xsZXJDb25maWc7XG4gIGNtY2RDb250cm9sbGVyPzogdHlwZW9mIENNQ0RDb250cm9sbGVyO1xuICAvLyBDb250ZW50IFN0ZWVyaW5nXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI/OiB0eXBlb2YgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcjtcblxuICAvLyBNZWRpYUNhcGFiaWxpZXMgQVBJIGZvciBsZXZlbCwgdHJhY2ssIGFuZCBzd2l0Y2ggZmlsdGVyaW5nXG4gIHVzZU1lZGlhQ2FwYWJpbGl0aWVzOiBib29sZWFuO1xuXG4gIGFickNvbnRyb2xsZXI6IHR5cGVvZiBBYnJDb250cm9sbGVyO1xuICBidWZmZXJDb250cm9sbGVyOiB0eXBlb2YgQnVmZmVyQ29udHJvbGxlcjtcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiB0eXBlb2YgQ2FwTGV2ZWxDb250cm9sbGVyO1xuICBlcnJvckNvbnRyb2xsZXI6IHR5cGVvZiBFcnJvckNvbnRyb2xsZXI7XG4gIGZwc0NvbnRyb2xsZXI6IHR5cGVvZiBGUFNDb250cm9sbGVyO1xuICBwcm9ncmVzc2l2ZTogYm9vbGVhbjtcbiAgbG93TGF0ZW5jeU1vZGU6IGJvb2xlYW47XG59ICYgQUJSQ29udHJvbGxlckNvbmZpZyAmXG4gIEJ1ZmZlckNvbnRyb2xsZXJDb25maWcgJlxuICBDYXBMZXZlbENvbnRyb2xsZXJDb25maWcgJlxuICBFTUVDb250cm9sbGVyQ29uZmlnICZcbiAgRlBTQ29udHJvbGxlckNvbmZpZyAmXG4gIExldmVsQ29udHJvbGxlckNvbmZpZyAmXG4gIE1QNFJlbXV4ZXJDb25maWcgJlxuICBTdHJlYW1Db250cm9sbGVyQ29uZmlnICZcbiAgU2VsZWN0aW9uUHJlZmVyZW5jZXMgJlxuICBMYXRlbmN5Q29udHJvbGxlckNvbmZpZyAmXG4gIE1ldGFkYXRhQ29udHJvbGxlckNvbmZpZyAmXG4gIFRpbWVsaW5lQ29udHJvbGxlckNvbmZpZyAmXG4gIFRTRGVtdXhlckNvbmZpZyAmXG4gIEhsc0xvYWRQb2xpY2llcyAmXG4gIEZyYWdtZW50TG9hZGVyQ29uZmlnICZcbiAgUGxheWxpc3RMb2FkZXJDb25maWc7XG5cbmNvbnN0IGRlZmF1bHRMb2FkUG9saWN5OiBMb2FkZXJDb25maWcgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4MDAwLFxuICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsLFxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKiBJZiBwb3NzaWJsZSwga2VlcCBobHNEZWZhdWx0Q29uZmlnIHNoYWxsb3dcbiAqIEl0IGlzIGNsb25lZCB3aGVuZXZlciBhIG5ldyBIbHMgaW5zdGFuY2UgaXMgY3JlYXRlZCwgYnkga2VlcGluZyB0aGUgY29uZmlnXG4gKiBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XG4gKi9cbmV4cG9ydCBjb25zdCBobHNEZWZhdWx0Q29uZmlnOiBIbHNDb25maWcgPSB7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSwgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlOiB0cnVlLFxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQ6IEluZmluaXR5LFxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDIsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VPZmZzZXQ6IDAuMSwgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU1heFJldHJ5OiAzLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLCAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LCAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IDEsIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSwgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGJhY2tCdWZmZXJMZW5ndGhcbiAgICovXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLCAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSwgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIHdvcmtlclBhdGg6IG51bGwsIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSwgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLCAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLCAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMywgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IFhockxvYWRlcixcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCwgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLCAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBlcnJvckNvbnRyb2xsZXI6IEVycm9yQ29udHJvbGxlcixcbiAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSwgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLCAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgYWJyRXdtYUZhc3RMaXZlOiAzLCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93TGl2ZTogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRmFzdFZvRDogMywgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd1ZvRDogOSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXg6IDVlNiwgLy8gNSBtYnBzXG4gIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LCAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heExvYWRpbmdEZWxheTogNCwgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtaW5BdXRvQml0cmF0ZTogMCwgLy8gdXNlZCBieSBobHNcbiAgZW1lRW5hYmxlZDogZmFsc2UsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtczoge30sIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtT3B0aW9uczoge30sIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogX19VU0VfRU1FX0RSTV9fXG4gICAgPyByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcbiAgICA6IG51bGwsIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgdGVzdEJhbmR3aWR0aDogdHJ1ZSxcbiAgcHJvZ3Jlc3NpdmU6IGZhbHNlLFxuICBsb3dMYXRlbmN5TW9kZTogdHJ1ZSxcbiAgY21jZDogdW5kZWZpbmVkLFxuICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6IHRydWUsXG4gIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgdXNlTWVkaWFDYXBhYmlsaXRpZXM6IF9fVVNFX01FRElBX0NBUEFCSUxJVElFU19fLFxuXG4gIGNlcnRMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogZGVmYXVsdExvYWRQb2xpY3ksXG4gIH0sXG4gIGtleUxvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMjAwMDAsXG4gICAgICAgIGJhY2tvZmY6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcicsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIG1hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMCxcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbiAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwLFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwLFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBmcmFnTG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxMDAwMCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDEyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDAsXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDAsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogX19VU0VfQ09OVEVOVF9TVEVFUklOR19fXG4gICAgICA/IHtcbiAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICAgIG1heFJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgICAgIG1heE51bVJldHJ5OiAxLFxuICAgICAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgIDogZGVmYXVsdExvYWRQb2xpY3ksXG4gIH0sXG5cbiAgLy8gVGhlc2UgZGVmYXVsdCBzZXR0aW5ncyBhcmUgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUgYWJvdmUgcG9saWNpZXNcbiAgLy8gYW5kIGFyZSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBtYW5pZmVzdExvYWRpbmdUaW1lT3V0OiAxMDAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnk6IDEsXG4gIG1hbmlmZXN0TG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIG1hbmlmZXN0TG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeTogNCxcbiAgbGV2ZWxMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgZnJhZ0xvYWRpbmdUaW1lT3V0OiAyMDAwMCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dDogNjQwMDAsXG5cbiAgLy8gRHluYW1pYyBNb2R1bGVzXG4gIC4uLnRpbWVsaW5lQ29uZmlnKCksXG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX19cbiAgICA/IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlclxuICAgIDogdW5kZWZpbmVkLFxuICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX19cbiAgICA/IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgOiB1bmRlZmluZWQsXG4gIHRpbWVsaW5lQ29udHJvbGxlcjogX19VU0VfU1VCVElUTEVTX18gPyBUaW1lbGluZUNvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGF1ZGlvU3RyZWFtQ29udHJvbGxlcjogX19VU0VfQUxUX0FVRElPX18gPyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBfX1VTRV9BTFRfQVVESU9fXyA/IEF1ZGlvVHJhY2tDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBlbWVDb250cm9sbGVyOiBfX1VTRV9FTUVfRFJNX18gPyBFTUVDb250cm9sbGVyIDogdW5kZWZpbmVkLFxuICBjbWNkQ29udHJvbGxlcjogX19VU0VfQ01DRF9fID8gQ01DRENvbnRyb2xsZXIgOiB1bmRlZmluZWQsXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IF9fVVNFX0NPTlRFTlRfU1RFRVJJTkdfX1xuICAgID8gQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlclxuICAgIDogdW5kZWZpbmVkLFxufTtcblxuZnVuY3Rpb24gdGltZWxpbmVDb25maWcoKTogVGltZWxpbmVDb250cm9sbGVyQ29uZmlnIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBDdWVzLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVXZWJWVFQ6IF9fVVNFX1NVQlRJVExFU19fLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogX19VU0VfU1VCVElUTEVTX18sIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZUNFQTcwOENhcHRpb25zOiBfX1VTRV9TVUJUSVRMRVNfXywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6ICdFbmdsaXNoJywgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOiAnZW4nLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLCAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6ICdlcycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOiAnVW5rbm93biBDQycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOiAnVW5rbm93biBDQycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTogJycsIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhcbiAgZGVmYXVsdENvbmZpZzogSGxzQ29uZmlnLFxuICB1c2VyQ29uZmlnOiBQYXJ0aWFsPEhsc0NvbmZpZz4sXG4pOiBIbHNDb25maWcge1xuICBpZiAoXG4gICAgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8XG4gICAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiZcbiAgICAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIixcbiAgICApO1xuICB9XG5cbiAgaWYgKFxuICAgIHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD1cbiAgICAgICAgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicsXG4gICAgKTtcbiAgfVxuXG4gIGlmIChcbiAgICB1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbilcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBkZWZhdWx0c0NvcHkgPSBkZWVwQ3B5KGRlZmF1bHRDb25maWcpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZGVwcmVjYXRlZCBjb25maWcgdmFsdWVzXG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMgPSBbJ21hbmlmZXN0JywgJ2xldmVsJywgJ2ZyYWcnXTtcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdzID0gW1xuICAgICdUaW1lT3V0JyxcbiAgICAnTWF4UmV0cnknLFxuICAgICdSZXRyeURlbGF5JyxcbiAgICAnTWF4UmV0cnlUaW1lb3V0JyxcbiAgXTtcbiAgZGVwcmVjYXRlZFNldHRpbmdUeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgY29uc3QgcG9saWN5TmFtZSA9IGAke3R5cGUgPT09ICdsZXZlbCcgPyAncGxheWxpc3QnIDogdHlwZX1Mb2FkUG9saWN5YDtcbiAgICBjb25zdCBwb2xpY3lOb3RTZXQgPSB1c2VyQ29uZmlnW3BvbGljeU5hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgcmVwb3J0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGRlcHJlY2F0ZWRTZXR0aW5ncy5mb3JFYWNoKChzZXR0aW5nKSA9PiB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkU2V0dGluZyA9IGAke3R5cGV9TG9hZGluZyR7c2V0dGluZ31gO1xuICAgICAgY29uc3QgdmFsdWUgPSB1c2VyQ29uZmlnW2RlcHJlY2F0ZWRTZXR0aW5nXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBvbGljeU5vdFNldCkge1xuICAgICAgICByZXBvcnQucHVzaChkZXByZWNhdGVkU2V0dGluZyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzOiBMb2FkZXJDb25maWcgPSBkZWZhdWx0c0NvcHlbcG9saWN5TmFtZV0uZGVmYXVsdDtcbiAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHsgZGVmYXVsdDogc2V0dGluZ3MgfTtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5nKSB7XG4gICAgICAgICAgY2FzZSAnVGltZU91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhMb2FkVGltZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy5tYXhUaW1lVG9GaXJzdEJ5dGVNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeSEubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeSEubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeSEucmV0cnlEZWxheU1zID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkhLnJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTWF4UmV0cnlUaW1lb3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yUmV0cnkhLm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5IS5tYXhSZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJlcG9ydC5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICBgaGxzLmpzIGNvbmZpZzogXCIke3JlcG9ydC5qb2luKFxuICAgICAgICAgICdcIiwgXCInLFxuICAgICAgICApfVwiIHNldHRpbmcocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBcIiR7cG9saWN5TmFtZX1cIjogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB1c2VyQ29uZmlnW3BvbGljeU5hbWVdLFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0c0NvcHksXG4gICAgLi4udXNlckNvbmZpZyxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVlcENweShvYmo6IGFueSk6IGFueSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ3B5KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBkZWVwQ3B5KG9ialtrZXldKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpIHtcbiAgY29uc3QgY3VycmVudExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgbG9nZ2VyLmxvZyhcbiAgICAgICdbY29uZmlnXTogQ3VzdG9tIGxvYWRlciBkZXRlY3RlZCwgY2Fubm90IGVuYWJsZSBwcm9ncmVzc2l2ZSBzdHJlYW1pbmcnLFxuICAgICk7XG4gICAgY29uZmlnLnByb2dyZXNzaXZlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9IGZldGNoU3VwcG9ydGVkKCk7XG4gICAgaWYgKGNhblN0cmVhbVByb2dyZXNzaXZlbHkpIHtcbiAgICAgIGNvbmZpZy5sb2FkZXIgPSBGZXRjaExvYWRlcjtcbiAgICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICBjb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgTWFuaWZlc3RMb2FkZWREYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIExldmVsTG9hZGVkRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBMZXZlbFN3aXRjaGluZ0RhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBNYW5pZmVzdExvYWRpbmdEYXRhLFxuICBGcmFnQnVmZmVyZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgTGV2ZWwsIFZpZGVvUmFuZ2VWYWx1ZXMsIGlzVmlkZW9SYW5nZSB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtcbiAgYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQsXG4gIGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZSxcbiAgY29udmVydEFWQzFUb0FWQ09USSxcbiAgZ2V0Q29kZWNDb21wYXRpYmxlTmFtZSxcbiAgdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZSxcbn0gZnJvbSAnLi4vdXRpbHMvY29kZWNzJztcbmltcG9ydCBCYXNlUGxheWxpc3RDb250cm9sbGVyIGZyb20gJy4vYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyJztcbmltcG9ydCB7IFBsYXlsaXN0Q29udGV4dFR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIGZyb20gJy4vY29udGVudC1zdGVlcmluZy1jb250cm9sbGVyJztcbmltcG9ydCB7IHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMgfSBmcm9tICcuLi91dGlscy9sZXZlbC1oZWxwZXInO1xuaW1wb3J0IHsgaGxzRGVmYXVsdENvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzVXJsUGFyYW1ldGVycywgTGV2ZWxQYXJzZWQgfSBmcm9tICcuLi90eXBlcy9sZXZlbCc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhUGxheWxpc3QgfSBmcm9tICcuLi90eXBlcy9tZWRpYS1wbGF5bGlzdCc7XG5cbmxldCBjaHJvbWVPckZpcmVmb3g6IGJvb2xlYW47XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldmVsQ29udHJvbGxlciBleHRlbmRzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBwcml2YXRlIF9sZXZlbHM6IExldmVsW10gPSBbXTtcbiAgcHJpdmF0ZSBfZmlyc3RMZXZlbDogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgX21heEF1dG9MZXZlbDogbnVtYmVyID0gLTE7XG4gIHByaXZhdGUgX3N0YXJ0TGV2ZWw/OiBudW1iZXI7XG4gIHByaXZhdGUgY3VycmVudExldmVsOiBMZXZlbCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRMZXZlbEluZGV4OiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBtYW51YWxMZXZlbEluZGV4OiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBzdGVlcmluZzogQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciB8IG51bGw7XG5cbiAgcHVibGljIG9uUGFyc2VkQ29tcGxldGUhOiBGdW5jdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBobHM6IEhscyxcbiAgICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIHwgbnVsbCxcbiAgKSB7XG4gICAgc3VwZXIoaGxzLCAnW2xldmVsLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy5zdGVlcmluZyA9IGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuc3RlZXJpbmcgPSBudWxsO1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICBwdWJsaWMgc3RvcExvYWQoKTogdm9pZCB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzO1xuXG4gICAgLy8gY2xlYW4gdXAgbGl2ZSBsZXZlbCBkZXRhaWxzIHRvIGZvcmNlIHJlbG9hZCB0aGVtLCBhbmQgcmVzZXQgbG9hZCBlcnJvcnNcbiAgICBsZXZlbHMuZm9yRWFjaCgobGV2ZWwpID0+IHtcbiAgICAgIGxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICB9KTtcblxuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0TGV2ZWxzKCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLl9sZXZlbHMgPSBbXTtcbiAgICB0aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMTtcbiAgfVxuXG4gIHByaXZhdGUgb25NYW5pZmVzdExvYWRpbmcoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gICkge1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1hbmlmZXN0TG9hZGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfTE9BREVELFxuICAgIGRhdGE6IE1hbmlmZXN0TG9hZGVkRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICBjb25zdCBsZXZlbHM6IExldmVsW10gPSBbXTtcbiAgICBjb25zdCByZWR1bmRhbnRTZXQ6IHsgW2tleTogc3RyaW5nXTogTGV2ZWwgfSA9IHt9O1xuICAgIGNvbnN0IGdlbmVyYXRlUGF0aHdheVNldDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICAgIGxldCByZXNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuXG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaCgobGV2ZWxQYXJzZWQ6IExldmVsUGFyc2VkKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbGV2ZWxQYXJzZWQuYXR0cnM7XG5cbiAgICAgIC8vIGVyYXNlIGF1ZGlvIGNvZGVjIGluZm8gaWYgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IG1wNGEuNDAuMzQuXG4gICAgICAvLyBkZW11eGVyIHdpbGwgYXV0b2RldGVjdCBjb2RlYyBhbmQgZmFsbGJhY2sgdG8gbXBlZy9hdWRpb1xuICAgICAgbGV0IHsgYXVkaW9Db2RlYywgdmlkZW9Db2RlYyB9ID0gbGV2ZWxQYXJzZWQ7XG4gICAgICBpZiAoYXVkaW9Db2RlYz8uaW5kZXhPZignbXA0YS40MC4zNCcpICE9PSAtMSkge1xuICAgICAgICBjaHJvbWVPckZpcmVmb3ggfHw9IC9jaHJvbWV8ZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIGlmIChjaHJvbWVPckZpcmVmb3gpIHtcbiAgICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXVkaW9Db2RlYykge1xuICAgICAgICBsZXZlbFBhcnNlZC5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYyA9IGdldENvZGVjQ29tcGF0aWJsZU5hbWUoXG4gICAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aWRlb0NvZGVjPy5pbmRleE9mKCdhdmMxJykgPT09IDApIHtcbiAgICAgICAgdmlkZW9Db2RlYyA9IGxldmVsUGFyc2VkLnZpZGVvQ29kZWMgPSBjb252ZXJ0QVZDMVRvQVZDT1RJKHZpZGVvQ29kZWMpO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGtlZXAgbGV2ZWxzIHdpdGggc3VwcG9ydGVkIGF1ZGlvL3ZpZGVvIGNvZGVjc1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB1bmtub3duQ29kZWNzIH0gPSBsZXZlbFBhcnNlZDtcbiAgICAgIHJlc29sdXRpb25Gb3VuZCB8fD0gISEod2lkdGggJiYgaGVpZ2h0KTtcbiAgICAgIHZpZGVvQ29kZWNGb3VuZCB8fD0gISF2aWRlb0NvZGVjO1xuICAgICAgYXVkaW9Db2RlY0ZvdW5kIHx8PSAhIWF1ZGlvQ29kZWM7XG4gICAgICBpZiAoXG4gICAgICAgIHVua25vd25Db2RlY3M/Lmxlbmd0aCB8fFxuICAgICAgICAoYXVkaW9Db2RlYyAmJlxuICAgICAgICAgICFhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgICAgICAnYXVkaW8nLFxuICAgICAgICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlLFxuICAgICAgICAgICkpIHx8XG4gICAgICAgICh2aWRlb0NvZGVjICYmXG4gICAgICAgICAgIWFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKFxuICAgICAgICAgICAgdmlkZW9Db2RlYyxcbiAgICAgICAgICAgICd2aWRlbycsXG4gICAgICAgICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UsXG4gICAgICAgICAgKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQ09ERUNTLFxuICAgICAgICAnRlJBTUUtUkFURSc6IEZSQU1FUkFURSxcbiAgICAgICAgJ0hEQ1AtTEVWRUwnOiBIRENQLFxuICAgICAgICAnUEFUSFdBWS1JRCc6IFBBVEhXQVksXG4gICAgICAgIFJFU09MVVRJT04sXG4gICAgICAgICdWSURFTy1SQU5HRSc6IFZJREVPX1JBTkdFLFxuICAgICAgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCBjb250ZW50U3RlZXJpbmdQcmVmaXggPSBgJHtQQVRIV0FZIHx8ICcuJ30tYDtcbiAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7Y29udGVudFN0ZWVyaW5nUHJlZml4fSR7bGV2ZWxQYXJzZWQuYml0cmF0ZX0tJHtSRVNPTFVUSU9OfS0ke0ZSQU1FUkFURX0tJHtDT0RFQ1N9LSR7VklERU9fUkFOR0V9LSR7SERDUH1gO1xuXG4gICAgICBpZiAoIXJlZHVuZGFudFNldFtsZXZlbEtleV0pIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobGV2ZWxQYXJzZWQpO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldID0gbGV2ZWw7XG4gICAgICAgIGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gPSAxO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldLnVyaSAhPT0gbGV2ZWxQYXJzZWQudXJsICYmXG4gICAgICAgICFsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddXG4gICAgICApIHtcbiAgICAgICAgLy8gQXNzaWduIFBhdGh3YXkgSURzIHRvIFJlZHVuZGFudCBTdHJlYW1zIChkZWZhdWx0IFBhdGh3YXlzIGlzIFwiLlwiLiBSZWR1bmRhbnQgU3RyZWFtcyBcIi4uXCIsIFwiLi4uXCIsIGFuZCBzbyBvbi4pXG4gICAgICAgIC8vIENvbnRlbnQgU3RlZXJpbmcgY29udHJvbGxlciB0byBoYW5kbGVzIFBhdGh3YXkgZmFsbGJhY2sgb24gZXJyb3JcbiAgICAgICAgY29uc3QgcGF0aHdheUNvdW50ID0gKGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gKz0gMSk7XG4gICAgICAgIGxldmVsUGFyc2VkLmF0dHJzWydQQVRIV0FZLUlEJ10gPSBuZXcgQXJyYXkocGF0aHdheUNvdW50ICsgMSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBsZXZlbCA9IG5ldyBMZXZlbChsZXZlbFBhcnNlZCk7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0gPSBsZXZlbDtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XS5hZGRHcm91cElkKCdhdWRpbycsIGF0dHJpYnV0ZXMuQVVESU8pO1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldLmFkZEdyb3VwSWQoJ3RleHQnLCBhdHRyaWJ1dGVzLlNVQlRJVExFUyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMoXG4gICAgICBsZXZlbHMsXG4gICAgICBkYXRhLFxuICAgICAgcmVzb2x1dGlvbkZvdW5kLFxuICAgICAgdmlkZW9Db2RlY0ZvdW5kLFxuICAgICAgYXVkaW9Db2RlY0ZvdW5kLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMoXG4gICAgZmlsdGVyZWRMZXZlbHM6IExldmVsW10sXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkZWREYXRhLFxuICAgIHJlc29sdXRpb25Gb3VuZDogYm9vbGVhbixcbiAgICB2aWRlb0NvZGVjRm91bmQ6IGJvb2xlYW4sXG4gICAgYXVkaW9Db2RlY0ZvdW5kOiBib29sZWFuLFxuICApIHtcbiAgICBsZXQgYXVkaW9UcmFja3M6IE1lZGlhUGxheWxpc3RbXSA9IFtdO1xuICAgIGxldCBzdWJ0aXRsZVRyYWNrczogTWVkaWFQbGF5bGlzdFtdID0gW107XG4gICAgbGV0IGxldmVscyA9IGZpbHRlcmVkTGV2ZWxzO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgYW5kIGludmFsaWQgdmlkZW8tcmFuZ2UgbGV2ZWxzIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihcbiAgICAgICAgKHsgdmlkZW9Db2RlYywgdmlkZW9SYW5nZSwgd2lkdGgsIGhlaWdodCB9KSA9PlxuICAgICAgICAgICghIXZpZGVvQ29kZWMgfHwgISEod2lkdGggJiYgaGVpZ2h0KSkgJiYgaXNWaWRlb1JhbmdlKHZpZGVvUmFuZ2UpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRGlzcGF0Y2ggZXJyb3IgYWZ0ZXIgTUFOSUZFU1RfTE9BREVEIGlzIGRvbmUgcHJvcGFnYXRpbmdcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgICBpZiAoZGF0YS5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICAgIGBPbmUgb3IgbW9yZSBDT0RFQ1MgaW4gdmFyaWFudCBub3Qgc3VwcG9ydGVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGRhdGEubGV2ZWxzWzBdLmF0dHJzLFxuICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0JyxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICAgIHVybDogZGF0YS51cmwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYXVkaW9UcmFja3MpIHtcbiAgICAgIGNvbnN0IHsgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlIH0gPSB0aGlzLmhscy5jb25maWc7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKFxuICAgICAgICAodHJhY2spID0+XG4gICAgICAgICAgIXRyYWNrLmF1ZGlvQ29kZWMgfHxcbiAgICAgICAgICBhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZChcbiAgICAgICAgICAgIHRyYWNrLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgICAnYXVkaW8nLFxuICAgICAgICAgICAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlLFxuICAgICAgICAgICksXG4gICAgICApO1xuICAgICAgLy8gQXNzaWduIGlkcyBhZnRlciBmaWx0ZXJpbmcgYXMgYXJyYXkgaW5kaWNlcyBieSBncm91cC1pZFxuICAgICAgYXNzaWduVHJhY2tJZHNCeUdyb3VwKGF1ZGlvVHJhY2tzKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zdWJ0aXRsZXMpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZXM7XG4gICAgICBhc3NpZ25UcmFja0lkc0J5R3JvdXAoc3VidGl0bGVUcmFja3MpO1xuICAgIH1cbiAgICAvLyBzdGFydCBiaXRyYXRlIGlzIHRoZSBmaXJzdCBiaXRyYXRlIG9mIHRoZSBtYW5pZmVzdFxuICAgIGNvbnN0IHVuc29ydGVkTGV2ZWxzID0gbGV2ZWxzLnNsaWNlKDApO1xuICAgIC8vIHNvcnQgbGV2ZWxzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3RcbiAgICBsZXZlbHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgaWYgKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSAhPT0gYi5hdHRyc1snSERDUC1MRVZFTCddKSB7XG4gICAgICAgIHJldHVybiAoYS5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA+IChiLmF0dHJzWydIRENQLUxFVkVMJ10gfHwgJycpXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgb24gaGVpZ2h0IGJlZm9yZSBiaXRyYXRlIGZvciBjYXAtbGV2ZWwtY29udHJvbGxlclxuICAgICAgaWYgKHJlc29sdXRpb25Gb3VuZCAmJiBhLmhlaWdodCAhPT0gYi5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGEuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAoYS5mcmFtZVJhdGUgIT09IGIuZnJhbWVSYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmZyYW1lUmF0ZSAtIGIuZnJhbWVSYXRlO1xuICAgICAgfVxuICAgICAgaWYgKGEudmlkZW9SYW5nZSAhPT0gYi52aWRlb1JhbmdlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKGEudmlkZW9SYW5nZSkgLVxuICAgICAgICAgIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihiLnZpZGVvUmFuZ2UpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoYS52aWRlb0NvZGVjICE9PSBiLnZpZGVvQ29kZWMpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBID0gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShhLnZpZGVvQ29kZWMpO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKGIudmlkZW9Db2RlYyk7XG4gICAgICAgIGlmICh2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUIgLSB2YWx1ZUE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhLnVyaSA9PT0gYi51cmkgJiYgYS5jb2RlY1NldCAhPT0gYi5jb2RlY1NldCkge1xuICAgICAgICBjb25zdCB2YWx1ZUEgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYS5jb2RlY1NldCk7XG4gICAgICAgIGNvbnN0IHZhbHVlQiA9IGNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZShiLmNvZGVjU2V0KTtcbiAgICAgICAgaWYgKHZhbHVlQSAhPT0gdmFsdWVCKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlQiAtIHZhbHVlQTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGEuYXZlcmFnZUJpdHJhdGUgIT09IGIuYXZlcmFnZUJpdHJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuYXZlcmFnZUJpdHJhdGUgLSBiLmF2ZXJhZ2VCaXRyYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICBsZXQgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1swXTtcbiAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgbGV2ZWxzID0gdGhpcy5zdGVlcmluZy5maWx0ZXJQYXJzZWRMZXZlbHMobGV2ZWxzKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoICE9PSB1bnNvcnRlZExldmVscy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnNvcnRlZExldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh1bnNvcnRlZExldmVsc1tpXS5wYXRod2F5SWQgPT09IGxldmVsc1swXS5wYXRod2F5SWQpIHtcbiAgICAgICAgICAgIGZpcnN0TGV2ZWxJblBsYXlsaXN0ID0gdW5zb3J0ZWRMZXZlbHNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG5cbiAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXSA9PT0gZmlyc3RMZXZlbEluUGxheWxpc3QpIHtcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IGk7XG4gICAgICAgIGNvbnN0IGZpcnN0TGV2ZWxCaXRyYXRlID0gZmlyc3RMZXZlbEluUGxheWxpc3QuYml0cmF0ZTtcbiAgICAgICAgY29uc3QgYmFuZHdpZHRoRXN0aW1hdGUgPSB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZTtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYG1hbmlmZXN0IGxvYWRlZCwgJHtsZXZlbHMubGVuZ3RofSBsZXZlbChzKSBmb3VuZCwgZmlyc3QgYml0cmF0ZTogJHtmaXJzdExldmVsQml0cmF0ZX1gLFxuICAgICAgICApO1xuICAgICAgICAvLyBVcGRhdGUgZGVmYXVsdCBid2UgdG8gZmlyc3QgdmFyaWFudCBiaXRyYXRlIGFzIGxvbmcgaXQgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQgb3Igc2V0XG4gICAgICAgIGlmICh0aGlzLmhscy51c2VyQ29uZmlnPy5hYnJFd21hRGVmYXVsdEVzdGltYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBzdGFydGluZ0J3RXN0aW1hdGUgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGZpcnN0TGV2ZWxCaXRyYXRlLFxuICAgICAgICAgICAgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXgsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGFydGluZ0J3RXN0aW1hdGUgPiBiYW5kd2lkdGhFc3RpbWF0ZSAmJlxuICAgICAgICAgICAgYmFuZHdpZHRoRXN0aW1hdGUgPT09IGhsc0RlZmF1bHRDb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5obHMuYmFuZHdpZHRoRXN0aW1hdGUgPSBzdGFydGluZ0J3RXN0aW1hdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF1ZGlvIGlzIG9ubHkgYWx0ZXJuYXRlIGlmIG1hbmlmZXN0IGluY2x1ZGUgYSBVUkkgYWxvbmcgd2l0aCB0aGUgYXVkaW8gZ3JvdXAgdGFnLFxuICAgIC8vIGFuZCB0aGlzIGlzIG5vdCBhbiBhdWRpby1vbmx5IHN0cmVhbSB3aGVyZSBsZXZlbHMgY29udGFpbiBhdWRpby1vbmx5XG4gICAgY29uc3QgYXVkaW9Pbmx5ID0gYXVkaW9Db2RlY0ZvdW5kICYmICF2aWRlb0NvZGVjRm91bmQ7XG4gICAgY29uc3QgZWRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YSA9IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVUcmFja3MsXG4gICAgICBzZXNzaW9uRGF0YTogZGF0YS5zZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzOiBkYXRhLnNlc3Npb25LZXlzLFxuICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcbiAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsXG4gICAgICBhbHRBdWRpbzogIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKCh0KSA9PiAhIXQudXJsKSxcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuXG4gICAgLy8gSW5pdGlhdGUgbG9hZGluZyBhZnRlciBhbGwgY29udHJvbGxlcnMgaGF2ZSByZWNlaXZlZCBNQU5JRkVTVF9QQVJTRURcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZCh0aGlzLmhscy5jb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxldmVscygpOiBMZXZlbFtdIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG5cbiAgZ2V0IGxldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gIH1cblxuICBzZXQgbGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcbiAgICBpZiAobGV2ZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBsZXZlbCBpZHggaXMgdmFsaWRcbiAgICBpZiAobmV3TGV2ZWwgPCAwIHx8IG5ld0xldmVsID49IGxldmVscy5sZW5ndGgpIHtcbiAgICAgIC8vIGludmFsaWQgbGV2ZWwgaWQgZ2l2ZW4sIHRyaWdnZXIgZXJyb3JcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdpbnZhbGlkIGxldmVsIGlkeCcpO1xuICAgICAgY29uc3QgZmF0YWwgPSBuZXdMZXZlbCA8IDA7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogbmV3TGV2ZWwsXG4gICAgICAgIGZhdGFsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgICBjb25zdCBsYXN0TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCBsYXN0UGF0aHdheUlkID0gbGFzdExldmVsID8gbGFzdExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10gOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxdO1xuICAgIGNvbnN0IHBhdGh3YXlJZCA9IGxldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG5cbiAgICBpZiAoXG4gICAgICBsYXN0TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiZcbiAgICAgIGxldmVsLmRldGFpbHMgJiZcbiAgICAgIGxhc3RMZXZlbCAmJlxuICAgICAgbGFzdFBhdGh3YXlJZCA9PT0gcGF0aHdheUlkXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2coXG4gICAgICBgU3dpdGNoaW5nIHRvIGxldmVsICR7bmV3TGV2ZWx9ICgke1xuICAgICAgICBsZXZlbC5oZWlnaHQgPyBsZXZlbC5oZWlnaHQgKyAncCAnIDogJydcbiAgICAgIH0ke2xldmVsLnZpZGVvUmFuZ2UgPyBsZXZlbC52aWRlb1JhbmdlICsgJyAnIDogJyd9JHtcbiAgICAgICAgbGV2ZWwuY29kZWNTZXQgPyBsZXZlbC5jb2RlY1NldCArICcgJyA6ICcnXG4gICAgICB9QCR7bGV2ZWwuYml0cmF0ZX0pJHtcbiAgICAgICAgcGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnXG4gICAgICB9IGZyb20gbGV2ZWwgJHtsYXN0TGV2ZWxJbmRleH0ke1xuICAgICAgICBsYXN0UGF0aHdheUlkID8gJyB3aXRoIFBhdGh3YXkgJyArIGxhc3RQYXRod2F5SWQgOiAnJ1xuICAgICAgfWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGxldmVsU3dpdGNoaW5nRGF0YTogTGV2ZWxTd2l0Y2hpbmdEYXRhID0ge1xuICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgYXR0cnM6IGxldmVsLmF0dHJzLFxuICAgICAgZGV0YWlsczogbGV2ZWwuZGV0YWlscyxcbiAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICBhdmVyYWdlQml0cmF0ZTogbGV2ZWwuYXZlcmFnZUJpdHJhdGUsXG4gICAgICBtYXhCaXRyYXRlOiBsZXZlbC5tYXhCaXRyYXRlLFxuICAgICAgcmVhbEJpdHJhdGU6IGxldmVsLnJlYWxCaXRyYXRlLFxuICAgICAgd2lkdGg6IGxldmVsLndpZHRoLFxuICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICBjb2RlY1NldDogbGV2ZWwuY29kZWNTZXQsXG4gICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYzogbGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgIGF1ZGlvR3JvdXBzOiBsZXZlbC5hdWRpb0dyb3VwcyxcbiAgICAgIHN1YnRpdGxlR3JvdXBzOiBsZXZlbC5zdWJ0aXRsZUdyb3VwcyxcbiAgICAgIGxvYWRlZDogbGV2ZWwubG9hZGVkLFxuICAgICAgbG9hZEVycm9yOiBsZXZlbC5sb2FkRXJyb3IsXG4gICAgICBmcmFnbWVudEVycm9yOiBsZXZlbC5mcmFnbWVudEVycm9yLFxuICAgICAgbmFtZTogbGV2ZWwubmFtZSxcbiAgICAgIGlkOiBsZXZlbC5pZCxcbiAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgdXJsOiBsZXZlbC51cmwsXG4gICAgICB1cmxJZDogMCxcbiAgICAgIGF1ZGlvR3JvdXBJZHM6IGxldmVsLmF1ZGlvR3JvdXBJZHMsXG4gICAgICB0ZXh0R3JvdXBJZHM6IGxldmVsLnRleHRHcm91cElkcyxcbiAgICB9O1xuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbD8uZGV0YWlscyk7XG4gICAgICB0aGlzLmxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFudWFsTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG5cbiAgc2V0IG1hbnVhbExldmVsKG5ld0xldmVsKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gbmV3TGV2ZWw7XG4gICAgaWYgKHRoaXMuX3N0YXJ0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3RhcnRMZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cblxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gIH1cblxuICBnZXQgZmlyc3RMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9maXJzdExldmVsO1xuICB9XG5cbiAgc2V0IGZpcnN0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICB0aGlzLl9maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICBnZXQgc3RhcnRMZXZlbCgpOiBudW1iZXIge1xuICAgIC8vIFNldHRpbmcgaGxzLnN0YXJ0TGV2ZWwgKHRoaXMuX3N0YXJ0TGV2ZWwpIG92ZXJyaWRlcyBjb25maWcuc3RhcnRMZXZlbFxuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1N0YXJ0TGV2ZWwgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIGlmIChjb25maWdTdGFydExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ1N0YXJ0TGV2ZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICB9XG5cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkVycm9yKGV2ZW50OiBFdmVudHMuRVJST1IsIGRhdGE6IEVycm9yRGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBkYXRhLmNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5MRVZFTCAmJlxuICAgICAgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsXG4gICAgKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBwcm90ZWN0ZWQgb25GcmFnQnVmZmVyZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5GUkFHX0JVRkZFUkVELFxuICAgIHsgZnJhZyB9OiBGcmFnQnVmZmVyZWREYXRhLFxuICApIHtcbiAgICBpZiAoZnJhZyAhPT0gdW5kZWZpbmVkICYmIGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgY29uc3QgZWwgPSBmcmFnLmVsZW1lbnRhcnlTdHJlYW1zO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZSgodHlwZSkgPT4gISFlbFt0eXBlXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWw/LmxvYWRFcnJvcikge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgUmVzZXR0aW5nIGxldmVsIGVycm9yIGNvdW50IG9mICR7bGV2ZWwubG9hZEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCxcbiAgICAgICAgKTtcbiAgICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25MZXZlbExvYWRlZChldmVudDogRXZlbnRzLkxFVkVMX0xPQURFRCwgZGF0YTogTGV2ZWxMb2FkZWREYXRhKSB7XG4gICAgY29uc3QgeyBsZXZlbCwgZGV0YWlscyB9ID0gZGF0YTtcbiAgICBjb25zdCBjdXJMZXZlbCA9IHRoaXMuX2xldmVsc1tsZXZlbF07XG5cbiAgICBpZiAoIWN1ckxldmVsKSB7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgbGV2ZWwgaW5kZXggJHtsZXZlbH1gKTtcbiAgICAgIGlmIChkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcz8uc2tpcCkge1xuICAgICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IHByb2Nlc3MgbGV2ZWwgbG9hZGVkIGV2ZW50cyBtYXRjaGluZyB3aXRoIGV4cGVjdGVkIGxldmVsXG4gICAgaWYgKGxldmVsID09PSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KSB7XG4gICAgICAvLyByZXNldCBsZXZlbCBsb2FkIGVycm9yIGNvdW50ZXIgb24gc3VjY2Vzc2Z1bCBsZXZlbCBsb2FkZWQgb25seSBpZiB0aGVyZSBpcyBubyBpc3N1ZXMgd2l0aCBmcmFnbWVudHNcbiAgICAgIGlmIChjdXJMZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIGN1ckxldmVsLmxvYWRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlsaXN0TG9hZGVkKGxldmVsLCBkYXRhLCBjdXJMZXZlbC5kZXRhaWxzKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzPy5za2lwKSB7XG4gICAgICAvLyByZWNlaXZlZCBhIGRlbHRhIHBsYXlsaXN0IHVwZGF0ZSB0aGF0IGNhbm5vdCBiZSBtZXJnZWRcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycz86IEhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG5cbiAgICBpZiAoY3VycmVudExldmVsICYmIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgIGxldCB1cmwgPSBjdXJyZW50TGV2ZWwudXJpO1xuICAgICAgaWYgKGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cmwgPSBobHNVcmxQYXJhbWV0ZXJzLmFkZERpcmVjdGl2ZXModXJsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICBgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IGN1cnJlbnRMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBMb2FkaW5nIGxldmVsIGluZGV4ICR7Y3VycmVudExldmVsSW5kZXh9JHtcbiAgICAgICAgICBobHNVcmxQYXJhbWV0ZXJzPy5tc24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAnIGF0IHNuICcgK1xuICAgICAgICAgICAgICBobHNVcmxQYXJhbWV0ZXJzLm1zbiArXG4gICAgICAgICAgICAgICcgcGFydCAnICtcbiAgICAgICAgICAgICAgaGxzVXJsUGFyYW1ldGVycy5wYXJ0XG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH0gd2l0aCR7cGF0aHdheUlkID8gJyBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ30gJHt1cmx9YCxcbiAgICAgICk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdDdXJyZW50IGF1ZGlvIHRyYWNrIGdyb3VwIElEOicsIHRoaXMuaGxzLmF1ZGlvVHJhY2tzW3RoaXMuaGxzLmF1ZGlvVHJhY2tdLmdyb3VwSWQpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ05ldyB2aWRlbyBxdWFsaXR5IGxldmVsIGF1ZGlvIGdyb3VwIGlkOicsIGxldmVsT2JqZWN0LmF0dHJzLkFVRElPLCBsZXZlbCk7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgICAgdXJsLFxuICAgICAgICBsZXZlbDogY3VycmVudExldmVsSW5kZXgsXG4gICAgICAgIHBhdGh3YXlJZDogY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ10sXG4gICAgICAgIGlkOiAwLCAvLyBEZXByZWNhdGVkIExldmVsIHVybElkXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hbnVhbExldmVsSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmhscy5uZXh0QXV0b0xldmVsO1xuICAgIH1cbiAgfVxuXG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgbGV2ZWxzID0gdGhpcy5fbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggIT09IGxldmVsSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGVlcmluZykge1xuICAgICAgICB0aGlzLnN0ZWVyaW5nLnJlbW92ZUxldmVsKGxldmVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChsZXZlbC5kZXRhaWxzKSB7XG4gICAgICAgICAgbGV2ZWwuZGV0YWlscy5mcmFnbWVudHMuZm9yRWFjaCgoZikgPT4gKGYubGV2ZWwgPSAtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpO1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA+IC0xICYmIHRoaXMuY3VycmVudExldmVsPy5kZXRhaWxzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gdGhpcy5jdXJyZW50TGV2ZWwuZGV0YWlscy5mcmFnbWVudHNbMF0ubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMU19VUERBVEVELCB7IGxldmVscyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25MZXZlbHNVcGRhdGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTEVWRUxTX1VQREFURUQsXG4gICAgeyBsZXZlbHMgfTogTGV2ZWxzVXBkYXRlZERhdGEsXG4gICkge1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgfVxuXG4gIHB1YmxpYyBjaGVja01heEF1dG9VcGRhdGVkKCkge1xuICAgIGNvbnN0IHsgYXV0b0xldmVsQ2FwcGluZywgbWF4QXV0b0xldmVsLCBtYXhIZGNwTGV2ZWwgfSA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLl9tYXhBdXRvTGV2ZWwgIT09IG1heEF1dG9MZXZlbCkge1xuICAgICAgdGhpcy5fbWF4QXV0b0xldmVsID0gbWF4QXV0b0xldmVsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwge1xuICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgICBsZXZlbHM6IHRoaXMubGV2ZWxzLFxuICAgICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbDogdGhpcy5obHMubWluQXV0b0xldmVsLFxuICAgICAgICBtYXhIZGNwTGV2ZWwsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrczogTWVkaWFQbGF5bGlzdFtdKTogdm9pZCB7XG4gIGNvbnN0IGdyb3VwcyA9IHt9O1xuICB0cmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICBjb25zdCBncm91cElkID0gdHJhY2suZ3JvdXBJZCB8fCAnJztcbiAgICB0cmFjay5pZCA9IGdyb3Vwc1tncm91cElkXSA9IGdyb3Vwc1tncm91cElkXSB8fCAwO1xuICAgIGdyb3Vwc1tncm91cElkXSsrO1xuICB9KTtcbn1cbiIsImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBGcmFnbWVudCwgUGFydCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgdHlwZSB7IFNvdXJjZUJ1ZmZlck5hbWUgfSBmcm9tICcuLi90eXBlcy9idWZmZXInO1xuaW1wb3J0IHR5cGUge1xuICBGcmFnbWVudEJ1ZmZlcmVkUmFuZ2UsXG4gIEZyYWdtZW50RW50aXR5LFxuICBGcmFnbWVudFRpbWVSYW5nZSxcbn0gZnJvbSAnLi4vdHlwZXMvZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUge1xuICBCdWZmZXJBcHBlbmRlZERhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5cbmV4cG9ydCBjb25zdCBlbnVtIEZyYWdtZW50U3RhdGUge1xuICBOT1RfTE9BREVEID0gJ05PVF9MT0FERUQnLFxuICBBUFBFTkRJTkcgPSAnQVBQRU5ESU5HJyxcbiAgUEFSVElBTCA9ICdQQVJUSUFMJyxcbiAgT0sgPSAnT0snLFxufVxuXG5leHBvcnQgY2xhc3MgRnJhZ21lbnRUcmFja2VyIGltcGxlbWVudHMgQ29tcG9uZW50QVBJIHtcbiAgcHJpdmF0ZSBhY3RpdmVQYXJ0TGlzdHM6IHsgW2tleSBpbiBQbGF5bGlzdExldmVsVHlwZV0/OiBQYXJ0W10gfSA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSBlbmRMaXN0RnJhZ21lbnRzOiB7IFtrZXkgaW4gUGxheWxpc3RMZXZlbFR5cGVdPzogRnJhZ21lbnRFbnRpdHkgfSA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSBmcmFnbWVudHM6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgRnJhZ21lbnRFbnRpdHk+PiA9XG4gICAgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcHJpdmF0ZSB0aW1lUmFuZ2VzOlxuICAgIHwge1xuICAgICAgICBba2V5IGluIFNvdXJjZUJ1ZmZlck5hbWVdPzogVGltZVJhbmdlcztcbiAgICAgIH1cbiAgICB8IG51bGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHByaXZhdGUgYnVmZmVyUGFkZGluZzogbnVtYmVyID0gMC4yO1xuICBwcml2YXRlIGhsczogSGxzO1xuICBwcml2YXRlIGhhc0dhcHM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihobHM6IEhscykge1xuICAgIHRoaXMuaGxzID0gaGxzO1xuXG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID1cbiAgICAgIHRoaXMudGltZVJhbmdlcyA9XG4gICAgICAgIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBwdWJsaWMgZ2V0QXBwZW5kZWRGcmFnKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgbGV2ZWxUeXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgKTogRnJhZ21lbnQgfCBQYXJ0IHwgbnVsbCB7XG4gICAgY29uc3QgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdO1xuICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZVBhcnRzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29uc3QgYWN0aXZlUGFydCA9IGFjdGl2ZVBhcnRzW2ldO1xuICAgICAgICBpZiAoIWFjdGl2ZVBhcnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRlZFBUUyA9IGFjdGl2ZVBhcnQuZW5kO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0aXZlUGFydC5zdGFydCA8PSBwb3NpdGlvbiAmJlxuICAgICAgICAgIGFwcGVuZGVkUFRTICE9PSBudWxsICYmXG4gICAgICAgICAgcG9zaXRpb24gPD0gYXBwZW5kZWRQVFNcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGJ1ZmZlcmVkIEZyYWdtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZS5cbiAgICogQSBidWZmZXJlZCBGcmFnbWVudCBpcyBvbmUgd2hvc2UgbG9hZGluZywgcGFyc2luZyBhbmQgYXBwZW5kaW5nIGlzIGRvbmUgKGNvbXBsZXRlZCBvciBcInBhcnRpYWxcIiBtZWFuaW5nIGFib3J0ZWQpLlxuICAgKiBJZiBub3QgZm91bmQgYW55IEZyYWdtZW50LCByZXR1cm4gbnVsbFxuICAgKi9cbiAgcHVibGljIGdldEJ1ZmZlcmVkRnJhZyhcbiAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgIGxldmVsVHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgeyBmcmFnbWVudHMgfSA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICBpZiAoZnJhZ21lbnRFbnRpdHk/LmJvZHkudHlwZSA9PT0gbGV2ZWxUeXBlICYmIGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudEVudGl0eS5ib2R5O1xuICAgICAgICBpZiAoZnJhZy5zdGFydCA8PSBwb3NpdGlvbiAmJiBwb3NpdGlvbiA8PSBmcmFnLmVuZCkge1xuICAgICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBUaGUgYnJvd3NlciB3aWxsIHVubG9hZCBwYXJ0cyBvZiB0aGUgYnVmZmVyIHRvIGZyZWUgdXAgbWVtb3J5IGZvciBuZXcgYnVmZmVyIGRhdGFcbiAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXG4gICAqL1xuICBwdWJsaWMgZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICBlbGVtZW50YXJ5U3RyZWFtOiBTb3VyY2VCdWZmZXJOYW1lLFxuICAgIHRpbWVSYW5nZTogVGltZVJhbmdlcyxcbiAgICBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIGFwcGVuZGVkUGFydD86IFBhcnQgfCBudWxsLFxuICApIHtcbiAgICBpZiAodGhpcy50aW1lUmFuZ2VzKSB7XG4gICAgICB0aGlzLnRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gPSB0aW1lUmFuZ2U7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGFueSBmbGFnZ2VkIGZyYWdtZW50cyBoYXZlIGJlZW4gdW5sb2FkZWRcbiAgICAvLyBleGNsdWRpbmcgYW55dGhpbmcgbmV3ZXIgdGhhbiBhcHBlbmRlZFBhcnRTblxuICAgIGNvbnN0IGFwcGVuZGVkUGFydFNuID0gKGFwcGVuZGVkUGFydD8uZnJhZ21lbnQuc24gfHwgLTEpIGFzIG51bWJlcjtcbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSAoZnJhZ21lbnRFbnRpdHkuYm9keS5zbiBhcyBudW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFlc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNEYXRhLnRpbWUuc29tZSgodGltZTogRnJhZ21lbnRUaW1lUmFuZ2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNOb3RCdWZmZXJlZCA9ICF0aGlzLmlzVGltZUJ1ZmZlcmVkKFxuICAgICAgICAgIHRpbWUuc3RhcnRQVFMsXG4gICAgICAgICAgdGltZS5lbmRQVFMsXG4gICAgICAgICAgdGltZVJhbmdlLFxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTm90QnVmZmVyZWQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBwdWJsaWMgZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhkYXRhOiBGcmFnQnVmZmVyZWREYXRhKSB7XG4gICAgY29uc3QgdGltZVJhbmdlcyA9IHRoaXMudGltZVJhbmdlcztcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQgfSA9IGRhdGE7XG4gICAgaWYgKCF0aW1lUmFuZ2VzIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5IHx8IChmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiBmcmFnLmdhcCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNGcmFnSGludCA9ICFmcmFnLnJlbHVybDtcbiAgICBPYmplY3Qua2V5cyh0aW1lUmFuZ2VzKS5mb3JFYWNoKChlbGVtZW50YXJ5U3RyZWFtOiBTb3VyY2VCdWZmZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dIGFzIFRpbWVSYW5nZXM7XG4gICAgICBjb25zdCBwYXJ0aWFsID0gaXNGcmFnSGludCB8fCBzdHJlYW1JbmZvLnBhcnRpYWwgPT09IHRydWU7XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZVtlbGVtZW50YXJ5U3RyZWFtXSA9IHRoaXMuZ2V0QnVmZmVyZWRUaW1lcyhcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdGltZVJhbmdlLFxuICAgICAgKTtcbiAgICB9KTtcbiAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgIGlmIChPYmplY3Qua2V5cyhmcmFnbWVudEVudGl0eS5yYW5nZSkubGVuZ3RoKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICBjb25zdCBlbmRMaXN0ID0gKGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdCA9XG4gICAgICAgIGZyYWcuZW5kTGlzdCB8fCBmcmFnbWVudEVudGl0eS5ib2R5LmVuZExpc3QpO1xuICAgICAgaWYgKGVuZExpc3QpIHtcbiAgICAgICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50RW50aXR5LmJvZHkudHlwZV0gPSBmcmFnbWVudEVudGl0eTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICAvLyBSZW1vdmUgb2xkZXIgZnJhZ21lbnQgcGFydHMgZnJvbSBsb29rdXAgYWZ0ZXIgZnJhZyBpcyB0cmFja2VkIGFzIGJ1ZmZlcmVkXG4gICAgICAgIHRoaXMucmVtb3ZlUGFydHMoKGZyYWcuc24gYXMgbnVtYmVyKSAtIDEsIGZyYWcudHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBmcmFnbWVudCBpZiBub3RoaW5nIHdhcyBhcHBlbmRlZFxuICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChmcmFnbWVudEVudGl0eS5ib2R5KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVBhcnRzKHNuVG9LZWVwOiBudW1iZXIsIGxldmVsVHlwZTogUGxheWxpc3RMZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKFxuICAgICAgKHBhcnQpID0+IChwYXJ0LmZyYWdtZW50LnNuIGFzIG51bWJlcikgPj0gc25Ub0tlZXAsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBmcmFnQnVmZmVyZWQoZnJhZzogRnJhZ21lbnQsIGZvcmNlPzogdHJ1ZSkge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICBsZXQgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgICBpZiAoIWZyYWdtZW50RW50aXR5ICYmIGZvcmNlKSB7XG4gICAgICBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldID0ge1xuICAgICAgICBib2R5OiBmcmFnLFxuICAgICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgICAgbG9hZGVkOiBudWxsLFxuICAgICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgfTtcbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICB0aGlzLmhhc0dhcHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5LmxvYWRlZCA9IG51bGw7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWZmZXJlZFRpbWVzKFxuICAgIGZyYWdtZW50OiBGcmFnbWVudCxcbiAgICBwYXJ0OiBQYXJ0IHwgbnVsbCxcbiAgICBwYXJ0aWFsOiBib29sZWFuLFxuICAgIHRpbWVSYW5nZTogVGltZVJhbmdlcyxcbiAgKTogRnJhZ21lbnRCdWZmZXJlZFJhbmdlIHtcbiAgICBjb25zdCBidWZmZXJlZDogRnJhZ21lbnRCdWZmZXJlZFJhbmdlID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsLFxuICAgIH07XG4gICAgY29uc3Qgc3RhcnRQVFMgPSBmcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBlbmRQVFMgPSBmcmFnbWVudC5lbmQ7XG4gICAgY29uc3QgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICBjb25zdCBtYXhTdGFydFBUUyA9IGZyYWdtZW50Lm1heFN0YXJ0UFRTIHx8IHN0YXJ0UFRTO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBjb25zdCBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciB0aW1lUmFuZ2UgdGltZXMgc2luY2UgaXQncyBjb21wbGV0ZWx5IHBsYXlhYmxlXG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBUUyA8IGVuZFRpbWUgJiYgZW5kUFRTID4gc3RhcnRUaW1lKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnRQVFMsIHRpbWVSYW5nZS5zdGFydChpKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGVuZFBUUywgdGltZVJhbmdlLmVuZChpKSk7XG4gICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgIGJ1ZmZlcmVkLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb24gd2l0aCBidWZmZXJcbiAgICAgICAgICAvLyBHZXQgcGxheWFibGUgc2VjdGlvbnMgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgICAgYnVmZmVyZWQudGltZS5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0UFRTOiBzdGFydCxcbiAgICAgICAgICAgIGVuZFBUUzogZW5kLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFydGlhbCBmcmFnbWVudCBmb3IgYSBjZXJ0YWluIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRQYXJ0aWFsRnJhZ21lbnQodGltZTogbnVtYmVyKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBsZXQgYmVzdEZyYWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGxldCB0aW1lUGFkZGluZzogbnVtYmVyO1xuICAgIGxldCBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBsZXQgZW5kVGltZTogbnVtYmVyO1xuICAgIGxldCBiZXN0T3ZlcmxhcDogbnVtYmVyID0gMDtcbiAgICBjb25zdCB7IGJ1ZmZlclBhZGRpbmcsIGZyYWdtZW50cyB9ID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhmcmFnbWVudHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZCArIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmICh0aW1lID49IHN0YXJ0VGltZSAmJiB0aW1lIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH1cblxuICBwdWJsaWMgaXNFbmRMaXN0QXBwZW5kZWQodHlwZTogUGxheWxpc3RMZXZlbFR5cGUpOiBib29sZWFuIHtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnRFbnRpdHkgPSB0aGlzLmVuZExpc3RGcmFnbWVudHNbdHlwZV07XG4gICAgcmV0dXJuIChcbiAgICAgIGxhc3RGcmFnbWVudEVudGl0eSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAobGFzdEZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IGlzUGFydGlhbChsYXN0RnJhZ21lbnRFbnRpdHkpKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3RhdGUoZnJhZ21lbnQ6IEZyYWdtZW50KTogRnJhZ21lbnRTdGF0ZSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuXG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgIH0gZWxzZSBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRDtcbiAgfVxuXG4gIHByaXZhdGUgaXNUaW1lQnVmZmVyZWQoXG4gICAgc3RhcnRQVFM6IG51bWJlcixcbiAgICBlbmRQVFM6IG51bWJlcixcbiAgICB0aW1lUmFuZ2U6IFRpbWVSYW5nZXMsXG4gICk6IGJvb2xlYW4ge1xuICAgIGxldCBzdGFydFRpbWU7XG4gICAgbGV0IGVuZFRpbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lUmFuZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVSYW5nZS5zdGFydChpKSAtIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGVuZFRpbWUgPSB0aW1lUmFuZ2UuZW5kKGkpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKHN0YXJ0UFRTID49IHN0YXJ0VGltZSAmJiBlbmRQVFMgPD0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uRnJhZ0xvYWRlZChldmVudDogRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhOiBGcmFnTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgZnJhZywgcGFydCB9ID0gZGF0YTtcbiAgICAvLyBkb24ndCB0cmFjayBpbml0c2VnbWVudCAoZm9yIHdoaWNoIHNuIGlzIG5vdCBhIG51bWJlcilcbiAgICAvLyBkb24ndCB0cmFjayBmcmFncyB1c2VkIGZvciBiaXRyYXRlVGVzdCwgdGhleSdyZSBpcnJlbGV2YW50LlxuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGcmFnbWVudCBlbnRpdHkgYGxvYWRlZGAgRnJhZ0xvYWRlZERhdGEgaXMgbnVsbCB3aGVuIGxvYWRpbmcgcGFydHNcbiAgICBjb25zdCBsb2FkZWQgPSBwYXJ0ID8gbnVsbCA6IGRhdGE7XG5cbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZyk7XG4gICAgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICBib2R5OiBmcmFnLFxuICAgICAgYXBwZW5kZWRQVFM6IG51bGwsXG4gICAgICBsb2FkZWQsXG4gICAgICBidWZmZXJlZDogZmFsc2UsXG4gICAgICByYW5nZTogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBvbkJ1ZmZlckFwcGVuZGVkKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0FQUEVOREVELFxuICAgIGRhdGE6IEJ1ZmZlckFwcGVuZGVkRGF0YSxcbiAgKSB7XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0LCB0aW1lUmFuZ2VzIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZTtcbiAgICBpZiAocGFydCkge1xuICAgICAgbGV0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXTtcbiAgICAgIGlmICghYWN0aXZlUGFydHMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbcGxheWxpc3RUeXBlXSA9IGFjdGl2ZVBhcnRzID0gW107XG4gICAgICB9XG4gICAgICBhY3RpdmVQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHRpbWVSYW5nZXMgbG9hZGVkIGluIHRoZSBidWZmZXJcbiAgICB0aGlzLnRpbWVSYW5nZXMgPSB0aW1lUmFuZ2VzO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goKGVsZW1lbnRhcnlTdHJlYW06IFNvdXJjZUJ1ZmZlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV0gYXMgVGltZVJhbmdlcztcbiAgICAgIHRoaXMuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICAgICAgZWxlbWVudGFyeVN0cmVhbSxcbiAgICAgICAgdGltZVJhbmdlLFxuICAgICAgICBwbGF5bGlzdFR5cGUsXG4gICAgICAgIHBhcnQsXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdCdWZmZXJlZChldmVudDogRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGRhdGE6IEZyYWdCdWZmZXJlZERhdGEpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGhhc0ZyYWdtZW50KGZyYWdtZW50OiBGcmFnbWVudCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnbWVudCk7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gIH1cblxuICBwdWJsaWMgaGFzUGFydHModHlwZTogUGxheWxpc3RMZXZlbFR5cGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmFjdGl2ZVBhcnRMaXN0c1t0eXBlXT8ubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUZyYWdtZW50c0luUmFuZ2UoXG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIHdpdGhHYXBPbmx5PzogYm9vbGVhbixcbiAgICB1bmJ1ZmZlcmVkT25seT86IGJvb2xlYW4sXG4gICkge1xuICAgIGlmICh3aXRoR2FwT25seSAmJiAhdGhpcy5oYXNHYXBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICBpZiAoZnJhZy50eXBlICE9PSBwbGF5bGlzdFR5cGUgfHwgKHdpdGhHYXBPbmx5ICYmICFmcmFnLmdhcCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBmcmFnLnN0YXJ0IDwgZW5kICYmXG4gICAgICAgIGZyYWcuZW5kID4gc3RhcnQgJiZcbiAgICAgICAgKGZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkIHx8IHVuYnVmZmVyZWRPbmx5KVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQ6IEZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICBmcmFnbWVudC5zdGF0cy5sb2FkZWQgPSAwO1xuICAgIGZyYWdtZW50LmNsZWFyRWxlbWVudGFyeVN0cmVhbUluZm8oKTtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2ZyYWdtZW50LnR5cGVdO1xuICAgIGlmIChhY3RpdmVQYXJ0cykge1xuICAgICAgY29uc3Qgc25Ub1JlbW92ZSA9IGZyYWdtZW50LnNuO1xuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV0gPSBhY3RpdmVQYXJ0cy5maWx0ZXIoXG4gICAgICAgIChwYXJ0KSA9PiBwYXJ0LmZyYWdtZW50LnNuICE9PSBzblRvUmVtb3ZlLFxuICAgICAgKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmIChmcmFnbWVudC5lbmRMaXN0KSB7XG4gICAgICBkZWxldGUgdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2ZyYWdtZW50LnR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVBbGxGcmFnbWVudHMoKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuaGFzR2FwcyA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUGFydGlhbChmcmFnbWVudEVudGl0eTogRnJhZ21lbnRFbnRpdHkpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJlxuICAgIChmcmFnbWVudEVudGl0eS5ib2R5LmdhcCB8fFxuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8/LnBhcnRpYWwgfHxcbiAgICAgIGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvPy5wYXJ0aWFsIHx8XG4gICAgICBmcmFnbWVudEVudGl0eS5yYW5nZS5hdWRpb3ZpZGVvPy5wYXJ0aWFsKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRGcmFnbWVudEtleShmcmFnbWVudDogRnJhZ21lbnQpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7ZnJhZ21lbnQudHlwZX1fJHtmcmFnbWVudC5sZXZlbH1fJHtmcmFnbWVudC5zbn1gO1xufVxuIiwiaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9mcmFnbWVudCc7XG5pbXBvcnQge1xuICBMb2FkZXIsXG4gIExvYWRlckNvbmZpZ3VyYXRpb24sXG4gIEZyYWdtZW50TG9hZGVyQ29udGV4dCxcbn0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMgfSBmcm9tICcuLi91dGlscy9lcnJvci1oZWxwZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBCYXNlU2VnbWVudCwgUGFydCB9IGZyb20gJy4vZnJhZ21lbnQnO1xuaW1wb3J0IHR5cGUge1xuICBFcnJvckRhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBQYXJ0c0xvYWRlZERhdGEsXG59IGZyb20gJy4uL3R5cGVzL2V2ZW50cyc7XG5cbmNvbnN0IE1JTl9DSFVOS19TSVpFID0gTWF0aC5wb3coMiwgMTcpOyAvLyAxMjhrYlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFnbWVudExvYWRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgbG9hZGVyOiBMb2FkZXI8RnJhZ21lbnRMb2FkZXJDb250ZXh0PiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHBhcnRMb2FkVGltZW91dDogbnVtYmVyID0gLTE7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBIbHNDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIG9uUHJvZ3Jlc3M/OiBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrLFxuICApOiBQcm9taXNlPEZyYWdMb2FkZWREYXRhPiB7XG4gICAgY29uc3QgdXJsID0gZnJhZy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGcmFnbWVudCBkb2VzIG5vdCBoYXZlIGEgJHt1cmwgPyAncGFydCBsaXN0JyA6ICd1cmwnfWAsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmFib3J0KCk7XG5cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCkge1xuICAgICAgICBpZiAoZnJhZy50YWdMaXN0LnNvbWUoKHRhZ3MpID0+IHRhZ3NbMF0gPT09ICdHQVAnKSkge1xuICAgICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZykpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXNldCB0ZW1wb3JhcnkgdHJlYXRtZW50IGFzIEdBUCB0YWdcbiAgICAgICAgICBmcmFnLmdhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXIgPVxuICAgICAgICAodGhpcy5sb2FkZXIgPVxuICAgICAgICBmcmFnLmxvYWRlciA9XG4gICAgICAgICAgRnJhZ21lbnRJTG9hZGVyXG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKVxuICAgICAgICAgICAgOiAobmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD4pKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcpO1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoXG4gICAgICAgIGNvbmZpZy5mcmFnTG9hZFBvbGljeS5kZWZhdWx0LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyA/IEluZmluaXR5IDogTUlOX0NIVU5LX1NJWkUsXG4gICAgICB9O1xuICAgICAgLy8gQXNzaWduIGZyYWcgc3RhdHMgdG8gdGhlIGxvYWRlcidzIHN0YXRzIHJlZmVyZW5jZVxuICAgICAgZnJhZy5zdGF0cyA9IGxvYWRlci5zdGF0cztcbiAgICAgIGxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIGxldCBwYXlsb2FkID0gcmVzcG9uc2UuZGF0YSBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgICBpZiAoY29udGV4dC5yZXNldElWICYmIGZyYWcuZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgICAgIGZyYWcuZGVjcnlwdGRhdGEuaXYgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDAsIDE2KSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZC5zbGljZSgxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHsgdXJsLCBkYXRhOiB1bmRlZmluZWQsIC4uLnJlc3BvbnNlIH0sXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignQWJvcnRlZCcpLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYFRpbWVvdXQgYWZ0ZXIgJHtsb2FkZXJDb25maWcudGltZW91dH1tc2ApLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGxvYWRQYXJ0KFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIHBhcnQ6IFBhcnQsXG4gICAgb25Qcm9ncmVzczogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFjayxcbiAgKTogUHJvbWlzZTxGcmFnTG9hZGVkRGF0YT4ge1xuICAgIHRoaXMuYWJvcnQoKTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuZ2FwIHx8IHBhcnQuZ2FwKSB7XG4gICAgICAgIHJlamVjdChjcmVhdGVHYXBMb2FkRXJyb3IoZnJhZywgcGFydCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZXIgPVxuICAgICAgICAodGhpcy5sb2FkZXIgPVxuICAgICAgICBmcmFnLmxvYWRlciA9XG4gICAgICAgICAgRnJhZ21lbnRJTG9hZGVyXG4gICAgICAgICAgICA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKVxuICAgICAgICAgICAgOiAobmV3IERlZmF1bHRJTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPEZyYWdtZW50TG9hZGVyQ29udGV4dD4pKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcsIHBhcnQpO1xuICAgICAgLy8gU2hvdWxkIHdlIGRlZmluZSBhbm90aGVyIGxvYWQgcG9saWN5IGZvciBwYXJ0cz9cbiAgICAgIGNvbnN0IGxvYWRQb2xpY3kgPSBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKFxuICAgICAgICBjb25maWcuZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCxcbiAgICAgICk7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWc6IExvYWRlckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IE1JTl9DSFVOS19TSVpFLFxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIHBhcnQuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCk7XG4gICAgICAgICAgY29uc3QgcGFydExvYWRlZERhdGE6IEZyYWdMb2FkZWREYXRhID0ge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBwYXlsb2FkOiByZXNwb25zZS5kYXRhIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvblByb2dyZXNzKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgICByZXNvbHZlKHBhcnRMb2FkZWREYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gJHtyZXNwb25zZS50ZXh0fWApLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgZnJhZy5zdGF0cy5hYm9ydGVkID0gcGFydC5zdGF0cy5hYm9ydGVkO1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCxcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RhdHNGcm9tUGFydChmcmFnOiBGcmFnbWVudCwgcGFydDogUGFydCkge1xuICAgIGNvbnN0IGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgY29uc3QgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICBjb25zdCBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuICAgIGlmIChwYXJ0VG90YWwpIHtcbiAgICAgIGNvbnN0IGVzdFRvdGFsUGFydHMgPSBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gLyBwYXJ0LmR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oXG4gICAgICAgIE1hdGgucm91bmQoZnJhZ1N0YXRzLmxvYWRlZCAvIHBhcnRUb3RhbCksXG4gICAgICAgIGVzdFRvdGFsUGFydHMsXG4gICAgICApO1xuICAgICAgY29uc3QgZXN0UmVtYWluaW5nUGFydHMgPSBlc3RUb3RhbFBhcnRzIC0gZXN0TG9hZGVkUGFydHM7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdCeXRlcyA9XG4gICAgICAgIGVzdFJlbWFpbmluZ1BhcnRzICogTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gZXN0TG9hZGVkUGFydHMpO1xuICAgICAgZnJhZ1N0YXRzLnRvdGFsID0gZnJhZ1N0YXRzLmxvYWRlZCArIGVzdFJlbWFpbmluZ0J5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBNYXRoLm1heChmcmFnU3RhdHMubG9hZGVkLCBmcmFnU3RhdHMudG90YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcmFnTG9hZGluZyA9IGZyYWdTdGF0cy5sb2FkaW5nO1xuICAgIGNvbnN0IHBhcnRMb2FkaW5nID0gcGFydFN0YXRzLmxvYWRpbmc7XG4gICAgaWYgKGZyYWdMb2FkaW5nLnN0YXJ0KSB7XG4gICAgICAvLyBhZGQgdG8gZnJhZ21lbnQgbG9hZGVyIGxhdGVuY3lcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ICs9IHBhcnRMb2FkaW5nLmZpcnN0IC0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdMb2FkaW5nLnN0YXJ0ID0gcGFydExvYWRpbmcuc3RhcnQ7XG4gICAgICBmcmFnTG9hZGluZy5maXJzdCA9IHBhcnRMb2FkaW5nLmZpcnN0O1xuICAgIH1cbiAgICBmcmFnTG9hZGluZy5lbmQgPSBwYXJ0TG9hZGluZy5lbmQ7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0TG9hZGVyKGZyYWc6IEZyYWdtZW50LCBsb2FkZXI6IExvYWRlcjxGcmFnbWVudExvYWRlckNvbnRleHQ+KSB7XG4gICAgZnJhZy5sb2FkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGxvYWRlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChcbiAgZnJhZzogRnJhZ21lbnQsXG4gIHBhcnQ6IFBhcnQgfCBudWxsID0gbnVsbCxcbik6IEZyYWdtZW50TG9hZGVyQ29udGV4dCB7XG4gIGNvbnN0IHNlZ21lbnQ6IEJhc2VTZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICBjb25zdCBsb2FkZXJDb250ZXh0OiBGcmFnbWVudExvYWRlckNvbnRleHQgPSB7XG4gICAgZnJhZyxcbiAgICBwYXJ0LFxuICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICB1cmw6IHNlZ21lbnQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDAsXG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldCBhcyBudW1iZXI7XG4gIGNvbnN0IGVuZCA9IHNlZ21lbnQuYnl0ZVJhbmdlRW5kT2Zmc2V0IGFzIG51bWJlcjtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShzdGFydCkgJiYgTnVtYmVyLmlzRmluaXRlKGVuZCkpIHtcbiAgICBsZXQgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYnl0ZVJhbmdlRW5kID0gZW5kO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnICYmIGZyYWcuZGVjcnlwdGRhdGE/Lm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAvLyBoYXMgdGhlIHVuZW5jcnlwdGVkIHNpemUgc3BlY2lmaWVkIGluIHRoZSByYW5nZS5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0wOCNzZWN0aW9uLTYuMy42XG4gICAgICBjb25zdCBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gKGZyYWdtZW50TGVuICUgMTYpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgICBsb2FkZXJDb250ZXh0LnJlc2V0SVYgPSB0cnVlO1xuICAgICAgICBieXRlUmFuZ2VTdGFydCA9IHN0YXJ0IC0gMTY7XG4gICAgICB9XG4gICAgfVxuICAgIGxvYWRlckNvbnRleHQucmFuZ2VTdGFydCA9IGJ5dGVSYW5nZVN0YXJ0O1xuICAgIGxvYWRlckNvbnRleHQucmFuZ2VFbmQgPSBieXRlUmFuZ2VFbmQ7XG4gIH1cbiAgcmV0dXJuIGxvYWRlckNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnOiBGcmFnbWVudCwgcGFydD86IFBhcnQpOiBMb2FkRXJyb3Ige1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgR0FQICR7ZnJhZy5nYXAgPyAndGFnJyA6ICdhdHRyaWJ1dGUnfSBmb3VuZGApO1xuICBjb25zdCBlcnJvckRhdGE6IEZyYWdMb2FkRmFpbFJlc3VsdCA9IHtcbiAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0dBUCxcbiAgICBmYXRhbDogZmFsc2UsXG4gICAgZnJhZyxcbiAgICBlcnJvcixcbiAgICBuZXR3b3JrRGV0YWlsczogbnVsbCxcbiAgfTtcbiAgaWYgKHBhcnQpIHtcbiAgICBlcnJvckRhdGEucGFydCA9IHBhcnQ7XG4gIH1cbiAgKHBhcnQgPyBwYXJ0IDogZnJhZykuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gIHJldHVybiBuZXcgTG9hZEVycm9yKGVycm9yRGF0YSk7XG59XG5cbmV4cG9ydCBjbGFzcyBMb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHB1YmxpYyByZWFkb25seSBkYXRhOiBGcmFnTG9hZEZhaWxSZXN1bHQ7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IEZyYWdMb2FkRmFpbFJlc3VsdCkge1xuICAgIHN1cGVyKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZyYWdMb2FkRmFpbFJlc3VsdCBleHRlbmRzIEVycm9yRGF0YSB7XG4gIGZyYWc6IEZyYWdtZW50O1xuICBwYXJ0PzogUGFydDtcbiAgcmVzcG9uc2U/OiB7XG4gICAgZGF0YTogYW55O1xuICAgIC8vIGVycm9yIHN0YXR1cyBjb2RlXG4gICAgY29kZTogbnVtYmVyO1xuICAgIC8vIGVycm9yIGRlc2NyaXB0aW9uXG4gICAgdGV4dDogc3RyaW5nO1xuICAgIHVybDogc3RyaW5nO1xuICB9O1xuICBuZXR3b3JrRGV0YWlsczogYW55O1xufVxuXG5leHBvcnQgdHlwZSBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrID0gKFxuICByZXN1bHQ6IEZyYWdMb2FkZWREYXRhIHwgUGFydHNMb2FkZWREYXRhLFxuKSA9PiB2b2lkO1xuIiwiaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7XG4gIExvYWRlclN0YXRzLFxuICBMb2FkZXJSZXNwb25zZSxcbiAgTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXIsXG4gIEtleUxvYWRlckNvbnRleHQsXG4gIFBsYXlsaXN0TGV2ZWxUeXBlLFxufSBmcm9tICcuLi90eXBlcy9sb2FkZXInO1xuaW1wb3J0IHsgTG9hZEVycm9yIH0gZnJvbSAnLi9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IENvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgeyBLZXlMb2FkZWREYXRhIH0gZnJvbSAnLi4vdHlwZXMvZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTGV2ZWxLZXkgfSBmcm9tICcuL2xldmVsLWtleSc7XG5pbXBvcnQgdHlwZSBFTUVDb250cm9sbGVyIGZyb20gJy4uL2NvbnRyb2xsZXIvZW1lLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgeyBNZWRpYUtleVNlc3Npb25Db250ZXh0IH0gZnJvbSAnLi4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7IEtleVN5c3RlbUZvcm1hdHMgfSBmcm9tICcuLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBLZXlMb2FkZXJJbmZvIHtcbiAgZGVjcnlwdGRhdGE6IExldmVsS2V5O1xuICBrZXlMb2FkUHJvbWlzZTogUHJvbWlzZTxLZXlMb2FkZWREYXRhPiB8IG51bGw7XG4gIGxvYWRlcjogTG9hZGVyPEtleUxvYWRlckNvbnRleHQ+IHwgbnVsbDtcbiAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogTWVkaWFLZXlTZXNzaW9uQ29udGV4dCB8IG51bGw7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlMb2FkZXIgaW1wbGVtZW50cyBDb21wb25lbnRBUEkge1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuICBwdWJsaWMga2V5VXJpVG9LZXlJbmZvOiB7IFtrZXl1cmk6IHN0cmluZ106IEtleUxvYWRlckluZm8gfSA9IHt9O1xuICBwdWJsaWMgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cblxuICBhYm9ydCh0eXBlPzogUGxheWxpc3RMZXZlbFR5cGUpIHtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGUgIT09IGxvYWRlci5jb250ZXh0Py5mcmFnLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICAgIC8vIFJlbW92ZSBjYWNoZWQgRU1FIGtleXMgb24gZGV0YWNoXG4gICAgICBpZiAoXG4gICAgICAgIGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCB8fFxuICAgICAgICBrZXlJbmZvLmRlY3J5cHRkYXRhLmlzQ29tbW9uRW5jcnlwdGlvblxuICAgICAgKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gIH1cblxuICBjcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgZGV0YWlsczogRXJyb3JEZXRhaWxzID0gRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLFxuICAgIGVycm9yOiBFcnJvcixcbiAgICBuZXR3b3JrRGV0YWlscz86IGFueSxcbiAgICByZXNwb25zZT86IHsgdXJsOiBzdHJpbmc7IGRhdGE6IHVuZGVmaW5lZDsgY29kZTogbnVtYmVyOyB0ZXh0OiBzdHJpbmcgfSxcbiAgKTogTG9hZEVycm9yIHtcbiAgICByZXR1cm4gbmV3IExvYWRFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICB9KTtcbiAgfVxuXG4gIGxvYWRDbGVhcihcbiAgICBsb2FkaW5nRnJhZzogRnJhZ21lbnQsXG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzOiBGcmFnbWVudFtdLFxuICApOiB2b2lkIHwgUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBhY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FpZG5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICBjb25zdCB7IHNuLCBjYyB9ID0gbG9hZGluZ0ZyYWc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmcmFnID0gZW5jcnlwdGVkRnJhZ21lbnRzW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2MgPD0gZnJhZy5jYyAmJlxuICAgICAgICAgIChzbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnIHx8IHNuIDwgZnJhZy5zbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5lbWVDb250cm9sbGVyXG4gICAgICAgICAgICAuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpXG4gICAgICAgICAgICAudGhlbigoa2V5U3lzdGVtRm9ybWF0KSA9PiB7XG4gICAgICAgICAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxvYWQoZnJhZzogRnJhZ21lbnQpOiBQcm9taXNlPEtleUxvYWRlZERhdGE+IHtcbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5lbmNyeXB0ZWQgJiYgdGhpcy5lbWVDb250cm9sbGVyKSB7XG4gICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlclxuICAgICAgICAuc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGZyYWcpXG4gICAgICAgIC50aGVuKChrZXlTeXN0ZW1Gb3JtYXQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9hZEludGVybmFsKGZyYWcpO1xuICB9XG5cbiAgbG9hZEludGVybmFsKFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIGtleVN5c3RlbUZvcm1hdD86IEtleVN5c3RlbUZvcm1hdHMsXG4gICk6IFByb21pc2U8S2V5TG9hZGVkRGF0YT4ge1xuICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAga2V5U3lzdGVtRm9ybWF0XG4gICAgICAgICAgPyBgRXhwZWN0ZWQgZnJhZy5kZWNyeXB0ZGF0YSB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHRpbmcgZm9ybWF0ICR7a2V5U3lzdGVtRm9ybWF0fWBcbiAgICAgICAgICA6ICdNaXNzaW5nIGRlY3J5cHRpb24gZGF0YSBvbiBmcmFnbWVudCBpbiBvbktleUxvYWRpbmcnLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvciksXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgICAgICAgbmV3IEVycm9yKGBJbnZhbGlkIGtleSBVUkk6IFwiJHt1cml9XCJgKSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcblxuICAgIGlmIChrZXlJbmZvPy5kZWNyeXB0ZGF0YS5rZXkpIHtcbiAgICAgIGRlY3J5cHRkYXRhLmtleSA9IGtleUluZm8uZGVjcnlwdGRhdGEua2V5O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGZyYWcsIGtleUluZm8gfSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBrZXkgbG9hZCBwcm9taXNlIGFzIGxvbmcgYXMgaXQgZG9lcyBub3QgaGF2ZSBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1bnVzYWJsZSBrZXkgc3RhdHVzXG4gICAgaWYgKGtleUluZm8/LmtleUxvYWRQcm9taXNlKSB7XG4gICAgICBzd2l0Y2ggKGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dD8ua2V5U3RhdHVzKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICdzdGF0dXMtcGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZSc6XG4gICAgICAgIGNhc2UgJ3VzYWJsZS1pbi1mdXR1cmUnOlxuICAgICAgICAgIHJldHVybiBrZXlJbmZvLmtleUxvYWRQcm9taXNlLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyYWcsIGtleUluZm8gfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBrZXkgc2Vzc2lvbiBhbmQgc3RhdHVzIGFuZCBpdCBpcyBub3QgcGVuZGluZyBvciB1c2FibGUsIGNvbnRpbnVlXG4gICAgICAvLyBUaGlzIHdpbGwgZ28gYmFjayB0byB0aGUgZW1lLWNvbnRyb2xsZXIgZm9yIGV4cGlyZWQga2V5cyB0byBnZXQgYSBuZXcga2V5TG9hZFByb21pc2VcbiAgICB9XG5cbiAgICAvLyBMb2FkIHRoZSBrZXkgb3IgcmV0dXJuIHRoZSBsb2FkaW5nIHByb21pc2VcbiAgICBrZXlJbmZvID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSA9IHtcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICAga2V5TG9hZFByb21pc2U6IG51bGwsXG4gICAgICBsb2FkZXI6IG51bGwsXG4gICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0OiBudWxsLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKGRlY3J5cHRkYXRhLm1ldGhvZCkge1xuICAgICAgY2FzZSAnSVNPLTIzMDAxLTcnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUyc6XG4gICAgICBjYXNlICdTQU1QTEUtQUVTLUNFTkMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DVFInOlxuICAgICAgICBpZiAoZGVjcnlwdGRhdGEua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgLy8gbG9hZEtleUhUVFAgaGFuZGxlcyBodHRwKHMpIGFuZCBkYXRhIFVSTHNcbiAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5RU1FKGtleUluZm8sIGZyYWcpO1xuICAgICAgY2FzZSAnQUVTLTEyOCc6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGtleUluZm8sIGZyYWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEtleSBzdXBwbGllZCB3aXRoIHVuc3VwcG9ydGVkIE1FVEhPRDogXCIke2RlY3J5cHRkYXRhLm1ldGhvZH1cImAsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbG9hZEtleUVNRShrZXlJbmZvOiBLZXlMb2FkZXJJbmZvLCBmcmFnOiBGcmFnbWVudCk6IFByb21pc2U8S2V5TG9hZGVkRGF0YT4ge1xuICAgIGNvbnN0IGtleUxvYWRlZERhdGE6IEtleUxvYWRlZERhdGEgPSB7IGZyYWcsIGtleUluZm8gfTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9XG4gICAgICAgIHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihcbiAgICAgICAgICAoa2V5U2Vzc2lvbkNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9IGtleVNlc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgICAgfSxcbiAgICAgICAgKSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfVxuXG4gIGxvYWRLZXlIVFRQKGtleUluZm86IEtleUxvYWRlckluZm8sIGZyYWc6IEZyYWdtZW50KTogUHJvbWlzZTxLZXlMb2FkZWREYXRhPiB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZykgYXMgTG9hZGVyPEtleUxvYWRlckNvbnRleHQ+O1xuICAgIGZyYWcua2V5TG9hZGVyID0ga2V5SW5mby5sb2FkZXIgPSBrZXlMb2FkZXI7XG5cbiAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsb2FkZXJDb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0ID0ge1xuICAgICAgICBrZXlJbmZvLFxuICAgICAgICBmcmFnLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgIHVybDoga2V5SW5mby5kZWNyeXB0ZGF0YS51cmksXG4gICAgICB9O1xuXG4gICAgICAvLyBtYXhSZXRyeSBpcyAwIHNvIHRoYXQgaW5zdGVhZCBvZiByZXRyeWluZyB0aGUgc2FtZSBrZXkgb24gdGhlIHNhbWUgdmFyaWFudCBtdWx0aXBsZSB0aW1lcyxcbiAgICAgIC8vIGtleS1sb2FkZXIgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIGFuZCByZWx5IG9uIHN0cmVhbS1jb250cm9sbGVyIHRvIGhhbmRsZSByZXRyeSBsb2dpYy5cbiAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIGFsaWduIHJldHJ5IGxvZ2ljIHdpdGggZnJhZ21lbnQtbG9hZGVyXG4gICAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICAgIGNvbnN0IGxvYWRlckNvbmZpZzogTG9hZGVyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgbG9hZFBvbGljeSxcbiAgICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGxvYWRlckNhbGxiYWNrczogTG9hZGVyQ2FsbGJhY2tzPEtleUxvYWRlckNvbnRleHQ+ID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChcbiAgICAgICAgICByZXNwb25zZTogTG9hZGVyUmVzcG9uc2UsXG4gICAgICAgICAgc3RhdHM6IExvYWRlclN0YXRzLFxuICAgICAgICAgIGNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBmcmFnLCBrZXlJbmZvLCB1cmw6IHVyaSB9ID0gY29udGV4dDtcbiAgICAgICAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgfHwga2V5SW5mbyAhPT0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcbiAgICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKCdhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXQgb3IgY2hhbmdlZCcpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBrZXlJbmZvLmRlY3J5cHRkYXRhLmtleSA9IGZyYWcuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhIGFzIEFycmF5QnVmZmVyLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBkZXRhY2ggZnJhZ21lbnQga2V5IGxvYWRlciBvbiBsb2FkIHN1Y2Nlc3NcbiAgICAgICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICAgICAga2V5SW5mby5sb2FkZXIgPSBudWxsO1xuICAgICAgICAgIHJlc29sdmUoeyBmcmFnLCBrZXlJbmZvIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXJyb3I6IChcbiAgICAgICAgICByZXNwb25zZTogeyBjb2RlOiBudW1iZXI7IHRleHQ6IHN0cmluZyB9LFxuICAgICAgICAgIGNvbnRleHQ6IEtleUxvYWRlckNvbnRleHQsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IGFueSxcbiAgICAgICAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUixcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gbG9hZGluZyBrZXkgJHtyZXNwb25zZS50ZXh0fWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgICB7IHVybDogbG9hZGVyQ29udGV4dC51cmwsIGRhdGE6IHVuZGVmaW5lZCwgLi4ucmVzcG9uc2UgfSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblRpbWVvdXQ6IChcbiAgICAgICAgICBzdGF0czogTG9hZGVyU3RhdHMsXG4gICAgICAgICAgY29udGV4dDogS2V5TG9hZGVyQ29udGV4dCxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogYW55LFxuICAgICAgICApID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKFxuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgICAgbmV3IEVycm9yKCdrZXkgbG9hZGluZyB0aW1lZCBvdXQnKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25BYm9ydDogKFxuICAgICAgICAgIHN0YXRzOiBMb2FkZXJTdGF0cyxcbiAgICAgICAgICBjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0LFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBhbnksXG4gICAgICAgICkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSxcbiAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBrZXlMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldExvYWRlcihjb250ZXh0OiBLZXlMb2FkZXJDb250ZXh0KSB7XG4gICAgY29uc3QgeyBmcmFnLCBrZXlJbmZvLCB1cmw6IHVyaSB9ID0gY29udGV4dDtcbiAgICBjb25zdCBsb2FkZXIgPSBrZXlJbmZvLmxvYWRlcjtcbiAgICBpZiAoZnJhZy5rZXlMb2FkZXIgPT09IGxvYWRlcikge1xuICAgICAgZnJhZy5rZXlMb2FkZXIgPSBudWxsO1xuICAgICAga2V5SW5mby5sb2FkZXIgPSBudWxsO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAaWdub3JlXG4gKiBTdWItY2xhc3Mgc3BlY2lhbGl6YXRpb24gb2YgRXZlbnRIYW5kbGVyIGJhc2UgY2xhc3MuXG4gKlxuICogVGFza0xvb3AgYWxsb3dzIHRvIHNjaGVkdWxlIGEgdGFzayBmdW5jdGlvbiBiZWluZyBjYWxsZWQgKG9wdGlvbm5hbHkgcmVwZWF0ZWRseSkgb24gdGhlIG1haW4gbG9vcCxcbiAqIHNjaGVkdWxlZCBhc3luY2hyb25lb3VzbHksIGF2b2lkaW5nIHJlY3Vyc2l2ZSBjYWxscyBpbiB0aGUgc2FtZSB0aWNrLlxuICpcbiAqIFRoZSB0YXNrIGl0c2VsZiBpcyBpbXBsZW1lbnRlZCBpbiBgZG9UaWNrYC4gSXQgY2FuIGJlIHJlcXVlc3RlZCBhbmQgY2FsbGVkIGZvciBzaW5nbGUgZXhlY3V0aW9uXG4gKiB1c2luZyB0aGUgYHRpY2tgIG1ldGhvZC5cbiAqXG4gKiBJdCB3aWxsIGJlIGFzc3VyZWQgdGhhdCB0aGUgdGFzayBleGVjdXRpb24gbWV0aG9kIChgdGlja2ApIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgbWFpbiBsb29wIFwidGlja1wiLFxuICogbm8gbWF0dGVyIGhvdyBvZnRlbiBpdCBnZXRzIHJlcXVlc3RlZCBmb3IgZXhlY3V0aW9uLiBFeGVjdXRpb24gaW4gZnVydGhlciB0aWNrcyB3aWxsIGJlIHNjaGVkdWxlZCBhY2NvcmRpbmdseS5cbiAqXG4gKiBJZiBmdXJ0aGVyIGV4ZWN1dGlvbiByZXF1ZXN0cyBoYXZlIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQgb24gdGhlIG5leHQgdGljaywgaXQgY2FuIGJlIGNoZWNrZWQgd2l0aCBgaGFzTmV4dFRpY2tgLFxuICogYW5kIGNhbmNlbGxlZCB3aXRoIGBjbGVhck5leHRUaWNrYC5cbiAqXG4gKiBUaGUgdGFzayBjYW4gYmUgc2NoZWR1bGVkIGFzIGFuIGludGVydmFsIHJlcGVhdGVkbHkgd2l0aCBhIHBlcmlvZCBhcyBwYXJhbWV0ZXIgKHNlZSBgc2V0SW50ZXJ2YWxgLCBgY2xlYXJJbnRlcnZhbGApLlxuICpcbiAqIFN1Yi1jbGFzc2VzIG5lZWQgdG8gaW1wbGVtZW50IHRoZSBgZG9UaWNrYCBtZXRob2Qgd2hpY2ggd2lsbCBlZmZlY3RpdmVseSBoYXZlIHRoZSB0YXNrIGV4ZWN1dGlvbiByb3V0aW5lLlxuICpcbiAqIEZ1cnRoZXIgZXhwbGFuYXRpb25zOlxuICpcbiAqIFRoZSBiYXNlY2xhc3MgaGFzIGEgYHRpY2tgIG1ldGhvZCB0aGF0IHdpbGwgc2NoZWR1bGUgdGhlIGRvVGljayBjYWxsLiBJdCBtYXkgYmUgY2FsbGVkIHN5bmNocm9uZW91c2x5XG4gKiBvbmx5IGZvciBhIHN0YWNrLWRlcHRoIG9mIG9uZS4gT24gcmUtZW50cmFudCBjYWxscywgc3ViLXNlcXVlbnQgY2FsbHMgYXJlIHNjaGVkdWxlZCBmb3IgbmV4dCBtYWluIGxvb3AgdGlja3MuXG4gKlxuICogV2hlbiB0aGUgdGFzayBleGVjdXRpb24gKGB0aWNrYCBtZXRob2QpIGlzIGNhbGxlZCBpbiByZS1lbnRyYW50IHdheSB0aGlzIGlzIGRldGVjdGVkIGFuZFxuICogd2UgYXJlIGxpbWl0aW5nIHRoZSB0YXNrIGV4ZWN1dGlvbiBwZXIgY2FsbCBzdGFjayB0byBleGFjdGx5IG9uZSwgYnV0IHNjaGVkdWxpbmcvcG9zdC1wb25pbmcgZnVydGhlclxuICogdGFzayBwcm9jZXNzaW5nIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gKGFsc28ga25vd24gYXMgXCJuZXh0IHRpY2tcIiBpbiB0aGUgTm9kZS9KUyBydW50aW1lIGxpbmdvKS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza0xvb3Age1xuICBwcml2YXRlIHJlYWRvbmx5IF9ib3VuZFRpY2s6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgX3RpY2tUaW1lcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3RpY2tJbnRlcnZhbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3RpY2tDYWxsQ291bnQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIC8vIGNsZWFyIGFsbCB0aW1lcnMgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZnJvbSBldmVudCBidXNcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7fVxuXG4gIHB1YmxpYyBoYXNJbnRlcnZhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrSW50ZXJ2YWw7XG4gIH1cblxuICBwdWJsaWMgaGFzTmV4dFRpY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fdGlja1RpbWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBtaWxsaXMgLSBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBwdWJsaWMgc2V0SW50ZXJ2YWwobWlsbGlzOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgbWlsbGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgcHVibGljIGNsZWFySW50ZXJ2YWwoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3RpY2tJbnRlcnZhbCkge1xuICAgICAgc2VsZi5jbGVhckludGVydmFsKHRoaXMuX3RpY2tJbnRlcnZhbCk7XG4gICAgICB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gdGltZW91dCB3YXMgY2xlYXJlZCwgZmFsc2Ugd2hlbiBub25lIHdhcyBzZXQgKG5vIGVmZmVjdClcbiAgICovXG4gIHB1YmxpYyBjbGVhck5leHRUaWNrKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICovXG4gIHB1YmxpYyB0aWNrKCk6IHZvaWQge1xuICAgIHRoaXMuX3RpY2tDYWxsQ291bnQrKztcbiAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA9PT0gMSkge1xuICAgICAgdGhpcy5kb1RpY2soKTtcbiAgICAgIC8vIHJlLWVudHJhbnQgY2FsbCB0byB0aWNrIGZyb20gcHJldmlvdXMgZG9UaWNrIGNhbGwgc3RhY2tcbiAgICAgIC8vIC0+IHNjaGVkdWxlIGEgY2FsbCBvbiB0aGUgbmV4dCBtYWluIGxvb3AgaXRlcmF0aW9uIHRvIHByb2Nlc3MgdGhpcyB0YXNrIHByb2Nlc3NpbmcgcmVxdWVzdFxuICAgICAgaWYgKHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvbmx5IG9uZSB0aW1lciBleGlzdHMgYXQgYW55IHRpbWUgYXQgbWF4XG4gICAgICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRpY2tJbW1lZGlhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHN1YmNsYXNzIHRvIGltcGxlbWVudCB0YXNrIGxvZ2ljXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcHJvdGVjdGVkIGRvVGljaygpOiB2b2lkIHt9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJlbXV4ZXJSZXN1bHQgfSBmcm9tICcuL3JlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nIH0gZnJvbSAnLi9sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi9idWZmZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbXV4ZXJSZXN1bHQge1xuICByZW11eFJlc3VsdDogUmVtdXhlclJlc3VsdDtcbiAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhO1xufVxuXG5leHBvcnQgY2xhc3MgQ2h1bmtNZXRhZGF0YSB7XG4gIHB1YmxpYyByZWFkb25seSBsZXZlbDogbnVtYmVyO1xuICBwdWJsaWMgcmVhZG9ubHkgc246IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IHBhcnQ6IG51bWJlcjtcbiAgcHVibGljIHJlYWRvbmx5IGlkOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIHB1YmxpYyByZWFkb25seSBwYXJ0aWFsOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgdHJhbnNtdXhpbmc6IEhsc0NodW5rUGVyZm9ybWFuY2VUaW1pbmcgPVxuICAgIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gIHB1YmxpYyByZWFkb25seSBidWZmZXJpbmc6IHtcbiAgICBba2V5IGluIFNvdXJjZUJ1ZmZlck5hbWVdOiBIbHNDaHVua1BlcmZvcm1hbmNlVGltaW5nO1xuICB9ID0ge1xuICAgIGF1ZGlvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgIGF1ZGlvdmlkZW86IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCksXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbGV2ZWw6IG51bWJlcixcbiAgICBzbjogbnVtYmVyLFxuICAgIGlkOiBudW1iZXIsXG4gICAgc2l6ZSA9IDAsXG4gICAgcGFydCA9IC0xLFxuICAgIHBhcnRpYWwgPSBmYWxzZSxcbiAgKSB7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuc24gPSBzbjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIHRoaXMucGFydGlhbCA9IHBhcnRpYWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKTogSGxzQ2h1bmtQZXJmb3JtYW5jZVRpbWluZyB7XG4gIHJldHVybiB7IHN0YXJ0OiAwLCBleGVjdXRlU3RhcnQ6IDAsIGV4ZWN1dGVFbmQ6IDAsIGVuZDogMCB9O1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgYWRqdXN0U2xpZGluZyB9IGZyb20gJy4vbGV2ZWwtaGVscGVyJztcblxuaW1wb3J0IHR5cGUgeyBGcmFnbWVudCB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1kZXRhaWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZyYWdXaXRoQ0MoXG4gIGZyYWdtZW50czogRnJhZ21lbnRbXSxcbiAgY2M6IG51bWJlcixcbik6IEZyYWdtZW50IHwgbnVsbCB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZnJhZ21lbnRzW2ldPy5jYyA9PT0gY2MpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhcbiAgbGFzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCxcbiAgc3dpdGNoRGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkLFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4pOiBzd2l0Y2hEZXRhaWxzIGlzIExldmVsRGV0YWlscyAmIGJvb2xlYW4ge1xuICBpZiAoc3dpdGNoRGV0YWlscykge1xuICAgIGlmIChcbiAgICAgIGRldGFpbHMuZW5kQ0MgPiBkZXRhaWxzLnN0YXJ0Q0MgfHxcbiAgICAgIChsYXN0RnJhZyAmJiBsYXN0RnJhZy5jYyA8IGRldGFpbHMuc3RhcnRDQylcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IGZyYWcgaW4gdGhlIHByZXZpb3VzIGxldmVsIHdoaWNoIG1hdGNoZXMgdGhlIENDIG9mIHRoZSBmaXJzdCBmcmFnIG9mIHRoZSBuZXcgbGV2ZWxcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcoXG4gIHByZXZEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIGN1ckRldGFpbHM6IExldmVsRGV0YWlscyxcbikge1xuICBjb25zdCBwcmV2RnJhZ3MgPSBwcmV2RGV0YWlscy5mcmFnbWVudHM7XG4gIGNvbnN0IGN1ckZyYWdzID0gY3VyRGV0YWlscy5mcmFnbWVudHM7XG5cbiAgaWYgKCFjdXJGcmFncy5sZW5ndGggfHwgIXByZXZGcmFncy5sZW5ndGgpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnbWVudHMgdG8gYWxpZ24nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcblxuICBpZiAoIXByZXZTdGFydEZyYWcgfHwgKHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpKSB7XG4gICAgbG9nZ2VyLmxvZygnTm8gZnJhZyBpbiBwcmV2aW91cyBsZXZlbCB0byBhbGlnbiBvbicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWc6IEZyYWdtZW50LCBzbGlkaW5nOiBudW1iZXIpIHtcbiAgaWYgKGZyYWcpIHtcbiAgICBjb25zdCBzdGFydCA9IGZyYWcuc3RhcnQgKyBzbGlkaW5nO1xuICAgIGZyYWcuc3RhcnQgPSBmcmFnLnN0YXJ0UFRTID0gc3RhcnQ7XG4gICAgZnJhZy5lbmRQVFMgPSBzdGFydCArIGZyYWcuZHVyYXRpb247XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFNsaWRpbmdTdGFydChzbGlkaW5nOiBudW1iZXIsIGRldGFpbHM6IExldmVsRGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gIH1cbiAgLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGRldGFpbHMuZnJhZ21lbnRIaW50LCBzbGlkaW5nKTtcbiAgfVxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGlnblN0cmVhbShcbiAgbGFzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCxcbiAgc3dpdGNoRGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkLFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4pIHtcbiAgaWYgKCFzd2l0Y2hEZXRhaWxzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFsaWduRGlzY29udGludWl0aWVzKGxhc3RGcmFnLCBkZXRhaWxzLCBzd2l0Y2hEZXRhaWxzKTtcbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIHN3aXRjaERldGFpbHMpIHtcbiAgICAvLyBJZiB0aGUgUFRTIHdhc24ndCBmaWd1cmVkIG91dCB2aWEgZGlzY29udGludWl0eSBzZXF1ZW5jZSB0aGF0IG1lYW5zIHRoZXJlIHdhcyBubyBDQyBpbmNyZWFzZSB3aXRoaW4gdGhlIGxldmVsLlxuICAgIC8vIEFsaWduaW5nIHZpYSBQcm9ncmFtIERhdGUgVGltZSBzaG91bGQgdGhlcmVmb3JlIGJlIHJlbGlhYmxlLCBzaW5jZSBQRFQgc2hvdWxkIGJlIHRoZSBzYW1lIHdpdGhpbiB0aGUgc2FtZVxuICAgIC8vIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UuXG4gICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgc3dpdGNoRGV0YWlscyk7XG4gIH1cbiAgaWYgKCFkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIHN3aXRjaERldGFpbHMgJiYgIWRldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgLy8gVHJ5IHRvIGFsaWduIG9uIHNuIHNvIHRoYXQgd2UgcGljayBhIGJldHRlciBzdGFydCBmcmFnbWVudC5cbiAgICAvLyBEbyBub3QgcGVyZm9ybSB0aGlzIG9uIHBsYXlsaXN0cyB3aXRoIGRlbHRhIHVwZGF0ZXMgYXMgdGhpcyBpcyBvbmx5IHRvIGFsaWduIGxldmVscyBvbiBzd2l0Y2hcbiAgICAvLyBhbmQgYWRqdXN0U2xpZGluZyBvbmx5IGFkanVzdHMgZnJhZ21lbnRzIGFmdGVyIHNraXBwZWRTZWdtZW50cy5cbiAgICBhZGp1c3RTbGlkaW5nKHN3aXRjaERldGFpbHMsIGRldGFpbHMpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBUUyBpZiBhIG5ldyBsZXZlbCdzIGZyYWdtZW50cyB1c2luZyB0aGUgUFRTIG9mIGEgZnJhZ21lbnQgaW4gdGhlIGxhc3QgbGV2ZWwgd2hpY2ggc2hhcmVzIHRoZSBzYW1lXG4gKiBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICogQHBhcmFtIGxhc3RGcmFnIC0gVGhlIGxhc3QgRnJhZ21lbnQgd2hpY2ggc2hhcmVzIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2VcbiAqIEBwYXJhbSBsYXN0TGV2ZWwgLSBUaGUgZGV0YWlscyBvZiB0aGUgbGFzdCBsb2FkZWQgbGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzIC0gVGhlIGRldGFpbHMgb2YgdGhlIG5ldyBsZXZlbFxuICovXG5mdW5jdGlvbiBhbGlnbkRpc2NvbnRpbnVpdGllcyhcbiAgbGFzdEZyYWc6IEZyYWdtZW50IHwgbnVsbCxcbiAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICBzd2l0Y2hEZXRhaWxzOiBMZXZlbERldGFpbHMgfCB1bmRlZmluZWQsXG4pIHtcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIHN3aXRjaERldGFpbHMsIGRldGFpbHMpKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhcbiAgICAgIHN3aXRjaERldGFpbHMsXG4gICAgICBkZXRhaWxzLFxuICAgICk7XG4gICAgaWYgKHJlZmVyZW5jZUZyYWcgJiYgTnVtYmVyLmlzRmluaXRlKHJlZmVyZW5jZUZyYWcuc3RhcnQpKSB7XG4gICAgICBsb2dnZXIubG9nKFxuICAgICAgICBgQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCAke2RldGFpbHMudXJsfWAsXG4gICAgICApO1xuICAgICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHJlZmVyZW5jZUZyYWcuc3RhcnQsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC5cbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUc1xuICogZm9yIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVyIHNoYXJlZCBieSBib3RoIHBsYXlsaXN0cyB3aGVuIHByZXNlbnQsXG4gKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAqIEdpdmVuIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIGZldGNoZXMgYW5kIGluaXRpYWwgbG9hZHMgb2YgbGl2ZSBgbWFpbmAgYW5kIGF1ZGlvL3N1YnRpdGxlIHRyYWNrcyxcbiAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICogYmUgY29uc2lzdGVudCBhY3Jvc3MgcGxheWxpc3RzLCBwZXIgdGhlIEhMUyBzcGVjLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKFxuICBkZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gIHJlZkRldGFpbHM6IExldmVsRGV0YWlscyxcbikge1xuICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCByZWZGcmFnbWVudHMgPSByZWZEZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKCFmcmFnbWVudHMubGVuZ3RoIHx8ICFyZWZGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgZGVsdGEgdG8gYXBwbHkgdG8gYWxsIGZyYWdtZW50cyBhY2NvcmRpbmcgdG8gdGhlIGRlbHRhIGluIFBEVCB0aW1lcyBhbmQgc3RhcnQgdGltZXNcbiAgLy8gb2YgYSBmcmFnbWVudCBpbiB0aGUgcmVmZXJlbmNlIGRldGFpbHMsIGFuZCBhIGZyYWdtZW50IGluIHRoZSB0YXJnZXQgZGV0YWlscyBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5LlxuICAvLyBJZiBhIGZyYWdtZW50IG9mIHRoZSBzYW1lIGRpc2NvbnRpbnVpdHkgd2FzIG5vdCBmb3VuZCB1c2UgdGhlIG1pZGRsZSBmcmFnbWVudCBvZiBib3RoLlxuICBsZXQgcmVmRnJhZzogRnJhZ21lbnQgfCBudWxsIHwgdW5kZWZpbmVkO1xuICBsZXQgZnJhZzogRnJhZ21lbnQgfCBudWxsIHwgdW5kZWZpbmVkO1xuICBjb25zdCB0YXJnZXRDQyA9IE1hdGgubWluKHJlZkRldGFpbHMuZW5kQ0MsIGRldGFpbHMuZW5kQ0MpO1xuICBpZiAocmVmRGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MgJiYgZGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MpIHtcbiAgICByZWZGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhyZWZGcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRhcmdldENDKTtcbiAgfVxuICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICByZWZGcmFnID0gcmVmRnJhZ21lbnRzW01hdGguZmxvb3IocmVmRnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgICBmcmFnID1cbiAgICAgIGZpbmRGaXJzdEZyYWdXaXRoQ0MoZnJhZ21lbnRzLCByZWZGcmFnLmNjKSB8fFxuICAgICAgZnJhZ21lbnRzW01hdGguZmxvb3IoZnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgfVxuICBjb25zdCByZWZQRFQgPSByZWZGcmFnLnByb2dyYW1EYXRlVGltZTtcbiAgY29uc3QgdGFyZ2V0UERUID0gZnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmICghcmVmUERUIHx8ICF0YXJnZXRQRFQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkZWx0YSA9ICh0YXJnZXRQRFQgLSByZWZQRFQpIC8gMTAwMCAtIChmcmFnLnN0YXJ0IC0gcmVmRnJhZy5zdGFydCk7XG4gIGFkanVzdFNsaWRpbmdTdGFydChkZWx0YSwgZGV0YWlscyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBRVNDcnlwdG8ge1xuICBwcml2YXRlIHN1YnRsZTogU3VidGxlQ3J5cHRvO1xuICBwcml2YXRlIGFlc0lWOiBVaW50OEFycmF5O1xuXG4gIGNvbnN0cnVjdG9yKHN1YnRsZTogU3VidGxlQ3J5cHRvLCBpdjogVWludDhBcnJheSkge1xuICAgIHRoaXMuc3VidGxlID0gc3VidGxlO1xuICAgIHRoaXMuYWVzSVYgPSBpdjtcbiAgfVxuXG4gIGRlY3J5cHQoZGF0YTogQXJyYXlCdWZmZXIsIGtleTogQ3J5cHRvS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoeyBuYW1lOiAnQUVTLUNCQycsIGl2OiB0aGlzLmFlc0lWIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhc3RBRVNLZXkge1xuICBwcml2YXRlIHN1YnRsZTogYW55O1xuICBwcml2YXRlIGtleTogQXJyYXlCdWZmZXI7XG5cbiAgY29uc3RydWN0b3Ioc3VidGxlLCBrZXkpIHtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgfVxuXG4gIGV4cGFuZEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCB0aGlzLmtleSwgeyBuYW1lOiAnQUVTLUNCQycgfSwgZmFsc2UsIFtcbiAgICAgICdlbmNyeXB0JyxcbiAgICAgICdkZWNyeXB0JyxcbiAgICBdKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgc2xpY2VVaW50OCB9IGZyb20gJy4uL3V0aWxzL3R5cGVkLWFycmF5JztcblxuLy8gUEtDUzdcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQYWRkaW5nKGFycmF5OiBVaW50OEFycmF5KTogVWludDhBcnJheSB7XG4gIGNvbnN0IG91dHB1dEJ5dGVzID0gYXJyYXkuYnl0ZUxlbmd0aDtcbiAgY29uc3QgcGFkZGluZ0J5dGVzID1cbiAgICBvdXRwdXRCeXRlcyAmJiBuZXcgRGF0YVZpZXcoYXJyYXkuYnVmZmVyKS5nZXRVaW50OChvdXRwdXRCeXRlcyAtIDEpO1xuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIHNsaWNlVWludDgoYXJyYXksIDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFFU0RlY3J5cHRvciB7XG4gIHByaXZhdGUgcmNvbjogQXJyYXk8bnVtYmVyPiA9IFtcbiAgICAweDAsIDB4MSwgMHgyLCAweDQsIDB4OCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNixcbiAgXTtcbiAgcHJpdmF0ZSBzdWJNaXg6IEFycmF5PFVpbnQzMkFycmF5PiA9IFtcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgXTtcbiAgcHJpdmF0ZSBpbnZTdWJNaXg6IEFycmF5PFVpbnQzMkFycmF5PiA9IFtcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgICBuZXcgVWludDMyQXJyYXkoMjU2KSxcbiAgXTtcbiAgcHJpdmF0ZSBzQm94OiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICBwcml2YXRlIGludlNCb3g6IFVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gIHByaXZhdGUga2V5OiBVaW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSgwKTtcblxuICBwcml2YXRlIGtzUm93czogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBrZXlTaXplOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGtleVNjaGVkdWxlITogVWludDMyQXJyYXk7XG4gIHByaXZhdGUgaW52S2V5U2NoZWR1bGUhOiBVaW50MzJBcnJheTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRUYWJsZSgpO1xuICB9XG5cbiAgLy8gVXNpbmcgdmlldy5nZXRVaW50MzIoKSBhbHNvIHN3YXBzIHRoZSBieXRlIG9yZGVyLlxuICB1aW50OEFycmF5VG9VaW50MzJBcnJheV8oYXJyYXlCdWZmZXIpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgbmV3QXJyYXlbaV0gPSB2aWV3LmdldFVpbnQzMihpICogNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG5cbiAgaW5pdFRhYmxlKCkge1xuICAgIGNvbnN0IHNCb3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgaW52U0JveCA9IHRoaXMuaW52U0JveDtcbiAgICBjb25zdCBzdWJNaXggPSB0aGlzLnN1Yk1peDtcbiAgICBjb25zdCBzdWJNaXgwID0gc3ViTWl4WzBdO1xuICAgIGNvbnN0IHN1Yk1peDEgPSBzdWJNaXhbMV07XG4gICAgY29uc3Qgc3ViTWl4MiA9IHN1Yk1peFsyXTtcbiAgICBjb25zdCBzdWJNaXgzID0gc3ViTWl4WzNdO1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG5cbiAgICBjb25zdCBkID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB4aSA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgaWYgKGkgPCAxMjgpIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG4gICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG4gICAgICBzQm94W3hdID0gc3g7XG4gICAgICBpbnZTQm94W3N4XSA9IHg7XG5cbiAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgIGNvbnN0IHgyID0gZFt4XTtcbiAgICAgIGNvbnN0IHg0ID0gZFt4Ml07XG4gICAgICBjb25zdCB4OCA9IGRbeDRdO1xuXG4gICAgICAvLyBDb21wdXRlIHN1Yi9pbnZTdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICAgICAgbGV0IHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgc3ViTWl4MFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIHN1Yk1peDFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICAgICAgc3ViTWl4Mlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICBpbnZTdWJNaXgwW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcbiAgICAgIGludlN1Yk1peDFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgICAgIGludlN1Yk1peDJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgaW52U3ViTWl4M1tzeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICAgICAgaWYgKCF4KSB7XG4gICAgICAgIHggPSB4aSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHBhbmRLZXkoa2V5QnVmZmVyOiBBcnJheUJ1ZmZlcikge1xuICAgIC8vIGNvbnZlcnQga2V5QnVmZmVyIHRvIFVpbnQzMkFycmF5XG4gICAgY29uc3Qga2V5ID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8oa2V5QnVmZmVyKTtcbiAgICBsZXQgc2FtZUtleSA9IHRydWU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwga2V5Lmxlbmd0aCAmJiBzYW1lS2V5KSB7XG4gICAgICBzYW1lS2V5ID0ga2V5W29mZnNldF0gPT09IHRoaXMua2V5W29mZnNldF07XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGNvbnN0IGtleVNpemUgPSAodGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aCk7XG5cbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cblxuICAgIGNvbnN0IGtzUm93cyA9ICh0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNCk7XG4gICAgbGV0IGtzUm93O1xuICAgIGxldCBpbnZLc1JvdztcblxuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gKHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkoa3NSb3dzKSk7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSAodGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpKTtcbiAgICBjb25zdCBzYm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IHJjb24gPSB0aGlzLnJjb247XG5cbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgbGV0IHByZXY7XG4gICAgbGV0IHQ7XG5cbiAgICBmb3IgKGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcbiAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcbiAgICAgICAgcHJldiA9IGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVtrc1Jvd107XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdCA9IHByZXY7XG5cbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID1cbiAgICAgICAgICAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgICAgc2JveFt0ICYgMHhmZl07XG5cbiAgICAgICAgLy8gTWl4IFJjb25cbiAgICAgICAgdCBePSByY29uWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID1cbiAgICAgICAgICAoc2JveFt0ID4+PiAyNF0gPDwgMjQpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoc2JveFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8XG4gICAgICAgICAgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG5cbiAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IHByZXYgPSAoa2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQpID4+PiAwO1xuICAgIH1cblxuICAgIGZvciAoaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgIGlmIChpbnZLc1JvdyAmIDMpIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzYm94W3QgPj4+IDI0XV0gXlxuICAgICAgICAgIGludlN1Yk1peDFbc2JveFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cbiAgICAgICAgICBpbnZTdWJNaXgyW3Nib3hbKHQgPj4+IDgpICYgMHhmZl1dIF5cbiAgICAgICAgICBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cblxuICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID4+PiAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZGluZyB0aGlzIGFzIGEgbWV0aG9kIGdyZWF0bHkgaW1wcm92ZXMgcGVyZm9ybWFuY2UuXG4gIG5ldHdvcmtUb0hvc3RPcmRlclN3YXAod29yZCkge1xuICAgIHJldHVybiAoXG4gICAgICAod29yZCA8PCAyNCkgfFxuICAgICAgKCh3b3JkICYgMHhmZjAwKSA8PCA4KSB8XG4gICAgICAoKHdvcmQgJiAweGZmMDAwMCkgPj4gOCkgfFxuICAgICAgKHdvcmQgPj4+IDI0KVxuICAgICk7XG4gIH1cblxuICBkZWNyeXB0KGlucHV0QXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyLCBvZmZzZXQ6IG51bWJlciwgYWVzSVY6IEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMua2V5U2l6ZSArIDY7XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLmludktleVNjaGVkdWxlO1xuICAgIGNvbnN0IGludlNCT1ggPSB0aGlzLmludlNCb3g7XG5cbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuXG4gICAgY29uc3QgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuXG4gICAgY29uc3QgaW5wdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0QXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG91dHB1dEludDMyID0gbmV3IEludDMyQXJyYXkoaW5wdXRJbnQzMi5sZW5ndGgpO1xuXG4gICAgbGV0IHQwLCB0MSwgdDIsIHQzO1xuICAgIGxldCBzMCwgczEsIHMyLCBzMztcbiAgICBsZXQgaW5wdXRXb3JkczAsIGlucHV0V29yZHMxLCBpbnB1dFdvcmRzMiwgaW5wdXRXb3JkczM7XG5cbiAgICBsZXQga3NSb3csIGk7XG4gICAgY29uc3Qgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgaW5wdXRJbnQzMi5sZW5ndGgpIHtcbiAgICAgIGlucHV0V29yZHMwID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXRdKTtcbiAgICAgIGlucHV0V29yZHMxID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAxXSk7XG4gICAgICBpbnB1dFdvcmRzMiA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMl0pO1xuICAgICAgaW5wdXRXb3JkczMgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDNdKTtcblxuICAgICAgczAgPSBpbnB1dFdvcmRzMCBeIGludktleVNjaGVkdWxlWzBdO1xuICAgICAgczEgPSBpbnB1dFdvcmRzMyBeIGludktleVNjaGVkdWxlWzFdO1xuICAgICAgczIgPSBpbnB1dFdvcmRzMiBeIGludktleVNjaGVkdWxlWzJdO1xuICAgICAgczMgPSBpbnB1dFdvcmRzMSBeIGludktleVNjaGVkdWxlWzNdO1xuXG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPVxuICAgICAgICAgIGludlN1Yk1peDBbczAgPj4+IDI0XSBeXG4gICAgICAgICAgaW52U3ViTWl4MVsoczEgPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDJbKHMyID4+IDgpICYgMHhmZl0gXlxuICAgICAgICAgIGludlN1Yk1peDNbczMgJiAweGZmXSBeXG4gICAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgICB0MSA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMSA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMiA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczMgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMCAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDFdO1xuICAgICAgICB0MiA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMyA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczAgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMSAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9XG4gICAgICAgICAgaW52U3ViTWl4MFtzMyA+Pj4gMjRdIF5cbiAgICAgICAgICBpbnZTdWJNaXgxWyhzMCA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4MlsoczEgPj4gOCkgJiAweGZmXSBeXG4gICAgICAgICAgaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF5cbiAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgczAgPSB0MDtcbiAgICAgICAgczEgPSB0MTtcbiAgICAgICAgczIgPSB0MjtcbiAgICAgICAgczMgPSB0MztcblxuICAgICAgICBrc1JvdyA9IGtzUm93ICsgNDtcbiAgICAgIH1cblxuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICB0MCA9XG4gICAgICAgIChpbnZTQk9YW3MwID4+PiAyNF0gPDwgMjQpIF5cbiAgICAgICAgKGludlNCT1hbKHMxID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMiA+PiA4KSAmIDB4ZmZdIDw8IDgpIF5cbiAgICAgICAgaW52U0JPWFtzMyAmIDB4ZmZdIF5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgdDEgPVxuICAgICAgICAoaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMiA+PiAxNikgJiAweGZmXSA8PCAxNikgXlxuICAgICAgICAoaW52U0JPWFsoczMgPj4gOCkgJiAweGZmXSA8PCA4KSBeXG4gICAgICAgIGludlNCT1hbczAgJiAweGZmXSBeXG4gICAgICAgIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9XG4gICAgICAgIChpbnZTQk9YW3MyID4+PiAyNF0gPDwgMjQpIF5cbiAgICAgICAgKGludlNCT1hbKHMzID4+IDE2KSAmIDB4ZmZdIDw8IDE2KSBeXG4gICAgICAgIChpbnZTQk9YWyhzMCA+PiA4KSAmIDB4ZmZdIDw8IDgpIF5cbiAgICAgICAgaW52U0JPWFtzMSAmIDB4ZmZdIF5cbiAgICAgICAgaW52S2V5U2NoZWR1bGVba3NSb3cgKyAyXTtcbiAgICAgIHQzID1cbiAgICAgICAgKGludlNCT1hbczMgPj4+IDI0XSA8PCAyNCkgXlxuICAgICAgICAoaW52U0JPWFsoczAgPj4gMTYpICYgMHhmZl0gPDwgMTYpIF5cbiAgICAgICAgKGludlNCT1hbKHMxID4+IDgpICYgMHhmZl0gPDwgOCkgXlxuICAgICAgICBpbnZTQk9YW3MyICYgMHhmZl0gXlxuICAgICAgICBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDNdO1xuXG4gICAgICAvLyBXcml0ZVxuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0XSA9IHN3YXBXb3JkKHQwIF4gaW5pdFZlY3RvcjApO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgMV0gPSBzd2FwV29yZCh0MyBeIGluaXRWZWN0b3IxKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDJdID0gc3dhcFdvcmQodDIgXiBpbml0VmVjdG9yMik7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAzXSA9IHN3YXBXb3JkKHQxIF4gaW5pdFZlY3RvcjMpO1xuXG4gICAgICAvLyByZXNldCBpbml0VmVjdG9yIHRvIGxhc3QgNCB1bnNpZ25lZCBpbnRcbiAgICAgIGluaXRWZWN0b3IwID0gaW5wdXRXb3JkczA7XG4gICAgICBpbml0VmVjdG9yMSA9IGlucHV0V29yZHMxO1xuICAgICAgaW5pdFZlY3RvcjIgPSBpbnB1dFdvcmRzMjtcbiAgICAgIGluaXRWZWN0b3IzID0gaW5wdXRXb3JkczM7XG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxufVxuIiwiaW1wb3J0IEFFU0NyeXB0byBmcm9tICcuL2Flcy1jcnlwdG8nO1xuaW1wb3J0IEZhc3RBRVNLZXkgZnJvbSAnLi9mYXN0LWFlcy1rZXknO1xuaW1wb3J0IEFFU0RlY3J5cHRvciwgeyByZW1vdmVQYWRkaW5nIH0gZnJvbSAnLi9hZXMtZGVjcnlwdG9yJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBhcHBlbmRVaW50OEFycmF5IH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IHNsaWNlVWludDggfSBmcm9tICcuLi91dGlscy90eXBlZC1hcnJheSc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmNvbnN0IENIVU5LX1NJWkUgPSAxNjsgLy8gMTYgYnl0ZXMsIDEyOCBiaXRzXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY3J5cHRlciB7XG4gIHByaXZhdGUgbG9nRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgcmVtb3ZlUEtDUzdQYWRkaW5nOiBib29sZWFuO1xuICBwcml2YXRlIHN1YnRsZTogU3VidGxlQ3J5cHRvIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc29mdHdhcmVEZWNyeXB0ZXI6IEFFU0RlY3J5cHRvciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGtleTogQXJyYXlCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmYXN0QWVzS2V5OiBGYXN0QUVTS2V5IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRJVjogQXJyYXlCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50UmVzdWx0OiBBcnJheUJ1ZmZlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHVzZVNvZnR3YXJlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSGxzQ29uZmlnLCB7IHJlbW92ZVBLQ1M3UGFkZGluZyA9IHRydWUgfSA9IHt9KSB7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IGNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA9IHJlbW92ZVBLQ1M3UGFkZGluZztcbiAgICAvLyBidWlsdCBpbiBkZWNyeXB0b3IgZXhwZWN0cyBQS0NTNyBwYWRkaW5nXG4gICAgaWYgKHJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnJvd3NlckNyeXB0byA9IHNlbGYuY3J5cHRvO1xuICAgICAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICAgIHRoaXMuc3VidGxlID1cbiAgICAgICAgICAgIGJyb3dzZXJDcnlwdG8uc3VidGxlIHx8XG4gICAgICAgICAgICAoKGJyb3dzZXJDcnlwdG8gYXMgYW55KS53ZWJraXRTdWJ0bGUgYXMgU3VidGxlQ3J5cHRvKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgaXNTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVNvZnR3YXJlO1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCk6IFVpbnQ4QXJyYXkgfCBudWxsIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSZXN1bHQsIHJlbWFpbmRlckRhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjdXJyZW50UmVzdWx0IHx8IHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoY3VycmVudFJlc3VsdCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIGlmICh0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbW92ZVBhZGRpbmcoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgaWYgKHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWNyeXB0KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgICBrZXk6IEFycmF5QnVmZmVyLFxuICAgIGl2OiBBcnJheUJ1ZmZlcixcbiAgKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4ge1xuICAgIGlmICh0aGlzLnVzZVNvZnR3YXJlKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRSZXN1bHQgPSB0aGlzLmZsdXNoKCk7XG4gICAgICAgIGlmIChkZWNyeXB0UmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShkZWNyeXB0UmVzdWx0LmJ1ZmZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignW3NvZnR3YXJlRGVjcnlwdF0gRmFpbGVkIHRvIGRlY3J5cHQgZGF0YScpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndlYkNyeXB0b0RlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSwgaXYpO1xuICB9XG5cbiAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgcHVibGljIHNvZnR3YXJlRGVjcnlwdChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleTogQXJyYXlCdWZmZXIsXG4gICAgaXY6IEFycmF5QnVmZmVyLFxuICApOiBBcnJheUJ1ZmZlciB8IG51bGwge1xuICAgIGNvbnN0IHsgY3VycmVudElWLCBjdXJyZW50UmVzdWx0LCByZW1haW5kZXJEYXRhIH0gPSB0aGlzO1xuICAgIHRoaXMubG9nT25jZSgnSlMgQUVTIGRlY3J5cHQnKTtcbiAgICAvLyBUaGUgb3V0cHV0IGlzIHN0YWdnZXJlZCBkdXJpbmcgcHJvZ3Jlc3NpdmUgcGFyc2luZyAtIHRoZSBjdXJyZW50IHJlc3VsdCBpcyBjYWNoZWQsIGFuZCBlbWl0dGVkIG9uIHRoZSBuZXh0IGNhbGxcbiAgICAvLyBUaGlzIGlzIGRvbmUgaW4gb3JkZXIgdG8gc3RyaXAgUEtDUzcgcGFkZGluZywgd2hpY2ggaXMgZm91bmQgYXQgdGhlIGVuZCBvZiBlYWNoIHNlZ21lbnQuIFdlIG9ubHkga25vdyB3ZSd2ZSByZWFjaGVkXG4gICAgLy8gdGhlIGVuZCBvbiBmbHVzaCgpLCBidXQgYnkgdGhhdCB0aW1lIHdlIGhhdmUgYWxyZWFkeSByZWNlaXZlZCBhbGwgYnl0ZXMgZm9yIHRoZSBzZWdtZW50LlxuICAgIC8vIFByb2dyZXNzaXZlIGRlY3J5cHRpb24gZG9lcyBub3Qgd29yayB3aXRoIFdlYkNyeXB0b1xuXG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIGRhdGEgPSBhcHBlbmRVaW50OEFycmF5KHJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBCeXRlIGxlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYgKEFFUy0xMjggPSAxMjggYml0IGJsb2NrcyA9IDE2IGJ5dGVzKVxuICAgIGNvbnN0IGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0VmFsaWRDaHVuayhkYXRhKTtcbiAgICBpZiAoIWN1cnJlbnRDaHVuay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cblxuICAgIGxldCBzb2Z0d2FyZURlY3J5cHRlciA9IHRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7XG4gICAgaWYgKCFzb2Z0d2FyZURlY3J5cHRlcikge1xuICAgICAgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbmV3IEFFU0RlY3J5cHRvcigpO1xuICAgIH1cbiAgICBzb2Z0d2FyZURlY3J5cHRlci5leHBhbmRLZXkoa2V5KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGN1cnJlbnRSZXN1bHQ7XG5cbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IHNsaWNlVWludDgoY3VycmVudENodW5rLCAtMTYpLmJ1ZmZlcjtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHB1YmxpYyB3ZWJDcnlwdG9EZWNyeXB0KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5OiBBcnJheUJ1ZmZlcixcbiAgICBpdjogQXJyYXlCdWZmZXIsXG4gICk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgICBjb25zdCBzdWJ0bGUgPSB0aGlzLnN1YnRsZTtcbiAgICBpZiAodGhpcy5rZXkgIT09IGtleSB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBGYXN0QUVTS2V5KHN1YnRsZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmFzdEFlc0tleVxuICAgICAgLmV4cGFuZEtleSgpXG4gICAgICAudGhlbigoYWVzS2V5KSA9PiB7XG4gICAgICAgIC8vIGRlY3J5cHQgdXNpbmcgd2ViIGNyeXB0b1xuICAgICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ3dlYiBjcnlwdG8gbm90IGluaXRpYWxpemVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IG5ldyBBRVNDcnlwdG8oc3VidGxlLCBuZXcgVWludDhBcnJheShpdikpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLmRlY3J5cHQoZGF0YS5idWZmZXIsIGFlc0tleSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYFtkZWNyeXB0ZXJdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSSwgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpO1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdik6IEFycmF5QnVmZmVyIHwgbmV2ZXIge1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdik7XG4gICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkNyeXB0byBhbmQgc29mdHdhcmVEZWNyeXB0OiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH1cblxuICBwcml2YXRlIGdldFZhbGlkQ2h1bmsoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICAgIGxldCBjdXJyZW50Q2h1bmsgPSBkYXRhO1xuICAgIGNvbnN0IHNwbGl0UG9pbnQgPSBkYXRhLmxlbmd0aCAtIChkYXRhLmxlbmd0aCAlIENIVU5LX1NJWkUpO1xuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gc2xpY2VVaW50OChkYXRhLCAwLCBzcGxpdFBvaW50KTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH1cblxuICBwcml2YXRlIGxvZ09uY2UobXNnOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBbZGVjcnlwdGVyXTogJHttc2d9YCk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogIFRpbWVSYW5nZXMgdG8gc3RyaW5nIGhlbHBlclxuICovXG5cbmNvbnN0IFRpbWVSYW5nZXMgPSB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAocjogVGltZVJhbmdlcykge1xuICAgIGxldCBsb2cgPSAnJztcbiAgICBjb25zdCBsZW4gPSByLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsb2cgKz0gYFske3Iuc3RhcnQoaSkudG9GaXhlZCgzKX0tJHtyLmVuZChpKS50b0ZpeGVkKDMpfV1gO1xuICAgIH1cblxuICAgIHJldHVybiBsb2c7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUaW1lUmFuZ2VzO1xuIiwiaW1wb3J0IFRhc2tMb29wIGZyb20gJy4uL3Rhc2stbG9vcCc7XG5pbXBvcnQgeyBGcmFnbWVudFN0YXRlIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcbmltcG9ydCB7IEJ1ZmZlcmFibGUsIEJ1ZmZlckhlbHBlciwgQnVmZmVySW5mbyB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFcnJvckRldGFpbHMsIEVycm9yVHlwZXMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHsgYXBwZW5kVWludDhBcnJheSB9IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBhbGlnblN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL2Rpc2NvbnRpbnVpdGllcyc7XG5pbXBvcnQge1xuICBmaW5kRnJhZ21lbnRCeVBEVCxcbiAgZmluZEZyYWdtZW50QnlQVFMsXG4gIGZpbmRGcmFnV2l0aENDLFxufSBmcm9tICcuL2ZyYWdtZW50LWZpbmRlcnMnO1xuaW1wb3J0IHtcbiAgZmluZFBhcnQsXG4gIGdldEZyYWdtZW50V2l0aFNOLFxuICBnZXRQYXJ0V2l0aCxcbiAgdXBkYXRlRnJhZ1BUU0RUUyxcbn0gZnJvbSAnLi4vdXRpbHMvbGV2ZWwtaGVscGVyJztcbmltcG9ydCBUcmFuc211eGVySW50ZXJmYWNlIGZyb20gJy4uL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCBGcmFnbWVudExvYWRlciwge1xuICBGcmFnbWVudExvYWRQcm9ncmVzc0NhbGxiYWNrLFxuICBMb2FkRXJyb3IsXG59IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudC1sb2FkZXInO1xuaW1wb3J0IEtleUxvYWRlciBmcm9tICcuLi9sb2FkZXIva2V5LWxvYWRlcic7XG5pbXBvcnQgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgRGVjcnlwdGVyIGZyb20gJy4uL2NyeXB0L2RlY3J5cHRlcic7XG5pbXBvcnQgVGltZVJhbmdlcyBmcm9tICcuLi91dGlscy90aW1lLXJhbmdlcyc7XG5pbXBvcnQgeyBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBnZXRSZXRyeURlbGF5IH0gZnJvbSAnLi4vdXRpbHMvZXJyb3ItaGVscGVyJztcbmltcG9ydCB7IE5ldHdvcmtFcnJvckFjdGlvbiB9IGZyb20gJy4vZXJyb3ItY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gIEVycm9yRGF0YSxcbiAgRnJhZ0xvYWRlZERhdGEsXG4gIFBhcnRzTG9hZGVkRGF0YSxcbiAgS2V5TG9hZGVkRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG4gIEJ1ZmZlckZsdXNoaW5nRGF0YSxcbiAgTWFuaWZlc3RMb2FkZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2ZyYWdtZW50LXRyYWNrZXInO1xuaW1wb3J0IHR5cGUgeyBMZXZlbCB9IGZyb20gJy4uL3R5cGVzL2xldmVsJztcbmltcG9ydCB0eXBlIHsgUmVtdXhlZFRyYWNrIH0gZnJvbSAnLi4vdHlwZXMvcmVtdXhlcic7XG5pbXBvcnQgdHlwZSBIbHMgZnJvbSAnLi4vaGxzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB0eXBlIHsgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcbmltcG9ydCB0eXBlIHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5cbnR5cGUgUmVzb2x2ZUZyYWdMb2FkZWQgPSAoRnJhZ0xvYWRlZEVuZERhdGEpID0+IHZvaWQ7XG50eXBlIFJlamVjdEZyYWdMb2FkZWQgPSAoTG9hZEVycm9yKSA9PiB2b2lkO1xuXG5leHBvcnQgY29uc3QgU3RhdGUgPSB7XG4gIFNUT1BQRUQ6ICdTVE9QUEVEJyxcbiAgSURMRTogJ0lETEUnLFxuICBLRVlfTE9BRElORzogJ0tFWV9MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HOiAnRlJBR19MT0FESU5HJyxcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6ICdGUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWScsXG4gIFdBSVRJTkdfVFJBQ0s6ICdXQUlUSU5HX1RSQUNLJyxcbiAgUEFSU0lORzogJ1BBUlNJTkcnLFxuICBQQVJTRUQ6ICdQQVJTRUQnLFxuICBFTkRFRDogJ0VOREVEJyxcbiAgRVJST1I6ICdFUlJPUicsXG4gIFdBSVRJTkdfSU5JVF9QVFM6ICdXQUlUSU5HX0lOSVRfUFRTJyxcbiAgV0FJVElOR19MRVZFTDogJ1dBSVRJTkdfTEVWRUwnLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVN0cmVhbUNvbnRyb2xsZXJcbiAgZXh0ZW5kcyBUYXNrTG9vcFxuICBpbXBsZW1lbnRzIE5ldHdvcmtDb21wb25lbnRBUElcbntcbiAgcHJvdGVjdGVkIGhsczogSGxzO1xuXG4gIHByb3RlY3RlZCBmcmFnUHJldmlvdXM6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBmcmFnQ3VycmVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGZyYWdtZW50VHJhY2tlcjogRnJhZ21lbnRUcmFja2VyO1xuICBwcm90ZWN0ZWQgdHJhbnNtdXhlcjogVHJhbnNtdXhlckludGVyZmFjZSB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgX3N0YXRlOiBzdHJpbmcgPSBTdGF0ZS5TVE9QUEVEO1xuICBwcm90ZWN0ZWQgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZTtcbiAgcHJvdGVjdGVkIG1lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBtZWRpYUJ1ZmZlcjogQnVmZmVyYWJsZSB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgY29uZmlnOiBIbHNDb25maWc7XG4gIHByb3RlY3RlZCBiaXRyYXRlVGVzdDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgbGFzdEN1cnJlbnRUaW1lOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgbmV4dExvYWRQb3NpdGlvbjogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIHN0YXJ0UG9zaXRpb246IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBzdGFydFRpbWVPZmZzZXQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcm90ZWN0ZWQgbG9hZGVkbWV0YWRhdGE6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIHJldHJ5RGF0ZTogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIGxldmVsczogQXJyYXk8TGV2ZWw+IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBmcmFnbWVudExvYWRlcjogRnJhZ21lbnRMb2FkZXI7XG4gIHByb3RlY3RlZCBrZXlMb2FkZXI6IEtleUxvYWRlcjtcbiAgcHJvdGVjdGVkIGxldmVsTGFzdExvYWRlZDogTGV2ZWwgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIHN0YXJ0RnJhZ1JlcXVlc3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgZGVjcnlwdGVyOiBEZWNyeXB0ZXI7XG4gIHByb3RlY3RlZCBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcFtdID0gW107XG4gIHByb3RlY3RlZCBvbnZzZWVraW5nOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBvbnZlbmRlZDogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nUHJlZml4OiBzdHJpbmcgPSAnJztcbiAgcHJvdGVjdGVkIGxvZzogKG1zZzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgd2FybjogKG1zZzogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGhsczogSGxzLFxuICAgIGZyYWdtZW50VHJhY2tlcjogRnJhZ21lbnRUcmFja2VyLFxuICAgIGtleUxvYWRlcjogS2V5TG9hZGVyLFxuICAgIGxvZ1ByZWZpeDogc3RyaW5nLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSBwbGF5bGlzdFR5cGU7XG4gICAgdGhpcy5sb2dQcmVmaXggPSBsb2dQcmVmaXg7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIoaGxzLmNvbmZpZyk7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMuY29uZmlnKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblRpY2tFbmQoKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcHVibGljIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHt9XG5cbiAgcHVibGljIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlci5hYm9ydCh0aGlzLnBsYXlsaXN0VHlwZSk7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWc/LmxvYWRlcikge1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N0cmVhbUVuZGVkKFxuICAgIGJ1ZmZlckluZm86IEJ1ZmZlckluZm8sXG4gICAgbGV2ZWxEZXRhaWxzOiBMZXZlbERldGFpbHMsXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIElmIHBsYXlsaXN0IGlzIGxpdmUsIHRoZXJlIGlzIGFub3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UsIG5vdGhpbmcgYnVmZmVyZWQsIG1lZGlhIGlzIGRldGFjaGVkLFxuICAgIC8vIG9mIG5vdGhpbmcgbG9hZGluZy9sb2FkZWQgcmV0dXJuIGZhbHNlXG4gICAgaWYgKFxuICAgICAgbGV2ZWxEZXRhaWxzLmxpdmUgfHxcbiAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8XG4gICAgICAhYnVmZmVySW5mby5lbmQgfHxcbiAgICAgICF0aGlzLm1lZGlhXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRMaXN0ID0gbGV2ZWxEZXRhaWxzLnBhcnRMaXN0O1xuICAgIC8vIFNpbmNlIHRoZSBsYXN0IHBhcnQgaXNuJ3QgZ3VhcmFudGVlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBsYXN0IHBsYXlsaXN0IHNlZ21lbnQgZm9yIExvdy1MYXRlbmN5IEhMUyxcbiAgICAvLyBjaGVjayBpbnN0ZWFkIGlmIHRoZSBsYXN0IHBhcnQgaXMgYnVmZmVyZWQuXG4gICAgaWYgKHBhcnRMaXN0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vIENoZWNraW5nIHRoZSBtaWRwb2ludCBvZiB0aGUgcGFydCBmb3IgcG90ZW50aWFsIG1hcmdpbiBvZiBlcnJvciBhbmQgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICAvLyBOT1RFOiBUZWNobmljYWxseSBJIGJlbGlldmUgcGFydHMgY291bGQgeWllbGQgY29udGVudCB0aGF0IGlzIDwgdGhlIGNvbXB1dGVkIGR1cmF0aW9uIChpbmNsdWRpbmcgcG90ZW50aWFsIGEgZHVyYXRpb24gb2YgMClcbiAgICAgIC8vIGFuZCBzdGlsbCBiZSBzcGVjLWNvbXBsaWFudCwgc28gdGhlcmUgbWF5IHN0aWxsIGJlIGVkZ2UgY2FzZXMgaGVyZS4gTGlrZXdpc2UsIHRoZXJlIGNvdWxkIGJlIGlzc3VlcyBpbiBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBwYXJ0IG1pc21hdGNoZXMgZm9yIGluZGVwZW5kZW50IGF1ZGlvIGFuZCB2aWRlbyBwbGF5bGlzdHMvc2VnbWVudHMuXG4gICAgICBjb25zdCBsYXN0UGFydEJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmlzQnVmZmVyZWQoXG4gICAgICAgIHRoaXMubWVkaWEsXG4gICAgICAgIGxhc3RQYXJ0LnN0YXJ0ICsgbGFzdFBhcnQuZHVyYXRpb24gLyAyLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBsYXN0UGFydEJ1ZmZlcmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9XG4gICAgICBsZXZlbERldGFpbHMuZnJhZ21lbnRzW2xldmVsRGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV0udHlwZTtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuaXNFbmRMaXN0QXBwZW5kZWQocGxheWxpc3RUeXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRMZXZlbERldGFpbHMoKTogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5sZXZlbHMgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsTGFzdExvYWRlZD8uZGV0YWlscztcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25NZWRpYUF0dGFjaGVkKFxuICAgIGV2ZW50OiBFdmVudHMuTUVESUFfQVRUQUNIRUQsXG4gICAgZGF0YTogTWVkaWFBdHRhY2hlZERhdGEsXG4gICkge1xuICAgIGNvbnN0IG1lZGlhID0gKHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gZGF0YS5tZWRpYSk7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpIGFzIEV2ZW50TGlzdGVuZXI7XG4gICAgdGhpcy5vbnZlbmRlZCA9IHRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcykgYXMgRXZlbnRMaXN0ZW5lcjtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdzZWVraW5nJywgdGhpcy5vbnZzZWVraW5nKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMub252ZW5kZWQpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0aGlzLmxldmVscyAmJiBjb25maWcuYXV0b1N0YXJ0TG9hZCAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5TVE9QUEVEKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZChjb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYT8uZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEgJiYgdGhpcy5vbnZzZWVraW5nICYmIHRoaXMub252ZW5kZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRldGFjaCgpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhU2Vla2luZygpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgZnJhZ0N1cnJlbnQsIG1lZGlhLCBtZWRpYUJ1ZmZlciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFRpbWU6IG51bWJlciA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiAwO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhcbiAgICAgIG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSxcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgY29uZmlnLm1heEJ1ZmZlckhvbGUsXG4gICAgKTtcblxuICAgIHRoaXMubG9nKFxuICAgICAgYG1lZGlhIHNlZWtpbmcgdG8gJHtcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKGN1cnJlbnRUaW1lKSA/IGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgOiBjdXJyZW50VGltZVxuICAgICAgfSwgc3RhdGU6ICR7c3RhdGV9YCxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkVOREVEKSB7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfSBlbHNlIGlmIChmcmFnQ3VycmVudCkge1xuICAgICAgLy8gU2Vla2luZyB3aGlsZSBmcmFnIGxvYWQgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ1N0YXJ0T2Zmc2V0ID0gZnJhZ0N1cnJlbnQuc3RhcnQgLSB0b2xlcmFuY2U7XG4gICAgICBjb25zdCBmcmFnRW5kT2Zmc2V0ID1cbiAgICAgICAgZnJhZ0N1cnJlbnQuc3RhcnQgKyBmcmFnQ3VycmVudC5kdXJhdGlvbiArIHRvbGVyYW5jZTtcbiAgICAgIC8vIGlmIHNlZWtpbmcgb3V0IG9mIGJ1ZmZlcmVkIHJhbmdlIG9yIGludG8gbmV3IG9uZVxuICAgICAgaWYgKFxuICAgICAgICAhYnVmZmVySW5mby5sZW4gfHxcbiAgICAgICAgZnJhZ0VuZE9mZnNldCA8IGJ1ZmZlckluZm8uc3RhcnQgfHxcbiAgICAgICAgZnJhZ1N0YXJ0T2Zmc2V0ID4gYnVmZmVySW5mby5lbmRcbiAgICAgICkge1xuICAgICAgICBjb25zdCBwYXN0RnJhZ21lbnQgPSBjdXJyZW50VGltZSA+IGZyYWdFbmRPZmZzZXQ7XG4gICAgICAgIC8vIGlmIHRoZSBzZWVrIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGN1cnJlbnQgZnJhZ21lbnQgcmFuZ2VcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgZnJhZ1N0YXJ0T2Zmc2V0IHx8IHBhc3RGcmFnbWVudCkge1xuICAgICAgICAgIGlmIChwYXN0RnJhZ21lbnQgJiYgZnJhZ0N1cnJlbnQubG9hZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgICAgJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAvLyBSZW1vdmUgZ2FwIGZyYWdtZW50c1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShcbiAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgIEluZmluaXR5LFxuICAgICAgICB0aGlzLnBsYXlsaXN0VHlwZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMubGFzdEN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSBzZWVraW5nIG9jY3VycyBhbHRob3VnaCBubyBtZWRpYSBidWZmZXJlZCwgYWRqdXN0IHN0YXJ0UG9zaXRpb24gYW5kIG5leHRMb2FkUG9zaXRpb24gdG8gc2VlayB0YXJnZXRcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgIWJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSBjdXJyZW50VGltZTtcbiAgICB9XG5cbiAgICAvLyBBc3luYyB0aWNrIHRvIHNwZWVkIHVwIHByb2Nlc3NpbmdcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRW5kZWQoKSB7XG4gICAgLy8gcmVzZXQgc3RhcnRQb3NpdGlvbiBhbmQgbGFzdEN1cnJlbnRUaW1lIHRvIHJlc3RhcnQgcGxheWJhY2sgQCBzdHJlYW0gYmVnaW5uaW5nXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWFuaWZlc3RMb2FkZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsXG4gICAgZGF0YTogTWFuaWZlc3RMb2FkZWREYXRhLFxuICApOiB2b2lkIHtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IGRhdGEuc3RhcnRUaW1lT2Zmc2V0O1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uSGFuZGxlckRlc3Ryb3llZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICBpZiAodGhpcy5mcmFnbWVudExvYWRlcikge1xuICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtleUxvYWRlcikge1xuICAgICAgdGhpcy5rZXlMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWNyeXB0ZXIpIHtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLmhscyA9XG4gICAgICB0aGlzLmxvZyA9XG4gICAgICB0aGlzLndhcm4gPVxuICAgICAgdGhpcy5kZWNyeXB0ZXIgPVxuICAgICAgdGhpcy5rZXlMb2FkZXIgPVxuICAgICAgdGhpcy5mcmFnbWVudExvYWRlciA9XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9XG4gICAgICAgIG51bGwgYXMgYW55O1xuICAgIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGxvYWRGcmFnbWVudChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLl9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRGcmFnRm9yUGxheWJhY2soXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHRhcmdldEJ1ZmZlclRpbWU6IG51bWJlcixcbiAgKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NDYWxsYmFjazogRnJhZ21lbnRMb2FkUHJvZ3Jlc3NDYWxsYmFjayA9IChcbiAgICAgIGRhdGE6IEZyYWdMb2FkZWREYXRhLFxuICAgICkgPT4ge1xuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICBgRnJhZ21lbnQgJHtmcmFnLnNufSR7XG4gICAgICAgICAgICBkYXRhLnBhcnQgPyAnIHA6ICcgKyBkYXRhLnBhcnQuaW5kZXggOiAnJ1xuICAgICAgICAgIH0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuYCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgfTtcblxuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUsIHByb2dyZXNzQ2FsbGJhY2spXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBoZXJlIHdlIHByb2JhYmx5IG5lZWRlZCB0byBiYWNrdHJhY2sgb3IgYXJlIHdhaXRpbmcgZm9yIG1vcmUgcGFydHNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8XG4gICAgICAgICAgICAoIXRoaXMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgTG9hZGVkIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfWApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgd2hvbGUgcGF5bG9hZDsgY29udHJvbGxlcnMgbm90IGltcGxlbWVudGluZyBwcm9ncmVzc2l2ZSBsb2FkaW5nIHJlY2VpdmUgZGF0YSBmcm9tIHRoaXMgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZGF0YSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjbGVhclRyYWNrZXJJZk5lZWRlZChmcmFnOiBGcmFnbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnRUcmFja2VyIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZyYWdTdGF0ZSA9IGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLkFQUEVORElORykge1xuICAgICAgLy8gTG93ZXIgdGhlIGJ1ZmZlciBzaXplIGFuZCB0cnkgYWdhaW5cbiAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGZyYWcudHlwZSBhcyBQbGF5bGlzdExldmVsVHlwZTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlcixcbiAgICAgICAgcGxheWxpc3RUeXBlLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG1pbkZvcndhcmRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgZnJhZy5kdXJhdGlvbixcbiAgICAgICAgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCxcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluRm9yd2FyZEJ1ZmZlckxlbmd0aCkpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5tZWRpYUJ1ZmZlcj8uYnVmZmVyZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBTdG9wIGdhcCBmb3IgYmFkIHRyYWNrZXIgLyBidWZmZXIgZmx1c2ggYmVoYXZpb3JcbiAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhmcmFnLnR5cGUpKSB7XG4gICAgICAvLyBJbiBsb3cgbGF0ZW5jeSBtb2RlLCByZW1vdmUgZnJhZ21lbnRzIGZvciB3aGljaCBvbmx5IHNvbWUgcGFydHMgd2VyZSBidWZmZXJlZFxuICAgICAgZnJhZ21lbnRUcmFja2VyLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoe1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBzdGF0czogZnJhZy5zdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKGZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tMaXZlVXBkYXRlKGRldGFpbHM6IExldmVsRGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgIWRldGFpbHMubGl2ZSkge1xuICAgICAgLy8gTGl2ZSBzdHJlYW0gZW5kZWQsIHVwZGF0ZSBmcmFnbWVudCB0cmFja2VyXG4gICAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoe1xuICAgICAgICBmcmFnOiBsYXN0RnJhZ21lbnQsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBsYXN0RnJhZ21lbnQuc3RhdHMsXG4gICAgICAgIGlkOiBsYXN0RnJhZ21lbnQudHlwZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzWzBdKSB7XG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZmx1c2hNYWluQnVmZmVyKFxuICAgIHN0YXJ0T2Zmc2V0OiBudW1iZXIsXG4gICAgZW5kT2Zmc2V0OiBudW1iZXIsXG4gICAgdHlwZTogU291cmNlQnVmZmVyTmFtZSB8IG51bGwgPSBudWxsLFxuICApIHtcbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIGNvbnN0IGZsdXNoU2NvcGU6IEJ1ZmZlckZsdXNoaW5nRGF0YSA9IHsgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2xvYWRJbml0U2VnbWVudChmcmFnOiBGcmFnbWVudCwgbGV2ZWw6IExldmVsKSB7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbClcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSB8fCAhdGhpcy5sZXZlbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YTogRnJhZ0xvYWRlZERhdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyBobHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBkZWNyeXB0ZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBheWxvYWQgJiZcbiAgICAgICAgICBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmXG4gICAgICAgICAgZGVjcnlwdERhdGE/LmtleSAmJlxuICAgICAgICAgIGRlY3J5cHREYXRhLml2ICYmXG4gICAgICAgICAgZGVjcnlwdERhdGEubWV0aG9kID09PSAnQUVTLTEyOCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAvLyBkZWNyeXB0IGluaXQgc2VnbWVudCBkYXRhXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyXG4gICAgICAgICAgICAuZGVjcnlwdChcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksXG4gICAgICAgICAgICAgIGRlY3J5cHREYXRhLmtleS5idWZmZXIsXG4gICAgICAgICAgICAgIGRlY3J5cHREYXRhLml2LmJ1ZmZlcixcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICByZWFzb246IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRlY3J5cHRlZERhdGEpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGVjcnlwdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICAgICAgdHN0YXJ0OiBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICB0ZGVjcnlwdDogZW5kVGltZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gZGVjcnlwdGVkRGF0YTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgICAgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZUluaXRTZWdtZW50TG9hZChkYXRhOiBGcmFnTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWxzIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGRhdGEuZnJhZy5zdGF0cztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBkYXRhLmZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmcmFnQ29udGV4dENoYW5nZWQoZnJhZzogRnJhZ21lbnQgfCBudWxsKSB7XG4gICAgY29uc3QgeyBmcmFnQ3VycmVudCB9ID0gdGhpcztcbiAgICByZXR1cm4gKFxuICAgICAgIWZyYWcgfHxcbiAgICAgICFmcmFnQ3VycmVudCB8fFxuICAgICAgZnJhZy5zbiAhPT0gZnJhZ0N1cnJlbnQuc24gfHxcbiAgICAgIGZyYWcubGV2ZWwgIT09IGZyYWdDdXJyZW50LmxldmVsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnOiBGcmFnbWVudCwgcGFydDogUGFydCB8IG51bGwpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICB0aGlzLmxvZyhcbiAgICAgIGBCdWZmZXJlZCAke2ZyYWcudHlwZX0gc246ICR7ZnJhZy5zbn0ke1xuICAgICAgICBwYXJ0ID8gJyBwYXJ0OiAnICsgcGFydC5pbmRleCA6ICcnXG4gICAgICB9IG9mICR7XG4gICAgICAgIHRoaXMucGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gJ2xldmVsJyA6ICd0cmFjaydcbiAgICAgIH0gJHtmcmFnLmxldmVsfSAoZnJhZzpbJHsoZnJhZy5zdGFydFBUUyA/PyBOYU4pLnRvRml4ZWQoMyl9LSR7KFxuICAgICAgICBmcmFnLmVuZFBUUyA/PyBOYU5cbiAgICAgICkudG9GaXhlZCgzKX1dID4gYnVmZmVyOiR7XG4gICAgICAgIG1lZGlhXG4gICAgICAgICAgPyBUaW1lUmFuZ2VzLnRvU3RyaW5nKEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkpXG4gICAgICAgICAgOiAnKGRldGFjaGVkKSdcbiAgICAgIH0pYCxcbiAgICApO1xuICAgIGlmIChmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBpZiAoZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgICBjb25zdCBlbCA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoZWwpLnNvbWUoKHR5cGUpID0+ICEhZWxbdHlwZV0pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgc2VnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmxldmVscz8uW2ZyYWcubGV2ZWxdO1xuICAgICAgaWYgKGxldmVsPy5mcmFnbWVudEVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBSZXNldHRpbmcgbGV2ZWwgZnJhZ21lbnQgZXJyb3IgY291bnQgb2YgJHtsZXZlbC5mcmFnbWVudEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCxcbiAgICAgICAgKTtcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXRoaXMubG9hZGVkbWV0YWRhdGEgJiZcbiAgICAgIGZyYWcudHlwZSA9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOICYmXG4gICAgICBtZWRpYS5idWZmZXJlZC5sZW5ndGggJiZcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQ/LnNuID09PSB0aGlzLmZyYWdQcmV2aW91cz8uc25cbiAgICApIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5zZWVrVG9TdGFydFBvcygpO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZWVrVG9TdGFydFBvcygpIHt9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShmcmFnTG9hZGVkRW5kRGF0YTogUGFydHNMb2FkZWREYXRhKSB7XG4gICAgY29uc3QgeyB0cmFuc211eGVyIH0gPSB0aGlzO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIHBhcnRzTG9hZGVkIH0gPSBmcmFnTG9hZGVkRW5kRGF0YTtcbiAgICAvLyBJZiB3ZSBkaWQgbm90IGxvYWQgcGFydHMsIG9yIGxvYWRlZCBhbGwgcGFydHMsIHdlIGhhdmUgY29tcGxldGUgKG5vdCBwYXJ0aWFsKSBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgY29tcGxldGUgPVxuICAgICAgIXBhcnRzTG9hZGVkIHx8XG4gICAgICBwYXJ0c0xvYWRlZC5sZW5ndGggPT09IDAgfHxcbiAgICAgIHBhcnRzTG9hZGVkLnNvbWUoKGZyYWdMb2FkZWQpID0+ICFmcmFnTG9hZGVkKTtcbiAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShcbiAgICAgIGZyYWcubGV2ZWwsXG4gICAgICBmcmFnLnNuIGFzIG51bWJlcixcbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCArIDEsXG4gICAgICAwLFxuICAgICAgcGFydCA/IHBhcnQuaW5kZXggOiAtMSxcbiAgICAgICFjb21wbGV0ZSxcbiAgICApO1xuICAgIHRyYW5zbXV4ZXIuZmx1c2goY2h1bmtNZXRhKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcHJvdGVjdGVkIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhcbiAgICBmcmFnOiBQYXJ0c0xvYWRlZERhdGEgfCBGcmFnTG9hZGVkRGF0YSxcbiAgKSB7fVxuXG4gIHByb3RlY3RlZCBfZG9GcmFnTG9hZChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz86IEZyYWdtZW50TG9hZFByb2dyZXNzQ2FsbGJhY2ssXG4gICk6IFByb21pc2U8UGFydHNMb2FkZWREYXRhIHwgRnJhZ0xvYWRlZERhdGEgfCBudWxsPiB7XG4gICAgY29uc3QgZGV0YWlscyA9IGxldmVsPy5kZXRhaWxzO1xuICAgIGlmICghdGhpcy5sZXZlbHMgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsJHtkZXRhaWxzID8gJycgOiAnIGRldGFpbCd9c2AsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBrZXlMb2FkaW5nUHJvbWlzZTogUHJvbWlzZTxLZXlMb2FkZWREYXRhIHwgdm9pZD4gfCBudWxsID0gbnVsbDtcbiAgICBpZiAoZnJhZy5lbmNyeXB0ZWQgJiYgIWZyYWcuZGVjcnlwdGRhdGE/LmtleSkge1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBMb2FkaW5nIGtleSBmb3IgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dLCAke1xuICAgICAgICAgIHRoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ1xuICAgICAgICB9ICR7ZnJhZy5sZXZlbH1gLFxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5LRVlfTE9BRElORztcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAga2V5TG9hZGluZ1Byb21pc2UgPSB0aGlzLmtleUxvYWRlci5sb2FkKGZyYWcpLnRoZW4oKGtleUxvYWRlZERhdGEpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURFRCwga2V5TG9hZGVkRGF0YSk7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLktFWV9MT0FESU5HKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuS0VZX0xPQURJTkcsIHsgZnJhZyB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgbmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEtFWV9MT0FESU5HYCksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZnJhZy5lbmNyeXB0ZWQgJiYgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmtleUxvYWRlci5sb2FkQ2xlYXIoZnJhZywgZGV0YWlscy5lbmNyeXB0ZWRGcmFnbWVudHMpO1xuICAgIH1cblxuICAgIHRhcmdldEJ1ZmZlclRpbWUgPSBNYXRoLm1heChmcmFnLnN0YXJ0LCB0YXJnZXRCdWZmZXJUaW1lIHx8IDApO1xuICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBjb25zdCBwYXJ0TGlzdCA9IGRldGFpbHMucGFydExpc3Q7XG4gICAgICBpZiAocGFydExpc3QgJiYgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBpZiAodGFyZ2V0QnVmZmVyVGltZSA+IGZyYWcuZW5kICYmIGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgICAgICAgZnJhZyA9IGRldGFpbHMuZnJhZ21lbnRIaW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHRoaXMuZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgICBpZiAocGFydEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbcGFydEluZGV4XTtcbiAgICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAgIGBMb2FkaW5nIHBhcnQgc246ICR7ZnJhZy5zbn0gcDogJHtwYXJ0LmluZGV4fSBjYzogJHtcbiAgICAgICAgICAgICAgZnJhZy5jY1xuICAgICAgICAgICAgfSBvZiBwbGF5bGlzdCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7XG4gICAgICAgICAgICAgIGRldGFpbHMuZW5kU05cbiAgICAgICAgICAgIH1dIHBhcnRzIFswLSR7cGFydEluZGV4fS0ke3BhcnRMaXN0Lmxlbmd0aCAtIDF9XSAke1xuICAgICAgICAgICAgICB0aGlzLmxvZ1ByZWZpeCA9PT0gJ1tzdHJlYW0tY29udHJvbGxlcl0nID8gJ2xldmVsJyA6ICd0cmFjaydcbiAgICAgICAgICAgIH06ICR7ZnJhZy5sZXZlbH0sIHRhcmdldDogJHtwYXJzZUZsb2F0KFxuICAgICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lLnRvRml4ZWQoMyksXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBwYXJ0LnN0YXJ0ICsgcGFydC5kdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgIGxldCByZXN1bHQ6IFByb21pc2U8UGFydHNMb2FkZWREYXRhIHwgRnJhZ0xvYWRlZERhdGEgfCBudWxsPjtcbiAgICAgICAgICBpZiAoa2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlXG4gICAgICAgICAgICAgIC50aGVuKChrZXlMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIWtleUxvYWRlZERhdGEgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoXG4gICAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5kb0ZyYWdQYXJ0c0xvYWQoXG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrLFxuICAgICAgICAgICAgKS5jYXRjaCgoZXJyb3I6IExvYWRFcnJvcikgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkcgcGFydHNgLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAhZnJhZy51cmwgfHxcbiAgICAgICAgICB0aGlzLmxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIEZyYWdtZW50IGhpbnQgaGFzIG5vIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9nKFxuICAgICAgYExvYWRpbmcgZnJhZ21lbnQgJHtmcmFnLnNufSBjYzogJHtmcmFnLmNjfSAke1xuICAgICAgICBkZXRhaWxzID8gJ29mIFsnICsgZGV0YWlscy5zdGFydFNOICsgJy0nICsgZGV0YWlscy5lbmRTTiArICddICcgOiAnJ1xuICAgICAgfSR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfTogJHtcbiAgICAgICAgZnJhZy5sZXZlbFxuICAgICAgfSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQodGFyZ2V0QnVmZmVyVGltZS50b0ZpeGVkKDMpKX1gLFxuICAgICk7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShmcmFnLnNuIGFzIG51bWJlcikgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGZyYWcuc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuXG4gICAgLy8gTG9hZCBrZXkgYmVmb3JlIHN0cmVhbWluZyBmcmFnbWVudCBkYXRhXG4gICAgY29uc3QgZGF0YU9uUHJvZ3Jlc3MgPSB0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZTtcbiAgICBsZXQgcmVzdWx0OiBQcm9taXNlPFBhcnRzTG9hZGVkRGF0YSB8IEZyYWdMb2FkZWREYXRhIHwgbnVsbD47XG4gICAgaWYgKGRhdGFPblByb2dyZXNzICYmIGtleUxvYWRpbmdQcm9taXNlKSB7XG4gICAgICByZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZVxuICAgICAgICAudGhlbigoa2V5TG9hZGVkRGF0YSkgPT4ge1xuICAgICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhPy5mcmFnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoZnJhZywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIHVuZW5jcnlwdGVkIGZyYWdtZW50IGRhdGEgd2l0aCBwcm9ncmVzcyBldmVudCxcbiAgICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgcmVzdWx0ID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmxvYWQoXG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBkYXRhT25Qcm9ncmVzcyA/IHByb2dyZXNzQ2FsbGJhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgICksXG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlLFxuICAgICAgXSlcbiAgICAgICAgLnRoZW4oKFtmcmFnTG9hZGVkRGF0YV0pID0+IHtcbiAgICAgICAgICBpZiAoIWRhdGFPblByb2dyZXNzICYmIGZyYWdMb2FkZWREYXRhICYmIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soZnJhZ0xvYWRlZERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ0xvYWRlZERhdGE7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURJTkcsIHsgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSB9KTtcbiAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HYCksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBkb0ZyYWdQYXJ0c0xvYWQoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgZnJvbVBhcnQ6IFBhcnQsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHByb2dyZXNzQ2FsbGJhY2s6IEZyYWdtZW50TG9hZFByb2dyZXNzQ2FsbGJhY2ssXG4gICk6IFByb21pc2U8UGFydHNMb2FkZWREYXRhIHwgbnVsbD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShcbiAgICAgIChyZXNvbHZlOiBSZXNvbHZlRnJhZ0xvYWRlZCwgcmVqZWN0OiBSZWplY3RGcmFnTG9hZGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzTG9hZGVkOiBGcmFnTG9hZGVkRGF0YVtdID0gW107XG4gICAgICAgIGNvbnN0IGluaXRpYWxQYXJ0TGlzdCA9IGxldmVsLmRldGFpbHM/LnBhcnRMaXN0O1xuICAgICAgICBjb25zdCBsb2FkUGFydCA9IChwYXJ0OiBQYXJ0KSA9PiB7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudExvYWRlclxuICAgICAgICAgICAgLmxvYWRQYXJ0KGZyYWcsIHBhcnQsIHByb2dyZXNzQ2FsbGJhY2spXG4gICAgICAgICAgICAudGhlbigocGFydExvYWRlZERhdGE6IEZyYWdMb2FkZWREYXRhKSA9PiB7XG4gICAgICAgICAgICAgIHBhcnRzTG9hZGVkW3BhcnQuaW5kZXhdID0gcGFydExvYWRlZERhdGE7XG4gICAgICAgICAgICAgIGNvbnN0IGxvYWRlZFBhcnQgPSBwYXJ0TG9hZGVkRGF0YS5wYXJ0IGFzIFBhcnQ7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID1cbiAgICAgICAgICAgICAgICBnZXRQYXJ0V2l0aChsZXZlbCwgZnJhZy5zbiBhcyBudW1iZXIsIHBhcnQuaW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgIGZpbmRQYXJ0KGluaXRpYWxQYXJ0TGlzdCwgZnJhZy5zbiBhcyBudW1iZXIsIHBhcnQuaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRQYXJ0KSB7XG4gICAgICAgICAgICAgICAgbG9hZFBhcnQobmV4dFBhcnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICBwYXJ0OiBsb2FkZWRQYXJ0LFxuICAgICAgICAgICAgICAgICAgcGFydHNMb2FkZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9hZFBhcnQoZnJvbVBhcnQpO1xuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yOiBMb2FkRXJyb3IgfCBFcnJvcikge1xuICAgIGlmICgnZGF0YScgaW4gZXJyb3IpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBlcnJvci5kYXRhO1xuICAgICAgaWYgKGVycm9yLmRhdGEgJiYgZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuSU5URVJOQUxfQUJPUlRFRCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkQWJvcnRlZChkYXRhLmZyYWcsIGRhdGEucGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZGF0YSBhcyBFcnJvckRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaChjaHVua01ldGE6IENodW5rTWV0YWRhdGEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmZyYWdDdXJyZW50ICYmXG4gICAgICAgIHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRVJST1JcbiAgICAgICkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmcmFnLCBwYXJ0LCBsZXZlbCB9ID0gY29udGV4dDtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGZyYWcuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgaWYgKHBhcnQpIHtcbiAgICAgIHBhcnQuc3RhdHMucGFyc2luZy5lbmQgPSBub3c7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcoZnJhZywgcGFydCwgbGV2ZWwsIGNodW5rTWV0YS5wYXJ0aWFsKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRDdXJyZW50Q29udGV4dChcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICk6IHsgZnJhZzogRnJhZ21lbnQ7IHBhcnQ6IFBhcnQgfCBudWxsOyBsZXZlbDogTGV2ZWwgfSB8IG51bGwge1xuICAgIGNvbnN0IHsgbGV2ZWxzLCBmcmFnQ3VycmVudCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGxldmVsOiBsZXZlbEluZGV4LCBzbiwgcGFydDogcGFydEluZGV4IH0gPSBjaHVua01ldGE7XG4gICAgaWYgKCFsZXZlbHM/LltsZXZlbEluZGV4XSkge1xuICAgICAgdGhpcy53YXJuKFxuICAgICAgICBgTGV2ZWxzIG9iamVjdCB3YXMgdW5zZXQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7c259IG9mIGxldmVsICR7bGV2ZWxJbmRleH0uIFRoZSBjdXJyZW50IGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGNvbnN0IHBhcnQgPSBwYXJ0SW5kZXggPiAtMSA/IGdldFBhcnRXaXRoKGxldmVsLCBzbiwgcGFydEluZGV4KSA6IG51bGw7XG4gICAgY29uc3QgZnJhZyA9IHBhcnRcbiAgICAgID8gcGFydC5mcmFnbWVudFxuICAgICAgOiBnZXRGcmFnbWVudFdpdGhTTihsZXZlbCwgc24sIGZyYWdDdXJyZW50KTtcbiAgICBpZiAoIWZyYWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQgIT09IGZyYWcpIHtcbiAgICAgIGZyYWcuc3RhdHMgPSBmcmFnQ3VycmVudC5zdGF0cztcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJhZywgcGFydCwgbGV2ZWwgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBidWZmZXJGcmFnbWVudERhdGEoXG4gICAgZGF0YTogUmVtdXhlZFRyYWNrLFxuICAgIGZyYWc6IEZyYWdtZW50LFxuICAgIHBhcnQ6IFBhcnQgfCBudWxsLFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSxcbiAgICBub0JhY2t0cmFja2luZz86IGJvb2xlYW4sXG4gICkge1xuICAgIGlmICghZGF0YSB8fCB0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhMSwgZGF0YTIgfSA9IGRhdGE7XG4gICAgbGV0IGJ1ZmZlciA9IGRhdGExO1xuICAgIGlmIChkYXRhMSAmJiBkYXRhMikge1xuICAgICAgLy8gQ29tYmluZSB0aGUgbW9vZiArIG1kYXQgc28gdGhhdCB3ZSBidWZmZXIgd2l0aCBhIHNpbmdsZSBhcHBlbmRcbiAgICAgIGJ1ZmZlciA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKTtcbiAgICB9XG5cbiAgICBpZiAoIWJ1ZmZlcj8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VnbWVudDogQnVmZmVyQXBwZW5kaW5nRGF0YSA9IHtcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICBkYXRhOiBidWZmZXIsXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcblxuICAgIGlmIChkYXRhLmRyb3BwZWQgJiYgZGF0YS5pbmRlcGVuZGVudCAmJiAhcGFydCkge1xuICAgICAgaWYgKG5vQmFja3RyYWNraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIGJ1ZmZlciBzbyB0aGF0IHdlIHJlbG9hZCBwcmV2aW91cyBzZWdtZW50cyBzZXF1ZW50aWFsbHkgaWYgcmVxdWlyZWRcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXJHYXAoZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGZsdXNoQnVmZmVyR2FwKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgaWYgKCFCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IGZyYWcuZHVyYXRpb247XG4gICAgY29uc3Qgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4oXG4gICAgICB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlICogMixcbiAgICAgIGZyYWdEdXJhdGlvbiAqIDAuMjUsXG4gICAgKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KFxuICAgICAgTWF0aC5taW4oZnJhZy5zdGFydCAtIHNlZ21lbnRGcmFjdGlvbiwgYnVmZmVySW5mby5lbmQgLSBzZWdtZW50RnJhY3Rpb24pLFxuICAgICAgY3VycmVudFRpbWUgKyBzZWdtZW50RnJhY3Rpb24sXG4gICAgKTtcbiAgICBpZiAoZnJhZy5zdGFydCAtIHN0YXJ0ID4gc2VnbWVudEZyYWN0aW9uKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydCwgZnJhZy5zdGFydCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldEZ3ZEJ1ZmZlckluZm8oXG4gICAgYnVmZmVyYWJsZTogQnVmZmVyYWJsZSB8IG51bGwsXG4gICAgdHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICk6IEJ1ZmZlckluZm8gfCBudWxsIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHBvcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MoYnVmZmVyYWJsZSwgcG9zLCB0eXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRGd2RCdWZmZXJJbmZvQXRQb3MoXG4gICAgYnVmZmVyYWJsZTogQnVmZmVyYWJsZSB8IG51bGwsXG4gICAgcG9zOiBudW1iZXIsXG4gICAgdHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICk6IEJ1ZmZlckluZm8gfCBudWxsIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHsgbWF4QnVmZmVySG9sZSB9LFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgIC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnQXRQb3MgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgPCBidWZmZXJlZEZyYWdBdFBvcy5lbmQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKFxuICAgICAgICAgIGJ1ZmZlcmFibGUsXG4gICAgICAgICAgcG9zLFxuICAgICAgICAgIE1hdGgubWF4KGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBtYXhCdWZmZXJIb2xlKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlckluZm87XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsQml0cmF0ZT86IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgeyBjb25maWcgfSA9IHRoaXM7XG4gICAgbGV0IG1heEJ1ZkxlbjtcbiAgICBpZiAobGV2ZWxCaXRyYXRlKSB7XG4gICAgICBtYXhCdWZMZW4gPSBNYXRoLm1heChcbiAgICAgICAgKDggKiBjb25maWcubWF4QnVmZmVyU2l6ZSkgLyBsZXZlbEJpdHJhdGUsXG4gICAgICAgIGNvbmZpZy5tYXhCdWZmZXJMZW5ndGgsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhCdWZMZW4gPSBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obWF4QnVmTGVuLCBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWR1Y2VNYXhCdWZmZXJMZW5ndGgodGhyZXNob2xkOiBudW1iZXIpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBtaW5MZW5ndGggPSB0aHJlc2hvbGQgfHwgY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICBpZiAoY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCBhcyBpdCBtaWdodCBiZSB0b28gaGlnaC4gd2UgZG8gdGhpcyB0byBhdm9pZCBsb29wIGZsdXNoaW5nIC4uLlxuICAgICAgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCAvPSAyO1xuICAgICAgdGhpcy53YXJuKGBSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RofXNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0QXBwZW5kZWRGcmFnKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZSA9IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZnJhZ09yUGFydCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEFwcGVuZGVkRnJhZyhcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTixcbiAgICApO1xuICAgIGlmIChmcmFnT3JQYXJ0ICYmICdmcmFnbWVudCcgaW4gZnJhZ09yUGFydCkge1xuICAgICAgcmV0dXJuIGZyYWdPclBhcnQuZnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmcmFnT3JQYXJ0O1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE5leHRGcmFnbWVudChcbiAgICBwb3M6IG51bWJlcixcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuXG4gICAgaWYgKCFmcmFnTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGZyYWdtZW50IGluZGV4LCBjb250aWd1b3VzIHdpdGggZW5kIG9mIGJ1ZmZlciBwb3NpdGlvblxuICAgIGNvbnN0IHsgY29uZmlnIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN0YXJ0ID0gZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGxldCBmcmFnO1xuXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlKSB7XG4gICAgICBjb25zdCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSA9IGNvbmZpZy5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtcbiAgICAgIGlmIChmcmFnTGVuIDwgaW5pdGlhbExpdmVNYW5pZmVzdFNpemUpIHtcbiAgICAgICAgdGhpcy53YXJuKFxuICAgICAgICAgIGBOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogJHtmcmFnTGVufSwgbmVlZDogJHtpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZX0pYCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gZGlzY292ZXIgdGhlIHJhbmdlLCB3ZSBsb2FkIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGF0IGxldmVsIGFuZCBkZW11eCBpdC5cbiAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcbiAgICAgIGlmIChcbiAgICAgICAgKCFsZXZlbERldGFpbHMuUFRTS25vd24gJiZcbiAgICAgICAgICAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiZcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xKSB8fFxuICAgICAgICBwb3MgPCBzdGFydFxuICAgICAgKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnXG4gICAgICAgICAgPyB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IGZyYWcuc3RhcnRcbiAgICAgICAgICA6IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBzdGFydCkge1xuICAgICAgLy8gVm9EIHBsYXlsaXN0OiBpZiBsb2FkUG9zaXRpb24gYmVmb3JlIHN0YXJ0IG9mIHBsYXlsaXN0LCBsb2FkIGZpcnN0IGZyYWdtZW50XG4gICAgICBmcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgcnVuIGludG8gYW55IHNwZWNpYWwgY2FzZXMgYWxyZWFkeSwganVzdCBsb2FkIHRoZSBmcmFnbWVudCBtb3N0IGNsb3NlbHkgbWF0Y2hpbmcgdGhlIHJlcXVlc3RlZCBwb3NpdGlvblxuICAgIGlmICghZnJhZykge1xuICAgICAgY29uc3QgZW5kID0gY29uZmlnLmxvd0xhdGVuY3lNb2RlXG4gICAgICAgID8gbGV2ZWxEZXRhaWxzLnBhcnRFbmRcbiAgICAgICAgOiBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQ7XG4gICAgICBmcmFnID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24ocG9zLCBlbmQsIGxldmVsRGV0YWlscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc0xvb3BMb2FkaW5nKGZyYWc6IEZyYWdtZW50LCB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFja2VyU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICByZXR1cm4gKFxuICAgICAgKHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fFxuICAgICAgICAodHJhY2tlclN0YXRlID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwgJiYgISFmcmFnLmdhcCkpICYmXG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0YXJnZXRCdWZmZXJUaW1lXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgICBidWZmZXJJbmZvOiBCdWZmZXJJbmZvLFxuICAgIHBsYXlsaXN0VHlwZTogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgbWF4QnVmTGVuOiBudW1iZXIsXG4gICk6IEZyYWdtZW50IHwgbnVsbCB7XG4gICAgY29uc3QgZ2FwU3RhcnQgPSBmcmFnLmdhcDtcbiAgICBjb25zdCBuZXh0RnJhZ21lbnQgPSB0aGlzLmdldE5leHRGcmFnbWVudChcbiAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbixcbiAgICAgIGxldmVsRGV0YWlscyxcbiAgICApO1xuICAgIGlmIChuZXh0RnJhZ21lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0RnJhZ21lbnQ7XG4gICAgfVxuICAgIGZyYWcgPSBuZXh0RnJhZ21lbnQ7XG4gICAgaWYgKGdhcFN0YXJ0ICYmIGZyYWcgJiYgIWZyYWcuZ2FwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAvLyBNZWRpYSBidWZmZXJlZCBhZnRlciBHQVAgdGFncyBzaG91bGQgbm90IG1ha2UgdGhlIG5leHQgYnVmZmVyIHRpbWVyYW5nZSBleGNlZWQgZm9yd2FyZCBidWZmZXIgbGVuZ3RoXG4gICAgICBjb25zdCBuZXh0YnVmZmVySW5mbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mb0F0UG9zKFxuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsXG4gICAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0LFxuICAgICAgICBwbGF5bGlzdFR5cGUsXG4gICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0YnVmZmVySW5mbyAhPT0gbnVsbCAmJlxuICAgICAgICBidWZmZXJJbmZvLmxlbiArIG5leHRidWZmZXJJbmZvLmxlbiA+PSBtYXhCdWZMZW5cbiAgICAgICkge1xuICAgICAgICAvLyBSZXR1cm5pbmcgaGVyZSBtaWdodCByZXN1bHQgaW4gbm90IGZpbmRpbmcgYW4gYXVkaW8gYW5kIHZpZGVvIGNhbmRpYXRlIHRvIHNraXAgdG9cbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgYGJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXCIke3BsYXlsaXN0VHlwZX1cIiBwbGF5bGlzdCBzdGFydGluZyBhdCBzbjogJHtmcmFnLnNufWAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIG1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZnJhZzogRnJhZ21lbnQgfCBudWxsKTogdHlwZW9mIGZyYWcge1xuICAgIC8vIElmIGFuIGluaXRTZWdtZW50IGlzIHByZXNlbnQsIGl0IG11c3QgYmUgYnVmZmVyZWQgZmlyc3RcbiAgICBpZiAoZnJhZz8uaW5pdFNlZ21lbnQgJiYgIWZyYWc/LmluaXRTZWdtZW50LmRhdGEgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIHJldHVybiBmcmFnLmluaXRTZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgZ2V0TmV4dFBhcnQoXG4gICAgcGFydExpc3Q6IFBhcnRbXSxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXIsXG4gICk6IG51bWJlciB7XG4gICAgbGV0IG5leHRQYXJ0ID0gLTE7XG4gICAgbGV0IGNvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXBlbmRlbnRBdHRyT21pdHRlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gaW5kZXBlbmRlbnRBdHRyT21pdHRlZCAmJiAhcGFydC5pbmRlcGVuZGVudDtcbiAgICAgIGlmIChuZXh0UGFydCA+IC0xICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBwYXJ0LnN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkID0gcGFydC5sb2FkZWQ7XG4gICAgICBpZiAobG9hZGVkKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAoY29udGlndW91cyB8fCBwYXJ0LmluZGVwZW5kZW50IHx8IGluZGVwZW5kZW50QXR0ck9taXR0ZWQpICYmXG4gICAgICAgIHBhcnQuZnJhZ21lbnQgPT09IGZyYWdcbiAgICAgICkge1xuICAgICAgICBuZXh0UGFydCA9IGk7XG4gICAgICB9XG4gICAgICBjb250aWd1b3VzID0gbG9hZGVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFBhcnQ7XG4gIH1cblxuICBwcml2YXRlIGxvYWRlZEVuZE9mUGFydHMoXG4gICAgcGFydExpc3Q6IFBhcnRbXSxcbiAgICB0YXJnZXRCdWZmZXJUaW1lOiBudW1iZXIsXG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3RQYXJ0ICYmIHRhcmdldEJ1ZmZlclRpbWUgPiBsYXN0UGFydC5zdGFydCAmJiBsYXN0UGFydC5sb2FkZWQ7XG4gIH1cblxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIHByb3RlY3RlZCBnZXRJbml0aWFsTGl2ZUZyYWdtZW50KFxuICAgIGxldmVsRGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIGZyYWdtZW50czogQXJyYXk8RnJhZ21lbnQ+LFxuICApOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIGxldCBmcmFnOiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICAgIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICAgIGlmIChsZXZlbERldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyBQRFQsIGJlY2F1c2UgaXQgY2FuIGJlIGFjY3VyYXRlIGVub3VnaCB0byBjaG9vc2UgdGhlIGNvcnJlY3QgZnJhZ21lbnQgd2l0aG91dCBrbm93aW5nIHRoZSBsZXZlbCBzbGlkaW5nXG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgUERUOiAke2ZyYWdQcmV2aW91cy5wcm9ncmFtRGF0ZVRpbWV9YCxcbiAgICAgICAgKTtcbiAgICAgICAgZnJhZyA9IGZpbmRGcmFnbWVudEJ5UERUKFxuICAgICAgICAgIGZyYWdtZW50cyxcbiAgICAgICAgICBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWcpIHtcbiAgICAgICAgLy8gU04gZG9lcyBub3QgbmVlZCB0byBiZSBhY2N1cmF0ZSBiZXR3ZWVuIHJlbmRpdGlvbnMsIGJ1dCBkZXBlbmRpbmcgb24gdGhlIHBhY2thZ2luZyBpdCBtYXkgYmUgc28uXG4gICAgICAgIGNvbnN0IHRhcmdldFNOID0gKGZyYWdQcmV2aW91cy5zbiBhcyBudW1iZXIpICsgMTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRhcmdldFNOID49IGxldmVsRGV0YWlscy5zdGFydFNOICYmXG4gICAgICAgICAgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGZyYWdOZXh0ID0gZnJhZ21lbnRzW3RhcmdldFNOIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U05dO1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlJ3JlIHN0YXlpbmcgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlLCBzaW5jZSBQVFMgcmVzZXRzIHVwb24gYSBuZXcgcmFuZ2VcbiAgICAgICAgICBpZiAoZnJhZ1ByZXZpb3VzLmNjID09PSBmcmFnTmV4dC5jYykge1xuICAgICAgICAgICAgZnJhZyA9IGZyYWdOZXh0O1xuICAgICAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgICAgIGBMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIG5leHQgU046ICR7XG4gICAgICAgICAgICAgICAgZnJhZyEuc25cbiAgICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBzdGF5IHdpdGhpbiB0aGUgY29udGludWl0eSByYW5nZSBpZiBhdmFpbGFibGU7IG90aGVyd2lzZSB0aGUgZnJhZ21lbnRzIGluIHRoZSBwbGF5bGlzdFxuICAgICAgICAvLyB3aWxsIGhhdmUgdGhlIHdyb25nIHN0YXJ0IHRpbWVzXG4gICAgICAgIGlmICghZnJhZykge1xuICAgICAgICAgIGZyYWcgPSBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIGZyYWdQcmV2aW91cy5jYyk7XG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgICAgICBgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIENDOiAke2ZyYWcuc259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgYSBuZXcgc3RhcnQgZnJhZ21lbnQgd2hlbiBmcmFnUHJldmlvdXMgaXMgbnVsbFxuICAgICAgY29uc3QgbGl2ZVN0YXJ0ID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgIGlmIChsaXZlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgZnJhZyA9IHRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKFxuICAgICAgICAgIGxpdmVTdGFydCxcbiAgICAgICAgICB0aGlzLmJpdHJhdGVUZXN0ID8gbGV2ZWxEZXRhaWxzLmZyYWdtZW50RW5kIDogbGV2ZWxEZXRhaWxzLmVkZ2UsXG4gICAgICAgICAgbGV2ZWxEZXRhaWxzLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEZyYWdtZW50QXRQb3NpdGlvbihcbiAgICBidWZmZXJFbmQ6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBsZXZlbERldGFpbHM6IExldmVsRGV0YWlscyxcbiAgKTogRnJhZ21lbnQgfCBudWxsIHtcbiAgICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcztcbiAgICBsZXQgeyBmcmFnUHJldmlvdXMgfSA9IHRoaXM7XG4gICAgbGV0IHsgZnJhZ21lbnRzLCBlbmRTTiB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHsgZnJhZ21lbnRIaW50IH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgY29uc3QgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7XG5cbiAgICBjb25zdCBsb2FkaW5nUGFydHMgPSAhIShcbiAgICAgIGNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJlxuICAgICAgcGFydExpc3Q/Lmxlbmd0aCAmJlxuICAgICAgZnJhZ21lbnRIaW50XG4gICAgKTtcbiAgICBpZiAobG9hZGluZ1BhcnRzICYmIGZyYWdtZW50SGludCAmJiAhdGhpcy5iaXRyYXRlVGVzdCkge1xuICAgICAgLy8gSW5jbHVkZSBpbmNvbXBsZXRlIGZyYWdtZW50IHdpdGggcGFydHMgYXQgZW5kXG4gICAgICBmcmFnbWVudHMgPSBmcmFnbWVudHMuY29uY2F0KGZyYWdtZW50SGludCk7XG4gICAgICBlbmRTTiA9IGZyYWdtZW50SGludC5zbiBhcyBudW1iZXI7XG4gICAgfVxuXG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGJ1ZmZlckVuZCA8IGVuZCkge1xuICAgICAgY29uc3QgbG9va3VwVG9sZXJhbmNlID0gYnVmZmVyRW5kID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdG9sZXJhbmNlIGlmIGl0IHdvdWxkIHB1dCB0aGUgYnVmZmVyRW5kIHBhc3QgdGhlIGFjdHVhbCBlbmQgb2Ygc3RyZWFtXG4gICAgICAvLyBVc2VzIGJ1ZmZlciBhbmQgc2VxdWVuY2UgbnVtYmVyIHRvIGNhbGN1bGF0ZSBzd2l0Y2ggc2VnbWVudCAocmVxdWlyZWQgaWYgdXNpbmcgRVhULVgtRElTQ09OVElOVUlUWS1TRVFVRU5DRSlcbiAgICAgIGZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhcbiAgICAgICAgZnJhZ1ByZXZpb3VzLFxuICAgICAgICBmcmFnbWVudHMsXG4gICAgICAgIGJ1ZmZlckVuZCxcbiAgICAgICAgbG9va3VwVG9sZXJhbmNlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBpZiAoZnJhZykge1xuICAgICAgY29uc3QgY3VyU05JZHggPSBmcmFnLnNuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICAvLyBNb3ZlIGZyYWdQcmV2aW91cyBmb3J3YXJkIHRvIHN1cHBvcnQgZm9yY2luZyB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkXG4gICAgICAvLyB3aGVuIHRoZSBidWZmZXIgY2F0Y2hlcyB1cCB0byBhIHByZXZpb3VzbHkgYnVmZmVyZWQgcmFuZ2UuXG4gICAgICBjb25zdCBmcmFnU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICAgIGlmIChcbiAgICAgICAgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8XG4gICAgICAgIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiBmcmFnLmdhcClcbiAgICAgICkge1xuICAgICAgICBmcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBmcmFnUHJldmlvdXMgJiZcbiAgICAgICAgZnJhZy5zbiA9PT0gZnJhZ1ByZXZpb3VzLnNuICYmXG4gICAgICAgICghbG9hZGluZ1BhcnRzIHx8IHBhcnRMaXN0WzBdLmZyYWdtZW50LnNuID4gZnJhZy5zbilcbiAgICAgICkge1xuICAgICAgICAvLyBGb3JjZSB0aGUgbmV4dCBmcmFnbWVudCB0byBsb2FkIGlmIHRoZSBwcmV2aW91cyBvbmUgd2FzIGFscmVhZHkgc2VsZWN0ZWQuIFRoaXMgY2FuIG9jY2FzaW9uYWxseSBoYXBwZW4gd2l0aFxuICAgICAgICAvLyBub24tdW5pZm9ybSBmcmFnbWVudCBkdXJhdGlvbnNcbiAgICAgICAgY29uc3Qgc2FtZUxldmVsID0gZnJhZ1ByZXZpb3VzICYmIGZyYWcubGV2ZWwgPT09IGZyYWdQcmV2aW91cy5sZXZlbDtcbiAgICAgICAgaWYgKHNhbWVMZXZlbCkge1xuICAgICAgICAgIGNvbnN0IG5leHRGcmFnID0gZnJhZ21lbnRzW2N1clNOSWR4ICsgMV07XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnJhZy5zbiA8IGVuZFNOICYmXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShuZXh0RnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0tcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZyYWcgPSBuZXh0RnJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN5bmNocm9uaXplVG9MaXZlRWRnZShsZXZlbERldGFpbHM6IExldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHsgY29uZmlnLCBtZWRpYSB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpdmVTeW5jUG9zaXRpb24gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3Qgc3RhcnQgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgIGNvbnN0IGVuZCA9IGxldmVsRGV0YWlscy5lZGdlO1xuICAgIGNvbnN0IHdpdGhpblNsaWRpbmdXaW5kb3cgPVxuICAgICAgY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJlxuICAgICAgY3VycmVudFRpbWUgPD0gZW5kO1xuICAgIC8vIENvbnRpbnVlIGlmIHdlIGNhbiBzZWVrIGZvcndhcmQgdG8gc3luYyBwb3NpdGlvbiBvciBpZiBjdXJyZW50IHRpbWUgaXMgb3V0c2lkZSBvZiBzbGlkaW5nIHdpbmRvd1xuICAgIGlmIChcbiAgICAgIGxpdmVTeW5jUG9zaXRpb24gIT09IG51bGwgJiZcbiAgICAgIG1lZGlhLmR1cmF0aW9uID4gbGl2ZVN5bmNQb3NpdGlvbiAmJlxuICAgICAgKGN1cnJlbnRUaW1lIDwgbGl2ZVN5bmNQb3NpdGlvbiB8fCAhd2l0aGluU2xpZGluZ1dpbmRvdylcbiAgICApIHtcbiAgICAgIC8vIENvbnRpbnVlIGlmIGJ1ZmZlciBpcyBzdGFydmluZyBvciBpZiBjdXJyZW50IHRpbWUgaXMgYmVoaW5kIG1heCBsYXRlbmN5XG4gICAgICBjb25zdCBtYXhMYXRlbmN5ID1cbiAgICAgICAgY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gY29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25cbiAgICAgICAgICA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAoXG4gICAgICAgICghd2l0aGluU2xpZGluZ1dpbmRvdyAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgNCkgfHxcbiAgICAgICAgY3VycmVudFRpbWUgPCBlbmQgLSBtYXhMYXRlbmN5XG4gICAgICApIHtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHNlZWsgaWYgcmVhZHkgYW5kIHRoZXJlIGlzIG5vdCBhIHNpZ25pZmljYW50IGZvcndhcmQgYnVmZmVyIGF2YWlsYWJsZSBmb3IgcGxheWJhY2tcbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgICBgUGxheWJhY2s6ICR7Y3VycmVudFRpbWUudG9GaXhlZChcbiAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2VuZH0sIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogJHtsaXZlU3luY1Bvc2l0aW9uLnRvRml4ZWQoXG4gICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgYWxpZ25QbGF5bGlzdHMoXG4gICAgZGV0YWlsczogTGV2ZWxEZXRhaWxzLFxuICAgIHByZXZpb3VzRGV0YWlsczogTGV2ZWxEZXRhaWxzIHwgdW5kZWZpbmVkLFxuICAgIHN3aXRjaERldGFpbHM6IExldmVsRGV0YWlscyB8IHVuZGVmaW5lZCxcbiAgKTogbnVtYmVyIHtcbiAgICAvLyBGSVhNRTogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG4gICAgY29uc3QgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oYE5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0YCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgY29uc3QgZmlyc3RMZXZlbExvYWQgPSAhcHJldmlvdXNEZXRhaWxzO1xuICAgIGNvbnN0IGFsaWduZWQgPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIE51bWJlci5pc0Zpbml0ZShzbGlkaW5nU3RhcnQpO1xuICAgIGlmIChmaXJzdExldmVsTG9hZCB8fCAoIWFsaWduZWQgJiYgIXNsaWRpbmdTdGFydCkpIHtcbiAgICAgIGNvbnN0IHsgZnJhZ1ByZXZpb3VzIH0gPSB0aGlzO1xuICAgICAgYWxpZ25TdHJlYW0oZnJhZ1ByZXZpb3VzLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICAgIGNvbnN0IGFsaWduZWRTbGlkaW5nU3RhcnQgPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiAke2FsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKX0gc3RhcnQtc246ICR7XG4gICAgICAgICAgcHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnXG4gICAgICAgIH0tPiR7ZGV0YWlscy5zdGFydFNOfSBwcmV2LXNuOiAke1xuICAgICAgICAgIGZyYWdQcmV2aW91cyA/IGZyYWdQcmV2aW91cy5zbiA6ICduYSdcbiAgICAgICAgfSBmcmFnbWVudHM6ICR7bGVuZ3RofWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFsaWduZWRTbGlkaW5nU3RhcnQ7XG4gICAgfVxuICAgIHJldHVybiBzbGlkaW5nU3RhcnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgd2FpdEZvckNkblR1bmVJbihkZXRhaWxzOiBMZXZlbERldGFpbHMpIHtcbiAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pbiB0byBnZXQgYW4gdXBkYXRlZCBwbGF5bGlzdFxuICAgIGNvbnN0IGFkdmFuY2VQYXJ0TGltaXQgPSAzO1xuICAgIHJldHVybiAoXG4gICAgICBkZXRhaWxzLmxpdmUgJiZcbiAgICAgIGRldGFpbHMuY2FuQmxvY2tSZWxvYWQgJiZcbiAgICAgIGRldGFpbHMucGFydFRhcmdldCAmJlxuICAgICAgZGV0YWlscy50dW5lSW5Hb2FsID5cbiAgICAgICAgTWF0aC5tYXgoZGV0YWlscy5wYXJ0SG9sZEJhY2ssIGRldGFpbHMucGFydFRhcmdldCAqIGFkdmFuY2VQYXJ0TGltaXQpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRTdGFydFBvc2l0aW9uKGRldGFpbHM6IExldmVsRGV0YWlscywgc2xpZGluZzogbnVtYmVyKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICBjb25zdCBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0XG4gICAgICAgID8gdGhpcy5zdGFydFRpbWVPZmZzZXRcbiAgICAgICAgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgIT09IG51bGwgJiYgTnVtYmVyLmlzRmluaXRlKHN0YXJ0VGltZU9mZnNldCkpIHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHNsaWRpbmcgKyBzdGFydFRpbWVPZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KHNsaWRpbmcsIHN0YXJ0UG9zaXRpb24pLFxuICAgICAgICAgIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24sXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBTdGFydCB0aW1lIG9mZnNldCAke3N0YXJ0VGltZU9mZnNldH0gZm91bmQgaW4gJHtcbiAgICAgICAgICAgIG9mZnNldEluTXVsdGl2YXJpYW50UGxheWxpc3QgPyAnbXVsdGl2YXJpYW50JyA6ICdtZWRpYSdcbiAgICAgICAgICB9IHBsYXlsaXN0LCBhZGp1c3Qgc3RhcnRQb3NpdGlvbiB0byAke3N0YXJ0UG9zaXRpb259YCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIExlYXZlIHRoaXMuc3RhcnRQb3NpdGlvbiBhdCAtMSwgc28gdGhhdCB3ZSBjYW4gdXNlIGBnZXRJbml0aWFsTGl2ZUZyYWdtZW50YCBsb2dpYyB3aGVuIHN0YXJ0UG9zaXRpb24gaGFzXG4gICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgc2xpZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldExvYWRQb3NpdGlvbigpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgLy8gaWYgd2UgaGF2ZSBub3QgeWV0IGxvYWRlZCBhbnkgZnJhZ21lbnQsIHN0YXJ0IGxvYWRpbmcgZnJvbSBzdGFydCBwb3NpdGlvblxuICAgIGxldCBwb3MgPSAwO1xuICAgIGlmICh0aGlzLmxvYWRlZG1ldGFkYXRhICYmIG1lZGlhKSB7XG4gICAgICBwb3MgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubmV4dExvYWRQb3NpdGlvbikge1xuICAgICAgcG9zID0gdGhpcy5uZXh0TG9hZFBvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZyYWdMb2FkQWJvcnRlZChmcmFnOiBGcmFnbWVudCwgcGFydDogUGFydCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHBhcnQgJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtcbiAgICAgICAgICBmcmFnLmxldmVsXG4gICAgICAgIH0gd2FzIGFib3J0ZWRgLFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuZnJhZ0N1cnJlbnQgfHxcbiAgICAgICghdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgJiZcbiAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpXG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb25GcmFnbWVudE9yS2V5TG9hZEVycm9yKFxuICAgIGZpbHRlclR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICAgIGRhdGE6IEVycm9yRGF0YSxcbiAgKSB7XG4gICAgaWYgKGRhdGEuY2h1bmtNZXRhICYmICFkYXRhLmZyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGRhdGEuY2h1bmtNZXRhKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeSAke2ZyYWcudXJsfSA+ICR7dGhpcy5mcmFnQ3VycmVudD8udXJsfWAsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgIGlmIChnYXBUYWdFbmNvdW50ZXJlZCkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb247XG4gICAgY29uc3QgeyBhY3Rpb24sIHJldHJ5Q291bnQgPSAwLCByZXRyeUNvbmZpZyB9ID0gZXJyb3JBY3Rpb24gfHwge307XG4gICAgaWYgKFxuICAgICAgZXJyb3JBY3Rpb24gJiZcbiAgICAgIGFjdGlvbiA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlJldHJ5UmVxdWVzdCAmJlxuICAgICAgcmV0cnlDb25maWdcbiAgICApIHtcbiAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQodGhpcy5sZXZlbExhc3RMb2FkZWQpO1xuICAgICAgY29uc3QgZGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50KTtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHtmaWx0ZXJUeXBlfSAke2ZyYWcubGV2ZWx9IGVycm9yZWQgd2l0aCAke1xuICAgICAgICAgIGRhdGEuZGV0YWlsc1xuICAgICAgICB9LCByZXRyeWluZyBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7XG4gICAgICAgICAgcmV0cnlDb25maWcubWF4TnVtUmV0cnlcbiAgICAgICAgfSBpbiAke2RlbGF5fW1zYCxcbiAgICAgICk7XG4gICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICB0aGlzLnJldHJ5RGF0ZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgKyBkZWxheTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTtcbiAgICB9IGVsc2UgaWYgKHJldHJ5Q29uZmlnICYmIGVycm9yQWN0aW9uKSB7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSk7XG4gICAgICBpZiAocmV0cnlDb3VudCA8IHJldHJ5Q29uZmlnLm1heE51bVJldHJ5KSB7XG4gICAgICAgIC8vIE5ldHdvcmsgcmV0cnkgaXMgc2tpcHBlZCB3aGVuIGxldmVsIHN3aXRjaCBpcyBwcmVmZXJyZWRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFnYXBUYWdFbmNvdW50ZXJlZCAmJlxuICAgICAgICAgIGFjdGlvbiAhPT0gTmV0d29ya0Vycm9yQWN0aW9uLlJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5XG4gICAgICAgICkge1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYCR7ZGF0YS5kZXRhaWxzfSByZWFjaGVkIG9yIGV4Y2VlZGVkIG1heCByZXRyeSAoJHtyZXRyeUNvdW50fSlgLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGVycm9yQWN0aW9uPy5hY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94XG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgIH1cbiAgICAvLyBQZXJmb3JtIG5leHQgYXN5bmMgdGljayBzb29uZXIgdG8gc3BlZWQgdXAgZXJyb3IgYWN0aW9uIHJlc29sdXRpb25cbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcihkYXRhOiBFcnJvckRhdGEpOiBib29sZWFuIHtcbiAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGRhdGEucGFyZW50IGFzIFBsYXlsaXN0TGV2ZWxUeXBlO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKFxuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyLFxuICAgICAgICBwbGF5bGlzdFR5cGUsXG4gICAgICApO1xuICAgICAgLy8gMC41IDogdG9sZXJhbmNlIG5lZWRlZCBhcyBzb21lIGJyb3dzZXJzIHN0YWxscyBwbGF5YmFjayBiZWZvcmUgcmVhY2hpbmcgYnVmZmVyZWQgZW5kXG4gICAgICAvLyByZWR1Y2UgbWF4IGJ1ZiBsZW4gaWYgY3VycmVudCBwb3NpdGlvbiBpcyBidWZmZXJlZFxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBidWZmZXJlZEluZm8gJiYgYnVmZmVyZWRJbmZvLmxlbiA+IDAuNTtcbiAgICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgICB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChidWZmZXJlZEluZm8ubGVuKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsdXNoQnVmZmVyID0gIWJ1ZmZlcmVkO1xuICAgICAgaWYgKGZsdXNoQnVmZmVyKSB7XG4gICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLCBidXQgYnJvd3NlciBpcyBzdGlsbCBjb21wbGFpbmluZyBhYm91dCBidWZmZXIgZnVsbCBlcnJvclxuICAgICAgICAvLyB0aGlzIGhhcHBlbnMgb24gSUUvRWRnZSwgcmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvcHVsbC83MDhcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGZsdXNoIHRoZSB3aG9sZSBhdWRpbyBidWZmZXIgdG8gcmVjb3ZlclxuICAgICAgICB0aGlzLndhcm4oXG4gICAgICAgICAgYEJ1ZmZlciBmdWxsIGVycm9yIHdoaWxlIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggJHtwbGF5bGlzdFR5cGV9IGJ1ZmZlcmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5mcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGRhdGEuZnJhZyk7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuZnJhZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIHJldHVybiBmbHVzaEJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZTogUGxheWxpc3RMZXZlbFR5cGUpIHtcbiAgICBpZiAoZmlsdGVyVHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pIHtcbiAgICAgIC8vIFJlc2V0IGN1cnJlbnQgZnJhZ21lbnQgc2luY2UgYXVkaW8gdHJhY2sgYXVkaW8gaXMgZXNzZW50aWFsIGFuZCBtYXkgbm90IGhhdmUgYSBmYWlsLW92ZXIgdHJhY2tcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGcmFnbWVudCBlcnJvcnMgdGhhdCByZXN1bHQgaW4gYSBsZXZlbCBzd2l0Y2ggb3IgcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgIC8vIHNob3VsZCByZXNldCB0aGUgc3RyZWFtIGNvbnRyb2xsZXIgc3RhdGUgdG8gaWRsZVxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhZnRlckJ1ZmZlckZsdXNoZWQoXG4gICAgbWVkaWE6IEJ1ZmZlcmFibGUsXG4gICAgYnVmZmVyVHlwZTogU291cmNlQnVmZmVyTmFtZSxcbiAgICBwbGF5bGlzdFR5cGU6IFBsYXlsaXN0TGV2ZWxUeXBlLFxuICApIHtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEFmdGVyIHN1Y2Nlc3NmdWwgYnVmZmVyIGZsdXNoaW5nLCBmaWx0ZXIgZmx1c2hlZCBmcmFnbWVudHMgZnJvbSBidWZmZXJlZEZyYWdzIHVzZSBtZWRpYUJ1ZmZlcmVkIGluc3RlYWQgb2YgbWVkaWFcbiAgICAvLyAoc28gdGhhdCB3ZSB3aWxsIGNoZWNrIGFnYWluc3QgdmlkZW8uYnVmZmVyZWQgcmFuZ2VzIGluIGNhc2Ugb2YgYWx0IGF1ZGlvIHRyYWNrKVxuICAgIGNvbnN0IGJ1ZmZlcmVkVGltZVJhbmdlcyA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyhcbiAgICAgIGJ1ZmZlclR5cGUsXG4gICAgICBidWZmZXJlZFRpbWVSYW5nZXMsXG4gICAgICBwbGF5bGlzdFR5cGUsXG4gICAgKTtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRU5ERUQpIHtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRMb2FkaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5sb2coJ1Jlc2V0IGxvYWRpbmcgc3RhdGUnKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQobGV2ZWw6IExldmVsIHwgbnVsbCk6IHZvaWQge1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgZmlyc3QgZnJhZyByZXF1ZXN0IGZhaWxlZFxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwgPyBsZXZlbC5kZXRhaWxzIDogbnVsbDtcbiAgICAgIGlmIChkZXRhaWxzPy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkge1xuICAgIHRoaXMud2FybihcbiAgICAgIGBUaGUgbG9hZGluZyBjb250ZXh0IGNoYW5nZWQgd2hpbGUgYnVmZmVyaW5nIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSBvZiBsZXZlbCAke2NodW5rTWV0YS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCxcbiAgICApO1xuICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsTGFzdExvYWRlZCk7XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydDogbnVtYmVyID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoXG4gICAgICBzdGFydCxcbiAgICAgIEluZmluaXR5LFxuICAgICAgdGhpcy5wbGF5bGlzdFR5cGUsXG4gICAgICBmYWxzZSxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTGV2ZWxUaW1pbmcoXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgcGFydDogUGFydCB8IG51bGwsXG4gICAgbGV2ZWw6IExldmVsLFxuICAgIHBhcnRpYWw6IGJvb2xlYW4sXG4gICkge1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzIGFzIExldmVsRGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybignbGV2ZWwuZGV0YWlscyB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmtleXMoZnJhZy5lbGVtZW50YXJ5U3RyZWFtcykucmVkdWNlKFxuICAgICAgKHJlc3VsdCwgdHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBpbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1t0eXBlXTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWREdXJhdGlvbiA9IGluZm8uZW5kUFRTIC0gaW5mby5zdGFydFBUUztcbiAgICAgICAgICBpZiAocGFyc2VkRHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgdHJhbnNtdXhlciBhZnRlciBpdCdzIG5leHQgdGltZSBvZmZzZXQgZmFpbGVkIHRvIGFkdmFuY2UgYmVjYXVzZSBkdXJhdGlvbiB3YXMgPD0gMC5cbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgICAgLy8gcHJldmVudGluZyB0aGUgdGltZWxpbmUgZnJvbSBzaGlmdGluZy5cbiAgICAgICAgICAgIHRoaXMud2FybihcbiAgICAgICAgICAgICAgYENvdWxkIG5vdCBwYXJzZSBmcmFnbWVudCAke2ZyYWcuc259ICR7dHlwZX0gZHVyYXRpb24gcmVsaWFibHkgKCR7cGFyc2VkRHVyYXRpb259KWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZHJpZnQgPSBwYXJ0aWFsXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogdXBkYXRlRnJhZ1BUU0RUUyhcbiAgICAgICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgaW5mby5zdGFydFBUUyxcbiAgICAgICAgICAgICAgICBpbmZvLmVuZFBUUyxcbiAgICAgICAgICAgICAgICBpbmZvLnN0YXJ0RFRTLFxuICAgICAgICAgICAgICAgIGluZm8uZW5kRFRTLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBkcmlmdCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgICBlbmQ6IGluZm8uZW5kUFRTLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICBpZiAoIXBhcnNlZCAmJiB0aGlzLnRyYW5zbXV4ZXI/LmVycm9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYEZvdW5kIG5vIG1lZGlhIGluIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdgLFxuICAgICAgKTtcbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIC8vIE1hcmsgYW5kIHRyYWNrIHRoZSBvZGQgZW1wdHkgc2VnbWVudCBhcyBhIGdhcCB0byBhdm9pZCByZWxvYWRpbmdcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmcmFnLFxuICAgICAgICByZWFzb246IGBGb3VuZCBubyBtZWRpYSBpbiBtc24gJHtmcmFnLnNufSBvZiBsZXZlbCBcIiR7bGV2ZWwudXJsfVwiYCxcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmhscykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgLy8gRm9yIHRoaXMgZXJyb3IgZmFsbHRocm91Z2guIE1hcmtpbmcgcGFyc2VkIHdpbGwgYWxsb3cgYWR2YW5jaW5nIHRvIG5leHQgZnJhZ21lbnQuXG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTRUQ7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTRUQsIHsgZnJhZywgcGFydCB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHJlY292ZXJXb3JrZXJFcnJvcihkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2RlbXV4ZXJXb3JrZXInKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgc3RhdGUobmV4dFN0YXRlKSB7XG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBuZXh0U3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgdGhpcy5sb2coYCR7cHJldmlvdXNTdGF0ZX0tPiR7bmV4dFN0YXRlfWApO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbn1cbiIsImltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXInO1xuaW1wb3J0IHsgbWltZVR5cGVGb3JDb2RlYyB9IGZyb20gJy4vdXRpbHMvY29kZWNzJztcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRTb3VyY2VCdWZmZXIgfSBmcm9tICcuL3R5cGVzL2J1ZmZlcic7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpOiB0eXBlb2Ygc2VsZi5Tb3VyY2VCdWZmZXIge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgKHNlbGYgYXMgYW55KS5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc01TRVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgU291cmNlQnVmZmVyIGlzIGV4cG9zZWQgZW5zdXJlIGl0cyBBUEkgaXMgdmFsaWRcbiAgLy8gT2xkZXIgYnJvd3NlcnMgZG8gbm90IGV4cG9zZSBTb3VyY2VCdWZmZXIgZ2xvYmFsbHkgc28gY2hlY2tpbmcgU291cmNlQnVmZmVyLnByb3RvdHlwZSBpcyBpbXBvc3NpYmxlXG4gIGNvbnN0IHNvdXJjZUJ1ZmZlciA9IGdldFNvdXJjZUJ1ZmZlcigpO1xuICByZXR1cm4gKFxuICAgICFzb3VyY2VCdWZmZXIgfHxcbiAgICAoc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJlxuICAgICAgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5yZW1vdmUgPT09ICdmdW5jdGlvbicpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgaWYgKCFpc01TRVN1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSgpO1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBtZWRpYVNvdXJjZT8uaXNUeXBlU3VwcG9ydGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgKFsnYXZjMS40MkUwMUUsbXA0YS40MC4yJywgJ2F2MDEuMC4wMU0uMDgnLCAndnAwOS4wMC41MC4wOCddLnNvbWUoXG4gICAgICAoY29kZWNzRm9yVmlkZW9Db250YWluZXIpID0+XG4gICAgICAgIG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChcbiAgICAgICAgICBtaW1lVHlwZUZvckNvZGVjKGNvZGVjc0ZvclZpZGVvQ29udGFpbmVyLCAndmlkZW8nKSxcbiAgICAgICAgKSxcbiAgICApIHx8XG4gICAgICBbJ21wNGEuNDAuMicsICdmTGFDJ10uc29tZSgoY29kZWNGb3JBdWRpb0NvbnRhaW5lcikgPT5cbiAgICAgICAgbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKFxuICAgICAgICAgIG1pbWVUeXBlRm9yQ29kZWMoY29kZWNGb3JBdWRpb0NvbnRhaW5lciwgJ2F1ZGlvJyksXG4gICAgICAgICksXG4gICAgICApKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlVHlwZVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgY29uc3Qgc291cmNlQnVmZmVyID0gZ2V0U291cmNlQnVmZmVyKCk7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIChzb3VyY2VCdWZmZXI/LnByb3RvdHlwZSBhcyBFeHRlbmRlZFNvdXJjZUJ1ZmZlcik/LmNoYW5nZVR5cGUgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuICApO1xufVxuIiwiLy8gZW5zdXJlIHRoZSB3b3JrZXIgZW5kcyB1cCBpbiB0aGUgYnVuZGxlXG4vLyBJZiB0aGUgd29ya2VyIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgdGhpcyBnZXRzIGFsaWFzZWQgdG8gZW1wdHkuanNcbmltcG9ydCAnLi90cmFuc211eGVyLXdvcmtlcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNVTURXb3JrZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgdHlwZSBXb3JrZXJDb250ZXh0ID0ge1xuICB3b3JrZXI6IFdvcmtlcjtcbiAgb2JqZWN0VVJMPzogc3RyaW5nO1xuICBzY3JpcHRVUkw/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0V29ya2VyKCk6IFdvcmtlckNvbnRleHQge1xuICBjb25zdCBibG9iID0gbmV3IHNlbGYuQmxvYihcbiAgICBbXG4gICAgICBgdmFyIGV4cG9ydHM9e307dmFyIG1vZHVsZT17ZXhwb3J0czpleHBvcnRzfTtmdW5jdGlvbiBkZWZpbmUoZil7ZigpfTtkZWZpbmUuYW1kPXRydWU7KCR7X19ITFNfV09SS0VSX0JVTkRMRV9fLnRvU3RyaW5nKCl9KSh0cnVlKTtgLFxuICAgIF0sXG4gICAge1xuICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgfSxcbiAgKTtcbiAgY29uc3Qgb2JqZWN0VVJMID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIob2JqZWN0VVJMKTtcblxuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBvYmplY3RVUkwsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkV29ya2VyKHBhdGg6IHN0cmluZyk6IFdvcmtlckNvbnRleHQge1xuICBjb25zdCBzY3JpcHRVUkwgPSBuZXcgc2VsZi5VUkwocGF0aCwgc2VsZi5sb2NhdGlvbi5ocmVmKS5ocmVmO1xuICBjb25zdCB3b3JrZXIgPSBuZXcgc2VsZi5Xb3JrZXIoc2NyaXB0VVJMKTtcblxuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBzY3JpcHRVUkwsXG4gIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7IERlbXV4ZWRUcmFjayB9IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlID0gJycsIGlucHV0VGltZVNjYWxlID0gOTAwMDApOiBEZW11eGVkVHJhY2sge1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgaWQ6IC0xLFxuICAgIHBpZDogLTEsXG4gICAgaW5wdXRUaW1lU2NhbGUsXG4gICAgc2VxdWVuY2VOdW1iZXI6IC0xLFxuICAgIHNhbXBsZXM6IFtdLFxuICAgIGRyb3BwZWQ6IDAsXG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vaWQzJztcbmltcG9ydCB7XG4gIERlbXV4ZXJSZXN1bHQsXG4gIERlbXV4ZXIsXG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBBdWRpb0ZyYW1lLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFZpZGVvVHJhY2tCYXNlLFxuICBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgS2V5RGF0YSxcbiAgTWV0YWRhdGFTY2hlbWEsXG59IGZyb20gJy4uLy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHsgZHVtbXlUcmFjayB9IGZyb20gJy4uL2R1bW15LWRlbXV4ZWQtdHJhY2snO1xuaW1wb3J0IHsgYXBwZW5kVWludDhBcnJheSB9IGZyb20gJy4uLy4uL3V0aWxzL21wNC10b29scyc7XG5pbXBvcnQgeyBzbGljZVVpbnQ4IH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZWQtYXJyYXknO1xuaW1wb3J0IHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi8uLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5cbmNsYXNzIEJhc2VBdWRpb0RlbXV4ZXIgaW1wbGVtZW50cyBEZW11eGVyIHtcbiAgcHJvdGVjdGVkIF9hdWRpb1RyYWNrITogRGVtdXhlZEF1ZGlvVHJhY2s7XG4gIHByb3RlY3RlZCBfaWQzVHJhY2shOiBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgcHJvdGVjdGVkIGZyYW1lSW5kZXg6IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBjYWNoZWREYXRhOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBiYXNlUFRTOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIGluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBsYXN0UFRTOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHtcbiAgICAgIHR5cGU6ICdpZDMnLFxuICAgICAgaWQ6IDMsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wKGRlYXVsdFRpbWVzdGFtcDogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsKSB7XG4gICAgdGhpcy5pbml0UFRTID0gZGVhdWx0VGltZXN0YW1wO1xuICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gIH1cblxuICByZXNldENvbnRpZ3VpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cblxuICBjYW5QYXJzZShkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFwcGVuZEZyYW1lKFxuICAgIHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjayxcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIG9mZnNldDogbnVtYmVyLFxuICApOiBBdWRpb0ZyYW1lIHwgdm9pZCB7fVxuXG4gIC8vIGZlZWQgaW5jb21pbmcgZGF0YSB0byB0aGUgZnJvbnQgb2YgdGhlIHBhcnNpbmcgcGlwZWxpbmVcbiAgZGVtdXgoZGF0YTogVWludDhBcnJheSwgdGltZU9mZnNldDogbnVtYmVyKTogRGVtdXhlclJlc3VsdCB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGlkM0RhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICBsZXQgbGFzdERhdGFJbmRleDtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBpZDNEYXRhID8gSUQzLmdldFRpbWVTdGFtcChpZDNEYXRhKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fFxuICAgICAgKHRoaXMuZnJhbWVJbmRleCA9PT0gMCAmJiBOdW1iZXIuaXNGaW5pdGUodGltZXN0YW1wKSlcbiAgICApIHtcbiAgICAgIHRoaXMuYmFzZVBUUyA9IGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIHRoaXMuaW5pdFBUUyk7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGFzdFBUUyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXN0UFRTID0gdGhpcy5iYXNlUFRTO1xuICAgIH1cblxuICAgIC8vIG1vcmUgZXhwcmVzc2l2ZSB0aGFuIGFsdGVybmF0aXZlOiBpZDNEYXRhPy5sZW5ndGhcbiAgICBpZiAoaWQzRGF0YSAmJiBpZDNEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZGF0YTogaWQzRGF0YSxcbiAgICAgICAgdHlwZTogTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5hcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUluZGV4Kys7XG4gICAgICAgICAgdGhpcy5sYXN0UFRTID0gZnJhbWUuc2FtcGxlLnB0cztcbiAgICAgICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKElEMy5jYW5QYXJzZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIC8vIGFmdGVyIGEgSUQzLmNhblBhcnNlLCBhIGNhbGwgdG8gSUQzLmdldElEM0RhdGEgKnNob3VsZCogYWx3YXlzIHJldHVybnMgc29tZSBkYXRhXG4gICAgICAgIGlkM0RhdGEgPSBJRDMuZ2V0SUQzRGF0YShkYXRhLCBvZmZzZXQpITtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgKz0gaWQzRGF0YS5sZW5ndGg7XG4gICAgICAgIGxhc3REYXRhSW5kZXggPSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCAmJiBsYXN0RGF0YUluZGV4ICE9PSBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbERhdGEgPSBzbGljZVVpbnQ4KGRhdGEsIGxhc3REYXRhSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZWREYXRhKSB7XG4gICAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLmNhY2hlZERhdGEsIHBhcnRpYWxEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBwYXJ0aWFsRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0cmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVmlkZW9UcmFja0Jhc2UsXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIH07XG4gIH1cblxuICBkZW11eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoXG4gICAgICAgIGBbJHt0aGlzfV0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uYCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIGZsdXNoKHRpbWVPZmZzZXQ6IG51bWJlcik6IERlbXV4ZXJSZXN1bHQge1xuICAgIC8vIFBhcnNlIGNhY2hlIGluIGNhc2Ugb2YgcmVtYWluaW5nIGZyYW1lcy5cbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGlmIChjYWNoZWREYXRhKSB7XG4gICAgICB0aGlzLmNhY2hlZERhdGEgPSBudWxsO1xuICAgICAgdGhpcy5kZW11eChjYWNoZWREYXRhLCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVmlkZW9UcmFja0Jhc2UsXG4gICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgZGVzdHJveSgpIHt9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQVFNcbiAqIDxwPlxuICogICAgdXNlIHRpbWVzdGFtcCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBOYU4gb3IgSW5maW5pdHlcbiAqIDwvcD5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRQVFNGbiA9IChcbiAgdGltZXN0YW1wOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsLFxuKTogbnVtYmVyID0+IHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZSh0aW1lc3RhbXAgYXMgbnVtYmVyKSkge1xuICAgIHJldHVybiB0aW1lc3RhbXAhICogOTA7XG4gIH1cbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUU1xuICAgID8gKGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCkgLyBpbml0UFRTLnRpbWVzY2FsZVxuICAgIDogMDtcbiAgcmV0dXJuIHRpbWVPZmZzZXQgKiA5MDAwMCArIGluaXQ5MGtIejtcbn07XG5leHBvcnQgZGVmYXVsdCBCYXNlQXVkaW9EZW11eGVyO1xuIiwiLyoqXG4gKiBBRFRTIHBhcnNlciBoZWxwZXJcbiAqIEBsaW5rIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gKi9cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9ldmVudHMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIEF1ZGlvRnJhbWUsXG4gIEF1ZGlvU2FtcGxlLFxufSBmcm9tICcuLi8uLi90eXBlcy9kZW11eGVyJztcblxudHlwZSBBdWRpb0NvbmZpZyA9IHtcbiAgY29uZmlnOiBudW1iZXJbXTtcbiAgc2FtcGxlcmF0ZTogbnVtYmVyO1xuICBjaGFubmVsQ291bnQ6IG51bWJlcjtcbiAgY29kZWM6IHN0cmluZztcbiAgbWFuaWZlc3RDb2RlYzogc3RyaW5nO1xufTtcblxudHlwZSBGcmFtZUhlYWRlciA9IHtcbiAgaGVhZGVyTGVuZ3RoOiBudW1iZXI7XG4gIGZyYW1lTGVuZ3RoOiBudW1iZXI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXVkaW9Db25maWcoXG4gIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICBhdWRpb0NvZGVjOiBzdHJpbmcsXG4pOiBBdWRpb0NvbmZpZyB8IHZvaWQge1xuICBsZXQgYWR0c09iamVjdFR5cGU6IG51bWJlcjtcbiAgbGV0IGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4OiBudW1iZXI7XG4gIGxldCBhZHRzQ2hhbm5lbENvbmZpZzogbnVtYmVyO1xuICBsZXQgY29uZmlnOiBudW1iZXJbXTtcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBtYW5pZmVzdENvZGVjID0gYXVkaW9Db2RlYztcbiAgY29uc3QgYWR0c1NhbXBsaW5nUmF0ZXMgPSBbXG4gICAgOTYwMDAsIDg4MjAwLCA2NDAwMCwgNDgwMDAsIDQ0MTAwLCAzMjAwMCwgMjQwMDAsIDIyMDUwLCAxNjAwMCwgMTIwMDAsIDExMDI1LFxuICAgIDgwMDAsIDczNTAsXG4gIF07XG4gIC8vIGJ5dGUgMlxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4YzApID4+PiA2KSArIDE7XG4gIGNvbnN0IGFkdHNTYW1wbGluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcbiAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gYWR0c1NhbXBsaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gKTtcbiAgICBvYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgZXJyb3IsXG4gICAgICByZWFzb246IGVycm9yLm1lc3NhZ2UsXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkdHNDaGFubmVsQ29uZmlnID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDAxKSA8PCAyO1xuICAvLyBieXRlIDNcbiAgYWR0c0NoYW5uZWxDb25maWcgfD0gKGRhdGFbb2Zmc2V0ICsgM10gJiAweGMwKSA+Pj4gNjtcbiAgbG9nZ2VyLmxvZyhcbiAgICBgbWFuaWZlc3QgY29kZWM6JHthdWRpb0NvZGVjfSwgQURUUyB0eXBlOiR7YWR0c09iamVjdFR5cGV9LCBzYW1wbGluZ0luZGV4OiR7YWR0c1NhbXBsaW5nSW5kZXh9YCxcbiAgKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKFxuICAgICAgKGF1ZGlvQ29kZWMgJiZcbiAgICAgICAgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fFxuICAgICAgICAgIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSkgfHxcbiAgICAgICghYXVkaW9Db2RlYyAmJiBhZHRzU2FtcGxpbmdJbmRleCA+PSA2KVxuICAgICkge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKFxuICAgICAgICAoYXVkaW9Db2RlYyAmJlxuICAgICAgICAgIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xICYmXG4gICAgICAgICAgKChhZHRzU2FtcGxpbmdJbmRleCA+PSA2ICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKSB8fFxuICAgICAgICAgICAgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpKSB8fFxuICAgICAgICAoIWF1ZGlvQ29kZWMgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEpXG4gICAgICApIHtcbiAgICAgICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgICAgICBjb25maWcgPSBuZXcgQXJyYXkoMik7XG4gICAgICB9XG4gICAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICAgIH1cbiAgfVxuICAvKiByZWZlciB0byBodHRwOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1NUEVHLTRfQXVkaW8jQXVkaW9fU3BlY2lmaWNfQ29uZmlnXG4gICAgICBJU08gMTQ0OTYtMyAoQUFDKS5wZGYgLSBUYWJsZSAxLjEzIOKAlCBTeW50YXggb2YgQXVkaW9TcGVjaWZpY0NvbmZpZygpXG4gICAgQXVkaW8gUHJvZmlsZSAvIEF1ZGlvIE9iamVjdCBUeXBlXG4gICAgMDogTnVsbFxuICAgIDE6IEFBQyBNYWluXG4gICAgMjogQUFDIExDIChMb3cgQ29tcGxleGl0eSlcbiAgICAzOiBBQUMgU1NSIChTY2FsYWJsZSBTYW1wbGUgUmF0ZSlcbiAgICA0OiBBQUMgTFRQIChMb25nIFRlcm0gUHJlZGljdGlvbilcbiAgICA1OiBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pXG4gICAgNjogQUFDIFNjYWxhYmxlXG4gICBzYW1wbGluZyBmcmVxXG4gICAgMDogOTYwMDAgSHpcbiAgICAxOiA4ODIwMCBIelxuICAgIDI6IDY0MDAwIEh6XG4gICAgMzogNDgwMDAgSHpcbiAgICA0OiA0NDEwMCBIelxuICAgIDU6IDMyMDAwIEh6XG4gICAgNjogMjQwMDAgSHpcbiAgICA3OiAyMjA1MCBIelxuICAgIDg6IDE2MDAwIEh6XG4gICAgOTogMTIwMDAgSHpcbiAgICAxMDogMTEwMjUgSHpcbiAgICAxMTogODAwMCBIelxuICAgIDEyOiA3MzUwIEh6XG4gICAgMTM6IFJlc2VydmVkXG4gICAgMTQ6IFJlc2VydmVkXG4gICAgMTU6IGZyZXF1ZW5jeSBpcyB3cml0dGVuIGV4cGxpY3RseVxuICAgIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICBUaGVzZSBhcmUgdGhlIGNoYW5uZWwgY29uZmlndXJhdGlvbnM6XG4gICAgMDogRGVmaW5lZCBpbiBBT1QgU3BlY2lmYyBDb25maWdcbiAgICAxOiAxIGNoYW5uZWw6IGZyb250LWNlbnRlclxuICAgIDI6IDIgY2hhbm5lbHM6IGZyb250LWxlZnQsIGZyb250LXJpZ2h0XG4gICovXG4gIC8vIGF1ZGlvT2JqZWN0VHlwZSA9IHByb2ZpbGUgPT4gcHJvZmlsZSwgdGhlIE1QRUctNCBBdWRpbyBPYmplY3QgVHlwZSBtaW51cyAxXG4gIGNvbmZpZ1swXSA9IGFkdHNPYmplY3RUeXBlIDw8IDM7XG4gIC8vIHNhbXBsaW5nRnJlcXVlbmN5SW5kZXhcbiAgY29uZmlnWzBdIHw9IChhZHRzU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gIGNvbmZpZ1sxXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAvLyBjaGFubmVsQ29uZmlndXJhdGlvblxuICBjb25maWdbMV0gfD0gYWR0c0NoYW5uZWxDb25maWcgPDwgMztcbiAgaWYgKGFkdHNPYmplY3RUeXBlID09PSA1KSB7XG4gICAgLy8gYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXhcbiAgICBjb25maWdbMV0gfD0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwZSkgPj4gMTtcbiAgICBjb25maWdbMl0gPSAoYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggJiAweDAxKSA8PCA3O1xuICAgIC8vIGFkdHNPYmplY3RUeXBlIChmb3JjZSB0byAyLCBjaHJvbWUgaXMgY2hlY2tpbmcgdGhhdCBvYmplY3QgdHlwZSBpcyBsZXNzIHRoYW4gNSA/Pz9cbiAgICAvLyAgICBodHRwczovL2Nocm9taXVtLmdvb2dsZXNvdXJjZS5jb20vY2hyb21pdW0vc3JjLmdpdC8rL21hc3Rlci9tZWRpYS9mb3JtYXRzL21wNC9hYWMuY2NcbiAgICBjb25maWdbMl0gfD0gMiA8PCAyO1xuICAgIGNvbmZpZ1szXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25maWcsXG4gICAgc2FtcGxlcmF0ZTogYWR0c1NhbXBsaW5nUmF0ZXNbYWR0c1NhbXBsaW5nSW5kZXhdLFxuICAgIGNoYW5uZWxDb3VudDogYWR0c0NoYW5uZWxDb25maWcsXG4gICAgY29kZWM6ICdtcDRhLjQwLicgKyBhZHRzT2JqZWN0VHlwZSxcbiAgICBtYW5pZmVzdENvZGVjLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBkYXRhW29mZnNldCArIDFdICYgMHgwMSA/IDcgOiA5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIChcbiAgICAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDAzKSA8PCAxMSkgfFxuICAgIChkYXRhW29mZnNldCArIDRdIDw8IDMpIHxcbiAgICAoKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBvZmZzZXQgKyA1IDwgZGF0YS5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlcihkYXRhOiBVaW50OEFycmF5LCBvZmZzZXQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBMb29rIGZvciBBRFRTIGhlYWRlciB8IDExMTEgMTExMSB8IDExMTEgWDAwWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gIC8vIE1vcmUgaW5mbyBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuUGFyc2UoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBjYW5HZXRGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpICYmXG4gICAgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiZcbiAgICBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvYmUoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IEFEVFMgZnJhbWUgZm9sbG93cyBsYXN0IEFEVFMgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAoaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyhcbiAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgYXVkaW9Db2RlYzogc3RyaW5nLFxuKSB7XG4gIGlmICghdHJhY2suc2FtcGxlcmF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGdldEF1ZGlvQ29uZmlnKG9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIGF1ZGlvQ29kZWMpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrLmNvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgdHJhY2suc2FtcGxlcmF0ZSA9IGNvbmZpZy5zYW1wbGVyYXRlO1xuICAgIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNvbmZpZy5jaGFubmVsQ291bnQ7XG4gICAgdHJhY2suY29kZWMgPSBjb25maWcuY29kZWM7XG4gICAgdHJhY2subWFuaWZlc3RDb2RlYyA9IGNvbmZpZy5tYW5pZmVzdENvZGVjO1xuICAgIGxvZ2dlci5sb2coXG4gICAgICBgcGFyc2VkIGNvZGVjOiR7dHJhY2suY29kZWN9LCByYXRlOiR7Y29uZmlnLnNhbXBsZXJhdGV9LCBjaGFubmVsczoke2NvbmZpZy5jaGFubmVsQ291bnR9YCxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFtZUR1cmF0aW9uKHNhbXBsZXJhdGU6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiAoMTAyNCAqIDkwMDAwKSAvIHNhbXBsZXJhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZyYW1lSGVhZGVyKFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbik6IEZyYW1lSGVhZGVyIHwgdm9pZCB7XG4gIC8vIFRoZSBwcm90ZWN0aW9uIHNraXAgYml0IHRlbGxzIHVzIGlmIHdlIGhhdmUgMiBieXRlcyBvZiBDUkMgZGF0YSBhdCB0aGUgZW5kIG9mIHRoZSBBRFRTIGhlYWRlclxuICBjb25zdCBoZWFkZXJMZW5ndGggPSBnZXRIZWFkZXJMZW5ndGgoZGF0YSwgb2Zmc2V0KTtcbiAgaWYgKG9mZnNldCArIGhlYWRlckxlbmd0aCA8PSBkYXRhLmxlbmd0aCkge1xuICAgIC8vIHJldHJpZXZlIGZyYW1lIHNpemVcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpIC0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChmcmFtZUxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQyBmcmFtZSwgb2Zmc2V0L2xlbmd0aC90b3RhbC9wdHM6JHtvZmZzZXQraGVhZGVyTGVuZ3RofS8ke2ZyYW1lTGVuZ3RofS8ke2RhdGEuYnl0ZUxlbmd0aH1gKTtcbiAgICAgIHJldHVybiB7IGhlYWRlckxlbmd0aCwgZnJhbWVMZW5ndGggfTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZEZyYW1lKFxuICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIG9mZnNldDogbnVtYmVyLFxuICBwdHM6IG51bWJlcixcbiAgZnJhbWVJbmRleDogbnVtYmVyLFxuKTogQXVkaW9GcmFtZSB7XG4gIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUgYXMgbnVtYmVyKTtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgaGVhZGVyID0gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpO1xuICBsZXQgdW5pdDogVWludDhBcnJheTtcbiAgaWYgKGhlYWRlcikge1xuICAgIGNvbnN0IHsgZnJhbWVMZW5ndGgsIGhlYWRlckxlbmd0aCB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhlYWRlckxlbmd0aCArIGZyYW1lTGVuZ3RoO1xuICAgIGNvbnN0IG1pc3NpbmcgPSBNYXRoLm1heCgwLCBvZmZzZXQgKyBsZW5ndGggLSBkYXRhLmxlbmd0aCk7XG4gICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lICR7ZnJhbWVJbmRleH0sIHB0czoke3N0YW1wfSBsZW5ndGhAb2Zmc2V0L3RvdGFsOiAke2ZyYW1lTGVuZ3RofUAke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofSBtaXNzaW5nOiAke21pc3Npbmd9YCk7XG4gICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzYW1wbGU6IEF1ZGlvU2FtcGxlID0ge1xuICAgICAgdW5pdCxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgfTtcbiAgICBpZiAoIW1pc3NpbmcpIHtcbiAgICAgIHRyYWNrLnNhbXBsZXMucHVzaChzYW1wbGUgYXMgQXVkaW9TYW1wbGUpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoLCBtaXNzaW5nIH07XG4gIH1cbiAgLy8gb3ZlcmZsb3cgaW5jb21wbGV0ZSBoZWFkZXJcbiAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBvZmZzZXQ7XG4gIHVuaXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICB1bml0LnNldChkYXRhLnN1YmFycmF5KG9mZnNldCwgZGF0YS5sZW5ndGgpLCAwKTtcbiAgY29uc3Qgc2FtcGxlOiBBdWRpb1NhbXBsZSA9IHtcbiAgICB1bml0LFxuICAgIHB0czogc3RhbXAsXG4gIH07XG4gIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoLCBtaXNzaW5nOiAtMSB9O1xufVxuIiwiLyoqXG4gKiAgTVBFRyBwYXJzZXIgaGVscGVyXG4gKi9cbmltcG9ydCB7IERlbXV4ZWRBdWRpb1RyYWNrIH0gZnJvbSAnLi4vLi4vdHlwZXMvZGVtdXhlcic7XG5cbmxldCBjaHJvbWVWZXJzaW9uOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuY29uc3QgQml0cmF0ZXNNYXAgPSBbXG4gIDMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LFxuICA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCxcbiAgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCxcbiAgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsXG4gIDE2MCxcbl07XG5cbmNvbnN0IFNhbXBsaW5nUmF0ZU1hcCA9IFtcbiAgNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwLFxuXTtcblxuY29uc3QgU2FtcGxlc0NvZWZmaWNpZW50cyA9IFtcbiAgLy8gTVBFRyAyLjVcbiAgW1xuICAgIDAsIC8vIFJlc2VydmVkXG4gICAgNzIsIC8vIExheWVyM1xuICAgIDE0NCwgLy8gTGF5ZXIyXG4gICAgMTIsIC8vIExheWVyMVxuICBdLFxuICAvLyBSZXNlcnZlZFxuICBbXG4gICAgMCwgLy8gUmVzZXJ2ZWRcbiAgICAwLCAvLyBMYXllcjNcbiAgICAwLCAvLyBMYXllcjJcbiAgICAwLCAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAyXG4gIFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDcyLCAvLyBMYXllcjNcbiAgICAxNDQsIC8vIExheWVyMlxuICAgIDEyLCAvLyBMYXllcjFcbiAgXSxcbiAgLy8gTVBFRyAxXG4gIFtcbiAgICAwLCAvLyBSZXNlcnZlZFxuICAgIDE0NCwgLy8gTGF5ZXIzXG4gICAgMTQ0LCAvLyBMYXllcjJcbiAgICAxMiwgLy8gTGF5ZXIxXG4gIF0sXG5dO1xuXG5jb25zdCBCeXRlc0luU2xvdCA9IFtcbiAgMCwgLy8gUmVzZXJ2ZWRcbiAgMSwgLy8gTGF5ZXIzXG4gIDEsIC8vIExheWVyMlxuICA0LCAvLyBMYXllcjFcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRGcmFtZShcbiAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgcHRzOiBudW1iZXIsXG4gIGZyYW1lSW5kZXg6IG51bWJlcixcbikge1xuICAvLyBVc2luZyBodHRwOi8vd3d3LmRhdGF2b3lhZ2UuY29tL21wZ3NjcmlwdC9tcGVnaGRyLmh0bSBhcyBhIHJlZmVyZW5jZVxuICBpZiAob2Zmc2V0ICsgMjQgPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IChoZWFkZXIuc2FtcGxlc1BlckZyYW1lICogOTAwMDApIC8gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgICBjb25zdCBzYW1wbGUgPSB7XG4gICAgICB1bml0OiBkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoKSxcbiAgICAgIHB0czogc3RhbXAsXG4gICAgICBkdHM6IHN0YW1wLFxuICAgIH07XG5cbiAgICB0cmFjay5jb25maWcgPSBbXTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBoZWFkZXIuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBoZWFkZXIuc2FtcGxlUmF0ZTtcbiAgICB0cmFjay5zYW1wbGVzLnB1c2goc2FtcGxlKTtcblxuICAgIHJldHVybiB7IHNhbXBsZSwgbGVuZ3RoOiBoZWFkZXIuZnJhbWVMZW5ndGgsIG1pc3Npbmc6IDAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpIHtcbiAgY29uc3QgbXBlZ1ZlcnNpb24gPSAoZGF0YVtvZmZzZXQgKyAxXSA+PiAzKSAmIDM7XG4gIGNvbnN0IG1wZWdMYXllciA9IChkYXRhW29mZnNldCArIDFdID4+IDEpICYgMztcbiAgY29uc3QgYml0UmF0ZUluZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCkgJiAxNTtcbiAgY29uc3Qgc2FtcGxlUmF0ZUluZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gPj4gMikgJiAzO1xuICBpZiAoXG4gICAgbXBlZ1ZlcnNpb24gIT09IDEgJiZcbiAgICBiaXRSYXRlSW5kZXggIT09IDAgJiZcbiAgICBiaXRSYXRlSW5kZXggIT09IDE1ICYmXG4gICAgc2FtcGxlUmF0ZUluZGV4ICE9PSAzXG4gICkge1xuICAgIGNvbnN0IHBhZGRpbmdCaXQgPSAoZGF0YVtvZmZzZXQgKyAyXSA+PiAxKSAmIDE7XG4gICAgY29uc3QgY2hhbm5lbE1vZGUgPSBkYXRhW29mZnNldCArIDNdID4+IDY7XG4gICAgY29uc3QgY29sdW1uSW5CaXRyYXRlcyA9XG4gICAgICBtcGVnVmVyc2lvbiA9PT0gMyA/IDMgLSBtcGVnTGF5ZXIgOiBtcGVnTGF5ZXIgPT09IDMgPyAzIDogNDtcbiAgICBjb25zdCBiaXRSYXRlID1cbiAgICAgIEJpdHJhdGVzTWFwW2NvbHVtbkluQml0cmF0ZXMgKiAxNCArIGJpdFJhdGVJbmRleCAtIDFdICogMTAwMDtcbiAgICBjb25zdCBjb2x1bW5JblNhbXBsZVJhdGVzID1cbiAgICAgIG1wZWdWZXJzaW9uID09PSAzID8gMCA6IG1wZWdWZXJzaW9uID09PSAyID8gMSA6IDI7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9XG4gICAgICBTYW1wbGluZ1JhdGVNYXBbY29sdW1uSW5TYW1wbGVSYXRlcyAqIDMgKyBzYW1wbGVSYXRlSW5kZXhdO1xuICAgIGNvbnN0IGNoYW5uZWxDb3VudCA9IGNoYW5uZWxNb2RlID09PSAzID8gMSA6IDI7IC8vIElmIGJpdHMgb2YgY2hhbm5lbCBtb2RlIGFyZSBgMTFgIHRoZW4gaXQgaXMgYSBzaW5nbGUgY2hhbm5lbCAoTW9ubylcbiAgICBjb25zdCBzYW1wbGVDb2VmZmljaWVudCA9IFNhbXBsZXNDb2VmZmljaWVudHNbbXBlZ1ZlcnNpb25dW21wZWdMYXllcl07XG4gICAgY29uc3QgYnl0ZXNJblNsb3QgPSBCeXRlc0luU2xvdFttcGVnTGF5ZXJdO1xuICAgIGNvbnN0IHNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZUNvZWZmaWNpZW50ICogOCAqIGJ5dGVzSW5TbG90O1xuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID1cbiAgICAgIE1hdGguZmxvb3IoKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSkgLyBzYW1wbGVSYXRlICsgcGFkZGluZ0JpdCkgKlxuICAgICAgYnl0ZXNJblNsb3Q7XG5cbiAgICBpZiAoY2hyb21lVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgY2hyb21lVmVyc2lvbiA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uICYmIGNocm9tZVZlcnNpb24gPD0gODc7XG5cbiAgICBpZiAoXG4gICAgICBuZWVkQ2hyb21lRml4ICYmXG4gICAgICBtcGVnTGF5ZXIgPT09IDIgJiZcbiAgICAgIGJpdFJhdGUgPj0gMjI0MDAwICYmXG4gICAgICBjaGFubmVsTW9kZSA9PT0gMFxuICAgICkge1xuICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM10gfCAweDgwO1xuICAgIH1cblxuICAgIHJldHVybiB7IHNhbXBsZVJhdGUsIGNoYW5uZWxDb3VudCwgZnJhbWVMZW5ndGgsIHNhbXBsZXNQZXJGcmFtZSB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlYWRlclBhdHRlcm4oZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiZcbiAgICAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4ZTApID09PSAweGUwICYmXG4gICAgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIZWFkZXIoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgLy8gTW9yZSBpbmZvIGh0dHA6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhblBhcnNlKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhlYWRlclNpemUgPSA0O1xuXG4gIHJldHVybiBpc0hlYWRlclBhdHRlcm4oZGF0YSwgb2Zmc2V0KSAmJiBoZWFkZXJTaXplIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvYmUoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gc2FtZSBhcyBpc0hlYWRlciBidXQgd2UgYWxzbyBjaGVjayB0aGF0IE1QRUcgZnJhbWUgZm9sbG93cyBsYXN0IE1QRUcgZnJhbWVcbiAgLy8gb3IgZW5kIG9mIGRhdGEgaXMgcmVhY2hlZFxuICBpZiAob2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpKSB7XG4gICAgLy8gTVBFRyBoZWFkZXIgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gNDtcbiAgICAvLyBNUEVHIGZyYW1lIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gICAgbGV0IGZyYW1lTGVuZ3RoID0gaGVhZGVyTGVuZ3RoO1xuICAgIGlmIChoZWFkZXI/LmZyYW1lTGVuZ3RoKSB7XG4gICAgICBmcmFtZUxlbmd0aCA9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBvZmZzZXQgKyBmcmFtZUxlbmd0aDtcbiAgICByZXR1cm4gbmV3T2Zmc2V0ID09PSBkYXRhLmxlbmd0aCB8fCBpc0hlYWRlcihkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuICogQUFDIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IEJhc2VBdWRpb0RlbXV4ZXIgZnJvbSAnLi9iYXNlLWF1ZGlvLWRlbXV4ZXInO1xuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2FkdHMnO1xuaW1wb3J0ICogYXMgTXBlZ0F1ZGlvIGZyb20gJy4vbXBlZ2F1ZGlvJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgKiBhcyBJRDMgZnJvbSAnLi4vaWQzJztcbmltcG9ydCB0eXBlIHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnJztcblxuY2xhc3MgQUFDRGVtdXhlciBleHRlbmRzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG5cbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlcixcbiAgKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FkdHMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWFjJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IElEMy5nZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSBpZDNEYXRhPy5sZW5ndGggfHwgMDtcblxuICAgIGlmIChNcGVnQXVkaW8ucHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoQURUUy5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0FEVFMgc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBBRFRTLmNhblBhcnNlKGRhdGEsIG9mZnNldCk7XG4gIH1cblxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgQURUUy5pbml0VHJhY2tDb25maWcoXG4gICAgICB0cmFjayxcbiAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICBkYXRhLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyxcbiAgICApO1xuICAgIGNvbnN0IGZyYW1lID0gQURUUy5hcHBlbmRGcmFtZShcbiAgICAgIHRyYWNrLFxuICAgICAgZGF0YSxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRoaXMuYmFzZVBUUyBhcyBudW1iZXIsXG4gICAgICB0aGlzLmZyYW1lSW5kZXgsXG4gICAgKTtcbiAgICBpZiAoZnJhbWUgJiYgZnJhbWUubWlzc2luZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBQUNEZW11eGVyO1xuIiwiLyoqXG4gKiBNUDQgZGVtdXhlclxuICovXG5pbXBvcnQge1xuICBEZW11eGVyLFxuICBEZW11eGVyUmVzdWx0LFxuICBQYXNzdGhyb3VnaFRyYWNrLFxuICBEZW11eGVkQXVkaW9UcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIERlbXV4ZWRNZXRhZGF0YVRyYWNrLFxuICBLZXlEYXRhLFxuICBNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQge1xuICBmaW5kQm94LFxuICBzZWdtZW50VmFsaWRSYW5nZSxcbiAgYXBwZW5kVWludDhBcnJheSxcbiAgcGFyc2VFbXNnLFxuICBwYXJzZVNhbXBsZXMsXG4gIHBhcnNlSW5pdFNlZ21lbnQsXG4gIFJlbXV4ZXJUcmFja0lkQ29uZmlnLFxuICBoYXNNb29mRGF0YSxcbn0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGR1bW15VHJhY2sgfSBmcm9tICcuL2R1bW15LWRlbXV4ZWQtdHJhY2snO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5jb25zdCBlbXNnU2NoZW1lUGF0dGVybiA9IC9cXC9lbXNnWy0vXUlEMy9pO1xuXG5jbGFzcyBNUDREZW11eGVyIGltcGxlbWVudHMgRGVtdXhlciB7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRpbWVPZmZzZXQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgdmlkZW9UcmFjaz86IFBhc3N0aHJvdWdoVHJhY2s7XG4gIHByaXZhdGUgYXVkaW9UcmFjaz86IERlbXV4ZWRBdWRpb1RyYWNrO1xuICBwcml2YXRlIGlkM1RyYWNrPzogRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gIHByaXZhdGUgdHh0VHJhY2s/OiBEZW11eGVkVXNlcmRhdGFUcmFjaztcblxuICBjb25zdHJ1Y3RvcihvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLCBjb25maWc6IEhsc0NvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG5cbiAgcHVibGljIHJlc2V0VGltZVN0YW1wKCkge31cblxuICBwdWJsaWMgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlcixcbiAgKSB7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9ICh0aGlzLnZpZGVvVHJhY2sgPSBkdW1teVRyYWNrKFxuICAgICAgJ3ZpZGVvJyxcbiAgICAgIDEsXG4gICAgKSBhcyBQYXNzdGhyb3VnaFRyYWNrKTtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gKHRoaXMuYXVkaW9UcmFjayA9IGR1bW15VHJhY2soXG4gICAgICAnYXVkaW8nLFxuICAgICAgMSxcbiAgICApIGFzIERlbXV4ZWRBdWRpb1RyYWNrKTtcbiAgICBjb25zdCBjYXB0aW9uVHJhY2sgPSAodGhpcy50eHRUcmFjayA9IGR1bW15VHJhY2soXG4gICAgICAndGV4dCcsXG4gICAgICAxLFxuICAgICkgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2spO1xuXG4gICAgdGhpcy5pZDNUcmFjayA9IGR1bW15VHJhY2soJ2lkMycsIDEpIGFzIERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG5cbiAgICBpZiAoIWluaXRTZWdtZW50Py5ieXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIGNvbnN0IHsgaWQsIHRpbWVzY2FsZSwgY29kZWMgfSA9IGluaXREYXRhLnZpZGVvO1xuICAgICAgdmlkZW9UcmFjay5pZCA9IGlkO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgdmlkZW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cblxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgY29uc3QgeyBpZCwgdGltZXNjYWxlLCBjb2RlYyB9ID0gaW5pdERhdGEuYXVkaW87XG4gICAgICBhdWRpb1RyYWNrLmlkID0gaWQ7XG4gICAgICBhdWRpb1RyYWNrLnRpbWVzY2FsZSA9IHRpbWVzY2FsZTtcbiAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSBjb2RlYztcbiAgICB9XG5cbiAgICBjYXB0aW9uVHJhY2suaWQgPSBSZW11eGVyVHJhY2tJZENvbmZpZy50ZXh0O1xuICAgIHZpZGVvVHJhY2suc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZXNldENvbnRpZ3VpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGhhc01vb2ZEYXRhKGRhdGEpO1xuICB9XG5cbiAgcHVibGljIGRlbXV4KGRhdGE6IFVpbnQ4QXJyYXksIHRpbWVPZmZzZXQ6IG51bWJlcik6IERlbXV4ZXJSZXN1bHQge1xuICAgIHRoaXMudGltZU9mZnNldCA9IHRpbWVPZmZzZXQ7XG4gICAgLy8gTG9hZCBhbGwgZGF0YSBpbnRvIHRoZSBhdmMgdHJhY2suIFRoZSBDTUFGIHJlbXV4ZXIgd2lsbCBsb29rIGZvciB0aGUgZGF0YSBpbiB0aGUgc2FtcGxlcyBvYmplY3Q7IHRoZSByZXN0IG9mIHRoZSBmaWVsZHMgZG8gbm90IG1hdHRlclxuICAgIGxldCB2aWRlb1NhbXBsZXMgPSBkYXRhO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2sgYXMgUGFzc3Rocm91Z2hUcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZ21lbnRlZERhdGEgPSBzZWdtZW50VmFsaWRSYW5nZSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG5cbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQpO1xuICAgIHRleHRUcmFjay5zYW1wbGVzID0gcGFyc2VTYW1wbGVzKHRpbWVPZmZzZXQsIHZpZGVvVHJhY2spO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2sgYXMgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGhpcy50eHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZsdXNoKCkge1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSB0aGlzLnRpbWVPZmZzZXQ7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjayBhcyBQYXNzdGhyb3VnaFRyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMudHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2s7XG4gICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcblxuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogZHVtbXlUcmFjaygpIGFzIERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgICAgaWQzVHJhY2ssXG4gICAgICB0ZXh0VHJhY2s6IGR1bW15VHJhY2soKSBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0SUQzVHJhY2soXG4gICAgdmlkZW9UcmFjazogUGFzc3Rocm91Z2hUcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICk6IERlbXV4ZWRNZXRhZGF0YVRyYWNrIHtcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuaWQzVHJhY2sgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2s7XG4gICAgaWYgKHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtc2dzID0gZmluZEJveCh2aWRlb1RyYWNrLnNhbXBsZXMsIFsnZW1zZyddKTtcbiAgICAgIGlmIChlbXNncykge1xuICAgICAgICBlbXNncy5mb3JFYWNoKChkYXRhOiBVaW50OEFycmF5KSA9PiB7XG4gICAgICAgICAgY29uc3QgZW1zZ0luZm8gPSBwYXJzZUVtc2coZGF0YSk7XG4gICAgICAgICAgaWYgKGVtc2dTY2hlbWVQYXR0ZXJuLnRlc3QoZW1zZ0luZm8uc2NoZW1lSWRVcmkpKSB7XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBOdW1iZXIuaXNGaW5pdGUoZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSlcbiAgICAgICAgICAgICAgPyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lISAvIGVtc2dJbmZvLnRpbWVTY2FsZVxuICAgICAgICAgICAgICA6IHRpbWVPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWVEZWx0YSEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPVxuICAgICAgICAgICAgICBlbXNnSW5mby5ldmVudER1cmF0aW9uID09PSAweGZmZmZmZmZmXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgICAgICA6IGVtc2dJbmZvLmV2ZW50RHVyYXRpb24gLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICAvLyBTYWZhcmkgdGFrZXMgYW55dGhpbmcgPD0gMC4wMDEgc2Vjb25kcyBhbmQgbWFwcyBpdCB0byBJbmZpbml0eVxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDAuMDAxKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGVtc2dJbmZvLnBheWxvYWQ7XG4gICAgICAgICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgICBsZW46IHBheWxvYWQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgZHRzOiBwdHMsXG4gICAgICAgICAgICAgIHB0czogcHRzLFxuICAgICAgICAgICAgICB0eXBlOiBNZXRhZGF0YVNjaGVtYS5lbXNnLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWQzVHJhY2s7XG4gIH1cblxuICBkZW11eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEsXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICApOiBQcm9taXNlPERlbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICBuZXcgRXJyb3IoJ1RoZSBNUDQgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNBTVBMRS1BRVMgZGVjcnlwdGlvbicpLFxuICAgICk7XG4gIH1cblxuICBkZXN0cm95KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTVA0RGVtdXhlcjtcbiIsImV4cG9ydCBjb25zdCBnZXRBdWRpb0JTSUQgPSAoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTMgfCBlYy0zXG4gIGxldCBic2lkID0gMDtcbiAgbGV0IG51bUJpdHMgPSA1O1xuICBvZmZzZXQgKz0gbnVtQml0cztcbiAgY29uc3QgdGVtcCA9IG5ldyBVaW50MzJBcnJheSgxKTsgLy8gdW5zaWduZWQgMzIgYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICBjb25zdCBtYXNrID0gbmV3IFVpbnQzMkFycmF5KDEpOyAvLyB1bnNpZ25lZCAzMiBiaXQgbWFzayB2YWx1ZVxuICBjb25zdCBieXRlID0gbmV3IFVpbnQ4QXJyYXkoMSk7IC8vIHVuc2lnbmVkIDggYml0IGZvciB0ZW1wb3Jhcnkgc3RvcmFnZVxuICB3aGlsZSAobnVtQml0cyA+IDApIHtcbiAgICBieXRlWzBdID0gZGF0YVtvZmZzZXRdO1xuICAgIC8vIHJlYWQgcmVtYWluaW5nIGJpdHMsIHVwdG8gOCBiaXRzIGF0IGEgdGltZVxuICAgIGNvbnN0IGJpdHMgPSBNYXRoLm1pbihudW1CaXRzLCA4KTtcbiAgICBjb25zdCBzaGlmdCA9IDggLSBiaXRzO1xuICAgIG1hc2tbMF0gPSAoMHhmZjAwMDAwMCA+Pj4gKDI0ICsgc2hpZnQpKSA8PCBzaGlmdDtcbiAgICB0ZW1wWzBdID0gKGJ5dGVbMF0gJiBtYXNrWzBdKSA+PiBzaGlmdDtcbiAgICBic2lkID0gIWJzaWQgPyB0ZW1wWzBdIDogKGJzaWQgPDwgYml0cykgfCB0ZW1wWzBdO1xuICAgIG9mZnNldCArPSAxO1xuICAgIG51bUJpdHMgLT0gYml0cztcbiAgfVxuICByZXR1cm4gYnNpZDtcbn07XG4iLCJpbXBvcnQgdHlwZSB7IFBhcnNlZFZpZGVvU2FtcGxlIH0gZnJvbSAnLi4vdHNkZW11eGVyJztcbmltcG9ydCB7XG4gIERlbXV4ZWRWaWRlb1RyYWNrLFxuICBWaWRlb1NhbXBsZSxcbiAgVmlkZW9TYW1wbGVVbml0LFxufSBmcm9tICcuLi8uLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5cbmNsYXNzIEJhc2VWaWRlb1BhcnNlciB7XG4gIHByb3RlY3RlZCBWaWRlb1NhbXBsZTogUGFyc2VkVmlkZW9TYW1wbGUgfCBudWxsID0gbnVsbDtcblxuICBwcm90ZWN0ZWQgY3JlYXRlVmlkZW9TYW1wbGUoXG4gICAga2V5OiBib29sZWFuLFxuICAgIHB0czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGR0czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGRlYnVnOiBzdHJpbmcsXG4gICk6IFBhcnNlZFZpZGVvU2FtcGxlIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgZnJhbWU6IGZhbHNlLFxuICAgICAgcHRzLFxuICAgICAgZHRzLFxuICAgICAgdW5pdHM6IFtdLFxuICAgICAgZGVidWcsXG4gICAgICBsZW5ndGg6IDAsXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRMYXN0TmFsVW5pdChcbiAgICBzYW1wbGVzOiBWaWRlb1NhbXBsZVtdLFxuICApOiBWaWRlb1NhbXBsZVVuaXQgfCB1bmRlZmluZWQge1xuICAgIGxldCBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgbGV0IGxhc3RVbml0OiBWaWRlb1NhbXBsZVVuaXQgfCB1bmRlZmluZWQ7XG4gICAgLy8gdHJ5IHRvIGZhbGxiYWNrIHRvIHByZXZpb3VzIHNhbXBsZSBpZiBjdXJyZW50IG9uZSBpcyBlbXB0eVxuICAgIGlmICghVmlkZW9TYW1wbGUgfHwgVmlkZW9TYW1wbGUudW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBWaWRlb1NhbXBsZSA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKFZpZGVvU2FtcGxlPy51bml0cykge1xuICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBwdXNoQWNjZXNzVW5pdChcbiAgICBWaWRlb1NhbXBsZTogUGFyc2VkVmlkZW9TYW1wbGUsXG4gICAgdmlkZW9UcmFjazogRGVtdXhlZFZpZGVvVHJhY2ssXG4gICkge1xuICAgIGlmIChWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggJiYgVmlkZW9TYW1wbGUuZnJhbWUpIHtcbiAgICAgIC8vIGlmIHNhbXBsZSBkb2VzIG5vdCBoYXZlIFBUUy9EVFMsIHBhdGNoIHdpdGggbGFzdCBzYW1wbGUgUFRTL0RUU1xuICAgICAgaWYgKFZpZGVvU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgICAgVmlkZW9TYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgICAgVmlkZW9TYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBpbmcgc2FtcGxlcywgbm8gdGltZXN0YW1wIGZvdW5kXG4gICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkKys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMucHVzaChWaWRlb1NhbXBsZSBhcyBWaWRlb1NhbXBsZSk7XG4gICAgfVxuICAgIGlmIChWaWRlb1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgIFZpZGVvU2FtcGxlLnB0cyArICcvJyArIFZpZGVvU2FtcGxlLmR0cyArICc6JyArIFZpZGVvU2FtcGxlLmRlYnVnLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVZpZGVvUGFyc2VyO1xuIiwiLyoqXG4gKiBQYXJzZXIgZm9yIGV4cG9uZW50aWFsIEdvbG9tYiBjb2RlcywgYSB2YXJpYWJsZS1iaXR3aWR0aCBudW1iZXIgZW5jb2Rpbmcgc2NoZW1lIHVzZWQgYnkgaDI2NC5cbiAqL1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnZXInO1xuXG5jbGFzcyBFeHBHb2xvbWIge1xuICBwcml2YXRlIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpYyBieXRlc0F2YWlsYWJsZTogbnVtYmVyO1xuICBwcml2YXRlIHdvcmQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBiaXRzQXZhaWxhYmxlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZGF0YTogVWludDhBcnJheSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB3b3JraW5nQnl0ZXMuc2V0KGRhdGEuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgYXZhaWxhYmxlQnl0ZXMpKTtcbiAgICB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcod29ya2luZ0J5dGVzLmJ1ZmZlcikuZ2V0VWludDMyKDApO1xuICAgIC8vIHRyYWNrIHRoZSBhbW91bnQgb2YgdGhpcy5kYXRhIHRoYXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gYXZhaWxhYmxlQnl0ZXMgKiA4O1xuICAgIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gYXZhaWxhYmxlQnl0ZXM7XG4gIH1cblxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGNvdW50OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgc2tpcEJ5dGVzOyAvLyA6aW50XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiBjb3VudCkge1xuICAgICAgdGhpcy53b3JkIDw8PSBjb3VudDtcbiAgICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBjb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgLT0gdGhpcy5iaXRzQXZhaWxhYmxlO1xuICAgICAgc2tpcEJ5dGVzID0gY291bnQgPj4gMztcbiAgICAgIGNvdW50IC09IHNraXBCeXRlcyA8PCAzO1xuICAgICAgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSBza2lwQnl0ZXM7XG4gICAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBiaXRzID0gTWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLCBzaXplKTsgLy8gOnVpbnRcbiAgICBjb25zdCB2YWx1ID0gdGhpcy53b3JkID4+PiAoMzIgLSBiaXRzKTsgLy8gOnVpbnRcbiAgICBpZiAoc2l6ZSA+IDMyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCByZWFkIG1vcmUgdGhhbiAzMiBiaXRzIGF0IGEgdGltZScpO1xuICAgIH1cblxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgYml0cyA9IHNpemUgLSBiaXRzO1xuICAgIGlmIChiaXRzID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiAodmFsdSA8PCBiaXRzKSB8IHRoaXMucmVhZEJpdHMoYml0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1O1xuICAgIH1cbiAgfVxuXG4gIC8vICgpOnVpbnRcbiAgc2tpcExaKCk6IG51bWJlciB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChcbiAgICAgIGxlYWRpbmdaZXJvQ291bnQgPSAwO1xuICAgICAgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTtcbiAgICAgICsrbGVhZGluZ1plcm9Db3VudFxuICAgICkge1xuICAgICAgaWYgKCh0aGlzLndvcmQgJiAoMHg4MDAwMDAwMCA+Pj4gbGVhZGluZ1plcm9Db3VudCkpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCk6IHZvaWQge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKTogdm9pZCB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKTogbnVtYmVyIHtcbiAgICBjb25zdCBjbHogPSB0aGlzLnNraXBMWigpOyAvLyA6dWludFxuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGNseiArIDEpIC0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkRUcoKTogbnVtYmVyIHtcbiAgICBjb25zdCB2YWx1ID0gdGhpcy5yZWFkVUVHKCk7IC8vIDppbnRcbiAgICBpZiAoMHgwMSAmIHZhbHUpIHtcbiAgICAgIC8vIHRoZSBudW1iZXIgaXMgb2RkIGlmIHRoZSBsb3cgb3JkZXIgYml0IGlzIHNldFxuICAgICAgcmV0dXJuICgxICsgdmFsdSkgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyg4KTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpO1xuICB9XG5cbiAgLy8gKCk6aW50XG4gIHJlYWRVSW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGxhc3RTY2FsZSA9IDg7XG4gICAgbGV0IG5leHRTY2FsZSA9IDg7XG4gICAgbGV0IGRlbHRhU2NhbGU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBpZiAobmV4dFNjYWxlICE9PSAwKSB7XG4gICAgICAgIGRlbHRhU2NhbGUgPSB0aGlzLnJlYWRFRygpO1xuICAgICAgICBuZXh0U2NhbGUgPSAobGFzdFNjYWxlICsgZGVsdGFTY2FsZSArIDI1NikgJSAyNTY7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbGUgPSBuZXh0U2NhbGUgPT09IDAgPyBsYXN0U2NhbGUgOiBuZXh0U2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUygpOiB7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBwaXhlbFJhdGlvOiBbbnVtYmVyLCBudW1iZXJdO1xuICB9IHtcbiAgICBsZXQgZnJhbWVDcm9wTGVmdE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gMDtcbiAgICBsZXQgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gMDtcbiAgICBsZXQgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlO1xuICAgIGxldCBzY2FsaW5nTGlzdENvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJlYWRVQnl0ZSA9IHRoaXMucmVhZFVCeXRlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZEJpdHMgPSB0aGlzLnJlYWRCaXRzLmJpbmQodGhpcyk7XG4gICAgY29uc3QgcmVhZFVFRyA9IHRoaXMucmVhZFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCb29sZWFuID0gdGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBCaXRzID0gdGhpcy5za2lwQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBFRyA9IHRoaXMuc2tpcEVHLmJpbmQodGhpcyk7XG4gICAgY29uc3Qgc2tpcFVFRyA9IHRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBTY2FsaW5nTGlzdCA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG5cbiAgICByZWFkVUJ5dGUoKTtcbiAgICBjb25zdCBwcm9maWxlSWRjID0gcmVhZFVCeXRlKCk7IC8vIHByb2ZpbGVfaWRjXG4gICAgcmVhZEJpdHMoNSk7IC8vIHByb2ZpbGVDb21wYXQgY29uc3RyYWludF9zZXRbMC00XV9mbGFnLCB1KDUpXG4gICAgc2tpcEJpdHMoMyk7IC8vIHJlc2VydmVkX3plcm9fM2JpdHMgdSgzKSxcbiAgICByZWFkVUJ5dGUoKTsgLy8gbGV2ZWxfaWRjIHUoOClcbiAgICBza2lwVUVHKCk7IC8vIHNlcV9wYXJhbWV0ZXJfc2V0X2lkXG4gICAgLy8gc29tZSBwcm9maWxlcyBoYXZlIG1vcmUgb3B0aW9uYWwgZGF0YSB3ZSBkb24ndCBuZWVkXG4gICAgaWYgKFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMTAwIHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMTAgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDEyMiB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8XG4gICAgICBwcm9maWxlSWRjID09PSA0NCB8fFxuICAgICAgcHJvZmlsZUlkYyA9PT0gODMgfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDg2IHx8XG4gICAgICBwcm9maWxlSWRjID09PSAxMTggfHxcbiAgICAgIHByb2ZpbGVJZGMgPT09IDEyOFxuICAgICkge1xuICAgICAgY29uc3QgY2hyb21hRm9ybWF0SWRjID0gcmVhZFVFRygpO1xuICAgICAgaWYgKGNocm9tYUZvcm1hdElkYyA9PT0gMykge1xuICAgICAgICBza2lwQml0cygxKTtcbiAgICAgIH0gLy8gc2VwYXJhdGVfY29sb3VyX3BsYW5lX2ZsYWdcblxuICAgICAgc2tpcFVFRygpOyAvLyBiaXRfZGVwdGhfbHVtYV9taW51czhcbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2Nocm9tYV9taW51czhcbiAgICAgIHNraXBCaXRzKDEpOyAvLyBxcHByaW1lX3lfemVyb190cmFuc2Zvcm1fYnlwYXNzX2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIHNlcV9zY2FsaW5nX21hdHJpeF9wcmVzZW50X2ZsYWdcbiAgICAgICAgc2NhbGluZ0xpc3RDb3VudCA9IGNocm9tYUZvcm1hdElkYyAhPT0gMyA/IDggOiAxMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYWxpbmdMaXN0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgICAgICAvLyBzZXFfc2NhbGluZ19saXN0X3ByZXNlbnRfZmxhZ1sgaSBdXG4gICAgICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICAgICAgc2tpcFNjYWxpbmdMaXN0KDE2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCg2NCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbG9nMl9tYXhfZnJhbWVfbnVtX21pbnVzNFxuICAgIGNvbnN0IHBpY09yZGVyQ250VHlwZSA9IHJlYWRVRUcoKTtcbiAgICBpZiAocGljT3JkZXJDbnRUeXBlID09PSAwKSB7XG4gICAgICByZWFkVUVHKCk7IC8vIGxvZzJfbWF4X3BpY19vcmRlcl9jbnRfbHNiX21pbnVzNFxuICAgIH0gZWxzZSBpZiAocGljT3JkZXJDbnRUeXBlID09PSAxKSB7XG4gICAgICBza2lwQml0cygxKTsgLy8gZGVsdGFfcGljX29yZGVyX2Fsd2F5c196ZXJvX2ZsYWdcbiAgICAgIHNraXBFRygpOyAvLyBvZmZzZXRfZm9yX25vbl9yZWZfcGljXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl90b3BfdG9fYm90dG9tX2ZpZWxkXG4gICAgICBudW1SZWZGcmFtZXNJblBpY09yZGVyQ250Q3ljbGUgPSByZWFkVUVHKCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlOyBpKyspIHtcbiAgICAgICAgc2tpcEVHKCk7XG4gICAgICB9IC8vIG9mZnNldF9mb3JfcmVmX2ZyYW1lWyBpIF1cbiAgICB9XG4gICAgc2tpcFVFRygpOyAvLyBtYXhfbnVtX3JlZl9mcmFtZXNcbiAgICBza2lwQml0cygxKTsgLy8gZ2Fwc19pbl9mcmFtZV9udW1fdmFsdWVfYWxsb3dlZF9mbGFnXG4gICAgY29uc3QgcGljV2lkdGhJbk1ic01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBwaWNIZWlnaHRJbk1hcFVuaXRzTWludXMxID0gcmVhZFVFRygpO1xuICAgIGNvbnN0IGZyYW1lTWJzT25seUZsYWcgPSByZWFkQml0cygxKTtcbiAgICBpZiAoZnJhbWVNYnNPbmx5RmxhZyA9PT0gMCkge1xuICAgICAgc2tpcEJpdHMoMSk7XG4gICAgfSAvLyBtYl9hZGFwdGl2ZV9mcmFtZV9maWVsZF9mbGFnXG5cbiAgICBza2lwQml0cygxKTsgLy8gZGlyZWN0Xzh4OF9pbmZlcmVuY2VfZmxhZ1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyBmcmFtZV9jcm9wcGluZ19mbGFnXG4gICAgICBmcmFtZUNyb3BMZWZ0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wUmlnaHRPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BUb3BPZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgICBmcmFtZUNyb3BCb3R0b21PZmZzZXQgPSByZWFkVUVHKCk7XG4gICAgfVxuICAgIGxldCBwaXhlbFJhdGlvOiBbbnVtYmVyLCBudW1iZXJdID0gWzEsIDFdO1xuICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAvLyB2dWlfcGFyYW1ldGVyc19wcmVzZW50X2ZsYWdcbiAgICAgIGlmIChyZWFkQm9vbGVhbigpKSB7XG4gICAgICAgIC8vIGFzcGVjdF9yYXRpb19pbmZvX3ByZXNlbnRfZmxhZ1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb0lkYyA9IHJlYWRVQnl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGFzcGVjdFJhdGlvSWRjKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTYsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNDAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjQsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMjAsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMzIsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbODAsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE4LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNSwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNjQsIDMzXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2MCwgOTldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbNCwgM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFszLCAyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIsIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNTU6IHtcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbXG4gICAgICAgICAgICAgIChyZWFkVUJ5dGUoKSA8PCA4KSB8IHJlYWRVQnl0ZSgpLFxuICAgICAgICAgICAgICAocmVhZFVCeXRlKCkgPDwgOCkgfCByZWFkVUJ5dGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoXG4gICAgICAgIChwaWNXaWR0aEluTWJzTWludXMxICsgMSkgKiAxNiAtXG4gICAgICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLVxuICAgICAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ICogMixcbiAgICAgICksXG4gICAgICBoZWlnaHQ6XG4gICAgICAgICgyIC0gZnJhbWVNYnNPbmx5RmxhZykgKiAocGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSArIDEpICogMTYgLVxuICAgICAgICAoZnJhbWVNYnNPbmx5RmxhZyA/IDIgOiA0KSAqXG4gICAgICAgICAgKGZyYW1lQ3JvcFRvcE9mZnNldCArIGZyYW1lQ3JvcEJvdHRvbU9mZnNldCksXG4gICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgIH07XG4gIH1cblxuICByZWFkU2xpY2VUeXBlKCkge1xuICAgIC8vIHNraXAgTkFMdSB0eXBlXG4gICAgdGhpcy5yZWFkVUJ5dGUoKTtcbiAgICAvLyBkaXNjYXJkIGZpcnN0X21iX2luX3NsaWNlXG4gICAgdGhpcy5yZWFkVUVHKCk7XG4gICAgLy8gcmV0dXJuIHNsaWNlX3R5cGVcbiAgICByZXR1cm4gdGhpcy5yZWFkVUVHKCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwR29sb21iO1xuIiwiaW1wb3J0IEJhc2VWaWRlb1BhcnNlciBmcm9tICcuL2Jhc2UtdmlkZW8tcGFyc2VyJztcbmltcG9ydCB7XG4gIERlbXV4ZWRWaWRlb1RyYWNrLFxuICBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgVmlkZW9TYW1wbGVVbml0LFxufSBmcm9tICcuLi8uLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB7XG4gIGFwcGVuZFVpbnQ4QXJyYXksXG4gIHBhcnNlU0VJTWVzc2FnZUZyb21OQUx1LFxufSBmcm9tICcuLi8uLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IEV4cEdvbG9tYiBmcm9tICcuL2V4cC1nb2xvbWInO1xuaW1wb3J0IHR5cGUgeyBQRVMgfSBmcm9tICcuLi90c2RlbXV4ZXInO1xuXG5jbGFzcyBBdmNWaWRlb1BhcnNlciBleHRlbmRzIEJhc2VWaWRlb1BhcnNlciB7XG4gIHB1YmxpYyBwYXJzZUFWQ1BFUyhcbiAgICB0cmFjazogRGVtdXhlZFZpZGVvVHJhY2ssXG4gICAgdGV4dFRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICBwZXM6IFBFUyxcbiAgICBsYXN0OiBib29sZWFuLFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IHVuaXRzID0gdGhpcy5wYXJzZUFWQ05BTHUodHJhY2ssIHBlcy5kYXRhKTtcbiAgICBjb25zdCBkZWJ1ZyA9IGZhbHNlO1xuICAgIGxldCBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGU7XG4gICAgbGV0IHB1c2g6IGJvb2xlYW47XG4gICAgbGV0IHNwc2ZvdW5kID0gZmFsc2U7XG4gICAgLy8gZnJlZSBwZXMuZGF0YSB0byBzYXZlIHVwIHNvbWUgbWVtb3J5XG4gICAgKHBlcyBhcyBhbnkpLmRhdGEgPSBudWxsO1xuXG4gICAgLy8gaWYgbmV3IE5BTCB1bml0cyBmb3VuZCBhbmQgbGFzdCBzYW1wbGUgc3RpbGwgdGhlcmUsIGxldCdzIHB1c2ggLi4uXG4gICAgLy8gdGhpcyBoZWxwcyBwYXJzaW5nIHN0cmVhbXMgd2l0aCBtaXNzaW5nIEFVRCAob25seSBkbyB0aGlzIGlmIEFVRCBuZXZlciBmb3VuZClcbiAgICBpZiAoVmlkZW9TYW1wbGUgJiYgdW5pdHMubGVuZ3RoICYmICF0cmFjay5hdWRGb3VuZCkge1xuICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHBlcy5wdHMsXG4gICAgICAgIHBlcy5kdHMsXG4gICAgICAgICcnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB1bml0cy5mb3JFYWNoKCh1bml0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHVuaXQudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgbGV0IGlza2V5ID0gZmFsc2U7XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICBpZiAoc3BzZm91bmQgJiYgZGF0YS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyByZXRyaWV2ZSBzbGljZSB0eXBlIGJ5IHBhcnNpbmcgYmVnaW5uaW5nIG9mIE5BTCB1bml0IChmb2xsb3cgSDI2NCBzcGVjLCBzbGljZV9oZWFkZXIgZGVmaW5pdGlvbikgdG8gZGV0ZWN0IGtleWZyYW1lIGVtYmVkZGVkIGluIE5EUlxuICAgICAgICAgICAgY29uc3Qgc2xpY2VUeXBlID0gbmV3IEV4cEdvbG9tYihkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAvLyAyIDogSSBzbGljZSwgNCA6IFNJIHNsaWNlLCA3IDogSSBzbGljZSwgOTogU0kgc2xpY2VcbiAgICAgICAgICAgIC8vIFNJIHNsaWNlIDogQSBzbGljZSB0aGF0IGlzIGNvZGVkIHVzaW5nIGludHJhIHByZWRpY3Rpb24gb25seSBhbmQgdXNpbmcgcXVhbnRpc2F0aW9uIG9mIHRoZSBwcmVkaWN0aW9uIHNhbXBsZXMuXG4gICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgLy8gSSBzbGljZTogQSBzbGljZSB0aGF0IGlzIG5vdCBhbiBTSSBzbGljZSB0aGF0IGlzIGRlY29kZWQgdXNpbmcgaW50cmEgcHJlZGljdGlvbiBvbmx5LlxuICAgICAgICAgICAgLy8gaWYgKHNsaWNlVHlwZSA9PT0gMiB8fCBzbGljZVR5cGUgPT09IDcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgc2xpY2VUeXBlID09PSAyIHx8XG4gICAgICAgICAgICAgIHNsaWNlVHlwZSA9PT0gNCB8fFxuICAgICAgICAgICAgICBzbGljZVR5cGUgPT09IDcgfHxcbiAgICAgICAgICAgICAgc2xpY2VUeXBlID09PSA5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaXNrZXkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc2tleSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBub24ta2V5ZnJhbWUgZGF0YSBhbHJlYWR5LCB0aGF0IGNhbm5vdCBiZWxvbmcgdG8gdGhlIHNhbWUgZnJhbWUgYXMgYSBrZXlmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgICBpZiAoVmlkZW9TYW1wbGU/LmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgIHBlcy5wdHMsXG4gICAgICAgICAgICAgIHBlcy5kdHMsXG4gICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmRlYnVnICs9ICdORFIgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gaXNrZXk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBJRFJcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgLy8gaGFuZGxlIFBFUyBub3Qgc3RhcnRpbmcgd2l0aCBBVURcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGZyYW1lIGRhdGEgYWxyZWFkeSwgdGhhdCBjYW5ub3QgYmVsb25nIHRvIHRoZSBzYW1lIGZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICBpZiAoVmlkZW9TYW1wbGU/LmZyYW1lICYmICFWaWRlb1NhbXBsZS5rZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgIHBlcy5wdHMsXG4gICAgICAgICAgICAgIHBlcy5kdHMsXG4gICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmRlYnVnICs9ICdJRFIgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBWaWRlb1NhbXBsZS5rZXkgPSB0cnVlO1xuICAgICAgICAgIFZpZGVvU2FtcGxlLmZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU0VJXG4gICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZGVidWcgKz0gJ1NFSSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShcbiAgICAgICAgICAgIHVuaXQuZGF0YSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBwZXMucHRzIGFzIG51bWJlcixcbiAgICAgICAgICAgIHRleHRUcmFjay5zYW1wbGVzLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gU1BTXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgc3BzZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZGVidWcgKz0gJ1NQUyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzcHMgPSB1bml0LmRhdGE7XG4gICAgICAgICAgY29uc3QgZXhwR29sb21iRGVjb2RlciA9IG5ldyBFeHBHb2xvbWIoc3BzKTtcbiAgICAgICAgICBjb25zdCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICF0cmFjay5zcHMgfHxcbiAgICAgICAgICAgIHRyYWNrLndpZHRoICE9PSBjb25maWcud2lkdGggfHxcbiAgICAgICAgICAgIHRyYWNrLmhlaWdodCAhPT0gY29uZmlnLmhlaWdodCB8fFxuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbz8uWzBdICE9PSBjb25maWcucGl4ZWxSYXRpb1swXSB8fFxuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbz8uWzFdICE9PSBjb25maWcucGl4ZWxSYXRpb1sxXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJhY2sud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICAgICAgICB0cmFjay5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdHJhY2suc3BzID0gW3Nwc107XG4gICAgICAgICAgICB0cmFjay5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgY29kZWNhcnJheSA9IHNwcy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIGxldCBjb2RlY3N0cmluZyA9ICdhdmMxLic7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2suY29kZWMgPSBjb2RlY3N0cmluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBQUFNcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGlmIChkZWJ1ZyAmJiBWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZGVidWcgKz0gJ1BQUyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyYWNrLnBwcyA9IFt1bml0LmRhdGFdO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIHBlcy5wdHMsXG4gICAgICAgICAgICBwZXMuZHRzLFxuICAgICAgICAgICAgZGVidWcgPyAnQVVEICcgOiAnJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGaWxsZXIgRGF0YVxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2ggPSBmYWxzZTtcbiAgICAgICAgICBpZiAoVmlkZW9TYW1wbGUpIHtcbiAgICAgICAgICAgIFZpZGVvU2FtcGxlLmRlYnVnICs9ICd1bmtub3duIE5BTCAnICsgdW5pdC50eXBlICsgJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFZpZGVvU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIFZpZGVvU2FtcGxlKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhcnNlQVZDTkFMdShcbiAgICB0cmFjazogRGVtdXhlZFZpZGVvVHJhY2ssXG4gICAgYXJyYXk6IFVpbnQ4QXJyYXksXG4gICk6IEFycmF5PHtcbiAgICBkYXRhOiBVaW50OEFycmF5O1xuICAgIHR5cGU6IG51bWJlcjtcbiAgICBzdGF0ZT86IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdW5pdHM6IFZpZGVvU2FtcGxlVW5pdFtdID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB2YWx1ZTogbnVtYmVyO1xuICAgIGxldCBvdmVyZmxvdzogbnVtYmVyO1xuICAgIGxldCB1bml0VHlwZTogbnVtYmVyO1xuICAgIGxldCBsYXN0VW5pdFN0YXJ0ID0gLTE7XG4gICAgbGV0IGxhc3RVbml0VHlwZTogbnVtYmVyID0gMDtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB2YWx1ZSA9IGFycmF5W2krK107XG4gICAgICAvLyBvcHRpbWl6YXRpb24uIHN0YXRlIDAgYW5kIDEgYXJlIHRoZSBwcmVkb21pbmFudCBjYXNlLiBsZXQncyBoYW5kbGUgdGhlbSBvdXRzaWRlIG9mIHRoZSBzd2l0Y2gvY2FzZVxuICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSAxKSB7XG4gICAgICAgIHN0YXRlID0gdmFsdWUgPyAwIDogMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBoZXJlIHdlIGhhdmUgc3RhdGUgZWl0aGVyIGVxdWFsIHRvIDIgb3IgM1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAxKSB7XG4gICAgICAgIG92ZXJmbG93ID0gaSAtIHN0YXRlIC0gMTtcbiAgICAgICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHVuaXQ6IFZpZGVvU2FtcGxlVW5pdCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIG92ZXJmbG93KSxcbiAgICAgICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXN0VW5pdFN0YXJ0IGlzIHVuZGVmaW5lZCA9PiB0aGlzIGlzIHRoZSBmaXJzdCBzdGFydCBjb2RlIGZvdW5kIGluIHRoaXMgUEVTIHBhY2tldFxuICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIGlmIHN0YXJ0IGNvZGUgZGVsaW1pdGVyIGlzIG92ZXJsYXBwaW5nIGJldHdlZW4gMiBQRVMgcGFja2V0cyxcbiAgICAgICAgICAvLyBpZSBpdCBzdGFydGVkIGluIGxhc3QgcGFja2V0IChsYXN0U3RhdGUgbm90IHplcm8pXG4gICAgICAgICAgLy8gYW5kIGVuZGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBQRVMgcGFja2V0IChpIDw9IDQgLSBsYXN0U3RhdGUpXG4gICAgICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAmJiBpIDw9IDQgLSBsYXN0U3RhdGUpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgZGVsaW1pdGVyIG92ZXJsYXBwaW5nIGJldHdlZW4gUEVTIHBhY2tldHNcbiAgICAgICAgICAgICAgLy8gc3RyaXAgc3RhcnQgZGVsaW1pdGVyIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBsYXN0IE5BTCB1bml0XG4gICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhc3RVbml0IGhhZCBhIHN0YXRlIGRpZmZlcmVudCBmcm9tIHplcm9cbiAgICAgICAgICAgICAgaWYgKGxhc3RVbml0LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGFzdCBieXRlc1xuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBsYXN0VW5pdC5kYXRhLnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEuYnl0ZUxlbmd0aCAtIGxhc3RTdGF0ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBhcHBlbmRVaW50OEFycmF5KFxuICAgICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEsXG4gICAgICAgICAgICAgICAgYXJyYXkuc3ViYXJyYXkoMCwgb3ZlcmZsb3cpLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBsYXN0VW5pdC5zdGF0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiByZWFkIHVuaXQgdHlwZVxuICAgICAgICBpZiAoaSA8IGxlbikge1xuICAgICAgICAgIHVuaXRUeXBlID0gYXJyYXlbaV0gJiAweDFmO1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2ZpbmQgTkFMVSBAIG9mZnNldDonICsgaSArICcsdHlwZTonICsgdW5pdFR5cGUpO1xuICAgICAgICAgIGxhc3RVbml0U3RhcnQgPSBpO1xuICAgICAgICAgIGxhc3RVbml0VHlwZSA9IHVuaXRUeXBlO1xuICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBub3QgZW5vdWdoIGJ5dGUgdG8gcmVhZCB1bml0IHR5cGUuIGxldCdzIHJlYWQgaXQgb24gbmV4dCBQRVMgcGFyc2luZ1xuICAgICAgICAgIHN0YXRlID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhc3RVbml0U3RhcnQgPj0gMCAmJiBzdGF0ZSA+PSAwKSB7XG4gICAgICBjb25zdCB1bml0OiBWaWRlb1NhbXBsZVVuaXQgPSB7XG4gICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksXG4gICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgfTtcbiAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZS9zdGF0ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGggKyAnLycgKyBzdGF0ZSk7XG4gICAgfVxuICAgIC8vIG5vIE5BTHUgZm91bmRcbiAgICBpZiAodW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBhcHBlbmQgcGVzLmRhdGEgdG8gcHJldmlvdXMgTkFMIHVuaXRcbiAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgIGlmIChsYXN0VW5pdCkge1xuICAgICAgICBsYXN0VW5pdC5kYXRhID0gYXBwZW5kVWludDhBcnJheShsYXN0VW5pdC5kYXRhLCBhcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLm5hbHVTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiB1bml0cztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdmNWaWRlb1BhcnNlcjtcbiIsIi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAqL1xuXG5pbXBvcnQgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IERlY3J5cHRlciBmcm9tICcuLi9jcnlwdC9kZWNyeXB0ZXInO1xuaW1wb3J0IHsgSGxzRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9TYW1wbGUsXG4gIFZpZGVvU2FtcGxlLFxuICBWaWRlb1NhbXBsZVVuaXQsXG4gIERlbXV4ZWRWaWRlb1RyYWNrQmFzZSxcbiAgS2V5RGF0YSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgeyBkaXNjYXJkRVBCIH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcblxuY2xhc3MgU2FtcGxlQWVzRGVjcnlwdGVyIHtcbiAgcHJpdmF0ZSBrZXlEYXRhOiBLZXlEYXRhO1xuICBwcml2YXRlIGRlY3J5cHRlcjogRGVjcnlwdGVyO1xuXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsIGNvbmZpZzogSGxzQ29uZmlnLCBrZXlEYXRhOiBLZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0ga2V5RGF0YTtcbiAgICB0aGlzLmRlY3J5cHRlciA9IG5ldyBEZWNyeXB0ZXIoY29uZmlnLCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6IGZhbHNlLFxuICAgIH0pO1xuICB9XG5cbiAgZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoXG4gICAgICBlbmNyeXB0ZWREYXRhLFxuICAgICAgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsXG4gICAgICB0aGlzLmtleURhdGEuaXYuYnVmZmVyLFxuICAgICk7XG4gIH1cblxuICAvLyBBQUMgLSBlbmNyeXB0IGFsbCBmdWxsIDE2IGJ5dGVzIGJsb2NrcyBzdGFydGluZyBmcm9tIG9mZnNldCAxNlxuICBwcml2YXRlIGRlY3J5cHRBYWNTYW1wbGUoXG4gICAgc2FtcGxlczogQXVkaW9TYW1wbGVbXSxcbiAgICBzYW1wbGVJbmRleDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkLFxuICApIHtcbiAgICBjb25zdCBjdXJVbml0ID0gc2FtcGxlc1tzYW1wbGVJbmRleF0udW5pdDtcbiAgICBpZiAoY3VyVW5pdC5sZW5ndGggPD0gMTYpIHtcbiAgICAgIC8vIE5vIGVuY3J5cHRlZCBwb3J0aW9uIGluIHRoaXMgc2FtcGxlIChmaXJzdCAxNiBieXRlcyBpcyBub3RcbiAgICAgIC8vIGVuY3J5cHRlZCwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSExTX1NhbXBsZV9FbmNyeXB0aW9uL0VuY3J5cHRpb24vRW5jcnlwdGlvbi5odG1sKSxcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IGN1clVuaXQuc3ViYXJyYXkoXG4gICAgICAxNixcbiAgICAgIGN1clVuaXQubGVuZ3RoIC0gKGN1clVuaXQubGVuZ3RoICUgMTYpLFxuICAgICk7XG4gICAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gZW5jcnlwdGVkRGF0YS5idWZmZXIuc2xpY2UoXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQsXG4gICAgICBlbmNyeXB0ZWREYXRhLmJ5dGVPZmZzZXQgKyBlbmNyeXB0ZWREYXRhLmxlbmd0aCxcbiAgICApO1xuXG4gICAgdGhpcy5kZWNyeXB0QnVmZmVyKGVuY3J5cHRlZEJ1ZmZlcikudGhlbigoZGVjcnlwdGVkQnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgY29uc3QgZGVjcnlwdGVkRGF0YSA9IG5ldyBVaW50OEFycmF5KGRlY3J5cHRlZEJ1ZmZlcik7XG4gICAgICBjdXJVbml0LnNldChkZWNyeXB0ZWREYXRhLCAxNik7XG5cbiAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlcyhzYW1wbGVzLCBzYW1wbGVJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlY3J5cHRBYWNTYW1wbGVzKFxuICAgIHNhbXBsZXM6IEF1ZGlvU2FtcGxlW10sXG4gICAgc2FtcGxlSW5kZXg6IG51bWJlcixcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZCxcbiAgKSB7XG4gICAgZm9yICg7IDsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVjcnlwdEFhY1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhOiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YUxlbiA9XG4gICAgICBNYXRoLmZsb29yKChkZWNvZGVkRGF0YS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNjtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gbmV3IEludDhBcnJheShlbmNyeXB0ZWREYXRhTGVuKTtcbiAgICBsZXQgb3V0cHV0UG9zID0gMDtcbiAgICBmb3IgKFxuICAgICAgbGV0IGlucHV0UG9zID0gMzI7XG4gICAgICBpbnB1dFBvcyA8IGRlY29kZWREYXRhLmxlbmd0aCAtIDE2O1xuICAgICAgaW5wdXRQb3MgKz0gMTYwLCBvdXRwdXRQb3MgKz0gMTZcbiAgICApIHtcbiAgICAgIGVuY3J5cHRlZERhdGEuc2V0KFxuICAgICAgICBkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksXG4gICAgICAgIG91dHB1dFBvcyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY3J5cHRlZERhdGE7XG4gIH1cblxuICBnZXRBdmNEZWNyeXB0ZWRVbml0KFxuICAgIGRlY29kZWREYXRhOiBVaW50OEFycmF5LFxuICAgIGRlY3J5cHRlZERhdGE6IEFycmF5TGlrZTxudW1iZXI+IHwgQXJyYXlCdWZmZXIgfCBTaGFyZWRBcnJheUJ1ZmZlcixcbiAgKSB7XG4gICAgY29uc3QgdWludDhEZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkRGF0YSk7XG4gICAgbGV0IGlucHV0UG9zID0gMDtcbiAgICBmb3IgKFxuICAgICAgbGV0IG91dHB1dFBvcyA9IDMyO1xuICAgICAgb3V0cHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7XG4gICAgICBvdXRwdXRQb3MgKz0gMTYwLCBpbnB1dFBvcyArPSAxNlxuICAgICkge1xuICAgICAgZGVjb2RlZERhdGEuc2V0KFxuICAgICAgICB1aW50OERlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLFxuICAgICAgICBvdXRwdXRQb3MsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNvZGVkRGF0YTtcbiAgfVxuXG4gIGRlY3J5cHRBdmNTYW1wbGUoXG4gICAgc2FtcGxlczogVmlkZW9TYW1wbGVbXSxcbiAgICBzYW1wbGVJbmRleDogbnVtYmVyLFxuICAgIHVuaXRJbmRleDogbnVtYmVyLFxuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkLFxuICAgIGN1clVuaXQ6IFZpZGVvU2FtcGxlVW5pdCxcbiAgKSB7XG4gICAgY29uc3QgZGVjb2RlZERhdGEgPSBkaXNjYXJkRVBCKGN1clVuaXQuZGF0YSk7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShkZWNvZGVkRGF0YSk7XG5cbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YS5idWZmZXIpLnRoZW4oXG4gICAgICAoZGVjcnlwdGVkQnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBjdXJVbml0LmRhdGEgPSB0aGlzLmdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZEJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCArIDEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgZGVjcnlwdEF2Y1NhbXBsZXMoXG4gICAgc2FtcGxlczogRGVtdXhlZFZpZGVvVHJhY2tCYXNlWydzYW1wbGVzJ10sXG4gICAgc2FtcGxlSW5kZXg6IG51bWJlcixcbiAgICB1bml0SW5kZXg6IG51bWJlcixcbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZCxcbiAgKSB7XG4gICAgaWYgKHNhbXBsZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5Jyk7XG4gICAgfVxuXG4gICAgZm9yICg7IDsgc2FtcGxlSW5kZXgrKywgdW5pdEluZGV4ID0gMCkge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgIGZvciAoOyA7IHVuaXRJbmRleCsrKSB7XG4gICAgICAgIGlmICh1bml0SW5kZXggPj0gY3VyVW5pdHMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHxcbiAgICAgICAgICAoY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGUoXG4gICAgICAgICAgc2FtcGxlcyxcbiAgICAgICAgICBzYW1wbGVJbmRleCxcbiAgICAgICAgICB1bml0SW5kZXgsXG4gICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgY3VyVW5pdCxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNhbXBsZUFlc0RlY3J5cHRlcjtcbiIsIi8qKlxuICogaGlnaGx5IG9wdGltaXplZCBUUyBkZW11eGVyOlxuICogcGFyc2UgUEFULCBQTVRcbiAqIGV4dHJhY3QgUEVTIHBhY2tldCBmcm9tIGF1ZGlvIGFuZCB2aWRlbyBQSURzXG4gKiBleHRyYWN0IEFWQy9IMjY0IE5BTCB1bml0cyBhbmQgQUFDL0FEVFMgc2FtcGxlcyBmcm9tIFBFUyBwYWNrZXRcbiAqIHRyaWdnZXIgdGhlIHJlbXV4ZXIgdXBvbiBwYXJzaW5nIGNvbXBsZXRpb25cbiAqIGl0IGFsc28gdHJpZXMgdG8gd29ya2Fyb3VuZCBhcyBiZXN0IGFzIGl0IGNhbiBhdWRpbyBjb2RlYyBzd2l0Y2ggKEhFLUFBQyB0byBBQUMgYW5kIHZpY2UgdmVyc2EpLCB3aXRob3V0IGhhdmluZyB0byByZXN0YXJ0IHRoZSBNZWRpYVNvdXJjZS5cbiAqIGl0IGFsc28gY29udHJvbHMgdGhlIHJlbXV4aW5nIHByb2Nlc3MgOlxuICogdXBvbiBkaXNjb250aW51aXR5IG9yIGxldmVsIHN3aXRjaCBkZXRlY3Rpb24sIGl0IHdpbGwgYWxzbyBub3RpZmllcyB0aGUgcmVtdXhlciBzbyB0aGF0IGl0IGNhbiByZXNldCBpdHMgc3RhdGUuXG4gKi9cblxuaW1wb3J0ICogYXMgQURUUyBmcm9tICcuL2F1ZGlvL2FkdHMnO1xuaW1wb3J0ICogYXMgTXBlZ0F1ZGlvIGZyb20gJy4vYXVkaW8vbXBlZ2F1ZGlvJztcbmltcG9ydCAqIGFzIEFDMyBmcm9tICcuL2F1ZGlvL2FjMy1kZW11eGVyJztcbmltcG9ydCBBdmNWaWRlb1BhcnNlciBmcm9tICcuL3ZpZGVvL2F2Yy12aWRlby1wYXJzZXInO1xuaW1wb3J0IFNhbXBsZUFlc0RlY3J5cHRlciBmcm9tICcuL3NhbXBsZS1hZXMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGFwcGVuZFVpbnQ4QXJyYXksIFJlbXV4ZXJUcmFja0lkQ29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvclR5cGVzLCBFcnJvckRldGFpbHMgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBIbHNDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHtcbiAgRGVtdXhlZFZpZGVvVHJhY2ssXG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBEZW11eGVkVHJhY2ssXG4gIERlbXV4ZXIsXG4gIERlbXV4ZXJSZXN1bHQsXG4gIFZpZGVvU2FtcGxlLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIEVsZW1lbnRhcnlTdHJlYW1EYXRhLFxuICBLZXlEYXRhLFxuICBNZXRhZGF0YVNjaGVtYSxcbn0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5pbXBvcnQgeyBBdWRpb0ZyYW1lIH0gZnJvbSAnLi4vdHlwZXMvZGVtdXhlcic7XG5cbmV4cG9ydCB0eXBlIFBhcnNlZFRpbWVzdGFtcCA9IHtcbiAgcHRzPzogbnVtYmVyO1xuICBkdHM/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBQRVMgPSBQYXJzZWRUaW1lc3RhbXAgJiB7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIGxlbjogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgUGFyc2VkVmlkZW9TYW1wbGUgPSBQYXJzZWRUaW1lc3RhbXAgJlxuICBPbWl0PFZpZGVvU2FtcGxlLCAncHRzJyB8ICdkdHMnPjtcblxuZXhwb3J0IGludGVyZmFjZSBUeXBlU3VwcG9ydGVkIHtcbiAgbXBlZzogYm9vbGVhbjtcbiAgbXAzOiBib29sZWFuO1xuICBhYzM6IGJvb2xlYW47XG59XG5cbmNvbnN0IFBBQ0tFVF9MRU5HVEggPSAxODg7XG5cbmNsYXNzIFRTRGVtdXhlciBpbXBsZW1lbnRzIERlbXV4ZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZDtcblxuICBwcml2YXRlIHNhbXBsZUFlczogU2FtcGxlQWVzRGVjcnlwdGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcG10UGFyc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgcHJpdmF0ZSB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIF9kdXJhdGlvbjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfcG10SWQ6IG51bWJlciA9IC0xO1xuXG4gIHByaXZhdGUgX3ZpZGVvVHJhY2s/OiBEZW11eGVkVmlkZW9UcmFjaztcbiAgcHJpdmF0ZSBfYXVkaW9UcmFjaz86IERlbXV4ZWRBdWRpb1RyYWNrO1xuICBwcml2YXRlIF9pZDNUcmFjaz86IERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICBwcml2YXRlIF90eHRUcmFjaz86IERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuICBwcml2YXRlIGFhY092ZXJGbG93OiBBdWRpb0ZyYW1lIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcmVtYWluZGVyRGF0YTogVWludDhBcnJheSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHZpZGVvUGFyc2VyOiBBdmNWaWRlb1BhcnNlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyLFxuICAgIGNvbmZpZzogSGxzQ29uZmlnLFxuICAgIHR5cGVTdXBwb3J0ZWQ6IFR5cGVTdXBwb3J0ZWQsXG4gICkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMudmlkZW9QYXJzZXIgPSBuZXcgQXZjVmlkZW9QYXJzZXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBwcm9iZShkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuICAgIGlmIChzeW5jT2Zmc2V0ID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgIGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7c3luY09mZnNldH1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNPZmZzZXQgIT09IC0xO1xuICB9XG5cbiAgc3RhdGljIHN5bmNPZmZzZXQoZGF0YTogVWludDhBcnJheSk6IG51bWJlciB7XG4gICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgbGV0IHNjYW53aW5kb3cgPSBNYXRoLm1pbihQQUNLRVRfTEVOR1RIICogNSwgbGVuZ3RoIC0gUEFDS0VUX0xFTkdUSCkgKyAxO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNjYW53aW5kb3cpIHtcbiAgICAgIC8vIGEgVFMgaW5pdCBzZWdtZW50IHNob3VsZCBjb250YWluIGF0IGxlYXN0IDIgVFMgcGFja2V0czogUEFUIGFuZCBQTVQsIGVhY2ggc3RhcnRpbmcgd2l0aCAweDQ3XG4gICAgICBsZXQgZm91bmRQYXQgPSBmYWxzZTtcbiAgICAgIGxldCBwYWNrZXRTdGFydCA9IC0xO1xuICAgICAgbGV0IHRzUGFja2V0cyA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGxlbmd0aDsgaiArPSBQQUNLRVRfTEVOR1RIKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBkYXRhW2pdID09PSAweDQ3ICYmXG4gICAgICAgICAgKGxlbmd0aCAtIGogPT09IFBBQ0tFVF9MRU5HVEggfHwgZGF0YVtqICsgUEFDS0VUX0xFTkdUSF0gPT09IDB4NDcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRzUGFja2V0cysrO1xuICAgICAgICAgIGlmIChwYWNrZXRTdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHBhY2tldFN0YXJ0ID0gajtcbiAgICAgICAgICAgIC8vIEZpcnN0IHN5bmMgd29yZCBmb3VuZCBhdCBvZmZzZXQsIGluY3JlYXNlIHNjYW4gbGVuZ3RoICgjNTI1MSlcbiAgICAgICAgICAgIGlmIChwYWNrZXRTdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICBzY2Fud2luZG93ID1cbiAgICAgICAgICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgIHBhY2tldFN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAqIDk5LFxuICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggLSBQQUNLRVRfTEVOR1RILFxuICAgICAgICAgICAgICAgICkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kUGF0KSB7XG4gICAgICAgICAgICBmb3VuZFBhdCA9IHBhcnNlUElEKGRhdGEsIGopID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTeW5jIHdvcmQgZm91bmQgYXQgMCB3aXRoIDMgcGFja2V0cywgb3IgZm91bmQgYXQgb2Zmc2V0IGxlYXN0IDIgcGFja2V0cyB1cCB0byBzY2Fud2luZG93ICgjNTUwMSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmb3VuZFBhdCAmJlxuICAgICAgICAgICAgdHNQYWNrZXRzID4gMSAmJlxuICAgICAgICAgICAgKChwYWNrZXRTdGFydCA9PT0gMCAmJiB0c1BhY2tldHMgPiAyKSB8fFxuICAgICAgICAgICAgICBqICsgUEFDS0VUX0xFTkdUSCA+IHNjYW53aW5kb3cpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0U3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRzUGFja2V0cykge1xuICAgICAgICAgIC8vIEV4aXQgaWYgc3luYyB3b3JkIGZvdW5kLCBidXQgZG9lcyBub3QgY29udGFpbiBjb250aWd1b3VzIHBhY2tldHNcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0cmFjayBtb2RlbCBpbnRlcm5hbCB0byBkZW11eGVyIHVzZWQgdG8gZHJpdmUgcmVtdXhpbmcgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVUcmFjayhcbiAgICB0eXBlOiAnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdpZDMnIHwgJ3RleHQnLFxuICAgIGR1cmF0aW9uPzogbnVtYmVyLFxuICApOiBEZW11eGVkVHJhY2sge1xuICAgIHJldHVybiB7XG4gICAgICBjb250YWluZXI6XG4gICAgICAgIHR5cGUgPT09ICd2aWRlbycgfHwgdHlwZSA9PT0gJ2F1ZGlvJyA/ICd2aWRlby9tcDJ0JyA6IHVuZGVmaW5lZCxcbiAgICAgIHR5cGUsXG4gICAgICBpZDogUmVtdXhlclRyYWNrSWRDb25maWdbdHlwZV0sXG4gICAgICBwaWQ6IC0xLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICBkdXJhdGlvbjogdHlwZSA9PT0gJ2F1ZGlvJyA/IGR1cmF0aW9uIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovXG4gIHB1YmxpYyByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcsXG4gICAgdHJhY2tEdXJhdGlvbjogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG5cbiAgICB0aGlzLl92aWRlb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCd2aWRlbycpIGFzIERlbXV4ZWRWaWRlb1RyYWNrO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSBUU0RlbXV4ZXIuY3JlYXRlVHJhY2soXG4gICAgICAnYXVkaW8nLFxuICAgICAgdHJhY2tEdXJhdGlvbixcbiAgICApIGFzIERlbXV4ZWRBdWRpb1RyYWNrO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnKSBhcyBEZW11eGVkTWV0YWRhdGFUcmFjaztcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcpIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gJ2FhYyc7XG5cbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG5cbiAgcHVibGljIHJlc2V0VGltZVN0YW1wKCkge31cblxuICBwdWJsaWMgcmVzZXRDb250aWd1aXR5KCk6IHZvaWQge1xuICAgIGNvbnN0IHsgX2F1ZGlvVHJhY2ssIF92aWRlb1RyYWNrLCBfaWQzVHJhY2sgfSA9IHRoaXM7XG4gICAgaWYgKF9hdWRpb1RyYWNrKSB7XG4gICAgICBfYXVkaW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF92aWRlb1RyYWNrKSB7XG4gICAgICBfdmlkZW9UcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKF9pZDNUcmFjaykge1xuICAgICAgX2lkM1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGRlbXV4KFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGlzU2FtcGxlQWVzID0gZmFsc2UsXG4gICAgZmx1c2ggPSBmYWxzZSxcbiAgKTogRGVtdXhlclJlc3VsdCB7XG4gICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgdGhpcy5zYW1wbGVBZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGxldCBwZXM6IFBFUyB8IG51bGw7XG5cbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy5fdmlkZW9UcmFjayBhcyBEZW11eGVkVmlkZW9UcmFjaztcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjayBhcyBEZW11eGVkQXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrIGFzIERlbXV4ZWRNZXRhZGF0YVRyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuX3R4dFRyYWNrIGFzIERlbXV4ZWRVc2VyZGF0YVRyYWNrO1xuXG4gICAgbGV0IHZpZGVvUGlkID0gdmlkZW9UcmFjay5waWQ7XG4gICAgbGV0IHZpZGVvRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgYXVkaW9QaWQgPSBhdWRpb1RyYWNrLnBpZDtcbiAgICBsZXQgaWQzUGlkID0gaWQzVHJhY2sucGlkO1xuICAgIGxldCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGlkM0RhdGEgPSBpZDNUcmFjay5wZXNEYXRhO1xuICAgIGxldCB1bmtub3duUElEOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgcG10UGFyc2VkID0gdGhpcy5wbXRQYXJzZWQ7XG4gICAgbGV0IHBtdElkID0gdGhpcy5fcG10SWQ7XG5cbiAgICBsZXQgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHRoaXMucmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobGVuIDwgUEFDS0VUX0xFTkdUSCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuIC0gc3luY09mZnNldCkgJSBQQUNLRVRfTEVOR1RIO1xuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgIGxlbixcbiAgICAgICAgZGF0YS5idWZmZXIuYnl0ZUxlbmd0aCAtIGxlbixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gbG9vcCB0aHJvdWdoIFRTIHBhY2tldHNcbiAgICBsZXQgdHNQYWNrZXRFcnJvcnMgPSAwO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gc3luY09mZnNldDsgc3RhcnQgPCBsZW47IHN0YXJ0ICs9IFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgIGlmIChkYXRhW3N0YXJ0XSA9PT0gMHg0Nykge1xuICAgICAgICBjb25zdCBzdHQgPSAhIShkYXRhW3N0YXJ0ICsgMV0gJiAweDQwKTtcbiAgICAgICAgY29uc3QgcGlkID0gcGFyc2VQSUQoZGF0YSwgc3RhcnQpO1xuICAgICAgICBjb25zdCBhdGYgPSAoZGF0YVtzdGFydCArIDNdICYgMHgzMCkgPj4gNDtcblxuICAgICAgICAvLyBpZiBhbiBhZGFwdGlvbiBmaWVsZCBpcyBwcmVzZW50LCBpdHMgbGVuZ3RoIGlzIHNwZWNpZmllZCBieSB0aGUgZmlmdGggYnl0ZSBvZiB0aGUgVFMgcGFja2V0IGhlYWRlci5cbiAgICAgICAgbGV0IG9mZnNldDogbnVtYmVyO1xuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIHZpZGVvUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VBVkNQRVMoXG4gICAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgICAgICAgdGV4dFRyYWNrLFxuICAgICAgICAgICAgICAgICAgcGVzLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmlkZW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZGVvRGF0YSkge1xuICAgICAgICAgICAgICB2aWRlb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgdmlkZW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBhdWRpb1BpZDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfXykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQzNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0geyBkYXRhOiBbXSwgc2l6ZTogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1ZGlvRGF0YSkge1xuICAgICAgICAgICAgICBhdWRpb0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLnNpemUgKz0gc3RhcnQgKyBQQUNLRVRfTEVOR1RIIC0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZDNQaWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWQzRGF0YSA9IHsgZGF0YTogW10sIHNpemU6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBtdElkID0gdGhpcy5fcG10SWQgPSBwYXJzZVBBVChkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnUE1UIFBJRDonICArIHRoaXMuX3BtdElkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgcG10SWQ6IHtcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFBJRHMgPSBwYXJzZVBNVChcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICB0aGlzLnR5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICAgIGlzU2FtcGxlQWVzLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHJlc2V0dGluZyB0aGUgUElEIHRvIC0xIGluIGNhc2VcbiAgICAgICAgICAgIC8vIHRyYWNrIFBJRCB0cmFuc2llbnRseSBkaXNhcHBlYXJzIGZyb20gdGhlIHN0cmVhbVxuICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAvLyBOT1RFIHRoaXMgaXMgb25seSB0aGUgUElEIG9mIHRoZSB0cmFjayBhcyBmb3VuZCBpbiBUUyxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBhcmUgbm90IHVzaW5nIHRoaXMgZm9yIE1QNCB0cmFjayBJRHMuXG4gICAgICAgICAgICB2aWRlb1BpZCA9IHBhcnNlZFBJRHMudmlkZW9QaWQ7XG4gICAgICAgICAgICBpZiAodmlkZW9QaWQgPiAwKSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhY2sucGlkID0gdmlkZW9QaWQ7XG4gICAgICAgICAgICAgIHZpZGVvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50VmlkZW9Db2RlYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXVkaW9QaWQgPSBwYXJzZWRQSURzLmF1ZGlvUGlkO1xuICAgICAgICAgICAgaWYgKGF1ZGlvUGlkID4gMCkge1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvUGlkO1xuICAgICAgICAgICAgICBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9IHBhcnNlZFBJRHMuc2VnbWVudEF1ZGlvQ29kZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZDNQaWQgPSBwYXJzZWRQSURzLmlkM1BpZDtcbiAgICAgICAgICAgIGlmIChpZDNQaWQgPiAwKSB7XG4gICAgICAgICAgICAgIGlkM1RyYWNrLnBpZCA9IGlkM1BpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICBgTVBFRy1UUyBQTVQgZm91bmQgYXQgJHtzdGFydH0gYWZ0ZXIgdW5rbm93biBQSUQgJyR7dW5rbm93blBJRH0nLiBCYWNrdHJhY2tpbmcgdG8gc3luYyBieXRlIEAke3N5bmNPZmZzZXR9IHRvIHBhcnNlIGFsbCBUUyBwYWNrZXRzLmAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHVua25vd25QSUQgPSBudWxsO1xuICAgICAgICAgICAgICAvLyB3ZSBzZXQgaXQgdG8gLTE4OCwgdGhlICs9IDE4OCBpbiB0aGUgZm9yIGxvb3Agd2lsbCByZXNldCBzdGFydCB0byAwXG4gICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDB4MTE6XG4gICAgICAgICAgY2FzZSAweDFmZmY6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5rbm93blBJRCA9IHBpZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c1BhY2tldEVycm9ycysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgRm91bmQgJHt0c1BhY2tldEVycm9yc30gVFMgcGFja2V0L3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCAweDQ3YCxcbiAgICAgICk7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmlkZW9UcmFjay5wZXNEYXRhID0gdmlkZW9EYXRhO1xuICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICBpZDNUcmFjay5wZXNEYXRhID0gaWQzRGF0YTtcblxuICAgIGNvbnN0IGRlbXV4UmVzdWx0OiBEZW11eGVyUmVzdWx0ID0ge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFjayxcbiAgICB9O1xuXG4gICAgaWYgKGZsdXNoKSB7XG4gICAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVtdXhSZXN1bHQ7XG4gIH1cblxuICBwdWJsaWMgZmx1c2goKTogRGVtdXhlclJlc3VsdCB8IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIGNvbnN0IHsgcmVtYWluZGVyRGF0YSB9ID0gdGhpcztcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGxldCByZXN1bHQ6IERlbXV4ZXJSZXN1bHQ7XG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZGVtdXgocmVtYWluZGVyRGF0YSwgLTEsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB2aWRlb1RyYWNrOiB0aGlzLl92aWRlb1RyYWNrIGFzIERlbXV4ZWRWaWRlb1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrIGFzIERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2sgYXMgRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2sgYXMgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHJlc3VsdCk7XG4gICAgaWYgKHRoaXMuc2FtcGxlQWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHJlc3VsdCwgdGhpcy5zYW1wbGVBZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0UmVtYWluaW5nU2FtcGxlcyhkZW11eFJlc3VsdDogRGVtdXhlclJlc3VsdCkge1xuICAgIGNvbnN0IHsgYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjayB9ID0gZGVtdXhSZXN1bHQ7XG4gICAgY29uc3QgdmlkZW9EYXRhID0gdmlkZW9UcmFjay5wZXNEYXRhO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IGF1ZGlvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICAvLyB0cnkgdG8gcGFyc2UgbGFzdCBQRVMgcGFja2V0c1xuICAgIGxldCBwZXM6IFBFUyB8IG51bGw7XG4gICAgaWYgKHZpZGVvRGF0YSAmJiAocGVzID0gcGFyc2VQRVModmlkZW9EYXRhKSkpIHtcbiAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VBVkNQRVMoXG4gICAgICAgIHZpZGVvVHJhY2sgYXMgRGVtdXhlZFZpZGVvVHJhY2ssXG4gICAgICAgIHRleHRUcmFjayBhcyBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICAgICAgcGVzLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLl9kdXJhdGlvbixcbiAgICAgICk7XG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSB2aWRlb0RhdGE7XG4gICAgfVxuXG4gICAgaWYgKGF1ZGlvRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoYXVkaW9EYXRhKSkpIHtcbiAgICAgIHN3aXRjaCAoYXVkaW9UcmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICB0aGlzLnBhcnNlQUFDUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgdGhpcy5wYXJzZU1QRUdQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICBpZiAoX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfXykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGE/LnNpemUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAnbGFzdCBBQUMgUEVTIHBhY2tldCB0cnVuY2F0ZWQsbWlnaHQgb3ZlcmxhcCBiZXR3ZWVuIGZyYWdtZW50cycsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cblxuICAgIGlmIChpZDNEYXRhICYmIChwZXMgPSBwYXJzZVBFUyhpZDNEYXRhKSkpIHtcbiAgICAgIHRoaXMucGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcyk7XG4gICAgICBpZDNUcmFjay5wZXNEYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWl0aGVyIGlkM0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IGlkM0RhdGE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlbXV4U2FtcGxlQWVzKFxuICAgIGRhdGE6IFVpbnQ4QXJyYXksXG4gICAga2V5RGF0YTogS2V5RGF0YSxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICk6IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIGNvbnN0IGRlbXV4UmVzdWx0ID0gdGhpcy5kZW11eChcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgdHJ1ZSxcbiAgICAgICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSxcbiAgICApO1xuICAgIGNvbnN0IHNhbXBsZUFlcyA9ICh0aGlzLnNhbXBsZUFlcyA9IG5ldyBTYW1wbGVBZXNEZWNyeXB0ZXIoXG4gICAgICB0aGlzLm9ic2VydmVyLFxuICAgICAgdGhpcy5jb25maWcsXG4gICAgICBrZXlEYXRhLFxuICAgICkpO1xuICAgIHJldHVybiB0aGlzLmRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcyk7XG4gIH1cblxuICBwcml2YXRlIGRlY3J5cHQoXG4gICAgZGVtdXhSZXN1bHQ6IERlbXV4ZXJSZXN1bHQsXG4gICAgc2FtcGxlQWVzOiBTYW1wbGVBZXNEZWNyeXB0ZXIsXG4gICk6IFByb21pc2U8RGVtdXhlclJlc3VsdD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgeyBhdWRpb1RyYWNrLCB2aWRlb1RyYWNrIH0gPSBkZW11eFJlc3VsdDtcbiAgICAgIGlmIChhdWRpb1RyYWNrLnNhbXBsZXMgJiYgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QWFjU2FtcGxlcyhhdWRpb1RyYWNrLnNhbXBsZXMsIDAsICgpID0+IHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZGVtdXhSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhY2suc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVBZXMuZGVjcnlwdEF2Y1NhbXBsZXModmlkZW9UcmFjay5zYW1wbGVzLCAwLCAwLCAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZUFBQ1BFUyh0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssIHBlczogUEVTKSB7XG4gICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICBjb25zdCBhYWNPdmVyRmxvdyA9IHRoaXMuYWFjT3ZlckZsb3c7XG4gICAgbGV0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgICAgY29uc3QgZnJhbWVNaXNzaW5nQnl0ZXMgPSBhYWNPdmVyRmxvdy5taXNzaW5nO1xuICAgICAgY29uc3Qgc2FtcGxlTGVuZ3RoID0gYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIC8vIGxvZ2dlci5sb2coYEFBQzogYXBwZW5kIG92ZXJmbG93aW5nICR7c2FtcGxlTGVuZ3RofSBieXRlcyB0byBiZWdpbm5pbmcgb2YgbmV3IFBFU2ApO1xuICAgICAgaWYgKGZyYW1lTWlzc2luZ0J5dGVzID09PSAtMSkge1xuICAgICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheShhYWNPdmVyRmxvdy5zYW1wbGUudW5pdCwgZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmcmFtZU92ZXJmbG93Qnl0ZXMgPSBzYW1wbGVMZW5ndGggLSBmcmFtZU1pc3NpbmdCeXRlcztcbiAgICAgICAgYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQuc2V0KFxuICAgICAgICAgIGRhdGEuc3ViYXJyYXkoMCwgZnJhbWVNaXNzaW5nQnl0ZXMpLFxuICAgICAgICAgIGZyYW1lT3ZlcmZsb3dCeXRlcyxcbiAgICAgICAgKTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY092ZXJGbG93LnNhbXBsZSk7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBsZXQgb2Zmc2V0OiBudW1iZXI7XG4gICAgbGV0IGxlbjogbnVtYmVyO1xuICAgIGZvciAob2Zmc2V0ID0gc3RhcnRPZmZzZXQsIGxlbiA9IGRhdGEubGVuZ3RoOyBvZmZzZXQgPCBsZW4gLSAxOyBvZmZzZXQrKykge1xuICAgICAgaWYgKEFEVFMuaXNIZWFkZXIoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgQURUUyBoZWFkZXIgZG9lcyBub3Qgc3RhcnQgc3RyYWlnaHQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGF5bG9hZCwgcmFpc2UgYW4gZXJyb3JcbiAgICBpZiAob2Zmc2V0ICE9PSBzdGFydE9mZnNldCkge1xuICAgICAgbGV0IHJlYXNvbjogc3RyaW5nO1xuICAgICAgY29uc3QgcmVjb3ZlcmFibGUgPSBvZmZzZXQgPCBsZW4gLSAxO1xuICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdObyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICBsb2dnZXIud2FybihgcGFyc2luZyBlcnJvcjogJHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBsZXZlbFJldHJ5OiByZWNvdmVyYWJsZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZWNvdmVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgQURUUy5pbml0VHJhY2tDb25maWcoXG4gICAgICB0cmFjayxcbiAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICBkYXRhLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5hdWRpb0NvZGVjIGFzIHN0cmluZyxcbiAgICApO1xuXG4gICAgbGV0IHB0czogbnVtYmVyO1xuICAgIGlmIChwZXMucHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHB0cyA9IHBlcy5wdHM7XG4gICAgfSBlbHNlIGlmIChhYWNPdmVyRmxvdykge1xuICAgICAgLy8gaWYgbGFzdCBBQUMgZnJhbWUgaXMgb3ZlcmZsb3dpbmcsIHdlIHNob3VsZCBlbnN1cmUgdGltZXN0YW1wcyBhcmUgY29udGlndW91czpcbiAgICAgIC8vIGZpcnN0IHNhbXBsZSBQVFMgc2hvdWxkIGJlIGVxdWFsIHRvIGxhc3Qgc2FtcGxlIFBUUyArIGZyYW1lRHVyYXRpb25cbiAgICAgIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBBRFRTLmdldEZyYW1lRHVyYXRpb24odHJhY2suc2FtcGxlcmF0ZSBhcyBudW1iZXIpO1xuICAgICAgcHRzID0gYWFjT3ZlckZsb3cuc2FtcGxlLnB0cyArIGZyYW1lRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogQUFDIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNjYW4gZm9yIGFhYyBzYW1wbGVzXG4gICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgIGxldCBmcmFtZTtcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICBmcmFtZSA9IEFEVFMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KTtcbiAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICBpZiAoIWZyYW1lLm1pc3NpbmcpIHtcbiAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuIC0gMTsgb2Zmc2V0KyspIHtcbiAgICAgICAgICBpZiAoQURUUy5pc0hlYWRlcihkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBmcmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZU1QRUdQRVModHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLCBwZXM6IFBFUykge1xuICAgIGNvbnN0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogTVBFRyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoTXBlZ0F1ZGlvLmlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBNcGVnQXVkaW8uYXBwZW5kRnJhbWUoXG4gICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgcHRzLFxuICAgICAgICAgIGZyYW1lSW5kZXgsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBhcnNlQUMzUEVTKHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjaywgcGVzOiBQRVMpIHtcbiAgICBpZiAoX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfXykge1xuICAgICAgY29uc3QgZGF0YSA9IHBlcy5kYXRhO1xuICAgICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICAgIGlmIChwdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IEFDMyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIGxldCBwYXJzZWQ7XG5cbiAgICAgIHdoaWxlIChcbiAgICAgICAgb2Zmc2V0IDwgbGVuZ3RoICYmXG4gICAgICAgIChwYXJzZWQgPSBBQzMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KyspKSA+IDBcbiAgICAgICkge1xuICAgICAgICBvZmZzZXQgKz0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VJRDNQRVMoaWQzVHJhY2s6IERlbXV4ZWRNZXRhZGF0YVRyYWNrLCBwZXM6IFBFUykge1xuICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogSUQzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZDNTYW1wbGUgPSBPYmplY3QuYXNzaWduKHt9LCBwZXMgYXMgUmVxdWlyZWQ8UEVTPiwge1xuICAgICAgdHlwZTogdGhpcy5fdmlkZW9UcmFjayA/IE1ldGFkYXRhU2NoZW1hLmVtc2cgOiBNZXRhZGF0YVNjaGVtYS5hdWRpb0lkMyxcbiAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgfSk7XG4gICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKGlkM1NhbXBsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQSUQoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBwaWQgaXMgYSAxMy1iaXQgZmllbGQgc3RhcnRpbmcgYXQgdGhlIGxhc3QgYml0IG9mIFRTWzFdXG4gIHJldHVybiAoKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDFmKSA8PCA4KSArIGRhdGFbb2Zmc2V0ICsgMl07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUEFUKGRhdGE6IFVpbnQ4QXJyYXksIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gc2tpcCB0aGUgUFNJIGhlYWRlciBhbmQgcGFyc2UgdGhlIGZpcnN0IFBNVCBlbnRyeVxuICByZXR1cm4gKChkYXRhW29mZnNldCArIDEwXSAmIDB4MWYpIDw8IDgpIHwgZGF0YVtvZmZzZXQgKyAxMV07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUE1UKFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbiAgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZCxcbiAgaXNTYW1wbGVBZXM6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF1ZGlvUGlkOiAtMSxcbiAgICB2aWRlb1BpZDogLTEsXG4gICAgaWQzUGlkOiAtMSxcbiAgICBzZWdtZW50VmlkZW9Db2RlYzogJ2F2YycsXG4gICAgc2VnbWVudEF1ZGlvQ29kZWM6ICdhYWMnLFxuICB9O1xuICBjb25zdCBzZWN0aW9uTGVuZ3RoID0gKChkYXRhW29mZnNldCArIDFdICYgMHgwZikgPDwgOCkgfCBkYXRhW29mZnNldCArIDJdO1xuICBjb25zdCB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gIGNvbnN0IHByb2dyYW1JbmZvTGVuZ3RoID1cbiAgICAoKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCkgfCBkYXRhW29mZnNldCArIDExXTtcbiAgLy8gYWR2YW5jZSB0aGUgb2Zmc2V0IHRvIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgbWFwcGluZyB0YWJsZVxuICBvZmZzZXQgKz0gMTIgKyBwcm9ncmFtSW5mb0xlbmd0aDtcbiAgd2hpbGUgKG9mZnNldCA8IHRhYmxlRW5kKSB7XG4gICAgY29uc3QgcGlkID0gcGFyc2VQSUQoZGF0YSwgb2Zmc2V0KTtcbiAgICBjb25zdCBlc0luZm9MZW5ndGggPSAoKGRhdGFbb2Zmc2V0ICsgM10gJiAweDBmKSA8PCA4KSB8IGRhdGFbb2Zmc2V0ICsgNF07XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjogLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FEVFMgQUFDJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgwZjogLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBQYWNrZXRpemVkIG1ldGFkYXRhIChJRDMpXG4gICAgICBjYXNlIDB4MTU6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0lEMyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmlkM1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuaWQzUGlkID0gcGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHhkYjogLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0guMjY0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgxYjogLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LnZpZGVvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudFZpZGVvQ29kZWMgPSAnYXZjJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBJU08vSUVDIDExMTcyLTMgKE1QRUctMSBhdWRpbylcbiAgICAgIC8vIG9yIElTTy9JRUMgMTM4MTgtMyAoTVBFRy0yIGhhbHZlZCBzYW1wbGUgcmF0ZSBhdWRpbylcbiAgICAgIGNhc2UgMHgwMzpcbiAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgLy8gbG9nZ2VyLmxvZygnTVBFRyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAoIXR5cGVTdXBwb3J0ZWQubXBlZyAmJiAhdHlwZVN1cHBvcnRlZC5tcDMpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKCdNUEVHIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ21wMyc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHhjMTogLy8gU0FNUExFLUFFUyBBQzNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FDLTMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDgxOlxuICAgICAgICBpZiAoX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfXykge1xuICAgICAgICAgIGlmICghdHlwZVN1cHBvcnRlZC5hYzMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coJ0FDLTMgYXVkaW8gZm91bmQsIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuYXVkaW9QaWQgPSBwaWQ7XG4gICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0FDLTMgaW4gTTJUUyBzdXBwb3J0IG5vdCBpbmNsdWRlZCBpbiBidWlsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MDY6XG4gICAgICAgIC8vIHN0cmVhbV90eXBlIDYgY2FuIG1lYW4gYSBsb3Qgb2YgZGlmZmVyZW50IHRoaW5ncyBpbiBjYXNlIG9mIERWQi5cbiAgICAgICAgLy8gV2UgbmVlZCB0byBsb29rIGF0IHRoZSBkZXNjcmlwdG9ycy4gUmlnaHQgbm93LCB3ZSdyZSBvbmx5IGludGVyZXN0ZWRcbiAgICAgICAgLy8gaW4gQUMtMyBhdWRpbywgc28gd2UgZG8gdGhlIGRlc2NyaXB0b3IgcGFyc2luZyBvbmx5IHdoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBhbiBhdWRpbyBQSUQgeWV0LlxuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSAmJiBlc0luZm9MZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHBhcnNlUG9zID0gb2Zmc2V0ICsgNTtcbiAgICAgICAgICBsZXQgcmVtYWluaW5nID0gZXNJbmZvTGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKHJlbWFpbmluZyA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3JJZCA9IGRhdGFbcGFyc2VQb3NdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3JJZCkge1xuICAgICAgICAgICAgICBjYXNlIDB4NmE6IC8vIERWQiBEZXNjcmlwdG9yIGZvciBBQy0zXG4gICAgICAgICAgICAgICAgaWYgKF9fVVNFX00yVFNfQURWQU5DRURfQ09ERUNTX18pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlU3VwcG9ydGVkLmFjMyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgICAgICAgICAgICdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlciBmb3Igbm93JyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ2FjMyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBQy0zIGluIE0yVFMgc3VwcG9ydCBub3QgaW5jbHVkZWQgaW4gYnVpbGQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3JMZW4gPSBkYXRhW3BhcnNlUG9zICsgMV0gKyAyO1xuICAgICAgICAgICAgcGFyc2VQb3MgKz0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSBkZXNjcmlwdG9yTGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweGMyOiAvLyBTQU1QTEUtQUVTIEVDM1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAweDg3OlxuICAgICAgICBsb2dnZXIud2FybignVW5zdXBwb3J0ZWQgRUMtMyBpbiBNMlRTIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDI0OlxuICAgICAgICBsb2dnZXIud2FybignVW5zdXBwb3J0ZWQgSEVWQyBpbiBNMlRTIGZvdW5kJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCd1bmtub3duIHN0cmVhbSB0eXBlOicgKyBkYXRhW29mZnNldF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gbW92ZSB0byB0aGUgbmV4dCB0YWJsZSBlbnRyeVxuICAgIC8vIHNraXAgcGFzdCB0aGUgZWxlbWVudGFyeSBzdHJlYW0gZGVzY3JpcHRvcnMsIGlmIHByZXNlbnRcbiAgICBvZmZzZXQgKz0gZXNJbmZvTGVuZ3RoICsgNTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBsb2dFbmNyeXB0ZWRTYW1wbGVzRm91bmRJblVuZW5jcnlwdGVkU3RyZWFtKHR5cGU6IHN0cmluZykge1xuICBsb2dnZXIubG9nKGAke3R5cGV9IHdpdGggQUVTLTEyOC1DQkMgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1gKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQRVMoc3RyZWFtOiBFbGVtZW50YXJ5U3RyZWFtRGF0YSk6IFBFUyB8IG51bGwge1xuICBsZXQgaSA9IDA7XG4gIGxldCBmcmFnOiBVaW50OEFycmF5O1xuICBsZXQgcGVzTGVuOiBudW1iZXI7XG4gIGxldCBwZXNIZHJMZW46IG51bWJlcjtcbiAgbGV0IHBlc1B0czogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgcGVzRHRzOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGRhdGEgPSBzdHJlYW0uZGF0YTtcbiAgLy8gc2FmZXR5IGNoZWNrXG4gIGlmICghc3RyZWFtIHx8IHN0cmVhbS5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB3ZSBtaWdodCBuZWVkIHVwIHRvIDE5IGJ5dGVzIHRvIHJlYWQgUEVTIGhlYWRlclxuICAvLyBpZiBmaXJzdCBjaHVuayBvZiBkYXRhIGlzIGxlc3MgdGhhbiAxOSBieXRlcywgbGV0J3MgbWVyZ2UgaXQgd2l0aCBmb2xsb3dpbmcgb25lcyB1bnRpbCB3ZSBnZXQgMTkgYnl0ZXNcbiAgLy8gdXN1YWxseSBvbmx5IG9uZSBtZXJnZSBpcyBuZWVkZWQgKGFuZCB0aGlzIGlzIHJhcmUgLi4uKVxuICB3aGlsZSAoZGF0YVswXS5sZW5ndGggPCAxOSAmJiBkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICBkYXRhWzBdID0gYXBwZW5kVWludDhBcnJheShkYXRhWzBdLCBkYXRhWzFdKTtcbiAgICBkYXRhLnNwbGljZSgxLCAxKTtcbiAgfVxuICAvLyByZXRyaWV2ZSBQVFMvRFRTIGZyb20gZmlyc3QgZnJhZ21lbnRcbiAgZnJhZyA9IGRhdGFbMF07XG4gIGNvbnN0IHBlc1ByZWZpeCA9IChmcmFnWzBdIDw8IDE2KSArIChmcmFnWzFdIDw8IDgpICsgZnJhZ1syXTtcbiAgaWYgKHBlc1ByZWZpeCA9PT0gMSkge1xuICAgIHBlc0xlbiA9IChmcmFnWzRdIDw8IDgpICsgZnJhZ1s1XTtcbiAgICAvLyBpZiBQRVMgcGFyc2VkIGxlbmd0aCBpcyBub3QgemVybyBhbmQgZ3JlYXRlciB0aGFuIHRvdGFsIHJlY2VpdmVkIGxlbmd0aCwgc3RvcCBwYXJzaW5nLiBQRVMgbWlnaHQgYmUgdHJ1bmNhdGVkXG4gICAgLy8gbWludXMgNiA6IFBFUyBoZWFkZXIgc2l6ZVxuICAgIGlmIChwZXNMZW4gJiYgcGVzTGVuID4gc3RyZWFtLnNpemUgLSA2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwZXNGbGFncyA9IGZyYWdbN107XG4gICAgaWYgKHBlc0ZsYWdzICYgMHhjMCkge1xuICAgICAgLyogUEVTIGhlYWRlciBkZXNjcmliZWQgaGVyZSA6IGh0dHA6Ly9kdmQuc291cmNlZm9yZ2UubmV0L2R2ZGluZm8vcGVzLWhkci5odG1sXG4gICAgICAgICAgYXMgUFRTIC8gRFRTIGlzIDMzIGJpdCB3ZSBjYW5ub3QgdXNlIGJpdHdpc2Ugb3BlcmF0b3IgaW4gSlMsXG4gICAgICAgICAgYXMgQml0d2lzZSBvcGVyYXRvcnMgdHJlYXQgdGhlaXIgb3BlcmFuZHMgYXMgYSBzZXF1ZW5jZSBvZiAzMiBiaXRzICovXG4gICAgICBwZXNQdHMgPVxuICAgICAgICAoZnJhZ1s5XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxMF0gJiAweGZmKSAqIDQxOTQzMDQgKyAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgKyAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzEyXSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzEzXSAmIDB4ZmUpIC8gMjtcblxuICAgICAgaWYgKHBlc0ZsYWdzICYgMHg0MCkge1xuICAgICAgICBwZXNEdHMgPVxuICAgICAgICAgIChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgICAgICAgIChmcmFnWzE1XSAmIDB4ZmYpICogNDE5NDMwNCArIC8vIDEgPDwgMjJcbiAgICAgICAgICAoZnJhZ1sxNl0gJiAweGZlKSAqIDE2Mzg0ICsgLy8gMSA8PCAxNFxuICAgICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgICAgICAgKGZyYWdbMThdICYgMHhmZSkgLyAyO1xuXG4gICAgICAgIGlmIChwZXNQdHMgLSBwZXNEdHMgPiA2MCAqIDkwMDAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAocGVzUHRzIC0gcGVzRHRzKSAvIDkwMDAwLFxuICAgICAgICAgICAgKX1zIGRlbHRhIGJldHdlZW4gUFRTIGFuZCBEVFMsIGFsaWduIHRoZW1gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcGVzUHRzID0gcGVzRHRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXNEdHMgPSBwZXNQdHM7XG4gICAgICB9XG4gICAgfVxuICAgIHBlc0hkckxlbiA9IGZyYWdbOF07XG4gICAgLy8gOSBieXRlcyA6IDYgYnl0ZXMgZm9yIFBFUyBoZWFkZXIgKyAzIGJ5dGVzIGZvciBQRVMgZXh0ZW5zaW9uXG4gICAgbGV0IHBheWxvYWRTdGFydE9mZnNldCA9IHBlc0hkckxlbiArIDk7XG4gICAgaWYgKHN0cmVhbS5zaXplIDw9IHBheWxvYWRTdGFydE9mZnNldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0cmVhbS5zaXplIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAvLyByZWFzc2VtYmxlIFBFUyBwYWNrZXRcbiAgICBjb25zdCBwZXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc3RyZWFtLnNpemUpO1xuICAgIGZvciAobGV0IGogPSAwLCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7IGogPCBkYXRhTGVuOyBqKyspIHtcbiAgICAgIGZyYWcgPSBkYXRhW2pdO1xuICAgICAgbGV0IGxlbiA9IGZyYWcuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgICAgaWYgKHBheWxvYWRTdGFydE9mZnNldCA+IGxlbikge1xuICAgICAgICAgIC8vIHRyaW0gZnVsbCBmcmFnIGlmIFBFUyBoZWFkZXIgYmlnZ2VyIHRoYW4gZnJhZ1xuICAgICAgICAgIHBheWxvYWRTdGFydE9mZnNldCAtPSBsZW47XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdHJpbSBwYXJ0aWFsIGZyYWcgaWYgUEVTIGhlYWRlciBzbWFsbGVyIHRoYW4gZnJhZ1xuICAgICAgICAgIGZyYWcgPSBmcmFnLnN1YmFycmF5KHBheWxvYWRTdGFydE9mZnNldCk7XG4gICAgICAgICAgbGVuIC09IHBheWxvYWRTdGFydE9mZnNldDtcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZXNEYXRhLnNldChmcmFnLCBpKTtcbiAgICAgIGkgKz0gbGVuO1xuICAgIH1cbiAgICBpZiAocGVzTGVuKSB7XG4gICAgICAvLyBwYXlsb2FkIHNpemUgOiByZW1vdmUgUEVTIGhlYWRlciArIFBFUyBleHRlbnNpb25cbiAgICAgIHBlc0xlbiAtPSBwZXNIZHJMZW4gKyAzO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBwZXNEYXRhLCBwdHM6IHBlc1B0cywgZHRzOiBwZXNEdHMsIGxlbjogcGVzTGVuIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRTRGVtdXhlcjtcbiIsIi8qKlxuICogTVAzIGRlbXV4ZXJcbiAqL1xuaW1wb3J0IEJhc2VBdWRpb0RlbXV4ZXIgZnJvbSAnLi9iYXNlLWF1ZGlvLWRlbXV4ZXInO1xuaW1wb3J0IHsgZ2V0SUQzRGF0YSwgZ2V0VGltZVN0YW1wIH0gZnJvbSAnLi4vaWQzJztcbmltcG9ydCB7IGdldEF1ZGlvQlNJRCB9IGZyb20gJy4vZG9sYnknO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCAqIGFzIE1wZWdBdWRpbyBmcm9tICcuL21wZWdhdWRpbyc7XG5cbmNsYXNzIE1QM0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudDogVWludDhBcnJheSB8IHVuZGVmaW5lZCxcbiAgICBhdWRpb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgdmlkZW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHRyYWNrRHVyYXRpb246IG51bWJlcixcbiAgKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wZWcnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnbXAzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHByb2JlKGRhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBkYXRhIGNvbnRhaW5zIElEMyB0aW1lc3RhbXAgYW5kIE1QRUcgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgTVBFRyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTFYIFhZWlggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxIGFuZCBZIG9yIFogc2hvdWxkIGJlIDFcbiAgICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAgIC8vIE1vcmUgaW5mbyBodHRwOi8vd3d3Lm1wMy10ZWNoLm9yZy9wcm9ncmFtbWVyL2ZyYW1lX2hlYWRlci5odG1sXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IGlkM0RhdGE/Lmxlbmd0aCB8fCAwO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGFjLTN8ZWMtMyBzeW5jIGJ5dGVzIGFuZCByZXR1cm4gZmFsc2UgaWYgcHJlc2VudFxuICAgIGlmIChcbiAgICAgIGlkM0RhdGEgJiZcbiAgICAgIGRhdGFbb2Zmc2V0XSA9PT0gMHgwYiAmJlxuICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJlxuICAgICAgZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyBvciBlYy0zIChub3QgbXAzKVxuICAgICAgZ2V0QXVkaW9CU0lEKGRhdGEsIG9mZnNldCkgPD0gMTZcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKE1wZWdBdWRpby5wcm9iZShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ01QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICEnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBNcGVnQXVkaW8uY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuXG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBNcGVnQXVkaW8uYXBwZW5kRnJhbWUoXG4gICAgICB0cmFjayxcbiAgICAgIGRhdGEsXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLmJhc2VQVFMsXG4gICAgICB0aGlzLmZyYW1lSW5kZXgsXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNUDNEZW11eGVyO1xuIiwiLyoqXG4gKiAgQUFDIGhlbHBlclxuICovXG5cbmNsYXNzIEFBQyB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShcbiAgICBjb2RlYz86IHN0cmluZyxcbiAgICBjaGFubmVsQ291bnQ/OiBudW1iZXIsXG4gICk6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ21wNGEuNDAuMic6XG4gICAgICAgIGlmIChjaGFubmVsQ291bnQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjMsIDB4ODBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgyMSwgMHgwMCwgMHg0OSwgMHg5MCwgMHgwMiwgMHgxOSwgMHgwMCwgMHgyMywgMHg4MCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCxcbiAgICAgICAgICAgIDB4MDAsIDB4OGUsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MDAsIDB4YzgsIDB4MDAsIDB4ODAsIDB4MjAsIDB4ODQsIDB4MDEsIDB4MjYsIDB4NDAsIDB4MDgsIDB4NjQsXG4gICAgICAgICAgICAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4LFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LFxuICAgICAgICAgICAgMHgwMCwgMHg4MiwgMHgzMCwgMHgwNCwgMHg5OSwgMHgwMCwgMHgyMSwgMHg5MCwgMHgwMiwgMHgzOCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgwMCwgMHhjOCwgMHgwMCwgMHg4MCwgMHgyMCwgMHg4NCwgMHgwMSwgMHgyNiwgMHg0MCwgMHgwOCwgMHg2NCxcbiAgICAgICAgICAgIDB4MDAsIDB4ODIsIDB4MzAsIDB4MDQsIDB4OTksIDB4MDAsIDB4MjEsIDB4OTAsIDB4MDIsIDB4MDAsIDB4YjIsXG4gICAgICAgICAgICAweDAwLCAweDIwLCAweDA4LCAweGUwLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDB4MSwgMHg0MCwgMHgyMiwgMHg4MCwgMHhhMywgMHg0ZSwgMHhlNiwgMHg4MCwgMHhiYSwgMHg4LCAweDAsIDB4MCxcbiAgICAgICAgICAgIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMikge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MDpkPTAuMDVcIiAtYzphIGxpYmZka19hYWMgLXByb2ZpbGU6YSBhYWNfaGVfdjIgLWI6YSA0ayBvdXRwdXQuYWFjICYmIGhleGR1bXAgLXYgLWUgJzE2LzEgXCIweCV4LFwiIFwiXFxuXCInIC12IG91dHB1dC5hYWNcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgMHgxLCAweDQwLCAweDIyLCAweDgwLCAweGEzLCAweDVlLCAweGU2LCAweDgwLCAweGJhLCAweDgsIDB4MCwgMHgwLFxuICAgICAgICAgICAgMHgwLCAweDAsIDB4OTUsIDB4MCwgMHg2LCAweGYxLCAweGExLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVlLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWxDb3VudCA9PT0gMykge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTB8MHwwOmQ9MC4wNVwiIC1jOmEgbGliZmRrX2FhYyAtcHJvZmlsZTphIGFhY19oZV92MiAtYjphIDRrIG91dHB1dC5hYWMgJiYgaGV4ZHVtcCAtdiAtZSAnMTYvMSBcIjB4JXgsXCIgXCJcXG5cIicgLXYgb3V0cHV0LmFhY1xuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsXG4gICAgICAgICAgICAweDAsIDB4MCwgMHg5NSwgMHgwLCAweDYsIDB4ZjEsIDB4YTEsIDB4YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsXG4gICAgICAgICAgICAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLFxuICAgICAgICAgICAgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSwgMHg1YSxcbiAgICAgICAgICAgIDB4NWEsIDB4NWUsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQUFDO1xuIiwiLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cblxuaW1wb3J0IHsgYXBwZW5kVWludDhBcnJheSB9IGZyb20gJy4uL3V0aWxzL21wNC10b29scyc7XG5cbnR5cGUgSGRsclR5cGVzID0ge1xuICB2aWRlbzogVWludDhBcnJheTtcbiAgYXVkaW86IFVpbnQ4QXJyYXk7XG59O1xuXG5jb25zdCBVSU5UMzJfTUFYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuY2xhc3MgTVA0IHtcbiAgcHVibGljIHN0YXRpYyB0eXBlczogUmVjb3JkPHN0cmluZywgbnVtYmVyW10+O1xuICBwcml2YXRlIHN0YXRpYyBIRExSX1RZUEVTOiBIZGxyVHlwZXM7XG4gIHByaXZhdGUgc3RhdGljIFNUVFM6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU0M6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUQ086IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU1o6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFZNSEQ6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNNSEQ6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIFNUU0Q6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIEZUWVA6IFVpbnQ4QXJyYXk7XG4gIHByaXZhdGUgc3RhdGljIERJTkY6IFVpbnQ4QXJyYXk7XG5cbiAgc3RhdGljIGluaXQoKSB7XG4gICAgTVA0LnR5cGVzID0ge1xuICAgICAgYXZjMTogW10sIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBkYWMzOiBbXSxcbiAgICAgICdhYy0zJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXSxcbiAgICB9O1xuXG4gICAgbGV0IGk6IHN0cmluZztcbiAgICBmb3IgKGkgaW4gTVA0LnR5cGVzKSB7XG4gICAgICBpZiAoTVA0LnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIE1QNC50eXBlc1tpXSA9IFtcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMCksXG4gICAgICAgICAgaS5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgIGkuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICBpLmNoYXJDb2RlQXQoMyksXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvbiAwXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgMHg3NixcbiAgICAgIDB4NjksXG4gICAgICAweDY0LFxuICAgICAgMHg2NSwgLy8gaGFuZGxlcl90eXBlOiAndmlkZSdcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4NTYsXG4gICAgICAweDY5LFxuICAgICAgMHg2NCxcbiAgICAgIDB4NjUsXG4gICAgICAweDZmLFxuICAgICAgMHg0OCxcbiAgICAgIDB4NjEsXG4gICAgICAweDZlLFxuICAgICAgMHg2NCxcbiAgICAgIDB4NmMsXG4gICAgICAweDY1LFxuICAgICAgMHg3MixcbiAgICAgIDB4MDAsIC8vIG5hbWU6ICdWaWRlb0hhbmRsZXInXG4gICAgXSk7XG5cbiAgICBjb25zdCBhdWRpb0hkbHIgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweDczLFxuICAgICAgMHg2ZixcbiAgICAgIDB4NzUsXG4gICAgICAweDZlLCAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHg1MyxcbiAgICAgIDB4NmYsXG4gICAgICAweDc1LFxuICAgICAgMHg2ZSxcbiAgICAgIDB4NjQsXG4gICAgICAweDQ4LFxuICAgICAgMHg2MSxcbiAgICAgIDB4NmUsXG4gICAgICAweDY0LFxuICAgICAgMHg2YyxcbiAgICAgIDB4NjUsXG4gICAgICAweDcyLFxuICAgICAgMHgwMCwgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcblxuICAgIE1QNC5IRExSX1RZUEVTID0ge1xuICAgICAgdmlkZW86IHZpZGVvSGRscixcbiAgICAgIGF1ZGlvOiBhdWRpb0hkbHIsXG4gICAgfTtcblxuICAgIGNvbnN0IGRyZWYgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsIC8vIGVudHJ5X2NvdW50XG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDBjLCAvLyBlbnRyeV9zaXplXG4gICAgICAweDc1LFxuICAgICAgMHg3MixcbiAgICAgIDB4NmMsXG4gICAgICAweDIwLCAvLyAndXJsJyB0eXBlXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSwgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcblxuICAgIGNvbnN0IHN0Y28gPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBlbnRyeV9jb3VudFxuICAgIF0pO1xuXG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcblxuICAgIE1QNC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gc2FtcGxlX3NpemVcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pO1xuICAgIE1QNC5WTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMHgwMCwgLy8gdmVyc2lvblxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGdyYXBoaWNzbW9kZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBvcGNvbG9yXG4gICAgXSk7XG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAwLCAvLyB2ZXJzaW9uXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gYmFsYW5jZVxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgXSk7XG5cbiAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMSxcbiAgICBdKTsgLy8gZW50cnlfY291bnRcblxuICAgIGNvbnN0IG1ham9yQnJhbmQgPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSk7IC8vIGlzb21cbiAgICBjb25zdCBhdmMxQnJhbmQgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSk7IC8vIGF2YzFcbiAgICBjb25zdCBtaW5vclZlcnNpb24gPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuXG4gICAgTVA0LkZUWVAgPSBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLmZ0eXAsXG4gICAgICBtYWpvckJyYW5kLFxuICAgICAgbWlub3JWZXJzaW9uLFxuICAgICAgbWFqb3JCcmFuZCxcbiAgICAgIGF2YzFCcmFuZCxcbiAgICApO1xuICAgIE1QNC5ESU5GID0gTVA0LmJveChNUDQudHlwZXMuZGluZiwgTVA0LmJveChNUDQudHlwZXMuZHJlZiwgZHJlZikpO1xuICB9XG5cbiAgc3RhdGljIGJveCh0eXBlLCAuLi5wYXlsb2FkOiBVaW50OEFycmF5W10pIHtcbiAgICBsZXQgc2l6ZSA9IDg7XG4gICAgbGV0IGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBpO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgcmVzdWx0WzBdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXN1bHRbMV0gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIHJlc3VsdFsyXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgICByZXN1bHQuc2V0KHR5cGUsIDQpO1xuICAgIC8vIGNvcHkgdGhlIHBheWxvYWQgaW50byB0aGUgcmVzdWx0XG4gICAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gY29weSBwYXlsb2FkW2ldIGFycmF5IEAgb2Zmc2V0IHNpemVcbiAgICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBoZGxyKHR5cGUpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuaGRsciwgTVA0LkhETFJfVFlQRVNbdHlwZV0pO1xuICB9XG5cbiAgc3RhdGljIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubWRoZCxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMSwgLy8gdmVyc2lvbiAxXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGZsYWdzXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDIsIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICAgKHRpbWVzY2FsZSA+PiAyNCkgJiAweGZmLFxuICAgICAgICAodGltZXNjYWxlID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweGZmLFxuICAgICAgICB0aW1lc2NhbGUgJiAweGZmLCAvLyB0aW1lc2NhbGVcbiAgICAgICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgICAodXBwZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAgIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgICAweDU1LFxuICAgICAgICAweGM0LCAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgXSksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtZGlhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubWRpYSxcbiAgICAgIE1QNC5tZGhkKHRyYWNrLnRpbWVzY2FsZSwgdHJhY2suZHVyYXRpb24pLFxuICAgICAgTVA0LmhkbHIodHJhY2sudHlwZSksXG4gICAgICBNUDQubWluZih0cmFjayksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtZmhkKHNlcXVlbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICBNUDQudHlwZXMubWZoZCxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgICAgc2VxdWVuY2VOdW1iZXIgPj4gMjQsXG4gICAgICAgIChzZXF1ZW5jZU51bWJlciA+PiAxNikgJiAweGZmLFxuICAgICAgICAoc2VxdWVuY2VOdW1iZXIgPj4gOCkgJiAweGZmLFxuICAgICAgICBzZXF1ZW5jZU51bWJlciAmIDB4ZmYsIC8vIHNlcXVlbmNlX251bWJlclxuICAgICAgXSksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtaW5mKHRyYWNrKSB7XG4gICAgaWYgKHRyYWNrLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMubWluZixcbiAgICAgICAgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLFxuICAgICAgICBNUDQuRElORixcbiAgICAgICAgTVA0LnN0YmwodHJhY2spLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy5taW5mLFxuICAgICAgICBNUDQuYm94KE1QNC50eXBlcy52bWhkLCBNUDQuVk1IRCksXG4gICAgICAgIE1QNC5ESU5GLFxuICAgICAgICBNUDQuc3RibCh0cmFjayksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLm1vb2YsXG4gICAgICBNUDQubWZoZChzbiksXG4gICAgICBNUDQudHJhZih0cmFjaywgYmFzZU1lZGlhRGVjb2RlVGltZSksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBtb292KHRyYWNrcykge1xuICAgIGxldCBpID0gdHJhY2tzLmxlbmd0aDtcbiAgICBjb25zdCBib3hlczogVWludDhBcnJheVtdID0gW107XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmFrKHRyYWNrc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1QNC5ib3guYXBwbHkoXG4gICAgICBudWxsLFxuICAgICAgW01QNC50eXBlcy5tb292LCBNUDQubXZoZCh0cmFja3NbMF0udGltZXNjYWxlLCB0cmFja3NbMF0uZHVyYXRpb24pXVxuICAgICAgICAuY29uY2F0KGJveGVzKVxuICAgICAgICAuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXM6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJleCh0cmFja3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleCwgLi4uYm94ZXNdKTtcbiAgfVxuXG4gIHN0YXRpYyBtdmhkKHRpbWVzY2FsZSwgZHVyYXRpb24pIHtcbiAgICBkdXJhdGlvbiAqPSB0aW1lc2NhbGU7XG4gICAgY29uc3QgdXBwZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uIC8gKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgbG93ZXJXb3JkRHVyYXRpb24gPSBNYXRoLmZsb29yKGR1cmF0aW9uICUgKFVJTlQzMl9NQVggKyAxKSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAweDAxLCAvLyB2ZXJzaW9uIDFcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gZmxhZ3NcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMywgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgICh0aW1lc2NhbGUgPj4gMjQpICYgMHhmZixcbiAgICAgICh0aW1lc2NhbGUgPj4gMTYpICYgMHhmZixcbiAgICAgICh0aW1lc2NhbGUgPj4gOCkgJiAweGZmLFxuICAgICAgdGltZXNjYWxlICYgMHhmZiwgLy8gdGltZXNjYWxlXG4gICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDgpICYgMHhmZixcbiAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgIGxvd2VyV29yZER1cmF0aW9uID4+IDI0LFxuICAgICAgKGxvd2VyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gMS4wIHJhdGVcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLCAvLyAxLjAgdm9sdW1lXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDEsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDQwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLCAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHByZV9kZWZpbmVkXG4gICAgICAweGZmLFxuICAgICAgMHhmZixcbiAgICAgIDB4ZmYsXG4gICAgICAweGZmLCAvLyBuZXh0X3RyYWNrX0lEXG4gICAgXSk7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm12aGQsIGJ5dGVzKTtcbiAgfVxuXG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID1cbiAgICAgICAgKGZsYWdzLmRlcGVuZHNPbiA8PCA0KSB8XG4gICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgMikgfFxuICAgICAgICBmbGFncy5oYXNSZWR1bmRhbmN5O1xuICAgIH1cblxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cblxuICBzdGF0aWMgc3RibCh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnN0YmwsXG4gICAgICBNUDQuc3RzZCh0cmFjayksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHNjLCBNUDQuU1RTQyksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdHN6LCBNUDQuU1RTWiksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTyksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgbGV0IHNwczogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgcHBzOiBudW1iZXJbXSA9IFtdO1xuICAgIGxldCBpO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBsZW47XG4gICAgLy8gYXNzZW1ibGUgdGhlIFNQU3NcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5zcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5zcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBzcHMucHVzaCgobGVuID4+PiA4KSAmIDB4ZmYpO1xuICAgICAgc3BzLnB1c2gobGVuICYgMHhmZik7XG5cbiAgICAgIC8vIFNQU1xuICAgICAgc3BzID0gc3BzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzZW1ibGUgdGhlIFBQU3NcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2sucHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2sucHBzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcHBzLnB1c2goKGxlbiA+Pj4gOCkgJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuXG4gICAgICBwcHMgPSBwcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICBjb25zdCBhdmNjID0gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5hdmNDLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIFtcbiAgICAgICAgICAweDAxLCAvLyB2ZXJzaW9uXG4gICAgICAgICAgc3BzWzNdLCAvLyBwcm9maWxlXG4gICAgICAgICAgc3BzWzRdLCAvLyBwcm9maWxlIGNvbXBhdFxuICAgICAgICAgIHNwc1s1XSwgLy8gbGV2ZWxcbiAgICAgICAgICAweGZjIHwgMywgLy8gbGVuZ3RoU2l6ZU1pbnVzT25lLCBoYXJkLWNvZGVkIHRvIDQgYnl0ZXNcbiAgICAgICAgICAweGUwIHwgdHJhY2suc3BzLmxlbmd0aCwgLy8gM2JpdCByZXNlcnZlZCAoMTExKSArIG51bU9mU2VxdWVuY2VQYXJhbWV0ZXJTZXRzXG4gICAgICAgIF1cbiAgICAgICAgICAuY29uY2F0KHNwcylcbiAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgIHRyYWNrLnBwcy5sZW5ndGgsIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICAgICAgICBdKVxuICAgICAgICAgIC5jb25jYXQocHBzKSxcbiAgICAgICksXG4gICAgKTsgLy8gXCJQUFNcIlxuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIGNvbnN0IGhTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1swXTtcbiAgICBjb25zdCB2U3BhY2luZyA9IHRyYWNrLnBpeGVsUmF0aW9bMV07XG5cbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5hdmMxLFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBwcmVfZGVmaW5lZFxuICAgICAgICAod2lkdGggPj4gOCkgJiAweGZmLFxuICAgICAgICB3aWR0aCAmIDB4ZmYsIC8vIHdpZHRoXG4gICAgICAgIChoZWlnaHQgPj4gOCkgJiAweGZmLFxuICAgICAgICBoZWlnaHQgJiAweGZmLCAvLyBoZWlnaHRcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHg0OCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4NDgsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGZyYW1lX2NvdW50XG4gICAgICAgIDB4MTIsXG4gICAgICAgIDB4NjQsXG4gICAgICAgIDB4NjEsXG4gICAgICAgIDB4NjksXG4gICAgICAgIDB4NmMsIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgICAweDc5LFxuICAgICAgICAweDZkLFxuICAgICAgICAweDZmLFxuICAgICAgICAweDc0LFxuICAgICAgICAweDY5LFxuICAgICAgICAweDZmLFxuICAgICAgICAweDZlLFxuICAgICAgICAweDJmLFxuICAgICAgICAweDY4LFxuICAgICAgICAweDZjLFxuICAgICAgICAweDczLFxuICAgICAgICAweDJlLFxuICAgICAgICAweDZhLFxuICAgICAgICAweDczLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDE4LCAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDB4MTEsXG4gICAgICAgIDB4MTEsXG4gICAgICBdKSwgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgYXZjYyxcbiAgICAgIE1QNC5ib3goXG4gICAgICAgIE1QNC50eXBlcy5idHJ0LFxuICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDFjLFxuICAgICAgICAgIDB4OWMsXG4gICAgICAgICAgMHg4MCwgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDJkLFxuICAgICAgICAgIDB4YzYsXG4gICAgICAgICAgMHhjMCwgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgyZCxcbiAgICAgICAgICAweGM2LFxuICAgICAgICAgIDB4YzAsXG4gICAgICAgIF0pLFxuICAgICAgKSwgLy8gYXZnQml0cmF0ZVxuICAgICAgTVA0LmJveChcbiAgICAgICAgTVA0LnR5cGVzLnBhc3AsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICBoU3BhY2luZyA+PiAyNCwgLy8gaFNwYWNpbmdcbiAgICAgICAgICAoaFNwYWNpbmcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAoaFNwYWNpbmcgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIGhTcGFjaW5nICYgMHhmZixcbiAgICAgICAgICB2U3BhY2luZyA+PiAyNCwgLy8gdlNwYWNpbmdcbiAgICAgICAgICAodlNwYWNpbmcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAodlNwYWNpbmcgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHZTcGFjaW5nICYgMHhmZixcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgZXNkcyh0cmFjaykge1xuICAgIGNvbnN0IGNvbmZpZ2xlbiA9IHRyYWNrLmNvbmZpZy5sZW5ndGg7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFxuICAgICAgW1xuICAgICAgICAweDAwLCAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZmxhZ3NcblxuICAgICAgICAweDAzLCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgICAgMHgxNyArIGNvbmZpZ2xlbiwgLy8gbGVuZ3RoXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsIC8vIGVzX2lkXG4gICAgICAgIDB4MDAsIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgICAgIDB4MDQsIC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgICAgICAweDBmICsgY29uZmlnbGVuLCAvLyBsZW5ndGhcbiAgICAgICAgMHg0MCwgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgICAgICAweDE1LCAvLyBzdHJlYW1fdHlwZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBidWZmZXJfc2l6ZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBtYXhCaXRyYXRlXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGF2Z0JpdHJhdGVcblxuICAgICAgICAweDA1LCAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIF1cbiAgICAgICAgLmNvbmNhdChbY29uZmlnbGVuXSlcbiAgICAgICAgLmNvbmNhdCh0cmFjay5jb25maWcpXG4gICAgICAgIC5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSxcbiAgICApOyAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gIH1cblxuICBzdGF0aWMgYXVkaW9TdHNkKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWRcbiAgICAgIDB4MDAsXG4gICAgICAweDAxLCAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAweDAwLFxuICAgICAgdHJhY2suY2hhbm5lbENvdW50LCAvLyBjaGFubmVsY291bnRcbiAgICAgIDB4MDAsXG4gICAgICAweDEwLCAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMHgwMCxcbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgICAgMHgwMCwgLy8gcmVzZXJ2ZWQyXG4gICAgICAoc2FtcGxlcmF0ZSA+PiA4KSAmIDB4ZmYsXG4gICAgICBzYW1wbGVyYXRlICYgMHhmZiwgLy9cbiAgICAgIDB4MDAsXG4gICAgICAweDAwLFxuICAgIF0pO1xuICB9XG5cbiAgc3RhdGljIG1wNGEodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlcy5tcDRhLFxuICAgICAgTVA0LmF1ZGlvU3RzZCh0cmFjayksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgbXAzKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIE1QNC5hdWRpb1N0c2QodHJhY2spKTtcbiAgfVxuXG4gIHN0YXRpYyBhYzModHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChcbiAgICAgIE1QNC50eXBlc1snYWMtMyddLFxuICAgICAgTVA0LmF1ZGlvU3RzZCh0cmFjayksXG4gICAgICBNUDQuYm94KE1QNC50eXBlcy5kYWMzLCB0cmFjay5jb25maWcpLFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWMzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hYzModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0a2hkKHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRyYWNrLmR1cmF0aW9uICogdHJhY2sudGltZXNjYWxlO1xuICAgIGNvbnN0IHdpZHRoID0gdHJhY2sud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdHJhY2suaGVpZ2h0O1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnRraGQsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDA3LCAvLyBmbGFnc1xuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAyLCAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDMsIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICAgIChpZCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaWQgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGlkID4+IDgpICYgMHhmZixcbiAgICAgICAgaWQgJiAweGZmLCAvLyB0cmFja19JRFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyByZXNlcnZlZFxuICAgICAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCxcbiAgICAgICAgKHVwcGVyV29yZER1cmF0aW9uID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICh1cHBlcldvcmREdXJhdGlvbiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZixcbiAgICAgICAgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsXG4gICAgICAgIChsb3dlcldvcmREdXJhdGlvbiA+PiAxNikgJiAweGZmLFxuICAgICAgICAobG93ZXJXb3JkRHVyYXRpb24gPj4gOCkgJiAweGZmLFxuICAgICAgICBsb3dlcldvcmREdXJhdGlvbiAmIDB4ZmYsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGxheWVyXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIGFsdGVybmF0ZV9ncm91cFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHJlc2VydmVkXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDEsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4NDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MDAsIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgICAgKHdpZHRoID4+IDgpICYgMHhmZixcbiAgICAgICAgd2lkdGggJiAweGZmLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyB3aWR0aFxuICAgICAgICAoaGVpZ2h0ID4+IDgpICYgMHhmZixcbiAgICAgICAgaGVpZ2h0ICYgMHhmZixcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gaGVpZ2h0XG4gICAgICBdKSxcbiAgICApO1xuICB9XG5cbiAgc3RhdGljIHRyYWYodHJhY2ssIGJhc2VNZWRpYURlY29kZVRpbWUpIHtcbiAgICBjb25zdCBzYW1wbGVEZXBlbmRlbmN5VGFibGUgPSBNUDQuc2R0cCh0cmFjayk7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICBjb25zdCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5mbG9vcihcbiAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLyAoVUlOVDMyX01BWCArIDEpLFxuICAgICk7XG4gICAgY29uc3QgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoXG4gICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lICUgKFVJTlQzMl9NQVggKyAxKSxcbiAgICApO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnRyYWYsXG4gICAgICBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMudGZoZCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgIGlkID4+IDI0LFxuICAgICAgICAgIChpZCA+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChpZCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgaWQgJiAweGZmLCAvLyB0cmFja19JRFxuICAgICAgICBdKSxcbiAgICAgICksXG4gICAgICBNUDQuYm94KFxuICAgICAgICBNUDQudHlwZXMudGZkdCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgIDB4MDEsIC8vIHZlcnNpb24gMVxuICAgICAgICAgIDB4MDAsXG4gICAgICAgICAgMHgwMCxcbiAgICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICAgIHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsXG4gICAgICAgICAgKHVwcGVyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAodXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsXG4gICAgICAgICAgbG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAyNCxcbiAgICAgICAgICAobG93ZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDgpICYgMHhmZixcbiAgICAgICAgICBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZixcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgICAgTVA0LnRydW4oXG4gICAgICAgIHRyYWNrLFxuICAgICAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUubGVuZ3RoICtcbiAgICAgICAgICAxNiArIC8vIHRmaGRcbiAgICAgICAgICAyMCArIC8vIHRmZHRcbiAgICAgICAgICA4ICsgLy8gdHJhZiBoZWFkZXJcbiAgICAgICAgICAxNiArIC8vIG1maGRcbiAgICAgICAgICA4ICsgLy8gbW9vZiBoZWFkZXJcbiAgICAgICAgICA4LFxuICAgICAgKSwgLy8gbWRhdCBoZWFkZXJcbiAgICAgIHNhbXBsZURlcGVuZGVuY3lUYWJsZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG5cbiAgc3RhdGljIHRyZXgodHJhY2spIHtcbiAgICBjb25zdCBpZCA9IHRyYWNrLmlkO1xuICAgIHJldHVybiBNUDQuYm94KFxuICAgICAgTVA0LnR5cGVzLnRyZXgsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDB4MDAsIC8vIHZlcnNpb24gMFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAwLCAvLyBmbGFnc1xuICAgICAgICBpZCA+PiAyNCxcbiAgICAgICAgKGlkID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChpZCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGlkICYgMHhmZiwgLy8gdHJhY2tfSURcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMSwgLy8gZGVmYXVsdF9zYW1wbGVfZGVzY3JpcHRpb25faW5kZXhcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfZHVyYXRpb25cbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCxcbiAgICAgICAgMHgwMCwgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLFxuICAgICAgICAweDAwLFxuICAgICAgICAweDAxLCAvLyBkZWZhdWx0X3NhbXBsZV9mbGFnc1xuICAgICAgXSksXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyB0cnVuKHRyYWNrLCBvZmZzZXQpIHtcbiAgICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcyB8fCBbXTtcbiAgICBjb25zdCBsZW4gPSBzYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBhcnJheWxlbiA9IDEyICsgMTYgKiBsZW47XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheWxlbik7XG4gICAgbGV0IGk7XG4gICAgbGV0IHNhbXBsZTtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgbGV0IHNpemU7XG4gICAgbGV0IGZsYWdzO1xuICAgIGxldCBjdHM7XG4gICAgb2Zmc2V0ICs9IDggKyBhcnJheWxlbjtcbiAgICBhcnJheS5zZXQoXG4gICAgICBbXG4gICAgICAgIHRyYWNrLnR5cGUgPT09ICd2aWRlbycgPyAweDAxIDogMHgwMCwgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAgIDB4MDAsXG4gICAgICAgIDB4MGYsXG4gICAgICAgIDB4MDEsIC8vIGZsYWdzXG4gICAgICAgIChsZW4gPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChsZW4gPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChsZW4gPj4+IDgpICYgMHhmZixcbiAgICAgICAgbGVuICYgMHhmZiwgLy8gc2FtcGxlX2NvdW50XG4gICAgICAgIChvZmZzZXQgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChvZmZzZXQgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChvZmZzZXQgPj4+IDgpICYgMHhmZixcbiAgICAgICAgb2Zmc2V0ICYgMHhmZiwgLy8gZGF0YV9vZmZzZXRcbiAgICAgIF0sXG4gICAgICAwLFxuICAgICk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoXG4gICAgICAgIFtcbiAgICAgICAgICAoZHVyYXRpb24gPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgKGR1cmF0aW9uID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgIChkdXJhdGlvbiA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgIGR1cmF0aW9uICYgMHhmZiwgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgICAgKHNpemUgPj4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgKHNpemUgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgKHNpemUgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICBzaXplICYgMHhmZiwgLy8gc2FtcGxlX3NpemVcbiAgICAgICAgICAoZmxhZ3MuaXNMZWFkaW5nIDw8IDIpIHwgZmxhZ3MuZGVwZW5kc09uLFxuICAgICAgICAgIChmbGFncy5pc0RlcGVuZGVkT24gPDwgNikgfFxuICAgICAgICAgICAgKGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCkgfFxuICAgICAgICAgICAgKGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxKSB8XG4gICAgICAgICAgICBmbGFncy5pc05vblN5bmMsXG4gICAgICAgICAgZmxhZ3MuZGVncmFkUHJpbyAmICgweGYwIDw8IDgpLFxuICAgICAgICAgIGZsYWdzLmRlZ3JhZFByaW8gJiAweDBmLCAvLyBzYW1wbGVfZmxhZ3NcbiAgICAgICAgICAoY3RzID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAgIChjdHMgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgKGN0cyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgIGN0cyAmIDB4ZmYsIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgICBdLFxuICAgICAgICAxMiArIDE2ICogaSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy50cnVuLCBhcnJheSk7XG4gIH1cblxuICBzdGF0aWMgaW5pdFNlZ21lbnQodHJhY2tzKSB7XG4gICAgaWYgKCFNUDQudHlwZXMpIHtcbiAgICAgIE1QNC5pbml0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbW92aWUgPSBNUDQubW9vdih0cmFja3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGVuZFVpbnQ4QXJyYXkoTVA0LkZUWVAsIG1vdmllKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1QNDtcbiIsImNvbnN0IE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiA9IDkwMDAwO1xuXG5leHBvcnQgdHlwZSBSYXRpb25hbFRpbWVzdGFtcCA9IHtcbiAgYmFzZVRpbWU6IG51bWJlcjsgLy8gdGlja3NcbiAgdGltZXNjYWxlOiBudW1iZXI7IC8vIHRpY2tzIHBlciBzZWNvbmRcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKFxuICBiYXNlVGltZTogbnVtYmVyLFxuICBkZXN0U2NhbGU6IG51bWJlcixcbiAgc3JjQmFzZTogbnVtYmVyID0gMSxcbiAgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZSxcbik6IG51bWJlciB7XG4gIGNvbnN0IHJlc3VsdCA9IGJhc2VUaW1lICogZGVzdFNjYWxlICogc3JjQmFzZTsgLy8gZXF1aXZhbGVudCB0byBgKHZhbHVlICogc2NhbGUpIC8gKDEgLyBiYXNlKWBcbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUoXG4gIGJhc2VUaW1lOiBudW1iZXIsXG4gIGRlc3RTY2FsZTogbnVtYmVyLFxuICBzcmNTY2FsZTogbnVtYmVyID0gMSxcbiAgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZSxcbik6IG51bWJlciB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIDEgLyBzcmNTY2FsZSwgcm91bmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9Nc0Zyb21NcGVnVHNDbG9jayhcbiAgYmFzZVRpbWU6IG51bWJlcixcbiAgcm91bmQ6IGJvb2xlYW4gPSBmYWxzZSxcbik6IG51bWJlciB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCAxMDAwLCAxIC8gTVBFR19UU19DTE9DS19GUkVRX0haLCByb3VuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZShcbiAgYmFzZVRpbWU6IG51bWJlcixcbiAgc3JjU2NhbGU6IG51bWJlciA9IDEsXG4pOiBudW1iZXIge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgTVBFR19UU19DTE9DS19GUkVRX0haLCAxIC8gc3JjU2NhbGUpO1xufVxuIiwiaW1wb3J0IEFBQyBmcm9tICcuL2FhYy1oZWxwZXInO1xuaW1wb3J0IE1QNCBmcm9tICcuL21wNC1nZW5lcmF0b3InO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHtcbiAgSW5pdFNlZ21lbnREYXRhLFxuICBSZW11eGVyLFxuICBSZW11eGVyUmVzdWx0LFxuICBSZW11eGVkTWV0YWRhdGEsXG4gIFJlbXV4ZWRUcmFjayxcbiAgUmVtdXhlZFVzZXJkYXRhLFxufSBmcm9tICcuLi90eXBlcy9yZW11eGVyJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7XG4gIFJhdGlvbmFsVGltZXN0YW1wLFxuICB0b01zRnJvbU1wZWdUc0Nsb2NrLFxufSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5pbXBvcnQgdHlwZSB7XG4gIEF1ZGlvU2FtcGxlLFxuICBWaWRlb1NhbXBsZSxcbiAgRGVtdXhlZEF1ZGlvVHJhY2ssXG4gIERlbXV4ZWRWaWRlb1RyYWNrLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBUcmFja1NldCB9IGZyb20gJy4uL3R5cGVzL3RyYWNrJztcbmltcG9ydCB0eXBlIHsgU291cmNlQnVmZmVyTmFtZSB9IGZyb20gJy4uL3R5cGVzL2J1ZmZlcic7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcblxuY29uc3QgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiA9IDEwICogMTAwMDsgLy8gMTAgc2Vjb25kc1xuY29uc3QgQUFDX1NBTVBMRVNfUEVSX0ZSQU1FID0gMTAyNDtcbmNvbnN0IE1QRUdfQVVESU9fU0FNUExFX1BFUl9GUkFNRSA9IDExNTI7XG5jb25zdCBBQzNfU0FNUExFU19QRVJfRlJBTUUgPSAxNTM2O1xuXG5sZXQgY2hyb21lVmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5sZXQgc2FmYXJpV2Via2l0VmVyc2lvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1QNFJlbXV4ZXIgaW1wbGVtZW50cyBSZW11eGVyIHtcbiAgcHJpdmF0ZSBvYnNlcnZlcjogSGxzRXZlbnRFbWl0dGVyO1xuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIHR5cGVTdXBwb3J0ZWQ6IGFueTtcbiAgcHJpdmF0ZSBJU0dlbmVyYXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9pbml0RFRTOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHRBdmNEdHM6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG5leHRBdWRpb1B0czogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdmlkZW9TYW1wbGVEdXJhdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaXNBdWRpb0NvbnRpZ3VvdXM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1ZpZGVvQ29udGlndW91czogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHZpZGVvVHJhY2tDb25maWc/OiB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgIHBpeGVsUmF0aW8/OiBbbnVtYmVyLCBudW1iZXJdO1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gICAgY29uZmlnOiBIbHNDb25maWcsXG4gICAgdHlwZVN1cHBvcnRlZCxcbiAgICB2ZW5kb3IgPSAnJyxcbiAgKSB7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gbnVsbDtcbiAgfVxuXG4gIHJlc2V0VGltZVN0YW1wKGRlZmF1bHRUaW1lU3RhbXA6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG5cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IHJlc2V0IG5leHQgdGltZXN0YW1wJyk7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgfVxuXG4gIHJlc2V0SW5pdFNlZ21lbnQoKSB7XG4gICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogSVNHZW5lcmF0ZWQgZmxhZyByZXNldCcpO1xuICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIGxldCByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKChtaW5QVFMsIHNhbXBsZSkgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUHRzKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBUUztcbiAgfVxuXG4gIHJlbXV4KFxuICAgIGF1ZGlvVHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgIHZpZGVvVHJhY2s6IERlbXV4ZWRWaWRlb1RyYWNrLFxuICAgIGlkM1RyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgICB0ZXh0VHJhY2s6IERlbXV4ZWRVc2VyZGF0YVRyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgZmx1c2g6IGJvb2xlYW4sXG4gICAgcGxheWxpc3RUeXBlOiBQbGF5bGlzdExldmVsVHlwZSxcbiAgKTogUmVtdXhlclJlc3VsdCB7XG4gICAgbGV0IHZpZGVvOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGF1ZGlvOiBSZW11eGVkVHJhY2sgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluaXRTZWdtZW50OiBJbml0U2VnbWVudERhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IHRleHQ6IFJlbXV4ZWRVc2VyZGF0YSB8IHVuZGVmaW5lZDtcbiAgICBsZXQgaWQzOiBSZW11eGVkTWV0YWRhdGEgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluZGVwZW5kZW50OiBib29sZWFuIHwgdW5kZWZpbmVkO1xuICAgIGxldCBhdWRpb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuICAgIGxldCB2aWRlb1RpbWVPZmZzZXQgPSB0aW1lT2Zmc2V0O1xuXG4gICAgLy8gSWYgd2UncmUgcmVtdXhpbmcgYXVkaW8gYW5kIHZpZGVvIHByb2dyZXNzaXZlbHksIHdhaXQgdW50aWwgd2UndmUgcmVjZWl2ZWQgZW5vdWdoIHNhbXBsZXMgZm9yIGVhY2ggdHJhY2sgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHN5bmNocm9uaXplIHRoZSBhdWRpbyBhbmQgdmlkZW8gc3RyZWFtcy4gV2Uga25vdyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHdpbGwgaGF2ZSBzYW1wbGVzIGlmIHRoZSBcInBpZFwiXG4gICAgLy8gcGFyYW1ldGVyIGlzIGdyZWF0ZXIgdGhhbiAtMS4gVGhlIHBpZCBpcyBzZXQgd2hlbiB0aGUgUE1UIGlzIHBhcnNlZCwgd2hpY2ggY29udGFpbnMgdGhlIHRyYWNrcyBsaXN0LlxuICAgIC8vIEhvd2V2ZXIsIGlmIHRoZSBpbml0U2VnbWVudCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZCwgb3Igd2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIGEgc2VnbWVudCAoZmx1c2gpLFxuICAgIC8vIHRoZW4gd2UgY2FuIHJlbXV4IG9uZSB0cmFjayB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSBvdGhlci5cbiAgICBjb25zdCBoYXNBdWRpbyA9IGF1ZGlvVHJhY2sucGlkID4gLTE7XG4gICAgY29uc3QgaGFzVmlkZW8gPSB2aWRlb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZpZGVvVHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gICAgY29uc3QgZW5vdWdoQXVkaW9TYW1wbGVzID0gYXVkaW9UcmFjay5zYW1wbGVzLmxlbmd0aCA+IDA7XG4gICAgY29uc3QgZW5vdWdoVmlkZW9TYW1wbGVzID0gKGZsdXNoICYmIGxlbmd0aCA+IDApIHx8IGxlbmd0aCA+IDE7XG4gICAgY29uc3QgY2FuUmVtdXhBdmMgPVxuICAgICAgKCghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJlxuICAgICAgICAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykpIHx8XG4gICAgICB0aGlzLklTR2VuZXJhdGVkIHx8XG4gICAgICBmbHVzaDtcblxuICAgIGlmIChjYW5SZW11eEF2Yykge1xuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy52aWRlb1RyYWNrQ29uZmlnO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY29uZmlnICYmXG4gICAgICAgICAgKHZpZGVvVHJhY2sud2lkdGggIT09IGNvbmZpZy53aWR0aCB8fFxuICAgICAgICAgICAgdmlkZW9UcmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHxcbiAgICAgICAgICAgIHZpZGVvVHJhY2sucGl4ZWxSYXRpbz8uWzBdICE9PSBjb25maWcucGl4ZWxSYXRpbz8uWzBdIHx8XG4gICAgICAgICAgICB2aWRlb1RyYWNrLnBpeGVsUmF0aW8/LlsxXSAhPT0gY29uZmlnLnBpeGVsUmF0aW8/LlsxXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5yZXNldEluaXRTZWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKFxuICAgICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNWaWRlb0NvbnRpZ3VvdXMgPSB0aGlzLmlzVmlkZW9Db250aWd1b3VzO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVJbmRleCA9IC0xO1xuICAgICAgbGV0IGZpcnN0S2V5RnJhbWVQVFM7XG5cbiAgICAgIGlmIChlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgZmlyc3RLZXlGcmFtZUluZGV4ID0gZmluZEtleWZyYW1lSW5kZXgodmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgaWYgKCFpc1ZpZGVvQ29udGlndW91cyAmJiB0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgaW5kZXBlbmRlbnQgPSB0cnVlO1xuICAgICAgICAgIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IERyb3BwZWQgJHtmaXJzdEtleUZyYW1lSW5kZXh9IG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5zYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzLnNsaWNlKGZpcnN0S2V5RnJhbWVJbmRleCk7XG4gICAgICAgICAgICB2aWRlb1RyYWNrLmRyb3BwZWQgKz0gZmlyc3RLZXlGcmFtZUluZGV4O1xuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0ICs9XG4gICAgICAgICAgICAgICh2aWRlb1RyYWNrLnNhbXBsZXNbMF0ucHRzIC0gc3RhcnRQVFMpIC9cbiAgICAgICAgICAgICAgdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgICAgIGZpcnN0S2V5RnJhbWVQVFMgPSB2aWRlb1RpbWVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEtleUZyYW1lSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlc2AsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuSVNHZW5lcmF0ZWQpIHtcbiAgICAgICAgaWYgKGVub3VnaEF1ZGlvU2FtcGxlcyAmJiBlbm91Z2hWaWRlb1NhbXBsZXMpIHtcbiAgICAgICAgICAvLyB0aW1lT2Zmc2V0IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IHRpbWVzdGFtcCBvZiB0aGlzIGZyYWdtZW50IChmaXJzdCBEVFMpXG4gICAgICAgICAgLy8gaWYgZmlyc3QgYXVkaW8gRFRTIGlzIG5vdCBhbGlnbmVkIHdpdGggZmlyc3QgdmlkZW8gRFRTIHRoZW4gd2UgbmVlZCB0byB0YWtlIHRoYXQgaW50byBhY2NvdW50XG4gICAgICAgICAgLy8gd2hlbiBwcm92aWRpbmcgdGltZU9mZnNldCB0byByZW11eEF1ZGlvIC8gcmVtdXhWaWRlby4gaWYgd2UgZG9uJ3QgZG8gdGhhdCwgdGhlcmUgbWlnaHQgYmUgYSBwZXJtYW5lbnQgLyBzbWFsbFxuICAgICAgICAgIC8vIGRyaWZ0IGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXNcbiAgICAgICAgICBjb25zdCBzdGFydFBUUyA9IHRoaXMuZ2V0VmlkZW9TdGFydFB0cyh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICAgIGNvbnN0IHRzRGVsdGEgPVxuICAgICAgICAgICAgbm9ybWFsaXplUHRzKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0UFRTO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICAgICdbbXA0LXJlbXV4ZXJdOiByZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhcbiAgICAgICAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXVkaW8gPSB0aGlzLnJlbXV4QXVkaW8oXG4gICAgICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICAgICAgYXVkaW9UaW1lT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyxcbiAgICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgICAgIGhhc1ZpZGVvIHx8XG4gICAgICAgICAgICAgIGVub3VnaFZpZGVvU2FtcGxlcyB8fFxuICAgICAgICAgICAgICBwbGF5bGlzdFR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPXG4gICAgICAgICAgICAgID8gdmlkZW9UaW1lT2Zmc2V0XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAnW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKFxuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2ssXG4gICAgICAgICAgICAgICAgdmlkZW9UcmFjayxcbiAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKFxuICAgICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgICB2aWRlb1RpbWVPZmZzZXQsXG4gICAgICAgICAgICAgIGlzVmlkZW9Db250aWd1b3VzLFxuICAgICAgICAgICAgICBhdWRpb1RyYWNrTGVuZ3RoLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8oXG4gICAgICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICAgICAgdmlkZW9UaW1lT2Zmc2V0LFxuICAgICAgICAgICAgaXNWaWRlb0NvbnRpZ3VvdXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICB2aWRlby5pbmRlcGVuZGVudCA9IGZpcnN0S2V5RnJhbWVJbmRleCAhPT0gLTE7XG4gICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZVBUUyA9IGZpcnN0S2V5RnJhbWVQVFM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBJRDMgYW5kIHRleHQgdG8gcmVtdXgsIGV2ZW4gaWYgbW9yZSBhdWRpby92aWRlbyBzYW1wbGVzIGFyZSByZXF1aXJlZFxuICAgIGlmICh0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUykge1xuICAgICAgaWYgKGlkM1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKFxuICAgICAgICAgIGlkM1RyYWNrLFxuICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgdGhpcy5faW5pdFBUUyxcbiAgICAgICAgICB0aGlzLl9pbml0RFRTLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyhcbiAgICAgICAgICB0ZXh0VHJhY2ssXG4gICAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgICB0aGlzLl9pbml0UFRTLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICBpbmRlcGVuZGVudCxcbiAgICAgIHRleHQsXG4gICAgICBpZDMsXG4gICAgfTtcbiAgfVxuXG4gIGdlbmVyYXRlSVMoXG4gICAgYXVkaW9UcmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdmlkZW9UcmFjazogRGVtdXhlZFZpZGVvVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgKTogSW5pdFNlZ21lbnREYXRhIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhdWRpb1NhbXBsZXMgPSBhdWRpb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdmlkZW9TYW1wbGVzID0gdmlkZW9UcmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IHR5cGVTdXBwb3J0ZWQgPSB0aGlzLnR5cGVTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdHJhY2tzOiBUcmFja1NldCA9IHt9O1xuICAgIGNvbnN0IF9pbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgY29tcHV0ZVBUU0RUUyA9ICFfaW5pdFBUUyB8fCBhY2N1cmF0ZVRpbWVPZmZzZXQ7XG4gICAgbGV0IGNvbnRhaW5lciA9ICdhdWRpby9tcDQnO1xuICAgIGxldCBpbml0UFRTOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGluaXREVFM6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBsZXQgdGltZXNjYWxlOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgaW5pdFBUUyA9IGluaXREVFMgPSBJbmZpbml0eTtcbiAgICB9XG5cbiAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcbiAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAgYXVkaW9UcmFjay5jb2RlYyA9ICdhYy0zJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYWNrcy5hdWRpbyA9IHtcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICBjb2RlYzogYXVkaW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6XG4gICAgICAgICAgYXVkaW9UcmFjay5zZWdtZW50Q29kZWMgPT09ICdtcDMnICYmIHR5cGVTdXBwb3J0ZWQubXBlZ1xuICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheSgwKVxuICAgICAgICAgICAgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRpbWVzY2FsZSA9IGF1ZGlvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgIGlmICghX2luaXRQVFMgfHwgdGltZXNjYWxlICE9PSBfaW5pdFBUUy50aW1lc2NhbGUpIHtcbiAgICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2YgdGhpcyBkZW11eGluZyBjb250ZXh0LiBmb3IgYXVkaW8sIFBUUyA9IERUU1xuICAgICAgICAgIGluaXRQVFMgPSBpbml0RFRTID1cbiAgICAgICAgICAgIGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aWRlb1RyYWNrLnNwcyAmJiB2aWRlb1RyYWNrLnBwcyAmJiB2aWRlb1NhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAvLyBsZXQncyB1c2UgaW5wdXQgdGltZSBzY2FsZSBhcyBNUDQgdmlkZW8gdGltZXNjYWxlXG4gICAgICAvLyB3ZSB1c2UgaW5wdXQgdGltZSBzY2FsZSBzdHJhaWdodCBhd2F5IHRvIGF2b2lkIHJvdW5kaW5nIGlzc3VlcyBvbiBmcmFtZSBkdXJhdGlvbiAvIGN0cyBjb21wdXRhdGlvblxuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9UcmFjay5jb2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQ6IE1QNC5pbml0U2VnbWVudChbdmlkZW9UcmFja10pLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1RyYWNrLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHQsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgICAgaWYgKCFfaW5pdFBUUyB8fCB0aW1lc2NhbGUgIT09IF9pbml0UFRTLnRpbWVzY2FsZSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0UFRTID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcyk7XG4gICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICAgIGluaXREVFMgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGluaXREVFMgYXMgbnVtYmVyLFxuICAgICAgICAgICAgbm9ybWFsaXplUHRzKHZpZGVvU2FtcGxlc1swXS5kdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMgYXMgbnVtYmVyLCBzdGFydFBUUyAtIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wdXRlUFRTRFRTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHtcbiAgICAgICAgd2lkdGg6IHZpZGVvVHJhY2sud2lkdGgsXG4gICAgICAgIGhlaWdodDogdmlkZW9UcmFjay5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW86IHZpZGVvVHJhY2sucGl4ZWxSYXRpbyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyYWNrcykubGVuZ3RoKSB7XG4gICAgICB0aGlzLklTR2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICAgIHRoaXMuX2luaXRQVFMgPSB7XG4gICAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMgYXMgbnVtYmVyLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlIGFzIG51bWJlcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdERUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdERUUyBhcyBudW1iZXIsXG4gICAgICAgICAgdGltZXNjYWxlOiB0aW1lc2NhbGUgYXMgbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdFBUUyA9IHRpbWVzY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2tzLFxuICAgICAgICBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGUsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJlbXV4VmlkZW8oXG4gICAgdHJhY2s6IERlbXV4ZWRWaWRlb1RyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIGF1ZGlvVHJhY2tMZW5ndGg6IG51bWJlcixcbiAgKTogUmVtdXhlZFRyYWNrIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0aW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGlucHV0U2FtcGxlczogQXJyYXk8VmlkZW9TYW1wbGU+ID0gdHJhY2suc2FtcGxlcztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzOiBBcnJheTxNcDRTYW1wbGU+ID0gW107XG4gICAgY29uc3QgbmJTYW1wbGVzID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUyBhcyBSYXRpb25hbFRpbWVzdGFtcDtcbiAgICBsZXQgbmV4dEF2Y0R0cyA9IHRoaXMubmV4dEF2Y0R0cztcbiAgICBsZXQgb2Zmc2V0ID0gODtcbiAgICBsZXQgbXA0U2FtcGxlRHVyYXRpb24gPSB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb247XG4gICAgbGV0IGZpcnN0RFRTO1xuICAgIGxldCBsYXN0RFRTO1xuICAgIGxldCBtaW5QVFM6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4UFRTOiBudW1iZXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IHNvcnRTYW1wbGVzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBwYXJzZWQgZnJhZ21lbnQgaXMgY29udGlndW91cyB3aXRoIGxhc3Qgb25lLCBsZXQncyB1c2UgbGFzdCBEVFMgdmFsdWUgYXMgcmVmZXJlbmNlXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdmNEdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHB0cyA9IHRpbWVPZmZzZXQgKiB0aW1lU2NhbGU7XG4gICAgICBjb25zdCBjdHMgPVxuICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzIC1cbiAgICAgICAgbm9ybWFsaXplUHRzKGlucHV0U2FtcGxlc1swXS5kdHMsIGlucHV0U2FtcGxlc1swXS5wdHMpO1xuICAgICAgaWYgKFxuICAgICAgICBjaHJvbWVWZXJzaW9uICYmXG4gICAgICAgIG5leHRBdmNEdHMgIT09IG51bGwgJiZcbiAgICAgICAgTWF0aC5hYnMocHRzIC0gY3RzIC0gbmV4dEF2Y0R0cykgPCAxNTAwMFxuICAgICAgKSB7XG4gICAgICAgIC8vIHRyZWF0IGFzIGNvbnRpZ291cyB0byBhZGp1c3Qgc2FtcGxlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBwcm9kdWNlIHZpZGVvIGJ1ZmZlciBnYXBzIGluIENocm9tZVxuICAgICAgICBjb250aWd1b3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCBjb250aWd1b3VzLCBsZXQncyB1c2UgdGFyZ2V0IHRpbWVPZmZzZXRcbiAgICAgICAgbmV4dEF2Y0R0cyA9IHB0cyAtIGN0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQVFMgaXMgY29kZWQgb24gMzNiaXRzLCBhbmQgY2FuIGxvb3AgZnJvbSAtMl4zMiB0byAyXjMyXG4gICAgLy8gUFRTTm9ybWFsaXplIHdpbGwgbWFrZSBQVFMvRFRTIHZhbHVlIG1vbm90b25pYywgd2UgdXNlIGxhc3Qga25vd24gRFRTIHZhbHVlIGFzIHJlZmVyZW5jZSB2YWx1ZVxuICAgIGNvbnN0IGluaXRUaW1lID0gKGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUpIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIG5leHRBdmNEdHMpO1xuICAgICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdFRpbWUsIG5leHRBdmNEdHMpO1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBpbnB1dFNhbXBsZXNbaSA+IDAgPyBpIC0gMSA6IGldLmR0cykge1xuICAgICAgICBzb3J0U2FtcGxlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc29ydCB2aWRlbyBzYW1wbGVzIGJ5IERUUyB0aGVuIFBUUyB0aGVuIGRlbXV4IGlkIG9yZGVyXG4gICAgaWYgKHNvcnRTYW1wbGVzKSB7XG4gICAgICBpbnB1dFNhbXBsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb25zdCBkZWx0YWR0cyA9IGEuZHRzIC0gYi5kdHM7XG4gICAgICAgIGNvbnN0IGRlbHRhcHRzID0gYS5wdHMgLSBiLnB0cztcbiAgICAgICAgcmV0dXJuIGRlbHRhZHRzIHx8IGRlbHRhcHRzO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGZpcnN0L2xhc3QgRFRTXG4gICAgZmlyc3REVFMgPSBpbnB1dFNhbXBsZXNbMF0uZHRzO1xuICAgIGxhc3REVFMgPSBpbnB1dFNhbXBsZXNbaW5wdXRTYW1wbGVzLmxlbmd0aCAtIDFdLmR0cztcblxuICAgIC8vIFNhbXBsZSBkdXJhdGlvbiAoYXMgZXhwZWN0ZWQgYnkgdHJ1biBNUDQgYm94ZXMpLCBzaG91bGQgYmUgdGhlIGRlbHRhIGJldHdlZW4gc2FtcGxlIERUU1xuICAgIC8vIHNldCB0aGlzIGNvbnN0YW50IGR1cmF0aW9uIGFzIGJlaW5nIHRoZSBhdmcgZGVsdGEgYmV0d2VlbiBjb25zZWN1dGl2ZSBEVFMuXG4gICAgY29uc3QgaW5wdXREdXJhdGlvbiA9IGxhc3REVFMgLSBmaXJzdERUUztcbiAgICBjb25zdCBhdmVyYWdlU2FtcGxlRHVyYXRpb24gPSBpbnB1dER1cmF0aW9uXG4gICAgICA/IE1hdGgucm91bmQoaW5wdXREdXJhdGlvbiAvIChuYlNhbXBsZXMgLSAxKSlcbiAgICAgIDogbXA0U2FtcGxlRHVyYXRpb24gfHwgdHJhY2suaW5wdXRUaW1lU2NhbGUgLyAzMDtcblxuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIGNvbnN0IGRlbHRhID0gZmlyc3REVFMgLSBuZXh0QXZjRHRzO1xuICAgICAgY29uc3QgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICBjb25zdCBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuICAgICAgaWYgKGZvdW5kSG9sZSB8fCBmb3VuZE92ZXJsYXApIHtcbiAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKFxuICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICl9IG1zICgke2RlbHRhfWR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCBhdCAke3RpbWVPZmZzZXQudG9GaXhlZChcbiAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYEFWQzogJHt0b01zRnJvbU1wZWdUc0Nsb2NrKFxuICAgICAgICAgICAgICAtZGVsdGEsXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApfSBtcyAoJHtkZWx0YX1kdHMpIG92ZXJsYXBwaW5nIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dGltZU9mZnNldC50b0ZpeGVkKFxuICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFmb3VuZE92ZXJsYXAgfHxcbiAgICAgICAgICBuZXh0QXZjRHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMgfHxcbiAgICAgICAgICBjaHJvbWVWZXJzaW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgICBjb25zdCBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dFNhbXBsZXNbaV0uZHRzID4gZmlyc3RQVFMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzIC09IGRlbHRhO1xuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0ucHRzIC09IGRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYFZpZGVvOiBJbml0aWFsIFBUUy9EVFMgYWRqdXN0ZWQ6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhcbiAgICAgICAgICAgICAgZmlyc3RQVFMsXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApfS8ke3RvTXNGcm9tTXBlZ1RzQ2xvY2soXG4gICAgICAgICAgICAgIGZpcnN0RFRTLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgKX0sIGRlbHRhOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZGVsdGEsIHRydWUpfSBtc2AsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0RFRTID0gTWF0aC5tYXgoMCwgZmlyc3REVFMpO1xuXG4gICAgbGV0IG5iTmFsdSA9IDA7XG4gICAgbGV0IG5hbHVMZW4gPSAwO1xuICAgIGxldCBkdHNTdGVwID0gZmlyc3REVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCB1bml0cyA9IHNhbXBsZS51bml0cztcbiAgICAgIGNvbnN0IG5iVW5pdHMgPSB1bml0cy5sZW5ndGg7XG4gICAgICBsZXQgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgbmFsdUxlbiArPSBzYW1wbGVMZW47XG4gICAgICBuYk5hbHUgKz0gbmJVbml0cztcbiAgICAgIHNhbXBsZS5sZW5ndGggPSBzYW1wbGVMZW47XG5cbiAgICAgIC8vIGVuc3VyZSBzYW1wbGUgbW9ub3RvbmljIERUU1xuICAgICAgaWYgKHNhbXBsZS5kdHMgPCBkdHNTdGVwKSB7XG4gICAgICAgIHNhbXBsZS5kdHMgPSBkdHNTdGVwO1xuICAgICAgICBkdHNTdGVwICs9IChhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyA0KSB8IDAgfHwgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR0c1N0ZXAgPSBzYW1wbGUuZHRzO1xuICAgICAgfVxuXG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihzYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgbWF4UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgY29uc3QgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgbGV0IG1kYXQ7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBtZGF0U2l6ZSk7XG4gICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuXG4gICAgbGV0IHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgIGxldCBtaW5EdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heER0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBWaWRlb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IFZpZGVvU2FtcGxlVW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxldCBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBWaWRlb1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBjb25zdCB1bml0ID0gVmlkZW9TYW1wbGVVbml0c1tqXTtcbiAgICAgICAgY29uc3QgdW5pdERhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIGNvbnN0IHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICBsZXQgcHRzRGVsdGE7XG4gICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSArIDFdLmR0cyAtIFZpZGVvU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cyAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9XG4gICAgICAgICAgaSA+IDBcbiAgICAgICAgICAgID8gVmlkZW9TYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgLSAxXS5kdHNcbiAgICAgICAgICAgIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBwdHNEZWx0YSA9XG4gICAgICAgICAgaSA+IDBcbiAgICAgICAgICAgID8gVmlkZW9TYW1wbGUucHRzIC0gaW5wdXRTYW1wbGVzW2kgLSAxXS5wdHNcbiAgICAgICAgICAgIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9QdHMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCBhIHNlZ21lbnQncyBhdWRpbyB0cmFjayBkdXJhdGlvbiBtYXkgZXhjZWVkIHRoZSB2aWRlbyB0cmFjayBkdXJhdGlvbi5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBhbHJlYWR5IHJlbXV4ZWQgYXVkaW8sIGFuZCB3ZSBrbm93IGhvdyBsb25nIHRoZSBhdWRpbyB0cmFjayBpcywgd2UgbG9vayB0b1xuICAgICAgICAgIC8vIHNlZSBpZiB0aGUgZGVsdGEgdG8gdGhlIG5leHQgc2VnbWVudCBpcyBsb25nZXIgdGhhbiBtYXhCdWZmZXJIb2xlLlxuICAgICAgICAgIC8vIElmIHNvLCBwbGF5YmFjayB3b3VsZCBwb3RlbnRpYWxseSBnZXQgc3R1Y2ssIHNvIHdlIGFydGlmaWNpYWxseSBpbmZsYXRlXG4gICAgICAgICAgLy8gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IGZyYW1lIHRvIG1pbmltaXplIGFueSBwb3RlbnRpYWwgZ2FwIGJldHdlZW4gc2VnbWVudHMuXG4gICAgICAgICAgY29uc3QgZ2FwVG9sZXJhbmNlID0gTWF0aC5mbG9vcihjb25maWcubWF4QnVmZmVySG9sZSAqIHRpbWVTY2FsZSk7XG4gICAgICAgICAgY29uc3QgZGVsdGFUb0ZyYW1lRW5kID1cbiAgICAgICAgICAgIChhdWRpb1RyYWNrTGVuZ3RoXG4gICAgICAgICAgICAgID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZVxuICAgICAgICAgICAgICA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgYFttcDQtcmVtdXhlcl06IEl0IGlzIGFwcHJveGltYXRlbHkgJHtcbiAgICAgICAgICAgICAgICBkZWx0YVRvRnJhbWVFbmQgLyA5MFxuICAgICAgICAgICAgICB9IG1zIHRvIHRoZSBuZXh0IHNlZ21lbnQ7IHVzaW5nIGR1cmF0aW9uICR7XG4gICAgICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gLyA5MFxuICAgICAgICAgICAgICB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChcbiAgICAgICAgVmlkZW9TYW1wbGUucHRzIC0gVmlkZW9TYW1wbGUuZHRzLFxuICAgICAgKTtcbiAgICAgIG1pbkR0c0RlbHRhID0gTWF0aC5taW4obWluRHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1heER0c0RlbHRhID0gTWF0aC5tYXgobWF4RHRzRGVsdGEsIG1wNFNhbXBsZUR1cmF0aW9uKTtcbiAgICAgIG1pblB0c0RlbHRhID0gTWF0aC5taW4obWluUHRzRGVsdGEsIHB0c0RlbHRhKTtcbiAgICAgIG1heFB0c0RlbHRhID0gTWF0aC5tYXgobWF4UHRzRGVsdGEsIHB0c0RlbHRhKTtcblxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKFxuICAgICAgICBuZXcgTXA0U2FtcGxlKFxuICAgICAgICAgIFZpZGVvU2FtcGxlLmtleSxcbiAgICAgICAgICBtcDRTYW1wbGVEdXJhdGlvbixcbiAgICAgICAgICBtcDRTYW1wbGVMZW5ndGgsXG4gICAgICAgICAgY29tcG9zaXRpb25UaW1lT2Zmc2V0LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uKSB7XG4gICAgICAgIGlmIChjaHJvbWVWZXJzaW9uIDwgNzApIHtcbiAgICAgICAgICAvLyBDaHJvbWUgd29ya2Fyb3VuZCwgbWFyayBmaXJzdCBzYW1wbGUgYXMgYmVpbmcgYSBSYW5kb20gQWNjZXNzIFBvaW50IChrZXlmcmFtZSkgdG8gYXZvaWQgc291cmNlYnVmZmVyIGFwcGVuZCBpc3N1ZVxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjk0MTJcbiAgICAgICAgICBjb25zdCBmbGFncyA9IG91dHB1dFNhbXBsZXNbMF0uZmxhZ3M7XG4gICAgICAgICAgZmxhZ3MuZGVwZW5kc09uID0gMjtcbiAgICAgICAgICBmbGFncy5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24pIHtcbiAgICAgICAgLy8gRml4IGZvciBcIkNOTiBzcGVjaWFsIHJlcG9ydCwgd2l0aCBDQ1wiIGluIHRlc3Qtc3RyZWFtcyAoU2FmYXJpIGJyb3dzZXIgb25seSlcbiAgICAgICAgLy8gSWdub3JlIERUUyB3aGVuIGZyYW1lIGR1cmF0aW9ucyBhcmUgaXJyZWd1bGFyLiBTYWZhcmkgTVNFIGRvZXMgbm90IGhhbmRsZSB0aGlzIGxlYWRpbmcgdG8gZ2Fwcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1heFB0c0RlbHRhIC0gbWluUHRzRGVsdGEgPCBtYXhEdHNEZWx0YSAtIG1pbkR0c0RlbHRhICYmXG4gICAgICAgICAgYXZlcmFnZVNhbXBsZUR1cmF0aW9uIC8gbWF4RHRzRGVsdGEgPCAwLjAyNSAmJlxuICAgICAgICAgIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgJ0ZvdW5kIGlycmVndWxhciBnYXBzIGluIHNhbXBsZSBkdXJhdGlvbi4gVXNpbmcgUFRTIGluc3RlYWQgb2YgRFRTIHRvIGRldGVybWluZSBNUDQgc2FtcGxlIGR1cmF0aW9uLicsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG91dHB1dFNhbXBsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHREdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgcHRzID0gZHRzICsgb3V0cHV0U2FtcGxlc1tpXS5jdHM7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dFB0cyA9IG5leHREdHMgKyBvdXRwdXRTYW1wbGVzW2kgKyAxXS5jdHM7XG4gICAgICAgICAgICAgIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb24gPSBuZXh0UHRzIC0gcHRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IGlcbiAgICAgICAgICAgICAgICA/IG91dHB1dFNhbXBsZXNbaSAtIDFdLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmN0cyA9IDA7XG4gICAgICAgICAgICBkdHMgPSBuZXh0RHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBuZXh0IEFWQyBzYW1wbGUgRFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBEVFMgKyBsYXN0IHNhbXBsZSBkdXJhdGlvbiAoaW4gUEVTIHRpbWVzY2FsZSlcbiAgICBtcDRTYW1wbGVEdXJhdGlvbiA9XG4gICAgICBzdHJldGNoZWRMYXN0RnJhbWUgfHwgIW1wNFNhbXBsZUR1cmF0aW9uXG4gICAgICAgID8gYXZlcmFnZVNhbXBsZUR1cmF0aW9uXG4gICAgICAgIDogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICBjb25zdCBtb29mID0gTVA0Lm1vb2YoXG4gICAgICB0cmFjay5zZXF1ZW5jZU51bWJlcisrLFxuICAgICAgZmlyc3REVFMsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0cmFjaywge1xuICAgICAgICBzYW1wbGVzOiBvdXRwdXRTYW1wbGVzLFxuICAgICAgfSksXG4gICAgKTtcbiAgICBjb25zdCB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lID0gJ3ZpZGVvJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IChuZXh0QXZjRHRzIGFzIG51bWJlcikgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkLFxuICAgIH07XG4gICAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICAgIHRyYWNrLmRyb3BwZWQgPSAwO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrOiBEZW11eGVkQXVkaW9UcmFjaykge1xuICAgIHN3aXRjaCAodHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICBjYXNlICdtcDMnOlxuICAgICAgICByZXR1cm4gTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FO1xuICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgcmV0dXJuIEFDM19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBBQUNfU0FNUExFU19QRVJfRlJBTUU7XG4gICAgfVxuICB9XG5cbiAgcmVtdXhBdWRpbyhcbiAgICB0cmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdGltZU9mZnNldDogbnVtYmVyLFxuICAgIGNvbnRpZ3VvdXM6IGJvb2xlYW4sXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICAgIHZpZGVvVGltZU9mZnNldD86IG51bWJlcixcbiAgKTogUmVtdXhlZFRyYWNrIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZTogbnVtYmVyID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlOiBudW1iZXIgPSB0cmFjay5zYW1wbGVyYXRlXG4gICAgICA/IHRyYWNrLnNhbXBsZXJhdGVcbiAgICAgIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3I6IG51bWJlciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNFNhbXBsZUR1cmF0aW9uOiBudW1iZXIgPSB0aGlzLmdldFNhbXBsZXNQZXJGcmFtZSh0cmFjayk7XG4gICAgY29uc3QgaW5wdXRTYW1wbGVEdXJhdGlvbjogbnVtYmVyID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUyBhcyBSYXRpb25hbFRpbWVzdGFtcDtcbiAgICBjb25zdCByYXdNUEVHOiBib29sZWFuID1cbiAgICAgIHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdGhpcy50eXBlU3VwcG9ydGVkLm1wZWc7XG4gICAgY29uc3Qgb3V0cHV0U2FtcGxlczogQXJyYXk8TXA0U2FtcGxlPiA9IFtdO1xuICAgIGNvbnN0IGFsaWduZWRXaXRoVmlkZW8gPSB2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZDtcblxuICAgIGxldCBpbnB1dFNhbXBsZXM6IEFycmF5PEF1ZGlvU2FtcGxlPiA9IHRyYWNrLnNhbXBsZXM7XG4gICAgbGV0IG9mZnNldDogbnVtYmVyID0gcmF3TVBFRyA/IDAgOiA4O1xuICAgIGxldCBuZXh0QXVkaW9QdHM6IG51bWJlciA9IHRoaXMubmV4dEF1ZGlvUHRzIHx8IC0xO1xuXG4gICAgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcblxuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcbiAgICBjb25zdCB0aW1lT2Zmc2V0TXBlZ1RTID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRUaW1lID0gKGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gY29udGlndW91cyA9XG4gICAgICBjb250aWd1b3VzIHx8XG4gICAgICAoKGlucHV0U2FtcGxlcy5sZW5ndGggJiZcbiAgICAgICAgbmV4dEF1ZGlvUHRzID4gMCAmJlxuICAgICAgICAoKGFjY3VyYXRlVGltZU9mZnNldCAmJlxuICAgICAgICAgIE1hdGguYWJzKHRpbWVPZmZzZXRNcGVnVFMgLSBuZXh0QXVkaW9QdHMpIDwgOTAwMCkgfHxcbiAgICAgICAgICBNYXRoLmFicyhcbiAgICAgICAgICAgIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0ucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpIC1cbiAgICAgICAgICAgICAgbmV4dEF1ZGlvUHRzLFxuICAgICAgICAgICkgPFxuICAgICAgICAgICAgMjAgKiBpbnB1dFNhbXBsZUR1cmF0aW9uKSkgYXMgYm9vbGVhbik7XG5cbiAgICAvLyBjb21wdXRlIG5vcm1hbGl6ZWQgUFRTXG4gICAgaW5wdXRTYW1wbGVzLmZvckVhY2goZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFRpbWUsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFjb250aWd1b3VzIHx8IG5leHRBdWRpb1B0cyA8IDApIHtcbiAgICAgIC8vIGZpbHRlciBvdXQgc2FtcGxlIHdpdGggbmVnYXRpdmUgUFRTIHRoYXQgYXJlIG5vdCBwbGF5YWJsZSBhbnl3YXlcbiAgICAgIC8vIGlmIHdlIGRvbid0IHJlbW92ZSB0aGVzZSBuZWdhdGl2ZSBzYW1wbGVzLCB0aGV5IHdpbGwgc2hpZnQgYWxsIGF1ZGlvIHNhbXBsZXMgZm9yd2FyZC5cbiAgICAgIC8vIGxlYWRpbmcgdG8gYXVkaW8gb3ZlcmxhcCBiZXR3ZWVuIGN1cnJlbnQgLyBuZXh0IGZyYWdtZW50XG4gICAgICBpbnB1dFNhbXBsZXMgPSBpbnB1dFNhbXBsZXMuZmlsdGVyKChzYW1wbGUpID0+IHNhbXBsZS5wdHMgPj0gMCk7XG5cbiAgICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgICBpZiAoIWlucHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlkZW9UaW1lT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhcnQgdG8gMCB0byBtYXRjaCB2aWRlbyBzbyB0aGF0IHN0YXJ0IGdhcHMgbGFyZ2VyIHRoYW4gaW5wdXRTYW1wbGVEdXJhdGlvbiBhcmUgZmlsbGVkIHdpdGggc2lsZW5jZVxuICAgICAgICBuZXh0QXVkaW9QdHMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChhY2N1cmF0ZVRpbWVPZmZzZXQgJiYgIWFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgLy8gV2hlbiBub3Qgc2Vla2luZywgbm90IGxpdmUsIGFuZCBMZXZlbERldGFpbHMuUFRTS25vd24sIHVzZSBmcmFnbWVudCBzdGFydCBhcyBwcmVkaWN0ZWQgbmV4dCBhdWRpbyBQVFNcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gTWF0aC5tYXgoMCwgdGltZU9mZnNldE1wZWdUUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBmcmFncyBhcmUgbm90IGNvbnRpZ3VvdXMgYW5kIGlmIHdlIGNhbnQgdHJ1c3QgdGltZSBvZmZzZXQsIGxldCdzIHVzZSBmaXJzdCBzYW1wbGUgUFRTIGFzIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IGlucHV0U2FtcGxlc1swXS5wdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGF1ZGlvIHRyYWNrIGlzIG1pc3Npbmcgc2FtcGxlcywgdGhlIGZyYW1lcyBzZWVtIHRvIGdldCBcImxlZnQtc2hpZnRlZFwiIHdpdGhpbiB0aGVcbiAgICAvLyByZXN1bHRpbmcgbXA0IHNlZ21lbnQsIGNhdXNpbmcgc3luYyBpc3N1ZXMgYW5kIGxlYXZpbmcgZ2FwcyBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBzZWdtZW50LlxuICAgIC8vIEluIGFuIGVmZm9ydCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmcsIHdlIGluamVjdCBmcmFtZXMgaGVyZSB3aGVyZSB0aGVyZSBhcmUgZ2Fwcy5cbiAgICAvLyBXaGVuIHBvc3NpYmxlLCB3ZSBpbmplY3QgYSBzaWxlbnQgZnJhbWU7IHdoZW4gdGhhdCdzIG5vdCBwb3NzaWJsZSwgd2UgZHVwbGljYXRlIHRoZSBsYXN0XG4gICAgLy8gZnJhbWUuXG5cbiAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgY29uc3QgbWF4QXVkaW9GcmFtZXNEcmlmdCA9IHRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQ7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbmV4dFB0cyA9IG5leHRBdWRpb1B0czsgaSA8IGlucHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBGaXJzdCwgbGV0J3Mgc2VlIGhvdyBmYXIgb2ZmIHRoaXMgZnJhbWUgaXMgZnJvbSB3aGVyZSB3ZSBleHBlY3QgaXQgdG8gYmVcbiAgICAgICAgY29uc3Qgc2FtcGxlID0gaW5wdXRTYW1wbGVzW2ldO1xuICAgICAgICBjb25zdCBwdHMgPSBzYW1wbGUucHRzO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHB0cyAtIG5leHRQdHM7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnMoKDEwMDAgKiBkZWx0YSkgLyBpbnB1dFRpbWVTY2FsZSk7XG5cbiAgICAgICAgLy8gV2hlbiByZW11eGluZyB3aXRoIHZpZGVvLCBpZiB3ZSdyZSBvdmVybGFwcGluZyBieSBtb3JlIHRoYW4gYSBkdXJhdGlvbiwgZHJvcCB0aGlzIHNhbXBsZSB0byBzdGF5IGluIHN5bmNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRlbHRhIDw9IC1tYXhBdWRpb0ZyYW1lc0RyaWZ0ICogaW5wdXRTYW1wbGVEdXJhdGlvbiAmJlxuICAgICAgICAgIGFsaWduZWRXaXRoVmlkZW9cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgICBgQXVkaW8gZnJhbWUgQCAkeyhwdHMgLyBpbnB1dFRpbWVTY2FsZSkudG9GaXhlZChcbiAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICApfXMgb3ZlcmxhcHMgbmV4dEF1ZGlvUHRzIGJ5ICR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAoMTAwMCAqIGRlbHRhKSAvIGlucHV0VGltZVNjYWxlLFxuICAgICAgICAgICAgICApfSBtcy5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cyA9IHB0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBicmFjZS1zdHlsZVxuXG4gICAgICAgIC8vIEluc2VydCBtaXNzaW5nIGZyYW1lcyBpZjpcbiAgICAgICAgLy8gMTogV2UncmUgbW9yZSB0aGFuIG1heEF1ZGlvRnJhbWVzRHJpZnQgZnJhbWUgYXdheVxuICAgICAgICAvLyAyOiBOb3QgbW9yZSB0aGFuIE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gYXdheVxuICAgICAgICAvLyAzOiBjdXJyZW50VGltZSAoYWthIG5leHRQdHNOb3JtKSBpcyBub3QgMFxuICAgICAgICAvLyA0OiByZW11eGluZyB3aXRoIHZpZGVvICh2aWRlb1RpbWVPZmZzZXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgZGVsdGEgPj0gbWF4QXVkaW9GcmFtZXNEcmlmdCAqIGlucHV0U2FtcGxlRHVyYXRpb24gJiZcbiAgICAgICAgICBkdXJhdGlvbiA8IE1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04gJiZcbiAgICAgICAgICBhbGlnbmVkV2l0aFZpZGVvXG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBtaXNzaW5nID0gTWF0aC5yb3VuZChkZWx0YSAvIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgICAgIC8vIEFkanVzdCBuZXh0UHRzIHNvIHRoYXQgc2lsZW50IHNhbXBsZXMgYXJlIGFsaWduZWQgd2l0aCBtZWRpYSBwdHMuIFRoaXMgd2lsbCBwcmV2ZW50IG1lZGlhIHNhbXBsZXMgZnJvbVxuICAgICAgICAgIC8vIGxhdGVyIGJlaW5nIHNoaWZ0ZWQgaWYgbmV4dFB0cyBpcyBiYXNlZCBvbiB0aW1lT2Zmc2V0IGFuZCBkZWx0YSBpcyBub3QgYSBtdWx0aXBsZSBvZiBpbnB1dFNhbXBsZUR1cmF0aW9uLlxuICAgICAgICAgIG5leHRQdHMgPSBwdHMgLSBtaXNzaW5nICogaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICBpZiAobmV4dFB0cyA8IDApIHtcbiAgICAgICAgICAgIG1pc3NpbmctLTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbmV4dFB0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgW21wNC1yZW11eGVyXTogSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWUgQCAkeyhcbiAgICAgICAgICAgICAgbmV4dFB0cyAvIGlucHV0VGltZVNjYWxlXG4gICAgICAgICAgICApLnRvRml4ZWQoMyl9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAoMTAwMCAqIGRlbHRhKSAvIGlucHV0VGltZVNjYWxlLFxuICAgICAgICAgICAgKX0gbXMgZ2FwLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1pc3Npbmc7IGorKykge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhbXAgPSBNYXRoLm1heChuZXh0UHRzIGFzIG51bWJlciwgMCk7XG4gICAgICAgICAgICBsZXQgZmlsbEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKFxuICAgICAgICAgICAgICB0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLFxuICAgICAgICAgICAgICB0cmFjay5jaGFubmVsQ291bnQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcbiAgICAgICAgICAgICAgICAnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmlsbEZyYW1lID0gc2FtcGxlLnVuaXQuc3ViYXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0U2FtcGxlcy5zcGxpY2UoaSwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBmaWxsRnJhbWUsXG4gICAgICAgICAgICAgIHB0czogbmV3U3RhbXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlLnB0cyA9IG5leHRQdHM7XG4gICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0UFRTOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbGFzdFBUUzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IG1kYXQ6IGFueTtcbiAgICBsZXQgbWRhdFNpemU6IG51bWJlciA9IDA7XG4gICAgbGV0IHNhbXBsZUxlbmd0aDogbnVtYmVyID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIG5iU2FtcGxlcyA9IGlucHV0U2FtcGxlcy5sZW5ndGg7IGogPCBuYlNhbXBsZXM7IGorKykge1xuICAgICAgY29uc3QgYXVkaW9TYW1wbGUgPSBpbnB1dFNhbXBsZXNbal07XG4gICAgICBjb25zdCB1bml0ID0gYXVkaW9TYW1wbGUudW5pdDtcbiAgICAgIGxldCBwdHMgPSBhdWRpb1NhbXBsZS5wdHM7XG4gICAgICBpZiAobGFzdFBUUyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCBzZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBzYW1wbGUgdG8gdGhlIFwicmVhbFwiIGR1cmF0aW9uOyB0aGUgUFRTIGRpZmYgd2l0aFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgc2FtcGxlXG4gICAgICAgIGNvbnN0IHByZXZTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW2ogLSAxXTtcbiAgICAgICAgcHJldlNhbXBsZS5kdXJhdGlvbiA9IE1hdGgucm91bmQoKHB0cyAtIGxhc3RQVFMpIC8gc2NhbGVGYWN0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgdHJhY2suc2VnbWVudENvZGVjID09PSAnYWFjJykge1xuICAgICAgICAgIC8vIHNldCBQVFMvRFRTIHRvIGV4cGVjdGVkIFBUUy9EVFNcbiAgICAgICAgICBwdHMgPSBuZXh0QXVkaW9QdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIG91ciBhdWRpb1NhbXBsZXNcbiAgICAgICAgZmlyc3RQVFMgPSBwdHM7XG4gICAgICAgIGlmIChtZGF0U2l6ZSA+IDApIHtcbiAgICAgICAgICAvKiBjb25jYXRlbmF0ZSB0aGUgYXVkaW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAgICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1kYXQgdHlwZSkgKi9cbiAgICAgICAgICBtZGF0U2l6ZSArPSBvZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyBhdWRpbyBtZGF0ICR7bWRhdFNpemV9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJhd01QRUcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbWRhdFNpemUpO1xuICAgICAgICAgICAgbWRhdC5zZXQoTVA0LnR5cGVzLm1kYXQsIDQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBhdWRpbyBzYW1wbGVzXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZGF0LnNldCh1bml0LCBvZmZzZXQpO1xuICAgICAgY29uc3QgdW5pdExlbiA9IHVuaXQuYnl0ZUxlbmd0aDtcbiAgICAgIG9mZnNldCArPSB1bml0TGVuO1xuICAgICAgLy8gRGVmYXVsdCB0aGUgc2FtcGxlJ3MgZHVyYXRpb24gdG8gdGhlIGNvbXB1dGVkIG1wNFNhbXBsZUR1cmF0aW9uLCB3aGljaCB3aWxsIGVpdGhlciBiZSAxMDI0IGZvciBBQUMgb3IgMTE1MiBmb3IgTVBFR1xuICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIDEgc2FtcGxlLCB0aGlzIHdpbGwgYmUgdGhlIGR1cmF0aW9uLiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgc2FtcGxlLCB0aGUgZHVyYXRpb25cbiAgICAgIC8vIGJlY29tZXMgdGhlIFBUUyBkaWZmIHdpdGggdGhlIHByZXZpb3VzIHNhbXBsZVxuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUodHJ1ZSwgbXA0U2FtcGxlRHVyYXRpb24sIHVuaXRMZW4sIDApKTtcbiAgICAgIGxhc3RQVFMgPSBwdHM7XG4gICAgfVxuXG4gICAgLy8gV2UgY291bGQgZW5kIHVwIHdpdGggbm8gYXVkaW8gc2FtcGxlcyBpZiBhbGwgaW5wdXQgc2FtcGxlcyB3ZXJlIG92ZXJsYXBwaW5nIHdpdGggdGhlIHByZXZpb3VzbHkgcmVtdXhlZCBvbmVzXG4gICAgY29uc3QgbmJTYW1wbGVzID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7XG4gICAgaWYgKCFuYlNhbXBsZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgbmV4dCBhdWRpbyBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBkdXJhdGlvblxuICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBvdXRwdXRTYW1wbGVzW291dHB1dFNhbXBsZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPVxuICAgICAgbGFzdFBUUyEgKyBzY2FsZUZhY3RvciAqIGxhc3RTYW1wbGUuZHVyYXRpb247XG5cbiAgICAvLyBTZXQgdGhlIHRyYWNrIHNhbXBsZXMgZnJvbSBpbnB1dFNhbXBsZXMgdG8gb3V0cHV0U2FtcGxlcyBiZWZvcmUgcmVtdXhpbmdcbiAgICBjb25zdCBtb29mID0gcmF3TVBFR1xuICAgICAgPyBuZXcgVWludDhBcnJheSgwKVxuICAgICAgOiBNUDQubW9vZihcbiAgICAgICAgICB0cmFjay5zZXF1ZW5jZU51bWJlcisrLFxuICAgICAgICAgIGZpcnN0UFRTISAvIHNjYWxlRmFjdG9yLFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRyYWNrLCB7IHNhbXBsZXM6IG91dHB1dFNhbXBsZXMgfSksXG4gICAgICAgICk7XG5cbiAgICAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSBmaXJzdFBUUyEgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBlbmQgPSBuZXh0QXVkaW9QdHMgLyBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCB0eXBlOiBTb3VyY2VCdWZmZXJOYW1lID0gJ2F1ZGlvJztcbiAgICBjb25zdCBhdWRpb0RhdGEgPSB7XG4gICAgICBkYXRhMTogbW9vZixcbiAgICAgIGRhdGEyOiBtZGF0LFxuICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgZW5kUFRTOiBlbmQsXG4gICAgICBzdGFydERUUzogc3RhcnQsXG4gICAgICBlbmREVFM6IGVuZCxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbzogdHJ1ZSxcbiAgICAgIGhhc1ZpZGVvOiBmYWxzZSxcbiAgICAgIG5iOiBuYlNhbXBsZXMsXG4gICAgfTtcblxuICAgIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSB0cnVlO1xuICAgIHJldHVybiBhdWRpb0RhdGE7XG4gIH1cblxuICByZW11eEVtcHR5QXVkaW8oXG4gICAgdHJhY2s6IERlbXV4ZWRBdWRpb1RyYWNrLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIHZpZGVvRGF0YTogRnJhZ21lbnQsXG4gICk6IFJlbXV4ZWRUcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaW5wdXRUaW1lU2NhbGU6IG51bWJlciA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZTogbnVtYmVyID0gdHJhY2suc2FtcGxlcmF0ZVxuICAgICAgPyB0cmFjay5zYW1wbGVyYXRlXG4gICAgICA6IGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yOiBudW1iZXIgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBuZXh0QXVkaW9QdHM6IG51bWJlciB8IG51bGwgPSB0aGlzLm5leHRBdWRpb1B0cztcbiAgICAvLyBzeW5jIHdpdGggdmlkZW8ncyB0aW1lc3RhbXBcbiAgICBjb25zdCBpbml0RFRTID0gdGhpcy5faW5pdERUUyBhcyBSYXRpb25hbFRpbWVzdGFtcDtcbiAgICBjb25zdCBpbml0OTBrSHogPSAoaW5pdERUUy5iYXNlVGltZSAqIDkwMDAwKSAvIGluaXREVFMudGltZXNjYWxlO1xuICAgIGNvbnN0IHN0YXJ0RFRTOiBudW1iZXIgPVxuICAgICAgKG5leHRBdWRpb1B0cyAhPT0gbnVsbFxuICAgICAgICA/IG5leHRBdWRpb1B0c1xuICAgICAgICA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIGluaXQ5MGtIejtcbiAgICBjb25zdCBlbmREVFM6IG51bWJlciA9IHZpZGVvRGF0YS5lbmREVFMgKiBpbnB1dFRpbWVTY2FsZSArIGluaXQ5MGtIejtcbiAgICAvLyBvbmUgc2FtcGxlJ3MgZHVyYXRpb24gdmFsdWVcbiAgICBjb25zdCBmcmFtZUR1cmF0aW9uOiBudW1iZXIgPSBzY2FsZUZhY3RvciAqIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICAvLyBzYW1wbGVzIGNvdW50IG9mIHRoaXMgc2VnbWVudCdzIGR1cmF0aW9uXG4gICAgY29uc3QgbmJTYW1wbGVzOiBudW1iZXIgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pO1xuICAgIC8vIHNpbGVudCBmcmFtZVxuICAgIGNvbnN0IHNpbGVudEZyYW1lOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkID0gQUFDLmdldFNpbGVudEZyYW1lKFxuICAgICAgdHJhY2subWFuaWZlc3RDb2RlYyB8fCB0cmFjay5jb2RlYyxcbiAgICAgIHRyYWNrLmNoYW5uZWxDb3VudCxcbiAgICApO1xuXG4gICAgbG9nZ2VyLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoXG4gICAgICAgICdbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWMnLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzYW1wbGVzOiBBcnJheTxhbnk+ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgY29uc3Qgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgc2FtcGxlcy5wdXNoKHsgdW5pdDogc2lsZW50RnJhbWUsIHB0czogc3RhbXAsIGR0czogc3RhbXAgfSk7XG4gICAgfVxuICAgIHRyYWNrLnNhbXBsZXMgPSBzYW1wbGVzO1xuXG4gICAgcmV0dXJuIHRoaXMucmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQdHModmFsdWU6IG51bWJlciwgcmVmZXJlbmNlOiBudW1iZXIgfCBudWxsKTogbnVtYmVyIHtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChyZWZlcmVuY2UgPCB2YWx1ZSkge1xuICAgIC8vIC0gMl4zM1xuICAgIG9mZnNldCA9IC04NTg5OTM0NTkyO1xuICB9IGVsc2Uge1xuICAgIC8vICsgMl4zM1xuICAgIG9mZnNldCA9IDg1ODk5MzQ1OTI7XG4gIH1cbiAgLyogUFRTIGlzIDMzYml0IChmcm9tIDAgdG8gMl4zMyAtMSlcbiAgICBpZiBkaWZmIGJldHdlZW4gdmFsdWUgYW5kIHJlZmVyZW5jZSBpcyBiaWdnZXIgdGhhbiBoYWxmIG9mIHRoZSBhbXBsaXR1ZGUgKDJeMzIpIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgIFBUUyBsb29waW5nIG9jY3VyZWQuIGZpbGwgdGhlIGdhcCAqL1xuICB3aGlsZSAoTWF0aC5hYnModmFsdWUgLSByZWZlcmVuY2UpID4gNDI5NDk2NzI5Nikge1xuICAgIHZhbHVlICs9IG9mZnNldDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmluZEtleWZyYW1lSW5kZXgoc2FtcGxlczogQXJyYXk8VmlkZW9TYW1wbGU+KTogbnVtYmVyIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXMoXG4gIHRyYWNrOiBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCxcbiAgaW5pdERUUzogUmF0aW9uYWxUaW1lc3RhbXAsXG4pOiBSZW11eGVkTWV0YWRhdGEgfCB1bmRlZmluZWQge1xuICBjb25zdCBsZW5ndGggPSB0cmFjay5zYW1wbGVzLmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXRUaW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbaW5kZXhdO1xuICAgIC8vIHNldHRpbmcgaWQzIHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9XG4gICAgICBub3JtYWxpemVQdHMoXG4gICAgICAgIHNhbXBsZS5wdHMgLSAoaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlKSAvIGluaXRQVFMudGltZXNjYWxlLFxuICAgICAgICB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUsXG4gICAgICApIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgc2FtcGxlLmR0cyA9XG4gICAgICBub3JtYWxpemVQdHMoXG4gICAgICAgIHNhbXBsZS5kdHMgLSAoaW5pdERUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlKSAvIGluaXREVFMudGltZXNjYWxlLFxuICAgICAgICB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUsXG4gICAgICApIC8gaW5wdXRUaW1lU2NhbGU7XG4gIH1cbiAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXM7XG4gIHRyYWNrLnNhbXBsZXMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBzYW1wbGVzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tVc2VyZGF0YUN1ZVNhbXBsZXMoXG4gIHRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgdGltZU9mZnNldDogbnVtYmVyLFxuICBpbml0UFRTOiBSYXRpb25hbFRpbWVzdGFtcCxcbik6IFJlbXV4ZWRVc2VyZGF0YSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIHRleHQgcHRzLCBkdHMgdG8gcmVsYXRpdmUgdGltZVxuICAgIC8vIHVzaW5nIHRoaXMuX2luaXRQVFMgYW5kIHRoaXMuX2luaXREVFMgdG8gY2FsY3VsYXRlIHJlbGF0aXZlIHRpbWVcbiAgICBzYW1wbGUucHRzID1cbiAgICAgIG5vcm1hbGl6ZVB0cyhcbiAgICAgICAgc2FtcGxlLnB0cyAtIChpbml0UFRTLmJhc2VUaW1lICogaW5wdXRUaW1lU2NhbGUpIC8gaW5pdFBUUy50aW1lc2NhbGUsXG4gICAgICAgIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSxcbiAgICAgICkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB0cmFjay5zYW1wbGVzLnNvcnQoKGEsIGIpID0+IGEucHRzIC0gYi5wdHMpO1xuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXMsXG4gIH07XG59XG5cbnR5cGUgTXA0U2FtcGxlRmxhZ3MgPSB7XG4gIGlzTGVhZGluZzogMDtcbiAgaXNEZXBlbmRlZE9uOiAwO1xuICBoYXNSZWR1bmRhbmN5OiAwO1xuICBkZWdyYWRQcmlvOiAwO1xuICBkZXBlbmRzT246IDEgfCAyO1xuICBpc05vblN5bmM6IDAgfCAxO1xufTtcblxuY2xhc3MgTXA0U2FtcGxlIHtcbiAgcHVibGljIHNpemU6IG51bWJlcjtcbiAgcHVibGljIGR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBjdHM6IG51bWJlcjtcbiAgcHVibGljIGZsYWdzOiBNcDRTYW1wbGVGbGFncztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBpc0tleWZyYW1lOiBib29sZWFuLFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGN0czogbnVtYmVyLFxuICApIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmN0cyA9IGN0cztcbiAgICB0aGlzLmZsYWdzID0ge1xuICAgICAgaXNMZWFkaW5nOiAwLFxuICAgICAgaXNEZXBlbmRlZE9uOiAwLFxuICAgICAgaGFzUmVkdW5kYW5jeTogMCxcbiAgICAgIGRlZ3JhZFByaW86IDAsXG4gICAgICBkZXBlbmRzT246IGlzS2V5ZnJhbWUgPyAyIDogMSxcbiAgICAgIGlzTm9uU3luYzogaXNLZXlmcmFtZSA/IDAgOiAxLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzLFxuICBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyxcbn0gZnJvbSAnLi9tcDQtcmVtdXhlcic7XG5pbXBvcnQge1xuICBJbml0RGF0YSxcbiAgSW5pdERhdGFUcmFjayxcbiAgcGF0Y2hFbmN5cHRpb25EYXRhLFxufSBmcm9tICcuLi91dGlscy9tcDQtdG9vbHMnO1xuaW1wb3J0IHtcbiAgZ2V0RHVyYXRpb24sXG4gIGdldFN0YXJ0RFRTLFxuICBvZmZzZXRTdGFydERUUyxcbiAgcGFyc2VJbml0U2VnbWVudCxcbn0gZnJvbSAnLi4vdXRpbHMvbXA0LXRvb2xzJztcbmltcG9ydCB7IEVsZW1lbnRhcnlTdHJlYW1UeXBlcyB9IGZyb20gJy4uL2xvYWRlci9mcmFnbWVudCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgZ2V0Q29kZWNDb21wYXRpYmxlTmFtZSB9IGZyb20gJy4uL3V0aWxzL2NvZGVjcyc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBJbml0U2VnbWVudERhdGEsXG4gIFJlbXV4ZWRUcmFjayxcbiAgUmVtdXhlcixcbiAgUmVtdXhlclJlc3VsdCxcbn0gZnJvbSAnLi4vdHlwZXMvcmVtdXhlcic7XG5pbXBvcnQgdHlwZSB7XG4gIERlbXV4ZWRBdWRpb1RyYWNrLFxuICBEZW11eGVkTWV0YWRhdGFUcmFjayxcbiAgRGVtdXhlZFVzZXJkYXRhVHJhY2ssXG4gIFBhc3N0aHJvdWdoVHJhY2ssXG59IGZyb20gJy4uL3R5cGVzL2RlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBEZWNyeXB0RGF0YSB9IGZyb20gJy4uL2xvYWRlci9sZXZlbC1rZXknO1xuaW1wb3J0IHR5cGUgeyBSYXRpb25hbFRpbWVzdGFtcCB9IGZyb20gJy4uL3V0aWxzL3RpbWVzY2FsZS1jb252ZXJzaW9uJztcblxuY2xhc3MgUGFzc1Rocm91Z2hSZW11eGVyIGltcGxlbWVudHMgUmVtdXhlciB7XG4gIHByaXZhdGUgZW1pdEluaXRTZWdtZW50OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYXVkaW9Db2RlYz86IHN0cmluZztcbiAgcHJpdmF0ZSB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICBwcml2YXRlIGluaXREYXRhPzogSW5pdERhdGE7XG4gIHByaXZhdGUgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbml0VHJhY2tzPzogVHJhY2tTZXQ7XG4gIHByaXZhdGUgbGFzdEVuZFRpbWU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIHB1YmxpYyBkZXN0cm95KCkge31cblxuICBwdWJsaWMgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQVFM6IFJhdGlvbmFsVGltZXN0YW1wIHwgbnVsbCkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldEluaXRTZWdtZW50KFxuICAgIGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbiAgKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChwYXRjaEVuY3lwdGlvbkRhdGEoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKSk7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUluaXRTZWdtZW50KGluaXRTZWdtZW50OiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgbGV0IHsgYXVkaW9Db2RlYywgdmlkZW9Db2RlYyB9ID0gdGhpcztcbiAgICBpZiAoIWluaXRTZWdtZW50Py5ieXRlTGVuZ3RoKSB7XG4gICAgICB0aGlzLmluaXRUcmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmluaXREYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0RGF0YSA9ICh0aGlzLmluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCkpO1xuXG4gICAgLy8gR2V0IGNvZGVjIGZyb20gaW5pdFNlZ21lbnQgb3IgZmFsbGJhY2sgdG8gZGVmYXVsdFxuICAgIGlmIChpbml0RGF0YS5hdWRpbykge1xuICAgICAgYXVkaW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoXG4gICAgICAgIGluaXREYXRhLmF1ZGlvLFxuICAgICAgICBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8sXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdmlkZW9Db2RlYyA9IGdldFBhcnNlZFRyYWNrQ29kZWMoXG4gICAgICAgIGluaXREYXRhLnZpZGVvLFxuICAgICAgICBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8sXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrczogVHJhY2tTZXQgPSB7fTtcbiAgICBpZiAoaW5pdERhdGEuYXVkaW8gJiYgaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy5hdWRpb3ZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogYXVkaW9Db2RlYyArICcsJyArIHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbycsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaW5pdERhdGEudmlkZW8pIHtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvQ29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50LFxuICAgICAgICBpZDogJ21haW4nLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicsXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH1cblxuICBwdWJsaWMgcmVtdXgoXG4gICAgYXVkaW9UcmFjazogRGVtdXhlZEF1ZGlvVHJhY2ssXG4gICAgdmlkZW9UcmFjazogUGFzc3Rocm91Z2hUcmFjayxcbiAgICBpZDNUcmFjazogRGVtdXhlZE1ldGFkYXRhVHJhY2ssXG4gICAgdGV4dFRyYWNrOiBEZW11eGVkVXNlcmRhdGFUcmFjayxcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBib29sZWFuLFxuICApOiBSZW11eGVyUmVzdWx0IHtcbiAgICBsZXQgeyBpbml0UFRTLCBsYXN0RW5kVGltZSB9ID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQ6IFJlbXV4ZXJSZXN1bHQgPSB7XG4gICAgICBhdWRpbzogdW5kZWZpbmVkLFxuICAgICAgdmlkZW86IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHRleHRUcmFjayxcbiAgICAgIGlkMzogaWQzVHJhY2ssXG4gICAgICBpbml0U2VnbWVudDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsYXN0RW5kVGltZSEpKSB7XG4gICAgICBsYXN0RW5kVGltZSA9IHRoaXMubGFzdEVuZFRpbWUgPSB0aW1lT2Zmc2V0IHx8IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGJpbmFyeSBzZWdtZW50IGRhdGEgaXMgYWRkZWQgdG8gdGhlIHZpZGVvVHJhY2sgaW4gdGhlIG1wNGRlbXV4ZXIuIFdlIGRvbid0IGNoZWNrIHRvIHNlZSBpZiB0aGUgZGF0YSBpcyBvbmx5XG4gICAgLy8gYXVkaW8gb3IgdmlkZW8gKG9yIGJvdGgpOyBhZGRpbmcgaXQgdG8gdmlkZW8gd2FzIGFuIGFyYml0cmFyeSBjaG9pY2UuXG4gICAgY29uc3QgZGF0YSA9IHZpZGVvVHJhY2suc2FtcGxlcztcbiAgICBpZiAoIWRhdGE/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0U2VnbWVudDogSW5pdFNlZ21lbnREYXRhID0ge1xuICAgICAgaW5pdFBUUzogdW5kZWZpbmVkLFxuICAgICAgdGltZXNjYWxlOiAxLFxuICAgIH07XG4gICAgbGV0IGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoIWluaXREYXRhPy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkYXRhKTtcbiAgICAgIGluaXREYXRhID0gdGhpcy5pbml0RGF0YTtcbiAgICB9XG4gICAgaWYgKCFpbml0RGF0YT8ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgbG9nZ2VyLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3MgYXMgVHJhY2tTZXQ7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpO1xuICAgIGNvbnN0IHN0YXJ0RFRTID0gZ2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZVRpbWUgPSBzdGFydERUUyA9PT0gbnVsbCA/IHRpbWVPZmZzZXQgOiBzdGFydERUUztcbiAgICBpZiAoXG4gICAgICBpc0ludmFsaWRJbml0UHRzKGluaXRQVFMsIGRlY29kZVRpbWUsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB8fFxuICAgICAgKGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUgJiYgYWNjdXJhdGVUaW1lT2Zmc2V0KVxuICAgICkge1xuICAgICAgaW5pdFNlZ21lbnQuaW5pdFBUUyA9IGRlY29kZVRpbWUgLSB0aW1lT2Zmc2V0O1xuICAgICAgaWYgKGluaXRQVFMgJiYgaW5pdFBUUy50aW1lc2NhbGUgPT09IDEpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgYEFkanVzdGluZyBpbml0UFRTIGJ5ICR7aW5pdFNlZ21lbnQuaW5pdFBUUyAtIGluaXRQVFMuYmFzZVRpbWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IDEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2tcbiAgICAgID8gZGVjb2RlVGltZSAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZVxuICAgICAgOiAobGFzdEVuZFRpbWUgYXMgbnVtYmVyKTtcbiAgICBjb25zdCBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGRhdGEsIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZSk7XG5cbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmxhc3RFbmRUaW1lID0gZW5kVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oJ0R1cmF0aW9uIHBhcnNlZCBmcm9tIG1wNCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgIHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcblxuICAgIGxldCB0eXBlOiBhbnkgPSAnJztcbiAgICBpZiAoaGFzQXVkaW8pIHtcbiAgICAgIHR5cGUgKz0gJ2F1ZGlvJztcbiAgICB9XG5cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG5cbiAgICBjb25zdCB0cmFjazogUmVtdXhlZFRyYWNrID0ge1xuICAgICAgZGF0YTE6IGRhdGEsXG4gICAgICBzdGFydFBUUzogc3RhcnRUaW1lLFxuICAgICAgc3RhcnREVFM6IHN0YXJ0VGltZSxcbiAgICAgIGVuZFBUUzogZW5kVGltZSxcbiAgICAgIGVuZERUUzogZW5kVGltZSxcbiAgICAgIHR5cGUsXG4gICAgICBoYXNBdWRpbyxcbiAgICAgIGhhc1ZpZGVvLFxuICAgICAgbmI6IDEsXG4gICAgICBkcm9wcGVkOiAwLFxuICAgIH07XG5cbiAgICByZXN1bHQuYXVkaW8gPSB0cmFjay50eXBlID09PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LnZpZGVvID0gdHJhY2sudHlwZSAhPT0gJ2F1ZGlvJyA/IHRyYWNrIDogdW5kZWZpbmVkO1xuICAgIHJlc3VsdC5pbml0U2VnbWVudCA9IGluaXRTZWdtZW50O1xuICAgIHJlc3VsdC5pZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRQVFMsXG4gICAgICBpbml0UFRTLFxuICAgICk7XG5cbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQudGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKFxuICAgICAgICB0ZXh0VHJhY2ssXG4gICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgIGluaXRQVFMsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbnZhbGlkSW5pdFB0cyhcbiAgaW5pdFBUUzogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsLFxuICBzdGFydERUUzogbnVtYmVyLFxuICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4pOiBpbml0UFRTIGlzIG51bGwge1xuICBpZiAoaW5pdFBUUyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIEluaXRQVFMgaXMgaW52YWxpZCB3aGVuIGRpc3RhbmNlIGZyb20gcHJvZ3JhbSB3b3VsZCBiZSBtb3JlIHRoYW4gc2VnbWVudCBkdXJhdGlvbiBvciBhIG1pbmltdW0gb2Ygb25lIHNlY29uZFxuICBjb25zdCBtaW5EdXJhdGlvbiA9IE1hdGgubWF4KGR1cmF0aW9uLCAxKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gc3RhcnREVFMgLSBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gIHJldHVybiBNYXRoLmFicyhzdGFydFRpbWUgLSB0aW1lT2Zmc2V0KSA+IG1pbkR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKFxuICB0cmFjazogSW5pdERhdGFUcmFjayxcbiAgdHlwZTogRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIHwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPLFxuKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyc2VkQ29kZWMgPSB0cmFjaz8uY29kZWM7XG4gIGlmIChwYXJzZWRDb2RlYyAmJiBwYXJzZWRDb2RlYy5sZW5ndGggPiA0KSB7XG4gICAgcmV0dXJuIHBhcnNlZENvZGVjO1xuICB9XG4gIGlmICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8pIHtcbiAgICBpZiAoXG4gICAgICBwYXJzZWRDb2RlYyA9PT0gJ2VjLTMnIHx8XG4gICAgICBwYXJzZWRDb2RlYyA9PT0gJ2FjLTMnIHx8XG4gICAgICBwYXJzZWRDb2RlYyA9PT0gJ2FsYWMnXG4gICAgKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gICAgfVxuICAgIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2ZMYUMnIHx8IHBhcnNlZENvZGVjID09PSAnT3B1cycpIHtcbiAgICAgIC8vIE9wdGluZyBub3QgdG8gZ2V0IGBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2VgIGZyb20gcGxheWVyIGNvbmZpZyBmb3IgaXNTdXBwb3J0ZWQoKSBjaGVjayBmb3Igc2ltcGxpY2l0eVxuICAgICAgY29uc3QgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShwYXJzZWRDb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gJ21wNGEuNDAuNSc7XG4gICAgbG9nZ2VyLmluZm8oXG4gICAgICBgUGFyc2VkIGF1ZGlvIGNvZGVjIFwiJHtwYXJzZWRDb2RlY31cIiBvciBhdWRpbyBvYmplY3QgdHlwZSBub3QgaGFuZGxlZC4gVXNpbmcgXCIke3Jlc3VsdH1cImAsXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgbG9nZ2VyLndhcm4oYFVuaGFuZGxlZCB2aWRlbyBjb2RlYyBcIiR7cGFyc2VkQ29kZWN9XCJgKTtcbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLjYuTDEyMC45MCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG4gIHJldHVybiAnYXZjMS40MmUwMWUnO1xufVxuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2hSZW11eGVyO1xuIiwiLyoqIHJldHVybnMgYHVuZGVmaW5lZGAgaXMgYHNlbGZgIGlzIG1pc3NpbmcsIGUuZy4gaW4gbm9kZSAqL1xuZXhwb3J0IGNvbnN0IG9wdGlvbmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCBEZWNyeXB0ZXIgZnJvbSAnLi4vY3J5cHQvZGVjcnlwdGVyJztcbmltcG9ydCBBQUNEZW11eGVyIGZyb20gJy4vYXVkaW8vYWFjZGVtdXhlcic7XG5pbXBvcnQgTVA0RGVtdXhlciBmcm9tICcuLi9kZW11eC9tcDRkZW11eGVyJztcbmltcG9ydCBUU0RlbXV4ZXIsIHsgVHlwZVN1cHBvcnRlZCB9IGZyb20gJy4uL2RlbXV4L3RzZGVtdXhlcic7XG5pbXBvcnQgTVAzRGVtdXhlciBmcm9tICcuL2F1ZGlvL21wM2RlbXV4ZXInO1xuaW1wb3J0IHsgQUMzRGVtdXhlciB9IGZyb20gJy4vYXVkaW8vYWMzLWRlbXV4ZXInO1xuaW1wb3J0IE1QNFJlbXV4ZXIgZnJvbSAnLi4vcmVtdXgvbXA0LXJlbXV4ZXInO1xuaW1wb3J0IFBhc3NUaHJvdWdoUmVtdXhlciBmcm9tICcuLi9yZW11eC9wYXNzdGhyb3VnaC1yZW11eGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IERlbXV4ZXIsIERlbXV4ZXJSZXN1bHQsIEtleURhdGEgfSBmcm9tICcuLi90eXBlcy9kZW11eGVyJztcbmltcG9ydCB0eXBlIHsgUmVtdXhlciB9IGZyb20gJy4uL3R5cGVzL3JlbXV4ZXInO1xuaW1wb3J0IHR5cGUgeyBUcmFuc211eGVyUmVzdWx0LCBDaHVua01ldGFkYXRhIH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IERlY3J5cHREYXRhIH0gZnJvbSAnLi4vbG9hZGVyL2xldmVsLWtleSc7XG5pbXBvcnQgdHlwZSB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5pbXBvcnQgeyBvcHRpb25hbFNlbGYgfSBmcm9tICcuLi91dGlscy9nbG9iYWwnO1xuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBvcHRpb25hbFNlbGY/LkRhdGUubm93O1xufVxuXG50eXBlIE11eENvbmZpZyA9XG4gIHwgeyBkZW11eDogdHlwZW9mIE1QNERlbXV4ZXI7IHJlbXV4OiB0eXBlb2YgUGFzc1Rocm91Z2hSZW11eGVyIH1cbiAgfCB7IGRlbXV4OiB0eXBlb2YgVFNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfVxuICB8IHsgZGVtdXg6IHR5cGVvZiBBQzNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfVxuICB8IHsgZGVtdXg6IHR5cGVvZiBBQUNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfVxuICB8IHsgZGVtdXg6IHR5cGVvZiBNUDNEZW11eGVyOyByZW11eDogdHlwZW9mIE1QNFJlbXV4ZXIgfTtcblxuY29uc3QgbXV4Q29uZmlnOiBNdXhDb25maWdbXSA9IFtcbiAgeyBkZW11eDogTVA0RGVtdXhlciwgcmVtdXg6IFBhc3NUaHJvdWdoUmVtdXhlciB9LFxuICB7IGRlbXV4OiBUU0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gIHsgZGVtdXg6IEFBQ0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG4gIHsgZGVtdXg6IE1QM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0sXG5dO1xuXG5pZiAoX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfXykge1xuICBtdXhDb25maWcuc3BsaWNlKDIsIDAsIHsgZGVtdXg6IEFDM0RlbXV4ZXIsIHJlbXV4OiBNUDRSZW11eGVyIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc211eGVyIHtcbiAgcHVibGljIGFzeW5jOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgb2JzZXJ2ZXI6IEhsc0V2ZW50RW1pdHRlcjtcbiAgcHJpdmF0ZSB0eXBlU3VwcG9ydGVkOiBUeXBlU3VwcG9ydGVkO1xuICBwcml2YXRlIGNvbmZpZzogSGxzQ29uZmlnO1xuICBwcml2YXRlIHZlbmRvcjogc3RyaW5nO1xuICBwcml2YXRlIGlkOiBQbGF5bGlzdExldmVsVHlwZTtcbiAgcHJpdmF0ZSBkZW11eGVyPzogRGVtdXhlcjtcbiAgcHJpdmF0ZSByZW11eGVyPzogUmVtdXhlcjtcbiAgcHJpdmF0ZSBkZWNyeXB0ZXI/OiBEZWNyeXB0ZXI7XG4gIHByaXZhdGUgcHJvYmUhOiBGdW5jdGlvbjtcbiAgcHJpdmF0ZSBkZWNyeXB0aW9uUHJvbWlzZTogUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHRyYW5zbXV4Q29uZmlnITogVHJhbnNtdXhDb25maWc7XG4gIHByaXZhdGUgY3VycmVudFRyYW5zbXV4U3RhdGUhOiBUcmFuc211eFN0YXRlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXIsXG4gICAgdHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZCxcbiAgICBjb25maWc6IEhsc0NvbmZpZyxcbiAgICB2ZW5kb3I6IHN0cmluZyxcbiAgICBpZDogUGxheWxpc3RMZXZlbFR5cGUsXG4gICkge1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB0eXBlU3VwcG9ydGVkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudmVuZG9yID0gdmVuZG9yO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuXG4gIGNvbmZpZ3VyZSh0cmFuc211eENvbmZpZzogVHJhbnNtdXhDb25maWcpIHtcbiAgICB0aGlzLnRyYW5zbXV4Q29uZmlnID0gdHJhbnNtdXhDb25maWc7XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goXG4gICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICAgc3RhdGU/OiBUcmFuc211eFN0YXRlLFxuICApOiBUcmFuc211eGVyUmVzdWx0IHwgUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG5cbiAgICBsZXQgdWludERhdGE6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICBjb25zdCB7IGN1cnJlbnRUcmFuc211eFN0YXRlLCB0cmFuc211eENvbmZpZyB9ID0gdGhpcztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBjb250aWd1b3VzLFxuICAgICAgZGlzY29udGludWl0eSxcbiAgICAgIHRyYWNrU3dpdGNoLFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRTZWdtZW50Q2hhbmdlLFxuICAgIH0gPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlZmF1bHRJbml0UHRzLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgfSA9IHRyYW5zbXV4Q29uZmlnO1xuXG4gICAgY29uc3Qga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgY29uc3QgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTtcbiAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgc3luY2hyb25vdXM7IHdlYkNyeXB0byBpcyBub3RcbiAgICAgIGlmIChkZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAgICAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgICAgICAgbGV0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuc29mdHdhcmVEZWNyeXB0KFxuICAgICAgICAgIHVpbnREYXRhLFxuICAgICAgICAgIGtleURhdGEua2V5LmJ1ZmZlcixcbiAgICAgICAgICBrZXlEYXRhLml2LmJ1ZmZlcixcbiAgICAgICAgKTtcbiAgICAgICAgLy8gRm9yIExvdy1MYXRlbmN5IEhMUyBQYXJ0cywgZGVjcnlwdCBpbiBwbGFjZSwgc2luY2UgcGFydCBwYXJzaW5nIGlzIGV4cGVjdGVkIG9uIHB1c2ggcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXJcbiAgICAgICAgICAud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcilcbiAgICAgICAgICAudGhlbigoZGVjcnlwdGVkRGF0YSk6IFRyYW5zbXV4ZXJSZXN1bHQgPT4ge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyBwdXNoIGhlcmUgaXMgaW1wb3J0YW50OyBpZiBmbHVzaCgpIGlzIGNhbGxlZCB3aGlsZSB0aGlzIGlzIHN0aWxsIHJlc29sdmluZywgdGhpcyBlbnN1cmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnB1c2goXG4gICAgICAgICAgICAgIGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICAgICkgYXMgVHJhbnNtdXhlclJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2UhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc2V0TXV4ZXJzID0gdGhpcy5uZWVkc1Byb2JpbmcoZGlzY29udGludWl0eSwgdHJhY2tTd2l0Y2gpO1xuICAgIGlmIChyZXNldE11eGVycykge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIodWludERhdGEpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2ggfHwgaW5pdFNlZ21lbnRDaGFuZ2UgfHwgcmVzZXRNdXhlcnMpIHtcbiAgICAgIHRoaXMucmVzZXRJbml0U2VnbWVudChcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb250aWd1b3VzKSB7XG4gICAgICB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJhbnNtdXgoXG4gICAgICB1aW50RGF0YSxcbiAgICAgIGtleURhdGEsXG4gICAgICB0aW1lT2Zmc2V0LFxuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgY2h1bmtNZXRhLFxuICAgICk7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcblxuICAgIGN1cnJlbnRTdGF0ZS5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuXG4gICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBEdWUgdG8gZGF0YSBjYWNoaW5nLCBmbHVzaCBjYWxscyBjYW4gcHJvZHVjZSBtb3JlIHRoYW4gb25lIFRyYW5zbXV4ZXJSZXN1bHQgKGhlbmNlIHRoZSBBcnJheSB0eXBlKVxuICBmbHVzaChcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICk6IFRyYW5zbXV4ZXJSZXN1bHRbXSB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdFtdPiB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG5cbiAgICBjb25zdCB7IGRlY3J5cHRlciwgY3VycmVudFRyYW5zbXV4U3RhdGUsIGRlY3J5cHRpb25Qcm9taXNlIH0gPSB0aGlzO1xuXG4gICAgaWYgKGRlY3J5cHRpb25Qcm9taXNlKSB7XG4gICAgICAvLyBVcG9uIHJlc29sdXRpb24sIHRoZSBkZWNyeXB0aW9uIHByb21pc2UgY2FsbHMgcHVzaCgpIGFuZCByZXR1cm5zIGl0cyBUcmFuc211eGVyUmVzdWx0IHVwIHRoZSBzdGFjay4gVGhlcmVmb3JlXG4gICAgICAvLyBvbmx5IGZsdXNoaW5nIGlzIHJlcXVpcmVkIGZvciBhc3luYyBkZWNyeXB0aW9uXG4gICAgICByZXR1cm4gZGVjcnlwdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc211eFJlc3VsdHM6IFRyYW5zbXV4ZXJSZXN1bHRbXSA9IFtdO1xuICAgIGNvbnN0IHsgdGltZU9mZnNldCB9ID0gY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goXG4gICAgICAgICAgdGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkgYXMgVHJhbnNtdXhlclJlc3VsdCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGRlbXV4ZXIsIHJlbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICAvLyBJZiBwcm9iaW5nIGZhaWxlZCwgdGhlbiBIbHMuanMgaGFzIGJlZW4gZ2l2ZW4gY29udGVudCBpdHMgbm90IGFibGUgdG8gaGFuZGxlXG4gICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICByZXR1cm4gW2VtcHR5UmVzdWx0KGNodW5rTWV0YSldO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbXV4UmVzdWx0T3JQcm9taXNlID0gZGVtdXhlci5mbHVzaCh0aW1lT2Zmc2V0KTtcbiAgICBpZiAoaXNQcm9taXNlKGRlbXV4UmVzdWx0T3JQcm9taXNlKSkge1xuICAgICAgLy8gRGVjcnlwdCBmaW5hbCBTQU1QTEUtQUVTIHNhbXBsZXNcbiAgICAgIHJldHVybiBkZW11eFJlc3VsdE9yUHJvbWlzZS50aGVuKChkZW11eFJlc3VsdCkgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmx1c2hSZW11eCh0cmFuc211eFJlc3VsdHMsIGRlbXV4UmVzdWx0T3JQcm9taXNlLCBjaHVua01ldGEpO1xuICAgIHJldHVybiB0cmFuc211eFJlc3VsdHM7XG4gIH1cblxuICBwcml2YXRlIGZsdXNoUmVtdXgoXG4gICAgdHJhbnNtdXhSZXN1bHRzOiBUcmFuc211eGVyUmVzdWx0W10sXG4gICAgZGVtdXhSZXN1bHQ6IERlbXV4ZXJSZXN1bHQsXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICApIHtcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2sgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHsgYWNjdXJhdGVUaW1lT2Zmc2V0LCB0aW1lT2Zmc2V0IH0gPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGxvZ2dlci5sb2coXG4gICAgICBgW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSR7XG4gICAgICAgIGNodW5rTWV0YS5wYXJ0ID4gLTEgPyAnIHA6ICcgKyBjaHVua01ldGEucGFydCA6ICcnXG4gICAgICB9IG9mIGxldmVsICR7Y2h1bmtNZXRhLmxldmVsfWAsXG4gICAgKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlciEucmVtdXgoXG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRydWUsXG4gICAgICB0aGlzLmlkLFxuICAgICk7XG4gICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGEsXG4gICAgfSk7XG5cbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICB9XG5cbiAgcmVzZXRJbml0aWFsVGltZXN0YW1wKGRlZmF1bHRJbml0UHRzOiBSYXRpb25hbFRpbWVzdGFtcCB8IG51bGwpIHtcbiAgICBjb25zdCB7IGRlbXV4ZXIsIHJlbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9XG5cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHsgZGVtdXhlciwgcmVtdXhlciB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldENvbnRpZ3VpdHkoKTtcbiAgICByZW11eGVyLnJlc2V0TmV4dFRpbWVzdGFtcCgpO1xuICB9XG5cbiAgcmVzZXRJbml0U2VnbWVudChcbiAgICBpbml0U2VnbWVudERhdGE6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsXG4gICAgYXVkaW9Db2RlYzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZpZGVvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB0cmFja0R1cmF0aW9uOiBudW1iZXIsXG4gICAgZGVjcnlwdGRhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbiAgKSB7XG4gICAgY29uc3QgeyBkZW11eGVyLCByZW11eGVyIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIHRyYWNrRHVyYXRpb24sXG4gICAgKTtcbiAgICByZW11eGVyLnJlc2V0SW5pdFNlZ21lbnQoXG4gICAgICBpbml0U2VnbWVudERhdGEsXG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlY3J5cHRkYXRhLFxuICAgICk7XG4gIH1cblxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRlbXV4ZXIpIHtcbiAgICAgIHRoaXMuZGVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbXV4ZXIpIHtcbiAgICAgIHRoaXMucmVtdXhlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc211eChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGtleURhdGE6IEtleURhdGEgfCBudWxsLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICApOiBUcmFuc211eGVyUmVzdWx0IHwgUHJvbWlzZTxUcmFuc211eGVyUmVzdWx0PiB7XG4gICAgbGV0IHJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCB8IFByb21pc2U8VHJhbnNtdXhlclJlc3VsdD47XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdTQU1QTEUtQUVTJykge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc211eFNhbXBsZUFlcyhcbiAgICAgICAgZGF0YSxcbiAgICAgICAga2V5RGF0YSxcbiAgICAgICAgdGltZU9mZnNldCxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICBjaHVua01ldGEsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNtdXhVbmVuY3J5cHRlZChcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICApOiBUcmFuc211eGVyUmVzdWx0IHtcbiAgICBjb25zdCB7IGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2sgfSA9IChcbiAgICAgIHRoaXMuZGVtdXhlciBhcyBEZW11eGVyXG4gICAgKS5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlciEucmVtdXgoXG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5pZCxcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc211eFNhbXBsZUFlcyhcbiAgICBkYXRhOiBVaW50OEFycmF5LFxuICAgIGRlY3J5cHREYXRhOiBLZXlEYXRhLFxuICAgIHRpbWVPZmZzZXQ6IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICApOiBQcm9taXNlPFRyYW5zbXV4ZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gKHRoaXMuZGVtdXhlciBhcyBEZW11eGVyKVxuICAgICAgLmRlbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0KVxuICAgICAgLnRoZW4oKGRlbXV4UmVzdWx0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyIS5yZW11eChcbiAgICAgICAgICBkZW11eFJlc3VsdC5hdWRpb1RyYWNrLFxuICAgICAgICAgIGRlbXV4UmVzdWx0LnZpZGVvVHJhY2ssXG4gICAgICAgICAgZGVtdXhSZXN1bHQuaWQzVHJhY2ssXG4gICAgICAgICAgZGVtdXhSZXN1bHQudGV4dFRyYWNrLFxuICAgICAgICAgIHRpbWVPZmZzZXQsXG4gICAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuaWQsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YTogVWludDhBcnJheSk6IHZvaWQgfCBFcnJvciB7XG4gICAgY29uc3QgeyBjb25maWcsIG9ic2VydmVyLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IgfSA9IHRoaXM7XG4gICAgLy8gcHJvYmUgZm9yIGNvbnRlbnQgdHlwZVxuICAgIGxldCBtdXg7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG11eENvbmZpZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKG11eENvbmZpZ1tpXS5kZW11eD8ucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBjb25zdCBSZW11eGVyOiBNdXhDb25maWdbJ3JlbXV4J10gPSBtdXgucmVtdXg7XG4gICAgY29uc3QgRGVtdXhlcjogTXV4Q29uZmlnWydkZW11eCddID0gbXV4LmRlbXV4O1xuICAgIGlmICghcmVtdXhlciB8fCAhKHJlbXV4ZXIgaW5zdGFuY2VvZiBSZW11eGVyKSkge1xuICAgICAgdGhpcy5yZW11eGVyID0gbmV3IFJlbXV4ZXIob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yKTtcbiAgICB9XG4gICAgaWYgKCFkZW11eGVyIHx8ICEoZGVtdXhlciBpbnN0YW5jZW9mIERlbXV4ZXIpKSB7XG4gICAgICB0aGlzLmRlbXV4ZXIgPSBuZXcgRGVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkKTtcbiAgICAgIHRoaXMucHJvYmUgPSBEZW11eGVyLnByb2JlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHk6IGJvb2xlYW4sIHRyYWNrU3dpdGNoOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb250aW51aXR5IGNoYW5nZSwgb3IgdHJhY2sgc3dpdGNoXG4gICAgLy8gd2UgbWlnaHQgc3dpdGNoIGZyb20gY29udGVudCB0eXBlIChBQUMgY29udGFpbmVyIHRvIFRTIGNvbnRhaW5lciwgb3IgVFMgdG8gZm1wNCBmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gIXRoaXMuZGVtdXhlciB8fCAhdGhpcy5yZW11eGVyIHx8IGRpc2NvbnRpbnVpdHkgfHwgdHJhY2tTd2l0Y2g7XG4gIH1cblxuICBwcml2YXRlIGdldERlY3J5cHRlcigpOiBEZWNyeXB0ZXIge1xuICAgIGxldCBkZWNyeXB0ZXIgPSB0aGlzLmRlY3J5cHRlcjtcbiAgICBpZiAoIWRlY3J5cHRlcikge1xuICAgICAgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY3J5cHRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uVHlwZShcbiAgZGF0YTogVWludDhBcnJheSxcbiAgZGVjcnlwdERhdGE6IERlY3J5cHREYXRhIHwgbnVsbCxcbik6IEtleURhdGEgfCBudWxsIHtcbiAgbGV0IGVuY3J5cHRpb25UeXBlOiBLZXlEYXRhIHwgbnVsbCA9IG51bGw7XG4gIGlmIChcbiAgICBkYXRhLmJ5dGVMZW5ndGggPiAwICYmXG4gICAgZGVjcnlwdERhdGE/LmtleSAhPSBudWxsICYmXG4gICAgZGVjcnlwdERhdGEuaXYgIT09IG51bGwgJiZcbiAgICBkZWNyeXB0RGF0YS5tZXRob2QgIT0gbnVsbFxuICApIHtcbiAgICBlbmNyeXB0aW9uVHlwZSA9IGRlY3J5cHREYXRhIGFzIEtleURhdGE7XG4gIH1cbiAgcmV0dXJuIGVuY3J5cHRpb25UeXBlO1xufVxuXG5jb25zdCBlbXB0eVJlc3VsdCA9IChjaHVua01ldGEpOiBUcmFuc211eGVyUmVzdWx0ID0+ICh7XG4gIHJlbXV4UmVzdWx0OiB7fSxcbiAgY2h1bmtNZXRhLFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2U8VD4ocDogUHJvbWlzZTxUPiB8IGFueSk6IHAgaXMgUHJvbWlzZTxUPiB7XG4gIHJldHVybiAndGhlbicgaW4gcCAmJiBwLnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cblxuZXhwb3J0IGNsYXNzIFRyYW5zbXV4Q29uZmlnIHtcbiAgcHVibGljIGF1ZGlvQ29kZWM/OiBzdHJpbmc7XG4gIHB1YmxpYyB2aWRlb0NvZGVjPzogc3RyaW5nO1xuICBwdWJsaWMgaW5pdFNlZ21lbnREYXRhPzogVWludDhBcnJheTtcbiAgcHVibGljIGR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBkZWZhdWx0SW5pdFB0czogUmF0aW9uYWxUaW1lc3RhbXAgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgaW5pdFNlZ21lbnREYXRhOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gICAgZGVmYXVsdEluaXRQdHM/OiBSYXRpb25hbFRpbWVzdGFtcCxcbiAgKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gZGVmYXVsdEluaXRQdHMgfHwgbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNtdXhTdGF0ZSB7XG4gIHB1YmxpYyBkaXNjb250aW51aXR5OiBib29sZWFuO1xuICBwdWJsaWMgY29udGlndW91czogYm9vbGVhbjtcbiAgcHVibGljIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbjtcbiAgcHVibGljIHRyYWNrU3dpdGNoOiBib29sZWFuO1xuICBwdWJsaWMgdGltZU9mZnNldDogbnVtYmVyO1xuICBwdWJsaWMgaW5pdFNlZ21lbnRDaGFuZ2U6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZGlzY29udGludWl0eTogYm9vbGVhbixcbiAgICBjb250aWd1b3VzOiBib29sZWFuLFxuICAgIGFjY3VyYXRlVGltZU9mZnNldDogYm9vbGVhbixcbiAgICB0cmFja1N3aXRjaDogYm9vbGVhbixcbiAgICB0aW1lT2Zmc2V0OiBudW1iZXIsXG4gICAgaW5pdFNlZ21lbnRDaGFuZ2U6IGJvb2xlYW4sXG4gICkge1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IGRpc2NvbnRpbnVpdHk7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdHJhY2tTd2l0Y2g7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gaW5pdFNlZ21lbnRDaGFuZ2U7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiIsImltcG9ydCB7XG4gIFdvcmtlckNvbnRleHQsXG4gIGhhc1VNRFdvcmtlcixcbiAgaW5qZWN0V29ya2VyLFxuICBsb2FkV29ya2VyLFxufSBmcm9tICcuL2luamVjdC13b3JrZXInO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBUcmFuc211eGVyLCB7XG4gIFRyYW5zbXV4Q29uZmlnLFxuICBUcmFuc211eFN0YXRlLFxuICBpc1Byb21pc2UsXG59IGZyb20gJy4uL2RlbXV4L3RyYW5zbXV4ZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNZWRpYVNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL21lZGlhc291cmNlLWhlbHBlcic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IEZyYWdtZW50LCBQYXJ0IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgQ2h1bmtNZXRhZGF0YSwgVHJhbnNtdXhlclJlc3VsdCB9IGZyb20gJy4uL3R5cGVzL3RyYW5zbXV4ZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IEhsc0V2ZW50RW1pdHRlciB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB0eXBlIHsgVHlwZVN1cHBvcnRlZCB9IGZyb20gJy4vdHNkZW11eGVyJztcbmltcG9ydCB0eXBlIHsgUmF0aW9uYWxUaW1lc3RhbXAgfSBmcm9tICcuLi91dGlscy90aW1lc2NhbGUtY29udmVyc2lvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zbXV4ZXJJbnRlcmZhY2Uge1xuICBwdWJsaWMgZXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaGxzOiBIbHM7XG4gIHByaXZhdGUgaWQ6IFBsYXlsaXN0TGV2ZWxUeXBlO1xuICBwcml2YXRlIG9ic2VydmVyOiBIbHNFdmVudEVtaXR0ZXI7XG4gIHByaXZhdGUgZnJhZzogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwYXJ0OiBQYXJ0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdXNlV29ya2VyOiBib29sZWFuO1xuICBwcml2YXRlIHdvcmtlckNvbnRleHQ6IFdvcmtlckNvbnRleHQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvbndtc2c/OiBGdW5jdGlvbjtcbiAgcHJpdmF0ZSB0cmFuc211eGVyOiBUcmFuc211eGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb25UcmFuc211eENvbXBsZXRlOiAodHJhbnNtdXhSZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQpID0+IHZvaWQ7XG4gIHByaXZhdGUgb25GbHVzaDogKGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBobHM6IEhscyxcbiAgICBpZDogUGxheWxpc3RMZXZlbFR5cGUsXG4gICAgb25UcmFuc211eENvbXBsZXRlOiAodHJhbnNtdXhSZXN1bHQ6IFRyYW5zbXV4ZXJSZXN1bHQpID0+IHZvaWQsXG4gICAgb25GbHVzaDogKGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSkgPT4gdm9pZCxcbiAgKSB7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy51c2VXb3JrZXIgPSAhIWNvbmZpZy5lbmFibGVXb3JrZXI7XG4gICAgdGhpcy5vblRyYW5zbXV4Q29tcGxldGUgPSBvblRyYW5zbXV4Q29tcGxldGU7XG4gICAgdGhpcy5vbkZsdXNoID0gb25GbHVzaDtcblxuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGV2ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpIGFzIEhsc0V2ZW50RW1pdHRlcjtcbiAgICB0aGlzLm9ic2VydmVyLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgZm9yd2FyZE1lc3NhZ2UpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkVSUk9SLCBmb3J3YXJkTWVzc2FnZSk7XG5cbiAgICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKGNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHx8IHtcbiAgICAgIGlzVHlwZVN1cHBvcnRlZDogKCkgPT4gZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBtMnRzVHlwZVN1cHBvcnRlZDogVHlwZVN1cHBvcnRlZCA9IHtcbiAgICAgIG1wZWc6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXBlZycpLFxuICAgICAgbXAzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKSxcbiAgICAgIGFjMzogX19VU0VfTTJUU19BRFZBTkNFRF9DT0RFQ1NfX1xuICAgICAgICA/IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJhYy0zXCInKVxuICAgICAgICA6IGZhbHNlLFxuICAgIH07XG5cbiAgICAvLyBuYXZpZ2F0b3IudmVuZG9yIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJcbiAgICAvLyByZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV29ya2VyR2xvYmFsU2NvcGUvbmF2aWdhdG9yXG4gICAgY29uc3QgdmVuZG9yID0gbmF2aWdhdG9yLnZlbmRvcjtcbiAgICBpZiAodGhpcy51c2VXb3JrZXIgJiYgdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbkNyZWF0ZVdvcmtlciA9IGNvbmZpZy53b3JrZXJQYXRoIHx8IGhhc1VNRFdvcmtlcigpO1xuICAgICAgaWYgKGNhbkNyZWF0ZVdvcmtlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChjb25maWcud29ya2VyUGF0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgbG9hZGluZyBXZWIgV29ya2VyICR7Y29uZmlnLndvcmtlclBhdGh9IGZvciBcIiR7aWR9XCJgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IGxvYWRXb3JrZXIoY29uZmlnLndvcmtlclBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBpbmplY3RpbmcgV2ViIFdvcmtlciBmb3IgXCIke2lkfVwiYCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlckNvbnRleHQgPSBpbmplY3RXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbndtc2cgPSAoZXY6IGFueSkgPT4gdGhpcy5vbldvcmtlck1lc3NhZ2UoZXYpO1xuICAgICAgICAgIGNvbnN0IHsgd29ya2VyIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9ud21zZyBhcyBhbnkpO1xuICAgICAgICAgIHdvcmtlci5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYCR7ZXZlbnQubWVzc2FnZX0gICgke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub30pYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgaW4gXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGNtZDogJ2luaXQnLFxuICAgICAgICAgICAgdHlwZVN1cHBvcnRlZDogbTJ0c1R5cGVTdXBwb3J0ZWQsXG4gICAgICAgICAgICB2ZW5kb3I6IHZlbmRvcixcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGNvbmZpZzogSlNPTi5zdHJpbmdpZnkoY29uZmlnKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oXG4gICAgICAgICAgICBgRXJyb3Igc2V0dGluZyB1cCBcIiR7aWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCxcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucmVzZXRXb3JrZXIoKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcihcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIsXG4gICAgICAgICAgICBtMnRzVHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHZlbmRvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKFxuICAgICAgdGhpcy5vYnNlcnZlcixcbiAgICAgIG0ydHNUeXBlU3VwcG9ydGVkLFxuICAgICAgY29uZmlnLFxuICAgICAgdmVuZG9yLFxuICAgICAgaWQsXG4gICAgKTtcbiAgfVxuXG4gIHJlc2V0V29ya2VyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHsgd29ya2VyLCBvYmplY3RVUkwgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICBzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VVJMKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cgYXMgYW55KTtcbiAgICAgIHdvcmtlci5vbmVycm9yID0gbnVsbDtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V29ya2VyKCk7XG4gICAgICB0aGlzLm9ud21zZyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICAgIGlmICh0cmFuc211eGVyKSB7XG4gICAgICAgIHRyYW5zbXV4ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMub2JzZXJ2ZXI7XG4gICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vYnNlcnZlciA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuXG4gIHB1c2goXG4gICAgZGF0YTogQXJyYXlCdWZmZXIsXG4gICAgaW5pdFNlZ21lbnREYXRhOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkLFxuICAgIGF1ZGlvQ29kZWM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2aWRlb0NvZGVjOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZnJhZzogRnJhZ21lbnQsXG4gICAgcGFydDogUGFydCB8IG51bGwsXG4gICAgZHVyYXRpb246IG51bWJlcixcbiAgICBhY2N1cmF0ZVRpbWVPZmZzZXQ6IGJvb2xlYW4sXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICAgIGRlZmF1bHRJbml0UFRTPzogUmF0aW9uYWxUaW1lc3RhbXAsXG4gICk6IHZvaWQge1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgeyB0cmFuc211eGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRpbWVPZmZzZXQgPSBwYXJ0ID8gcGFydC5zdGFydCA6IGZyYWcuc3RhcnQ7XG4gICAgLy8gVE9ETzogcHVzaCBcImNsZWFyLWxlYWRcIiBkZWNyeXB0IGRhdGEgZm9yIHVuZW5jcnlwdGVkIGZyYWdtZW50cyBpbiBzdHJlYW1zIHdpdGggZW5jcnlwdGVkIG9uZXNcbiAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGE7XG4gICAgY29uc3QgbGFzdEZyYWcgPSB0aGlzLmZyYWc7XG5cbiAgICBjb25zdCBkaXNjb250aW51aXR5ID0gIShsYXN0RnJhZyAmJiBmcmFnLmNjID09PSBsYXN0RnJhZy5jYyk7XG4gICAgY29uc3QgdHJhY2tTd2l0Y2ggPSAhKGxhc3RGcmFnICYmIGNodW5rTWV0YS5sZXZlbCA9PT0gbGFzdEZyYWcubGV2ZWwpO1xuICAgIGNvbnN0IHNuRGlmZiA9IGxhc3RGcmFnID8gY2h1bmtNZXRhLnNuIC0gKGxhc3RGcmFnLnNuIGFzIG51bWJlcikgOiAtMTtcbiAgICBjb25zdCBwYXJ0RGlmZiA9IHRoaXMucGFydCA/IGNodW5rTWV0YS5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogLTE7XG4gICAgY29uc3QgcHJvZ3Jlc3NpdmUgPVxuICAgICAgc25EaWZmID09PSAwICYmXG4gICAgICBjaHVua01ldGEuaWQgPiAxICYmXG4gICAgICBjaHVua01ldGEuaWQgPT09IGxhc3RGcmFnPy5zdGF0cy5jaHVua0NvdW50O1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPVxuICAgICAgIXRyYWNrU3dpdGNoICYmXG4gICAgICAoc25EaWZmID09PSAxIHx8XG4gICAgICAgIChzbkRpZmYgPT09IDAgJiYgKHBhcnREaWZmID09PSAxIHx8IChwcm9ncmVzc2l2ZSAmJiBwYXJ0RGlmZiA8PSAwKSkpKTtcbiAgICBjb25zdCBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgaWYgKHRyYWNrU3dpdGNoIHx8IHNuRGlmZiB8fCBmcmFnLnN0YXRzLnBhcnNpbmcuc3RhcnQgPT09IDApIHtcbiAgICAgIGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9IG5vdztcbiAgICB9XG4gICAgaWYgKHBhcnQgJiYgKHBhcnREaWZmIHx8ICFjb250aWd1b3VzKSkge1xuICAgICAgcGFydC5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICBjb25zdCBpbml0U2VnbWVudENoYW5nZSA9ICEoXG4gICAgICBsYXN0RnJhZyAmJiBmcmFnLmluaXRTZWdtZW50Py51cmwgPT09IGxhc3RGcmFnLmluaXRTZWdtZW50Py51cmxcbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFRyYW5zbXV4U3RhdGUoXG4gICAgICBkaXNjb250aW51aXR5LFxuICAgICAgY29udGlndW91cyxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRyYWNrU3dpdGNoLFxuICAgICAgdGltZU9mZnNldCxcbiAgICAgIGluaXRTZWdtZW50Q2hhbmdlLFxuICAgICk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIGxvZ2dlci5sb2coYFt0cmFuc211eGVyLWludGVyZmFjZSwgJHtmcmFnLnR5cGV9XTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiAke2NodW5rTWV0YS5zbn0gcDogJHtjaHVua01ldGEucGFydH0gbGV2ZWw6ICR7Y2h1bmtNZXRhLmxldmVsfSBpZDogJHtjaHVua01ldGEuaWR9XG4gICAgICAgIGRpc2NvbnRpbnVpdHk6ICR7ZGlzY29udGludWl0eX1cbiAgICAgICAgdHJhY2tTd2l0Y2g6ICR7dHJhY2tTd2l0Y2h9XG4gICAgICAgIGNvbnRpZ3VvdXM6ICR7Y29udGlndW91c31cbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiAke2FjY3VyYXRlVGltZU9mZnNldH1cbiAgICAgICAgdGltZU9mZnNldDogJHt0aW1lT2Zmc2V0fVxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogJHtpbml0U2VnbWVudENoYW5nZX1gKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBUcmFuc211eENvbmZpZyhcbiAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZGVmYXVsdEluaXRQVFMsXG4gICAgICApO1xuICAgICAgdGhpcy5jb25maWd1cmVUcmFuc211eGVyKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuXG4gICAgLy8gRnJhZ3Mgd2l0aCBzbiBvZiAnaW5pdFNlZ21lbnQnIGFyZSBub3QgdHJhbnNtdXhlZFxuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICB9LFxuICAgICAgICBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZGF0YV0gOiBbXSxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBjb25zdCB0cmFuc211eFJlc3VsdCA9IHRyYW5zbXV4ZXIucHVzaChcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgc3RhdGUsXG4gICAgICApO1xuICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0XG4gICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgICAgICAndHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvcicsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUodHJhbnNtdXhSZXN1bHQgYXMgVHJhbnNtdXhlclJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmx1c2goY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhKSB7XG4gICAgY2h1bmtNZXRhLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7IHRyYW5zbXV4ZXIgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgMTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdmbHVzaCcsXG4gICAgICAgIGNodW5rTWV0YSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgbGV0IHRyYW5zbXV4UmVzdWx0ID0gdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICAgICAgY29uc3QgYXN5bmNGbHVzaCA9IGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICBpZiAoYXN5bmNGbHVzaCB8fCB0cmFuc211eGVyLmFzeW5jKSB7XG4gICAgICAgIGlmICghaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KSkge1xuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc211eFJlc3VsdFxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KGRhdGEsIGNodW5rTWV0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXJFcnJvcihcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgICAgICAgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUZsdXNoUmVzdWx0KFxuICAgICAgICAgIHRyYW5zbXV4UmVzdWx0IGFzIEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbXV4ZXJFcnJvcihcbiAgICBlcnJvcjogRXJyb3IsXG4gICAgY2h1bmtNZXRhOiBDaHVua01ldGFkYXRhLFxuICAgIHJlYXNvbjogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBjaHVua01ldGEsXG4gICAgICBmYXRhbDogZmFsc2UsXG4gICAgICBlcnJvcixcbiAgICAgIGVycjogZXJyb3IsXG4gICAgICByZWFzb24sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZsdXNoUmVzdWx0KFxuICAgIHJlc3VsdHM6IEFycmF5PFRyYW5zbXV4ZXJSZXN1bHQ+LFxuICAgIGNodW5rTWV0YTogQ2h1bmtNZXRhZGF0YSxcbiAgKSB7XG4gICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICAgIH0pO1xuICAgIHRoaXMub25GbHVzaChjaHVua01ldGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldvcmtlck1lc3NhZ2UoZXY6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IGRhdGEgPSBldi5kYXRhO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIHN3aXRjaCAoZGF0YS5ldmVudCkge1xuICAgICAgY2FzZSAnaW5pdCc6IHtcbiAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gdGhpcy53b3JrZXJDb250ZXh0Py5vYmplY3RVUkw7XG4gICAgICAgIGlmIChvYmplY3RVUkwpIHtcbiAgICAgICAgICAvLyByZXZva2UgdGhlIE9iamVjdCBVUkwgdGhhdCB3YXMgdXNlZCB0byBjcmVhdGUgdHJhbnNtdXhlciB3b3JrZXIsIHNvIGFzIG5vdCB0byBsZWFrIGl0XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3RyYW5zbXV4Q29tcGxldGUnOiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAnZmx1c2gnOiB7XG4gICAgICAgIHRoaXMub25GbHVzaChkYXRhLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gcGFzcyBsb2dzIGZyb20gdGhlIHdvcmtlciB0aHJlYWQgdG8gdGhlIG1haW4gbG9nZ2VyXG4gICAgICBjYXNlICd3b3JrZXJMb2cnOlxuICAgICAgICBpZiAobG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXSkge1xuICAgICAgICAgIGxvZ2dlcltkYXRhLmRhdGEubG9nVHlwZV0oZGF0YS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCB7fTtcbiAgICAgICAgZGF0YS5kYXRhLmZyYWcgPSB0aGlzLmZyYWc7XG4gICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIGhscy50cmlnZ2VyKGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29uZmlndXJlVHJhbnNtdXhlcihjb25maWc6IFRyYW5zbXV4Q29uZmlnKSB7XG4gICAgY29uc3QgeyB0cmFuc211eGVyIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdjb25maWd1cmUnLFxuICAgICAgICBjb25maWcsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCkge1xuICAgIHJlc3VsdC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZShyZXN1bHQpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEJ1ZmZlckluZm8gfSBmcm9tICcuLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgRXJyb3JUeXBlcywgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBsYXlsaXN0TGV2ZWxUeXBlIH0gZnJvbSAnLi4vdHlwZXMvbG9hZGVyJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IEhsc0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCB0eXBlIHsgRnJhZ21lbnRUcmFja2VyIH0gZnJvbSAnLi9mcmFnbWVudC10cmFja2VyJztcblxuZXhwb3J0IGNvbnN0IFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMgPSAyNTA7XG5leHBvcnQgY29uc3QgTUFYX1NUQVJUX0dBUF9KVU1QID0gMi4wO1xuZXhwb3J0IGNvbnN0IFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xuZXhwb3J0IGNvbnN0IFNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUID0gMC4wNTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2FwQ29udHJvbGxlciB7XG4gIHByaXZhdGUgY29uZmlnOiBIbHNDb25maWc7XG4gIHByaXZhdGUgbWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBmcmFnbWVudFRyYWNrZXI6IEZyYWdtZW50VHJhY2tlcjtcbiAgcHJpdmF0ZSBobHM6IEhscztcbiAgcHJpdmF0ZSBudWRnZVJldHJ5OiBudW1iZXIgPSAwO1xuICBwcml2YXRlIHN0YWxsUmVwb3J0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGFsbGVkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBtb3ZlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHNlZWtpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihjb25maWcsIG1lZGlhLCBmcmFnbWVudFRyYWNrZXIsIGhscykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlciA9IGZyYWdtZW50VHJhY2tlcjtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBsYXloZWFkIGlzIHN0dWNrIHdpdGhpbiBhIGdhcCwgYW5kIGlmIHNvLCBhdHRlbXB0cyB0byBmcmVlIGl0LlxuICAgKiBBIGdhcCBpcyBhbiB1bmJ1ZmZlcmVkIHJhbmdlIGJldHdlZW4gdHdvIGJ1ZmZlcmVkIHJhbmdlcyAob3IgdGhlIHN0YXJ0IGFuZCB0aGUgZmlyc3QgYnVmZmVyZWQgcmFuZ2UpLlxuICAgKlxuICAgKiBAcGFyYW0gbGFzdEN1cnJlbnRUaW1lIC0gUHJldmlvdXNseSByZWFkIHBsYXloZWFkIHBvc2l0aW9uXG4gICAqL1xuICBwdWJsaWMgcG9sbChsYXN0Q3VycmVudFRpbWU6IG51bWJlciwgYWN0aXZlRnJhZzogRnJhZ21lbnQgfCBudWxsKSB7XG4gICAgY29uc3QgeyBjb25maWcsIG1lZGlhLCBzdGFsbGVkIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnRUaW1lLCBzZWVraW5nIH0gPSBtZWRpYTtcbiAgICBjb25zdCBzZWVrZWQgPSB0aGlzLnNlZWtpbmcgJiYgIXNlZWtpbmc7XG4gICAgY29uc3QgYmVnaW5TZWVrID0gIXRoaXMuc2Vla2luZyAmJiBzZWVraW5nO1xuXG4gICAgdGhpcy5zZWVraW5nID0gc2Vla2luZztcblxuICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcsIG5vLW9wXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFsbGVkO1xuICAgICAgICAgIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2N1cnJlbnRUaW1lfSwgYWZ0ZXIgJHtNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICBzdGFsbGVkRHVyYXRpb24sXG4gICAgICAgICAgICApfW1zYCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuc3RhbGxSZXBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhbGxlZCBzdGF0ZSB3aGVuIGJlZ2lubmluZyBvciBmaW5pc2hpbmcgc2Vla2luZyBzbyB0aGF0IHdlIGRvbid0IHJlcG9ydCBzdGFsbHMgY29taW5nIG91dCBvZiBhIHNlZWtcbiAgICBpZiAoYmVnaW5TZWVrIHx8IHNlZWtlZCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGxheWhlYWQgc2hvdWxkIG5vdCBiZSBtb3ZpbmdcbiAgICBpZiAoXG4gICAgICAobWVkaWEucGF1c2VkICYmICFzZWVraW5nKSB8fFxuICAgICAgbWVkaWEuZW5kZWQgfHxcbiAgICAgIG1lZGlhLnBsYXliYWNrUmF0ZSA9PT0gMCB8fFxuICAgICAgIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IG5leHRTdGFydCA9IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8IDA7XG5cbiAgICBpZiAoc2Vla2luZykge1xuICAgICAgLy8gV2FpdGluZyBmb3Igc2Vla2luZyBpbiBhIGJ1ZmZlcmVkIHJhbmdlIHRvIGNvbXBsZXRlXG4gICAgICBjb25zdCBoYXNFbm91Z2hCdWZmZXIgPSBidWZmZXJJbmZvLmxlbiA+IE1BWF9TVEFSVF9HQVBfSlVNUDtcbiAgICAgIC8vIE5leHQgYnVmZmVyZWQgcmFuZ2UgaXMgdG9vIGZhciBhaGVhZCB0byBqdW1wIHRvIHdoaWxlIHN0aWxsIHNlZWtpbmdcbiAgICAgIGNvbnN0IG5vQnVmZmVyR2FwID1cbiAgICAgICAgIW5leHRTdGFydCB8fFxuICAgICAgICAoYWN0aXZlRnJhZyAmJiBhY3RpdmVGcmFnLnN0YXJ0IDw9IGN1cnJlbnRUaW1lKSB8fFxuICAgICAgICAobmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPiBNQVhfU1RBUlRfR0FQX0pVTVAgJiZcbiAgICAgICAgICAhdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKSk7XG4gICAgICBpZiAoaGFzRW5vdWdoQnVmZmVyIHx8IG5vQnVmZmVyR2FwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2V0IG1vdmVkIHN0YXRlIHdoZW4gc2Vla2luZyB0byBhIHBvaW50IGluIG9yIGJlZm9yZSBhIGdhcFxuICAgICAgdGhpcy5tb3ZlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNraXAgc3RhcnQgZ2FwcyBpZiB3ZSBoYXZlbid0IHBsYXllZCwgYnV0IHRoZSBsYXN0IHBvbGwgZGV0ZWN0ZWQgdGhlIHN0YXJ0IG9mIGEgc3RhbGxcbiAgICAvLyBUaGUgYWRkaXRpb24gcG9sbCBnaXZlcyB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byBqdW1wIHRoZSBnYXAgZm9yIHVzXG4gICAgaWYgKCF0aGlzLm1vdmVkICYmIHRoaXMuc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gcGxheWFibGUgYnVmZmVyIChzZWVrZWQsIHdhaXRpbmcgZm9yIGJ1ZmZlcilcbiAgICAgIGNvbnN0IGlzQnVmZmVyZWQgPSBidWZmZXJJbmZvLmxlbiA+IDA7XG4gICAgICBpZiAoIWlzQnVmZmVyZWQgJiYgIW5leHRTdGFydCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBKdW1wIHN0YXJ0IGdhcHMgd2l0aGluIGp1bXAgdGhyZXNob2xkXG4gICAgICBjb25zdCBzdGFydEp1bXAgPVxuICAgICAgICBNYXRoLm1heChuZXh0U3RhcnQsIGJ1ZmZlckluZm8uc3RhcnQgfHwgMCkgLSBjdXJyZW50VGltZTtcblxuICAgICAgLy8gV2hlbiBqb2luaW5nIGEgbGl2ZSBzdHJlYW0gd2l0aCBhdWRpbyB0cmFja3MsIGFjY291bnQgZm9yIGxpdmUgcGxheWxpc3Qgd2luZG93IHNsaWRpbmcgYnkgYWxsb3dpbmdcbiAgICAgIC8vIGEgbGFyZ2VyIGp1bXAgb3ZlciBzdGFydCBnYXBzIGNhdXNlZCBieSB0aGUgYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXIgYnVmZmVyaW5nIGEgc3RhcnQgZnJhZ21lbnRcbiAgICAgIC8vIHRoYXQgYmVnaW5zIG92ZXIgMSB0YXJnZXQgZHVyYXRpb24gYWZ0ZXIgdGhlIHZpZGVvIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNcbiAgICAgICAgPyB0aGlzLmhscy5sZXZlbHNbdGhpcy5obHMuY3VycmVudExldmVsXVxuICAgICAgICA6IG51bGw7XG4gICAgICBjb25zdCBpc0xpdmUgPSBsZXZlbD8uZGV0YWlscz8ubGl2ZTtcbiAgICAgIGNvbnN0IG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZVxuICAgICAgICA/IGxldmVsIS5kZXRhaWxzIS50YXJnZXRkdXJhdGlvbiAqIDJcbiAgICAgICAgOiBNQVhfU1RBUlRfR0FQX0pVTVA7XG4gICAgICBjb25zdCBwYXJ0aWFsT3JHYXAgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHN0YXJ0SnVtcCA+IDAgJiYgKHN0YXJ0SnVtcCA8PSBtYXhTdGFydEdhcEp1bXAgfHwgcGFydGlhbE9yR2FwKSkge1xuICAgICAgICBpZiAoIW1lZGlhLnBhdXNlZCkge1xuICAgICAgICAgIHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWxPckdhcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRyYWNraW5nIHN0YWxsIHRpbWVcbiAgICBjb25zdCB0bm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoc3RhbGxlZCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGFsbGVkID0gdG5vdztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFsbGVkRHVyYXRpb24gPSB0bm93IC0gc3RhbGxlZDtcbiAgICBpZiAoIXNlZWtpbmcgJiYgc3RhbGxlZER1cmF0aW9uID49IFNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMpIHtcbiAgICAgIC8vIFJlcG9ydCBzdGFsbGluZyBhZnRlciB0cnlpbmcgdG8gZml4XG4gICAgICB0aGlzLl9yZXBvcnRTdGFsbChidWZmZXJJbmZvKTtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhcbiAgICAgIG1lZGlhLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBjb25maWcubWF4QnVmZmVySG9sZSxcbiAgICApO1xuICAgIHRoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlcmVkV2l0aEhvbGVzLCBzdGFsbGVkRHVyYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdHMgYW5kIGF0dGVtcHRzIHRvIGZpeCBrbm93biBidWZmZXIgc3RhbGxpbmcgaXNzdWVzLlxuICAgKiBAcGFyYW0gYnVmZmVySW5mbyAtIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgICogQHBhcmFtIHN0YWxsZWREdXJhdGlvbk1zIC0gVGhlIGFtb3VudCBvZiB0aW1lIEhscy5qcyBoYXMgYmVlbiBzdGFsbGluZyBmb3IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90cnlGaXhCdWZmZXJTdGFsbChcbiAgICBidWZmZXJJbmZvOiBCdWZmZXJJbmZvLFxuICAgIHN0YWxsZWREdXJhdGlvbk1zOiBudW1iZXIsXG4gICkge1xuICAgIGNvbnN0IHsgY29uZmlnLCBmcmFnbWVudFRyYWNrZXIsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuXG4gICAgY29uc3QgcGFydGlhbCA9IGZyYWdtZW50VHJhY2tlci5nZXRQYXJ0aWFsRnJhZ21lbnQoY3VycmVudFRpbWUpO1xuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUcnkgdG8gc2tpcCBvdmVyIHRoZSBidWZmZXIgaG9sZSBjYXVzZWQgYnkgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAgICAvLyBUaGlzIG1ldGhvZCBpc24ndCBsaW1pdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBnYXAgYmV0d2VlbiBidWZmZXJlZCByYW5nZXNcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsKTtcbiAgICAgIC8vIHdlIHJldHVybiBoZXJlIGluIHRoaXMgY2FzZSwgbWVhbmluZ1xuICAgICAgLy8gdGhlIGJyYW5jaCBiZWxvdyBvbmx5IGV4ZWN1dGVzIHdoZW4gd2UgaGF2ZW4ndCBzZWVrZWQgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgIGlmICh0YXJnZXRUaW1lIHx8ICF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IGhhZCB0byBza2lwIG92ZXIgYSBidWZmZXIgaG9sZSBvZiBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAvLyB3ZSBtYXkganVzdCBoYXZlIHRvIFwibnVkZ2VcIiB0aGUgcGxheWxpc3QgYXMgdGhlIGJyb3dzZXIgZGVjb2RpbmcvcmVuZGVyaW5nIGVuZ2luZVxuICAgIC8vIG5lZWRzIHRvIGNyb3NzIHNvbWUgc29ydCBvZiB0aHJlc2hvbGQgY292ZXJpbmcgYWxsIHNvdXJjZS1idWZmZXJzIGNvbnRlbnRcbiAgICAvLyB0byBzdGFydCBwbGF5aW5nIHByb3Blcmx5LlxuICAgIGlmIChcbiAgICAgIChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8XG4gICAgICAgIChidWZmZXJJbmZvLm5leHRTdGFydCAmJlxuICAgICAgICAgIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPCBjb25maWcubWF4QnVmZmVySG9sZSkpICYmXG4gICAgICBzdGFsbGVkRHVyYXRpb25NcyA+IGNvbmZpZy5oaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2QgKiAxMDAwXG4gICAgKSB7XG4gICAgICBsb2dnZXIud2FybignVHJ5aW5nIHRvIG51ZGdlIHBsYXloZWFkIG92ZXIgYnVmZmVyLWhvbGUnKTtcbiAgICAgIC8vIFRyeSB0byBudWRnZSBjdXJyZW50VGltZSBvdmVyIGEgYnVmZmVyIGhvbGUgaWYgd2UndmUgYmVlbiBzdGFsbGluZyBmb3IgdGhlIGNvbmZpZ3VyZWQgYW1vdW50IG9mIHNlY29uZHNcbiAgICAgIC8vIFdlIG9ubHkgdHJ5IHRvIGp1bXAgdGhlIGhvbGUgaWYgaXQncyB1bmRlciB0aGUgY29uZmlndXJlZCBzaXplXG4gICAgICAvLyBSZXNldCBzdGFsbGVkIHNvIHRvIHJlYXJtIHdhdGNoZG9nIHRpbWVyXG4gICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBCVUZGRVJfU1RBTExFRF9FUlJPUiBldmVudCwgYnV0IG9ubHkgb25jZSBwZXIgc3RhbGwgcGVyaW9kLlxuICAgKiBAcGFyYW0gYnVmZmVyTGVuIC0gVGhlIHBsYXloZWFkIGRpc3RhbmNlIGZyb20gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBidWZmZXIgc2VnbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm86IEJ1ZmZlckluZm8pIHtcbiAgICBjb25zdCB7IGhscywgbWVkaWEsIHN0YWxsUmVwb3J0ZWQgfSA9IHRoaXM7XG4gICAgaWYgKCFzdGFsbFJlcG9ydGVkICYmIG1lZGlhKSB7XG4gICAgICAvLyBSZXBvcnQgc3RhbGxlZCBlcnJvciBvbmNlXG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSB0cnVlO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHtcbiAgICAgICAgICBtZWRpYS5jdXJyZW50VGltZVxuICAgICAgICB9IGR1ZSB0byBsb3cgYnVmZmVyICgke0pTT04uc3RyaW5naWZ5KGJ1ZmZlckluZm8pfSlgLFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXJJbmZvLmxlbixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBqdW1waW5nIG92ZXIga25vd24gZ2FwcyBjYXVzZWQgYnkgcGFydGlhbCBmcmFnbWVudHNcbiAgICogQHBhcmFtIHBhcnRpYWwgLSBUaGUgcGFydGlhbCBmcmFnbWVudCBmb3VuZCBhdCB0aGUgY3VycmVudCB0aW1lICh3aGVyZSBwbGF5YmFjayBpcyBzdGFsbGluZykuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsOiBGcmFnbWVudCB8IG51bGwpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgY29uZmlnLCBobHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9XG4gICAgICBjdXJyZW50VGltZSA8IGJ1ZmZlckluZm8uc3RhcnQgPyBidWZmZXJJbmZvLnN0YXJ0IDogYnVmZmVySW5mby5uZXh0U3RhcnQ7XG4gICAgaWYgKHN0YXJ0VGltZSkge1xuICAgICAgY29uc3QgYnVmZmVyU3RhcnZlZCA9IGJ1ZmZlckluZm8ubGVuIDw9IGNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgICAgY29uc3Qgd2FpdGluZyA9XG4gICAgICAgIGJ1ZmZlckluZm8ubGVuID4gMCAmJiBidWZmZXJJbmZvLmxlbiA8IDEgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDM7XG4gICAgICBjb25zdCBnYXBMZW5ndGggPSBzdGFydFRpbWUgLSBjdXJyZW50VGltZTtcbiAgICAgIGlmIChnYXBMZW5ndGggPiAwICYmIChidWZmZXJTdGFydmVkIHx8IHdhaXRpbmcpKSB7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgbGFyZ2UgZ2FwcyB0byBiZSBza2lwcGVkIGlmIGl0IGlzIGEgc3RhcnQgZ2FwLCBvciBhbGwgZnJhZ21lbnRzIGluIHNraXAgcmFuZ2UgYXJlIHBhcnRpYWxcbiAgICAgICAgaWYgKGdhcExlbmd0aCA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlKSB7XG4gICAgICAgICAgY29uc3QgeyBmcmFnbWVudFRyYWNrZXIgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHN0YXJ0R2FwID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGN1cnJlbnRUaW1lID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEZyYWcgPSBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzdGFydEZyYWcgJiYgc3RhcnRUaW1lIDwgc3RhcnRGcmFnLmVuZCkge1xuICAgICAgICAgICAgICBzdGFydEdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RhcnRHYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UHJvdmlzaW9uZWQgPVxuICAgICAgICAgICAgICBwYXJ0aWFsIHx8XG4gICAgICAgICAgICAgIGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgIGxldCBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydFByb3Zpc2lvbmVkLmVuZDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHByb3Zpc2lvbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3JlVG9Mb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobW9yZVRvTG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBNYXRoLm1heChcbiAgICAgICAgICBzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCxcbiAgICAgICAgICBjdXJyZW50VGltZSArIFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTLFxuICAgICAgICApO1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgc2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gJHtjdXJyZW50VGltZX0gdG8gJHt0YXJnZXRUaW1lfWAsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgIGlmIChwYXJ0aWFsICYmICFwYXJ0aWFsLmdhcCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZzogcGFydGlhbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0VGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkgYWR2YW5jaW5nIHRoZSBtZWRpYUVsZW1lbnQncyBjdXJyZW50IHRpbWUgYnkgYSBzbWFsbCBhbW91bnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgaGxzLCBtZWRpYSwgbnVkZ2VSZXRyeSB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLm51ZGdlUmV0cnkrKztcblxuICAgIGlmIChudWRnZVJldHJ5IDwgY29uZmlnLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBjdXJyZW50VGltZSArIChudWRnZVJldHJ5ICsgMSkgKiBjb25maWcubnVkZ2VPZmZzZXQ7XG4gICAgICAvLyBwbGF5YmFjayBzdGFsbGVkIGluIGJ1ZmZlcmVkIGFyZWEgLi4uIGxldCdzIG51ZGdlIGN1cnJlbnRUaW1lIHRvIHRyeSB0byBvdmVyY29tZSB0aGlzXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gLFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke2N1cnJlbnRUaW1lfSBhZnRlciAke2NvbmZpZy5udWRnZU1heFJldHJ5fSBudWRnZXNgLFxuICAgICAgKTtcbiAgICAgIGxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IEJhc2VTdHJlYW1Db250cm9sbGVyLCB7IFN0YXRlIH0gZnJvbSAnLi9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IGNoYW5nZVR5cGVTdXBwb3J0ZWQgfSBmcm9tICcuLi9pcy1zdXBwb3J0ZWQnO1xuaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IEJ1ZmZlckhlbHBlciwgQnVmZmVySW5mbyB9IGZyb20gJy4uL3V0aWxzL2J1ZmZlci1oZWxwZXInO1xuaW1wb3J0IHsgRnJhZ21lbnRTdGF0ZSB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgeyBQbGF5bGlzdENvbnRleHRUeXBlLCBQbGF5bGlzdExldmVsVHlwZSB9IGZyb20gJy4uL3R5cGVzL2xvYWRlcic7XG5pbXBvcnQgeyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsIEZyYWdtZW50IH0gZnJvbSAnLi4vbG9hZGVyL2ZyYWdtZW50JztcbmltcG9ydCBUcmFuc211eGVySW50ZXJmYWNlIGZyb20gJy4uL2RlbXV4L3RyYW5zbXV4ZXItaW50ZXJmYWNlJztcbmltcG9ydCB7IENodW5rTWV0YWRhdGEgfSBmcm9tICcuLi90eXBlcy90cmFuc211eGVyJztcbmltcG9ydCBHYXBDb250cm9sbGVyLCB7IE1BWF9TVEFSVF9HQVBfSlVNUCB9IGZyb20gJy4vZ2FwLWNvbnRyb2xsZXInO1xuaW1wb3J0IHsgRXJyb3JEZXRhaWxzIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgTmV0d29ya0NvbXBvbmVudEFQSSB9IGZyb20gJy4uL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUgSGxzIGZyb20gJy4uL2hscyc7XG5pbXBvcnQgdHlwZSB7IExldmVsIH0gZnJvbSAnLi4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbERldGFpbHMgfSBmcm9tICcuLi9sb2FkZXIvbGV2ZWwtZGV0YWlscyc7XG5pbXBvcnQgdHlwZSB7IEZyYWdtZW50VHJhY2tlciB9IGZyb20gJy4vZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgdHlwZSBLZXlMb2FkZXIgZnJvbSAnLi4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IHR5cGUgeyBUcmFuc211eGVyUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMvdHJhbnNtdXhlcic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrU2V0IH0gZnJvbSAnLi4vdHlwZXMvdHJhY2snO1xuaW1wb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi4vdHlwZXMvYnVmZmVyJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9UcmFja1N3aXRjaGVkRGF0YSxcbiAgQXVkaW9UcmFja1N3aXRjaGluZ0RhdGEsXG4gIEJ1ZmZlckNyZWF0ZWREYXRhLFxuICBCdWZmZXJFT1NEYXRhLFxuICBCdWZmZXJGbHVzaGVkRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBGcmFnQnVmZmVyZWREYXRhLFxuICBGcmFnTG9hZGVkRGF0YSxcbiAgRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGEsXG4gIEZyYWdQYXJzaW5nVXNlcmRhdGFEYXRhLFxuICBMZXZlbExvYWRlZERhdGEsXG4gIExldmVsTG9hZGluZ0RhdGEsXG4gIExldmVsc1VwZGF0ZWREYXRhLFxuICBNYW5pZmVzdFBhcnNlZERhdGEsXG4gIE1lZGlhQXR0YWNoZWREYXRhLFxufSBmcm9tICcuLi90eXBlcy9ldmVudHMnO1xuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJlYW1Db250cm9sbGVyXG4gIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXJcbiAgaW1wbGVtZW50cyBOZXR3b3JrQ29tcG9uZW50QVBJXG57XG4gIHByaXZhdGUgYXVkaW9Db2RlY1N3YXA6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBnYXBDb250cm9sbGVyOiBHYXBDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGV2ZWw6IG51bWJlciA9IC0xO1xuICBwcml2YXRlIF9mb3JjZVN0YXJ0TG9hZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGFsdEF1ZGlvOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgYXVkaW9Pbmx5OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZnJhZ1BsYXlpbmc6IEZyYWdtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgb252cGxheWluZzogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIG9udnNlZWtlZDogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGZyYWdMYXN0S2JwczogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBjb3VsZEJhY2t0cmFjazogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJhY2t0cmFja0ZyYWdtZW50OiBGcmFnbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGF1ZGlvQ29kZWNTd2l0Y2g6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB2aWRlb0J1ZmZlcjogYW55IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgaGxzOiBIbHMsXG4gICAgZnJhZ21lbnRUcmFja2VyOiBGcmFnbWVudFRyYWNrZXIsXG4gICAga2V5TG9hZGVyOiBLZXlMb2FkZXIsXG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgaGxzLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAga2V5TG9hZGVyLFxuICAgICAgJ1tzdHJlYW0tY29udHJvbGxlcl0nLFxuICAgICAgUGxheWxpc3RMZXZlbFR5cGUuTUFJTixcbiAgICApO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihcbiAgICAgIEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLFxuICAgICAgdGhpcyxcbiAgICApO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihcbiAgICAgIEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsXG4gICAgICB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLFxuICAgICAgdGhpcyxcbiAgICApO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmxldmVscykge1xuICAgICAgY29uc3QgeyBsYXN0Q3VycmVudFRpbWUsIGhscyB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIGxldCBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgIGlmIChobHMuY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZChcbiAgICAgICAgICAgIDMsXG4gICAgICAgICAgKX1gLFxuICAgICAgICApO1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPVxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPVxuICAgICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9XG4gICAgICAgICAgc3RhcnRQb3NpdGlvbjtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19MRVZFTDoge1xuICAgICAgICBjb25zdCB7IGxldmVscywgbGV2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVscz8uW2xldmVsXTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbD8uZGV0YWlscztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRldGFpbHMgJiZcbiAgICAgICAgICAoIWRldGFpbHMubGl2ZSB8fCB0aGlzLmxldmVsTGFzdExvYWRlZCA9PT0gY3VycmVudExldmVsKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKGRldGFpbHMpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IHRoaXMubWVkaWE/LnNlZWtpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGV2ZWxzLCBsZXZlbCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVscz8uW2xldmVsXTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoY3VycmVudExldmVsIHx8IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvblRpY2tFbmQoKSB7XG4gICAgc3VwZXIub25UaWNrRW5kKCk7XG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgZG9UaWNrSWRsZSgpIHtcbiAgICBjb25zdCB7IGhscywgbGV2ZWxMYXN0TG9hZGVkLCBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY29uZmlnLCBuZXh0TG9hZExldmVsOiBsZXZlbCB9ID0gaGxzO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmIChcbiAgICAgIGxldmVsTGFzdExvYWRlZCA9PT0gbnVsbCB8fFxuICAgICAgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIFwibWFpblwiIGxldmVsIGlzIGF1ZGlvLW9ubHkgYnV0IHdlIGFyZSBsb2FkaW5nIGFuIGFsdGVybmF0ZSB0cmFjayBpbiB0aGUgc2FtZSBncm91cCwgZG8gbm90IGxvYWQgYW55dGhpbmdcbiAgICBpZiAodGhpcy5hbHRBdWRpbyAmJiB0aGlzLmF1ZGlvT25seSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghbGV2ZWxzPy5bbGV2ZWxdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW2xldmVsXTtcblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3REZXRhaWxzID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKTtcbiAgICBpZiAobGFzdERldGFpbHMgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgbGFzdERldGFpbHMpKSB7XG4gICAgICBjb25zdCBkYXRhOiBCdWZmZXJFT1NEYXRhID0ge307XG4gICAgICBpZiAodGhpcy5hbHRBdWRpbykge1xuICAgICAgICBkYXRhLnR5cGUgPSAndmlkZW8nO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRU9TLCBkYXRhKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgbmV4dCBsb2FkIGxldmVsIDogdGhpcyB3aWxsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkIGlmIG5lZWRlZFxuICAgIGlmIChobHMubG9hZExldmVsICE9PSBsZXZlbCAmJiBobHMubWFudWFsTGV2ZWwgPT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtsZXZlbH0gZnJvbSBsZXZlbCAke3RoaXMubGV2ZWx9YCk7XG4gICAgfVxuICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IGxldmVsO1xuXG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKFxuICAgICAgIWxldmVsRGV0YWlscyB8fFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fFxuICAgICAgKGxldmVsRGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbEluZm8pXG4gICAgKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXJMZW4gPSBidWZmZXJJbmZvLmxlbjtcblxuICAgIC8vIGNvbXB1dGUgbWF4IEJ1ZmZlciBMZW5ndGggdGhhdCB3ZSBjb3VsZCBnZXQgZnJvbSB0aGlzIGxvYWQgbGV2ZWwsIGJhc2VkIG9uIGxldmVsIGJpdHJhdGUuIGRvbid0IGJ1ZmZlciBtb3JlIHRoYW4gNjAgTUIgYW5kIG1vcmUgdGhhbiAzMHNcbiAgICBjb25zdCBtYXhCdWZMZW4gPSB0aGlzLmdldE1heEJ1ZmZlckxlbmd0aChsZXZlbEluZm8ubWF4Qml0cmF0ZSk7XG5cbiAgICAvLyBTdGF5IGlkbGUgaWYgd2UgYXJlIHN0aWxsIHdpdGggYnVmZmVyIG1hcmdpbnNcbiAgICBpZiAoYnVmZmVyTGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiZcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgPiBidWZmZXJJbmZvLmVuZFxuICAgICkge1xuICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEJ1ZmZlclRpbWUgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50XG4gICAgICA/IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnRcbiAgICAgIDogYnVmZmVySW5mby5lbmQ7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgIGlmIChcbiAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgJiZcbiAgICAgICF0aGlzLmZyYWdQcmV2aW91cyAmJlxuICAgICAgZnJhZyAmJlxuICAgICAgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJlxuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0tcbiAgICApIHtcbiAgICAgIGNvbnN0IGJhY2t0cmFja1NuID0gKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPz8gZnJhZykuc24gYXMgbnVtYmVyO1xuICAgICAgY29uc3QgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICBpZiAoYmFja3RyYWNrRnJhZyAmJiBmcmFnLmNjID09PSBiYWNrdHJhY2tGcmFnLmNjKSB7XG4gICAgICAgIGZyYWcgPSBiYWNrdHJhY2tGcmFnO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICBpZiAoIWdhcFN0YXJ0KSB7XG4gICAgICAgIC8vIENsZWFudXAgdGhlIGZyYWdtZW50IHRyYWNrZXIgYmVmb3JlIHRyeWluZyB0byBmaW5kIHRoZSBuZXh0IHVuYnVmZmVyZWQgZnJhZ21lbnRcbiAgICAgICAgY29uc3QgdHlwZSA9XG4gICAgICAgICAgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW9cbiAgICAgICAgICAgID8gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXG4gICAgICAgICAgICA6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTztcbiAgICAgICAgY29uc3QgbWVkaWFCdWZmZXIgPVxuICAgICAgICAgICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU9cbiAgICAgICAgICAgID8gdGhpcy52aWRlb0J1ZmZlclxuICAgICAgICAgICAgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgICBpZiAobWVkaWFCdWZmZXIpIHtcbiAgICAgICAgICB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYUJ1ZmZlciwgdHlwZSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKFxuICAgICAgICBmcmFnLFxuICAgICAgICBsZXZlbERldGFpbHMsXG4gICAgICAgIGJ1ZmZlckluZm8sXG4gICAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sXG4gICAgICAgIG1heEJ1ZkxlbixcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbEluZm8sIHRhcmdldEJ1ZmZlclRpbWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGxvYWRGcmFnbWVudChcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBsZXZlbDogTGV2ZWwsXG4gICAgdGFyZ2V0QnVmZmVyVGltZTogbnVtYmVyLFxuICApIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKFxuICAgICAgZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQgfHxcbiAgICAgIGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMXG4gICAgKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fbG9hZEJpdHJhdGVUZXN0RnJhZyhmcmFnLCBsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKFxuICAgICAgcG9zaXRpb24sXG4gICAgICBQbGF5bGlzdExldmVsVHlwZS5NQUlOLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhmcmFnOiBGcmFnbWVudCB8IG51bGwpIHtcbiAgICBpZiAoZnJhZykge1xuICAgICAgLy8gdHJ5IHRvIGdldCByYW5nZSBvZiBuZXh0IGZyYWdtZW50ICg1MDBtcyBhZnRlciB0aGlzIHJhbmdlKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKGZyYWcuZW5kICsgMC41KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgIG9uIGltbWVkaWF0ZSBsZXZlbCBzd2l0Y2ggOlxuICAgICAtIHBhdXNlIHBsYXliYWNrIGlmIHBsYXlpbmdcbiAgICAgLSBjYW5jZWwgYW55IHBlbmRpbmcgbG9hZCByZXF1ZXN0XG4gICAgIC0gYW5kIHRyaWdnZXIgYSBidWZmZXIgZmx1c2hcbiAgKi9cbiAgcHVibGljIGltbWVkaWF0ZUxldmVsU3dpdGNoKCkge1xuICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gIH1cblxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIHB1YmxpYyBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgY29uc3QgeyBsZXZlbHMsIG1lZGlhIH0gPSB0aGlzO1xuICAgIC8vIGVuc3VyZSB0aGF0IG1lZGlhIGlzIGRlZmluZWQgYW5kIHRoYXQgbWV0YWRhdGEgYXJlIGF2YWlsYWJsZSAodG8gcmV0cmlldmUgY3VycmVudFRpbWUpXG4gICAgaWYgKG1lZGlhPy5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgZmV0Y2hkZWxheTtcbiAgICAgIGNvbnN0IGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQgJiYgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0ID4gMSkge1xuICAgICAgICAvLyBmbHVzaCBidWZmZXIgcHJlY2VkaW5nIGN1cnJlbnQgZnJhZ21lbnQgKGZsdXNoIHVudGlsIGN1cnJlbnQgZnJhZ21lbnQgc3RhcnQgb2Zmc2V0KVxuICAgICAgICAvLyBtaW51cyAxcyB0byBhdm9pZCB2aWRlbyBmcmVlemluZywgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgZmx1c2gga2V5ZnJhbWUgb2YgY3VycmVudCB2aWRlbyAuLi5cbiAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgZnJhZ1BsYXlpbmdDdXJyZW50LnN0YXJ0IC0gMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXZlbERldGFpbHMgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgICAgaWYgKGxldmVsRGV0YWlscz8ubGl2ZSkge1xuICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAvLyBEbyBub3QgZmx1c2ggaW4gbGl2ZSBzdHJlYW0gd2l0aCBsb3cgYnVmZmVyXG4gICAgICAgIGlmICghYnVmZmVySW5mbyB8fCBidWZmZXJJbmZvLmxlbiA8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbiAqIDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWVkaWEucGF1c2VkICYmIGxldmVscykge1xuICAgICAgICAvLyBhZGQgYSBzYWZldHkgZGVsYXkgb2YgMXNcbiAgICAgICAgY29uc3QgbmV4dExldmVsSWQgPSB0aGlzLmhscy5uZXh0TG9hZExldmVsO1xuICAgICAgICBjb25zdCBuZXh0TGV2ZWwgPSBsZXZlbHNbbmV4dExldmVsSWRdO1xuICAgICAgICBjb25zdCBmcmFnTGFzdEticHMgPSB0aGlzLmZyYWdMYXN0S2JwcztcbiAgICAgICAgaWYgKGZyYWdMYXN0S2JwcyAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgZmV0Y2hkZWxheSA9XG4gICAgICAgICAgICAodGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiAqIG5leHRMZXZlbC5tYXhCaXRyYXRlKSAvXG4gICAgICAgICAgICAgICgxMDAwICogZnJhZ0xhc3RLYnBzKSArXG4gICAgICAgICAgICAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUU1xuICAgICAgICAgICAgPyBuZXh0QnVmZmVyZWRGcmFnLm1heFN0YXJ0UFRTXG4gICAgICAgICAgICA6IG5leHRCdWZmZXJlZEZyYWcuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgZnJhZ0R1cmF0aW9uID0gbmV4dEJ1ZmZlcmVkRnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBzdGFydFB0cyA9IE1hdGgubWF4KFxuICAgICAgICAgICAgYnVmZmVyZWRGcmFnLmVuZCxcbiAgICAgICAgICAgIG1heFN0YXJ0ICtcbiAgICAgICAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICBmcmFnRHVyYXRpb24gLSB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLFxuICAgICAgICAgICAgICAgICAgZnJhZ0R1cmF0aW9uICogKHRoaXMuY291bGRCYWNrdHJhY2sgPyAwLjUgOiAwLjEyNSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBmcmFnRHVyYXRpb24gKiAodGhpcy5jb3VsZEJhY2t0cmFjayA/IDAuNzUgOiAwLjI1KSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHN0YXJ0UHRzLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQ6IG51bWJlciwgZW5kT2Zmc2V0OiBudW1iZXIpIHtcbiAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoXG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIHRoaXMuYWx0QXVkaW8gPyAndmlkZW8nIDogbnVsbCxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG9uTWVkaWFBdHRhY2hlZChcbiAgICBldmVudDogRXZlbnRzLk1FRElBX0FUVEFDSEVELFxuICAgIGRhdGE6IE1lZGlhQXR0YWNoZWREYXRhLFxuICApIHtcbiAgICBzdXBlci5vbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpO1xuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9uTWVkaWFQbGF5aW5nLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbnZzZWVrZWQgPSB0aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCdwbGF5aW5nJywgdGhpcy5vbnZwbGF5aW5nIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG5ldyBHYXBDb250cm9sbGVyKFxuICAgICAgdGhpcy5jb25maWcsXG4gICAgICBtZWRpYSxcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLFxuICAgICAgdGhpcy5obHMsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKG1lZGlhICYmIHRoaXMub252cGxheWluZyAmJiB0aGlzLm9udnNlZWtlZCkge1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub252cGxheWluZyk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWVrZWQnLCB0aGlzLm9udnNlZWtlZCk7XG4gICAgICB0aGlzLm9udnBsYXlpbmcgPSB0aGlzLm9udnNlZWtlZCA9IG51bGw7XG4gICAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnUGxheWluZyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZ2FwQ29udHJvbGxlcikge1xuICAgICAgdGhpcy5nYXBDb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1lZGlhU2Vla2VkKCkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhID8gbWVkaWEuY3VycmVudFRpbWUgOiBudWxsO1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmxvZyhgTWVkaWEgc2Vla2VkIHRvICR7KGN1cnJlbnRUaW1lIGFzIG51bWJlcikudG9GaXhlZCgzKX1gKTtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWVrZWQgd2FzIGlzc3VlZCBiZWZvcmUgYnVmZmVyIHdhcyBhcHBlbmRlZCBkbyBub3QgdGljayBpbW1lZGlhdGVseVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgaWYgKGJ1ZmZlckluZm8gPT09IG51bGwgfHwgYnVmZmVySW5mby5sZW4gPT09IDApIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIG9uIFwic2Vla2VkXCIgZXZlbnQgJHtcbiAgICAgICAgICBidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknXG4gICAgICAgIH0pYCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICAvLyByZXNldCBidWZmZXIgb24gbWFuaWZlc3QgbG9hZGluZ1xuICAgIHRoaXMubG9nKCdUcmlnZ2VyIEJVRkZFUl9SRVNFVCcpO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9SRVNFVCwgdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSB0aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgdGhpcy5sZXZlbHMgPVxuICAgICAgdGhpcy5mcmFnUGxheWluZyA9XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID1cbiAgICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID1cbiAgICAgICAgbnVsbDtcbiAgICB0aGlzLmFsdEF1ZGlvID0gdGhpcy5hdWRpb09ubHkgPSB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBvbk1hbmlmZXN0UGFyc2VkKFxuICAgIGV2ZW50OiBFdmVudHMuTUFOSUZFU1RfUEFSU0VELFxuICAgIGRhdGE6IE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgKSB7XG4gICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICBsZXQgYWFjID0gZmFsc2U7XG4gICAgbGV0IGhlYWFjID0gZmFsc2U7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaCgobGV2ZWwpID0+IHtcbiAgICAgIGNvbnN0IGNvZGVjID0gbGV2ZWwuYXVkaW9Db2RlYztcbiAgICAgIGlmIChjb2RlYykge1xuICAgICAgICBhYWMgPSBhYWMgfHwgY29kZWMuaW5kZXhPZignbXA0YS40MC4yJykgIT09IC0xO1xuICAgICAgICBoZWFhYyA9IGhlYWFjIHx8IGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggPSBhYWMgJiYgaGVhYWMgJiYgIWNoYW5nZVR5cGVTdXBwb3J0ZWQoKTtcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgJ0JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVscyA9IGRhdGEubGV2ZWxzO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxMb2FkaW5nKGV2ZW50OiBFdmVudHMuTEVWRUxfTE9BRElORywgZGF0YTogTGV2ZWxMb2FkaW5nRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWxzIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzIHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLklETEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbZGF0YS5sZXZlbF07XG4gICAgaWYgKFxuICAgICAgIWxldmVsLmRldGFpbHMgfHxcbiAgICAgIChsZXZlbC5kZXRhaWxzLmxpdmUgJiYgdGhpcy5sZXZlbExhc3RMb2FkZWQgIT09IGxldmVsKSB8fFxuICAgICAgdGhpcy53YWl0Rm9yQ2RuVHVuZUluKGxldmVsLmRldGFpbHMpXG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uTGV2ZWxMb2FkZWQoZXZlbnQ6IEV2ZW50cy5MRVZFTF9MT0FERUQsIGRhdGE6IExldmVsTG9hZGVkRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG5cbiAgICBpZiAoIWxldmVscykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBsb2FkaW5nIGxldmVsICR7bmV3TGV2ZWxJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coXG4gICAgICBgTGV2ZWwgJHtuZXdMZXZlbElkfSBsb2FkZWQgWyR7bmV3RGV0YWlscy5zdGFydFNOfSwke25ld0RldGFpbHMuZW5kU059XSR7XG4gICAgICAgIG5ld0RldGFpbHMubGFzdFBhcnRTblxuICAgICAgICAgID8gYFtwYXJ0LSR7bmV3RGV0YWlscy5sYXN0UGFydFNufS0ke25ld0RldGFpbHMubGFzdFBhcnRJbmRleH1dYFxuICAgICAgICAgIDogJydcbiAgICAgIH0sIGNjIFske25ld0RldGFpbHMuc3RhcnRDQ30sICR7bmV3RGV0YWlscy5lbmRDQ31dIGR1cmF0aW9uOiR7ZHVyYXRpb259YCxcbiAgICApO1xuXG4gICAgY29uc3QgY3VyTGV2ZWwgPSBsZXZlbHNbbmV3TGV2ZWxJZF07XG4gICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgIGlmIChcbiAgICAgIGZyYWdDdXJyZW50ICYmXG4gICAgICAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuRlJBR19MT0FESU5HIHx8XG4gICAgICAgIHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKVxuICAgICkge1xuICAgICAgaWYgKGZyYWdDdXJyZW50LmxldmVsICE9PSBkYXRhLmxldmVsICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2xpZGluZyA9IDA7XG4gICAgaWYgKG5ld0RldGFpbHMubGl2ZSB8fCBjdXJMZXZlbC5kZXRhaWxzPy5saXZlKSB7XG4gICAgICB0aGlzLmNoZWNrTGl2ZVVwZGF0ZShuZXdEZXRhaWxzKTtcbiAgICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKFxuICAgICAgICBuZXdEZXRhaWxzLFxuICAgICAgICBjdXJMZXZlbC5kZXRhaWxzLFxuICAgICAgICB0aGlzLmxldmVsTGFzdExvYWRlZD8uZGV0YWlscyxcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIG92ZXJyaWRlIGxldmVsIGluZm9cbiAgICBjdXJMZXZlbC5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IGN1ckxldmVsO1xuXG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfVVBEQVRFRCwge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGxldmVsOiBuZXdMZXZlbElkLFxuICAgIH0pO1xuXG4gICAgLy8gb25seSBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlIGlmIHdlIHdlcmUgd2FpdGluZyBmb3IgbGV2ZWwgdG8gc3RhcnQgZG93bmxvYWRpbmcgYSBuZXcgZnJhZ21lbnRcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuZXdEZXRhaWxzKSkge1xuICAgICAgICAvLyBXYWl0IGZvciBMb3ctTGF0ZW5jeSBDRE4gVHVuZS1pblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXJ0UG9zaXRpb24obmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmxpdmUpIHtcbiAgICAgIHRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKG5ld0RldGFpbHMpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YTogRnJhZ0xvYWRlZERhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIHBheWxvYWQgfSA9IGRhdGE7XG4gICAgY29uc3QgeyBsZXZlbHMgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscyBhcyBMZXZlbERldGFpbHM7XG4gICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICB0aGlzLndhcm4oXG4gICAgICAgIGBEcm9wcGluZyBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0YCxcbiAgICAgICk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC52aWRlb0NvZGVjO1xuXG4gICAgLy8gdGltZSBPZmZzZXQgaXMgYWNjdXJhdGUgaWYgbGV2ZWwgUFRTIGlzIGtub3duLCBvciBpZiBwbGF5bGlzdCBpcyBub3Qgc2xpZGluZyAobm90IGxpdmUpXG4gICAgY29uc3QgYWNjdXJhdGVUaW1lT2Zmc2V0ID0gZGV0YWlscy5QVFNLbm93biB8fCAhZGV0YWlscy5saXZlO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IGZyYWcuaW5pdFNlZ21lbnQ/LmRhdGE7XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IHRoaXMuX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKTtcblxuICAgIC8vIHRyYW5zbXV4IHRoZSBNUEVHLVRTIGRhdGEgdG8gSVNPLUJNRkYgc2VnbWVudHNcbiAgICAvLyB0aGlzLmxvZyhgVHJhbnNtdXhpbmcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSxsZXZlbCAke2ZyYWcubGV2ZWx9LCBjYyAke2ZyYWcuY2N9YCk7XG4gICAgY29uc3QgdHJhbnNtdXhlciA9ICh0aGlzLnRyYW5zbXV4ZXIgPVxuICAgICAgdGhpcy50cmFuc211eGVyIHx8XG4gICAgICBuZXcgVHJhbnNtdXhlckludGVyZmFjZShcbiAgICAgICAgdGhpcy5obHMsXG4gICAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSxcbiAgICAgICAgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcyksXG4gICAgICApKTtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKFxuICAgICAgZnJhZy5sZXZlbCxcbiAgICAgIGZyYWcuc24gYXMgbnVtYmVyLFxuICAgICAgZnJhZy5zdGF0cy5jaHVua0NvdW50LFxuICAgICAgcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgcGFydEluZGV4LFxuICAgICAgcGFydGlhbCxcbiAgICApO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG5cbiAgICB0cmFuc211eGVyLnB1c2goXG4gICAgICBwYXlsb2FkLFxuICAgICAgaW5pdFNlZ21lbnREYXRhLFxuICAgICAgYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWMsXG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGRldGFpbHMudG90YWxkdXJhdGlvbixcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIGluaXRQVFMsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgb25BdWRpb1RyYWNrU3dpdGNoaW5nKFxuICAgIGV2ZW50OiBFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLFxuICAgIGRhdGE6IEF1ZGlvVHJhY2tTd2l0Y2hpbmdEYXRhLFxuICApIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgZnJvbUFsdEF1ZGlvID0gdGhpcy5hbHRBdWRpbztcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhZGF0YS51cmw7XG4gICAgLy8gaWYgd2Ugc3dpdGNoIG9uIG1haW4gYXVkaW8sIGVuc3VyZSB0aGF0IG1haW4gZnJhZ21lbnQgc2NoZWR1bGluZyBpcyBzeW5jZWQgd2l0aCBtZWRpYS5idWZmZXJlZFxuICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIHdlIHN3aXRjaCB0byBhbHQgYXVkaW86IGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyIGlzIGhhbmRsaW5nIGl0LlxuICAgIC8vIHdlIHdpbGwganVzdCBoYXZlIHRvIGNoYW5nZSBidWZmZXIgc2NoZWR1bGluZyBvbiBhdWRpb1RyYWNrU3dpdGNoZWRcbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICBpZiAodGhpcy5tZWRpYUJ1ZmZlciAhPT0gdGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICAnU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnQgPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlZmlsbCBhdWRpbyBidWZmZXIgZnJvbSBtYWluOiBjYW5jZWwgYW55IGZyYWcgbG9hZGluZyB0byBzcGVlZCB1cCBhdWRpbyBzd2l0Y2hcbiAgICAgICAgaWYgKGZyYWdDdXJyZW50KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkJyk7XG4gICAgICAgICAgZnJhZ0N1cnJlbnQuYWJvcnRSZXF1ZXN0cygpO1xuICAgICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXN0cm95IHRyYW5zbXV4ZXIgdG8gZm9yY2UgaW5pdCBzZWdtZW50IGdlbmVyYXRpb24gKGZvbGxvd2luZyBhdWRpbyBzd2l0Y2gpXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAgIC8vIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIGxvYWQgbmV3IGZyYWdtZW50XG4gICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hdWRpb09ubHkpIHtcbiAgICAgICAgLy8gUmVzZXQgYXVkaW8gdHJhbnNtdXhlciBzbyB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIG1haW4gYXVkaW8gd2UncmUgbm90IHN0aWxsIGFwcGVuZGluZyB3aGVyZSB3ZSBsZWZ0IG9mZlxuICAgICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAvLyBJZiBzd2l0Y2hpbmcgZnJvbSBhbHQgdG8gbWFpbiBhdWRpbywgZmx1c2ggYWxsIGF1ZGlvIGFuZCB0cmlnZ2VyIHRyYWNrIHN3aXRjaGVkXG4gICAgICBpZiAoZnJvbUFsdEF1ZGlvKSB7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB9XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25BdWRpb1RyYWNrU3dpdGNoZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCxcbiAgICBkYXRhOiBBdWRpb1RyYWNrU3dpdGNoZWREYXRhLFxuICApIHtcbiAgICBjb25zdCB0cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgY29uc3QgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgdGhpcy5sb2coXG4gICAgICAgICAgJ1N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdmlkZW9CdWZmZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWx0QXVkaW8gPSBhbHRBdWRpbztcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgb25CdWZmZXJDcmVhdGVkKFxuICAgIGV2ZW50OiBFdmVudHMuQlVGRkVSX0NSRUFURUQsXG4gICAgZGF0YTogQnVmZmVyQ3JlYXRlZERhdGEsXG4gICkge1xuICAgIGNvbnN0IHRyYWNrcyA9IGRhdGEudHJhY2tzO1xuICAgIGxldCBtZWRpYVRyYWNrO1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBhbHRlcm5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdHJhY2tzKSB7XG4gICAgICBjb25zdCB0cmFjayA9IHRyYWNrc1t0eXBlXTtcbiAgICAgIGlmICh0cmFjay5pZCA9PT0gJ21haW4nKSB7XG4gICAgICAgIG5hbWUgPSB0eXBlO1xuICAgICAgICBtZWRpYVRyYWNrID0gdHJhY2s7XG4gICAgICAgIC8vIGtlZXAgdmlkZW8gc291cmNlIGJ1ZmZlciByZWZlcmVuY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvQnVmZmVyID0gdmlkZW9UcmFjay5idWZmZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHRlcm5hdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0ZXJuYXRlICYmIG1lZGlhVHJhY2spIHtcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgQWx0ZXJuYXRlIHRyYWNrIGZvdW5kLCB1c2UgJHtuYW1lfS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdgLFxuICAgICAgKTtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBtZWRpYVRyYWNrLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdCdWZmZXJlZChldmVudDogRXZlbnRzLkZSQUdfQlVGRkVSRUQsIGRhdGE6IEZyYWdCdWZmZXJlZERhdGEpIHtcbiAgICBjb25zdCB7IGZyYWcsIHBhcnQgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMud2FybihcbiAgICAgICAgYEZyYWdtZW50ICR7ZnJhZy5zbn0ke3BhcnQgPyAnIHA6ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7XG4gICAgICAgICAgZnJhZy5sZXZlbFxuICAgICAgICB9IGZpbmlzaGVkIGJ1ZmZlcmluZywgYnV0IHdhcyBhYm9ydGVkLiBzdGF0ZTogJHt0aGlzLnN0YXRlfWAsXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlBBUlNFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKFxuICAgICAgKDggKiBzdGF0cy50b3RhbCkgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpLFxuICAgICk7XG4gICAgaWYgKGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gZnJhZztcbiAgICB9XG4gICAgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KTtcbiAgfVxuXG4gIHByaXZhdGUgb25FcnJvcihldmVudDogRXZlbnRzLkVSUk9SLCBkYXRhOiBFcnJvckRhdGEpIHtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkYXRhLmxldmVsUmV0cnkgJiZcbiAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0xFVkVMICYmXG4gICAgICAgICAgZGF0YS5jb250ZXh0Py50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAoIWRhdGEucGFyZW50IHx8IGRhdGEucGFyZW50ICE9PSAnbWFpbicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgICAgdGhpcy5yZWNvdmVyV29ya2VyRXJyb3IoZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIHByaXZhdGUgY2hlY2tCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBtZWRpYSwgZ2FwQ29udHJvbGxlciB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFnYXBDb250cm9sbGVyIHx8ICFtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGRvbid0IGhhdmUgbWVkaWEgb3IgaWYgdGhlIG1lZGlhIGhhc24ndCBidWZmZXJlZCBhbnl0aGluZyB5ZXQgKHJlYWR5U3RhdGUgMClcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBjb25zdCBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkJ1ZmZlckZsdXNoZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5CVUZGRVJfRkxVU0hFRCxcbiAgICB7IHR5cGUgfTogQnVmZmVyRmx1c2hlZERhdGEsXG4gICkge1xuICAgIGlmIChcbiAgICAgIHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyB8fFxuICAgICAgKHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvKVxuICAgICkge1xuICAgICAgY29uc3QgbWVkaWFCdWZmZXIgPVxuICAgICAgICAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXG4gICAgICAgICAgPyB0aGlzLnZpZGVvQnVmZmVyXG4gICAgICAgICAgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkxldmVsc1VwZGF0ZWQoXG4gICAgZXZlbnQ6IEV2ZW50cy5MRVZFTFNfVVBEQVRFRCxcbiAgICBkYXRhOiBMZXZlbHNVcGRhdGVkRGF0YSxcbiAgKSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50KSB7XG4gICAgICB0aGlzLmxldmVsID0gdGhpcy5mcmFnQ3VycmVudC5sZXZlbDtcbiAgICB9XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgfVxuXG4gIHB1YmxpYyBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cblxuICAvKipcbiAgICogU2Vla3MgdG8gdGhlIHNldCBzdGFydFBvc2l0aW9uIGlmIG5vdCBlcXVhbCB0byB0aGUgbWVkaWFFbGVtZW50J3MgY3VycmVudCB0aW1lLlxuICAgKi9cbiAgcHJvdGVjdGVkIHNlZWtUb1N0YXJ0UG9zKCkge1xuICAgIGNvbnN0IHsgbWVkaWEgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGxldCBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGlmIChzdGFydFBvc2l0aW9uID49IDAgJiYgY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICB0aGlzLmxvZyhcbiAgICAgICAgICBgY291bGQgbm90IHNlZWsgdG8gJHtzdGFydFBvc2l0aW9ufSwgYWxyZWFkeSBzZWVraW5nIGF0ICR7Y3VycmVudFRpbWV9YCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgY29uc3QgYnVmZmVyU3RhcnQgPSBidWZmZXJlZC5sZW5ndGggPyBidWZmZXJlZC5zdGFydCgwKSA6IDA7XG4gICAgICBjb25zdCBkZWx0YSA9IGJ1ZmZlclN0YXJ0IC0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmIChcbiAgICAgICAgZGVsdGEgPiAwICYmXG4gICAgICAgIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHxcbiAgICAgICAgICBkZWx0YSA8IHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2coYGFkanVzdGluZyBzdGFydCBwb3NpdGlvbiBieSAke2RlbHRhfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFxuICAgICAgICBgc2VlayB0byB0YXJnZXQgc3RhcnQgcG9zaXRpb24gJHtzdGFydFBvc2l0aW9ufSBmcm9tIGN1cnJlbnQgdGltZSAke2N1cnJlbnRUaW1lfWAsXG4gICAgICApO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF1ZGlvQ29kZWM7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWc6IEZyYWdtZW50LCBsZXZlbDogTGV2ZWwpIHtcbiAgICBmcmFnLmJpdHJhdGVUZXN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBjb25zdCB7IGhscyB9ID0gdGhpcztcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgIC8vIEJpdHJhdGUgdGVzdHMgZnJhZ21lbnRzIGFyZSBuZWl0aGVyIHBhcnNlZCBub3IgYnVmZmVyZWRcbiAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPVxuICAgICAgICBzdGF0cy5wYXJzaW5nLmVuZCA9XG4gICAgICAgIHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9XG4gICAgICAgIHN0YXRzLmJ1ZmZlcmluZy5lbmQgPVxuICAgICAgICAgIHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEgYXMgRnJhZ0xvYWRlZERhdGEpO1xuICAgICAgZnJhZy5iaXRyYXRlVGVzdCA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdDogVHJhbnNtdXhlclJlc3VsdCkge1xuICAgIGNvbnN0IGlkID0gJ21haW4nO1xuICAgIGNvbnN0IHsgaGxzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcmVtdXhSZXN1bHQsIGNodW5rTWV0YSB9ID0gdHJhbnNtdXhSZXN1bHQ7XG5cbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChjaHVua01ldGEpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdoZW5NaXNzaW5nQ29udGV4dChjaHVua01ldGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGZyYWcsIHBhcnQsIGxldmVsIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgdmlkZW8sIHRleHQsIGlkMywgaW5pdFNlZ21lbnQgfSA9IHJlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHsgZGV0YWlscyB9ID0gbGV2ZWw7XG4gICAgLy8gVGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGhhbmRsZXMgYXVkaW8gYnVmZmVyaW5nIGlmIEhscy5qcyBpcyBwbGF5aW5nIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5hbHRBdWRpbyA/IHVuZGVmaW5lZCA6IHJlbXV4UmVzdWx0LmF1ZGlvO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5QQVJTSU5HO1xuXG4gICAgaWYgKGluaXRTZWdtZW50KSB7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQ/LnRyYWNrcykge1xuICAgICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQoXG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgaW5pdFNlZ21lbnQudHJhY2tzLFxuICAgICAgICAgIG1hcEZyYWdtZW50LFxuICAgICAgICAgIGNodW5rTWV0YSxcbiAgICAgICAgKTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgICBmcmFnOiBtYXBGcmFnbWVudCxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0cmFja3M6IGluaXRTZWdtZW50LnRyYWNrcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcbiAgICAgIGNvbnN0IGluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTIGFzIG51bWJlcjtcbiAgICAgIGNvbnN0IHRpbWVzY2FsZSA9IGluaXRTZWdtZW50LnRpbWVzY2FsZSBhcyBudW1iZXI7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGluaXRQVFMpKSB7XG4gICAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHsgYmFzZVRpbWU6IGluaXRQVFMsIHRpbWVzY2FsZSB9O1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHsgZnJhZywgaWQsIGluaXRQVFMsIHRpbWVzY2FsZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdm9pZCBidWZmZXJpbmcgaWYgYmFja3RyYWNraW5nIHRoaXMgZnJhZ21lbnRcbiAgICBpZiAodmlkZW8gJiYgZGV0YWlscyAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGRldGFpbHMuZnJhZ21lbnRzW2ZyYWcuc24gLSAxIC0gZGV0YWlscy5zdGFydFNOXTtcbiAgICAgIGNvbnN0IGlzRmlyc3RGcmFnbWVudCA9IGZyYWcuc24gPT09IGRldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkgPSAhcHJldkZyYWcgfHwgZnJhZy5jYyA+IHByZXZGcmFnLmNjO1xuICAgICAgaWYgKHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMgfSA9IHZpZGVvO1xuICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbdmlkZW8udHlwZV0gPSB7XG4gICAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgICAgZW5kRFRTLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmlkZW8uZmlyc3RLZXlGcmFtZSAmJlxuICAgICAgICAgICAgdmlkZW8uaW5kZXBlbmRlbnQgJiZcbiAgICAgICAgICAgIGNodW5rTWV0YS5pZCA9PT0gMSAmJlxuICAgICAgICAgICAgIWlzRmlyc3RJbkRpc2NvbnRpbnVpdHlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmlkZW8uZHJvcHBlZCAmJiB2aWRlby5pbmRlcGVuZGVudCkge1xuICAgICAgICAgICAgLy8gQmFja3RyYWNrIGlmIGRyb3BwZWQgZnJhbWVzIGNyZWF0ZSBhIGdhcCBhZnRlciBjdXJyZW50VGltZVxuXG4gICAgICAgICAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9XG4gICAgICAgICAgICAgIChidWZmZXJJbmZvID8gYnVmZmVySW5mby5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArXG4gICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB2aWRlby5maXJzdEtleUZyYW1lUFRTXG4gICAgICAgICAgICAgID8gdmlkZW8uZmlyc3RLZXlGcmFtZVBUU1xuICAgICAgICAgICAgICA6IHN0YXJ0UFRTO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaXNGaXJzdEZyYWdtZW50ICYmXG4gICAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWUgPCBzdGFydFRpbWUgLSB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlICYmXG4gICAgICAgICAgICAgICFpc0ZpcnN0SW5EaXNjb250aW51aXR5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrdHJhY2soZnJhZyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICAvLyBNYXJrIHNlZ21lbnQgd2l0aCBhIGdhcCB0byBhdm9pZCBsb29wIGxvYWRpbmdcbiAgICAgICAgICAgICAgZnJhZy5nYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHZpZGVvIHN0cmVhbSBzdGFydCB0byBmcmFnbWVudCBzdGFydCBzbyB0aGF0IHRydW5jYXRlZCBzYW1wbGVzIGRvIG5vdCBkaXN0b3J0IHRoZSB0aW1lbGluZSwgYW5kIG1hcmsgaXQgcGFydGlhbFxuICAgICAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICAgICAgICAgICAgdmlkZW8udHlwZSBhcyBFbGVtZW50YXJ5U3RyZWFtVHlwZXMsXG4gICAgICAgICAgICAgIGZyYWcuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICAgICAgZnJhZy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kRFRTLFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCAmJiBzdGFydFBUUyA+IE1BWF9TVEFSVF9HQVBfSlVNUCkge1xuICAgICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gc2tpcCBsYXJnZSBzdGFydCBnYXBcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICAgICAgICB2aWRlby50eXBlIGFzIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTLFxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCkge1xuICAgICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKFxuICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgaXNGaXJzdEZyYWdtZW50IHx8IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCB8fCBpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdWRpbykge1xuICAgICAgY29uc3QgeyBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTIH0gPSBhdWRpbztcbiAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgIHBhcnQuZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IHtcbiAgICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgICBlbmRQVFMsXG4gICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgZW5kRFRTLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyhcbiAgICAgICAgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLFxuICAgICAgICBzdGFydFBUUyxcbiAgICAgICAgZW5kUFRTLFxuICAgICAgICBzdGFydERUUyxcbiAgICAgICAgZW5kRFRTLFxuICAgICAgKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cblxuICAgIGlmIChkZXRhaWxzICYmIGlkMz8uc2FtcGxlcz8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbWl0dGVkSUQzOiBGcmFnUGFyc2luZ01ldGFkYXRhRGF0YSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IGlkMy5zYW1wbGVzLFxuICAgICAgfTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIGVtaXR0ZWRJRDMpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiB0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dDogRnJhZ1BhcnNpbmdVc2VyZGF0YURhdGEgPSB7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBzYW1wbGVzOiB0ZXh0LnNhbXBsZXMsXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2J1ZmZlckluaXRTZWdtZW50KFxuICAgIGN1cnJlbnRMZXZlbDogTGV2ZWwsXG4gICAgdHJhY2tzOiBUcmFja1NldCxcbiAgICBmcmFnOiBGcmFnbWVudCxcbiAgICBjaHVua01ldGE6IENodW5rTWV0YWRhdGEsXG4gICkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hdWRpb09ubHkgPSAhIXRyYWNrcy5hdWRpbyAmJiAhdHJhY2tzLnZpZGVvO1xuXG4gICAgLy8gaWYgYXVkaW8gdHJhY2sgaXMgZXhwZWN0ZWQgdG8gY29tZSBmcm9tIGF1ZGlvIHN0cmVhbSBjb250cm9sbGVyLCBkaXNjYXJkIGFueSBjb21pbmcgZnJvbSBtYWluXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgIXRoaXMuYXVkaW9Pbmx5KSB7XG4gICAgICBkZWxldGUgdHJhY2tzLmF1ZGlvO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlIGxldmVsQ29kZWMgaW4gYXVkaW8gYW5kIHZpZGVvIHRyYWNrc1xuICAgIGNvbnN0IHsgYXVkaW8sIHZpZGVvLCBhdWRpb3ZpZGVvIH0gPSB0cmFja3M7XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBsZXQgYXVkaW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdCxcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyBpdC5cbiAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtLCBvciBpbiBGaXJlZm94XG4gICAgICAgIGlmIChhdWRpby5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgaWYgKFxuICAgICAgICBhdWRpb0NvZGVjICYmXG4gICAgICAgIGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xICYmXG4gICAgICAgIHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEgJiZcbiAgICAgICAgYXVkaW8uY29udGFpbmVyICE9PSAnYXVkaW8vbXBlZydcbiAgICAgICkge1xuICAgICAgICAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICB0aGlzLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHthdWRpb0NvZGVjfWApO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICYmIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nKFxuICAgICAgICAgIGBTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIiR7Y3VycmVudExldmVsLmF1ZGlvQ29kZWN9XCIgZm9yIFwiJHthdWRpb0NvZGVjfVwiYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGF1ZGlvLmxldmVsQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgICAgYXVkaW8uaWQgPSAnbWFpbic7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHtcbiAgICAgICAgICBhdWRpby5jb250YWluZXJcbiAgICAgICAgfSwgY29kZWNzW3NlbGVjdGVkL2xldmVsL3BhcnNlZF09WyR7YXVkaW9Db2RlYyB8fCAnJ30vJHtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYyB8fCAnJ1xuICAgICAgICB9LyR7YXVkaW8uY29kZWN9XWAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodmlkZW8pIHtcbiAgICAgIHZpZGVvLmxldmVsQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcbiAgICAgIHZpZGVvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgIGBJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7XG4gICAgICAgICAgdmlkZW8uY29udGFpbmVyXG4gICAgICAgIH0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2N1cnJlbnRMZXZlbC52aWRlb0NvZGVjIHx8ICcnfS8ke1xuICAgICAgICAgIHZpZGVvLmNvZGVjXG4gICAgICAgIH1dYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhdWRpb3ZpZGVvKSB7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgYEluaXQgYXVkaW92aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke2F1ZGlvdmlkZW8uY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7Y3VycmVudExldmVsLmNvZGVjc30vJHthdWRpb3ZpZGVvLmNvZGVjfV1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2goKHRyYWNrTmFtZSkgPT4ge1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgICBpZiAoaW5pdFNlZ21lbnQ/LmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0FQUEVORElORywge1xuICAgICAgICAgIHR5cGU6IHRyYWNrTmFtZSBhcyBTb3VyY2VCdWZmZXJOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNYWluRndkQnVmZmVySW5mbygpOiBCdWZmZXJJbmZvIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RndkQnVmZmVySW5mbyhcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYSxcbiAgICAgIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYmFja3RyYWNrKGZyYWc6IEZyYWdtZW50KSB7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgLy8gQ2F1c2VzIGZpbmRGcmFnbWVudHMgdG8gYmFja3RyYWNrIHRocm91Z2ggZnJhZ21lbnRzIHRvIGZpbmQgdGhlIGtleWZyYW1lXG4gICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IGZyYWc7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0O1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgbGV0IGZyYWdQbGF5aW5nQ3VycmVudDogRnJhZ21lbnQgfCBudWxsID0gbnVsbDtcbiAgICBpZiAodmlkZW8gJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDEgJiYgdmlkZW8uc2Vla2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgICAvKiBpZiB2aWRlbyBlbGVtZW50IGlzIGluIHNlZWtlZCBzdGF0ZSwgY3VycmVudFRpbWUgY2FuIG9ubHkgaW5jcmVhc2UuXG4gICAgICAgIChhc3N1bWluZyB0aGF0IHBsYXliYWNrIHJhdGUgaXMgcG9zaXRpdmUgLi4uKVxuICAgICAgICBBcyBzb21ldGltZXMgY3VycmVudFRpbWUganVtcHMgYmFjayB0byB6ZXJvIGFmdGVyIGFcbiAgICAgICAgbWVkaWEgZGVjb2RlIGVycm9yLCBjaGVjayB0aGlzLCB0byBhdm9pZCBzZWVraW5nIGJhY2sgdG9cbiAgICAgICAgd3JvbmcgcG9zaXRpb24gYWZ0ZXIgYSBtZWRpYSBkZWNvZGUgZXJyb3JcbiAgICAgICovXG5cbiAgICAgIGlmIChCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh2aWRlbywgY3VycmVudFRpbWUpKSB7XG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lICsgMC4xKSkge1xuICAgICAgICAvKiBlbnN1cmUgdGhhdCBGUkFHX0NIQU5HRUQgZXZlbnQgaXMgdHJpZ2dlcmVkIGF0IHN0YXJ0dXAsXG4gICAgICAgICAgd2hlbiBmaXJzdCB2aWRlbyBmcmFtZSBpcyBkaXNwbGF5ZWQgYW5kIHBsYXliYWNrIGlzIHBhdXNlZC5cbiAgICAgICAgICBhZGQgYSB0b2xlcmFuY2Ugb2YgMTAwbXMsIGluIGNhc2UgY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsXG4gICAgICAgICAgY2hlY2sgaWYgY3VycmVudCBwb3MrMTAwbXMgaXMgYnVmZmVyZWQgYW5kIHVzZSB0aGF0IGJ1ZmZlciByYW5nZVxuICAgICAgICAgIGZvciBGUkFHX0NIQU5HRUQgZXZlbnQgcmVwb3J0aW5nICovXG4gICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lICsgMC4xKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnUGxheWluZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGZyYWdQbGF5aW5nID0gdGhpcy5mcmFnUGxheWluZztcbiAgICAgICAgY29uc3QgZnJhZ0N1cnJlbnRMZXZlbCA9IGZyYWdQbGF5aW5nQ3VycmVudC5sZXZlbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFmcmFnUGxheWluZyB8fFxuICAgICAgICAgIGZyYWdQbGF5aW5nQ3VycmVudC5zbiAhPT0gZnJhZ1BsYXlpbmcuc24gfHxcbiAgICAgICAgICBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmZyYWdQbGF5aW5nID0gZnJhZ1BsYXlpbmdDdXJyZW50O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQ0hBTkdFRCwgeyBmcmFnOiBmcmFnUGxheWluZ0N1cnJlbnQgfSk7XG4gICAgICAgICAgaWYgKCFmcmFnUGxheWluZyB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENIRUQsIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGZyYWdDdXJyZW50TGV2ZWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgbmV4dExldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBjdXJyZW50RnJhZygpOiBGcmFnbWVudCB8IG51bGwge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdQbGF5aW5nIHx8IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXQgY3VycmVudFByb2dyYW1EYXRlVGltZSgpOiBEYXRlIHwgbnVsbCB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgICAgaWYgKFxuICAgICAgICBmcmFnICYmXG4gICAgICAgIE51bWJlci5pc0Zpbml0ZShjdXJyZW50VGltZSkgJiZcbiAgICAgICAgTnVtYmVyLmlzRmluaXRlKGZyYWcucHJvZ3JhbURhdGVUaW1lKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVwb2NNcyA9XG4gICAgICAgICAgKGZyYWcucHJvZ3JhbURhdGVUaW1lIGFzIG51bWJlcikgKyAoY3VycmVudFRpbWUgLSBmcmFnLnN0YXJ0KSAqIDEwMDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jTXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldCBjdXJyZW50TGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGdldCBuZXh0QnVmZmVyZWRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWcgPSB0aGlzLmN1cnJlbnRGcmFnO1xuICAgIGlmIChmcmFnKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCkge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVN0YXJ0TG9hZDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgYnVpbGRBYnNvbHV0ZVVSTCB9IGZyb20gJ3VybC10b29sa2l0JztcbmltcG9ydCBQbGF5bGlzdExvYWRlciBmcm9tICcuL2xvYWRlci9wbGF5bGlzdC1sb2FkZXInO1xuaW1wb3J0IElEM1RyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvaWQzLXRyYWNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IExhdGVuY3lDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9sYXRlbmN5LWNvbnRyb2xsZXInO1xuaW1wb3J0IExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvbGV2ZWwtY29udHJvbGxlcic7XG5pbXBvcnQgeyBGcmFnbWVudFRyYWNrZXIgfSBmcm9tICcuL2NvbnRyb2xsZXIvZnJhZ21lbnQtdHJhY2tlcic7XG5pbXBvcnQgS2V5TG9hZGVyIGZyb20gJy4vbG9hZGVyL2tleS1sb2FkZXInO1xuaW1wb3J0IFN0cmVhbUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL3N0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB7IGlzTVNFU3VwcG9ydGVkLCBpc1N1cHBvcnRlZCB9IGZyb20gJy4vaXMtc3VwcG9ydGVkJztcbmltcG9ydCB7IGdldE1lZGlhU291cmNlIH0gZnJvbSAnLi91dGlscy9tZWRpYXNvdXJjZS1oZWxwZXInO1xuaW1wb3J0IHsgbG9nZ2VyLCBlbmFibGVMb2dzIH0gZnJvbSAnLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgZW5hYmxlU3RyZWFtaW5nTW9kZSwgaGxzRGVmYXVsdENvbmZpZywgbWVyZ2VDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudGVtaXR0ZXIzJztcbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB7IEVycm9yVHlwZXMsIEVycm9yRGV0YWlscyB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGlzSGRjcExldmVsLCB0eXBlIEhkY3BMZXZlbCwgdHlwZSBMZXZlbCB9IGZyb20gJy4vdHlwZXMvbGV2ZWwnO1xuaW1wb3J0IHR5cGUgeyBIbHNFdmVudEVtaXR0ZXIsIEhsc0xpc3RlbmVycyB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB0eXBlIEF1ZGlvVHJhY2tDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9hdWRpby10cmFjay1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEFickNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Fici1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEJ1ZmZlckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2J1ZmZlci1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIENhcExldmVsQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvY2FwLWxldmVsLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQ01DRENvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NtY2QtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBFTUVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9lbWUtY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvc3VidGl0bGUtdHJhY2stY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSB7XG4gIEFickNvbXBvbmVudEFQSSxcbiAgQ29tcG9uZW50QVBJLFxuICBOZXR3b3JrQ29tcG9uZW50QVBJLFxufSBmcm9tICcuL3R5cGVzL2NvbXBvbmVudC1hcGknO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1NlbGVjdGlvbk9wdGlvbixcbiAgTWVkaWFQbGF5bGlzdCxcbiAgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24sXG4gIFZpZGVvU2VsZWN0aW9uT3B0aW9uLFxufSBmcm9tICcuL3R5cGVzL21lZGlhLXBsYXlsaXN0JztcbmltcG9ydCB0eXBlIHsgSGxzQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHR5cGUgeyBCdWZmZXJJbmZvIH0gZnJvbSAnLi91dGlscy9idWZmZXItaGVscGVyJztcbmltcG9ydCB0eXBlIEF1ZGlvU3RyZWFtQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYXVkaW8tc3RyZWFtLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgQmFzZVBsYXlsaXN0Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvYmFzZS1wbGF5bGlzdC1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIEJhc2VTdHJlYW1Db250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci9iYXNlLXN0cmVhbS1jb250cm9sbGVyJztcbmltcG9ydCB0eXBlIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2NvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlcic7XG5pbXBvcnQgdHlwZSBFcnJvckNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXInO1xuaW1wb3J0IHR5cGUgRlBTQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIvZnBzLWNvbnRyb2xsZXInO1xuXG4vKipcbiAqIFRoZSBgSGxzYCBjbGFzcyBpcyB0aGUgY29yZSBvZiB0aGUgSExTLmpzIGxpYnJhcnkgdXNlZCB0byBpbnN0YW50aWF0ZSBwbGF5ZXIgaW5zdGFuY2VzLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIbHMgaW1wbGVtZW50cyBIbHNFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHN0YXRpYyBkZWZhdWx0Q29uZmlnOiBIbHNDb25maWcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBydW50aW1lIGNvbmZpZ3VyYXRpb24gdXNlZCBieSB0aGUgcGxheWVyLiBBdCBpbnN0YW50aWF0aW9uIHRoaXMgaXMgY29tYmluYXRpb24gb2YgYGhscy51c2VyQ29uZmlnYCBtZXJnZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNvbmZpZzogSGxzQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QgcHJvdmlkZWQgb24gcGxheWVyIGluc3RhbnRpYXRpb24uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdXNlckNvbmZpZzogUGFydGlhbDxIbHNDb25maWc+O1xuXG4gIHByaXZhdGUgY29yZUNvbXBvbmVudHM6IENvbXBvbmVudEFQSVtdO1xuICBwcml2YXRlIG5ldHdvcmtDb250cm9sbGVyczogTmV0d29ya0NvbXBvbmVudEFQSVtdO1xuICBwcml2YXRlIHN0YXJ0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfZW1pdHRlcjogSGxzRXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBwcml2YXRlIF9hdXRvTGV2ZWxDYXBwaW5nOiBudW1iZXIgPSAtMTtcbiAgcHJpdmF0ZSBfbWF4SGRjcExldmVsOiBIZGNwTGV2ZWwgPSBudWxsO1xuICBwcml2YXRlIGFickNvbnRyb2xsZXI6IEFickNvbXBvbmVudEFQSTtcbiAgcHJpdmF0ZSBidWZmZXJDb250cm9sbGVyOiBCdWZmZXJDb250cm9sbGVyO1xuICBwcml2YXRlIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyO1xuICBwcml2YXRlIGxhdGVuY3lDb250cm9sbGVyOiBMYXRlbmN5Q29udHJvbGxlcjtcbiAgcHJpdmF0ZSBsZXZlbENvbnRyb2xsZXI6IExldmVsQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBzdHJlYW1Db250cm9sbGVyOiBTdHJlYW1Db250cm9sbGVyO1xuICBwcml2YXRlIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjogU3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gIHByaXZhdGUgZW1lQ29udHJvbGxlcjogRU1FQ29udHJvbGxlcjtcbiAgcHJpdmF0ZSBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXI7XG4gIHByaXZhdGUgX21lZGlhOiBIVE1MTWVkaWFFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdXJsOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0cmlnZ2VyaW5nRXhjZXB0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWRlby1kZXYvaGxzLmpzIHBhY2thZ2UgdmVyc2lvbi5cbiAgICovXG4gIHN0YXRpYyBnZXQgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBfX1ZFUlNJT05fXztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcmVxdWlyZWQgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgc3RhdGljIGlzTVNFU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc01TRVN1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIE1lZGlhU291cmNlIEV4dGVuc2lvbnMgYXJlIGF2YWlsYWJsZSBhbmQgaXNUeXBlU3VwcG9ydGVkIGNoZWNrcyBwYXNzIGZvciBhbnkgYmFzZWxpbmUgY29kZWNzLlxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1N1cHBvcnRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgTWVkaWFTb3VyY2UgZ2xvYmFsIHVzZWQgZm9yIE1TRSBwbGF5YmFjayAoTWFuYWdlZE1lZGlhU291cmNlLCBNZWRpYVNvdXJjZSwgb3IgV2ViS2l0TWVkaWFTb3VyY2UpLlxuICAgKi9cbiAgc3RhdGljIGdldE1lZGlhU291cmNlKCk6IHR5cGVvZiBNZWRpYVNvdXJjZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGdldE1lZGlhU291cmNlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50cygpOiB0eXBlb2YgRXZlbnRzIHtcbiAgICByZXR1cm4gRXZlbnRzO1xuICB9XG5cbiAgc3RhdGljIGdldCBFcnJvclR5cGVzKCk6IHR5cGVvZiBFcnJvclR5cGVzIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXJyb3JEZXRhaWxzKCk6IHR5cGVvZiBFcnJvckRldGFpbHMge1xuICAgIHJldHVybiBFcnJvckRldGFpbHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gYXBwbGllZCB0byBuZXcgaW5zdGFuY2VzLlxuICAgKi9cbiAgc3RhdGljIGdldCBEZWZhdWx0Q29uZmlnKCk6IEhsc0NvbmZpZyB7XG4gICAgaWYgKCFIbHMuZGVmYXVsdENvbmZpZykge1xuICAgICAgcmV0dXJuIGhsc0RlZmF1bHRDb25maWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcoZGVmYXVsdENvbmZpZzogSGxzQ29uZmlnKSB7XG4gICAgSGxzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKiBAcGFyYW0gdXNlckNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcHBsaWVkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYFxuICAgKi9cbiAgY29uc3RydWN0b3IodXNlckNvbmZpZzogUGFydGlhbDxIbHNDb25maWc+ID0ge30pIHtcbiAgICBlbmFibGVMb2dzKHVzZXJDb25maWcuZGVidWcgfHwgZmFsc2UsICdIbHMgaW5zdGFuY2UnKTtcbiAgICBjb25zdCBjb25maWcgPSAodGhpcy5jb25maWcgPSBtZXJnZUNvbmZpZyhIbHMuRGVmYXVsdENvbmZpZywgdXNlckNvbmZpZykpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHVzZXJDb25maWc7XG5cbiAgICBpZiAoY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICBlbmFibGVTdHJlYW1pbmdNb2RlKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gY29yZSBjb250cm9sbGVycyBhbmQgbmV0d29yayBsb2FkZXJzXG4gICAgY29uc3Qge1xuICAgICAgYWJyQ29udHJvbGxlcjogQ29uZmlnQWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IENvbmZpZ0NhcExldmVsQ29udHJvbGxlcixcbiAgICAgIGVycm9yQ29udHJvbGxlcjogQ29uZmlnRXJyb3JDb250cm9sbGVyLFxuICAgICAgZnBzQ29udHJvbGxlcjogQ29uZmlnRnBzQ29udHJvbGxlcixcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGVycm9yQ29udHJvbGxlciA9IG5ldyBDb25maWdFcnJvckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9ICh0aGlzLmFickNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQWJyQ29udHJvbGxlcih0aGlzKSk7XG4gICAgY29uc3QgYnVmZmVyQ29udHJvbGxlciA9ICh0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPVxuICAgICAgbmV3IENvbmZpZ0J1ZmZlckNvbnRyb2xsZXIodGhpcykpO1xuICAgIGNvbnN0IGNhcExldmVsQ29udHJvbGxlciA9ICh0aGlzLmNhcExldmVsQ29udHJvbGxlciA9XG4gICAgICBuZXcgQ29uZmlnQ2FwTGV2ZWxDb250cm9sbGVyKHRoaXMpKTtcblxuICAgIGNvbnN0IGZwc0NvbnRyb2xsZXIgPSBuZXcgQ29uZmlnRnBzQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBwbGF5TGlzdExvYWRlciA9IG5ldyBQbGF5bGlzdExvYWRlcih0aGlzKTtcbiAgICBjb25zdCBpZDNUcmFja0NvbnRyb2xsZXIgPSBuZXcgSUQzVHJhY2tDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgY29uc3QgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA9IGNvbmZpZy5jb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIC8vIENvbmVudFN0ZWVyaW5nQ29udHJvbGxlciBpcyBkZWZpbmVkIGJlZm9yZSBMZXZlbENvbnRyb2xsZXIgdG8gcmVjZWl2ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3QgZXZlbnRzIGZpcnN0XG4gICAgY29uc3QgY29udGVudFN0ZWVyaW5nID0gQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlclxuICAgICAgPyBuZXcgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlcih0aGlzKVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGxldmVsQ29udHJvbGxlciA9ICh0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIoXG4gICAgICB0aGlzLFxuICAgICAgY29udGVudFN0ZWVyaW5nLFxuICAgICkpO1xuICAgIC8vIEZyYWdtZW50VHJhY2tlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIFN0cmVhbUNvbnRyb2xsZXIgYmVjYXVzZSB0aGUgb3JkZXIgb2YgZXZlbnQgaGFuZGxpbmcgaXMgaW1wb3J0YW50XG4gICAgY29uc3QgZnJhZ21lbnRUcmFja2VyID0gbmV3IEZyYWdtZW50VHJhY2tlcih0aGlzKTtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgS2V5TG9hZGVyKHRoaXMuY29uZmlnKTtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gKHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKFxuICAgICAgdGhpcyxcbiAgICAgIGZyYWdtZW50VHJhY2tlcixcbiAgICAgIGtleUxvYWRlcixcbiAgICApKTtcblxuICAgIC8vIENhcCBsZXZlbCBjb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBmbHVzaCB0aGUgYnVmZmVyXG4gICAgY2FwTGV2ZWxDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgLy8gZnBzQ29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gc3dpdGNoIHdoZW4gZnJhbWVzIGFyZSBiZWluZyBkcm9wcGVkXG4gICAgZnBzQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuXG4gICAgY29uc3QgbmV0d29ya0NvbnRyb2xsZXJzOiBOZXR3b3JrQ29tcG9uZW50QVBJW10gPSBbXG4gICAgICBwbGF5TGlzdExvYWRlcixcbiAgICAgIGxldmVsQ29udHJvbGxlcixcbiAgICAgIHN0cmVhbUNvbnRyb2xsZXIsXG4gICAgXTtcbiAgICBpZiAoY29udGVudFN0ZWVyaW5nKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMuc3BsaWNlKDEsIDAsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMgPSBuZXR3b3JrQ29udHJvbGxlcnM7XG4gICAgY29uc3QgY29yZUNvbXBvbmVudHM6IENvbXBvbmVudEFQSVtdID0gW1xuICAgICAgYWJyQ29udHJvbGxlcixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXIsXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICBmcHNDb250cm9sbGVyLFxuICAgICAgaWQzVHJhY2tDb250cm9sbGVyLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgIF07XG5cbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyLFxuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLFxuICAgICk7XG4gICAgY29uc3QgQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuYXVkaW9TdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goXG4gICAgICAgIG5ldyBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciksXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgY29uZmlnLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLFxuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLFxuICAgICk7XG4gICAgY29uc3QgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MgPSBjb25maWcuc3VidGl0bGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGlmIChTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcykge1xuICAgICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goXG4gICAgICAgIG5ldyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciksXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLnRpbWVsaW5lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIGtleUxvYWRlci5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKFxuICAgICAgY29uZmlnLmVtZUNvbnRyb2xsZXIsXG4gICAgICBjb3JlQ29tcG9uZW50cyxcbiAgICApO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoXG4gICAgICBjb25maWcuY21jZENvbnRyb2xsZXIsXG4gICAgICBjb3JlQ29tcG9uZW50cyxcbiAgICApO1xuICAgIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoXG4gICAgICBMYXRlbmN5Q29udHJvbGxlcixcbiAgICAgIGNvcmVDb21wb25lbnRzLFxuICAgICk7XG5cbiAgICB0aGlzLmNvcmVDb21wb25lbnRzID0gY29yZUNvbXBvbmVudHM7XG5cbiAgICAvLyBFcnJvciBjb250cm9sbGVyIGhhbmRsZXMgZXJyb3JzIGJlZm9yZSBhbmQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzXG4gICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgYWxsIG90aGVyIGNvbnRyb2xsZXJzIGVycm9yIGxpc3RlbmVyc1xuICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKGVycm9yQ29udHJvbGxlcik7XG4gICAgY29uc3Qgb25FcnJvck91dCA9IGVycm9yQ29udHJvbGxlci5vbkVycm9yT3V0O1xuICAgIGlmICh0eXBlb2Ygb25FcnJvck91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbihFdmVudHMuRVJST1IsIG9uRXJyb3JPdXQsIGVycm9yQ29udHJvbGxlcik7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlQ29udHJvbGxlcihDb250cm9sbGVyQ2xhc3MsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVySW5zdGFuY2UgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMpO1xuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZSBFdmVudEVtaXR0ZXIgdGhyb3VnaCB0aGUgcHVibGljIEFQSSBvZiBIbHMuanNcbiAgb248RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGhpcyBhcyBhbnksXG4gICkge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuXG4gIG9uY2U8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycywgQ29udGV4dCA9IHVuZGVmaW5lZD4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbGlzdGVuZXI6IEhsc0xpc3RlbmVyc1tFXSxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGhpcyBhcyBhbnksXG4gICkge1xuICAgIHRoaXMuX2VtaXR0ZXIub25jZShldmVudCwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICB9XG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50PzogRSB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KTtcbiAgfVxuXG4gIG9mZjxFIGV4dGVuZHMga2V5b2YgSGxzTGlzdGVuZXJzLCBDb250ZXh0ID0gdW5kZWZpbmVkPihcbiAgICBldmVudDogRSxcbiAgICBsaXN0ZW5lcj86IEhsc0xpc3RlbmVyc1tFXSB8IHVuZGVmaW5lZCxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGhpcyBhcyBhbnksXG4gICAgb25jZT86IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gICkge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCwgb25jZSk7XG4gIH1cblxuICBsaXN0ZW5lcnM8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oZXZlbnQ6IEUpOiBIbHNMaXN0ZW5lcnNbRV1bXSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGV2ZW50KTtcbiAgfVxuXG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIEhsc0xpc3RlbmVycz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgbmFtZTogRSxcbiAgICBldmVudE9iamVjdDogUGFyYW1ldGVyczxIbHNMaXN0ZW5lcnNbRV0+WzFdLFxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH1cblxuICB0cmlnZ2VyPEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KFxuICAgIGV2ZW50OiBFLFxuICAgIGV2ZW50T2JqZWN0OiBQYXJhbWV0ZXJzPEhsc0xpc3RlbmVyc1tFXT5bMV0sXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgZXZlbnQsIGV2ZW50T2JqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcbiAgICAgICAgICAnQW4gaW50ZXJuYWwgZXJyb3IgaGFwcGVuZWQgd2hpbGUgaGFuZGxpbmcgZXZlbnQgJyArXG4gICAgICAgICAgICBldmVudCArXG4gICAgICAgICAgICAnLiBFcnJvciBtZXNzYWdlOiBcIicgK1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArXG4gICAgICAgICAgICAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICk7XG4gICAgICAgIC8vIFByZXZlbnQgcmVjdXJzaW9uIGluIGVycm9yIGV2ZW50IGhhbmRsZXJzIHRoYXQgdGhyb3cgIzU0OTdcbiAgICAgICAgaWYgKCF0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24pIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGZhdGFsID0gZXZlbnQgPT09IEV2ZW50cy5FUlJPUjtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgIGZhdGFsLFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsaXN0ZW5lckNvdW50PEUgZXh0ZW5kcyBrZXlvZiBIbHNMaXN0ZW5lcnM+KGV2ZW50OiBFKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb21wb25lbnQpID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goKGNvbXBvbmVudCkgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIC8vIFJlbW92ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGJlIGhlbGQgaW4gY29uZmlnIG9wdGlvbnMgb3IgY2FsbGJhY2tzXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uZmlnLnhoclNldHVwID0gY29uZmlnLmZldGNoU2V0dXAgPSB1bmRlZmluZWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudXNlckNvbmZpZyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgSGxzLmpzIHRvIGEgbWVkaWEgZWxlbWVudFxuICAgKi9cbiAgYXR0YWNoTWVkaWEobWVkaWE6IEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICBsb2dnZXIubG9nKCdhdHRhY2hNZWRpYScpO1xuICAgIHRoaXMuX21lZGlhID0gbWVkaWE7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHsgbWVkaWE6IG1lZGlhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCBIbHMuanMgZnJvbSB0aGUgbWVkaWFcbiAgICovXG4gIGRldGFjaE1lZGlhKCkge1xuICAgIGxvZ2dlci5sb2coJ2RldGFjaE1lZGlhJyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIFVSTC4gQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLlxuICAgKi9cbiAgbG9hZFNvdXJjZSh1cmw6IHN0cmluZykge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbG9hZGVkU291cmNlID0gdGhpcy51cmw7XG4gICAgY29uc3QgbG9hZGluZ1NvdXJjZSA9ICh0aGlzLnVybCA9IGJ1aWxkQWJzb2x1dGVVUkwoXG4gICAgICBzZWxmLmxvY2F0aW9uLmhyZWYsXG4gICAgICB1cmwsXG4gICAgICB7XG4gICAgICAgIGFsd2F5c05vcm1hbGl6ZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgKSk7XG4gICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgIHRoaXMuX21heEhkY3BMZXZlbCA9IG51bGw7XG4gICAgbG9nZ2VyLmxvZyhgbG9hZFNvdXJjZToke2xvYWRpbmdTb3VyY2V9YCk7XG4gICAgaWYgKFxuICAgICAgbWVkaWEgJiZcbiAgICAgIGxvYWRlZFNvdXJjZSAmJlxuICAgICAgKGxvYWRlZFNvdXJjZSAhPT0gbG9hZGluZ1NvdXJjZSB8fCB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIuaGFzU291cmNlVHlwZXMoKSlcbiAgICApIHtcbiAgICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICAgIHRoaXMuYXR0YWNoTWVkaWEobWVkaWEpO1xuICAgIH1cbiAgICAvLyB3aGVuIGF0dGFjaGluZyB0byBhIHNvdXJjZSBVUkwsIHRyaWdnZXIgYSBwbGF5bGlzdCBsb2FkXG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB7IHVybDogdXJsIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGxvYWRpbmcgZGF0YSBmcm9tIHRoZSBzdHJlYW0gc291cmNlLlxuICAgKiBEZXBlbmRpbmcgb24gZGVmYXVsdCBjb25maWcsIGNsaWVudCBzdGFydHMgbG9hZGluZyBhdXRvbWF0aWNhbGx5IHdoZW4gYSBzb3VyY2UgaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gc3RhcnRQb3NpdGlvbiAtIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gdG8gc3RyZWFtIGZyb20uXG4gICAqIERlZmF1bHRzIHRvIC0xIChOb25lOiBzdGFydHMgZnJvbSBlYXJsaWVzdCBwb2ludClcbiAgICovXG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uOiBudW1iZXIgPSAtMSkge1xuICAgIGxvZ2dlci5sb2coYHN0YXJ0TG9hZCgke3N0YXJ0UG9zaXRpb259KWApO1xuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIHN0b3BMb2FkKCkge1xuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgY29udHJvbGxlci5zdG9wTG9hZCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgc3RyZWFtIGNvbnRyb2xsZXIgc2VnbWVudCBsb2FkaW5nIGlmIHByZXZpb3VzbHkgc3RhcnRlZC5cbiAgICovXG4gIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmICgnZnJhZ21lbnRMb2FkZXInIGluIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnN0YXJ0TG9hZCgtMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBzdHJlYW0gY29udHJvbGxlciBzZWdtZW50IGxvYWRpbmcgd2l0aG91dCBjaGFuZ2luZyAnc3RhcnRlZCcgc3RhdGUgbGlrZSBzdG9wTG9hZCgpLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgbWVkaWEgYnVmZmVyaW5nIHRvIGJlIHBhdXNlZCB3aXRob3V0IGludGVydXB0aW5nIHBsYXlsaXN0IGxvYWRpbmcuXG4gICAqL1xuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgICBpZiAoJ2ZyYWdtZW50TG9hZGVyJyBpbiBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXG4gICAqXG4gICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICovXG4gIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgIGxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLl9tZWRpYTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVMZXZlbChsZXZlbEluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChsZXZlbEluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgUkVTT0xVVElPTiAoaGVpZ2h0KSwgRlJBTUUtUkFURSwgQ09ERUNTLCBWSURFTy1SQU5HRSwgYW5kIEJBTkRXSURUSFxuICAgKi9cbiAgZ2V0IGxldmVscygpOiBMZXZlbFtdIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbHM7XG4gICAgcmV0dXJuIGxldmVscyA/IGxldmVscyA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHF1YWxpdHkgbGV2ZWwgKHZhcmlhbnQpIGN1cnJlbnRseSBwbGF5ZWRcbiAgICovXG4gIGdldCBjdXJyZW50TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS4gU2V0IHRvIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZCBhcyBzY2hlZHVsZWQgYnkgc3RyZWFtIGNvbnRyb2xsZXIuXG4gICAqL1xuICBnZXQgbmV4dExldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICovXG4gIGdldCBsb2FkTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEgaW4gYSBjb25zZXJ2YXRpdmUgd2F5LlxuICAgKiBUaGlzIHdpbGwgc3dpdGNoIHRoZSBxdWFsaXR5IHdpdGhvdXQgZmx1c2hpbmcsIGJ1dCBpbnRlcnJ1cHQgY3VycmVudCBsb2FkaW5nLlxuICAgKiBUaHVzIHRoZSBtb21lbnQgd2hlbiB0aGUgcXVhbGl0eSBzd2l0Y2ggd2lsbCBhcHBlYXIgaW4gZWZmZWN0IHdpbGwgb25seSBiZSBhZnRlciB0aGUgYWxyZWFkeSBleGlzdGluZyBidWZmZXIuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBsb2FkTGV2ZWwobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGxvZ2dlci5sb2coYHNldCBsb2FkTGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBuZXh0IHF1YWxpdHkgbGV2ZWwgbG9hZGVkXG4gICAqL1xuICBnZXQgbmV4dExvYWRMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsLCB0aGlzLm1pbkF1dG9MZXZlbCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBcImZpcnN0LWxldmVsXCIsIHNlZSBnZXR0ZXIuXG4gICAqL1xuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZXNpcmVkIHN0YXJ0IGxldmVsIGZvciB0aGUgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIGxvYWRlZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24uXG4gICAqIFNldHRpbmcgaGxzLm5leHRBdXRvTGV2ZWwgd2l0aG91dCBzZXR0aW5nIGEgc3RhcnRMZXZlbCB3aWxsIHJlc3VsdCBpblxuICAgKiB0aGUgbmV4dEF1dG9MZXZlbCB2YWx1ZSBiZWluZyB1c2VkIGZvciBvbmUgZnJhZ21lbnQgbG9hZC5cbiAgICovXG4gIGdldCBzdGFydExldmVsKCk6IG51bWJlciB7XG4gICAgY29uc3Qgc3RhcnRMZXZlbCA9IHRoaXMubGV2ZWxDb250cm9sbGVyLnN0YXJ0TGV2ZWw7XG4gICAgaWYgKHN0YXJ0TGV2ZWwgPT09IC0xICYmIHRoaXMuYWJyQ29udHJvbGxlci5mb3JjZWRBdXRvTGV2ZWwgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiBzdGFydExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbDogbnVtYmVyKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IHN0YXJ0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICAvLyBpZiBub3QgaW4gYXV0b21hdGljIHN0YXJ0IGxldmVsIGRldGVjdGlvbiwgZW5zdXJlIHN0YXJ0TGV2ZWwgaXMgZ3JlYXRlciB0aGFuIG1pbkF1dG9MZXZlbFxuICAgIGlmIChuZXdMZXZlbCAhPT0gLTEpIHtcbiAgICAgIG5ld0xldmVsID0gTWF0aC5tYXgobmV3TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgc2V0IHZpYSBgY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplYC5cbiAgICovXG4gIGdldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgKi9cbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKHNob3VsZFN0YXJ0Q2FwcGluZzogYm9vbGVhbikge1xuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG5cbiAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUgIT09IHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICBpZiAobmV3Q2FwTGV2ZWxUb1BsYXllclNpemUpIHtcbiAgICAgICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RhcnRDYXBwaW5nKCk7IC8vIElmIGNhcHBpbmcgb2NjdXJzLCBuZXh0TGV2ZWxTd2l0Y2ggd2lsbCBoYXBwZW4gYmFzZWQgb24gc2l6ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0b3BDYXBwaW5nKCk7XG4gICAgICAgIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IC0xO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7IC8vIE5vdyB3ZSdyZSB1bmNhcHBlZCwgZ2V0IHRoZSBuZXh0IGxldmVsIGFzYXAuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplID0gbmV3Q2FwTGV2ZWxUb1BsYXllclNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxDYXBwaW5nKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBiYW5kd2lkdGggZXN0aW1hdGUgaW4gYml0cyBwZXIgc2Vjb25kLCB3aGVuIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBgTmFOYCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldCBiYW5kd2lkdGhFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYndFc3RpbWF0b3IgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTtcbiAgfVxuXG4gIHNldCBiYW5kd2lkdGhFc3RpbWF0ZShhYnJFd21hRGVmYXVsdEVzdGltYXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIucmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRpbWUgdG8gZmlyc3QgYnl0ZSBlc3RpbWF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHR0ZmJFc3RpbWF0ZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYndFc3RpbWF0b3IgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICBpZiAoIWJ3RXN0aW1hdG9yKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgc2V0IGF1dG9MZXZlbENhcHBpbmcobmV3TGV2ZWw6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBuZXdMZXZlbCkge1xuICAgICAgbG9nZ2VyLmxvZyhgc2V0IGF1dG9MZXZlbENhcHBpbmc6JHtuZXdMZXZlbH1gKTtcbiAgICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSBuZXdMZXZlbDtcbiAgICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbWF4SGRjcExldmVsKCk6IEhkY3BMZXZlbCB7XG4gICAgcmV0dXJuIHRoaXMuX21heEhkY3BMZXZlbDtcbiAgfVxuXG4gIHNldCBtYXhIZGNwTGV2ZWwodmFsdWU6IEhkY3BMZXZlbCkge1xuICAgIGlmIChpc0hkY3BMZXZlbCh2YWx1ZSkgJiYgdGhpcy5fbWF4SGRjcExldmVsICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gdmFsdWU7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5jaGVja01heEF1dG9VcGRhdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogbWluIGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBjb25maWcubWluQXV0b0JpdHJhdGVcbiAgICovXG4gIGdldCBtaW5BdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHMsXG4gICAgICBjb25maWc6IHsgbWluQXV0b0JpdHJhdGUgfSxcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWxldmVscykgcmV0dXJuIDA7XG5cbiAgICBjb25zdCBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0ubWF4Qml0cmF0ZSA+PSBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXggbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGF1dG9MZXZlbENhcHBpbmdcbiAgICovXG4gIGdldCBtYXhBdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICBjb25zdCB7IGxldmVscywgYXV0b0xldmVsQ2FwcGluZywgbWF4SGRjcExldmVsIH0gPSB0aGlzO1xuXG4gICAgbGV0IG1heEF1dG9MZXZlbDtcbiAgICBpZiAoYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgJiYgbGV2ZWxzPy5sZW5ndGgpIHtcbiAgICAgIG1heEF1dG9MZXZlbCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBhdXRvTGV2ZWxDYXBwaW5nO1xuICAgIH1cblxuICAgIGlmIChtYXhIZGNwTGV2ZWwpIHtcbiAgICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGktLTsgKSB7XG4gICAgICAgIGNvbnN0IGhkY3BMZXZlbCA9IGxldmVsc1tpXS5hdHRyc1snSERDUC1MRVZFTCddO1xuICAgICAgICBpZiAoaGRjcExldmVsICYmIGhkY3BMZXZlbCA8PSBtYXhIZGNwTGV2ZWwpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhBdXRvTGV2ZWw7XG4gIH1cblxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5hYnJDb250cm9sbGVyLmZpcnN0QXV0b0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG5leHQgYXV0b21hdGljYWxseSBzZWxlY3RlZCBxdWFsaXR5IGxldmVsXG4gICAqL1xuICBnZXQgbmV4dEF1dG9MZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGlzIHNldHRlciBpcyB1c2VkIHRvIGZvcmNlIG5leHQgYXV0byBsZXZlbC5cbiAgICogdGhpcyBpcyB1c2VmdWwgdG8gZm9yY2UgYSBzd2l0Y2ggZG93biBpbiBhdXRvIG1vZGU6XG4gICAqIGluIGNhc2Ugb2YgbG9hZCBlcnJvciBvbiBsZXZlbCBOLCBobHMuanMgY2FuIHNldCBuZXh0QXV0b0xldmVsIHRvIE4tMSBmb3IgZXhhbXBsZSlcbiAgICogZm9yY2VkIHZhbHVlIGlzIHZhbGlkIGZvciBvbmUgZnJhZ21lbnQuIHVwb24gc3VjY2Vzc2Z1bCBmcmFnIGxvYWRpbmcgYXQgZm9yY2VkIGxldmVsLFxuICAgKiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVzZXR0ZWQgdG8gLTEgYnkgQUJSIGNvbnRyb2xsZXIuXG4gICAqL1xuICBzZXQgbmV4dEF1dG9MZXZlbChuZXh0TGV2ZWw6IG51bWJlcikge1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0ZXRpbWUgdmFsdWUgcmVsYXRpdmUgdG8gbWVkaWEuY3VycmVudFRpbWUgZm9yIHRoZSBhY3RpdmUgbGV2ZWwgUHJvZ3JhbSBEYXRlIFRpbWUgaWYgcHJlc2VudFxuICAgKi9cbiAgcHVibGljIGdldCBwbGF5aW5nRGF0ZSgpOiBEYXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50UHJvZ3JhbURhdGVUaW1lO1xuICB9XG5cbiAgcHVibGljIGdldCBtYWluRm9yd2FyZEJ1ZmZlckluZm8oKTogQnVmZmVySW5mbyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgYXVkaW8gdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgcHVibGljIHNldEF1ZGlvT3B0aW9uKFxuICAgIGF1ZGlvT3B0aW9uOiBNZWRpYVBsYXlsaXN0IHwgQXVkaW9TZWxlY3Rpb25PcHRpb24gfCB1bmRlZmluZWQsXG4gICk6IE1lZGlhUGxheWxpc3QgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcj8uc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgc3VidGl0bGUgdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgcHVibGljIHNldFN1YnRpdGxlT3B0aW9uKFxuICAgIHN1YnRpdGxlT3B0aW9uOiBNZWRpYVBsYXlsaXN0IHwgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24gfCB1bmRlZmluZWQsXG4gICk6IE1lZGlhUGxheWxpc3QgfCBudWxsIHtcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyPy5zZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21wbGV0ZSBsaXN0IG9mIGF1ZGlvIHRyYWNrcyBhY3Jvc3MgYWxsIG1lZGlhIGdyb3Vwc1xuICAgKi9cbiAgZ2V0IGFsbEF1ZGlvVHJhY2tzKCk6IEFycmF5PE1lZGlhUGxheWxpc3Q+IHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYWxsQXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpOiBBcnJheTxNZWRpYVBsYXlsaXN0PiB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2tzIDogW107XG4gIH1cblxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCk6IG51bWJlciB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZDogbnVtYmVyKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChhdWRpb1RyYWNrQ29udHJvbGxlcikge1xuICAgICAgYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFjayA9IGF1ZGlvVHJhY2tJZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBjb21wbGV0ZSBsaXN0IG9mIHN1YnRpdGxlIHRyYWNrcyBhY3Jvc3MgYWxsIG1lZGlhIGdyb3Vwc1xuICAgKi9cbiAgZ2V0IGFsbFN1YnRpdGxlVHJhY2tzKCk6IEFycmF5PE1lZGlhUGxheWxpc3Q+IHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgICA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLmFsbFN1YnRpdGxlVHJhY2tzXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCk6IEFycmF5PE1lZGlhUGxheWxpc3Q+IHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgICA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2tzXG4gICAgICA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpXG4gICAqL1xuICBnZXQgc3VidGl0bGVUcmFjaygpOiBudW1iZXIge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrIDogLTE7XG4gIH1cblxuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQ6IG51bWJlcikge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgPSBzdWJ0aXRsZVRyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgc3VidGl0bGUgZGlzcGxheSBpcyBlbmFibGVkIG9yIG5vdFxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyXG4gICAgICA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheVxuICAgICAgOiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlRGlzcGxheSh2YWx1ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgbW9kZSBmb3IgTG93LUxhdGVuY3kgSExTIGxvYWRpbmdcbiAgICovXG4gIGdldCBsb3dMYXRlbmN5TW9kZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgTG93LUxhdGVuY3kgSExTIHBhcnQgcGxheWxpc3QgYW5kIHNlZ21lbnQgbG9hZGluZywgYW5kIHN0YXJ0IGxpdmUgc3RyZWFtcyBhdCBwbGF5bGlzdCBQQVJULUhPTEQtQkFDSyByYXRoZXIgdGhhbiBIT0xELUJBQ0suXG4gICAqL1xuICBzZXQgbG93TGF0ZW5jeU1vZGUobW9kZTogYm9vbGVhbikge1xuICAgIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlID0gbW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBzeW5jIHBvaW50IChpZSBlZGdlIG9mIGxpdmUgcG9zaXRpb24gbWludXMgc2FmZXR5IGRlbGF5IGRlZmluZWQgYnkgYGBgaGxzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uYGBgKVxuICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgKi9cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZWQgcG9zaXRpb24gKGluIHNlY29uZHMpIG9mIGxpdmUgZWRnZSAoaWUgZWRnZSBvZiBsaXZlIHBsYXlsaXN0IHBsdXMgdGltZSBzeW5jIHBsYXlsaXN0IGFkdmFuY2VkKVxuICAgKiBAcmV0dXJucyAwIGJlZm9yZSBmaXJzdCBwbGF5bGlzdCBpcyBsb2FkZWRcbiAgICovXG4gIGdldCBsYXRlbmN5KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG1heExhdGVuY3koKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5tYXhMYXRlbmN5O1xuICB9XG5cbiAgLyoqXG4gICAqIHRhcmdldCBkaXN0YW5jZSBmcm9tIHRoZSBlZGdlIGFzIGNhbGN1bGF0ZWQgYnkgdGhlIGxhdGVuY3kgY29udHJvbGxlclxuICAgKi9cbiAgZ2V0IHRhcmdldExhdGVuY3koKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIudGFyZ2V0TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgZWRnZSBvZiB0aGUgY3VycmVudCBsaXZlIHBsYXlsaXN0IGlzIGFkdmFuY2luZyBvciAxIGlmIHRoZXJlIGlzIG5vbmVcbiAgICovXG4gIGdldCBkcmlmdCgpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgdG8gdHJ1ZSB3aGVuIHN0YXJ0TG9hZCBpcyBjYWxsZWQgYmVmb3JlIE1BTklGRVNUX1BBUlNFRCBldmVudFxuICAgKi9cbiAgZ2V0IGZvcmNlU3RhcnRMb2FkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZm9yY2VTdGFydExvYWQ7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUge1xuICBBdWRpb1NlbGVjdGlvbk9wdGlvbixcbiAgU3VidGl0bGVTZWxlY3Rpb25PcHRpb24sXG4gIFZpZGVvU2VsZWN0aW9uT3B0aW9uLFxuICBNZWRpYVBsYXlsaXN0LFxuICBFcnJvckRldGFpbHMsXG4gIEVycm9yVHlwZXMsXG4gIEV2ZW50cyxcbiAgTGV2ZWwsXG4gIEhsc0xpc3RlbmVycyxcbiAgSGxzRXZlbnRFbWl0dGVyLFxuICBIbHNDb25maWcsXG4gIEJ1ZmZlckluZm8sXG4gIEhkY3BMZXZlbCxcbiAgQWJyQ29udHJvbGxlcixcbiAgQXVkaW9TdHJlYW1Db250cm9sbGVyLFxuICBBdWRpb1RyYWNrQ29udHJvbGxlcixcbiAgQmFzZVBsYXlsaXN0Q29udHJvbGxlcixcbiAgQmFzZVN0cmVhbUNvbnRyb2xsZXIsXG4gIEJ1ZmZlckNvbnRyb2xsZXIsXG4gIENhcExldmVsQ29udHJvbGxlcixcbiAgQ01DRENvbnRyb2xsZXIsXG4gIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIsXG4gIEVNRUNvbnRyb2xsZXIsXG4gIEVycm9yQ29udHJvbGxlcixcbiAgRlBTQ29udHJvbGxlcixcbiAgU3VidGl0bGVUcmFja0NvbnRyb2xsZXIsXG59O1xuZXhwb3J0IHR5cGUge1xuICBDb21wb25lbnRBUEksXG4gIEFickNvbXBvbmVudEFQSSxcbiAgTmV0d29ya0NvbXBvbmVudEFQSSxcbn0gZnJvbSAnLi90eXBlcy9jb21wb25lbnQtYXBpJztcbmV4cG9ydCB0eXBlIHtcbiAgQUJSQ29udHJvbGxlckNvbmZpZyxcbiAgQnVmZmVyQ29udHJvbGxlckNvbmZpZyxcbiAgQ2FwTGV2ZWxDb250cm9sbGVyQ29uZmlnLFxuICBDTUNEQ29udHJvbGxlckNvbmZpZyxcbiAgRU1FQ29udHJvbGxlckNvbmZpZyxcbiAgRFJNU3lzdGVtc0NvbmZpZ3VyYXRpb24sXG4gIERSTVN5c3RlbU9wdGlvbnMsXG4gIEZQU0NvbnRyb2xsZXJDb25maWcsXG4gIEZyYWdtZW50TG9hZGVyQ29uZmlnLFxuICBGcmFnbWVudExvYWRlckNvbnN0cnVjdG9yLFxuICBIbHNMb2FkUG9saWNpZXMsXG4gIExldmVsQ29udHJvbGxlckNvbmZpZyxcbiAgTG9hZGVyQ29uZmlnLFxuICBMb2FkUG9saWN5LFxuICBNUDRSZW11eGVyQ29uZmlnLFxuICBQbGF5bGlzdExvYWRlckNvbmZpZyxcbiAgUGxheWxpc3RMb2FkZXJDb25zdHJ1Y3RvcixcbiAgUmV0cnlDb25maWcsXG4gIFNlbGVjdGlvblByZWZlcmVuY2VzLFxuICBTdHJlYW1Db250cm9sbGVyQ29uZmlnLFxuICBMYXRlbmN5Q29udHJvbGxlckNvbmZpZyxcbiAgTWV0YWRhdGFDb250cm9sbGVyQ29uZmlnLFxuICBUaW1lbGluZUNvbnRyb2xsZXJDb25maWcsXG4gIFRTRGVtdXhlckNvbmZpZyxcbn0gZnJvbSAnLi9jb25maWcnO1xuZXhwb3J0IHR5cGUgeyBNZWRpYUtleVNlc3Npb25Db250ZXh0IH0gZnJvbSAnLi9jb250cm9sbGVyL2VtZS1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgSUxvZ2dlciB9IGZyb20gJy4vdXRpbHMvbG9nZ2VyJztcbmV4cG9ydCB0eXBlIHtcbiAgUGF0aHdheUNsb25lLFxuICBTdGVlcmluZ01hbmlmZXN0LFxuICBVcmlSZXBsYWNlbWVudCxcbn0gZnJvbSAnLi9jb250cm9sbGVyL2NvbnRlbnQtc3RlZXJpbmctY29udHJvbGxlcic7XG5leHBvcnQgdHlwZSB7IFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci9zdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlcic7XG5leHBvcnQgdHlwZSB7IFRpbWVsaW5lQ29udHJvbGxlciB9IGZyb20gJy4vY29udHJvbGxlci90aW1lbGluZS1jb250cm9sbGVyJztcbmV4cG9ydCB0eXBlIHsgQ3Vlc0ludGVyZmFjZSB9IGZyb20gJy4vdXRpbHMvY3Vlcyc7XG5leHBvcnQgdHlwZSB7XG4gIE1lZGlhS2V5RnVuYyxcbiAgS2V5U3lzdGVtcyxcbiAgS2V5U3lzdGVtRm9ybWF0cyxcbn0gZnJvbSAnLi91dGlscy9tZWRpYWtleXMtaGVscGVyJztcbmV4cG9ydCB0eXBlIHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9sb2FkZXIvZGF0ZS1yYW5nZSc7XG5leHBvcnQgdHlwZSB7IExvYWRTdGF0cyB9IGZyb20gJy4vbG9hZGVyL2xvYWQtc3RhdHMnO1xuZXhwb3J0IHR5cGUgeyBMZXZlbEtleSB9IGZyb20gJy4vbG9hZGVyL2xldmVsLWtleSc7XG5leHBvcnQgdHlwZSB7IExldmVsRGV0YWlscyB9IGZyb20gJy4vbG9hZGVyL2xldmVsLWRldGFpbHMnO1xuZXhwb3J0IHR5cGUgeyBTb3VyY2VCdWZmZXJOYW1lIH0gZnJvbSAnLi90eXBlcy9idWZmZXInO1xuZXhwb3J0IHR5cGUge1xuICBNZXRhZGF0YVNhbXBsZSxcbiAgTWV0YWRhdGFTY2hlbWEsXG4gIFVzZXJkYXRhU2FtcGxlLFxufSBmcm9tICcuL3R5cGVzL2RlbXV4ZXInO1xuZXhwb3J0IHR5cGUge1xuICBIbHNTa2lwLFxuICBIbHNVcmxQYXJhbWV0ZXJzLFxuICBMZXZlbEF0dHJpYnV0ZXMsXG4gIExldmVsUGFyc2VkLFxuICBWYXJpYWJsZU1hcCxcbn0gZnJvbSAnLi90eXBlcy9sZXZlbCc7XG5leHBvcnQgdHlwZSB7IE1lZGlhRGVjb2RpbmdJbmZvIH0gZnJvbSAnLi91dGlscy9tZWRpYWNhcGFiaWxpdGllcy1oZWxwZXInO1xuZXhwb3J0IHR5cGUge1xuICBQbGF5bGlzdExldmVsVHlwZSxcbiAgSGxzQ2h1bmtQZXJmb3JtYW5jZVRpbWluZyxcbiAgSGxzUGVyZm9ybWFuY2VUaW1pbmcsXG4gIEhsc1Byb2dyZXNzaXZlUGVyZm9ybWFuY2VUaW1pbmcsXG4gIFBsYXlsaXN0Q29udGV4dFR5cGUsXG4gIFBsYXlsaXN0TG9hZGVyQ29udGV4dCxcbiAgRnJhZ21lbnRMb2FkZXJDb250ZXh0LFxuICBMb2FkZXIsXG4gIExvYWRlclN0YXRzLFxuICBMb2FkZXJDb250ZXh0LFxuICBMb2FkZXJSZXNwb25zZSxcbiAgTG9hZGVyQ29uZmlndXJhdGlvbixcbiAgTG9hZGVyQ2FsbGJhY2tzLFxuICBMb2FkZXJPblByb2dyZXNzLFxuICBMb2FkZXJPbkFib3J0LFxuICBMb2FkZXJPbkVycm9yLFxuICBMb2FkZXJPblN1Y2Nlc3MsXG4gIExvYWRlck9uVGltZW91dCxcbn0gZnJvbSAnLi90eXBlcy9sb2FkZXInO1xuZXhwb3J0IHR5cGUge1xuICBNZWRpYUF0dHJpYnV0ZXMsXG4gIE1lZGlhUGxheWxpc3RUeXBlLFxuICBNYWluUGxheWxpc3RUeXBlLFxuICBBdWRpb1BsYXlsaXN0VHlwZSxcbiAgU3VidGl0bGVQbGF5bGlzdFR5cGUsXG59IGZyb20gJy4vdHlwZXMvbWVkaWEtcGxheWxpc3QnO1xuZXhwb3J0IHR5cGUgeyBUcmFjaywgVHJhY2tTZXQgfSBmcm9tICcuL3R5cGVzL3RyYWNrJztcbmV4cG9ydCB0eXBlIHsgQ2h1bmtNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMvdHJhbnNtdXhlcic7XG5leHBvcnQgdHlwZSB7XG4gIEJhc2VTZWdtZW50LFxuICBGcmFnbWVudCxcbiAgUGFydCxcbiAgRWxlbWVudGFyeVN0cmVhbXMsXG4gIEVsZW1lbnRhcnlTdHJlYW1UeXBlcyxcbiAgRWxlbWVudGFyeVN0cmVhbUluZm8sXG59IGZyb20gJy4vbG9hZGVyL2ZyYWdtZW50JztcbmV4cG9ydCB0eXBlIHtcbiAgVHJhY2tMb2FkaW5nRGF0YSxcbiAgVHJhY2tMb2FkZWREYXRhLFxuICBBdWRpb1RyYWNrTG9hZGVkRGF0YSxcbiAgQXVkaW9UcmFja3NVcGRhdGVkRGF0YSxcbiAgQXVkaW9UcmFja1N3aXRjaGVkRGF0YSxcbiAgQXVkaW9UcmFja1N3aXRjaGluZ0RhdGEsXG4gIEJhY2tCdWZmZXJEYXRhLFxuICBCdWZmZXJBcHBlbmRlZERhdGEsXG4gIEJ1ZmZlckFwcGVuZGluZ0RhdGEsXG4gIEJ1ZmZlckNvZGVjc0RhdGEsXG4gIEJ1ZmZlckNyZWF0ZWREYXRhLFxuICBCdWZmZXJFT1NEYXRhLFxuICBCdWZmZXJGbHVzaGVkRGF0YSxcbiAgQnVmZmVyRmx1c2hpbmdEYXRhLFxuICBDdWVzUGFyc2VkRGF0YSxcbiAgRXJyb3JEYXRhLFxuICBGUFNEcm9wRGF0YSxcbiAgRlBTRHJvcExldmVsQ2FwcGluZ0RhdGEsXG4gIEZyYWdCdWZmZXJlZERhdGEsXG4gIEZyYWdDaGFuZ2VkRGF0YSxcbiAgRnJhZ0RlY3J5cHRlZERhdGEsXG4gIEZyYWdMb2FkZWREYXRhLFxuICBGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWREYXRhLFxuICBGcmFnTG9hZGluZ0RhdGEsXG4gIEZyYWdQYXJzZWREYXRhLFxuICBGcmFnUGFyc2luZ0luaXRTZWdtZW50RGF0YSxcbiAgRnJhZ1BhcnNpbmdNZXRhZGF0YURhdGEsXG4gIEZyYWdQYXJzaW5nVXNlcmRhdGFEYXRhLFxuICBJbml0UFRTRm91bmREYXRhLFxuICBLZXlMb2FkZWREYXRhLFxuICBLZXlMb2FkaW5nRGF0YSxcbiAgTGV2ZWxMb2FkZWREYXRhLFxuICBMZXZlbExvYWRpbmdEYXRhLFxuICBMZXZlbFBUU1VwZGF0ZWREYXRhLFxuICBMZXZlbHNVcGRhdGVkRGF0YSxcbiAgTGV2ZWxTd2l0Y2hlZERhdGEsXG4gIExldmVsU3dpdGNoaW5nRGF0YSxcbiAgTGV2ZWxVcGRhdGVkRGF0YSxcbiAgTGl2ZUJhY2tCdWZmZXJEYXRhLFxuICBDb250ZW50U3RlZXJpbmdPcHRpb25zLFxuICBNYW5pZmVzdExvYWRlZERhdGEsXG4gIE1hbmlmZXN0TG9hZGluZ0RhdGEsXG4gIE1hbmlmZXN0UGFyc2VkRGF0YSxcbiAgTWVkaWFBdHRhY2hlZERhdGEsXG4gIE1lZGlhQXR0YWNoaW5nRGF0YSxcbiAgTm9uTmF0aXZlVGV4dFRyYWNrLFxuICBOb25OYXRpdmVUZXh0VHJhY2tzRGF0YSxcbiAgU3RlZXJpbmdNYW5pZmVzdExvYWRlZERhdGEsXG4gIFN1YnRpdGxlRnJhZ1Byb2Nlc3NlZERhdGEsXG4gIFN1YnRpdGxlVHJhY2tMb2FkZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrc1VwZGF0ZWREYXRhLFxuICBTdWJ0aXRsZVRyYWNrU3dpdGNoRGF0YSxcbn0gZnJvbSAnLi90eXBlcy9ldmVudHMnO1xuZXhwb3J0IHR5cGUge1xuICBOZXR3b3JrRXJyb3JBY3Rpb24sXG4gIEVycm9yQWN0aW9uRmxhZ3MsXG4gIElFcnJvckFjdGlvbixcbn0gZnJvbSAnLi9jb250cm9sbGVyL2Vycm9yLWNvbnRyb2xsZXInO1xuZXhwb3J0IHR5cGUgeyBBdHRyTGlzdCB9IGZyb20gJy4vdXRpbHMvYXR0ci1saXN0JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hls.js/dist/hls.light.mjs\n");

/***/ })

};
