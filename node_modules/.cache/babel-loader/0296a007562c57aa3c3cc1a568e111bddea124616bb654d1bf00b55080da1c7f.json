{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { render, nothing } from '../lit-html.js';\nimport { directive, Directive } from '../directive.js';\nimport { clearPart, getCommittedValue, insertPart, isCompiledTemplateResult, isTemplateResult, setCommittedValue } from '../directive-helpers.js';\n/**\n * The template strings array contents are not compatible between the two\n * template result types as the compiled template contains a prepared string;\n * only use the returned template strings array as a cache key.\n */\nconst getStringsFromTemplateResult = result => isCompiledTemplateResult(result) ? result['_$litType$'].h : result.strings;\nclass CacheDirective extends Directive {\n  constructor(partInfo) {\n    super(partInfo);\n    this._templateCache = new WeakMap();\n  }\n  render(v) {\n    // Return an array of the value to induce lit-html to create a ChildPart\n    // for the value that we can move into the cache.\n    return [v];\n  }\n  update(containerPart, [v]) {\n    const _valueKey = isTemplateResult(this._value) ? getStringsFromTemplateResult(this._value) : null;\n    const vKey = isTemplateResult(v) ? getStringsFromTemplateResult(v) : null;\n    // If the previous value is a TemplateResult and the new value is not,\n    // or is a different Template as the previous value, move the child part\n    // into the cache.\n    if (_valueKey !== null && (vKey === null || _valueKey !== vKey)) {\n      // This is always an array because we return [v] in render()\n      const partValue = getCommittedValue(containerPart);\n      const childPart = partValue.pop();\n      let cachedContainerPart = this._templateCache.get(_valueKey);\n      if (cachedContainerPart === undefined) {\n        const fragment = document.createDocumentFragment();\n        cachedContainerPart = render(nothing, fragment);\n        cachedContainerPart.setConnected(false);\n        this._templateCache.set(_valueKey, cachedContainerPart);\n      }\n      // Move into cache\n      setCommittedValue(cachedContainerPart, [childPart]);\n      insertPart(cachedContainerPart, undefined, childPart);\n    }\n    // If the new value is a TemplateResult and the previous value is not,\n    // or is a different Template as the previous value, restore the child\n    // part from the cache.\n    if (vKey !== null) {\n      if (_valueKey === null || _valueKey !== vKey) {\n        const cachedContainerPart = this._templateCache.get(vKey);\n        if (cachedContainerPart !== undefined) {\n          // Move the cached part back into the container part value\n          const partValue = getCommittedValue(cachedContainerPart);\n          const cachedPart = partValue.pop();\n          // Move cached part back into DOM\n          clearPart(containerPart);\n          insertPart(containerPart, undefined, cachedPart);\n          setCommittedValue(containerPart, [cachedPart]);\n        }\n      }\n      // Because vKey is non null, v must be a TemplateResult.\n      this._value = v;\n    } else {\n      this._value = undefined;\n    }\n    return this.render(v);\n  }\n}\n/**\n * Enables fast switching between multiple templates by caching the DOM nodes\n * and TemplateInstances produced by the templates.\n *\n * Example:\n *\n * ```js\n * let checked = false;\n *\n * html`\n *   ${cache(checked ? html`input is checked` : html`input is not checked`)}\n * `\n * ```\n */\nexport const cache = directive(CacheDirective);","map":{"version":3,"names":["render","nothing","directive","Directive","clearPart","getCommittedValue","insertPart","isCompiledTemplateResult","isTemplateResult","setCommittedValue","getStringsFromTemplateResult","result","h","strings","CacheDirective","constructor","partInfo","_templateCache","WeakMap","v","update","containerPart","_valueKey","_value","vKey","partValue","childPart","pop","cachedContainerPart","get","undefined","fragment","document","createDocumentFragment","setConnected","set","cachedPart","cache"],"sources":["../../src/directives/cache.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  TemplateResult,\n  ChildPart,\n  RootPart,\n  render,\n  nothing,\n  CompiledTemplateResult,\n} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n} from '../directive.js';\nimport {\n  clearPart,\n  getCommittedValue,\n  insertPart,\n  isCompiledTemplateResult,\n  isTemplateResult,\n  setCommittedValue,\n} from '../directive-helpers.js';\n\n/**\n * The template strings array contents are not compatible between the two\n * template result types as the compiled template contains a prepared string;\n * only use the returned template strings array as a cache key.\n */\nconst getStringsFromTemplateResult = (\n  result: TemplateResult | CompiledTemplateResult\n): TemplateStringsArray =>\n  isCompiledTemplateResult(result) ? result['_$litType$'].h : result.strings;\n\nclass CacheDirective extends Directive {\n  private _templateCache = new WeakMap<TemplateStringsArray, RootPart>();\n  private _value?: TemplateResult | CompiledTemplateResult;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n  }\n\n  render(v: unknown) {\n    // Return an array of the value to induce lit-html to create a ChildPart\n    // for the value that we can move into the cache.\n    return [v];\n  }\n\n  override update(containerPart: ChildPart, [v]: DirectiveParameters<this>) {\n    const _valueKey = isTemplateResult(this._value)\n      ? getStringsFromTemplateResult(this._value)\n      : null;\n    const vKey = isTemplateResult(v) ? getStringsFromTemplateResult(v) : null;\n\n    // If the previous value is a TemplateResult and the new value is not,\n    // or is a different Template as the previous value, move the child part\n    // into the cache.\n    if (_valueKey !== null && (vKey === null || _valueKey !== vKey)) {\n      // This is always an array because we return [v] in render()\n      const partValue = getCommittedValue(containerPart) as Array<ChildPart>;\n      const childPart = partValue.pop()!;\n      let cachedContainerPart = this._templateCache.get(_valueKey);\n      if (cachedContainerPart === undefined) {\n        const fragment = document.createDocumentFragment();\n        cachedContainerPart = render(nothing, fragment);\n        cachedContainerPart.setConnected(false);\n        this._templateCache.set(_valueKey, cachedContainerPart);\n      }\n      // Move into cache\n      setCommittedValue(cachedContainerPart, [childPart]);\n      insertPart(cachedContainerPart, undefined, childPart);\n    }\n    // If the new value is a TemplateResult and the previous value is not,\n    // or is a different Template as the previous value, restore the child\n    // part from the cache.\n    if (vKey !== null) {\n      if (_valueKey === null || _valueKey !== vKey) {\n        const cachedContainerPart = this._templateCache.get(vKey);\n        if (cachedContainerPart !== undefined) {\n          // Move the cached part back into the container part value\n          const partValue = getCommittedValue(\n            cachedContainerPart\n          ) as Array<ChildPart>;\n          const cachedPart = partValue.pop()!;\n          // Move cached part back into DOM\n          clearPart(containerPart);\n          insertPart(containerPart, undefined, cachedPart);\n          setCommittedValue(containerPart, [cachedPart]);\n        }\n      }\n      // Because vKey is non null, v must be a TemplateResult.\n      this._value = v as TemplateResult | CompiledTemplateResult;\n    } else {\n      this._value = undefined;\n    }\n    return this.render(v);\n  }\n}\n\n/**\n * Enables fast switching between multiple templates by caching the DOM nodes\n * and TemplateInstances produced by the templates.\n *\n * Example:\n *\n * ```js\n * let checked = false;\n *\n * html`\n *   ${cache(checked ? html`input is checked` : html`input is not checked`)}\n * `\n * ```\n */\nexport const cache = directive(CacheDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {CacheDirective};\n"],"mappings":"AAAA;;;;;AAMA,SAIEA,MAAM,EACNC,OAAO,QAEF,gBAAgB;AACvB,SACEC,SAAS,EACTC,SAAS,QAGJ,iBAAiB;AACxB,SACEC,SAAS,EACTC,iBAAiB,EACjBC,UAAU,EACVC,wBAAwB,EACxBC,gBAAgB,EAChBC,iBAAiB,QACZ,yBAAyB;AAEhC;;;;;AAKA,MAAMC,4BAA4B,GAChCC,MAA+C,IAE/CJ,wBAAwB,CAACI,MAAM,CAAC,GAAGA,MAAM,CAAC,YAAY,CAAC,CAACC,CAAC,GAAGD,MAAM,CAACE,OAAO;AAE5E,MAAMC,cAAe,SAAQX,SAAS;EAIpCY,YAAYC,QAAkB;IAC5B,KAAK,CAACA,QAAQ,CAAC;IAJT,KAAAC,cAAc,GAAG,IAAIC,OAAO,EAAkC;EAKtE;EAEAlB,MAAMA,CAACmB,CAAU;IACf;IACA;IACA,OAAO,CAACA,CAAC,CAAC;EACZ;EAESC,MAAMA,CAACC,aAAwB,EAAE,CAACF,CAAC,CAA4B;IACtE,MAAMG,SAAS,GAAGd,gBAAgB,CAAC,IAAI,CAACe,MAAM,CAAC,GAC3Cb,4BAA4B,CAAC,IAAI,CAACa,MAAM,CAAC,GACzC,IAAI;IACR,MAAMC,IAAI,GAAGhB,gBAAgB,CAACW,CAAC,CAAC,GAAGT,4BAA4B,CAACS,CAAC,CAAC,GAAG,IAAI;IAEzE;IACA;IACA;IACA,IAAIG,SAAS,KAAK,IAAI,KAAKE,IAAI,KAAK,IAAI,IAAIF,SAAS,KAAKE,IAAI,CAAC,EAAE;MAC/D;MACA,MAAMC,SAAS,GAAGpB,iBAAiB,CAACgB,aAAa,CAAqB;MACtE,MAAMK,SAAS,GAAGD,SAAS,CAACE,GAAG,EAAG;MAClC,IAAIC,mBAAmB,GAAG,IAAI,CAACX,cAAc,CAACY,GAAG,CAACP,SAAS,CAAC;MAC5D,IAAIM,mBAAmB,KAAKE,SAAS,EAAE;QACrC,MAAMC,QAAQ,GAAGC,QAAQ,CAACC,sBAAsB,EAAE;QAClDL,mBAAmB,GAAG5B,MAAM,CAACC,OAAO,EAAE8B,QAAQ,CAAC;QAC/CH,mBAAmB,CAACM,YAAY,CAAC,KAAK,CAAC;QACvC,IAAI,CAACjB,cAAc,CAACkB,GAAG,CAACb,SAAS,EAAEM,mBAAmB,CAAC;;MAEzD;MACAnB,iBAAiB,CAACmB,mBAAmB,EAAE,CAACF,SAAS,CAAC,CAAC;MACnDpB,UAAU,CAACsB,mBAAmB,EAAEE,SAAS,EAAEJ,SAAS,CAAC;;IAEvD;IACA;IACA;IACA,IAAIF,IAAI,KAAK,IAAI,EAAE;MACjB,IAAIF,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKE,IAAI,EAAE;QAC5C,MAAMI,mBAAmB,GAAG,IAAI,CAACX,cAAc,CAACY,GAAG,CAACL,IAAI,CAAC;QACzD,IAAII,mBAAmB,KAAKE,SAAS,EAAE;UACrC;UACA,MAAML,SAAS,GAAGpB,iBAAiB,CACjCuB,mBAAmB,CACA;UACrB,MAAMQ,UAAU,GAAGX,SAAS,CAACE,GAAG,EAAG;UACnC;UACAvB,SAAS,CAACiB,aAAa,CAAC;UACxBf,UAAU,CAACe,aAAa,EAAES,SAAS,EAAEM,UAAU,CAAC;UAChD3B,iBAAiB,CAACY,aAAa,EAAE,CAACe,UAAU,CAAC,CAAC;;;MAGlD;MACA,IAAI,CAACb,MAAM,GAAGJ,CAA4C;KAC3D,MAAM;MACL,IAAI,CAACI,MAAM,GAAGO,SAAS;;IAEzB,OAAO,IAAI,CAAC9B,MAAM,CAACmB,CAAC,CAAC;EACvB;;AAGF;;;;;;;;;;;;;;AAcA,OAAO,MAAMkB,KAAK,GAAGnC,SAAS,CAACY,cAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}