{"ast":null,"code":"import \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { shallowEqual } from \"../util/shallow-equal\";\n\n/**\n * Transform function type.\n */\n\n/**\n * Specifies an tranformer callback that is run when the value of the decorated property, or any of the properties in the watching array, changes.\n * The result of the tranformer is assigned to the decorated property.\n * The tranformer receives the current as arguments.\n */\nexport var transform = function transform(config) {\n  return function (clsElement) {\n    var key = String(clsElement.key);\n    return Object.assign(Object.assign({}, clsElement), {}, {\n      kind: \"method\",\n      descriptor: {\n        set: function set(value) {\n          var oldValue = this[\"__transform_\".concat(key)];\n          var trnsformr = this._transformers.get(key);\n          if (trnsformr) {\n            this[\"__transform_\".concat(key)] = trnsformr.call(this, value);\n          } else {\n            this[\"__transform_\".concat(key)] = value;\n          }\n          this[\"__original_\".concat(key)] = value;\n          this.requestUpdate(key, oldValue);\n        },\n        get: function get() {\n          return this[\"__transform_\".concat(key)];\n        },\n        enumerable: true,\n        configurable: true\n      },\n      finisher: function finisher(cls) {\n        // if we haven't wrapped `willUpdate` in this class, do so\n        if (!cls.prototype._transformers) {\n          cls.prototype._transformers = new Map();\n          cls.prototype._watching = new Map();\n          // @ts-ignore\n          var userWillUpdate = cls.prototype.willUpdate;\n          // @ts-ignore\n          cls.prototype.willUpdate = function (changedProperties) {\n            var _this = this;\n            userWillUpdate.call(this, changedProperties);\n            var keys = new Set();\n            changedProperties.forEach(function (_v, k) {\n              var watchers = _this._watching;\n              var ks = watchers.get(k);\n              if (ks !== undefined) {\n                ks.forEach(function (wk) {\n                  return keys.add(wk);\n                });\n              }\n            });\n            keys.forEach(function (k) {\n              // trigger setter\n              _this[k] = _this[\"__original_\".concat(String(k))];\n            });\n          };\n          // clone any existing observers (superclasses)\n          // eslint-disable-next-line no-prototype-builtins\n        } else if (!cls.prototype.hasOwnProperty(\"_transformers\")) {\n          var tranformers = cls.prototype._transformers;\n          cls.prototype._transformers = new Map();\n          tranformers.forEach(function (v, k) {\n            return cls.prototype._transformers.set(k, v);\n          });\n        }\n        // set this method\n        cls.prototype._transformers.set(clsElement.key, config.transformer);\n        if (config.watch) {\n          // store watchers\n          config.watch.forEach(function (k) {\n            var curWatch = cls.prototype._watching.get(k);\n            if (!curWatch) {\n              curWatch = new Set();\n              cls.prototype._watching.set(k, curWatch);\n            }\n            curWatch.add(clsElement.key);\n          });\n        }\n        cls.createProperty(clsElement.key, Object.assign({\n          noAccessor: true,\n          hasChanged: function hasChanged(v, o) {\n            return !shallowEqual(v, o);\n          }\n        }, config.propertyOptions));\n      }\n    });\n  };\n};","map":{"version":3,"names":["shallowEqual","transform","config","clsElement","key","String","Object","assign","kind","descriptor","set","value","oldValue","concat","trnsformr","_transformers","get","call","requestUpdate","enumerable","configurable","finisher","cls","prototype","Map","_watching","userWillUpdate","willUpdate","changedProperties","_this","keys","Set","forEach","_v","k","watchers","ks","undefined","wk","add","hasOwnProperty","tranformers","v","transformer","watch","curWatch","createProperty","noAccessor","hasChanged","o","propertyOptions"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/decorators/transform.ts"],"sourcesContent":["import { PropertyDeclaration, PropertyValues, ReactiveElement } from \"lit\";\nimport { ClassElement } from \"../../types\";\nimport { shallowEqual } from \"../util/shallow-equal\";\n\n/**\n * Transform function type.\n */\nexport interface Transformer<T = any, V = any> {\n  (value: V): T;\n}\n\ntype ReactiveTransformElement = ReactiveElement & {\n  _transformers: Map<PropertyKey, Transformer>;\n  _watching: Map<PropertyKey, Set<PropertyKey>>;\n};\n\ntype ReactiveElementClassWithTransformers = typeof ReactiveElement & {\n  prototype: ReactiveTransformElement;\n};\n\n/**\n * Specifies an tranformer callback that is run when the value of the decorated property, or any of the properties in the watching array, changes.\n * The result of the tranformer is assigned to the decorated property.\n * The tranformer receives the current as arguments.\n */\nexport const transform =\n  <T, V>(config: {\n    transformer: Transformer<T, V>;\n    watch?: PropertyKey[];\n    propertyOptions?: PropertyDeclaration;\n  }): any =>\n  (clsElement: ClassElement) => {\n    const key = String(clsElement.key);\n    return {\n      ...clsElement,\n      kind: \"method\",\n      descriptor: {\n        set(this: ReactiveTransformElement, value: V) {\n          const oldValue = this[`__transform_${key}`];\n          const trnsformr: Transformer<T, V> | undefined =\n            this._transformers.get(key);\n          if (trnsformr) {\n            this[`__transform_${key}`] = trnsformr.call(this, value);\n          } else {\n            this[`__transform_${key}`] = value;\n          }\n          this[`__original_${key}`] = value;\n          this.requestUpdate(key, oldValue);\n        },\n        get(): T {\n          return this[`__transform_${key}`];\n        },\n        enumerable: true,\n        configurable: true,\n      },\n      finisher(cls: ReactiveElementClassWithTransformers) {\n        // if we haven't wrapped `willUpdate` in this class, do so\n        if (!cls.prototype._transformers) {\n          cls.prototype._transformers = new Map<PropertyKey, Transformer>();\n          cls.prototype._watching = new Map<PropertyKey, Set<PropertyKey>>();\n          // @ts-ignore\n          const userWillUpdate = cls.prototype.willUpdate;\n          // @ts-ignore\n          cls.prototype.willUpdate = function (\n            this: ReactiveTransformElement,\n            changedProperties: PropertyValues\n          ) {\n            userWillUpdate.call(this, changedProperties);\n            const keys = new Set<PropertyKey>();\n            changedProperties.forEach((_v, k) => {\n              const watchers = this._watching;\n              const ks: Set<PropertyKey> | undefined = watchers.get(k);\n              if (ks !== undefined) {\n                ks.forEach((wk) => keys.add(wk));\n              }\n            });\n            keys.forEach((k) => {\n              // trigger setter\n              this[k] = this[`__original_${String(k)}`];\n            });\n          };\n          // clone any existing observers (superclasses)\n          // eslint-disable-next-line no-prototype-builtins\n        } else if (!cls.prototype.hasOwnProperty(\"_transformers\")) {\n          const tranformers = cls.prototype._transformers;\n          cls.prototype._transformers = new Map();\n          tranformers.forEach((v: any, k: PropertyKey) =>\n            cls.prototype._transformers.set(k, v)\n          );\n        }\n        // set this method\n        cls.prototype._transformers.set(clsElement.key, config.transformer);\n        if (config.watch) {\n          // store watchers\n          config.watch.forEach((k) => {\n            let curWatch = cls.prototype._watching.get(k);\n            if (!curWatch) {\n              curWatch = new Set();\n              cls.prototype._watching.set(k, curWatch);\n            }\n            curWatch.add(clsElement.key);\n          });\n        }\n        cls.createProperty(clsElement.key, {\n          noAccessor: true,\n          hasChanged: (v: any, o: any) => !shallowEqual(v, o),\n          ...config.propertyOptions,\n        });\n      },\n    };\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}