{"ast":null,"code":"import { DOMAIN_ATTRIBUTES_FORMATERS, DOMAIN_ATTRIBUTES_UNITS, TEMPERATURE_ATTRIBUTES } from \"../../data/entity_attributes\";\nimport { getWeatherUnit } from \"../../data/weather\";\nimport checkValidDate from \"../datetime/check_valid_date\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTimeWithSeconds } from \"../datetime/format_date_time\";\nimport { formatNumber } from \"../number/format_number\";\nimport { capitalizeFirstLetter } from \"../string/capitalize-first-letter\";\nimport { isDate } from \"../string/is_date\";\nimport { isTimestamp } from \"../string/is_timestamp\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { computeDomain } from \"./compute_domain\";\nimport { computeStateDomain } from \"./compute_state_domain\";\nexport const computeAttributeValueDisplay = (localize, stateObj, locale, config, entities, attribute, value) => {\n  const attributeValue = value !== undefined ? value : stateObj.attributes[attribute];\n\n  // Null value, the state is unknown\n  if (attributeValue === null) {\n    return localize(\"state.default.unknown\");\n  }\n\n  // Number value, return formatted number\n  if (typeof attributeValue === \"number\") {\n    var _DOMAIN_ATTRIBUTES_FO, _DOMAIN_ATTRIBUTES_UN;\n    const domain = computeStateDomain(stateObj);\n    const formatter = (_DOMAIN_ATTRIBUTES_FO = DOMAIN_ATTRIBUTES_FORMATERS[domain]) === null || _DOMAIN_ATTRIBUTES_FO === void 0 ? void 0 : _DOMAIN_ATTRIBUTES_FO[attribute];\n    const formattedValue = formatter ? formatter(attributeValue, locale) : formatNumber(attributeValue, locale);\n    let unit = (_DOMAIN_ATTRIBUTES_UN = DOMAIN_ATTRIBUTES_UNITS[domain]) === null || _DOMAIN_ATTRIBUTES_UN === void 0 ? void 0 : _DOMAIN_ATTRIBUTES_UN[attribute];\n    if (domain === \"weather\") {\n      unit = getWeatherUnit(config, stateObj, attribute);\n    }\n    if (TEMPERATURE_ATTRIBUTES.has(attribute)) {\n      unit = config.unit_system.temperature;\n    }\n    if (unit) {\n      return `${formattedValue}${blankBeforeUnit(unit, locale)}${unit}`;\n    }\n    return formattedValue;\n  }\n\n  // Special handling in case this is a string with an known format\n  if (typeof attributeValue === \"string\") {\n    // Date handling\n    if (isDate(attributeValue, true)) {\n      // Timestamp handling\n      if (isTimestamp(attributeValue)) {\n        const date = new Date(attributeValue);\n        if (checkValidDate(date)) {\n          return formatDateTimeWithSeconds(date, locale, config);\n        }\n      }\n\n      // Value was not a timestamp, so only do date formatting\n      const date = new Date(attributeValue);\n      if (checkValidDate(date)) {\n        return formatDate(date, locale, config);\n      }\n    }\n  }\n\n  // Values are objects, render object\n  if (Array.isArray(attributeValue) && attributeValue.some(val => val instanceof Object) || !Array.isArray(attributeValue) && attributeValue instanceof Object) {\n    return JSON.stringify(attributeValue);\n  }\n  // If this is an array, try to determine the display value for each item\n  if (Array.isArray(attributeValue)) {\n    return attributeValue.map(item => computeAttributeValueDisplay(localize, stateObj, locale, config, entities, attribute, item)).join(\", \");\n  }\n\n  // We've explored all known value handling, so now we'll try to find a\n  // translation for the value.\n  const entityId = stateObj.entity_id;\n  const domain = computeDomain(entityId);\n  const deviceClass = stateObj.attributes.device_class;\n  const registryEntry = entities[entityId];\n  const translationKey = registryEntry === null || registryEntry === void 0 ? void 0 : registryEntry.translation_key;\n  return translationKey && localize(`component.${registryEntry.platform}.entity.${domain}.${translationKey}.state_attributes.${attribute}.state.${attributeValue}`) || deviceClass && localize(`component.${domain}.entity_component.${deviceClass}.state_attributes.${attribute}.state.${attributeValue}`) || localize(`component.${domain}.entity_component._.state_attributes.${attribute}.state.${attributeValue}`) || attributeValue;\n};\nexport const computeAttributeNameDisplay = (localize, stateObj, entities, attribute) => {\n  const entityId = stateObj.entity_id;\n  const deviceClass = stateObj.attributes.device_class;\n  const domain = computeDomain(entityId);\n  const entity = entities[entityId];\n  const translationKey = entity === null || entity === void 0 ? void 0 : entity.translation_key;\n  return translationKey && localize(`component.${entity.platform}.entity.${domain}.${translationKey}.state_attributes.${attribute}.name`) || deviceClass && localize(`component.${domain}.entity_component.${deviceClass}.state_attributes.${attribute}.name`) || localize(`component.${domain}.entity_component._.state_attributes.${attribute}.name`) || capitalizeFirstLetter(attribute.replace(/_/g, \" \").replace(/\\bid\\b/g, \"ID\").replace(/\\bip\\b/g, \"IP\").replace(/\\bmac\\b/g, \"MAC\").replace(/\\bgps\\b/g, \"GPS\"));\n};","map":{"version":3,"names":["DOMAIN_ATTRIBUTES_FORMATERS","DOMAIN_ATTRIBUTES_UNITS","TEMPERATURE_ATTRIBUTES","getWeatherUnit","checkValidDate","formatDate","formatDateTimeWithSeconds","formatNumber","capitalizeFirstLetter","isDate","isTimestamp","blankBeforeUnit","computeDomain","computeStateDomain","computeAttributeValueDisplay","localize","stateObj","locale","config","entities","attribute","value","attributeValue","undefined","attributes","_DOMAIN_ATTRIBUTES_FO","_DOMAIN_ATTRIBUTES_UN","domain","formatter","formattedValue","unit","has","unit_system","temperature","date","Date","Array","isArray","some","val","Object","JSON","stringify","map","item","join","entityId","entity_id","deviceClass","device_class","registryEntry","translationKey","translation_key","platform","computeAttributeNameDisplay","entity","replace"],"sources":["/workspaces/frontend/src/common/entity/compute_attribute_display.ts"],"sourcesContent":["import { HassConfig, HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  DOMAIN_ATTRIBUTES_FORMATERS,\n  DOMAIN_ATTRIBUTES_UNITS,\n  TEMPERATURE_ATTRIBUTES,\n} from \"../../data/entity_attributes\";\nimport { EntityRegistryDisplayEntry } from \"../../data/entity_registry\";\nimport { FrontendLocaleData } from \"../../data/translation\";\nimport { WeatherEntity, getWeatherUnit } from \"../../data/weather\";\nimport { HomeAssistant } from \"../../types\";\nimport checkValidDate from \"../datetime/check_valid_date\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTimeWithSeconds } from \"../datetime/format_date_time\";\nimport { formatNumber } from \"../number/format_number\";\nimport { capitalizeFirstLetter } from \"../string/capitalize-first-letter\";\nimport { isDate } from \"../string/is_date\";\nimport { isTimestamp } from \"../string/is_timestamp\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { LocalizeFunc } from \"../translations/localize\";\nimport { computeDomain } from \"./compute_domain\";\nimport { computeStateDomain } from \"./compute_state_domain\";\n\nexport const computeAttributeValueDisplay = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entities: HomeAssistant[\"entities\"],\n  attribute: string,\n  value?: any\n): string => {\n  const attributeValue =\n    value !== undefined ? value : stateObj.attributes[attribute];\n\n  // Null value, the state is unknown\n  if (attributeValue === null) {\n    return localize(\"state.default.unknown\");\n  }\n\n  // Number value, return formatted number\n  if (typeof attributeValue === \"number\") {\n    const domain = computeStateDomain(stateObj);\n\n    const formatter = DOMAIN_ATTRIBUTES_FORMATERS[domain]?.[attribute];\n\n    const formattedValue = formatter\n      ? formatter(attributeValue, locale)\n      : formatNumber(attributeValue, locale);\n\n    let unit = DOMAIN_ATTRIBUTES_UNITS[domain]?.[attribute] as\n      | string\n      | undefined;\n\n    if (domain === \"weather\") {\n      unit = getWeatherUnit(config, stateObj as WeatherEntity, attribute);\n    }\n\n    if (TEMPERATURE_ATTRIBUTES.has(attribute)) {\n      unit = config.unit_system.temperature;\n    }\n\n    if (unit) {\n      return `${formattedValue}${blankBeforeUnit(unit, locale)}${unit}`;\n    }\n\n    return formattedValue;\n  }\n\n  // Special handling in case this is a string with an known format\n  if (typeof attributeValue === \"string\") {\n    // Date handling\n    if (isDate(attributeValue, true)) {\n      // Timestamp handling\n      if (isTimestamp(attributeValue)) {\n        const date = new Date(attributeValue);\n        if (checkValidDate(date)) {\n          return formatDateTimeWithSeconds(date, locale, config);\n        }\n      }\n\n      // Value was not a timestamp, so only do date formatting\n      const date = new Date(attributeValue);\n      if (checkValidDate(date)) {\n        return formatDate(date, locale, config);\n      }\n    }\n  }\n\n  // Values are objects, render object\n  if (\n    (Array.isArray(attributeValue) &&\n      attributeValue.some((val) => val instanceof Object)) ||\n    (!Array.isArray(attributeValue) && attributeValue instanceof Object)\n  ) {\n    return JSON.stringify(attributeValue);\n  }\n  // If this is an array, try to determine the display value for each item\n  if (Array.isArray(attributeValue)) {\n    return attributeValue\n      .map((item) =>\n        computeAttributeValueDisplay(\n          localize,\n          stateObj,\n          locale,\n          config,\n          entities,\n          attribute,\n          item\n        )\n      )\n      .join(\", \");\n  }\n\n  // We've explored all known value handling, so now we'll try to find a\n  // translation for the value.\n  const entityId = stateObj.entity_id;\n  const domain = computeDomain(entityId);\n  const deviceClass = stateObj.attributes.device_class;\n  const registryEntry = entities[entityId] as\n    | EntityRegistryDisplayEntry\n    | undefined;\n  const translationKey = registryEntry?.translation_key;\n\n  return (\n    (translationKey &&\n      localize(\n        `component.${registryEntry.platform}.entity.${domain}.${translationKey}.state_attributes.${attribute}.state.${attributeValue}`\n      )) ||\n    (deviceClass &&\n      localize(\n        `component.${domain}.entity_component.${deviceClass}.state_attributes.${attribute}.state.${attributeValue}`\n      )) ||\n    localize(\n      `component.${domain}.entity_component._.state_attributes.${attribute}.state.${attributeValue}`\n    ) ||\n    attributeValue\n  );\n};\n\nexport const computeAttributeNameDisplay = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  entities: HomeAssistant[\"entities\"],\n  attribute: string\n): string => {\n  const entityId = stateObj.entity_id;\n  const deviceClass = stateObj.attributes.device_class;\n  const domain = computeDomain(entityId);\n  const entity = entities[entityId] as EntityRegistryDisplayEntry | undefined;\n  const translationKey = entity?.translation_key;\n\n  return (\n    (translationKey &&\n      localize(\n        `component.${entity.platform}.entity.${domain}.${translationKey}.state_attributes.${attribute}.name`\n      )) ||\n    (deviceClass &&\n      localize(\n        `component.${domain}.entity_component.${deviceClass}.state_attributes.${attribute}.name`\n      )) ||\n    localize(\n      `component.${domain}.entity_component._.state_attributes.${attribute}.name`\n    ) ||\n    capitalizeFirstLetter(\n      attribute\n        .replace(/_/g, \" \")\n        .replace(/\\bid\\b/g, \"ID\")\n        .replace(/\\bip\\b/g, \"IP\")\n        .replace(/\\bmac\\b/g, \"MAC\")\n        .replace(/\\bgps\\b/g, \"GPS\")\n    )\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}