{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nvar ClassMapDirective = /*#__PURE__*/function (_Directive) {\n  _inherits(ClassMapDirective, _Directive);\n  function ClassMapDirective(partInfo) {\n    var _this;\n    _classCallCheck(this, ClassMapDirective);\n    var _a;\n    _this = _callSuper(this, ClassMapDirective, [partInfo]);\n    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== 'class' || ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {\n      throw new Error('`classMap()` can only be used in the `class` attribute ' + 'and must be the only part in the attribute.');\n    }\n    return _this;\n  }\n  _createClass(ClassMapDirective, [{\n    key: \"render\",\n    value: function render(classInfo) {\n      // Add spaces to ensure separation from static classes\n      return ' ' + Object.keys(classInfo).filter(function (key) {\n        return classInfo[key];\n      }).join(' ') + ' ';\n    }\n  }, {\n    key: \"update\",\n    value: function update(part, _ref) {\n      var _this2 = this;\n      var _ref2 = _slicedToArray(_ref, 1),\n        classInfo = _ref2[0];\n      var _a, _b;\n      // Remember dynamic classes on the first render\n      if (this._previousClasses === undefined) {\n        this._previousClasses = new Set();\n        if (part.strings !== undefined) {\n          this._staticClasses = new Set(part.strings.join(' ').split(/\\s/).filter(function (s) {\n            return s !== '';\n          }));\n        }\n        for (var name in classInfo) {\n          if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {\n            this._previousClasses.add(name);\n          }\n        }\n        return this.render(classInfo);\n      }\n      var classList = part.element.classList;\n      // Remove old classes that no longer apply\n      // We use forEach() instead of for-of so that we don't require down-level\n      // iteration.\n      this._previousClasses.forEach(function (name) {\n        if (!(name in classInfo)) {\n          classList.remove(name);\n          _this2._previousClasses.delete(name);\n        }\n      });\n      // Add or remove classes based on their classMap value\n      for (var _name in classInfo) {\n        // We explicitly want a loose truthy check of `value` because it seems\n        // more convenient that '' and 0 are skipped.\n        var value = !!classInfo[_name];\n        if (value !== this._previousClasses.has(_name) && !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(_name))) {\n          if (value) {\n            classList.add(_name);\n            this._previousClasses.add(_name);\n          } else {\n            classList.remove(_name);\n            this._previousClasses.delete(_name);\n          }\n        }\n      }\n      return noChange;\n    }\n  }]);\n  return ClassMapDirective;\n}(Directive);\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport var classMap = directive(ClassMapDirective);","map":{"version":3,"names":["noChange","directive","Directive","PartType","ClassMapDirective","_Directive","_inherits","partInfo","_this","_classCallCheck","_callSuper","type","ATTRIBUTE","name","_a","strings","length","Error","_createClass","key","value","render","classInfo","Object","keys","filter","join","update","part","_ref","_this2","_ref2","_slicedToArray","_previousClasses","undefined","Set","_staticClasses","split","s","has","add","classList","element","forEach","remove","delete","_b","classMap"],"sources":["../../src/directives/class-map.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.'\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== '')\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach((name) => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    });\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}