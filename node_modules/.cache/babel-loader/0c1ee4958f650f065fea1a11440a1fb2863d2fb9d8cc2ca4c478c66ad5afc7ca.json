{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDisplayFromEntityAttributes } from \"../common/entity/compute_state_display\";\nimport { computeStateNameFromEntityAttributes } from \"../common/entity/compute_state_name\";\nvar DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nvar NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\", \"person\", \"device_tracker\"];\nvar LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\", \"action\", \"current_humidity\"];\nexport var entityIdHistoryNeedsAttributes = function entityIdHistoryNeedsAttributes(hass, entityId) {\n  return !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\n};\nexport var fetchDateWS = function fetchDateWS(hass, startTime, endTime, entityIds) {\n  var params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(function (entityId) {\n      return entityIdHistoryNeedsAttributes(hass, entityId);\n    })\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS(Object.assign(Object.assign({}, params), {}, {\n      entity_ids: entityIds\n    }));\n  }\n  return hass.callWS(params);\n};\nexport var subscribeHistory = function subscribeHistory(hass, callbackFunction, startTime, endTime, entityIds) {\n  var params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(function (entityId) {\n      return entityIdHistoryNeedsAttributes(hass, entityId);\n    })\n  };\n  var stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage(function (message) {\n    return callbackFunction(stream.processMessage(message));\n  }, params);\n};\nvar HistoryStream = /*#__PURE__*/function () {\n  function HistoryStream(hass, hoursToShow) {\n    _classCallCheck(this, HistoryStream);\n    this.hass = void 0;\n    this.hoursToShow = void 0;\n    this.combinedHistory = void 0;\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n  _createClass(HistoryStream, [{\n    key: \"processMessage\",\n    value: function processMessage(streamMessage) {\n      if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n        this.combinedHistory = streamMessage.states;\n        return this.combinedHistory;\n      }\n      if (!Object.keys(streamMessage.states).length) {\n        // Empty messages are still sent to\n        // indicate no more historical events\n        return this.combinedHistory;\n      }\n      var purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n      var newHistory = {};\n      for (var _i = 0, _Object$keys = Object.keys(this.combinedHistory); _i < _Object$keys.length; _i++) {\n        var _entityId = _Object$keys[_i];\n        newHistory[_entityId] = [];\n      }\n      for (var _i2 = 0, _Object$keys2 = Object.keys(streamMessage.states); _i2 < _Object$keys2.length; _i2++) {\n        var _entityId2 = _Object$keys2[_i2];\n        newHistory[_entityId2] = [];\n      }\n      for (var _i3 = 0, _Object$keys3 = Object.keys(newHistory); _i3 < _Object$keys3.length; _i3++) {\n        var _entityId3 = _Object$keys3[_i3];\n        if (_entityId3 in this.combinedHistory && _entityId3 in streamMessage.states) {\n          var entityCombinedHistory = this.combinedHistory[_entityId3];\n          var lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n          newHistory[_entityId3] = entityCombinedHistory.concat(streamMessage.states[_entityId3]);\n          if (streamMessage.states[_entityId3][0].lu < lastEntityCombinedHistory.lu) {\n            // If the history is out of order we have to sort it.\n            newHistory[_entityId3] = newHistory[_entityId3].sort(function (a, b) {\n              return a.lu - b.lu;\n            });\n          }\n        } else if (_entityId3 in this.combinedHistory) {\n          newHistory[_entityId3] = this.combinedHistory[_entityId3];\n        } else {\n          newHistory[_entityId3] = streamMessage.states[_entityId3];\n        }\n        // Remove old history\n        if (purgeBeforePythonTime && _entityId3 in this.combinedHistory) {\n          var expiredStates = newHistory[_entityId3].filter(function (state) {\n            return state.lu < purgeBeforePythonTime;\n          });\n          if (!expiredStates.length) {\n            continue;\n          }\n          newHistory[_entityId3] = newHistory[_entityId3].filter(function (state) {\n            return state.lu >= purgeBeforePythonTime;\n          });\n          if (newHistory[_entityId3].length && newHistory[_entityId3][0].lu === purgeBeforePythonTime) {\n            continue;\n          }\n          // Update the first entry to the start time state\n          // as we need to preserve the start time state and\n          // only expire the rest of the history as it ages.\n          var lastExpiredState = expiredStates[expiredStates.length - 1];\n          lastExpiredState.lu = purgeBeforePythonTime;\n          newHistory[_entityId3].unshift(lastExpiredState);\n        }\n      }\n      this.combinedHistory = newHistory;\n      return this.combinedHistory;\n    }\n  }]);\n  return HistoryStream;\n}();\nexport var subscribeHistoryStatesTimeWindow = function subscribeHistoryStatesTimeWindow(hass, callbackFunction, hoursToShow, entityIds) {\n  var minimalResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var significantChangesOnly = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var noAttributes = arguments.length > 6 ? arguments[6] : undefined;\n  var params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes !== null && noAttributes !== void 0 ? noAttributes : !entityIds.some(function (entityId) {\n      return entityIdHistoryNeedsAttributes(hass, entityId);\n    })\n  };\n  var stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage(function (message) {\n    return callbackFunction(stream.processMessage(message));\n  }, params);\n};\nvar equalState = function equalState(obj1, obj2) {\n  return obj1.state === obj2.state && (\n  // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  !obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(function (attr) {\n    return obj1.attributes[attr] === obj2.attributes[attr];\n  }));\n};\nvar processTimelineEntity = function processTimelineEntity(localize, locale, config, entities, entityId, states, current_state) {\n  var data = [];\n  var first = states[0];\n  var _iterator = _createForOfIteratorHelper(states),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var state = _step.value;\n      if (data.length > 0 && state.s === data[data.length - 1].state) {\n        continue;\n      }\n      var currentAttributes = {};\n      if (current_state !== null && current_state !== void 0 && current_state.attributes.device_class) {\n        currentAttributes.device_class = current_state === null || current_state === void 0 ? void 0 : current_state.attributes.device_class;\n      }\n      data.push({\n        state_localize: computeStateDisplayFromEntityAttributes(localize, locale, config, entities[entityId], entityId, Object.assign(Object.assign({}, state.a || first.a), currentAttributes), state.s),\n        state: state.s,\n        // lc (last_changed) may be omitted if its the same\n        // as lu (last_updated).\n        last_changed: (state.lc ? state.lc : state.lu) * 1000\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    name: computeStateNameFromEntityAttributes(entityId, (current_state === null || current_state === void 0 ? void 0 : current_state.attributes) || first.a),\n    entity_id: entityId,\n    data: data\n  };\n};\nvar processLineChartEntities = function processLineChartEntities(unit, device_class, entities, hassEntities) {\n  var data = [];\n  Object.keys(entities).forEach(function (entityId) {\n    var states = entities[entityId];\n    var first = states[0];\n    var domain = computeDomain(entityId);\n    var processedStates = [];\n    var _iterator2 = _createForOfIteratorHelper(states),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var state = _step2.value;\n        var processedState = void 0;\n        if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n          processedState = {\n            state: state.s,\n            last_changed: state.lu * 1000,\n            attributes: {}\n          };\n          for (var _i4 = 0, _LINE_ATTRIBUTES_TO_K = LINE_ATTRIBUTES_TO_KEEP; _i4 < _LINE_ATTRIBUTES_TO_K.length; _i4++) {\n            var attr = _LINE_ATTRIBUTES_TO_K[_i4];\n            if (attr in state.a) {\n              processedState.attributes[attr] = state.a[attr];\n            }\n          }\n        } else {\n          processedState = {\n            state: state.s,\n            // lc (last_changed) may be omitted if its the same\n            // as lu (last_updated).\n            last_changed: (state.lc ? state.lc : state.lu) * 1000,\n            attributes: {}\n          };\n        }\n        if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n          continue;\n        }\n        processedStates.push(processedState);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n    data.push({\n      domain: domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates\n    });\n  });\n  return {\n    unit: unit,\n    device_class: device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data: data\n  };\n};\nvar NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\nvar isNumericFromDomain = function isNumericFromDomain(domain) {\n  return NUMERICAL_DOMAINS.includes(domain);\n};\nvar isNumericFromAttributes = function isNumericFromAttributes(attributes) {\n  return \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n};\nvar isNumericSensorEntity = function isNumericSensorEntity(stateObj, sensorNumericalDeviceClasses) {\n  return stateObj.attributes.device_class != null && sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\n};\nvar BLANK_UNIT = \" \";\nexport var computeHistory = function computeHistory(hass, stateHistory, localize, sensorNumericalDeviceClasses) {\n  var splitDeviceClasses = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var lineChartDevices = {};\n  var timelineDevices = [];\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n  Object.keys(stateHistory).forEach(function (entityId) {\n    var _ref;\n    var stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n    var domain = computeDomain(entityId);\n    var currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    var numericStateFromHistory = currentState || isNumericFromDomain(domain) ? undefined : stateInfo.find(function (state) {\n      return state.a && isNumericFromAttributes(state.a);\n    });\n    var unit;\n    var isNumeric = isNumericFromDomain(domain) || currentState != null && isNumericFromAttributes(currentState.attributes) || currentState != null && domain === \"sensor\" && isNumericSensorEntity(currentState, sensorNumericalDeviceClasses) || numericStateFromHistory != null;\n    if (isNumeric) {\n      unit = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes.unit_of_measurement) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a.unit_of_measurement) || BLANK_UNIT;\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        humidifier: \"%\",\n        water_heater: hass.config.unit_system.temperature\n      }[domain];\n    }\n    var specialDomainClasses = {\n      climate: \"temperature\",\n      humidifier: \"humidity\",\n      water_heater: \"temperature\"\n    };\n    var deviceClass = specialDomainClasses[domain] || ((_ref = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a)) === null || _ref === void 0 ? void 0 : _ref.device_class);\n    var key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, hass.config, hass.entities, entityId, stateInfo, currentState));\n    } else if (key && key in lineChartDevices && entityId in lineChartDevices[key]) {\n      var _lineChartDevices$key;\n      (_lineChartDevices$key = lineChartDevices[key][entityId]).push.apply(_lineChartDevices$key, _toConsumableArray(stateInfo));\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n  var unitStates = Object.keys(lineChartDevices).map(function (key) {\n    var splitKey = key.split(\"_\");\n    var unit = splitKey[0];\n    var deviceClass = splitKey[1] || undefined;\n    return processLineChartEntities(unit, deviceClass, lineChartDevices[key], hass.states);\n  });\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n};\nexport var computeGroupKey = function computeGroupKey(unit, device_class, splitDeviceClasses) {\n  return splitDeviceClasses ? \"\".concat(unit, \"_\").concat(device_class || \"\") : unit;\n};","map":{"version":3,"names":["computeDomain","computeStateDisplayFromEntityAttributes","computeStateNameFromEntityAttributes","DOMAINS_USE_LAST_UPDATED","NEED_ATTRIBUTE_DOMAINS","LINE_ATTRIBUTES_TO_KEEP","entityIdHistoryNeedsAttributes","hass","entityId","states","includes","fetchDateWS","startTime","endTime","entityIds","params","type","start_time","toISOString","end_time","minimal_response","no_attributes","some","length","callWS","Object","assign","entity_ids","subscribeHistory","callbackFunction","stream","HistoryStream","connection","subscribeMessage","message","processMessage","hoursToShow","_classCallCheck","combinedHistory","_createClass","key","value","streamMessage","keys","purgeBeforePythonTime","Date","getTime","undefined","newHistory","_i","_Object$keys","_i2","_Object$keys2","_i3","_Object$keys3","entityCombinedHistory","lastEntityCombinedHistory","concat","lu","sort","a","b","expiredStates","filter","state","lastExpiredState","unshift","subscribeHistoryStatesTimeWindow","minimalResponse","arguments","significantChangesOnly","noAttributes","significant_changes_only","equalState","obj1","obj2","attributes","every","attr","processTimelineEntity","localize","locale","config","entities","current_state","data","first","_iterator","_createForOfIteratorHelper","_step","s","n","done","currentAttributes","device_class","push","state_localize","last_changed","lc","err","e","f","name","entity_id","processLineChartEntities","unit","hassEntities","forEach","domain","processedStates","_iterator2","_step2","processedState","_i4","_LINE_ATTRIBUTES_TO_K","identifier","join","NUMERICAL_DOMAINS","isNumericFromDomain","isNumericFromAttributes","isNumericSensorEntity","stateObj","sensorNumericalDeviceClasses","BLANK_UNIT","computeHistory","stateHistory","splitDeviceClasses","lineChartDevices","timelineDevices","line","timeline","_ref","stateInfo","currentState","numericStateFromHistory","find","isNumeric","unit_of_measurement","zone","climate","unit_system","temperature","humidifier","water_heater","specialDomainClasses","deviceClass","computeGroupKey","_lineChartDevices$key","apply","_toConsumableArray","unitStates","map","splitKey","split"],"sources":["/workspaces/frontend/src/data/history.ts"],"sourcesContent":["import {\n  HassConfig,\n  HassEntities,\n  HassEntity,\n  HassEntityAttributeBase,\n} from \"home-assistant-js-websocket\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDisplayFromEntityAttributes } from \"../common/entity/compute_state_display\";\nimport { computeStateNameFromEntityAttributes } from \"../common/entity/compute_state_name\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { HomeAssistant } from \"../types\";\nimport { FrontendLocaleData } from \"./translation\";\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\n  \"climate\",\n  \"humidifier\",\n  \"input_datetime\",\n  \"thermostat\",\n  \"water_heater\",\n  \"person\",\n  \"device_tracker\",\n];\nconst LINE_ATTRIBUTES_TO_KEEP = [\n  \"temperature\",\n  \"current_temperature\",\n  \"target_temp_low\",\n  \"target_temp_high\",\n  \"hvac_action\",\n  \"humidity\",\n  \"mode\",\n  \"action\",\n  \"current_humidity\",\n];\n\nexport interface LineChartState {\n  state: string;\n  last_changed: number;\n  attributes?: Record<string, any>;\n}\n\nexport interface LineChartEntity {\n  domain: string;\n  name: string;\n  entity_id: string;\n  states: LineChartState[];\n  statistics?: LineChartState[];\n}\n\nexport interface LineChartUnit {\n  unit: string;\n  device_class?: string;\n  identifier: string;\n  data: LineChartEntity[];\n}\n\nexport interface TimelineState {\n  state_localize: string;\n  state: string;\n  last_changed: number;\n}\n\nexport interface TimelineEntity {\n  name: string;\n  entity_id: string;\n  data: TimelineState[];\n}\n\nexport interface HistoryResult {\n  line: LineChartUnit[];\n  timeline: TimelineEntity[];\n}\n\nexport interface HistoryStates {\n  [entityId: string]: EntityHistoryState[];\n}\n\nexport interface EntityHistoryState {\n  /** state */\n  s: string;\n  /** attributes */\n  a: { [key: string]: any };\n  /** last_changed; if set, also applies to lu */\n  lc: number;\n  /** last_updated */\n  lu: number;\n}\n\nexport interface HistoryStreamMessage {\n  states: HistoryStates;\n  start_time?: number; // Start time of this historical chunk\n  end_time?: number; // End time of this historical chunk\n}\n\nexport const entityIdHistoryNeedsAttributes = (\n  hass: HomeAssistant,\n  entityId: string\n) =>\n  !hass.states[entityId] ||\n  NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\n\nexport const fetchDateWS = (\n  hass: HomeAssistant,\n  startTime: Date,\n  endTime: Date,\n  entityIds: string[]\n) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some((entityId) =>\n      entityIdHistoryNeedsAttributes(hass, entityId)\n    ),\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS<HistoryStates>({ ...params, entity_ids: entityIds });\n  }\n  return hass.callWS<HistoryStates>(params);\n};\n\nexport const subscribeHistory = (\n  hass: HomeAssistant,\n  callbackFunction: (data: HistoryStates) => void,\n  startTime: Date,\n  endTime: Date,\n  entityIds: string[]\n): Promise<() => Promise<void>> => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some((entityId) =>\n      entityIdHistoryNeedsAttributes(hass, entityId)\n    ),\n  };\n  const stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage<HistoryStreamMessage>(\n    (message) => callbackFunction(stream.processMessage(message)),\n    params\n  );\n};\n\nclass HistoryStream {\n  hass: HomeAssistant;\n\n  hoursToShow?: number;\n\n  combinedHistory: HistoryStates;\n\n  constructor(hass: HomeAssistant, hoursToShow?: number) {\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n\n  processMessage(streamMessage: HistoryStreamMessage): HistoryStates {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow\n      ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000\n      : undefined;\n    const newHistory: HistoryStates = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (\n        entityId in this.combinedHistory &&\n        entityId in streamMessage.states\n      ) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory =\n          entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(\n          streamMessage.states[entityId]\n        );\n        if (\n          streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu\n        ) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort(\n            (a, b) => a.lu - b.lu\n          );\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter(\n          (state) => state.lu < purgeBeforePythonTime\n        );\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter(\n          (state) => state.lu >= purgeBeforePythonTime\n        );\n        if (\n          newHistory[entityId].length &&\n          newHistory[entityId][0].lu === purgeBeforePythonTime\n        ) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\n\nexport const subscribeHistoryStatesTimeWindow = (\n  hass: HomeAssistant,\n  callbackFunction: (data: HistoryStates) => void,\n  hoursToShow: number,\n  entityIds: string[],\n  minimalResponse = true,\n  significantChangesOnly = true,\n  noAttributes?: boolean\n): Promise<() => Promise<void>> => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(\n      new Date().getTime() - 60 * 60 * hoursToShow * 1000\n    ).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes:\n      noAttributes ??\n      !entityIds.some((entityId) =>\n        entityIdHistoryNeedsAttributes(hass, entityId)\n      ),\n  };\n  const stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage<HistoryStreamMessage>(\n    (message) => callbackFunction(stream.processMessage(message)),\n    params\n  );\n};\n\nconst equalState = (obj1: LineChartState, obj2: LineChartState) =>\n  obj1.state === obj2.state &&\n  // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  (!obj1.attributes ||\n    !obj2.attributes ||\n    LINE_ATTRIBUTES_TO_KEEP.every(\n      (attr) => obj1.attributes![attr] === obj2.attributes![attr]\n    ));\n\nconst processTimelineEntity = (\n  localize: LocalizeFunc,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entities: HomeAssistant[\"entities\"],\n  entityId: string,\n  states: EntityHistoryState[],\n  current_state: HassEntity | undefined\n): TimelineEntity => {\n  const data: TimelineState[] = [];\n  const first: EntityHistoryState = states[0];\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n\n    const currentAttributes: HassEntityAttributeBase = {};\n    if (current_state?.attributes.device_class) {\n      currentAttributes.device_class = current_state?.attributes.device_class;\n    }\n\n    data.push({\n      state_localize: computeStateDisplayFromEntityAttributes(\n        localize,\n        locale,\n        config,\n        entities[entityId],\n        entityId,\n        {\n          ...(state.a || first.a),\n          ...currentAttributes,\n        },\n        state.s\n      ),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000,\n    });\n  }\n\n  return {\n    name: computeStateNameFromEntityAttributes(\n      entityId,\n      current_state?.attributes || first.a\n    ),\n    entity_id: entityId,\n    data,\n  };\n};\n\nconst processLineChartEntities = (\n  unit: string,\n  device_class: string | undefined,\n  entities: HistoryStates,\n  hassEntities: HassEntities\n): LineChartUnit => {\n  const data: LineChartEntity[] = [];\n\n  Object.keys(entities).forEach((entityId) => {\n    const states = entities[entityId];\n    const first: EntityHistoryState = states[0];\n    const domain = computeDomain(entityId);\n    const processedStates: LineChartState[] = [];\n\n    for (const state of states) {\n      let processedState: LineChartState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {},\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes![attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {},\n        };\n      }\n\n      if (\n        processedStates.length > 1 &&\n        equalState(\n          processedState,\n          processedStates[processedStates.length - 1]\n        ) &&\n        equalState(processedState, processedStates[processedStates.length - 2])\n      ) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    const attributes =\n      entityId in hassEntities\n        ? hassEntities[entityId].attributes\n        : \"friendly_name\" in first.a\n          ? first.a\n          : undefined;\n\n    data.push({\n      domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates,\n    });\n  });\n\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data,\n  };\n};\n\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\n\nconst isNumericFromDomain = (domain: string) =>\n  NUMERICAL_DOMAINS.includes(domain);\n\nconst isNumericFromAttributes = (attributes: { [key: string]: any }) =>\n  \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n\nconst isNumericSensorEntity = (\n  stateObj: HassEntity,\n  sensorNumericalDeviceClasses: string[]\n) =>\n  stateObj.attributes.device_class != null &&\n  sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\n\nconst BLANK_UNIT = \" \";\n\nexport const computeHistory = (\n  hass: HomeAssistant,\n  stateHistory: HistoryStates,\n  localize: LocalizeFunc,\n  sensorNumericalDeviceClasses: string[],\n  splitDeviceClasses = false\n): HistoryResult => {\n  const lineChartDevices: { [unit: string]: HistoryStates } = {};\n  const timelineDevices: TimelineEntity[] = [];\n  if (!stateHistory) {\n    return { line: [], timeline: [] };\n  }\n  Object.keys(stateHistory).forEach((entityId) => {\n    const stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const domain = computeDomain(entityId);\n\n    const currentState =\n      entityId in hass.states ? hass.states[entityId] : undefined;\n    const numericStateFromHistory =\n      currentState || isNumericFromDomain(domain)\n        ? undefined\n        : stateInfo.find(\n            (state) => state.a && isNumericFromAttributes(state.a)\n          );\n\n    let unit: string | undefined;\n\n    const isNumeric =\n      isNumericFromDomain(domain) ||\n      (currentState != null &&\n        isNumericFromAttributes(currentState.attributes)) ||\n      (currentState != null &&\n        domain === \"sensor\" &&\n        isNumericSensorEntity(currentState, sensorNumericalDeviceClasses)) ||\n      numericStateFromHistory != null;\n\n    if (isNumeric) {\n      unit =\n        currentState?.attributes.unit_of_measurement ||\n        numericStateFromHistory?.a.unit_of_measurement ||\n        BLANK_UNIT;\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        humidifier: \"%\",\n        water_heater: hass.config.unit_system.temperature,\n      }[domain];\n    }\n\n    const specialDomainClasses = {\n      climate: \"temperature\",\n      humidifier: \"humidity\",\n      water_heater: \"temperature\",\n    };\n\n    const deviceClass: string | undefined =\n      specialDomainClasses[domain] ||\n      (currentState?.attributes || numericStateFromHistory?.a)?.device_class;\n\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n\n    if (!unit) {\n      timelineDevices.push(\n        processTimelineEntity(\n          localize,\n          hass.locale,\n          hass.config,\n          hass.entities,\n          entityId,\n          stateInfo,\n          currentState\n        )\n      );\n    } else if (\n      key &&\n      key in lineChartDevices &&\n      entityId in lineChartDevices[key]\n    ) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n\n  const unitStates = Object.keys(lineChartDevices).map((key) => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey[1] || undefined;\n    return processLineChartEntities(\n      unit,\n      deviceClass,\n      lineChartDevices[key],\n      hass.states\n    );\n  });\n\n  return { line: unitStates, timeline: timelineDevices };\n};\n\nexport const computeGroupKey = (\n  unit: string | undefined,\n  device_class: string | undefined,\n  splitDeviceClasses: boolean\n) => (splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}