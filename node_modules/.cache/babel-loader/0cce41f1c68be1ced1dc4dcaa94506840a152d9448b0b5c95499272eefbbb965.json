{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { ReactiveElement } from \"lit\";\nimport { property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { navigate } from \"../common/navigate\";\nconst extractPage = (path, defaultPage) => {\n  if (path === \"\") {\n    return defaultPage;\n  }\n  const subpathStart = path.indexOf(\"/\", 1);\n  return subpathStart === -1 ? path.substr(1) : path.substr(1, subpathStart - 1);\n};\n// Time to wait for code to load before we show loading screen.\nconst LOADING_SCREEN_THRESHOLD = 400; // ms\n\nexport let HassRouterPage = _decorate(null, function (_initialize, _ReactiveElement) {\n  class HassRouterPage extends _ReactiveElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HassRouterPage,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"route\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"routerOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_currentPage\",\n      value() {\n        return \"\";\n      }\n    }, {\n      kind: \"field\",\n      key: \"_currentLoadProm\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_cache\",\n      value() {\n        return {};\n      }\n    }, {\n      kind: \"field\",\n      key: \"_initialLoadDone\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_computeTail\",\n      value() {\n        return memoizeOne(route => {\n          const dividerPos = route.path.indexOf(\"/\", 1);\n          return dividerPos === -1 ? {\n            prefix: route.prefix + route.path,\n            path: \"\"\n          } : {\n            prefix: route.prefix + route.path.substr(0, dividerPos),\n            path: route.path.substr(dividerPos)\n          };\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"createRenderRoot\",\n      value: function createRenderRoot() {\n        return this;\n      }\n    }, {\n      kind: \"method\",\n      key: \"update\",\n      value: function update(changedProps) {\n        _get(_getPrototypeOf(HassRouterPage.prototype), \"update\", this).call(this, changedProps);\n        const routerOptions = this.routerOptions || {\n          routes: {}\n        };\n        if (routerOptions && routerOptions.initialLoad && !this._initialLoadDone) {\n          return;\n        }\n        if (!changedProps.has(\"route\")) {\n          // Do not update if we have a currentLoadProm, because that means\n          // that there is still an old panel shown and we're moving to a new one.\n          if (this.lastChild && !this._currentLoadProm) {\n            this.updatePageEl(this.lastChild, changedProps);\n          }\n          return;\n        }\n        const route = this.route;\n        const defaultPage = routerOptions.defaultPage;\n        if (route && route.path === \"\" && defaultPage !== undefined) {\n          navigate(`${route.prefix}/${defaultPage}`, {\n            replace: true\n          });\n        }\n        let newPage = route ? extractPage(route.path, defaultPage || \"\") : \"not_found\";\n        let routeOptions = routerOptions.routes[newPage];\n\n        // Handle redirects\n        while (typeof routeOptions === \"string\") {\n          newPage = routeOptions;\n          routeOptions = routerOptions.routes[newPage];\n        }\n        if (routerOptions.beforeRender) {\n          const result = routerOptions.beforeRender(newPage);\n          if (result !== undefined) {\n            newPage = result;\n            routeOptions = routerOptions.routes[newPage];\n\n            // Handle redirects\n            while (typeof routeOptions === \"string\") {\n              newPage = routeOptions;\n              routeOptions = routerOptions.routes[newPage];\n            }\n\n            // Update the url if we know where we're mounted.\n            if (route) {\n              navigate(`${route.prefix}/${result}${location.search}`, {\n                replace: true\n              });\n            }\n          }\n        }\n        if (this._currentPage === newPage) {\n          if (this.lastChild) {\n            this.updatePageEl(this.lastChild, changedProps);\n          }\n          return;\n        }\n        if (!routeOptions) {\n          this._currentPage = \"\";\n          if (this.lastChild) {\n            this.removeChild(this.lastChild);\n          }\n          return;\n        }\n        this._currentPage = newPage;\n        const loadProm = routeOptions.load ? routeOptions.load() : Promise.resolve();\n        let showLoadingScreenTimeout;\n\n        // Check when loading the page source failed.\n        loadProm.catch(err => {\n          // eslint-disable-next-line\n          console.error(\"Error loading page\", newPage, err);\n\n          // Verify that we're still trying to show the same page.\n          if (this._currentPage !== newPage) {\n            return;\n          }\n\n          // Removes either loading screen or the panel\n          if (this.lastChild) {\n            this.removeChild(this.lastChild);\n          }\n          if (showLoadingScreenTimeout) {\n            clearTimeout(showLoadingScreenTimeout);\n          }\n\n          // Show error screen\n          this.appendChild(this.createErrorScreen(`Error while loading page ${newPage}.`));\n        });\n\n        // If we don't show loading screen, just show the panel.\n        // It will be automatically upgraded when loading done.\n        if (!routerOptions.showLoading) {\n          this._createPanel(routerOptions, newPage, routeOptions);\n          return;\n        }\n\n        // We are only going to show the loading screen after some time.\n        // That way we won't have a double fast flash on fast connections.\n        let created = false;\n        showLoadingScreenTimeout = window.setTimeout(() => {\n          if (created || this._currentPage !== newPage) {\n            return;\n          }\n\n          // Show a loading screen.\n          if (this.lastChild) {\n            this.removeChild(this.lastChild);\n          }\n          this.appendChild(this.createLoadingScreen());\n        }, LOADING_SCREEN_THRESHOLD);\n        this._currentLoadProm = loadProm.then(() => {\n          this._currentLoadProm = undefined;\n          // Check if we're still trying to show the same page.\n          if (this._currentPage !== newPage) {\n            return;\n          }\n          created = true;\n          this._createPanel(routerOptions, newPage,\n          // @ts-ignore TS forgot this is not a string.\n          routeOptions);\n        }, () => {\n          this._currentLoadProm = undefined;\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated(changedProps) {\n        _get(_getPrototypeOf(HassRouterPage.prototype), \"firstUpdated\", this).call(this, changedProps);\n        const options = this.routerOptions;\n        if (!options) {\n          return;\n        }\n        if (options.preloadAll) {\n          Object.values(options.routes).forEach(route => typeof route === \"object\" && route.load && route.load());\n        }\n        if (options.initialLoad) {\n          setTimeout(() => {\n            if (!this._initialLoadDone) {\n              this.appendChild(this.createLoadingScreen());\n            }\n          }, LOADING_SCREEN_THRESHOLD);\n          options.initialLoad().then(() => {\n            this._initialLoadDone = true;\n            this.requestUpdate(\"route\");\n          });\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"createLoadingScreen\",\n      value: function createLoadingScreen() {\n        import(\"./hass-loading-screen\");\n        return document.createElement(\"hass-loading-screen\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"createErrorScreen\",\n      value: function createErrorScreen(error) {\n        import(\"./hass-error-screen\");\n        const errorEl = document.createElement(\"hass-error-screen\");\n        errorEl.error = error;\n        return errorEl;\n      }\n\n      /**\n       * Rebuild the current panel.\n       *\n       * Promise will resolve when rebuilding is done and DOM updated.\n       */\n    }, {\n      kind: \"method\",\n      key: \"rebuild\",\n      value: async function rebuild() {\n        const oldRoute = this.route;\n        if (oldRoute === undefined) {\n          return;\n        }\n        this.route = undefined;\n        await this.updateComplete;\n        // Make sure that the parent didn't override this in the meanwhile.\n        if (this.route === undefined) {\n          this.route = oldRoute;\n        }\n      }\n\n      /**\n       * Promise that resolves when the page has rendered.\n       */\n    }, {\n      kind: \"get\",\n      key: \"pageRendered\",\n      value: function pageRendered() {\n        return this.updateComplete.then(() => this._currentLoadProm);\n      }\n    }, {\n      kind: \"method\",\n      key: \"createElement\",\n      value: function createElement(tag) {\n        return document.createElement(tag);\n      }\n    }, {\n      kind: \"method\",\n      key: \"updatePageEl\",\n      value: function updatePageEl(_pageEl, _changedProps) {\n        // default we do nothing\n      }\n    }, {\n      kind: \"get\",\n      key: \"routeTail\",\n      value: function routeTail() {\n        return this._computeTail(this.route);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_createPanel\",\n      value: function _createPanel(routerOptions, page, routeOptions) {\n        if (this.lastChild) {\n          this.removeChild(this.lastChild);\n        }\n        const panelEl = this._cache[page] || this.createElement(routeOptions.tag);\n        this.updatePageEl(panelEl);\n        this.appendChild(panelEl);\n        if (routerOptions.cacheAll || routeOptions.cache) {\n          this._cache[page] = panelEl;\n        }\n      }\n    }]\n  };\n}, ReactiveElement);","map":{"version":3,"names":["ReactiveElement","property","memoizeOne","navigate","extractPage","path","defaultPage","subpathStart","indexOf","substr","LOADING_SCREEN_THRESHOLD","HassRouterPage","_decorate","_initialize","_ReactiveElement","constructor","args","F","d","kind","decorators","attribute","key","value","route","dividerPos","prefix","createRenderRoot","update","changedProps","_get","_getPrototypeOf","prototype","call","routerOptions","routes","initialLoad","_initialLoadDone","has","lastChild","_currentLoadProm","updatePageEl","undefined","replace","newPage","routeOptions","beforeRender","result","location","search","_currentPage","removeChild","loadProm","load","Promise","resolve","showLoadingScreenTimeout","catch","err","console","error","clearTimeout","appendChild","createErrorScreen","showLoading","_createPanel","created","window","setTimeout","createLoadingScreen","then","firstUpdated","options","preloadAll","Object","values","forEach","requestUpdate","document","createElement","errorEl","rebuild","oldRoute","updateComplete","pageRendered","tag","_pageEl","_changedProps","routeTail","_computeTail","page","panelEl","_cache","cacheAll","cache"],"sources":["/workspaces/frontend/src/layouts/hass-router-page.ts"],"sourcesContent":["import { PropertyValues, ReactiveElement } from \"lit\";\nimport { property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { navigate } from \"../common/navigate\";\nimport { Route } from \"../types\";\n\nconst extractPage = (path: string, defaultPage: string) => {\n  if (path === \"\") {\n    return defaultPage;\n  }\n  const subpathStart = path.indexOf(\"/\", 1);\n  return subpathStart === -1\n    ? path.substr(1)\n    : path.substr(1, subpathStart - 1);\n};\n\nexport interface RouteOptions {\n  // HTML tag of the route page.\n  tag: string;\n  // Function to load the page.\n  load?: () => Promise<unknown>;\n  cache?: boolean;\n}\n\nexport interface RouterOptions {\n  // The default route to show if path does not define a page.\n  defaultPage?: string;\n  // If all routes should be preloaded\n  preloadAll?: boolean;\n  // If a route has been shown, should we keep the element in memory\n  cacheAll?: boolean;\n  // Should we show a loading spinner while we load the element for the route\n  showLoading?: boolean;\n  // Promise that resolves when the initial data is loaded which is needed to show any route.\n  initialLoad?: () => Promise<unknown>;\n  // Hook that is called before rendering a new route. Allowing redirects.\n  // If string returned, that page will be rendered instead.\n  beforeRender?: (page: string) => string | undefined;\n  routes: {\n    // If it's a string, it is another route whose options should be adopted.\n    [route: string]: RouteOptions | string;\n  };\n}\n\n// Time to wait for code to load before we show loading screen.\nconst LOADING_SCREEN_THRESHOLD = 400; // ms\n\nexport class HassRouterPage extends ReactiveElement {\n  @property({ attribute: false }) public route?: Route;\n\n  protected routerOptions!: RouterOptions;\n\n  protected _currentPage = \"\";\n\n  private _currentLoadProm?: Promise<void>;\n\n  private _cache = {};\n\n  private _initialLoadDone = false;\n\n  private _computeTail = memoizeOne((route: Route) => {\n    const dividerPos = route.path.indexOf(\"/\", 1);\n    return dividerPos === -1\n      ? {\n          prefix: route.prefix + route.path,\n          path: \"\",\n        }\n      : {\n          prefix: route.prefix + route.path.substr(0, dividerPos),\n          path: route.path.substr(dividerPos),\n        };\n  });\n\n  protected createRenderRoot() {\n    return this;\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    const routerOptions = this.routerOptions || { routes: {} };\n\n    if (routerOptions && routerOptions.initialLoad && !this._initialLoadDone) {\n      return;\n    }\n\n    if (!changedProps.has(\"route\")) {\n      // Do not update if we have a currentLoadProm, because that means\n      // that there is still an old panel shown and we're moving to a new one.\n      if (this.lastChild && !this._currentLoadProm) {\n        this.updatePageEl(this.lastChild, changedProps);\n      }\n      return;\n    }\n\n    const route = this.route;\n    const defaultPage = routerOptions.defaultPage;\n\n    if (route && route.path === \"\" && defaultPage !== undefined) {\n      navigate(`${route.prefix}/${defaultPage}`, { replace: true });\n    }\n\n    let newPage = route\n      ? extractPage(route.path, defaultPage || \"\")\n      : \"not_found\";\n    let routeOptions = routerOptions.routes[newPage];\n\n    // Handle redirects\n    while (typeof routeOptions === \"string\") {\n      newPage = routeOptions;\n      routeOptions = routerOptions.routes[newPage];\n    }\n\n    if (routerOptions.beforeRender) {\n      const result = routerOptions.beforeRender(newPage);\n      if (result !== undefined) {\n        newPage = result;\n        routeOptions = routerOptions.routes[newPage];\n\n        // Handle redirects\n        while (typeof routeOptions === \"string\") {\n          newPage = routeOptions;\n          routeOptions = routerOptions.routes[newPage];\n        }\n\n        // Update the url if we know where we're mounted.\n        if (route) {\n          navigate(`${route.prefix}/${result}${location.search}`, {\n            replace: true,\n          });\n        }\n      }\n    }\n\n    if (this._currentPage === newPage) {\n      if (this.lastChild) {\n        this.updatePageEl(this.lastChild, changedProps);\n      }\n      return;\n    }\n\n    if (!routeOptions) {\n      this._currentPage = \"\";\n      if (this.lastChild) {\n        this.removeChild(this.lastChild);\n      }\n      return;\n    }\n\n    this._currentPage = newPage;\n    const loadProm = routeOptions.load\n      ? routeOptions.load()\n      : Promise.resolve();\n\n    let showLoadingScreenTimeout: undefined | number;\n\n    // Check when loading the page source failed.\n    loadProm.catch((err) => {\n      // eslint-disable-next-line\n      console.error(\"Error loading page\", newPage, err);\n\n      // Verify that we're still trying to show the same page.\n      if (this._currentPage !== newPage) {\n        return;\n      }\n\n      // Removes either loading screen or the panel\n      if (this.lastChild) {\n        this.removeChild(this.lastChild!);\n      }\n\n      if (showLoadingScreenTimeout) {\n        clearTimeout(showLoadingScreenTimeout);\n      }\n\n      // Show error screen\n      this.appendChild(\n        this.createErrorScreen(`Error while loading page ${newPage}.`)\n      );\n    });\n\n    // If we don't show loading screen, just show the panel.\n    // It will be automatically upgraded when loading done.\n    if (!routerOptions.showLoading) {\n      this._createPanel(routerOptions, newPage, routeOptions);\n      return;\n    }\n\n    // We are only going to show the loading screen after some time.\n    // That way we won't have a double fast flash on fast connections.\n    let created = false;\n\n    showLoadingScreenTimeout = window.setTimeout(() => {\n      if (created || this._currentPage !== newPage) {\n        return;\n      }\n\n      // Show a loading screen.\n      if (this.lastChild) {\n        this.removeChild(this.lastChild);\n      }\n      this.appendChild(this.createLoadingScreen());\n    }, LOADING_SCREEN_THRESHOLD);\n\n    this._currentLoadProm = loadProm.then(\n      () => {\n        this._currentLoadProm = undefined;\n        // Check if we're still trying to show the same page.\n        if (this._currentPage !== newPage) {\n          return;\n        }\n\n        created = true;\n        this._createPanel(\n          routerOptions,\n          newPage,\n          // @ts-ignore TS forgot this is not a string.\n          routeOptions\n        );\n      },\n      () => {\n        this._currentLoadProm = undefined;\n      }\n    );\n  }\n\n  protected firstUpdated(changedProps: PropertyValues) {\n    super.firstUpdated(changedProps);\n\n    const options = this.routerOptions;\n\n    if (!options) {\n      return;\n    }\n\n    if (options.preloadAll) {\n      Object.values(options.routes).forEach(\n        (route) => typeof route === \"object\" && route.load && route.load()\n      );\n    }\n\n    if (options.initialLoad) {\n      setTimeout(() => {\n        if (!this._initialLoadDone) {\n          this.appendChild(this.createLoadingScreen());\n        }\n      }, LOADING_SCREEN_THRESHOLD);\n\n      options.initialLoad().then(() => {\n        this._initialLoadDone = true;\n        this.requestUpdate(\"route\");\n      });\n    }\n  }\n\n  protected createLoadingScreen() {\n    import(\"./hass-loading-screen\");\n    return document.createElement(\"hass-loading-screen\");\n  }\n\n  protected createErrorScreen(error: string) {\n    import(\"./hass-error-screen\");\n    const errorEl = document.createElement(\"hass-error-screen\");\n    errorEl.error = error;\n    return errorEl;\n  }\n\n  /**\n   * Rebuild the current panel.\n   *\n   * Promise will resolve when rebuilding is done and DOM updated.\n   */\n  protected async rebuild(): Promise<void> {\n    const oldRoute = this.route;\n\n    if (oldRoute === undefined) {\n      return;\n    }\n\n    this.route = undefined;\n    await this.updateComplete;\n    // Make sure that the parent didn't override this in the meanwhile.\n    if (this.route === undefined) {\n      this.route = oldRoute;\n    }\n  }\n\n  /**\n   * Promise that resolves when the page has rendered.\n   */\n  protected get pageRendered(): Promise<void> {\n    return this.updateComplete.then(() => this._currentLoadProm);\n  }\n\n  protected createElement(tag: string) {\n    return document.createElement(tag);\n  }\n\n  protected updatePageEl(_pageEl, _changedProps?: PropertyValues) {\n    // default we do nothing\n  }\n\n  protected get routeTail(): Route {\n    return this._computeTail(this.route!);\n  }\n\n  private _createPanel(\n    routerOptions: RouterOptions,\n    page: string,\n    routeOptions: RouteOptions\n  ) {\n    if (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    const panelEl = this._cache[page] || this.createElement(routeOptions.tag);\n    this.updatePageEl(panelEl);\n    this.appendChild(panelEl);\n\n    if (routerOptions.cacheAll || routeOptions.cache) {\n      this._cache[page] = panelEl;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}