{"ast":null,"code":"/* eslint-disable no-console */\n\nimport { castApiAvailable } from \"./cast_framework\";\nimport { CAST_APP_ID, CAST_DEV, CAST_NS } from \"./const\";\nimport { CAST_DEV_HASS_URL } from \"./dev_const\";\nimport { castSendAuth } from \"./receiver_messages\";\nlet managerProm;\n\n/*\nGeneral flow of Chromecast:\n\nChromecast sessions are started via the Chromecast button. When clicked, session\nstate changes to started. We then send authentication, which will cause the\nreceiver app to send a status update.\n\nIf a session is already active, we query the status to see what it is up to. If\na user presses the cast button we send auth if not connected yet, then send\ncommand as usual.\n*/\n\nexport class CastManager {\n  constructor(auth) {\n    this.auth = void 0;\n    // If the cast connection is connected to our Hass.\n    this.status = void 0;\n    this._eventListeners = {};\n    this._sessionStateChanged = ev => {\n      if (__DEV__) {\n        console.log(\"Cast session state changed\", ev.sessionState);\n      }\n      // On Android, opening a new session always results in SESSION_RESUMED.\n      // So treat both as the same.\n      if (ev.sessionState === \"SESSION_STARTED\" || ev.sessionState === \"SESSION_RESUMED\") {\n        if (this.auth) {\n          castSendAuth(this, this.auth);\n        } else {\n          // Only do if no auth, as this is done as part of sendAuth.\n          this.sendMessage({\n            type: \"get_status\"\n          });\n        }\n        this._attachMessageListener();\n      } else if (ev.sessionState === \"SESSION_ENDED\") {\n        this.status = undefined;\n        this._fireEvent(\"connection-changed\");\n      }\n    };\n    this._castStateChanged = ev => {\n      if (__DEV__) {\n        console.log(\"Cast state changed\", ev.castState);\n      }\n      this._fireEvent(\"state-changed\");\n    };\n    this.auth = auth;\n    const context = this.castContext;\n    context.setOptions({\n      receiverApplicationId: CAST_APP_ID,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED\n    });\n    context.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, this._sessionStateChanged);\n    context.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, this._castStateChanged);\n  }\n  addEventListener(event, listener) {\n    if (!(event in this._eventListeners)) {\n      this._eventListeners[event] = [];\n    }\n    this._eventListeners[event].push(listener);\n    return () => {\n      this._eventListeners[event].splice(this._eventListeners[event].indexOf(listener));\n    };\n  }\n  get castConnectedToOurHass() {\n    return this.status !== undefined && this.auth !== undefined && this.status.connected && (this.status.hassUrl === this.auth.data.hassUrl || CAST_DEV && this.status.hassUrl === CAST_DEV_HASS_URL);\n  }\n  sendMessage(msg) {\n    if (__DEV__) {\n      console.log(\"Sending cast message\", msg);\n    }\n    this.castSession.sendMessage(CAST_NS, msg);\n  }\n  get castState() {\n    return this.castContext.getCastState();\n  }\n  get castContext() {\n    // @ts-ignore\n    return cast.framework.CastContext.getInstance();\n  }\n  get castSession() {\n    return this.castContext.getCurrentSession();\n  }\n  requestSession() {\n    return this.castContext.requestSession();\n  }\n  _fireEvent(event) {\n    for (const listener of this._eventListeners[event] || []) {\n      listener();\n    }\n  }\n  _receiveMessage(msg) {\n    if (__DEV__) {\n      console.log(\"Received cast message\", msg);\n    }\n    if (msg.type === \"receiver_status\") {\n      this.status = msg;\n      this._fireEvent(\"connection-changed\");\n    }\n  }\n  _attachMessageListener() {\n    const session = this.castSession;\n    session.addMessageListener(CAST_NS, (_ns, msg) => this._receiveMessage(JSON.parse(msg)));\n  }\n}\nexport const getCastManager = auth => {\n  if (!managerProm) {\n    managerProm = castApiAvailable().then(isAvailable => {\n      if (!isAvailable) {\n        throw new Error(\"No Cast API available\");\n      }\n      return new CastManager(auth);\n    });\n  }\n  return managerProm;\n};","map":{"version":3,"names":["castApiAvailable","CAST_APP_ID","CAST_DEV","CAST_NS","CAST_DEV_HASS_URL","castSendAuth","managerProm","CastManager","constructor","auth","status","_eventListeners","_sessionStateChanged","ev","__DEV__","console","log","sessionState","sendMessage","type","_attachMessageListener","undefined","_fireEvent","_castStateChanged","castState","context","castContext","setOptions","receiverApplicationId","autoJoinPolicy","chrome","cast","AutoJoinPolicy","ORIGIN_SCOPED","addEventListener","framework","CastContextEventType","SESSION_STATE_CHANGED","CAST_STATE_CHANGED","event","listener","push","splice","indexOf","castConnectedToOurHass","connected","hassUrl","data","msg","castSession","getCastState","CastContext","getInstance","getCurrentSession","requestSession","_receiveMessage","session","addMessageListener","_ns","JSON","parse","getCastManager","then","isAvailable","Error"],"sources":["/Users/sercanardil/Desktop/frontend/src/cast/cast_manager.ts"],"sourcesContent":["/* eslint-disable no-console */\n\nimport { Auth } from \"home-assistant-js-websocket\";\nimport { castApiAvailable } from \"./cast_framework\";\nimport { CAST_APP_ID, CAST_DEV, CAST_NS } from \"./const\";\nimport { CAST_DEV_HASS_URL } from \"./dev_const\";\nimport {\n  castSendAuth,\n  HassMessage as ReceiverMessage,\n} from \"./receiver_messages\";\nimport { ReceiverStatusMessage, SenderMessage } from \"./sender_messages\";\n\nlet managerProm: Promise<CastManager> | undefined;\n\ntype CastEventListener = () => void;\n\n/*\nGeneral flow of Chromecast:\n\nChromecast sessions are started via the Chromecast button. When clicked, session\nstate changes to started. We then send authentication, which will cause the\nreceiver app to send a status update.\n\nIf a session is already active, we query the status to see what it is up to. If\na user presses the cast button we send auth if not connected yet, then send\ncommand as usual.\n*/\n\ntype CastEvent = \"connection-changed\" | \"state-changed\";\n\nexport class CastManager {\n  public auth?: Auth;\n\n  // If the cast connection is connected to our Hass.\n  public status?: ReceiverStatusMessage;\n\n  private _eventListeners: { [event: string]: CastEventListener[] } = {};\n\n  constructor(auth?: Auth) {\n    this.auth = auth;\n    const context = this.castContext;\n    context.setOptions({\n      receiverApplicationId: CAST_APP_ID,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\n    });\n    context.addEventListener(\n      cast.framework.CastContextEventType.SESSION_STATE_CHANGED,\n      this._sessionStateChanged\n    );\n    context.addEventListener(\n      cast.framework.CastContextEventType.CAST_STATE_CHANGED,\n      this._castStateChanged\n    );\n  }\n\n  public addEventListener(event: CastEvent, listener: CastEventListener) {\n    if (!(event in this._eventListeners)) {\n      this._eventListeners[event] = [];\n    }\n    this._eventListeners[event].push(listener);\n\n    return () => {\n      this._eventListeners[event].splice(\n        this._eventListeners[event].indexOf(listener)\n      );\n    };\n  }\n\n  public get castConnectedToOurHass(): boolean {\n    return (\n      this.status !== undefined &&\n      this.auth !== undefined &&\n      this.status.connected &&\n      (this.status.hassUrl === this.auth.data.hassUrl ||\n        (CAST_DEV && this.status.hassUrl === CAST_DEV_HASS_URL))\n    );\n  }\n\n  public sendMessage(msg: ReceiverMessage) {\n    if (__DEV__) {\n      console.log(\"Sending cast message\", msg);\n    }\n    this.castSession.sendMessage(CAST_NS, msg);\n  }\n\n  public get castState() {\n    return this.castContext.getCastState();\n  }\n\n  public get castContext() {\n    // @ts-ignore\n    return cast.framework.CastContext.getInstance();\n  }\n\n  public get castSession() {\n    return this.castContext.getCurrentSession()!;\n  }\n\n  public requestSession() {\n    return this.castContext.requestSession();\n  }\n\n  private _fireEvent(event: CastEvent) {\n    for (const listener of this._eventListeners[event] || []) {\n      listener();\n    }\n  }\n\n  private _receiveMessage(msg: SenderMessage) {\n    if (__DEV__) {\n      console.log(\"Received cast message\", msg);\n    }\n    if (msg.type === \"receiver_status\") {\n      this.status = msg;\n      this._fireEvent(\"connection-changed\");\n    }\n  }\n\n  private _sessionStateChanged = (ev: cast.framework.SessionStateEventData) => {\n    if (__DEV__) {\n      console.log(\"Cast session state changed\", ev.sessionState);\n    }\n    // On Android, opening a new session always results in SESSION_RESUMED.\n    // So treat both as the same.\n    if (\n      ev.sessionState === \"SESSION_STARTED\" ||\n      ev.sessionState === \"SESSION_RESUMED\"\n    ) {\n      if (this.auth) {\n        castSendAuth(this, this.auth);\n      } else {\n        // Only do if no auth, as this is done as part of sendAuth.\n        this.sendMessage({ type: \"get_status\" });\n      }\n      this._attachMessageListener();\n    } else if (ev.sessionState === \"SESSION_ENDED\") {\n      this.status = undefined;\n      this._fireEvent(\"connection-changed\");\n    }\n  };\n\n  private _castStateChanged = (ev: cast.framework.CastStateEventData) => {\n    if (__DEV__) {\n      console.log(\"Cast state changed\", ev.castState);\n    }\n    this._fireEvent(\"state-changed\");\n  };\n\n  private _attachMessageListener() {\n    const session = this.castSession;\n    session.addMessageListener(CAST_NS, (_ns, msg) =>\n      this._receiveMessage(JSON.parse(msg))\n    );\n  }\n}\n\nexport const getCastManager = (auth?: Auth) => {\n  if (!managerProm) {\n    managerProm = castApiAvailable().then((isAvailable) => {\n      if (!isAvailable) {\n        throw new Error(\"No Cast API available\");\n      }\n      return new CastManager(auth);\n    });\n  }\n  return managerProm;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}