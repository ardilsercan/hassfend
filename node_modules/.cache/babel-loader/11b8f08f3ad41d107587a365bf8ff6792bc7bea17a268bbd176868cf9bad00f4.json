{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport 'blocking-elements';\nimport 'wicg-inert';\nimport { cssClasses } from '@material/dialog/constants.js';\nimport MDCDialogFoundation from '@material/dialog/foundation.js';\nimport { applyPassive } from '@material/dom/events.js';\nimport { closest, matches } from '@material/dom/ponyfill.js';\nimport { addHasRemoveClass, BaseElement } from '@material/mwc-base/base-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nconst blockingElements = document.$blockingElements;\nexport class DialogBase extends BaseElement {\n  constructor() {\n    super(...arguments);\n    this.hideActions = false;\n    this.stacked = false;\n    this.heading = '';\n    this.scrimClickAction = 'close';\n    this.escapeKeyAction = 'close';\n    this.open = false;\n    this.defaultAction = 'close';\n    this.actionAttribute = 'dialogAction';\n    this.initialFocusAttribute = 'dialogInitialFocus';\n    this.initialSupressDefaultPressSelector = '';\n    this.mdcFoundationClass = MDCDialogFoundation;\n    this.boundHandleClick = null;\n    this.boundHandleKeydown = null;\n    this.boundHandleDocumentKeydown = null;\n  }\n  set suppressDefaultPressSelector(selector) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setSuppressDefaultPressSelector(selector);\n    } else {\n      this.initialSupressDefaultPressSelector = selector;\n    }\n  }\n  /**\n   * @export\n   */\n  get suppressDefaultPressSelector() {\n    return this.mdcFoundation ? this.mdcFoundation.getSuppressDefaultPressSelector() : this.initialSupressDefaultPressSelector;\n  }\n  get primaryButton() {\n    let assignedNodes = this.primarySlot.assignedNodes();\n    assignedNodes = assignedNodes.filter(node => node instanceof HTMLElement);\n    const button = assignedNodes[0];\n    return button ? button : null;\n  }\n  emitNotification(name, action) {\n    const init = {\n      detail: action ? {\n        action\n      } : {}\n    };\n    const ev = new CustomEvent(name, init);\n    this.dispatchEvent(ev);\n  }\n  getInitialFocusEl() {\n    const initFocusSelector = `[${this.initialFocusAttribute}]`;\n    // only search light DOM. This typically handles all the cases\n    const lightDomQs = this.querySelector(initFocusSelector);\n    if (lightDomQs) {\n      return lightDomQs;\n    }\n    // if not in light dom, search each flattened distributed node.\n    const primarySlot = this.primarySlot;\n    const primaryNodes = primarySlot.assignedNodes({\n      flatten: true\n    });\n    const primaryFocusElement = this.searchNodeTreesForAttribute(primaryNodes, this.initialFocusAttribute);\n    if (primaryFocusElement) {\n      return primaryFocusElement;\n    }\n    const secondarySlot = this.secondarySlot;\n    const secondaryNodes = secondarySlot.assignedNodes({\n      flatten: true\n    });\n    const secondaryFocusElement = this.searchNodeTreesForAttribute(secondaryNodes, this.initialFocusAttribute);\n    if (secondaryFocusElement) {\n      return secondaryFocusElement;\n    }\n    const contentSlot = this.contentSlot;\n    const contentNodes = contentSlot.assignedNodes({\n      flatten: true\n    });\n    const initFocusElement = this.searchNodeTreesForAttribute(contentNodes, this.initialFocusAttribute);\n    return initFocusElement;\n  }\n  searchNodeTreesForAttribute(nodes, attribute) {\n    for (const node of nodes) {\n      if (!(node instanceof HTMLElement)) {\n        continue;\n      }\n      if (node.hasAttribute(attribute)) {\n        return node;\n      } else {\n        const selection = node.querySelector(`[${attribute}]`);\n        if (selection) {\n          return selection;\n        }\n      }\n    }\n    return null;\n  }\n  createAdapter() {\n    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {\n      addBodyClass: () => document.body.style.overflow = 'hidden',\n      removeBodyClass: () => document.body.style.overflow = '',\n      areButtonsStacked: () => this.stacked,\n      clickDefaultButton: () => {\n        const primary = this.primaryButton;\n        if (primary) {\n          primary.click();\n        }\n      },\n      eventTargetMatches: (target, selector) => target ? matches(target, selector) : false,\n      getActionFromEvent: e => {\n        if (!e.target) {\n          return '';\n        }\n        const element = closest(e.target, `[${this.actionAttribute}]`);\n        const action = element && element.getAttribute(this.actionAttribute);\n        return action;\n      },\n      getInitialFocusEl: () => {\n        return this.getInitialFocusEl();\n      },\n      isContentScrollable: () => {\n        const el = this.contentElement;\n        return el ? el.scrollHeight > el.offsetHeight : false;\n      },\n      notifyClosed: action => this.emitNotification('closed', action),\n      notifyClosing: action => {\n        if (!this.closingDueToDisconnect) {\n          // Don't set our open state to closed just because we were\n          // disconnected. That way if we get reconnected, we'll know to\n          // re-open.\n          this.open = false;\n        }\n        this.emitNotification('closing', action);\n      },\n      notifyOpened: () => this.emitNotification('opened'),\n      notifyOpening: () => {\n        this.open = true;\n        this.emitNotification('opening');\n      },\n      reverseButtons: () => {},\n      releaseFocus: () => {\n        blockingElements.remove(this);\n      },\n      trapFocus: el => {\n        if (!this.isConnected) {\n          // this is the case where it is opened and closed and then removed\n          // from DOM before the animation has completed. Blocking Elements will\n          // throw if this is the case\n          return;\n        }\n        blockingElements.push(this);\n        if (el) {\n          el.focus();\n        }\n      },\n      registerContentEventHandler: (evtType, handler) => {\n        const el = this.contentElement;\n        el.addEventListener(evtType, handler);\n      },\n      deregisterContentEventHandler: (evtType, handler) => {\n        const el = this.contentElement;\n        el.removeEventListener(evtType, handler);\n      },\n      isScrollableContentAtTop: () => {\n        const el = this.contentElement;\n        return el ? el.scrollTop === 0 : false;\n      },\n      isScrollableContentAtBottom: () => {\n        const el = this.contentElement;\n        return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;\n      },\n      registerWindowEventHandler: (evtType, handler) => {\n        window.addEventListener(evtType, handler, applyPassive());\n      },\n      deregisterWindowEventHandler: (evtType, handler) => {\n        window.removeEventListener(evtType, handler, applyPassive());\n      }\n    });\n  }\n  render() {\n    const classes = {\n      [cssClasses.STACKED]: this.stacked\n    };\n    let heading = html``;\n    if (this.heading) {\n      heading = this.renderHeading();\n    }\n    const actionsClasses = {\n      'mdc-dialog__actions': !this.hideActions\n    };\n    return html`\n    <div class=\"mdc-dialog ${classMap(classes)}\"\n        role=\"alertdialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"title\"\n        aria-describedby=\"content\">\n      <div class=\"mdc-dialog__container\">\n        <div class=\"mdc-dialog__surface\">\n          ${heading}\n          <div id=\"content\" class=\"mdc-dialog__content\">\n            <slot id=\"contentSlot\"></slot>\n          </div>\n          <footer\n              id=\"actions\"\n              class=\"${classMap(actionsClasses)}\">\n            <span>\n              <slot name=\"secondaryAction\"></slot>\n            </span>\n            <span>\n             <slot name=\"primaryAction\"></slot>\n            </span>\n          </footer>\n        </div>\n      </div>\n      <div class=\"mdc-dialog__scrim\"></div>\n    </div>`;\n  }\n  renderHeading() {\n    return html`\n      <h2 id=\"title\" class=\"mdc-dialog__title\">${this.heading}</h2>`;\n  }\n  firstUpdated() {\n    super.firstUpdated();\n    this.mdcFoundation.setAutoStackButtons(true);\n    if (this.initialSupressDefaultPressSelector) {\n      this.suppressDefaultPressSelector = this.initialSupressDefaultPressSelector;\n    } else {\n      this.suppressDefaultPressSelector = [this.suppressDefaultPressSelector, 'mwc-textarea', 'mwc-menu mwc-list-item', 'mwc-select mwc-list-item'].join(', ');\n    }\n    this.boundHandleClick = this.mdcFoundation.handleClick.bind(this.mdcFoundation);\n    this.boundHandleKeydown = this.mdcFoundation.handleKeydown.bind(this.mdcFoundation);\n    this.boundHandleDocumentKeydown = this.mdcFoundation.handleDocumentKeydown.bind(this.mdcFoundation);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    if (this.open && this.mdcFoundation && !this.mdcFoundation.isOpen()) {\n      // We probably got disconnected while we were still open. Re-open,\n      // matching the behavior of native <dialog>.\n      this.setEventListeners();\n      this.mdcFoundation.open();\n    }\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this.open && this.mdcFoundation) {\n      // If this dialog is opened and then disconnected, we want to close\n      // the foundation, so that 1) any pending timers are cancelled\n      // (in particular for trapFocus), and 2) if we reconnect, we can open\n      // the foundation again to retrigger animations and focus.\n      this.removeEventListeners();\n      this.closingDueToDisconnect = true;\n      this.mdcFoundation.close(this.currentAction || this.defaultAction);\n      this.closingDueToDisconnect = false;\n      this.currentAction = undefined;\n      // When we close normally, the releaseFocus callback handles removing\n      // ourselves from the blocking elements stack. However, that callback\n      // happens on a delay, and when we are closing due to a disconnect we\n      // need to remove ourselves before the blocking element polyfill's\n      // mutation observer notices and logs a warning, since it's not valid to\n      // be in the blocking elements stack while disconnected.\n      blockingElements.remove(this);\n    }\n  }\n  forceLayout() {\n    this.mdcFoundation.layout();\n  }\n  focus() {\n    const initialFocusEl = this.getInitialFocusEl();\n    initialFocusEl && initialFocusEl.focus();\n  }\n  blur() {\n    if (!this.shadowRoot) {\n      return;\n    }\n    const activeEl = this.shadowRoot.activeElement;\n    if (activeEl) {\n      if (activeEl instanceof HTMLElement) {\n        activeEl.blur();\n      }\n    } else {\n      const root = this.getRootNode();\n      const activeEl = root instanceof Document ? root.activeElement : null;\n      if (activeEl instanceof HTMLElement) {\n        activeEl.blur();\n      }\n    }\n  }\n  setEventListeners() {\n    if (this.boundHandleClick) {\n      this.mdcRoot.addEventListener('click', this.boundHandleClick);\n    }\n    if (this.boundHandleKeydown) {\n      this.mdcRoot.addEventListener('keydown', this.boundHandleKeydown, applyPassive());\n    }\n    if (this.boundHandleDocumentKeydown) {\n      document.addEventListener('keydown', this.boundHandleDocumentKeydown, applyPassive());\n    }\n  }\n  removeEventListeners() {\n    if (this.boundHandleClick) {\n      this.mdcRoot.removeEventListener('click', this.boundHandleClick);\n    }\n    if (this.boundHandleKeydown) {\n      this.mdcRoot.removeEventListener('keydown', this.boundHandleKeydown);\n    }\n    if (this.boundHandleDocumentKeydown) {\n      document.removeEventListener('keydown', this.boundHandleDocumentKeydown);\n    }\n  }\n  close() {\n    this.open = false;\n  }\n  show() {\n    this.open = true;\n  }\n}\n__decorate([query('.mdc-dialog')], DialogBase.prototype, \"mdcRoot\", void 0);\n__decorate([query('slot[name=\"primaryAction\"]')], DialogBase.prototype, \"primarySlot\", void 0);\n__decorate([query('slot[name=\"secondaryAction\"]')], DialogBase.prototype, \"secondarySlot\", void 0);\n__decorate([query('#contentSlot')], DialogBase.prototype, \"contentSlot\", void 0);\n__decorate([query('.mdc-dialog__content')], DialogBase.prototype, \"contentElement\", void 0);\n__decorate([query('.mdc-container')], DialogBase.prototype, \"conatinerElement\", void 0);\n__decorate([property({\n  type: Boolean\n})], DialogBase.prototype, \"hideActions\", void 0);\n__decorate([property({\n  type: Boolean\n}), observer(function () {\n  this.forceLayout();\n})], DialogBase.prototype, \"stacked\", void 0);\n__decorate([property({\n  type: String\n})], DialogBase.prototype, \"heading\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (newAction) {\n  this.mdcFoundation.setScrimClickAction(newAction);\n})], DialogBase.prototype, \"scrimClickAction\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (newAction) {\n  this.mdcFoundation.setEscapeKeyAction(newAction);\n})], DialogBase.prototype, \"escapeKeyAction\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n}), observer(function (isOpen) {\n  // Check isConnected because we could have been disconnected before first\n  // update. If we're now closed, then we shouldn't start the MDC foundation\n  // opening animation. If we're now closed, then we've already closed the\n  // foundation in disconnectedCallback.\n  if (this.mdcFoundation && this.isConnected) {\n    if (isOpen) {\n      this.setEventListeners();\n      this.mdcFoundation.open();\n    } else {\n      this.removeEventListeners();\n      this.mdcFoundation.close(this.currentAction || this.defaultAction);\n      this.currentAction = undefined;\n    }\n  }\n})], DialogBase.prototype, \"open\", void 0);\n__decorate([property()], DialogBase.prototype, \"defaultAction\", void 0);\n__decorate([property()], DialogBase.prototype, \"actionAttribute\", void 0);\n__decorate([property()], DialogBase.prototype, \"initialFocusAttribute\", void 0);","map":{"version":3,"names":["cssClasses","MDCDialogFoundation","applyPassive","closest","matches","addHasRemoveClass","BaseElement","observer","html","property","query","classMap","blockingElements","document","$blockingElements","DialogBase","constructor","hideActions","stacked","heading","scrimClickAction","escapeKeyAction","open","defaultAction","actionAttribute","initialFocusAttribute","initialSupressDefaultPressSelector","mdcFoundationClass","boundHandleClick","boundHandleKeydown","boundHandleDocumentKeydown","suppressDefaultPressSelector","selector","mdcFoundation","setSuppressDefaultPressSelector","getSuppressDefaultPressSelector","primaryButton","assignedNodes","primarySlot","filter","node","HTMLElement","button","emitNotification","name","action","init","detail","ev","CustomEvent","dispatchEvent","getInitialFocusEl","initFocusSelector","lightDomQs","querySelector","primaryNodes","flatten","primaryFocusElement","searchNodeTreesForAttribute","secondarySlot","secondaryNodes","secondaryFocusElement","contentSlot","contentNodes","initFocusElement","nodes","attribute","hasAttribute","selection","createAdapter","Object","assign","mdcRoot","addBodyClass","body","style","overflow","removeBodyClass","areButtonsStacked","clickDefaultButton","primary","click","eventTargetMatches","target","getActionFromEvent","e","element","getAttribute","isContentScrollable","el","contentElement","scrollHeight","offsetHeight","notifyClosed","notifyClosing","closingDueToDisconnect","notifyOpened","notifyOpening","reverseButtons","releaseFocus","remove","trapFocus","isConnected","push","focus","registerContentEventHandler","evtType","handler","addEventListener","deregisterContentEventHandler","removeEventListener","isScrollableContentAtTop","scrollTop","isScrollableContentAtBottom","Math","ceil","clientHeight","registerWindowEventHandler","window","deregisterWindowEventHandler","render","classes","STACKED","renderHeading","actionsClasses","firstUpdated","setAutoStackButtons","join","handleClick","bind","handleKeydown","handleDocumentKeydown","connectedCallback","isOpen","setEventListeners","disconnectedCallback","removeEventListeners","close","currentAction","undefined","forceLayout","layout","initialFocusEl","blur","shadowRoot","activeEl","activeElement","root","getRootNode","Document","show","__decorate","type","Boolean","String","newAction","setScrimClickAction","setEscapeKeyAction","reflect"],"sources":["mwc-dialog-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport 'blocking-elements';\nimport 'wicg-inert';\n\nimport {MDCDialogAdapter} from '@material/dialog/adapter.js';\nimport {cssClasses} from '@material/dialog/constants.js';\nimport MDCDialogFoundation from '@material/dialog/foundation.js';\nimport {applyPassive} from '@material/dom/events.js';\nimport {closest, matches} from '@material/dom/ponyfill.js';\nimport {addHasRemoveClass, BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {DocumentWithBlockingElements} from 'blocking-elements';\nimport {html} from 'lit';\nimport {property, query} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nexport {MDCDialogCloseEventDetail} from '@material/dialog/types.js';\n\nconst blockingElements =\n    (document as DocumentWithBlockingElements).$blockingElements;\n\nexport class DialogBase extends BaseElement {\n  @query('.mdc-dialog') protected mdcRoot!: HTMLDivElement;\n\n  // _actionItemsSlot should have type HTMLSlotElement, but when TypeScript's\n  // emitDecoratorMetadata is enabled, the HTMLSlotElement constructor will\n  // be emitted into the runtime, which will cause an \"HTMLSlotElement is\n  // undefined\" error in browsers that don't define it (e.g. IE11).\n  @query('slot[name=\"primaryAction\"]') protected primarySlot!: HTMLElement;\n\n  // _actionItemsSlot should have type HTMLSlotElement, but when TypeScript's\n  // emitDecoratorMetadata is enabled, the HTMLSlotElement constructor will\n  // be emitted into the runtime, which will cause an \"HTMLSlotElement is\n  // undefined\" error in browsers that don't define it (e.g. IE11).\n  @query('slot[name=\"secondaryAction\"]') protected secondarySlot!: HTMLElement;\n\n  @query('#contentSlot') protected contentSlot!: HTMLElement;\n\n  @query('.mdc-dialog__content') protected contentElement!: HTMLDivElement;\n\n  @query('.mdc-container') protected conatinerElement!: HTMLDivElement;\n\n  @property({type: Boolean}) hideActions = false;\n\n  @property({type: Boolean})\n  @observer(function(this: DialogBase) {\n    this.forceLayout();\n  })\n  stacked = false;\n\n  @property({type: String}) heading = '';\n\n  @property({type: String})\n  @observer(function(this: DialogBase, newAction: string) {\n    this.mdcFoundation.setScrimClickAction(newAction);\n  })\n  scrimClickAction = 'close';\n\n  @property({type: String})\n  @observer(function(this: DialogBase, newAction: string) {\n    this.mdcFoundation.setEscapeKeyAction(newAction);\n  })\n  escapeKeyAction = 'close';\n\n  @property({type: Boolean, reflect: true})\n  @observer(function(this: DialogBase, isOpen: boolean) {\n    // Check isConnected because we could have been disconnected before first\n    // update. If we're now closed, then we shouldn't start the MDC foundation\n    // opening animation. If we're now closed, then we've already closed the\n    // foundation in disconnectedCallback.\n    if (this.mdcFoundation && this.isConnected) {\n      if (isOpen) {\n        this.setEventListeners();\n        this.mdcFoundation.open();\n      } else {\n        this.removeEventListeners();\n        this.mdcFoundation.close(this.currentAction || this.defaultAction);\n        this.currentAction = undefined;\n      }\n    }\n  })\n  open = false;\n\n  @property() defaultAction = 'close';\n  @property() actionAttribute = 'dialogAction';\n  @property() initialFocusAttribute = 'dialogInitialFocus';\n\n  set suppressDefaultPressSelector(selector: string) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setSuppressDefaultPressSelector(selector);\n    } else {\n      this.initialSupressDefaultPressSelector = selector;\n    }\n  }\n\n  /**\n   * @export\n   */\n  get suppressDefaultPressSelector(): string {\n    return this.mdcFoundation ?\n        this.mdcFoundation.getSuppressDefaultPressSelector() :\n        this.initialSupressDefaultPressSelector;\n  }\n\n  protected closingDueToDisconnect?: boolean;\n  protected initialSupressDefaultPressSelector = '';\n\n  protected get primaryButton(): HTMLElement|null {\n    let assignedNodes = (this.primarySlot as HTMLSlotElement).assignedNodes();\n    assignedNodes = assignedNodes.filter((node) => node instanceof HTMLElement);\n    const button = assignedNodes[0] as HTMLElement | undefined;\n    return button ? button : null;\n  }\n\n  protected currentAction: string|undefined;\n  protected mdcFoundationClass = MDCDialogFoundation;\n  protected mdcFoundation!: MDCDialogFoundation;\n  protected boundHandleClick: ((ev: MouseEvent) => void)|null = null;\n  protected boundHandleKeydown: ((ev: KeyboardEvent) => void)|null = null;\n  protected boundHandleDocumentKeydown:\n      ((ev: KeyboardEvent) => void)|null = null;\n\n  protected emitNotification(name: string, action?: string) {\n    const init: CustomEventInit = {detail: action ? {action} : {}};\n    const ev = new CustomEvent(name, init);\n    this.dispatchEvent(ev);\n  }\n\n  protected getInitialFocusEl(): HTMLElement|null {\n    const initFocusSelector = `[${this.initialFocusAttribute}]`;\n\n    // only search light DOM. This typically handles all the cases\n    const lightDomQs = this.querySelector(initFocusSelector);\n\n    if (lightDomQs) {\n      return lightDomQs as HTMLElement;\n    }\n\n    // if not in light dom, search each flattened distributed node.\n    const primarySlot = this.primarySlot as HTMLSlotElement;\n    const primaryNodes = primarySlot.assignedNodes({flatten: true});\n    const primaryFocusElement = this.searchNodeTreesForAttribute(\n        primaryNodes, this.initialFocusAttribute);\n    if (primaryFocusElement) {\n      return primaryFocusElement;\n    }\n\n    const secondarySlot = this.secondarySlot as HTMLSlotElement;\n    const secondaryNodes = secondarySlot.assignedNodes({flatten: true});\n    const secondaryFocusElement = this.searchNodeTreesForAttribute(\n        secondaryNodes, this.initialFocusAttribute);\n    if (secondaryFocusElement) {\n      return secondaryFocusElement;\n    }\n\n\n    const contentSlot = this.contentSlot as HTMLSlotElement;\n    const contentNodes = contentSlot.assignedNodes({flatten: true});\n    const initFocusElement = this.searchNodeTreesForAttribute(\n        contentNodes, this.initialFocusAttribute);\n    return initFocusElement;\n  }\n\n  protected searchNodeTreesForAttribute(nodes: Node[], attribute: string):\n      HTMLElement|null {\n    for (const node of nodes) {\n      if (!(node instanceof HTMLElement)) {\n        continue;\n      }\n\n      if (node.hasAttribute(attribute)) {\n        return node;\n      } else {\n        const selection = node.querySelector(`[${attribute}]`);\n        if (selection) {\n          return selection as HTMLElement;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  protected createAdapter(): MDCDialogAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      addBodyClass: () => document.body.style.overflow = 'hidden',\n      removeBodyClass: () => document.body.style.overflow = '',\n      areButtonsStacked: () => this.stacked,\n      clickDefaultButton: () => {\n        const primary = this.primaryButton;\n        if (primary) {\n          primary.click();\n        }\n      },\n      eventTargetMatches: (target, selector) =>\n          target ? matches(target as Element, selector) : false,\n      getActionFromEvent: (e: Event) => {\n        if (!e.target) {\n          return '';\n        }\n\n        const element =\n            closest(e.target as Element, `[${this.actionAttribute}]`);\n        const action = element && element.getAttribute(this.actionAttribute);\n        return action;\n      },\n      getInitialFocusEl: () => {\n        return this.getInitialFocusEl();\n      },\n      isContentScrollable: () => {\n        const el = this.contentElement;\n        return el ? el.scrollHeight > el.offsetHeight : false;\n      },\n      notifyClosed: (action) => this.emitNotification('closed', action),\n      notifyClosing: (action) => {\n        if (!this.closingDueToDisconnect) {\n          // Don't set our open state to closed just because we were\n          // disconnected. That way if we get reconnected, we'll know to\n          // re-open.\n          this.open = false;\n        }\n        this.emitNotification('closing', action);\n      },\n      notifyOpened: () => this.emitNotification('opened'),\n      notifyOpening: () => {\n        this.open = true;\n        this.emitNotification('opening');\n      },\n      reverseButtons: () => { /* handled by render fn */ },\n      releaseFocus: () => {\n        blockingElements.remove(this);\n      },\n      trapFocus: (el) => {\n        if (!this.isConnected) {\n          // this is the case where it is opened and closed and then removed\n          // from DOM before the animation has completed. Blocking Elements will\n          // throw if this is the case\n          return;\n        }\n        blockingElements.push(this);\n\n        if (el) {\n          el.focus();\n        }\n      },\n      registerContentEventHandler: (evtType, handler) => {\n        const el = this.contentElement;\n        el.addEventListener(evtType, handler);\n      },\n      deregisterContentEventHandler: (evtType, handler) => {\n        const el = this.contentElement;\n        el.removeEventListener(evtType, handler);\n      },\n      isScrollableContentAtTop: () => {\n        const el = this.contentElement;\n        return el ? el.scrollTop === 0 : false;\n      },\n      isScrollableContentAtBottom: () => {\n        const el = this.contentElement;\n        return el ?\n            Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight :\n            false;\n      },\n      registerWindowEventHandler: (evtType, handler) => {\n        window.addEventListener(evtType, handler, applyPassive());\n      },\n      deregisterWindowEventHandler: (evtType, handler) => {\n        window.removeEventListener(evtType, handler, applyPassive());\n      },\n\n    };\n  }\n\n  protected override render() {\n    const classes = {\n      [cssClasses.STACKED]: this.stacked,\n    };\n\n    let heading = html``;\n\n    if (this.heading) {\n      heading = this.renderHeading();\n    }\n\n    const actionsClasses = {\n      'mdc-dialog__actions': !this.hideActions,\n    };\n\n    return html`\n    <div class=\"mdc-dialog ${classMap(classes)}\"\n        role=\"alertdialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"title\"\n        aria-describedby=\"content\">\n      <div class=\"mdc-dialog__container\">\n        <div class=\"mdc-dialog__surface\">\n          ${heading}\n          <div id=\"content\" class=\"mdc-dialog__content\">\n            <slot id=\"contentSlot\"></slot>\n          </div>\n          <footer\n              id=\"actions\"\n              class=\"${classMap(actionsClasses)}\">\n            <span>\n              <slot name=\"secondaryAction\"></slot>\n            </span>\n            <span>\n             <slot name=\"primaryAction\"></slot>\n            </span>\n          </footer>\n        </div>\n      </div>\n      <div class=\"mdc-dialog__scrim\"></div>\n    </div>`;\n  }\n\n  protected renderHeading() {\n    return html`\n      <h2 id=\"title\" class=\"mdc-dialog__title\">${this.heading}</h2>`;\n  }\n\n  protected override firstUpdated() {\n    super.firstUpdated();\n    this.mdcFoundation.setAutoStackButtons(true);\n    if (this.initialSupressDefaultPressSelector) {\n      this.suppressDefaultPressSelector =\n          this.initialSupressDefaultPressSelector;\n    } else {\n      this.suppressDefaultPressSelector = [\n        this.suppressDefaultPressSelector, 'mwc-textarea',\n        'mwc-menu mwc-list-item', 'mwc-select mwc-list-item'\n      ].join(', ');\n    }\n    this.boundHandleClick = this.mdcFoundation.handleClick.bind(\n                                this.mdcFoundation) as EventListener;\n    this.boundHandleKeydown = this.mdcFoundation.handleKeydown.bind(\n                                  this.mdcFoundation) as EventListener;\n    this.boundHandleDocumentKeydown =\n        this.mdcFoundation.handleDocumentKeydown.bind(this.mdcFoundation) as\n        EventListener;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    if (this.open && this.mdcFoundation && !this.mdcFoundation.isOpen()) {\n      // We probably got disconnected while we were still open. Re-open,\n      // matching the behavior of native <dialog>.\n      this.setEventListeners();\n      this.mdcFoundation.open();\n    }\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n    if (this.open && this.mdcFoundation) {\n      // If this dialog is opened and then disconnected, we want to close\n      // the foundation, so that 1) any pending timers are cancelled\n      // (in particular for trapFocus), and 2) if we reconnect, we can open\n      // the foundation again to retrigger animations and focus.\n      this.removeEventListeners();\n      this.closingDueToDisconnect = true;\n      this.mdcFoundation.close(this.currentAction || this.defaultAction);\n      this.closingDueToDisconnect = false;\n      this.currentAction = undefined;\n\n      // When we close normally, the releaseFocus callback handles removing\n      // ourselves from the blocking elements stack. However, that callback\n      // happens on a delay, and when we are closing due to a disconnect we\n      // need to remove ourselves before the blocking element polyfill's\n      // mutation observer notices and logs a warning, since it's not valid to\n      // be in the blocking elements stack while disconnected.\n      blockingElements.remove(this);\n    }\n  }\n\n  forceLayout() {\n    this.mdcFoundation.layout();\n  }\n\n  override focus() {\n    const initialFocusEl = this.getInitialFocusEl();\n    initialFocusEl && initialFocusEl.focus();\n  }\n\n  override blur() {\n    if (!this.shadowRoot) {\n      return;\n    }\n\n    const activeEl = this.shadowRoot.activeElement;\n    if (activeEl) {\n      if (activeEl instanceof HTMLElement) {\n        activeEl.blur();\n      }\n    } else {\n      const root = this.getRootNode();\n      const activeEl = root instanceof Document ? root.activeElement : null;\n      if (activeEl instanceof HTMLElement) {\n        activeEl.blur();\n      }\n    }\n  }\n\n  protected setEventListeners() {\n    if (this.boundHandleClick) {\n      this.mdcRoot.addEventListener('click', this.boundHandleClick);\n    }\n    if (this.boundHandleKeydown) {\n      this.mdcRoot.addEventListener(\n          'keydown', this.boundHandleKeydown, applyPassive());\n    }\n    if (this.boundHandleDocumentKeydown) {\n      document.addEventListener(\n          'keydown', this.boundHandleDocumentKeydown, applyPassive());\n    }\n  }\n\n  protected removeEventListeners() {\n    if (this.boundHandleClick) {\n      this.mdcRoot.removeEventListener('click', this.boundHandleClick);\n    }\n\n    if (this.boundHandleKeydown) {\n      this.mdcRoot.removeEventListener('keydown', this.boundHandleKeydown);\n    }\n\n    if (this.boundHandleDocumentKeydown) {\n      document.removeEventListener('keydown', this.boundHandleDocumentKeydown);\n    }\n  }\n\n  close() {\n    this.open = false;\n  }\n\n  show() {\n    this.open = true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}