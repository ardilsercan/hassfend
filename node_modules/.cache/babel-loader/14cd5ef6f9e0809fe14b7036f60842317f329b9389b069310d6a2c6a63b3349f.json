{"ast":null,"code":"import { BINARY_STATE_OFF, BINARY_STATE_ON, DOMAINS_WITH_DYNAMIC_PICTURE } from \"../common/const\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../common/entity/compute_state_domain\";\nimport { autoCaseNoun } from \"../common/translations/auto_case_noun\";\nimport { UNAVAILABLE, UNKNOWN } from \"./entity\";\nconst LOGBOOK_LOCALIZE_PATH = \"ui.components.logbook.messages\";\nexport const CONTINUOUS_DOMAINS = [\"counter\", \"proximity\", \"sensor\", \"zone\"];\n//\n// Localization mapping for all the triggers in core\n// in homeassistant.components.homeassistant.triggers\n//\nconst triggerPhrases = {\n  \"numeric state of\": \"triggered_by_numeric_state_of\",\n  // number state trigger\n  \"state of\": \"triggered_by_state_of\",\n  // state trigger\n  event: \"triggered_by_event\",\n  // event trigger\n  time: \"triggered_by_time\",\n  // time trigger\n  \"time pattern\": \"triggered_by_time_pattern\",\n  // time trigger\n  \"Home Assistant stopping\": \"triggered_by_homeassistant_stopping\",\n  // stop event\n  \"Home Assistant starting\": \"triggered_by_homeassistant_starting\" // start event\n};\nexport const getLogbookDataForContext = async (hass, startDate, contextId) => getLogbookDataFromServer(hass, startDate, undefined, undefined, contextId);\nconst getLogbookDataFromServer = (hass, startDate, endDate, entityIds, contextId, deviceIds) => {\n  // If all specified filters are empty lists, we can return an empty list.\n  if ((entityIds || deviceIds) && (!entityIds || entityIds.length === 0) && (!deviceIds || deviceIds.length === 0)) {\n    return Promise.resolve([]);\n  }\n  const params = {\n    type: \"logbook/get_events\",\n    start_time: startDate\n  };\n  if (endDate) {\n    params.end_time = endDate;\n  }\n  if (entityIds !== null && entityIds !== void 0 && entityIds.length) {\n    params.entity_ids = entityIds;\n  }\n  if (deviceIds !== null && deviceIds !== void 0 && deviceIds.length) {\n    params.device_ids = deviceIds;\n  }\n  if (contextId) {\n    params.context_id = contextId;\n  }\n  return hass.callWS(params);\n};\nexport const subscribeLogbook = (hass, callbackFunction, startDate, endDate, entityIds, deviceIds) => {\n  // If all specified filters are empty lists, we can return an empty list.\n  if ((entityIds || deviceIds) && (!entityIds || entityIds.length === 0) && (!deviceIds || deviceIds.length === 0)) {\n    return Promise.reject(\"No entities or devices\");\n  }\n  const params = {\n    type: \"logbook/event_stream\",\n    start_time: startDate,\n    end_time: endDate\n  };\n  if (entityIds !== null && entityIds !== void 0 && entityIds.length) {\n    params.entity_ids = entityIds;\n  }\n  if (deviceIds !== null && deviceIds !== void 0 && deviceIds.length) {\n    params.device_ids = deviceIds;\n  }\n  return hass.connection.subscribeMessage(message => callbackFunction(message), params);\n};\nexport const createHistoricState = (currentStateObj, state) => ({\n  entity_id: currentStateObj.entity_id,\n  state: state,\n  attributes: {\n    // Rebuild the historical state by copying static attributes only\n    device_class: currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.device_class,\n    source_type: currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.source_type,\n    has_date: currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.has_date,\n    has_time: currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.has_time,\n    // We do not want to use dynamic entity pictures (e.g., from media player) for the log book rendering,\n    // as they would present a false state in the log (played media right now vs actual historic data).\n    entity_picture_local: DOMAINS_WITH_DYNAMIC_PICTURE.has(computeDomain(currentStateObj.entity_id)) ? undefined : currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.entity_picture_local,\n    entity_picture: DOMAINS_WITH_DYNAMIC_PICTURE.has(computeDomain(currentStateObj.entity_id)) ? undefined : currentStateObj === null || currentStateObj === void 0 ? void 0 : currentStateObj.attributes.entity_picture\n  }\n});\nexport const localizeTriggerSource = (localize, source) => {\n  for (const triggerPhrase in triggerPhrases) {\n    if (source.startsWith(triggerPhrase)) {\n      return source.replace(triggerPhrase, `${localize(`ui.components.logbook.${triggerPhrases[triggerPhrase]}`)}`);\n    }\n  }\n  return source;\n};\nexport const localizeStateMessage = (hass, localize, state, stateObj, domain) => {\n  switch (domain) {\n    case \"device_tracker\":\n    case \"person\":\n      if (state === \"not_home\") {\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.was_away`);\n      }\n      if (state === \"home\") {\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_home`);\n      }\n      return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_state`, {\n        state\n      });\n    case \"sun\":\n      return state === \"above_horizon\" ? localize(`${LOGBOOK_LOCALIZE_PATH}.rose`) : localize(`${LOGBOOK_LOCALIZE_PATH}.set`);\n    case \"binary_sensor\":\n      {\n        const isOn = state === BINARY_STATE_ON;\n        const isOff = state === BINARY_STATE_OFF;\n        const device_class = stateObj.attributes.device_class;\n        switch (device_class) {\n          case \"battery\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_low`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_normal`);\n            }\n            break;\n          case \"connectivity\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_connected`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_disconnected`);\n            }\n            break;\n          case \"door\":\n          case \"garage_door\":\n          case \"opening\":\n          case \"window\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_opened`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_closed`);\n            }\n            break;\n          case \"lock\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unlocked`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_locked`);\n            }\n            break;\n          case \"plug\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_plugged_in`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unplugged`);\n            }\n            break;\n          case \"presence\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_home`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_away`);\n            }\n            break;\n          case \"safety\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unsafe`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.was_safe`);\n            }\n            break;\n          case \"cold\":\n          case \"gas\":\n          case \"heat\":\n          case \"moisture\":\n          case \"motion\":\n          case \"occupancy\":\n          case \"power\":\n          case \"problem\":\n          case \"smoke\":\n          case \"sound\":\n          case \"vibration\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_device_class`, {\n                device_class: autoCaseNoun(localize(`component.binary_sensor.entity_component.${device_class}.name`), hass.language)\n              });\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.cleared_device_class`, {\n                device_class: autoCaseNoun(localize(`component.binary_sensor.entity_component.${device_class}.name`), hass.language)\n              });\n            }\n            break;\n          case \"tamper\":\n            if (isOn) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_tampering`);\n            }\n            if (isOff) {\n              return localize(`${LOGBOOK_LOCALIZE_PATH}.cleared_tampering`);\n            }\n            break;\n        }\n        break;\n      }\n    case \"cover\":\n      switch (state) {\n        case \"open\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_opened`);\n        case \"opening\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_opening`);\n        case \"closing\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_closing`);\n        case \"closed\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_closed`);\n      }\n      break;\n    case \"event\":\n      {\n        var _hass$formatEntityAtt;\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_event_no_type`);\n\n        // TODO: This is not working yet, as we don't get historic attribute values\n\n        const event_type = (_hass$formatEntityAtt = hass.formatEntityAttributeValue(stateObj, \"event_type\")) === null || _hass$formatEntityAtt === void 0 ? void 0 : _hass$formatEntityAtt.toString();\n        if (!event_type) {\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_unknown_event`);\n        }\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_event`, {\n          event_type: autoCaseNoun(event_type, hass.language)\n        });\n      }\n    case \"lock\":\n      switch (state) {\n        case \"unlocked\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unlocked`);\n        case \"locking\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_locking`);\n        case \"unlocking\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_unlocking`);\n        case \"locked\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_locked`);\n        case \"jammed\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_jammed`);\n      }\n      break;\n  }\n  if (state === BINARY_STATE_ON) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.turned_on`);\n  }\n  if (state === BINARY_STATE_OFF) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.turned_off`);\n  }\n  if (state === UNKNOWN) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.became_unknown`);\n  }\n  if (state === UNAVAILABLE) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.became_unavailable`);\n  }\n  return hass.localize(`${LOGBOOK_LOCALIZE_PATH}.changed_to_state`, {\n    state: stateObj ? hass.formatEntityState(stateObj, state) : state\n  });\n};\nexport const filterLogbookCompatibleEntities = entity => computeStateDomain(entity) !== \"sensor\" || entity.attributes.unit_of_measurement === undefined && entity.attributes.state_class === undefined;","map":{"version":3,"names":["BINARY_STATE_OFF","BINARY_STATE_ON","DOMAINS_WITH_DYNAMIC_PICTURE","computeDomain","computeStateDomain","autoCaseNoun","UNAVAILABLE","UNKNOWN","LOGBOOK_LOCALIZE_PATH","CONTINUOUS_DOMAINS","triggerPhrases","event","time","getLogbookDataForContext","hass","startDate","contextId","getLogbookDataFromServer","undefined","endDate","entityIds","deviceIds","length","Promise","resolve","params","type","start_time","end_time","entity_ids","device_ids","context_id","callWS","subscribeLogbook","callbackFunction","reject","connection","subscribeMessage","message","createHistoricState","currentStateObj","state","entity_id","attributes","device_class","source_type","has_date","has_time","entity_picture_local","has","entity_picture","localizeTriggerSource","localize","source","triggerPhrase","startsWith","replace","localizeStateMessage","stateObj","domain","isOn","isOff","language","_hass$formatEntityAtt","event_type","formatEntityAttributeValue","toString","formatEntityState","filterLogbookCompatibleEntities","entity","unit_of_measurement","state_class"],"sources":["/Users/sercanardil/Desktop/frontend/src/data/logbook.ts"],"sourcesContent":["import { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  BINARY_STATE_OFF,\n  BINARY_STATE_ON,\n  DOMAINS_WITH_DYNAMIC_PICTURE,\n} from \"../common/const\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDomain } from \"../common/entity/compute_state_domain\";\nimport { autoCaseNoun } from \"../common/translations/auto_case_noun\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { HaEntityPickerEntityFilterFunc } from \"../components/entity/ha-entity-picker\";\nimport { HomeAssistant } from \"../types\";\nimport { UNAVAILABLE, UNKNOWN } from \"./entity\";\n\nconst LOGBOOK_LOCALIZE_PATH = \"ui.components.logbook.messages\";\nexport const CONTINUOUS_DOMAINS = [\"counter\", \"proximity\", \"sensor\", \"zone\"];\n\nexport interface LogbookStreamMessage {\n  events: LogbookEntry[];\n  start_time?: number; // Start time of this historical chunk\n  end_time?: number; // End time of this historical chunk\n  partial?: boolean; // Indiciates more historical chunks are coming\n}\n\nexport interface LogbookEntry {\n  // Base data\n  when: number; // Python timestamp. Do *1000 to get JS timestamp.\n  name: string;\n  message?: string;\n  entity_id?: string;\n  icon?: string;\n  source?: string; // The trigger source\n  domain?: string;\n  state?: string; // The state of the entity\n  // Context data\n  context_id?: string;\n  context_user_id?: string;\n  context_event_type?: string;\n  context_domain?: string;\n  context_service?: string; // Service calls only\n  context_entity_id?: string;\n  context_entity_id_name?: string; // Legacy, not longer sent\n  context_name?: string;\n  context_state?: string; // The state of the entity\n  context_source?: string; // The trigger source\n  context_message?: string;\n}\n\n//\n// Localization mapping for all the triggers in core\n// in homeassistant.components.homeassistant.triggers\n//\nconst triggerPhrases = {\n  \"numeric state of\": \"triggered_by_numeric_state_of\", // number state trigger\n  \"state of\": \"triggered_by_state_of\", // state trigger\n  event: \"triggered_by_event\", // event trigger\n  time: \"triggered_by_time\", // time trigger\n  \"time pattern\": \"triggered_by_time_pattern\", // time trigger\n  \"Home Assistant stopping\": \"triggered_by_homeassistant_stopping\", // stop event\n  \"Home Assistant starting\": \"triggered_by_homeassistant_starting\", // start event\n};\n\nexport const getLogbookDataForContext = async (\n  hass: HomeAssistant,\n  startDate: string,\n  contextId?: string\n): Promise<LogbookEntry[]> =>\n  getLogbookDataFromServer(hass, startDate, undefined, undefined, contextId);\n\nconst getLogbookDataFromServer = (\n  hass: HomeAssistant,\n  startDate: string,\n  endDate?: string,\n  entityIds?: string[],\n  contextId?: string,\n  deviceIds?: string[]\n): Promise<LogbookEntry[]> => {\n  // If all specified filters are empty lists, we can return an empty list.\n  if (\n    (entityIds || deviceIds) &&\n    (!entityIds || entityIds.length === 0) &&\n    (!deviceIds || deviceIds.length === 0)\n  ) {\n    return Promise.resolve([]);\n  }\n\n  const params: any = {\n    type: \"logbook/get_events\",\n    start_time: startDate,\n  };\n  if (endDate) {\n    params.end_time = endDate;\n  }\n  if (entityIds?.length) {\n    params.entity_ids = entityIds;\n  }\n  if (deviceIds?.length) {\n    params.device_ids = deviceIds;\n  }\n  if (contextId) {\n    params.context_id = contextId;\n  }\n  return hass.callWS<LogbookEntry[]>(params);\n};\n\nexport const subscribeLogbook = (\n  hass: HomeAssistant,\n  callbackFunction: (message: LogbookStreamMessage) => void,\n  startDate: string,\n  endDate: string,\n  entityIds?: string[],\n  deviceIds?: string[]\n): Promise<() => Promise<void>> => {\n  // If all specified filters are empty lists, we can return an empty list.\n  if (\n    (entityIds || deviceIds) &&\n    (!entityIds || entityIds.length === 0) &&\n    (!deviceIds || deviceIds.length === 0)\n  ) {\n    return Promise.reject(\"No entities or devices\");\n  }\n  const params: any = {\n    type: \"logbook/event_stream\",\n    start_time: startDate,\n    end_time: endDate,\n  };\n  if (entityIds?.length) {\n    params.entity_ids = entityIds;\n  }\n  if (deviceIds?.length) {\n    params.device_ids = deviceIds;\n  }\n  return hass.connection.subscribeMessage<LogbookStreamMessage>(\n    (message) => callbackFunction(message),\n    params\n  );\n};\n\nexport const createHistoricState = (\n  currentStateObj: HassEntity,\n  state?: string\n): HassEntity => <HassEntity>(<unknown>{\n    entity_id: currentStateObj.entity_id,\n    state: state,\n    attributes: {\n      // Rebuild the historical state by copying static attributes only\n      device_class: currentStateObj?.attributes.device_class,\n      source_type: currentStateObj?.attributes.source_type,\n      has_date: currentStateObj?.attributes.has_date,\n      has_time: currentStateObj?.attributes.has_time,\n      // We do not want to use dynamic entity pictures (e.g., from media player) for the log book rendering,\n      // as they would present a false state in the log (played media right now vs actual historic data).\n      entity_picture_local: DOMAINS_WITH_DYNAMIC_PICTURE.has(\n        computeDomain(currentStateObj.entity_id)\n      )\n        ? undefined\n        : currentStateObj?.attributes.entity_picture_local,\n      entity_picture: DOMAINS_WITH_DYNAMIC_PICTURE.has(\n        computeDomain(currentStateObj.entity_id)\n      )\n        ? undefined\n        : currentStateObj?.attributes.entity_picture,\n    },\n  });\n\nexport const localizeTriggerSource = (\n  localize: LocalizeFunc,\n  source: string\n) => {\n  for (const triggerPhrase in triggerPhrases) {\n    if (source.startsWith(triggerPhrase)) {\n      return source.replace(\n        triggerPhrase,\n        `${localize(`ui.components.logbook.${triggerPhrases[triggerPhrase]}`)}`\n      );\n    }\n  }\n  return source;\n};\n\nexport const localizeStateMessage = (\n  hass: HomeAssistant,\n  localize: LocalizeFunc,\n  state: string,\n  stateObj: HassEntity,\n  domain: string\n): string => {\n  switch (domain) {\n    case \"device_tracker\":\n    case \"person\":\n      if (state === \"not_home\") {\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.was_away`);\n      }\n      if (state === \"home\") {\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_home`);\n      }\n      return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_state`, { state });\n\n    case \"sun\":\n      return state === \"above_horizon\"\n        ? localize(`${LOGBOOK_LOCALIZE_PATH}.rose`)\n        : localize(`${LOGBOOK_LOCALIZE_PATH}.set`);\n\n    case \"binary_sensor\": {\n      const isOn = state === BINARY_STATE_ON;\n      const isOff = state === BINARY_STATE_OFF;\n      const device_class = stateObj.attributes.device_class;\n\n      switch (device_class) {\n        case \"battery\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_low`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_normal`);\n          }\n          break;\n\n        case \"connectivity\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_connected`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_disconnected`);\n          }\n          break;\n\n        case \"door\":\n        case \"garage_door\":\n        case \"opening\":\n        case \"window\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_opened`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_closed`);\n          }\n          break;\n\n        case \"lock\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unlocked`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_locked`);\n          }\n          break;\n\n        case \"plug\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_plugged_in`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unplugged`);\n          }\n          break;\n\n        case \"presence\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_at_home`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_away`);\n          }\n          break;\n\n        case \"safety\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unsafe`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.was_safe`);\n          }\n          break;\n\n        case \"cold\":\n        case \"gas\":\n        case \"heat\":\n        case \"moisture\":\n        case \"motion\":\n        case \"occupancy\":\n        case \"power\":\n        case \"problem\":\n        case \"smoke\":\n        case \"sound\":\n        case \"vibration\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_device_class`, {\n              device_class: autoCaseNoun(\n                localize(\n                  `component.binary_sensor.entity_component.${device_class}.name`\n                ),\n                hass.language\n              ),\n            });\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.cleared_device_class`, {\n              device_class: autoCaseNoun(\n                localize(\n                  `component.binary_sensor.entity_component.${device_class}.name`\n                ),\n                hass.language\n              ),\n            });\n          }\n          break;\n\n        case \"tamper\":\n          if (isOn) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_tampering`);\n          }\n          if (isOff) {\n            return localize(`${LOGBOOK_LOCALIZE_PATH}.cleared_tampering`);\n          }\n          break;\n      }\n\n      break;\n    }\n\n    case \"cover\":\n      switch (state) {\n        case \"open\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_opened`);\n        case \"opening\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_opening`);\n        case \"closing\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_closing`);\n        case \"closed\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_closed`);\n      }\n      break;\n\n    case \"event\": {\n      return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_event_no_type`);\n\n      // TODO: This is not working yet, as we don't get historic attribute values\n\n      const event_type = hass\n        .formatEntityAttributeValue(stateObj, \"event_type\")\n        ?.toString();\n\n      if (!event_type) {\n        return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_unknown_event`);\n      }\n\n      return localize(`${LOGBOOK_LOCALIZE_PATH}.detected_event`, {\n        event_type: autoCaseNoun(event_type, hass.language),\n      });\n    }\n\n    case \"lock\":\n      switch (state) {\n        case \"unlocked\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_unlocked`);\n        case \"locking\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_locking`);\n        case \"unlocking\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_unlocking`);\n        case \"locked\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.was_locked`);\n        case \"jammed\":\n          return localize(`${LOGBOOK_LOCALIZE_PATH}.is_jammed`);\n      }\n      break;\n  }\n\n  if (state === BINARY_STATE_ON) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.turned_on`);\n  }\n\n  if (state === BINARY_STATE_OFF) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.turned_off`);\n  }\n\n  if (state === UNKNOWN) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.became_unknown`);\n  }\n\n  if (state === UNAVAILABLE) {\n    return localize(`${LOGBOOK_LOCALIZE_PATH}.became_unavailable`);\n  }\n\n  return hass.localize(`${LOGBOOK_LOCALIZE_PATH}.changed_to_state`, {\n    state: stateObj ? hass.formatEntityState(stateObj, state) : state,\n  });\n};\n\nexport const filterLogbookCompatibleEntities: HaEntityPickerEntityFilterFunc = (\n  entity\n) =>\n  computeStateDomain(entity) !== \"sensor\" ||\n  (entity.attributes.unit_of_measurement === undefined &&\n    entity.attributes.state_class === undefined);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}