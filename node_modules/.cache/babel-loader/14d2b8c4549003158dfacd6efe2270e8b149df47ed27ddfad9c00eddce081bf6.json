{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport './mixin.js';\nimport './async.js';\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport var Debouncer = /*#__PURE__*/function () {\n  function Debouncer() {\n    _classCallCheck(this, Debouncer);\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  _createClass(Debouncer, [{\n    key: \"setConfig\",\n    value: function setConfig(asyncModule, callback) {\n      var _this = this;\n      this._asyncModule = asyncModule;\n      this._callback = callback;\n      this._timer = this._asyncModule.run(function () {\n        _this._timer = null;\n        debouncerQueue.delete(_this);\n        _this._callback();\n      });\n    }\n    /**\n     * Cancels an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.isActive()) {\n        this._cancelAsync();\n        // Canceling a debouncer removes its spot from the flush queue,\n        // so if a debouncer is manually canceled and re-debounced, it\n        // will reset its flush order (this is a very minor difference from 1.x)\n        // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n        debouncerQueue.delete(this);\n      }\n    }\n    /**\n     * Cancels a debouncer's async callback.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"_cancelAsync\",\n    value: function _cancelAsync() {\n      if (this.isActive()) {\n        this._asyncModule.cancel( /** @type {number} */this._timer);\n        this._timer = null;\n      }\n    }\n    /**\n     * Flushes an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.isActive()) {\n        this.cancel();\n        this._callback();\n      }\n    }\n    /**\n     * Returns true if the debouncer is active.\n     *\n     * @return {boolean} True if active.\n     */\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this._timer != null;\n    }\n    /**\n     * Creates a debouncer if no debouncer is passed as a parameter\n     * or it cancels an active debouncer otherwise. The following\n     * example shows how a debouncer can be called multiple times within a\n     * microtask and \"debounced\" such that the provided callback function is\n     * called once. Add this method to a custom element:\n     *\n     * ```js\n     * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n     * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n     * // ...\n     *\n     * _debounceWork() {\n     *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n     *       microTask, () => this._doWork());\n     * }\n     * ```\n     *\n     * If the `_debounceWork` method is called multiple times within the same\n     * microtask, the `_doWork` function will be called only once at the next\n     * microtask checkpoint.\n     *\n     * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n     * this with a debouncer, you can use `enqueueDebouncer` and\n     * `flush`. For example, extend the above example by adding\n     * `enqueueDebouncer(this._debounceJob)` at the end of the\n     * `_debounceWork` method. Then in a test, call `flush` to ensure\n     * the debouncer has completed.\n     *\n     * @param {Debouncer?} debouncer Debouncer object.\n     * @param {!AsyncInterface} asyncModule Object with Async interface\n     * @param {function()} callback Callback to run.\n     * @return {!Debouncer} Returns a debouncer object.\n     */\n  }], [{\n    key: \"debounce\",\n    value: function debounce(debouncer, asyncModule, callback) {\n      if (debouncer instanceof Debouncer) {\n        // Cancel the async callback, but leave in debouncerQueue if it was\n        // enqueued, to maintain 1.x flush order\n        debouncer._cancelAsync();\n      } else {\n        debouncer = new Debouncer();\n      }\n      debouncer.setConfig(asyncModule, callback);\n      return debouncer;\n    }\n  }]);\n  return Debouncer;\n}();\nvar debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport var enqueueDebouncer = function enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n};\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport var flushDebouncers = function flushDebouncers() {\n  var didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(function (debouncer) {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(function () {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};","map":{"version":3,"names":["Debouncer","_classCallCheck","_asyncModule","_callback","_timer","_createClass","key","value","setConfig","asyncModule","callback","_this","run","debouncerQueue","delete","cancel","isActive","_cancelAsync","flush","debounce","debouncer","Set","enqueueDebouncer","add","flushDebouncers","didFlush","Boolean","size","forEach","e","setTimeout"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/utils/debounce.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\n\nimport './mixin.js';\nimport './async.js';\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(/** @type {number} */(this._timer));\n      this._timer = null;\n    }\n  }\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@polymer/polymer/lib/utils/async.js';\n   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n}\n\nlet debouncerQueue = new Set();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport const enqueueDebouncer = function(debouncer) {\n  debouncerQueue.add(debouncer);\n};\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport const flushDebouncers = function() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(debouncer => {\n    try {\n      debouncer.flush();\n    } catch(e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}