{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\n/**\n * A ReactiveController which adds context consuming behavior to a custom\n * element by dispatching `context-request` events.\n *\n * When the host element is connected to the document it will emit a\n * `context-request` event with its context key. When the context request\n * is satisfied the controller will invoke the callback, if present, and\n * trigger a host update so it can respond to the new value.\n *\n * It will also call the dispose method given by the provider when the\n * host element is disconnected.\n */\nexport var ContextConsumer = /*#__PURE__*/function () {\n  function ContextConsumer(host, contextOrOptions, callback, subscribe) {\n    var _this = this;\n    _classCallCheck(this, ContextConsumer);\n    var _a;\n    this.subscribe = false;\n    this.provided = false;\n    this.value = undefined;\n    // This function must have stable identity to properly dedupe in ContextRoot\n    // if this element connects multiple times.\n    this._callback = function (value, unsubscribe) {\n      // some providers will pass an unsubscribe function indicating they may provide future values\n      if (_this.unsubscribe) {\n        // if the unsubscribe function changes this implies we have changed provider\n        if (_this.unsubscribe !== unsubscribe) {\n          // cleanup the old provider\n          _this.provided = false;\n          _this.unsubscribe();\n        }\n        // if we don't support subscription, immediately unsubscribe\n        if (!_this.subscribe) {\n          _this.unsubscribe();\n        }\n      }\n      // store the value so that it can be retrieved from the controller\n      _this.value = value;\n      // schedule an update in case this value is used in a template\n      _this.host.requestUpdate();\n      // only invoke callback if we are either expecting updates or have not yet\n      // been provided a value\n      if (!_this.provided || _this.subscribe) {\n        _this.provided = true;\n        if (_this.callback) {\n          _this.callback(value, unsubscribe);\n        }\n      }\n      _this.unsubscribe = unsubscribe;\n    };\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if (contextOrOptions.context !== undefined) {\n      var options = contextOrOptions;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = (_a = options.subscribe) !== null && _a !== void 0 ? _a : false;\n    } else {\n      this.context = contextOrOptions;\n      this.callback = callback;\n      this.subscribe = subscribe !== null && subscribe !== void 0 ? subscribe : false;\n    }\n    this.host.addController(this);\n  }\n  _createClass(ContextConsumer, [{\n    key: \"hostConnected\",\n    value: function hostConnected() {\n      this.dispatchRequest();\n    }\n  }, {\n    key: \"hostDisconnected\",\n    value: function hostDisconnected() {\n      if (this.unsubscribe) {\n        this.unsubscribe();\n        this.unsubscribe = undefined;\n      }\n    }\n  }, {\n    key: \"dispatchRequest\",\n    value: function dispatchRequest() {\n      this.host.dispatchEvent(new ContextRequestEvent(this.context, this._callback, this.subscribe));\n    }\n  }]);\n  return ContextConsumer;\n}();","map":{"version":3,"names":["ContextRequestEvent","ContextConsumer","host","contextOrOptions","callback","subscribe","_this","_classCallCheck","provided","value","undefined","_callback","unsubscribe","requestUpdate","context","options","_a","addController","_createClass","key","hostConnected","dispatchRequest","hostDisconnected","dispatchEvent"],"sources":["../../../src/lib/controllers/context-consumer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ContextCallback,\n  ContextRequestEvent,\n} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  subscribe?: boolean;\n}\n\n/**\n * A ReactiveController which adds context consuming behavior to a custom\n * element by dispatching `context-request` events.\n *\n * When the host element is connected to the document it will emit a\n * `context-request` event with its context key. When the context request\n * is satisfied the controller will invoke the callback, if present, and\n * trigger a host update so it can respond to the new value.\n *\n * It will also call the dispose method given by the provider when the\n * host element is disconnected.\n */\nexport class ContextConsumer<\n  C extends Context<unknown, unknown>,\n  HostElement extends ReactiveElement\n> implements ReactiveController\n{\n  protected host: HostElement;\n  private context: C;\n  private callback?: (value: ContextType<C>, dispose?: () => void) => void;\n  private subscribe = false;\n\n  private provided = false;\n\n  value?: ContextType<C> = undefined;\n\n  constructor(host: HostElement, options: Options<C>);\n  /** @deprecated Use new ContextConsumer(host, options) */\n  constructor(\n    host: HostElement,\n    context: C,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  );\n  constructor(\n    host: HostElement,\n    contextOrOptions: C | Options<C>,\n    callback?: (value: ContextType<C>, dispose?: () => void) => void,\n    subscribe?: boolean\n  ) {\n    this.host = host;\n    // This is a potentially fragile duck-type. It means a context object can't\n    // have a property name context and be used in positional argument form.\n    if ((contextOrOptions as Options<C>).context !== undefined) {\n      const options = contextOrOptions as Options<C>;\n      this.context = options.context;\n      this.callback = options.callback;\n      this.subscribe = options.subscribe ?? false;\n    } else {\n      this.context = contextOrOptions as C;\n      this.callback = callback;\n      this.subscribe = subscribe ?? false;\n    }\n    this.host.addController(this);\n  }\n\n  private unsubscribe?: () => void;\n\n  hostConnected(): void {\n    this.dispatchRequest();\n  }\n\n  hostDisconnected(): void {\n    if (this.unsubscribe) {\n      this.unsubscribe();\n      this.unsubscribe = undefined;\n    }\n  }\n\n  private dispatchRequest() {\n    this.host.dispatchEvent(\n      new ContextRequestEvent(this.context, this._callback, this.subscribe)\n    );\n  }\n\n  // This function must have stable identity to properly dedupe in ContextRoot\n  // if this element connects multiple times.\n  private _callback: ContextCallback<ContextType<C>> = (value, unsubscribe) => {\n    // some providers will pass an unsubscribe function indicating they may provide future values\n    if (this.unsubscribe) {\n      // if the unsubscribe function changes this implies we have changed provider\n      if (this.unsubscribe !== unsubscribe) {\n        // cleanup the old provider\n        this.provided = false;\n        this.unsubscribe();\n      }\n      // if we don't support subscription, immediately unsubscribe\n      if (!this.subscribe) {\n        this.unsubscribe();\n      }\n    }\n\n    // store the value so that it can be retrieved from the controller\n    this.value = value;\n    // schedule an update in case this value is used in a template\n    this.host.requestUpdate();\n\n    // only invoke callback if we are either expecting updates or have not yet\n    // been provided a value\n    if (!this.provided || this.subscribe) {\n      this.provided = true;\n      if (this.callback) {\n        this.callback(value, unsubscribe);\n      }\n    }\n\n    this.unsubscribe = unsubscribe;\n  };\n}\n"],"mappings":";;AAAA;;;;;AAMA,SAEEA,mBAAmB,QACd,6BAA6B;AAUpC;;;;;;;;;;;;AAYA,WAAaC,eAAe;EAsB1B,SAAAA,gBACEC,IAAiB,EACjBC,gBAAgC,EAChCC,QAAgE,EAChEC,SAAmB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAN,eAAA;;IAlBb,KAAAI,SAAS,GAAG,KAAK;IAEjB,KAAAG,QAAQ,GAAG,KAAK;IAExB,KAAAC,KAAK,GAAoBC,SAAS;IAmDlC;IACA;IACQ,KAAAC,SAAS,GAAoC,UAACF,KAAK,EAAEG,WAAW,EAAI;MAC1E;MACA,IAAIN,KAAI,CAACM,WAAW,EAAE;QACpB;QACA,IAAIN,KAAI,CAACM,WAAW,KAAKA,WAAW,EAAE;UACpC;UACAN,KAAI,CAACE,QAAQ,GAAG,KAAK;UACrBF,KAAI,CAACM,WAAW,EAAE;;QAEpB;QACA,IAAI,CAACN,KAAI,CAACD,SAAS,EAAE;UACnBC,KAAI,CAACM,WAAW,EAAE;;;MAItB;MACAN,KAAI,CAACG,KAAK,GAAGA,KAAK;MAClB;MACAH,KAAI,CAACJ,IAAI,CAACW,aAAa,EAAE;MAEzB;MACA;MACA,IAAI,CAACP,KAAI,CAACE,QAAQ,IAAIF,KAAI,CAACD,SAAS,EAAE;QACpCC,KAAI,CAACE,QAAQ,GAAG,IAAI;QACpB,IAAIF,KAAI,CAACF,QAAQ,EAAE;UACjBE,KAAI,CAACF,QAAQ,CAACK,KAAK,EAAEG,WAAW,CAAC;;;MAIrCN,KAAI,CAACM,WAAW,GAAGA,WAAW;IAChC,CAAC;IAnEC,IAAI,CAACV,IAAI,GAAGA,IAAI;IAChB;IACA;IACA,IAAKC,gBAA+B,CAACW,OAAO,KAAKJ,SAAS,EAAE;MAC1D,IAAMK,OAAO,GAAGZ,gBAA8B;MAC9C,IAAI,CAACW,OAAO,GAAGC,OAAO,CAACD,OAAO;MAC9B,IAAI,CAACV,QAAQ,GAAGW,OAAO,CAACX,QAAQ;MAChC,IAAI,CAACC,SAAS,GAAG,CAAAW,EAAA,GAAAD,OAAO,CAACV,SAAS,cAAAW,EAAA,cAAAA,EAAA,GAAI,KAAK;KAC5C,MAAM;MACL,IAAI,CAACF,OAAO,GAAGX,gBAAqB;MACpC,IAAI,CAACC,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACC,SAAS,GAAGA,SAAS,aAATA,SAAS,cAATA,SAAS,GAAI,KAAK;;IAErC,IAAI,CAACH,IAAI,CAACe,aAAa,CAAC,IAAI,CAAC;EAC/B;EAACC,YAAA,CAAAjB,eAAA;IAAAkB,GAAA;IAAAV,KAAA,EAID,SAAAW,cAAA,EAAa;MACX,IAAI,CAACC,eAAe,EAAE;IACxB;EAAC;IAAAF,GAAA;IAAAV,KAAA,EAED,SAAAa,iBAAA,EAAgB;MACd,IAAI,IAAI,CAACV,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,EAAE;QAClB,IAAI,CAACA,WAAW,GAAGF,SAAS;;IAEhC;EAAC;IAAAS,GAAA;IAAAV,KAAA,EAEO,SAAAY,gBAAA,EAAe;MACrB,IAAI,CAACnB,IAAI,CAACqB,aAAa,CACrB,IAAIvB,mBAAmB,CAAC,IAAI,CAACc,OAAO,EAAE,IAAI,CAACH,SAAS,EAAE,IAAI,CAACN,SAAS,CAAC,CACtE;IACH;EAAC;EAAA,OAAAJ,eAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}