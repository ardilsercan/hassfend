{"ast":null,"code":"import { NumberFormat } from \"../../data/translation\";\nimport { round } from \"./round\";\n\n/**\n * Returns true if the entity is considered numeric based on the attributes it has\n * @param stateObj The entity state object\n */\nexport const isNumericState = stateObj => isNumericFromAttributes(stateObj.attributes);\nexport const isNumericFromAttributes = attributes => !!attributes.unit_of_measurement || !!attributes.state_class;\nexport const numberFormatToLocale = localeOptions => {\n  switch (localeOptions.number_format) {\n    case NumberFormat.comma_decimal:\n      return [\"en-US\", \"en\"];\n    // Use United States with fallback to English formatting 1,234,567.89\n    case NumberFormat.decimal_comma:\n      return [\"de\", \"es\", \"it\"];\n    // Use German with fallback to Spanish then Italian formatting 1.234.567,89\n    case NumberFormat.space_comma:\n      return [\"fr\", \"sv\", \"cs\"];\n    // Use French with fallback to Swedish and Czech formatting 1 234 567,89\n    case NumberFormat.system:\n      return undefined;\n    default:\n      return localeOptions.language;\n  }\n};\n\n/**\n * Formats a number based on the user's preference with thousands separator(s) and decimal character for better legibility.\n *\n * @param num The number to format\n * @param localeOptions The user-selected language and formatting, from `hass.locale`\n * @param options Intl.NumberFormatOptions to use\n */\nexport const formatNumber = (num, localeOptions, options) => {\n  const locale = localeOptions ? numberFormatToLocale(localeOptions) : undefined;\n\n  // Polyfill for Number.isNaN, which is more reliable than the global isNaN()\n  Number.isNaN = Number.isNaN || function isNaN(input) {\n    return typeof input === \"number\" && isNaN(input);\n  };\n  if ((localeOptions === null || localeOptions === void 0 ? void 0 : localeOptions.number_format) !== NumberFormat.none && !Number.isNaN(Number(num)) && Intl) {\n    try {\n      return new Intl.NumberFormat(locale, getDefaultFormatOptions(num, options)).format(Number(num));\n    } catch (err) {\n      // Don't fail when using \"TEST\" language\n      // eslint-disable-next-line no-console\n      console.error(err);\n      return new Intl.NumberFormat(undefined, getDefaultFormatOptions(num, options)).format(Number(num));\n    }\n  }\n  if (!Number.isNaN(Number(num)) && num !== \"\" && (localeOptions === null || localeOptions === void 0 ? void 0 : localeOptions.number_format) === NumberFormat.none && Intl) {\n    // If NumberFormat is none, use en-US format without grouping.\n    return new Intl.NumberFormat(\"en-US\", getDefaultFormatOptions(num, {\n      ...options,\n      useGrouping: false\n    })).format(Number(num));\n  }\n  if (typeof num === \"string\") {\n    return num;\n  }\n  return `${round(num, options === null || options === void 0 ? void 0 : options.maximumFractionDigits).toString()}${(options === null || options === void 0 ? void 0 : options.style) === \"currency\" ? ` ${options.currency}` : \"\"}`;\n};\n\n/**\n * Checks if the current entity state should be formatted as an integer based on the `state` and `step` attribute and returns the appropriate `Intl.NumberFormatOptions` object with `maximumFractionDigits` set\n * @param entityState The state object of the entity\n * @returns An `Intl.NumberFormatOptions` object with `maximumFractionDigits` set to 0, or `undefined`\n */\nexport const getNumberFormatOptions = (entityState, entity) => {\n  var _entityState$attribut;\n  const precision = entity === null || entity === void 0 ? void 0 : entity.display_precision;\n  if (precision != null) {\n    return {\n      maximumFractionDigits: precision,\n      minimumFractionDigits: precision\n    };\n  }\n  if (Number.isInteger(Number(entityState === null || entityState === void 0 || (_entityState$attribut = entityState.attributes) === null || _entityState$attribut === void 0 ? void 0 : _entityState$attribut.step)) && Number.isInteger(Number(entityState === null || entityState === void 0 ? void 0 : entityState.state))) {\n    return {\n      maximumFractionDigits: 0\n    };\n  }\n  return undefined;\n};\n\n/**\n * Generates default options for Intl.NumberFormat\n * @param num The number to be formatted\n * @param options The Intl.NumberFormatOptions that should be included in the returned options\n */\nexport const getDefaultFormatOptions = (num, options) => {\n  const defaultOptions = {\n    maximumFractionDigits: 2,\n    ...options\n  };\n  if (typeof num !== \"string\") {\n    return defaultOptions;\n  }\n\n  // Keep decimal trailing zeros if they are present in a string numeric value\n  if (!options || options.minimumFractionDigits === undefined && options.maximumFractionDigits === undefined) {\n    const digits = num.indexOf(\".\") > -1 ? num.split(\".\")[1].length : 0;\n    defaultOptions.minimumFractionDigits = digits;\n    defaultOptions.maximumFractionDigits = digits;\n  }\n  return defaultOptions;\n};","map":{"version":3,"names":["NumberFormat","round","isNumericState","stateObj","isNumericFromAttributes","attributes","unit_of_measurement","state_class","numberFormatToLocale","localeOptions","number_format","comma_decimal","decimal_comma","space_comma","system","undefined","language","formatNumber","num","options","locale","Number","isNaN","input","none","Intl","getDefaultFormatOptions","format","err","console","error","useGrouping","maximumFractionDigits","toString","style","currency","getNumberFormatOptions","entityState","entity","_entityState$attribut","precision","display_precision","minimumFractionDigits","isInteger","step","state","defaultOptions","digits","indexOf","split","length"],"sources":["/workspaces/frontend/src/common/number/format_number.ts"],"sourcesContent":["import {\n  HassEntity,\n  HassEntityAttributeBase,\n} from \"home-assistant-js-websocket\";\nimport { EntityRegistryDisplayEntry } from \"../../data/entity_registry\";\nimport { FrontendLocaleData, NumberFormat } from \"../../data/translation\";\nimport { round } from \"./round\";\n\n/**\n * Returns true if the entity is considered numeric based on the attributes it has\n * @param stateObj The entity state object\n */\nexport const isNumericState = (stateObj: HassEntity): boolean =>\n  isNumericFromAttributes(stateObj.attributes);\n\nexport const isNumericFromAttributes = (\n  attributes: HassEntityAttributeBase\n): boolean => !!attributes.unit_of_measurement || !!attributes.state_class;\n\nexport const numberFormatToLocale = (\n  localeOptions: FrontendLocaleData\n): string | string[] | undefined => {\n  switch (localeOptions.number_format) {\n    case NumberFormat.comma_decimal:\n      return [\"en-US\", \"en\"]; // Use United States with fallback to English formatting 1,234,567.89\n    case NumberFormat.decimal_comma:\n      return [\"de\", \"es\", \"it\"]; // Use German with fallback to Spanish then Italian formatting 1.234.567,89\n    case NumberFormat.space_comma:\n      return [\"fr\", \"sv\", \"cs\"]; // Use French with fallback to Swedish and Czech formatting 1 234 567,89\n    case NumberFormat.system:\n      return undefined;\n    default:\n      return localeOptions.language;\n  }\n};\n\n/**\n * Formats a number based on the user's preference with thousands separator(s) and decimal character for better legibility.\n *\n * @param num The number to format\n * @param localeOptions The user-selected language and formatting, from `hass.locale`\n * @param options Intl.NumberFormatOptions to use\n */\nexport const formatNumber = (\n  num: string | number,\n  localeOptions?: FrontendLocaleData,\n  options?: Intl.NumberFormatOptions\n): string => {\n  const locale = localeOptions\n    ? numberFormatToLocale(localeOptions)\n    : undefined;\n\n  // Polyfill for Number.isNaN, which is more reliable than the global isNaN()\n  Number.isNaN =\n    Number.isNaN ||\n    function isNaN(input) {\n      return typeof input === \"number\" && isNaN(input);\n    };\n\n  if (\n    localeOptions?.number_format !== NumberFormat.none &&\n    !Number.isNaN(Number(num)) &&\n    Intl\n  ) {\n    try {\n      return new Intl.NumberFormat(\n        locale,\n        getDefaultFormatOptions(num, options)\n      ).format(Number(num));\n    } catch (err: any) {\n      // Don't fail when using \"TEST\" language\n      // eslint-disable-next-line no-console\n      console.error(err);\n      return new Intl.NumberFormat(\n        undefined,\n        getDefaultFormatOptions(num, options)\n      ).format(Number(num));\n    }\n  }\n\n  if (\n    !Number.isNaN(Number(num)) &&\n    num !== \"\" &&\n    localeOptions?.number_format === NumberFormat.none &&\n    Intl\n  ) {\n    // If NumberFormat is none, use en-US format without grouping.\n    return new Intl.NumberFormat(\n      \"en-US\",\n      getDefaultFormatOptions(num, {\n        ...options,\n        useGrouping: false,\n      })\n    ).format(Number(num));\n  }\n\n  if (typeof num === \"string\") {\n    return num;\n  }\n  return `${round(num, options?.maximumFractionDigits).toString()}${\n    options?.style === \"currency\" ? ` ${options.currency}` : \"\"\n  }`;\n};\n\n/**\n * Checks if the current entity state should be formatted as an integer based on the `state` and `step` attribute and returns the appropriate `Intl.NumberFormatOptions` object with `maximumFractionDigits` set\n * @param entityState The state object of the entity\n * @returns An `Intl.NumberFormatOptions` object with `maximumFractionDigits` set to 0, or `undefined`\n */\nexport const getNumberFormatOptions = (\n  entityState?: HassEntity,\n  entity?: EntityRegistryDisplayEntry\n): Intl.NumberFormatOptions | undefined => {\n  const precision = entity?.display_precision;\n  if (precision != null) {\n    return {\n      maximumFractionDigits: precision,\n      minimumFractionDigits: precision,\n    };\n  }\n  if (\n    Number.isInteger(Number(entityState?.attributes?.step)) &&\n    Number.isInteger(Number(entityState?.state))\n  ) {\n    return { maximumFractionDigits: 0 };\n  }\n  return undefined;\n};\n\n/**\n * Generates default options for Intl.NumberFormat\n * @param num The number to be formatted\n * @param options The Intl.NumberFormatOptions that should be included in the returned options\n */\nexport const getDefaultFormatOptions = (\n  num: string | number,\n  options?: Intl.NumberFormatOptions\n): Intl.NumberFormatOptions => {\n  const defaultOptions: Intl.NumberFormatOptions = {\n    maximumFractionDigits: 2,\n    ...options,\n  };\n\n  if (typeof num !== \"string\") {\n    return defaultOptions;\n  }\n\n  // Keep decimal trailing zeros if they are present in a string numeric value\n  if (\n    !options ||\n    (options.minimumFractionDigits === undefined &&\n      options.maximumFractionDigits === undefined)\n  ) {\n    const digits = num.indexOf(\".\") > -1 ? num.split(\".\")[1].length : 0;\n    defaultOptions.minimumFractionDigits = digits;\n    defaultOptions.maximumFractionDigits = digits;\n  }\n\n  return defaultOptions;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}