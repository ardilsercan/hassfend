{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\n/**\n * Used to calculate the scroll direction during touch events.\n * @type {!Object}\n */\nvar lastTouchPosition = {\n  pageX: 0,\n  pageY: 0\n};\n/**\n * Used to avoid computing event.path and filter scrollable nodes (better perf).\n * @type {?EventTarget}\n */\nvar lastRootTarget = null;\n/**\n * @type {!Array<!Node>}\n */\nvar lastScrollableNodes = [];\n/**\n * @type {!Array<string>}\n */\nvar scrollEvents = [\n// Modern `wheel` event for mouse wheel scrolling:\n'wheel',\n// Older, non-standard `mousewheel` event for some FF:\n'mousewheel',\n// IE:\n'DOMMouseScroll',\n// Touch enabled devices\n'touchstart', 'touchmove'];\n// must be defined for modulizer\nvar _boundScrollHandler;\n\n/**\n * The current element that defines the DOM boundaries of the\n * scroll lock. This is always the most recently locking element.\n *\n * @type {!Node|undefined}\n */\nvar currentLockingElement;\nexport { currentLockingElement };\n\n/**\n * Returns true if the provided element is \"scroll locked\", which is to\n * say that it cannot be scrolled via pointer or keyboard interactions.\n *\n * @param {!HTMLElement} element An HTML element instance which may or may\n * not be scroll locked.\n */\nexport function elementIsScrollLocked(element) {\n  var lockingElement = currentLockingElement;\n  if (lockingElement === undefined) {\n    return false;\n  }\n  var scrollLocked;\n  if (_hasCachedLockedElement(element)) {\n    return true;\n  }\n  if (_hasCachedUnlockedElement(element)) {\n    return false;\n  }\n  scrollLocked = !!lockingElement && lockingElement !== element && !_composedTreeContains(lockingElement, element);\n  if (scrollLocked) {\n    _lockedElementCache.push(element);\n  } else {\n    _unlockedElementCache.push(element);\n  }\n  return scrollLocked;\n}\n\n/**\n * Push an element onto the current scroll lock stack. The most recently\n * pushed element and its children will be considered scrollable. All\n * other elements will not be scrollable.\n *\n * Scroll locking is implemented as a stack so that cases such as\n * dropdowns within dropdowns are handled well.\n *\n * @param {!HTMLElement} element The element that should lock scroll.\n */\nexport function pushScrollLock(element) {\n  // Prevent pushing the same element twice\n  if (_lockingElements.indexOf(element) >= 0) {\n    return;\n  }\n  if (_lockingElements.length === 0) {\n    _lockScrollInteractions();\n  }\n  _lockingElements.push(element);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n}\n\n/**\n * Remove an element from the scroll lock stack. The element being\n * removed does not need to be the most recently pushed element. However,\n * the scroll lock constraints only change when the most recently pushed\n * element is removed.\n *\n * @param {!HTMLElement} element The element to remove from the scroll\n * lock stack.\n */\nexport function removeScrollLock(element) {\n  var index = _lockingElements.indexOf(element);\n  if (index === -1) {\n    return;\n  }\n  _lockingElements.splice(index, 1);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n  if (_lockingElements.length === 0) {\n    _unlockScrollInteractions();\n  }\n}\nexport var _lockingElements = [];\nexport var _lockedElementCache = null;\nexport var _unlockedElementCache = null;\nexport function _hasCachedLockedElement(element) {\n  return _lockedElementCache.indexOf(element) > -1;\n}\nexport function _hasCachedUnlockedElement(element) {\n  return _unlockedElementCache.indexOf(element) > -1;\n}\nexport function _composedTreeContains(element, child) {\n  // NOTE(cdata): This method iterates over content elements and their\n  // corresponding distributed nodes to implement a contains-like method\n  // that pierces through the composed tree of the ShadowDOM. Results of\n  // this operation are cached (elsewhere) on a per-scroll-lock basis, to\n  // guard against potentially expensive lookups happening repeatedly as\n  // a user scrolls / touchmoves.\n  var contentElements;\n  var distributedNodes;\n  var contentIndex;\n  var nodeIndex;\n  if (element.contains(child)) {\n    return true;\n  }\n  contentElements = dom(element).querySelectorAll('content,slot');\n  for (contentIndex = 0; contentIndex < contentElements.length; ++contentIndex) {\n    distributedNodes = dom(contentElements[contentIndex]).getDistributedNodes();\n    for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {\n      // Polymer 2.x returns slot.assignedNodes which can contain text nodes.\n      if (distributedNodes[nodeIndex].nodeType !== Node.ELEMENT_NODE) continue;\n      if (_composedTreeContains(distributedNodes[nodeIndex], child)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport function _scrollInteractionHandler(event) {\n  // Avoid canceling an event with cancelable=false, e.g. scrolling is in\n  // progress and cannot be interrupted.\n  if (event.cancelable && _shouldPreventScrolling(event)) {\n    event.preventDefault();\n  }\n  // If event has targetTouches (touch event), update last touch position.\n  if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    lastTouchPosition.pageX = touch.pageX;\n    lastTouchPosition.pageY = touch.pageY;\n  }\n}\n\n/**\n * @package\n */\nexport { _boundScrollHandler };\nexport function _lockScrollInteractions() {\n  _boundScrollHandler = _boundScrollHandler || _scrollInteractionHandler.bind(undefined);\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.addEventListener(scrollEvents[i], _boundScrollHandler, {\n      capture: true,\n      passive: false\n    });\n  }\n}\nexport function _unlockScrollInteractions() {\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.removeEventListener(scrollEvents[i], _boundScrollHandler, {\n      capture: true,\n      passive: false\n    });\n  }\n}\n\n/**\n * Returns true if the event causes scroll outside the current locking\n * element, e.g. pointer/keyboard interactions, or scroll \"leaking\"\n * outside the locking element when it is already at its scroll boundaries.\n * @param {!Event} event\n * @return {boolean}\n * @package\n */\nexport function _shouldPreventScrolling(event) {\n  // Update if root target changed. For touch events, ensure we don't\n  // update during touchmove.\n  var target = dom(event).rootTarget;\n  if (event.type !== 'touchmove' && lastRootTarget !== target) {\n    lastRootTarget = target;\n    lastScrollableNodes = _getScrollableNodes(dom(event).path);\n  }\n\n  // Prevent event if no scrollable nodes.\n  if (!lastScrollableNodes.length) {\n    return true;\n  }\n  // Don't prevent touchstart event inside the locking element when it has\n  // scrollable nodes.\n  if (event.type === 'touchstart') {\n    return false;\n  }\n  // Get deltaX/Y.\n  var info = _getScrollInfo(event);\n  // Prevent if there is no child that can scroll.\n  return !_getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);\n}\n\n/**\n * Returns an array of scrollable nodes up to the current locking element,\n * which is included too if scrollable.\n * @param {!Array<!Node>} nodes\n * @return {!Array<!Node>} scrollables\n * @package\n */\nexport function _getScrollableNodes(nodes) {\n  var scrollables = [];\n  var lockingIndex = nodes.indexOf( /** @type {!Node} */currentLockingElement);\n  // Loop from root target to locking element (included).\n  for (var i = 0; i <= lockingIndex; i++) {\n    // Skip non-Element nodes.\n    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n    var node = /** @type {!Element} */nodes[i];\n    // Check inline style before checking computed style.\n    var style = node.style;\n    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {\n      style = window.getComputedStyle(node);\n    }\n    if (style.overflow === 'scroll' || style.overflow === 'auto') {\n      scrollables.push(node);\n    }\n  }\n  return scrollables;\n}\n\n/**\n * Returns the node that is scrolling. If there is no scrolling,\n * returns undefined.\n * @param {!Array<!Node>} nodes\n * @param {number} deltaX Scroll delta on the x-axis\n * @param {number} deltaY Scroll delta on the y-axis\n * @return {!Node|undefined}\n * @package\n */\nexport function _getScrollingNode(nodes, deltaX, deltaY) {\n  // No scroll.\n  if (!deltaX && !deltaY) {\n    return;\n  }\n  // Check only one axis according to where there is more scroll.\n  // Prefer vertical to horizontal.\n  var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var canScroll = false;\n    if (verticalScroll) {\n      // delta < 0 is scroll up, delta > 0 is scroll down.\n      canScroll = deltaY < 0 ? node.scrollTop > 0 : node.scrollTop < node.scrollHeight - node.clientHeight;\n    } else {\n      // delta < 0 is scroll left, delta > 0 is scroll right.\n      canScroll = deltaX < 0 ? node.scrollLeft > 0 : node.scrollLeft < node.scrollWidth - node.clientWidth;\n    }\n    if (canScroll) {\n      return node;\n    }\n  }\n}\n\n/**\n * Returns scroll `deltaX` and `deltaY`.\n * @param {!Event} event The scroll event\n * @return {{deltaX: number, deltaY: number}} Object containing the\n * x-axis scroll delta (positive: scroll right, negative: scroll left,\n * 0: no scroll), and the y-axis scroll delta (positive: scroll down,\n * negative: scroll up, 0: no scroll).\n * @package\n */\nexport function _getScrollInfo(event) {\n  var info = {\n    deltaX: event.deltaX,\n    deltaY: event.deltaY\n  };\n  // Already available.\n  if ('deltaX' in event) {\n    // do nothing, values are already good.\n  }\n  // Safari has scroll info in `wheelDeltaX/Y`.\n  else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {\n    info.deltaX = -event.wheelDeltaX;\n    info.deltaY = -event.wheelDeltaY;\n  }\n  // IE10 has only vertical scroll info in `wheelDelta`.\n  else if ('wheelDelta' in event) {\n    info.deltaX = 0;\n    info.deltaY = -event.wheelDelta;\n  }\n  // Firefox has scroll info in `detail` and `axis`.\n  else if ('axis' in event) {\n    info.deltaX = event.axis === 1 ? event.detail : 0;\n    info.deltaY = event.axis === 2 ? event.detail : 0;\n  }\n  // On mobile devices, calculate scroll direction.\n  else if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    // Touch moves from right to left => scrolling goes right.\n    info.deltaX = lastTouchPosition.pageX - touch.pageX;\n    // Touch moves from down to up => scrolling goes down.\n    info.deltaY = lastTouchPosition.pageY - touch.pageY;\n  }\n  return info;\n}","map":{"version":3,"names":["dom","lastTouchPosition","pageX","pageY","lastRootTarget","lastScrollableNodes","scrollEvents","_boundScrollHandler","currentLockingElement","elementIsScrollLocked","element","lockingElement","undefined","scrollLocked","_hasCachedLockedElement","_hasCachedUnlockedElement","_composedTreeContains","_lockedElementCache","push","_unlockedElementCache","pushScrollLock","_lockingElements","indexOf","length","_lockScrollInteractions","removeScrollLock","index","splice","_unlockScrollInteractions","child","contentElements","distributedNodes","contentIndex","nodeIndex","contains","querySelectorAll","getDistributedNodes","nodeType","Node","ELEMENT_NODE","_scrollInteractionHandler","event","cancelable","_shouldPreventScrolling","preventDefault","targetTouches","touch","bind","i","l","document","addEventListener","capture","passive","removeEventListener","target","rootTarget","type","_getScrollableNodes","path","info","_getScrollInfo","_getScrollingNode","deltaX","deltaY","nodes","scrollables","lockingIndex","node","style","overflow","window","getComputedStyle","verticalScroll","Math","abs","canScroll","scrollTop","scrollHeight","clientHeight","scrollLeft","scrollWidth","clientWidth","wheelDeltaX","wheelDeltaY","wheelDelta","axis","detail"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/iron-overlay-behavior/iron-scroll-manager.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n/**\n * Used to calculate the scroll direction during touch events.\n * @type {!Object}\n */\nvar lastTouchPosition = {pageX: 0, pageY: 0};\n/**\n * Used to avoid computing event.path and filter scrollable nodes (better perf).\n * @type {?EventTarget}\n */\nvar lastRootTarget = null;\n/**\n * @type {!Array<!Node>}\n */\nvar lastScrollableNodes = [];\n/**\n * @type {!Array<string>}\n */\nvar scrollEvents = [\n  // Modern `wheel` event for mouse wheel scrolling:\n  'wheel',\n  // Older, non-standard `mousewheel` event for some FF:\n  'mousewheel',\n  // IE:\n  'DOMMouseScroll',\n  // Touch enabled devices\n  'touchstart',\n  'touchmove'\n];\n// must be defined for modulizer\nvar _boundScrollHandler;\n\n/**\n * The current element that defines the DOM boundaries of the\n * scroll lock. This is always the most recently locking element.\n *\n * @type {!Node|undefined}\n */\nvar currentLockingElement;\n\nexport {currentLockingElement};\n\n/**\n * Returns true if the provided element is \"scroll locked\", which is to\n * say that it cannot be scrolled via pointer or keyboard interactions.\n *\n * @param {!HTMLElement} element An HTML element instance which may or may\n * not be scroll locked.\n */\nexport function elementIsScrollLocked(element) {\n  var lockingElement = currentLockingElement;\n\n  if (lockingElement === undefined) {\n    return false;\n  }\n\n  var scrollLocked;\n\n  if (_hasCachedLockedElement(element)) {\n    return true;\n  }\n\n  if (_hasCachedUnlockedElement(element)) {\n    return false;\n  }\n\n  scrollLocked = !!lockingElement && lockingElement !== element &&\n      !_composedTreeContains(lockingElement, element);\n\n  if (scrollLocked) {\n    _lockedElementCache.push(element);\n  } else {\n    _unlockedElementCache.push(element);\n  }\n\n  return scrollLocked;\n}\n\n/**\n * Push an element onto the current scroll lock stack. The most recently\n * pushed element and its children will be considered scrollable. All\n * other elements will not be scrollable.\n *\n * Scroll locking is implemented as a stack so that cases such as\n * dropdowns within dropdowns are handled well.\n *\n * @param {!HTMLElement} element The element that should lock scroll.\n */\nexport function pushScrollLock(element) {\n  // Prevent pushing the same element twice\n  if (_lockingElements.indexOf(element) >= 0) {\n    return;\n  }\n\n  if (_lockingElements.length === 0) {\n    _lockScrollInteractions();\n  }\n\n  _lockingElements.push(element);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n}\n\n/**\n * Remove an element from the scroll lock stack. The element being\n * removed does not need to be the most recently pushed element. However,\n * the scroll lock constraints only change when the most recently pushed\n * element is removed.\n *\n * @param {!HTMLElement} element The element to remove from the scroll\n * lock stack.\n */\nexport function removeScrollLock(element) {\n  var index = _lockingElements.indexOf(element);\n\n  if (index === -1) {\n    return;\n  }\n\n  _lockingElements.splice(index, 1);\n  currentLockingElement = _lockingElements[_lockingElements.length - 1];\n\n  _lockedElementCache = [];\n  _unlockedElementCache = [];\n\n  if (_lockingElements.length === 0) {\n    _unlockScrollInteractions();\n  }\n}\n\nexport const _lockingElements = [];\nexport let _lockedElementCache = null;\nexport let _unlockedElementCache = null;\n\nexport function _hasCachedLockedElement(element) {\n  return _lockedElementCache.indexOf(element) > -1;\n}\n\nexport function _hasCachedUnlockedElement(element) {\n  return _unlockedElementCache.indexOf(element) > -1;\n}\n\nexport function _composedTreeContains(element, child) {\n  // NOTE(cdata): This method iterates over content elements and their\n  // corresponding distributed nodes to implement a contains-like method\n  // that pierces through the composed tree of the ShadowDOM. Results of\n  // this operation are cached (elsewhere) on a per-scroll-lock basis, to\n  // guard against potentially expensive lookups happening repeatedly as\n  // a user scrolls / touchmoves.\n  var contentElements;\n  var distributedNodes;\n  var contentIndex;\n  var nodeIndex;\n\n  if (element.contains(child)) {\n    return true;\n  }\n\n  contentElements = dom(element).querySelectorAll('content,slot');\n\n  for (contentIndex = 0; contentIndex < contentElements.length;\n       ++contentIndex) {\n    distributedNodes = dom(contentElements[contentIndex]).getDistributedNodes();\n\n    for (nodeIndex = 0; nodeIndex < distributedNodes.length; ++nodeIndex) {\n      // Polymer 2.x returns slot.assignedNodes which can contain text nodes.\n      if (distributedNodes[nodeIndex].nodeType !== Node.ELEMENT_NODE)\n        continue;\n\n      if (_composedTreeContains(distributedNodes[nodeIndex], child)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function _scrollInteractionHandler(event) {\n  // Avoid canceling an event with cancelable=false, e.g. scrolling is in\n  // progress and cannot be interrupted.\n  if (event.cancelable && _shouldPreventScrolling(event)) {\n    event.preventDefault();\n  }\n  // If event has targetTouches (touch event), update last touch position.\n  if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    lastTouchPosition.pageX = touch.pageX;\n    lastTouchPosition.pageY = touch.pageY;\n  }\n}\n\n/**\n * @package\n */\nexport {_boundScrollHandler};\n\nexport function _lockScrollInteractions() {\n  _boundScrollHandler =\n      _boundScrollHandler || _scrollInteractionHandler.bind(undefined);\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.addEventListener(\n        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});\n  }\n}\n\nexport function _unlockScrollInteractions() {\n  for (var i = 0, l = scrollEvents.length; i < l; i++) {\n    // NOTE: browsers that don't support objects as third arg will\n    // interpret it as boolean, hence useCapture = true in this case.\n    document.removeEventListener(\n        scrollEvents[i], _boundScrollHandler, {capture: true, passive: false});\n  }\n}\n\n/**\n * Returns true if the event causes scroll outside the current locking\n * element, e.g. pointer/keyboard interactions, or scroll \"leaking\"\n * outside the locking element when it is already at its scroll boundaries.\n * @param {!Event} event\n * @return {boolean}\n * @package\n */\nexport function _shouldPreventScrolling(event) {\n  // Update if root target changed. For touch events, ensure we don't\n  // update during touchmove.\n  var target = dom(event).rootTarget;\n  if (event.type !== 'touchmove' && lastRootTarget !== target) {\n    lastRootTarget = target;\n    lastScrollableNodes = _getScrollableNodes(dom(event).path);\n  }\n\n  // Prevent event if no scrollable nodes.\n  if (!lastScrollableNodes.length) {\n    return true;\n  }\n  // Don't prevent touchstart event inside the locking element when it has\n  // scrollable nodes.\n  if (event.type === 'touchstart') {\n    return false;\n  }\n  // Get deltaX/Y.\n  var info = _getScrollInfo(event);\n  // Prevent if there is no child that can scroll.\n  return !_getScrollingNode(lastScrollableNodes, info.deltaX, info.deltaY);\n}\n\n/**\n * Returns an array of scrollable nodes up to the current locking element,\n * which is included too if scrollable.\n * @param {!Array<!Node>} nodes\n * @return {!Array<!Node>} scrollables\n * @package\n */\nexport function _getScrollableNodes(nodes) {\n  var scrollables = [];\n  var lockingIndex =\n      nodes.indexOf(/** @type {!Node} */ (currentLockingElement));\n  // Loop from root target to locking element (included).\n  for (var i = 0; i <= lockingIndex; i++) {\n    // Skip non-Element nodes.\n    if (nodes[i].nodeType !== Node.ELEMENT_NODE) {\n      continue;\n    }\n    var node = /** @type {!Element} */ (nodes[i]);\n    // Check inline style before checking computed style.\n    var style = node.style;\n    if (style.overflow !== 'scroll' && style.overflow !== 'auto') {\n      style = window.getComputedStyle(node);\n    }\n    if (style.overflow === 'scroll' || style.overflow === 'auto') {\n      scrollables.push(node);\n    }\n  }\n  return scrollables;\n}\n\n/**\n * Returns the node that is scrolling. If there is no scrolling,\n * returns undefined.\n * @param {!Array<!Node>} nodes\n * @param {number} deltaX Scroll delta on the x-axis\n * @param {number} deltaY Scroll delta on the y-axis\n * @return {!Node|undefined}\n * @package\n */\nexport function _getScrollingNode(nodes, deltaX, deltaY) {\n  // No scroll.\n  if (!deltaX && !deltaY) {\n    return;\n  }\n  // Check only one axis according to where there is more scroll.\n  // Prefer vertical to horizontal.\n  var verticalScroll = Math.abs(deltaY) >= Math.abs(deltaX);\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var canScroll = false;\n    if (verticalScroll) {\n      // delta < 0 is scroll up, delta > 0 is scroll down.\n      canScroll = deltaY < 0 ?\n          node.scrollTop > 0 :\n          node.scrollTop < node.scrollHeight - node.clientHeight;\n    } else {\n      // delta < 0 is scroll left, delta > 0 is scroll right.\n      canScroll = deltaX < 0 ?\n          node.scrollLeft > 0 :\n          node.scrollLeft < node.scrollWidth - node.clientWidth;\n    }\n    if (canScroll) {\n      return node;\n    }\n  }\n}\n\n/**\n * Returns scroll `deltaX` and `deltaY`.\n * @param {!Event} event The scroll event\n * @return {{deltaX: number, deltaY: number}} Object containing the\n * x-axis scroll delta (positive: scroll right, negative: scroll left,\n * 0: no scroll), and the y-axis scroll delta (positive: scroll down,\n * negative: scroll up, 0: no scroll).\n * @package\n */\nexport function _getScrollInfo(event) {\n  var info = {deltaX: event.deltaX, deltaY: event.deltaY};\n  // Already available.\n  if ('deltaX' in event) {\n    // do nothing, values are already good.\n  }\n  // Safari has scroll info in `wheelDeltaX/Y`.\n  else if ('wheelDeltaX' in event && 'wheelDeltaY' in event) {\n    info.deltaX = -event.wheelDeltaX;\n    info.deltaY = -event.wheelDeltaY;\n  }\n  // IE10 has only vertical scroll info in `wheelDelta`.\n  else if ('wheelDelta' in event) {\n    info.deltaX = 0;\n    info.deltaY = -event.wheelDelta;\n  }\n  // Firefox has scroll info in `detail` and `axis`.\n  else if ('axis' in event) {\n    info.deltaX = event.axis === 1 ? event.detail : 0;\n    info.deltaY = event.axis === 2 ? event.detail : 0;\n  }\n  // On mobile devices, calculate scroll direction.\n  else if (event.targetTouches) {\n    var touch = event.targetTouches[0];\n    // Touch moves from right to left => scrolling goes right.\n    info.deltaX = lastTouchPosition.pageX - touch.pageX;\n    // Touch moves from down to up => scrolling goes down.\n    info.deltaY = lastTouchPosition.pageY - touch.pageY;\n  }\n  return info;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}