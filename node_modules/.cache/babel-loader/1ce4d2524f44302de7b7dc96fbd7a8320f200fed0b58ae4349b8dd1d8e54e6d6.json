{"ast":null,"code":"import { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDisplayFromEntityAttributes } from \"../common/entity/compute_state_display\";\nimport { computeStateNameFromEntityAttributes } from \"../common/entity/compute_state_name\";\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\", \"person\", \"device_tracker\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\", \"action\", \"current_humidity\"];\nexport const entityIdHistoryNeedsAttributes = (hass, entityId) => !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\nexport const fetchDateWS = (hass, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS({\n      ...params,\n      entity_ids: entityIds\n    });\n  }\n  return hass.callWS(params);\n};\nexport const subscribeHistory = (hass, callbackFunction, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nclass HistoryStream {\n  constructor(hass, hoursToShow) {\n    this.hass = void 0;\n    this.hoursToShow = void 0;\n    this.combinedHistory = void 0;\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n  processMessage(streamMessage) {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n    const newHistory = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (entityId in this.combinedHistory && entityId in streamMessage.states) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(streamMessage.states[entityId]);\n        if (streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort((a, b) => a.lu - b.lu);\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter(state => state.lu < purgeBeforePythonTime);\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter(state => state.lu >= purgeBeforePythonTime);\n        if (newHistory[entityId].length && newHistory[entityId][0].lu === purgeBeforePythonTime) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\nexport const subscribeHistoryStatesTimeWindow = (hass, callbackFunction, hoursToShow, entityIds, minimalResponse = true, significantChangesOnly = true, noAttributes) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes !== null && noAttributes !== void 0 ? noAttributes : !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nconst equalState = (obj1, obj2) => obj1.state === obj2.state && (\n// Only compare attributes if both states have an attributes object.\n// When `minimal_response` is sent, only the first and last state\n// will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(attr => obj1.attributes[attr] === obj2.attributes[attr]));\nconst processTimelineEntity = (localize, locale, config, entities, entityId, states, current_state) => {\n  const data = [];\n  const first = states[0];\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n    const currentAttributes = {};\n    if (current_state !== null && current_state !== void 0 && current_state.attributes.device_class) {\n      currentAttributes.device_class = current_state === null || current_state === void 0 ? void 0 : current_state.attributes.device_class;\n    }\n    data.push({\n      state_localize: computeStateDisplayFromEntityAttributes(localize, locale, config, entities[entityId], entityId, {\n        ...(state.a || first.a),\n        ...currentAttributes\n      }, state.s),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000\n    });\n  }\n  return {\n    name: computeStateNameFromEntityAttributes(entityId, (current_state === null || current_state === void 0 ? void 0 : current_state.attributes) || first.a),\n    entity_id: entityId,\n    data\n  };\n};\nconst processLineChartEntities = (unit, device_class, entities, hassEntities) => {\n  const data = [];\n  Object.keys(entities).forEach(entityId => {\n    const states = entities[entityId];\n    const first = states[0];\n    const domain = computeDomain(entityId);\n    const processedStates = [];\n    for (const state of states) {\n      let processedState;\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {}\n        };\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes[attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {}\n        };\n      }\n      if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n        continue;\n      }\n      processedStates.push(processedState);\n    }\n    const attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n    data.push({\n      domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates\n    });\n  });\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data\n  };\n};\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\nconst isNumericFromDomain = domain => NUMERICAL_DOMAINS.includes(domain);\nconst isNumericFromAttributes = attributes => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\nconst isNumericSensorEntity = (stateObj, sensorNumericalDeviceClasses) => stateObj.attributes.device_class != null && sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\nconst BLANK_UNIT = \" \";\nexport const computeHistory = (hass, stateHistory, localize, sensorNumericalDeviceClasses, splitDeviceClasses = false) => {\n  const lineChartDevices = {};\n  const timelineDevices = [];\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n  Object.keys(stateHistory).forEach(entityId => {\n    var _ref;\n    const stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n    const domain = computeDomain(entityId);\n    const currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    const numericStateFromHistory = currentState || isNumericFromDomain(domain) ? undefined : stateInfo.find(state => state.a && isNumericFromAttributes(state.a));\n    let unit;\n    const isNumeric = isNumericFromDomain(domain) || currentState != null && isNumericFromAttributes(currentState.attributes) || currentState != null && domain === \"sensor\" && isNumericSensorEntity(currentState, sensorNumericalDeviceClasses) || numericStateFromHistory != null;\n    if (isNumeric) {\n      unit = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes.unit_of_measurement) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a.unit_of_measurement) || BLANK_UNIT;\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        humidifier: \"%\",\n        water_heater: hass.config.unit_system.temperature\n      }[domain];\n    }\n    const specialDomainClasses = {\n      climate: \"temperature\",\n      humidifier: \"humidity\",\n      water_heater: \"temperature\"\n    };\n    const deviceClass = specialDomainClasses[domain] || ((_ref = (currentState === null || currentState === void 0 ? void 0 : currentState.attributes) || (numericStateFromHistory === null || numericStateFromHistory === void 0 ? void 0 : numericStateFromHistory.a)) === null || _ref === void 0 ? void 0 : _ref.device_class);\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, hass.config, hass.entities, entityId, stateInfo, currentState));\n    } else if (key && key in lineChartDevices && entityId in lineChartDevices[key]) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n  const unitStates = Object.keys(lineChartDevices).map(key => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey[1] || undefined;\n    return processLineChartEntities(unit, deviceClass, lineChartDevices[key], hass.states);\n  });\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n};\nexport const computeGroupKey = (unit, device_class, splitDeviceClasses) => splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit;","map":{"version":3,"names":["computeDomain","computeStateDisplayFromEntityAttributes","computeStateNameFromEntityAttributes","DOMAINS_USE_LAST_UPDATED","NEED_ATTRIBUTE_DOMAINS","LINE_ATTRIBUTES_TO_KEEP","entityIdHistoryNeedsAttributes","hass","entityId","states","includes","fetchDateWS","startTime","endTime","entityIds","params","type","start_time","toISOString","end_time","minimal_response","no_attributes","some","length","callWS","entity_ids","subscribeHistory","callbackFunction","stream","HistoryStream","connection","subscribeMessage","message","processMessage","constructor","hoursToShow","combinedHistory","streamMessage","Object","keys","purgeBeforePythonTime","Date","getTime","undefined","newHistory","entityCombinedHistory","lastEntityCombinedHistory","concat","lu","sort","a","b","expiredStates","filter","state","lastExpiredState","unshift","subscribeHistoryStatesTimeWindow","minimalResponse","significantChangesOnly","noAttributes","significant_changes_only","equalState","obj1","obj2","attributes","every","attr","processTimelineEntity","localize","locale","config","entities","current_state","data","first","s","currentAttributes","device_class","push","state_localize","last_changed","lc","name","entity_id","processLineChartEntities","unit","hassEntities","forEach","domain","processedStates","processedState","identifier","join","NUMERICAL_DOMAINS","isNumericFromDomain","isNumericFromAttributes","isNumericSensorEntity","stateObj","sensorNumericalDeviceClasses","BLANK_UNIT","computeHistory","stateHistory","splitDeviceClasses","lineChartDevices","timelineDevices","line","timeline","_ref","stateInfo","currentState","numericStateFromHistory","find","isNumeric","unit_of_measurement","zone","climate","unit_system","temperature","humidifier","water_heater","specialDomainClasses","deviceClass","key","computeGroupKey","unitStates","map","splitKey","split"],"sources":["/workspaces/frontend/src/data/history.ts"],"sourcesContent":["import {\n  HassConfig,\n  HassEntities,\n  HassEntity,\n  HassEntityAttributeBase,\n} from \"home-assistant-js-websocket\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport { computeStateDisplayFromEntityAttributes } from \"../common/entity/compute_state_display\";\nimport { computeStateNameFromEntityAttributes } from \"../common/entity/compute_state_name\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { HomeAssistant } from \"../types\";\nimport { FrontendLocaleData } from \"./translation\";\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\n  \"climate\",\n  \"humidifier\",\n  \"input_datetime\",\n  \"thermostat\",\n  \"water_heater\",\n  \"person\",\n  \"device_tracker\",\n];\nconst LINE_ATTRIBUTES_TO_KEEP = [\n  \"temperature\",\n  \"current_temperature\",\n  \"target_temp_low\",\n  \"target_temp_high\",\n  \"hvac_action\",\n  \"humidity\",\n  \"mode\",\n  \"action\",\n  \"current_humidity\",\n];\n\nexport interface LineChartState {\n  state: string;\n  last_changed: number;\n  attributes?: Record<string, any>;\n}\n\nexport interface LineChartEntity {\n  domain: string;\n  name: string;\n  entity_id: string;\n  states: LineChartState[];\n  statistics?: LineChartState[];\n}\n\nexport interface LineChartUnit {\n  unit: string;\n  device_class?: string;\n  identifier: string;\n  data: LineChartEntity[];\n}\n\nexport interface TimelineState {\n  state_localize: string;\n  state: string;\n  last_changed: number;\n}\n\nexport interface TimelineEntity {\n  name: string;\n  entity_id: string;\n  data: TimelineState[];\n}\n\nexport interface HistoryResult {\n  line: LineChartUnit[];\n  timeline: TimelineEntity[];\n}\n\nexport interface HistoryStates {\n  [entityId: string]: EntityHistoryState[];\n}\n\nexport interface EntityHistoryState {\n  /** state */\n  s: string;\n  /** attributes */\n  a: { [key: string]: any };\n  /** last_changed; if set, also applies to lu */\n  lc: number;\n  /** last_updated */\n  lu: number;\n}\n\nexport interface HistoryStreamMessage {\n  states: HistoryStates;\n  start_time?: number; // Start time of this historical chunk\n  end_time?: number; // End time of this historical chunk\n}\n\nexport const entityIdHistoryNeedsAttributes = (\n  hass: HomeAssistant,\n  entityId: string\n) =>\n  !hass.states[entityId] ||\n  NEED_ATTRIBUTE_DOMAINS.includes(computeDomain(entityId));\n\nexport const fetchDateWS = (\n  hass: HomeAssistant,\n  startTime: Date,\n  endTime: Date,\n  entityIds: string[]\n) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some((entityId) =>\n      entityIdHistoryNeedsAttributes(hass, entityId)\n    ),\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS<HistoryStates>({ ...params, entity_ids: entityIds });\n  }\n  return hass.callWS<HistoryStates>(params);\n};\n\nexport const subscribeHistory = (\n  hass: HomeAssistant,\n  callbackFunction: (data: HistoryStates) => void,\n  startTime: Date,\n  endTime: Date,\n  entityIds: string[]\n): Promise<() => Promise<void>> => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some((entityId) =>\n      entityIdHistoryNeedsAttributes(hass, entityId)\n    ),\n  };\n  const stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage<HistoryStreamMessage>(\n    (message) => callbackFunction(stream.processMessage(message)),\n    params\n  );\n};\n\nclass HistoryStream {\n  hass: HomeAssistant;\n\n  hoursToShow?: number;\n\n  combinedHistory: HistoryStates;\n\n  constructor(hass: HomeAssistant, hoursToShow?: number) {\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n\n  processMessage(streamMessage: HistoryStreamMessage): HistoryStates {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow\n      ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000\n      : undefined;\n    const newHistory: HistoryStates = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (\n        entityId in this.combinedHistory &&\n        entityId in streamMessage.states\n      ) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory =\n          entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(\n          streamMessage.states[entityId]\n        );\n        if (\n          streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu\n        ) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort(\n            (a, b) => a.lu - b.lu\n          );\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter(\n          (state) => state.lu < purgeBeforePythonTime\n        );\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter(\n          (state) => state.lu >= purgeBeforePythonTime\n        );\n        if (\n          newHistory[entityId].length &&\n          newHistory[entityId][0].lu === purgeBeforePythonTime\n        ) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\n\nexport const subscribeHistoryStatesTimeWindow = (\n  hass: HomeAssistant,\n  callbackFunction: (data: HistoryStates) => void,\n  hoursToShow: number,\n  entityIds: string[],\n  minimalResponse = true,\n  significantChangesOnly = true,\n  noAttributes?: boolean\n): Promise<() => Promise<void>> => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(\n      new Date().getTime() - 60 * 60 * hoursToShow * 1000\n    ).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes:\n      noAttributes ??\n      !entityIds.some((entityId) =>\n        entityIdHistoryNeedsAttributes(hass, entityId)\n      ),\n  };\n  const stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage<HistoryStreamMessage>(\n    (message) => callbackFunction(stream.processMessage(message)),\n    params\n  );\n};\n\nconst equalState = (obj1: LineChartState, obj2: LineChartState) =>\n  obj1.state === obj2.state &&\n  // Only compare attributes if both states have an attributes object.\n  // When `minimal_response` is sent, only the first and last state\n  // will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n  (!obj1.attributes ||\n    !obj2.attributes ||\n    LINE_ATTRIBUTES_TO_KEEP.every(\n      (attr) => obj1.attributes![attr] === obj2.attributes![attr]\n    ));\n\nconst processTimelineEntity = (\n  localize: LocalizeFunc,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entities: HomeAssistant[\"entities\"],\n  entityId: string,\n  states: EntityHistoryState[],\n  current_state: HassEntity | undefined\n): TimelineEntity => {\n  const data: TimelineState[] = [];\n  const first: EntityHistoryState = states[0];\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n\n    const currentAttributes: HassEntityAttributeBase = {};\n    if (current_state?.attributes.device_class) {\n      currentAttributes.device_class = current_state?.attributes.device_class;\n    }\n\n    data.push({\n      state_localize: computeStateDisplayFromEntityAttributes(\n        localize,\n        locale,\n        config,\n        entities[entityId],\n        entityId,\n        {\n          ...(state.a || first.a),\n          ...currentAttributes,\n        },\n        state.s\n      ),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000,\n    });\n  }\n\n  return {\n    name: computeStateNameFromEntityAttributes(\n      entityId,\n      current_state?.attributes || first.a\n    ),\n    entity_id: entityId,\n    data,\n  };\n};\n\nconst processLineChartEntities = (\n  unit: string,\n  device_class: string | undefined,\n  entities: HistoryStates,\n  hassEntities: HassEntities\n): LineChartUnit => {\n  const data: LineChartEntity[] = [];\n\n  Object.keys(entities).forEach((entityId) => {\n    const states = entities[entityId];\n    const first: EntityHistoryState = states[0];\n    const domain = computeDomain(entityId);\n    const processedStates: LineChartState[] = [];\n\n    for (const state of states) {\n      let processedState: LineChartState;\n\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {},\n        };\n\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes![attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {},\n        };\n      }\n\n      if (\n        processedStates.length > 1 &&\n        equalState(\n          processedState,\n          processedStates[processedStates.length - 1]\n        ) &&\n        equalState(processedState, processedStates[processedStates.length - 2])\n      ) {\n        continue;\n      }\n\n      processedStates.push(processedState);\n    }\n\n    const attributes =\n      entityId in hassEntities\n        ? hassEntities[entityId].attributes\n        : \"friendly_name\" in first.a\n          ? first.a\n          : undefined;\n\n    data.push({\n      domain,\n      name: computeStateNameFromEntityAttributes(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates,\n    });\n  });\n\n  return {\n    unit,\n    device_class,\n    identifier: Object.keys(entities).join(\"\"),\n    data,\n  };\n};\n\nconst NUMERICAL_DOMAINS = [\"counter\", \"input_number\", \"number\"];\n\nconst isNumericFromDomain = (domain: string) =>\n  NUMERICAL_DOMAINS.includes(domain);\n\nconst isNumericFromAttributes = (attributes: { [key: string]: any }) =>\n  \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\n\nconst isNumericSensorEntity = (\n  stateObj: HassEntity,\n  sensorNumericalDeviceClasses: string[]\n) =>\n  stateObj.attributes.device_class != null &&\n  sensorNumericalDeviceClasses.includes(stateObj.attributes.device_class);\n\nconst BLANK_UNIT = \" \";\n\nexport const computeHistory = (\n  hass: HomeAssistant,\n  stateHistory: HistoryStates,\n  localize: LocalizeFunc,\n  sensorNumericalDeviceClasses: string[],\n  splitDeviceClasses = false\n): HistoryResult => {\n  const lineChartDevices: { [unit: string]: HistoryStates } = {};\n  const timelineDevices: TimelineEntity[] = [];\n  if (!stateHistory) {\n    return { line: [], timeline: [] };\n  }\n  Object.keys(stateHistory).forEach((entityId) => {\n    const stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n\n    const domain = computeDomain(entityId);\n\n    const currentState =\n      entityId in hass.states ? hass.states[entityId] : undefined;\n    const numericStateFromHistory =\n      currentState || isNumericFromDomain(domain)\n        ? undefined\n        : stateInfo.find(\n            (state) => state.a && isNumericFromAttributes(state.a)\n          );\n\n    let unit: string | undefined;\n\n    const isNumeric =\n      isNumericFromDomain(domain) ||\n      (currentState != null &&\n        isNumericFromAttributes(currentState.attributes)) ||\n      (currentState != null &&\n        domain === \"sensor\" &&\n        isNumericSensorEntity(currentState, sensorNumericalDeviceClasses)) ||\n      numericStateFromHistory != null;\n\n    if (isNumeric) {\n      unit =\n        currentState?.attributes.unit_of_measurement ||\n        numericStateFromHistory?.a.unit_of_measurement ||\n        BLANK_UNIT;\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        humidifier: \"%\",\n        water_heater: hass.config.unit_system.temperature,\n      }[domain];\n    }\n\n    const specialDomainClasses = {\n      climate: \"temperature\",\n      humidifier: \"humidity\",\n      water_heater: \"temperature\",\n    };\n\n    const deviceClass: string | undefined =\n      specialDomainClasses[domain] ||\n      (currentState?.attributes || numericStateFromHistory?.a)?.device_class;\n\n    const key = computeGroupKey(unit, deviceClass, splitDeviceClasses);\n\n    if (!unit) {\n      timelineDevices.push(\n        processTimelineEntity(\n          localize,\n          hass.locale,\n          hass.config,\n          hass.entities,\n          entityId,\n          stateInfo,\n          currentState\n        )\n      );\n    } else if (\n      key &&\n      key in lineChartDevices &&\n      entityId in lineChartDevices[key]\n    ) {\n      lineChartDevices[key][entityId].push(...stateInfo);\n    } else if (key) {\n      if (!(key in lineChartDevices)) {\n        lineChartDevices[key] = {};\n      }\n      lineChartDevices[key][entityId] = stateInfo;\n    }\n  });\n\n  const unitStates = Object.keys(lineChartDevices).map((key) => {\n    const splitKey = key.split(\"_\");\n    const unit = splitKey[0];\n    const deviceClass = splitKey[1] || undefined;\n    return processLineChartEntities(\n      unit,\n      deviceClass,\n      lineChartDevices[key],\n      hass.states\n    );\n  });\n\n  return { line: unitStates, timeline: timelineDevices };\n};\n\nexport const computeGroupKey = (\n  unit: string | undefined,\n  device_class: string | undefined,\n  splitDeviceClasses: boolean\n) => (splitDeviceClasses ? `${unit}_${device_class || \"\"}` : unit);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}