{"ast":null,"code":"import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = {\n  unsubGrace: true\n}) => {\n  if (conn[key]) {\n    return conn[key];\n  }\n  let active = 0;\n  let unsubProm;\n  let unsubTimer;\n  let store = createStore();\n  const refresh = () => {\n    if (!fetchCollection) {\n      throw new Error(\"Collection does not support refresh\");\n    }\n    return fetchCollection(conn).then(state => store.setState(state, true));\n  };\n  const refreshSwallow = () => refresh().catch(err => {\n    // Swallow errors if socket is connecting, closing or closed.\n    // We will automatically call refresh again when we re-establish the connection.\n    if (conn.connected) {\n      throw err;\n    }\n  });\n  const setupUpdateSubscription = () => {\n    if (unsubTimer !== undefined) {\n      if (DEBUG) {\n        console.log(`Prevented unsubscribe for ${key}`);\n      }\n      clearTimeout(unsubTimer);\n      unsubTimer = undefined;\n      return;\n    }\n    if (DEBUG) {\n      console.log(`Subscribing to ${key}`);\n    }\n    if (subscribeUpdates) {\n      unsubProm = subscribeUpdates(conn, store);\n    }\n    if (fetchCollection) {\n      // Fetch when connection re-established.\n      conn.addEventListener(\"ready\", refreshSwallow);\n      refreshSwallow();\n    }\n    conn.addEventListener(\"disconnected\", handleDisconnect);\n  };\n  const teardownUpdateSubscription = () => {\n    if (DEBUG) {\n      console.log(`Unsubscribing from ${key}`);\n    }\n    unsubTimer = undefined;\n    // Unsubscribe from changes\n    if (unsubProm) unsubProm.then(unsub => {\n      unsub();\n    });\n    store.clearState();\n    conn.removeEventListener(\"ready\", refresh);\n    conn.removeEventListener(\"disconnected\", handleDisconnect);\n  };\n  const scheduleTeardownUpdateSubscription = () => {\n    if (DEBUG) {\n      console.log(`Scheduling unsubscribing from ${key}`);\n    }\n    unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n  };\n  const handleDisconnect = () => {\n    // If we're going to unsubscribe and then lose connection,\n    // just unsubscribe immediately.\n    if (unsubTimer) {\n      clearTimeout(unsubTimer);\n      teardownUpdateSubscription();\n    }\n  };\n  conn[key] = {\n    get state() {\n      return store.state;\n    },\n    refresh,\n    subscribe(subscriber) {\n      active++;\n      if (DEBUG) {\n        console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n      }\n      // If this was the first subscriber, attach collection\n      if (active === 1) {\n        setupUpdateSubscription();\n      }\n      const unsub = store.subscribe(subscriber);\n      if (store.state !== undefined) {\n        // Don't call it right away so that caller has time\n        // to initialize all the things.\n        setTimeout(() => subscriber(store.state), 0);\n      }\n      return () => {\n        unsub();\n        active--;\n        if (DEBUG) {\n          console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n        }\n        if (!active) {\n          options.unsubGrace ? scheduleTeardownUpdateSubscription() : teardownUpdateSubscription();\n        }\n      };\n    }\n  };\n  return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);","map":{"version":3,"names":["createStore","UNSUB_GRACE_PERIOD","DEBUG","getCollection","conn","key","fetchCollection","subscribeUpdates","options","unsubGrace","active","unsubProm","unsubTimer","store","refresh","Error","then","state","setState","refreshSwallow","catch","err","connected","setupUpdateSubscription","undefined","console","log","clearTimeout","addEventListener","handleDisconnect","teardownUpdateSubscription","unsub","clearState","removeEventListener","scheduleTeardownUpdateSubscription","setTimeout","subscribe","subscriber","createCollection","onChange"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    if (conn[key]) {\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}