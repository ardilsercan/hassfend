{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.is.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport var ValueNotifier = /*#__PURE__*/function () {\n  function ValueNotifier(defaultValue) {\n    var _this = this;\n    _classCallCheck(this, ValueNotifier);\n    this.subscriptions = new Map();\n    this.updateObservers = function () {\n      var _iterator = _createForOfIteratorHelper(_this.subscriptions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            callback = _step$value[0],\n            disposer = _step$value[1].disposer;\n          callback(_this._value, disposer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n  _createClass(ValueNotifier, [{\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    },\n    set: function set(v) {\n      this.setValue(v);\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(v) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var update = force || !Object.is(v, this._value);\n      this._value = v;\n      if (update) {\n        this.updateObservers();\n      }\n    }\n  }, {\n    key: \"addCallback\",\n    value: function addCallback(callback, consumerHost, subscribe) {\n      var _this2 = this;\n      if (!subscribe) {\n        // just call the callback once and we're done\n        callback(this.value);\n        return;\n      }\n      if (!this.subscriptions.has(callback)) {\n        this.subscriptions.set(callback, {\n          disposer: function disposer() {\n            _this2.subscriptions.delete(callback);\n          },\n          consumerHost: consumerHost\n        });\n      }\n      var _this$subscriptions$g = this.subscriptions.get(callback),\n        disposer = _this$subscriptions$g.disposer;\n      callback(this.value, disposer);\n    }\n  }, {\n    key: \"clearCallbacks\",\n    value: function clearCallbacks() {\n      this.subscriptions.clear();\n    }\n  }]);\n  return ValueNotifier;\n}();","map":{"version":3,"names":["ValueNotifier","defaultValue","_this","_classCallCheck","subscriptions","Map","updateObservers","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","callback","disposer","_value","err","e","f","undefined","_createClass","key","get","set","v","setValue","force","arguments","length","update","Object","is","addCallback","consumerHost","subscribe","_this2","has","delete","_this$subscriptions$g","clearCallbacks","clear"],"sources":["../../src/lib/value-notifier.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions: Map<ContextCallback<T>, CallbackInfo> =\n    new Map();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, {disposer}] of this.subscriptions) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean\n  ): void {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n      });\n    }\n    const {disposer} = this.subscriptions.get(callback)!;\n    callback(this.value, disposer);\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n"],"mappings":";;;;;;;;;;AAAA;;;;;AAkBA;;;;;;;;AAQA,WAAaA,aAAa;EAmBxB,SAAAA,cAAYC,YAAgB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAH,aAAA;IAlBT,KAAAI,aAAa,GAC9B,IAAIC,GAAG,EAAE;IAuBX,KAAAC,eAAe,GAAG,YAAW;MAAA,IAAAC,SAAA,GAAAC,0BAAA,CACUN,KAAI,CAACE,aAAa;QAAAK,KAAA;MAAA;QAAvD,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAyD;UAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAL,KAAA,CAAAM,KAAA;YAA7CC,QAAQ,GAAAH,WAAA;YAAGI,QAAQ,GAAAJ,WAAA,IAARI,QAAQ;UAC7BD,QAAQ,CAACd,KAAI,CAACgB,MAAM,EAAED,QAAQ,CAAC;;MAChC,SAAAE,GAAA;QAAAZ,SAAA,CAAAa,CAAA,CAAAD,GAAA;MAAA;QAAAZ,SAAA,CAAAc,CAAA;MAAA;IACH,CAAC;IATC,IAAIpB,YAAY,KAAKqB,SAAS,EAAE;MAC9B,IAAI,CAACP,KAAK,GAAGd,YAAY;;EAE7B;EAACsB,YAAA,CAAAvB,aAAA;IAAAwB,GAAA;IAAAC,GAAA,EAnBD,SAAAA,IAAA,EAAS;MACP,OAAO,IAAI,CAACP,MAAM;IACpB,CAAC;IAAAQ,GAAA,EACD,SAAAA,IAAUC,CAAI;MACZ,IAAI,CAACC,QAAQ,CAACD,CAAC,CAAC;IAClB;EAAC;IAAAH,GAAA;IAAAT,KAAA,EAED,SAAAa,SAASD,CAAI,EAAe;MAAA,IAAbE,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAR,SAAA,GAAAQ,SAAA,MAAG,KAAK;MAC1B,IAAME,MAAM,GAAGH,KAAK,IAAI,CAACI,MAAM,CAACC,EAAE,CAACP,CAAC,EAAE,IAAI,CAACT,MAAM,CAAC;MAClD,IAAI,CAACA,MAAM,GAAGS,CAAC;MACf,IAAIK,MAAM,EAAE;QACV,IAAI,CAAC1B,eAAe,EAAE;;IAE1B;EAAC;IAAAkB,GAAA;IAAAT,KAAA,EAcD,SAAAoB,YACEnB,QAA4B,EAC5BoB,YAAqB,EACrBC,SAAmB;MAAA,IAAAC,MAAA;MAEnB,IAAI,CAACD,SAAS,EAAE;QACd;QACArB,QAAQ,CAAC,IAAI,CAACD,KAAK,CAAC;QACpB;;MAEF,IAAI,CAAC,IAAI,CAACX,aAAa,CAACmC,GAAG,CAACvB,QAAQ,CAAC,EAAE;QACrC,IAAI,CAACZ,aAAa,CAACsB,GAAG,CAACV,QAAQ,EAAE;UAC/BC,QAAQ,EAAE,SAAAA,SAAA,EAAK;YACbqB,MAAI,CAAClC,aAAa,CAACoC,MAAM,CAACxB,QAAQ,CAAC;UACrC,CAAC;UACDoB,YAAY,EAAZA;SACD,CAAC;;MAEJ,IAAAK,qBAAA,GAAmB,IAAI,CAACrC,aAAa,CAACqB,GAAG,CAACT,QAAQ,CAAE;QAA7CC,QAAQ,GAAAwB,qBAAA,CAARxB,QAAQ;MACfD,QAAQ,CAAC,IAAI,CAACD,KAAK,EAAEE,QAAQ,CAAC;IAChC;EAAC;IAAAO,GAAA;IAAAT,KAAA,EAED,SAAA2B,eAAA,EAAc;MACZ,IAAI,CAACtC,aAAa,CAACuC,KAAK,EAAE;IAC5B;EAAC;EAAA,OAAA3C,aAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}