{"ast":null,"code":"import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _decorate from \"@babel/runtime/helpers/decorate\";\nvar _templateObject;\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { html, LitElement } from \"lit\";\nimport { property, query, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport { formatNumber, numberFormatToLocale, getNumberFormatOptions } from \"../../common/number/format_number\";\nimport { MIN_TIME_BETWEEN_UPDATES } from \"./ha-chart-base\";\nvar safeParseFloat = function safeParseFloat(value) {\n  var parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\nexport var StateHistoryChartLine = _decorate(null, function (_initialize, _LitElement) {\n  var StateHistoryChartLine = /*#__PURE__*/function (_LitElement2) {\n    _inherits(StateHistoryChartLine, _LitElement2);\n    function StateHistoryChartLine() {\n      var _this;\n      _classCallCheck(this, StateHistoryChartLine);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, StateHistoryChartLine, [].concat(args));\n      _initialize(_assertThisInitialized(_this));\n      return _this;\n    }\n    return _createClass(StateHistoryChartLine);\n  }(_LitElement);\n  return {\n    F: StateHistoryChartLine,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"data\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"names\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"identifier\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"showNames\",\n      value: function value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"clickForMoreInfo\",\n      value: function value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"startTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"paddingYAxis\",\n      value: function value() {\n        return 0;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"chartIndex\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"logarithmicScale\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"minYAxis\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"maxYAxis\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"fitYData\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_entityIds\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_datasetToDataIndex\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_yWidth\",\n      value: function value() {\n        return 0;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_chartTime\",\n      value: function value() {\n        return new Date();\n      }\n    }, {\n      kind: \"field\",\n      decorators: [query(\"ha-chart-base\")],\n      key: \"_chart\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"resize\",\n      value: function value() {\n        var _this2 = this;\n        return function (options) {\n          var _this2$_chart;\n          (_this2$_chart = _this2._chart) === null || _this2$_chart === void 0 || _this2$_chart.resize(options);\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <ha-chart-base\\n        .hass=\", \"\\n        .data=\", \"\\n        .options=\", \"\\n        .paddingYAxis=\", \"\\n        chart-type=\\\"line\\\"\\n      ></ha-chart-base>\\n    \"])), this.hass, this._chartData, this._chartOptions, this.paddingYAxis - this._yWidth);\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        var _this3 = this;\n        if (!this.hasUpdated || changedProps.has(\"showNames\") || changedProps.has(\"startTime\") || changedProps.has(\"endTime\") || changedProps.has(\"unit\") || changedProps.has(\"logarithmicScale\") || changedProps.has(\"minYAxis\") || changedProps.has(\"maxYAxis\") || changedProps.has(\"fitYData\")) {\n          this._chartOptions = {\n            parsing: false,\n            animation: false,\n            interaction: {\n              mode: \"nearest\",\n              axis: \"xy\"\n            },\n            scales: {\n              x: {\n                type: \"time\",\n                adapters: {\n                  date: {\n                    locale: this.hass.locale,\n                    config: this.hass.config\n                  }\n                },\n                suggestedMin: this.startTime,\n                suggestedMax: this.endTime,\n                ticks: {\n                  maxRotation: 0,\n                  sampleSize: 5,\n                  autoSkipPadding: 20,\n                  major: {\n                    enabled: true\n                  },\n                  font: function font(context) {\n                    return context.tick && context.tick.major ? {\n                      weight: \"bold\"\n                    } : {};\n                  }\n                },\n                time: {\n                  tooltipFormat: \"datetimeseconds\"\n                }\n              },\n              y: {\n                suggestedMin: this.fitYData ? this.minYAxis : null,\n                suggestedMax: this.fitYData ? this.maxYAxis : null,\n                min: this.fitYData ? null : this.minYAxis,\n                max: this.fitYData ? null : this.maxYAxis,\n                ticks: {\n                  maxTicksLimit: 7\n                },\n                title: {\n                  display: true,\n                  text: this.unit\n                },\n                afterUpdate: function afterUpdate(y) {\n                  if (_this3._yWidth !== Math.floor(y.width)) {\n                    _this3._yWidth = Math.floor(y.width);\n                    fireEvent(_this3, \"y-width-changed\", {\n                      value: _this3._yWidth,\n                      chartIndex: _this3.chartIndex\n                    });\n                  }\n                },\n                position: computeRTL(this.hass) ? \"right\" : \"left\",\n                type: this.logarithmicScale ? \"logarithmic\" : \"linear\"\n              }\n            },\n            plugins: {\n              tooltip: {\n                callbacks: {\n                  label: function label(context) {\n                    var label = \"\".concat(context.dataset.label, \": \").concat(formatNumber(context.parsed.y, _this3.hass.locale, getNumberFormatOptions(undefined, _this3.hass.entities[_this3._entityIds[context.datasetIndex]])), \" \").concat(_this3.unit);\n                    var dataIndex = _this3._datasetToDataIndex[context.datasetIndex];\n                    var data = _this3.data[dataIndex];\n                    if (data.statistics && data.statistics.length > 0) {\n                      var source = data.states.length === 0 || context.parsed.x < data.states[0].last_changed ? \"\\n\".concat(_this3.hass.localize(\"ui.components.history_charts.source_stats\")) : \"\\n\".concat(_this3.hass.localize(\"ui.components.history_charts.source_history\"));\n                      label += source;\n                    }\n                    return label;\n                  }\n                }\n              },\n              filler: {\n                propagate: true\n              },\n              legend: {\n                display: this.showNames,\n                labels: {\n                  usePointStyle: true\n                }\n              }\n            },\n            elements: {\n              line: {\n                tension: 0.1,\n                borderWidth: 1.5\n              },\n              point: {\n                hitRadius: 50\n              }\n            },\n            segment: {\n              borderColor: function borderColor(context) {\n                // render stat data with a slightly transparent line\n                var dataIndex = _this3._datasetToDataIndex[context.datasetIndex];\n                var data = _this3.data[dataIndex];\n                return data.statistics && data.statistics.length > 0 && (data.states.length === 0 || context.p0.parsed.x < data.states[0].last_changed) ? _this3._chartData.datasets[dataIndex].borderColor + \"7F\" : undefined;\n              }\n            },\n            // @ts-expect-error\n            locale: numberFormatToLocale(this.hass.locale),\n            onClick: function onClick(e) {\n              if (!_this3.clickForMoreInfo || !(e.native instanceof MouseEvent) || e.native instanceof PointerEvent && e.native.pointerType !== \"mouse\") {\n                return;\n              }\n              var chart = e.chart;\n              var points = chart.getElementsAtEventForMode(e, \"nearest\", {\n                intersect: true\n              }, true);\n              if (points.length) {\n                var firstPoint = points[0];\n                fireEvent(_this3, \"hass-more-info\", {\n                  entityId: _this3._entityIds[firstPoint.datasetIndex]\n                });\n                chart.canvas.dispatchEvent(new Event(\"mouseout\")); // to hide tooltip\n              }\n            }\n          };\n        }\n        if (changedProps.has(\"data\") || changedProps.has(\"startTime\") || changedProps.has(\"endTime\") || this._chartTime < new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)) {\n          // If the line is more than 5 minutes old, re-gen it\n          // so the X axis grows even if there is no new data\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: function _generateData() {\n        var _this4 = this;\n        var colorIndex = 0;\n        var computedStyles = getComputedStyle(this);\n        var entityStates = this.data;\n        var datasets = [];\n        var entityIds = [];\n        var datasetToDataIndex = [];\n        if (entityStates.length === 0) {\n          return;\n        }\n        this._chartTime = new Date();\n        var endTime = this.endTime;\n        var names = this.names || {};\n        entityStates.forEach(function (states, dataIdx) {\n          var domain = states.domain;\n          var name = names[states.entity_id] || states.name;\n          // array containing [value1, value2, etc]\n          var prevValues = null;\n          var data = [];\n          var pushData = function pushData(timestamp, datavalues) {\n            if (!datavalues) return;\n            if (timestamp > endTime) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n            data.forEach(function (d, i) {\n              if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n                // null data values show up as gaps in the chart.\n                // If the current value for the dataset is null and the previous\n                // value of the data set is not null, then add an 'end' point\n                // to the chart for the previous value. Otherwise the gap will\n                // be too big. It will go from the start of the previous data\n                // value until the start of the next data value.\n                d.data.push({\n                  x: timestamp.getTime(),\n                  y: prevValues[i]\n                });\n              }\n              d.data.push({\n                x: timestamp.getTime(),\n                y: datavalues[i]\n              });\n            });\n            prevValues = datavalues;\n          };\n          var addDataSet = function addDataSet(nameY) {\n            var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            var color = arguments.length > 2 ? arguments[2] : undefined;\n            if (!color) {\n              color = getGraphColorByIndex(colorIndex, computedStyles);\n              colorIndex++;\n            }\n            data.push({\n              label: nameY,\n              fill: fill ? \"origin\" : false,\n              borderColor: color,\n              backgroundColor: color + \"7F\",\n              stepped: \"before\",\n              pointRadius: 0,\n              data: []\n            });\n            entityIds.push(states.entity_id);\n            datasetToDataIndex.push(dataIdx);\n          };\n          if (domain === \"thermostat\" || domain === \"climate\" || domain === \"water_heater\") {\n            var hasHvacAction = states.states.some(function (entityState) {\n              var _entityState$attribut;\n              return (_entityState$attribut = entityState.attributes) === null || _entityState$attribut === void 0 ? void 0 : _entityState$attribut.hvac_action;\n            });\n            var isHeating = domain === \"climate\" && hasHvacAction ? function (entityState) {\n              var _entityState$attribut2;\n              return ((_entityState$attribut2 = entityState.attributes) === null || _entityState$attribut2 === void 0 ? void 0 : _entityState$attribut2.hvac_action) === \"heating\";\n            } : function (entityState) {\n              return entityState.state === \"heat\";\n            };\n            var isCooling = domain === \"climate\" && hasHvacAction ? function (entityState) {\n              var _entityState$attribut3;\n              return ((_entityState$attribut3 = entityState.attributes) === null || _entityState$attribut3 === void 0 ? void 0 : _entityState$attribut3.hvac_action) === \"cooling\";\n            } : function (entityState) {\n              return entityState.state === \"cool\";\n            };\n            var hasHeat = states.states.some(isHeating);\n            var hasCool = states.states.some(isCooling);\n            // We differentiate between thermostats that have a target temperature\n            // range versus ones that have just a target temperature\n\n            // Using step chart by step-before so manually interpolation not needed.\n            var hasTargetRange = states.states.some(function (entityState) {\n              return entityState.attributes && entityState.attributes.target_temp_high !== entityState.attributes.target_temp_low;\n            });\n            addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.current_temperature\", {\n              name: name\n            })));\n            if (hasHeat) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.heating\", {\n                name: name\n              })), true, computedStyles.getPropertyValue(\"--state-climate-heat-color\"));\n              // The \"heating\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n            if (hasCool) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.cooling\", {\n                name: name\n              })), true, computedStyles.getPropertyValue(\"--state-climate-cool-color\"));\n              // The \"cooling\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n            if (hasTargetRange) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: _this4.hass.localize(\"ui.card.climate.high\")\n              })));\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: _this4.hass.localize(\"ui.card.climate.low\")\n              })));\n            } else {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n                name: name\n              })));\n            }\n            states.states.forEach(function (entityState) {\n              if (!entityState.attributes) return;\n              var curTemp = safeParseFloat(entityState.attributes.current_temperature);\n              var series = [curTemp];\n              if (hasHeat) {\n                series.push(isHeating(entityState) ? curTemp : null);\n              }\n              if (hasCool) {\n                series.push(isCooling(entityState) ? curTemp : null);\n              }\n              if (hasTargetRange) {\n                var targetHigh = safeParseFloat(entityState.attributes.target_temp_high);\n                var targetLow = safeParseFloat(entityState.attributes.target_temp_low);\n                series.push(targetHigh, targetLow);\n                pushData(new Date(entityState.last_changed), series);\n              } else {\n                var target = safeParseFloat(entityState.attributes.temperature);\n                series.push(target);\n                pushData(new Date(entityState.last_changed), series);\n              }\n            });\n          } else if (domain === \"humidifier\") {\n            var hasAction = states.states.some(function (entityState) {\n              var _entityState$attribut4;\n              return (_entityState$attribut4 = entityState.attributes) === null || _entityState$attribut4 === void 0 ? void 0 : _entityState$attribut4.action;\n            });\n            var hasCurrent = states.states.some(function (entityState) {\n              var _entityState$attribut5;\n              return (_entityState$attribut5 = entityState.attributes) === null || _entityState$attribut5 === void 0 ? void 0 : _entityState$attribut5.current_humidity;\n            });\n            var hasHumidifying = hasAction && states.states.some(function (entityState) {\n              var _entityState$attribut6;\n              return ((_entityState$attribut6 = entityState.attributes) === null || _entityState$attribut6 === void 0 ? void 0 : _entityState$attribut6.action) === \"humidifying\";\n            });\n            var hasDrying = hasAction && states.states.some(function (entityState) {\n              var _entityState$attribut7;\n              return ((_entityState$attribut7 = entityState.attributes) === null || _entityState$attribut7 === void 0 ? void 0 : _entityState$attribut7.action) === \"drying\";\n            });\n            addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n              name: name\n            })));\n            if (hasCurrent) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.humidifier.current_humidity_entity\", {\n                name: name\n              })));\n            }\n\n            // If action attribute is available, we used it to shade the area below the humidity.\n            // If action attribute is not available, we shade the area when the device is on\n            if (hasHumidifying) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.humidifier.humidifying\", {\n                name: name\n              })), true, computedStyles.getPropertyValue(\"--state-humidifier-on-color\"));\n            } else if (hasDrying) {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.humidifier.drying\", {\n                name: name\n              })), true, computedStyles.getPropertyValue(\"--state-humidifier-on-color\"));\n            } else {\n              addDataSet(\"\".concat(_this4.hass.localize(\"ui.card.humidifier.on_entity\", {\n                name: name\n              })), true);\n            }\n            states.states.forEach(function (entityState) {\n              var _entityState$attribut8;\n              if (!entityState.attributes) return;\n              var target = safeParseFloat(entityState.attributes.humidity);\n              // If the current humidity is not available, then we fill up to the target humidity\n              var current = hasCurrent ? safeParseFloat((_entityState$attribut8 = entityState.attributes) === null || _entityState$attribut8 === void 0 ? void 0 : _entityState$attribut8.current_humidity) : target;\n              var series = [target];\n              if (hasCurrent) {\n                series.push(current);\n              }\n              if (hasHumidifying) {\n                var _entityState$attribut9;\n                series.push(((_entityState$attribut9 = entityState.attributes) === null || _entityState$attribut9 === void 0 ? void 0 : _entityState$attribut9.action) === \"humidifying\" ? current : null);\n              } else if (hasDrying) {\n                var _entityState$attribut10;\n                series.push(((_entityState$attribut10 = entityState.attributes) === null || _entityState$attribut10 === void 0 ? void 0 : _entityState$attribut10.action) === \"drying\" ? current : null);\n              } else {\n                series.push(entityState.state === \"on\" ? current : null);\n              }\n              pushData(new Date(entityState.last_changed), series);\n            });\n          } else {\n            addDataSet(name);\n            var lastValue;\n            var lastDate;\n            var lastNullDate = null;\n\n            // Process chart data.\n            // When state is `unknown`, calculate the value and break the line.\n            var processData = function processData(entityState) {\n              var value = safeParseFloat(entityState.state);\n              var date = new Date(entityState.last_changed);\n              if (value !== null && lastNullDate) {\n                var _lastDate;\n                var dateTime = date.getTime();\n                var lastNullDateTime = lastNullDate.getTime();\n                var lastDateTime = (_lastDate = lastDate) === null || _lastDate === void 0 ? void 0 : _lastDate.getTime();\n                var tmpValue = (value - lastValue) * ((lastNullDateTime - lastDateTime) / (dateTime - lastDateTime)) + lastValue;\n                pushData(lastNullDate, [tmpValue]);\n                pushData(new Date(lastNullDateTime + 1), [null]);\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n                lastNullDate = null;\n              } else if (value !== null && lastNullDate === null) {\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n              } else if (value === null && lastNullDate === null && lastValue !== undefined) {\n                lastNullDate = date;\n              }\n            };\n            if (states.statistics) {\n              var stopTime = !states.states || states.states.length === 0 ? 0 : states.states[0].last_changed;\n              for (var i = 0; i < states.statistics.length; i++) {\n                if (stopTime && states.statistics[i].last_changed >= stopTime) {\n                  break;\n                }\n                processData(states.statistics[i]);\n              }\n            }\n            states.states.forEach(function (entityState) {\n              processData(entityState);\n            });\n            if (lastNullDate !== null) {\n              pushData(lastNullDate, [null]);\n            }\n          }\n\n          // Add an entry for final values\n          pushData(endTime, prevValues);\n\n          // Concat two arrays\n          Array.prototype.push.apply(datasets, data);\n        });\n        this._chartData = {\n          datasets: datasets\n        };\n        this._entityIds = entityIds;\n        this._datasetToDataIndex = datasetToDataIndex;\n      }\n    }]\n  };\n}, LitElement);\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);","map":{"version":3,"names":["html","LitElement","property","query","state","getGraphColorByIndex","fireEvent","computeRTL","formatNumber","numberFormatToLocale","getNumberFormatOptions","MIN_TIME_BETWEEN_UPDATES","safeParseFloat","value","parsed","parseFloat","isFinite","StateHistoryChartLine","_decorate","_initialize","_LitElement","_LitElement2","_inherits","_this","_classCallCheck","_len","arguments","length","args","Array","_key","_callSuper","concat","_assertThisInitialized","_createClass","F","d","kind","decorators","attribute","key","type","Boolean","Number","Date","_this2","options","_this2$_chart","_chart","resize","render","_templateObject","_taggedTemplateLiteral","hass","_chartData","_chartOptions","paddingYAxis","_yWidth","willUpdate","changedProps","_this3","hasUpdated","has","parsing","animation","interaction","mode","axis","scales","x","adapters","date","locale","config","suggestedMin","startTime","suggestedMax","endTime","ticks","maxRotation","sampleSize","autoSkipPadding","major","enabled","font","context","tick","weight","time","tooltipFormat","y","fitYData","minYAxis","maxYAxis","min","max","maxTicksLimit","title","display","text","unit","afterUpdate","Math","floor","width","chartIndex","position","logarithmicScale","plugins","tooltip","callbacks","label","dataset","undefined","entities","_entityIds","datasetIndex","dataIndex","_datasetToDataIndex","data","statistics","source","states","last_changed","localize","filler","propagate","legend","showNames","labels","usePointStyle","elements","line","tension","borderWidth","point","hitRadius","segment","borderColor","p0","datasets","onClick","e","clickForMoreInfo","native","MouseEvent","PointerEvent","pointerType","chart","points","getElementsAtEventForMode","intersect","firstPoint","entityId","canvas","dispatchEvent","Event","_chartTime","getTime","_generateData","_this4","colorIndex","computedStyles","getComputedStyle","entityStates","entityIds","datasetToDataIndex","names","forEach","dataIdx","domain","name","entity_id","prevValues","pushData","timestamp","datavalues","i","push","addDataSet","nameY","fill","color","backgroundColor","stepped","pointRadius","hasHvacAction","some","entityState","_entityState$attribut","attributes","hvac_action","isHeating","_entityState$attribut2","isCooling","_entityState$attribut3","hasHeat","hasCool","hasTargetRange","target_temp_high","target_temp_low","getPropertyValue","curTemp","current_temperature","series","targetHigh","targetLow","target","temperature","hasAction","_entityState$attribut4","action","hasCurrent","_entityState$attribut5","current_humidity","hasHumidifying","_entityState$attribut6","hasDrying","_entityState$attribut7","_entityState$attribut8","humidity","current","_entityState$attribut9","_entityState$attribut10","lastValue","lastDate","lastNullDate","processData","_lastDate","dateTime","lastNullDateTime","lastDateTime","tmpValue","stopTime","prototype","apply","customElements","define"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/chart/state-history-chart-line.ts"],"sourcesContent":["import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { html, LitElement, PropertyValues } from \"lit\";\nimport { property, query, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n  getNumberFormatOptions,\n} from \"../../common/number/format_number\";\nimport { LineChartEntity, LineChartState } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport {\n  ChartResizeOptions,\n  HaChartBase,\n  MIN_TIME_BETWEEN_UPDATES,\n} from \"./ha-chart-base\";\n\nconst safeParseFloat = (value) => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\n\nexport class StateHistoryChartLine extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: LineChartEntity[] = [];\n\n  @property({ attribute: false }) public names?: Record<string, string>;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public showNames = true;\n\n  @property({ type: Boolean }) public clickForMoreInfo = true;\n\n  @property({ attribute: false }) public startTime!: Date;\n\n  @property({ attribute: false }) public endTime!: Date;\n\n  @property({ type: Number }) public paddingYAxis = 0;\n\n  @property({ type: Number }) public chartIndex?;\n\n  @property({ type: Boolean }) public logarithmicScale = false;\n\n  @property({ type: Number }) public minYAxis?: number;\n\n  @property({ type: Number }) public maxYAxis?: number;\n\n  @property({ type: Boolean }) public fitYData = false;\n\n  @state() private _chartData?: ChartData<\"line\">;\n\n  @state() private _entityIds: string[] = [];\n\n  private _datasetToDataIndex: number[] = [];\n\n  @state() private _chartOptions?: ChartOptions;\n\n  @state() private _yWidth = 0;\n\n  private _chartTime: Date = new Date();\n\n  @query(\"ha-chart-base\") private _chart?: HaChartBase;\n\n  public resize = (options?: ChartResizeOptions): void => {\n    this._chart?.resize(options);\n  };\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .paddingYAxis=${this.paddingYAxis - this._yWidth}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (\n      !this.hasUpdated ||\n      changedProps.has(\"showNames\") ||\n      changedProps.has(\"startTime\") ||\n      changedProps.has(\"endTime\") ||\n      changedProps.has(\"unit\") ||\n      changedProps.has(\"logarithmicScale\") ||\n      changedProps.has(\"minYAxis\") ||\n      changedProps.has(\"maxYAxis\") ||\n      changedProps.has(\"fitYData\")\n    ) {\n      this._chartOptions = {\n        parsing: false,\n        animation: false,\n        interaction: {\n          mode: \"nearest\",\n          axis: \"xy\",\n        },\n        scales: {\n          x: {\n            type: \"time\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n                config: this.hass.config,\n              },\n            },\n            suggestedMin: this.startTime,\n            suggestedMax: this.endTime,\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            suggestedMin: this.fitYData ? this.minYAxis : null,\n            suggestedMax: this.fitYData ? this.maxYAxis : null,\n            min: this.fitYData ? null : this.minYAxis,\n            max: this.fitYData ? null : this.maxYAxis,\n            ticks: {\n              maxTicksLimit: 7,\n            },\n            title: {\n              display: true,\n              text: this.unit,\n            },\n            afterUpdate: (y) => {\n              if (this._yWidth !== Math.floor(y.width)) {\n                this._yWidth = Math.floor(y.width);\n                fireEvent(this, \"y-width-changed\", {\n                  value: this._yWidth,\n                  chartIndex: this.chartIndex,\n                });\n              }\n            },\n            position: computeRTL(this.hass) ? \"right\" : \"left\",\n            type: this.logarithmicScale ? \"logarithmic\" : \"linear\",\n          },\n        },\n        plugins: {\n          tooltip: {\n            callbacks: {\n              label: (context) => {\n                let label = `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  this.hass.locale,\n                  getNumberFormatOptions(\n                    undefined,\n                    this.hass.entities[this._entityIds[context.datasetIndex]]\n                  )\n                )} ${this.unit}`;\n                const dataIndex =\n                  this._datasetToDataIndex[context.datasetIndex];\n                const data = this.data[dataIndex];\n                if (data.statistics && data.statistics.length > 0) {\n                  const source =\n                    data.states.length === 0 ||\n                    context.parsed.x < data.states[0].last_changed\n                      ? `\\n${this.hass.localize(\n                          \"ui.components.history_charts.source_stats\"\n                        )}`\n                      : `\\n${this.hass.localize(\n                          \"ui.components.history_charts.source_history\"\n                        )}`;\n                  label += source;\n                }\n                return label;\n              },\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n          legend: {\n            display: this.showNames,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        elements: {\n          line: {\n            tension: 0.1,\n            borderWidth: 1.5,\n          },\n          point: {\n            hitRadius: 50,\n          },\n        },\n        segment: {\n          borderColor: (context) => {\n            // render stat data with a slightly transparent line\n            const dataIndex = this._datasetToDataIndex[context.datasetIndex];\n            const data = this.data[dataIndex];\n            return data.statistics &&\n              data.statistics.length > 0 &&\n              (data.states.length === 0 ||\n                context.p0.parsed.x < data.states[0].last_changed)\n              ? this._chartData!.datasets[dataIndex].borderColor + \"7F\"\n              : undefined;\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n        onClick: (e: any) => {\n          if (\n            !this.clickForMoreInfo ||\n            !(e.native instanceof MouseEvent) ||\n            (e.native instanceof PointerEvent &&\n              e.native.pointerType !== \"mouse\")\n          ) {\n            return;\n          }\n\n          const chart = e.chart;\n\n          const points = chart.getElementsAtEventForMode(\n            e,\n            \"nearest\",\n            { intersect: true },\n            true\n          );\n\n          if (points.length) {\n            const firstPoint = points[0];\n            fireEvent(this, \"hass-more-info\", {\n              entityId: this._entityIds[firstPoint.datasetIndex],\n            });\n            chart.canvas.dispatchEvent(new Event(\"mouseout\")); // to hide tooltip\n          }\n        },\n      };\n    }\n    if (\n      changedProps.has(\"data\") ||\n      changedProps.has(\"startTime\") ||\n      changedProps.has(\"endTime\") ||\n      this._chartTime <\n        new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)\n    ) {\n      // If the line is more than 5 minutes old, re-gen it\n      // so the X axis grows even if there is no new data\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    let colorIndex = 0;\n    const computedStyles = getComputedStyle(this);\n    const entityStates = this.data;\n    const datasets: ChartDataset<\"line\">[] = [];\n    const entityIds: string[] = [];\n    const datasetToDataIndex: number[] = [];\n    if (entityStates.length === 0) {\n      return;\n    }\n\n    this._chartTime = new Date();\n    const endTime = this.endTime;\n    const names = this.names || {};\n    entityStates.forEach((states, dataIdx) => {\n      const domain = states.domain;\n      const name = names[states.entity_id] || states.name;\n      // array containing [value1, value2, etc]\n      let prevValues: any[] | null = null;\n\n      const data: ChartDataset<\"line\">[] = [];\n\n      const pushData = (timestamp: Date, datavalues: any[] | null) => {\n        if (!datavalues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        data.forEach((d, i) => {\n          if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i] });\n          }\n          d.data.push({ x: timestamp.getTime(), y: datavalues[i] });\n        });\n        prevValues = datavalues;\n      };\n\n      const addDataSet = (nameY: string, fill = false, color?: string) => {\n        if (!color) {\n          color = getGraphColorByIndex(colorIndex, computedStyles);\n          colorIndex++;\n        }\n        data.push({\n          label: nameY,\n          fill: fill ? \"origin\" : false,\n          borderColor: color,\n          backgroundColor: color + \"7F\",\n          stepped: \"before\",\n          pointRadius: 0,\n          data: [],\n        });\n        entityIds.push(states.entity_id);\n        datasetToDataIndex.push(dataIdx);\n      };\n\n      if (\n        domain === \"thermostat\" ||\n        domain === \"climate\" ||\n        domain === \"water_heater\"\n      ) {\n        const hasHvacAction = states.states.some(\n          (entityState) => entityState.attributes?.hvac_action\n        );\n\n        const isHeating =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"heating\"\n            : (entityState: LineChartState) => entityState.state === \"heat\";\n        const isCooling =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"cooling\"\n            : (entityState: LineChartState) => entityState.state === \"cool\";\n\n        const hasHeat = states.states.some(isHeating);\n        const hasCool = states.states.some(isCooling);\n        // We differentiate between thermostats that have a target temperature\n        // range versus ones that have just a target temperature\n\n        // Using step chart by step-before so manually interpolation not needed.\n        const hasTargetRange = states.states.some(\n          (entityState) =>\n            entityState.attributes &&\n            entityState.attributes.target_temp_high !==\n              entityState.attributes.target_temp_low\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.climate.current_temperature\", {\n            name: name,\n          })}`\n        );\n        if (hasHeat) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.heating\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-heat-color\")\n          );\n          // The \"heating\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n        if (hasCool) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.cooling\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-cool-color\")\n          );\n          // The \"cooling\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n\n        if (hasTargetRange) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.high\"),\n            })}`\n          );\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.low\"),\n            })}`\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n              name: name,\n            })}`\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const curTemp = safeParseFloat(\n            entityState.attributes.current_temperature\n          );\n          const series = [curTemp];\n          if (hasHeat) {\n            series.push(isHeating(entityState) ? curTemp : null);\n          }\n          if (hasCool) {\n            series.push(isCooling(entityState) ? curTemp : null);\n          }\n          if (hasTargetRange) {\n            const targetHigh = safeParseFloat(\n              entityState.attributes.target_temp_high\n            );\n            const targetLow = safeParseFloat(\n              entityState.attributes.target_temp_low\n            );\n            series.push(targetHigh, targetLow);\n            pushData(new Date(entityState.last_changed), series);\n          } else {\n            const target = safeParseFloat(entityState.attributes.temperature);\n            series.push(target);\n            pushData(new Date(entityState.last_changed), series);\n          }\n        });\n      } else if (domain === \"humidifier\") {\n        const hasAction = states.states.some(\n          (entityState) => entityState.attributes?.action\n        );\n        const hasCurrent = states.states.some(\n          (entityState) => entityState.attributes?.current_humidity\n        );\n\n        const hasHumidifying =\n          hasAction &&\n          states.states.some(\n            (entityState: LineChartState) =>\n              entityState.attributes?.action === \"humidifying\"\n          );\n        const hasDrying =\n          hasAction &&\n          states.states.some(\n            (entityState: LineChartState) =>\n              entityState.attributes?.action === \"drying\"\n          );\n\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n            name: name,\n          })}`\n        );\n\n        if (hasCurrent) {\n          addDataSet(\n            `${this.hass.localize(\n              \"ui.card.humidifier.current_humidity_entity\",\n              {\n                name: name,\n              }\n            )}`\n          );\n        }\n\n        // If action attribute is available, we used it to shade the area below the humidity.\n        // If action attribute is not available, we shade the area when the device is on\n        if (hasHumidifying) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.humidifying\", {\n              name: name,\n            })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-humidifier-on-color\")\n          );\n        } else if (hasDrying) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.drying\", {\n              name: name,\n            })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-humidifier-on-color\")\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n              name: name,\n            })}`,\n            true\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const target = safeParseFloat(entityState.attributes.humidity);\n          // If the current humidity is not available, then we fill up to the target humidity\n          const current = hasCurrent\n            ? safeParseFloat(entityState.attributes?.current_humidity)\n            : target;\n          const series = [target];\n\n          if (hasCurrent) {\n            series.push(current);\n          }\n\n          if (hasHumidifying) {\n            series.push(\n              entityState.attributes?.action === \"humidifying\" ? current : null\n            );\n          } else if (hasDrying) {\n            series.push(\n              entityState.attributes?.action === \"drying\" ? current : null\n            );\n          } else {\n            series.push(entityState.state === \"on\" ? current : null);\n          }\n          pushData(new Date(entityState.last_changed), series);\n        });\n      } else {\n        addDataSet(name);\n\n        let lastValue: number;\n        let lastDate: Date;\n        let lastNullDate: Date | null = null;\n\n        // Process chart data.\n        // When state is `unknown`, calculate the value and break the line.\n        const processData = (entityState: LineChartState) => {\n          const value = safeParseFloat(entityState.state);\n          const date = new Date(entityState.last_changed);\n          if (value !== null && lastNullDate) {\n            const dateTime = date.getTime();\n            const lastNullDateTime = lastNullDate.getTime();\n            const lastDateTime = lastDate?.getTime();\n            const tmpValue =\n              (value - lastValue) *\n                ((lastNullDateTime - lastDateTime) /\n                  (dateTime - lastDateTime)) +\n              lastValue;\n            pushData(lastNullDate, [tmpValue]);\n            pushData(new Date(lastNullDateTime + 1), [null]);\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n            lastNullDate = null;\n          } else if (value !== null && lastNullDate === null) {\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n          } else if (\n            value === null &&\n            lastNullDate === null &&\n            lastValue !== undefined\n          ) {\n            lastNullDate = date;\n          }\n        };\n\n        if (states.statistics) {\n          const stopTime =\n            !states.states || states.states.length === 0\n              ? 0\n              : states.states[0].last_changed;\n          for (let i = 0; i < states.statistics.length; i++) {\n            if (stopTime && states.statistics[i].last_changed >= stopTime) {\n              break;\n            }\n            processData(states.statistics[i]);\n          }\n        }\n        states.states.forEach((entityState) => {\n          processData(entityState);\n        });\n        if (lastNullDate !== null) {\n          pushData(lastNullDate, [null]);\n        }\n      }\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(datasets, data);\n    });\n\n    this._chartData = {\n      datasets,\n    };\n    this._entityIds = entityIds;\n    this._datasetToDataIndex = datasetToDataIndex;\n  }\n}\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-line\": StateHistoryChartLine;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}