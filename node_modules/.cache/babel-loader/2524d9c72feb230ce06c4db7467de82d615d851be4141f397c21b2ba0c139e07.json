{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nconst mdiAlertCircle = \"M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\";\nconst mdiCircle = \"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\";\nconst mdiCircleOutline = \"M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z\";\nconst mdiProgressClock = \"M13,2.03V2.05L13,4.05C17.39,4.59 20.5,8.58 19.96,12.97C19.5,16.61 16.64,19.5 13,19.93V21.93C18.5,21.38 22.5,16.5 21.95,11C21.5,6.25 17.73,2.5 13,2.03M11,2.06C9.05,2.25 7.19,3 5.67,4.26L7.1,5.74C8.22,4.84 9.57,4.26 11,4.06V2.06M4.26,5.67C3,7.19 2.25,9.04 2.05,11H4.05C4.24,9.58 4.8,8.23 5.69,7.1L4.26,5.67M2.06,13C2.26,14.96 3.03,16.81 4.27,18.33L5.69,16.9C4.81,15.77 4.24,14.42 4.06,13H2.06M7.1,18.37L5.67,19.74C7.18,21 9.04,21.79 11,22V20C9.58,19.82 8.23,19.25 7.1,18.37M12.5,7V12.25L17,14.92L16.25,16.15L11,13V7H12.5Z\";\nconst mdiProgressWrench = \"M13,2.03V2.05L13,4.05C17.39,4.59 20.5,8.58 19.96,12.97C19.5,16.61 16.64,19.5 13,19.93V21.93C18.5,21.38 22.5,16.5 21.95,11C21.5,6.25 17.73,2.5 13,2.03M11,2.06C9.05,2.25 7.19,3 5.67,4.26L7.1,5.74C8.22,4.84 9.57,4.26 11,4.06V2.06M4.26,5.67C3,7.19 2.25,9.04 2.05,11H4.05C4.24,9.58 4.8,8.23 5.69,7.1L4.26,5.67M2.06,13C2.26,14.96 3.03,16.81 4.27,18.33L5.69,16.9C4.81,15.77 4.24,14.42 4.06,13H2.06M7.1,18.37L5.67,19.74C7.18,21 9.04,21.79 11,22V20C9.58,19.82 8.23,19.25 7.1,18.37M16.82,15.19L12.71,11.08C13.12,10.04 12.89,8.82 12.03,7.97C11.13,7.06 9.78,6.88 8.69,7.38L10.63,9.32L9.28,10.68L7.29,8.73C6.75,9.82 7,11.17 7.88,12.08C8.74,12.94 9.96,13.16 11,12.76L15.11,16.86C15.29,17.05 15.56,17.05 15.74,16.86L16.78,15.83C17,15.65 17,15.33 16.82,15.19Z\";\nconst mdiRecordCircleOutline = \"M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport { relativeTime } from \"../../common/datetime/relative_time\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { toggleAttribute } from \"../../common/dom/toggle_attribute\";\nimport { subscribeEntityRegistry } from \"../../data/entity_registry\";\nimport { getActionType } from \"../../data/script\";\nimport { describeAction } from \"../../data/script_i18n\";\nimport { getDataFromPath, isTriggerPath } from \"../../data/trace\";\nimport \"./ha-timeline\";\nconst LOGBOOK_ENTRIES_BEFORE_FOLD = 2;\n\n/* eslint max-classes-per-file: \"off\" */\n\n// Report time entry when more than this time has passed\nconst SIGNIFICANT_TIME_CHANGE = 1000; // 1 seconds\n\nconst isSignificantTimeChange = (a, b) => Math.abs(b.getTime() - a.getTime()) > SIGNIFICANT_TIME_CHANGE;\nclass RenderedTimeTracker {\n  constructor(hass, entries, trace) {\n    this.hass = hass;\n    this.entries = entries;\n    this.lastReportedTime = void 0;\n    this.lastReportedTime = new Date(trace.timestamp.start);\n  }\n  setLastReportedTime(date) {\n    this.lastReportedTime = date;\n  }\n  renderTime(from, to) {\n    this.entries.push(html`\n      <ha-timeline label>\n        ${relativeTime(from, this.hass.locale, to, false)} later\n      </ha-timeline>\n    `);\n    this.lastReportedTime = to;\n  }\n  maybeRenderTime(timestamp) {\n    if (!isSignificantTimeChange(timestamp, this.lastReportedTime)) {\n      this.lastReportedTime = timestamp;\n      return false;\n    }\n    this.renderTime(this.lastReportedTime, timestamp);\n    return true;\n  }\n}\nclass LogbookRenderer {\n  constructor(entries, timeTracker, logbookEntries) {\n    this.entries = entries;\n    this.timeTracker = timeTracker;\n    this.logbookEntries = logbookEntries;\n    this.curIndex = void 0;\n    this.pendingItems = [];\n    // Skip the \"automation got triggered item\"\n    this.curIndex = logbookEntries.length > 0 && logbookEntries[0].domain === \"automation\" ? 1 : 0;\n  }\n  get curItem() {\n    return this.logbookEntries[this.curIndex];\n  }\n  get hasNext() {\n    return this.curIndex < this.logbookEntries.length;\n  }\n  maybeRenderItem() {\n    const logbookEntry = this.curItem;\n    this.curIndex++;\n    const entryDate = new Date(logbookEntry.when * 1000);\n    if (this.pendingItems.length === 0) {\n      this.pendingItems.push([entryDate, logbookEntry]);\n      return;\n    }\n    const previousEntryDate = this.pendingItems[this.pendingItems.length - 1][0];\n\n    // If logbook entry is too long after the last one,\n    // add a time passed label\n    if (isSignificantTimeChange(previousEntryDate, entryDate)) {\n      this._renderLogbookEntries();\n      this.timeTracker.renderTime(previousEntryDate, entryDate);\n    }\n    this.pendingItems.push([entryDate, logbookEntry]);\n  }\n  flush() {\n    if (this.pendingItems.length > 0) {\n      this._renderLogbookEntries();\n    }\n  }\n  _renderLogbookEntries() {\n    this.timeTracker.maybeRenderTime(this.pendingItems[0][0]);\n    const parts = [];\n    let i;\n    for (i = 0; i < Math.min(this.pendingItems.length, LOGBOOK_ENTRIES_BEFORE_FOLD); i++) {\n      parts.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n    }\n    let moreItems;\n\n    // If we didn't render all items, push rest into `moreItems`\n    if (i < this.pendingItems.length) {\n      moreItems = [];\n      for (; i < this.pendingItems.length; i++) {\n        moreItems.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n      }\n    }\n    this.entries.push(html`\n      <ha-timeline .icon=${mdiCircleOutline} .moreItems=${moreItems}>\n        ${parts}\n      </ha-timeline>\n    `);\n\n    // Clear rendered items.\n    this.timeTracker.setLastReportedTime(this.pendingItems[this.pendingItems.length - 1][0]);\n    this.pendingItems = [];\n  }\n  _renderLogbookEntryHelper(entry) {\n    return html`${entry.name} (${entry.entity_id})\n      ${entry.message || `turned ${entry.state}`}<br />`;\n  }\n}\nclass ActionRenderer {\n  constructor(hass, entityReg, entries, trace, logbookRenderer, timeTracker) {\n    this.hass = hass;\n    this.entityReg = entityReg;\n    this.entries = entries;\n    this.trace = trace;\n    this.logbookRenderer = logbookRenderer;\n    this.timeTracker = timeTracker;\n    this.curIndex = 0;\n    this.keys = void 0;\n    this.keys = Object.keys(trace.trace);\n  }\n  get curItem() {\n    return this._getItem(this.curIndex);\n  }\n  get hasNext() {\n    return this.curIndex < this.keys.length;\n  }\n  renderItem() {\n    this.curIndex = this._renderItem(this.curIndex);\n  }\n  _getItem(index) {\n    return this.trace.trace[this.keys[index]];\n  }\n  _renderItem(index, actionType, renderAllIterations) {\n    const value = this._getItem(index);\n    if (renderAllIterations) {\n      let i;\n      value.forEach(item => {\n        i = this._renderIteration(index, item, actionType);\n      });\n      return i;\n    }\n    return this._renderIteration(index, value[0], actionType);\n  }\n  _renderIteration(index, value, actionType) {\n    if (isTriggerPath(value.path)) {\n      return this._handleTrigger(index, value);\n    }\n    const timestamp = new Date(value.timestamp);\n\n    // Render all logbook items that are in front of this item.\n    while (this.logbookRenderer.hasNext && new Date(this.logbookRenderer.curItem.when * 1000) < timestamp) {\n      this.logbookRenderer.maybeRenderItem();\n    }\n    this.logbookRenderer.flush();\n    this.timeTracker.maybeRenderTime(timestamp);\n    const path = value.path;\n    let data;\n    try {\n      data = getDataFromPath(this.trace.config, path);\n    } catch (err) {\n      this._renderEntry(path, `Unable to extract path ${path}. Download trace and report as bug`);\n      return index + 1;\n    }\n    const parts = path.split(\"/\");\n    const isTopLevel = parts.length === 2;\n    if (!isTopLevel && !actionType) {\n      this._renderEntry(path, path.replace(/\\//g, \" \"));\n      return index + 1;\n    }\n    if (!actionType) {\n      actionType = getActionType(data);\n    }\n    if (actionType === \"choose\") {\n      return this._handleChoose(index);\n    }\n    if (actionType === \"repeat\") {\n      return this._handleRepeat(index);\n    }\n    if (actionType === \"if\") {\n      return this._handleIf(index);\n    }\n    if (actionType === \"parallel\") {\n      return this._handleParallel(index);\n    }\n    this._renderEntry(path, describeAction(this.hass, this.entityReg, data, actionType), undefined, data.enabled === false);\n    let i = index + 1;\n    for (; i < this.keys.length; i++) {\n      if (this.keys[i].split(\"/\").length === parts.length) {\n        break;\n      }\n    }\n    return i;\n  }\n  _handleTrigger(index, triggerStep) {\n    this._renderEntry(triggerStep.path, `${triggerStep.changed_variables.trigger.alias ? `${triggerStep.changed_variables.trigger.alias} triggered` : \"Triggered\"} ${triggerStep.path === \"trigger\" ? \"manually\" : `by the ${this.trace.trigger}`} at\n    ${formatDateTimeWithSeconds(new Date(triggerStep.timestamp), this.hass.locale, this.hass.config)}`, mdiCircle);\n    return index + 1;\n  }\n  _handleChoose(index) {\n    var _chooseTrace$result;\n    // startLevel: choose root config\n\n    // +1: 'default\n    // +2: executed sequence\n\n    // +1: 'choose'\n    // +2: current choice\n\n    // +3: 'conditions'\n    // +4: evaluated condition\n\n    // +3: 'sequence'\n    // +4: executed sequence\n\n    const choosePath = this.keys[index];\n    const startLevel = choosePath.split(\"/\").length;\n    const chooseTrace = this._getItem(index)[0];\n    const defaultExecuted = ((_chooseTrace$result = chooseTrace.result) === null || _chooseTrace$result === void 0 ? void 0 : _chooseTrace$result.choice) === \"default\";\n    const chooseConfig = this._getDataFromPath(this.keys[index]);\n    const disabled = chooseConfig.enabled === false;\n    const name = chooseConfig.alias || \"Choose\";\n    if (defaultExecuted) {\n      this._renderEntry(choosePath, `${name}: Default action executed`, undefined, disabled);\n    } else if (chooseTrace.result) {\n      const choiceNumeric = chooseTrace.result.choice !== \"default\" ? chooseTrace.result.choice + 1 : undefined;\n      const choiceConfig = this._getDataFromPath(`${this.keys[index]}/choose/${chooseTrace.result.choice}`);\n      const choiceName = choiceConfig ? `${choiceConfig.alias || `Option ${choiceNumeric}`} executed` : `Error: ${chooseTrace.error}`;\n      this._renderEntry(choosePath, `${name}: ${choiceName}`, undefined, disabled);\n    } else {\n      this._renderEntry(choosePath, `${name}: No action taken`, undefined, disabled);\n    }\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (defaultExecuted && parts[startLevel + 1] === \"default\" || !defaultExecuted && parts[startLevel + 3] === \"sequence\") {\n        break;\n      }\n    }\n\n    // Render choice\n    while (i < this.keys.length) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We know it's an action sequence, so force the type like that\n      // for rendering.\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n    return i;\n  }\n  _handleRepeat(index) {\n    const repeatPath = this.keys[index];\n    const startLevel = repeatPath.split(\"/\").length;\n    const repeatConfig = this._getDataFromPath(this.keys[index]);\n    const disabled = repeatConfig.enabled === false;\n    const name = repeatConfig.alias || describeAction(this.hass, this.entityReg, repeatConfig);\n    this._renderEntry(repeatPath, name, undefined, disabled);\n    let i;\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)), true);\n    }\n    return i;\n  }\n  _handleIf(index) {\n    var _ifTrace$result;\n    const ifPath = this.keys[index];\n    const startLevel = ifPath.split(\"/\").length;\n    const ifTrace = this._getItem(index)[0];\n    const ifConfig = this._getDataFromPath(this.keys[index]);\n    const disabled = ifConfig.enabled === false;\n    const name = ifConfig.alias || \"If\";\n    if ((_ifTrace$result = ifTrace.result) !== null && _ifTrace$result !== void 0 && _ifTrace$result.choice) {\n      const choiceConfig = this._getDataFromPath(`${this.keys[index]}/${ifTrace.result.choice}/`);\n      const choiceName = choiceConfig ? `${choiceConfig.alias || `${ifTrace.result.choice} action executed`}` : `Error: ${ifTrace.error}`;\n      this._renderEntry(ifPath, `${name}: ${choiceName}`, undefined, disabled);\n    } else {\n      this._renderEntry(ifPath, `${name}: No action taken`, undefined, disabled);\n    }\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (parts[startLevel + 1] === \"condition\" || parts.length < startLevel + 2) {\n        continue;\n      }\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n    return i;\n  }\n  _handleParallel(index) {\n    const parallelPath = this.keys[index];\n    const startLevel = parallelPath.split(\"/\").length;\n    const parallelConfig = this._getDataFromPath(this.keys[index]);\n    const disabled = parallelConfig.enabled === false;\n    const name = parallelConfig.alias || \"Execute in parallel\";\n    this._renderEntry(parallelPath, name, undefined, disabled);\n    let i;\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n    return i;\n  }\n  _renderEntry(path, description, icon = mdiRecordCircleOutline, disabled = false) {\n    this.entries.push(html`\n      <ha-timeline .icon=${icon} data-path=${path} .notEnabled=${disabled}>\n        ${description}${disabled ? html`<span class=\"disabled\"> (disabled)</span>` : \"\"}\n      </ha-timeline>\n    `);\n  }\n  _getDataFromPath(path) {\n    return getDataFromPath(this.trace.config, path);\n  }\n}\nexport let HaAutomationTracer = _decorate([customElement(\"hat-trace-timeline\")], function (_initialize, _LitElement) {\n  class HaAutomationTracer extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaAutomationTracer,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"trace\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"logbookEntries\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"selectedPath\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"allowPick\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_entityReg\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"method\",\n      key: \"hassSubscribe\",\n      value: function hassSubscribe() {\n        return [subscribeEntityRegistry(this.hass.connection, entities => {\n          this._entityReg = entities;\n        })];\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!this.trace) {\n          return nothing;\n        }\n        const entries = [];\n        const timeTracker = new RenderedTimeTracker(this.hass, entries, this.trace);\n        const logbookRenderer = new LogbookRenderer(entries, timeTracker, this.logbookEntries || []);\n        const actionRenderer = new ActionRenderer(this.hass, this._entityReg, entries, this.trace, logbookRenderer, timeTracker);\n        while (actionRenderer.hasNext) {\n          actionRenderer.renderItem();\n        }\n        while (logbookRenderer.hasNext) {\n          logbookRenderer.maybeRenderItem();\n        }\n        logbookRenderer.flush();\n\n        // Render footer\n        const renderFinishedAt = () => formatDateTimeWithSeconds(new Date(this.trace.timestamp.finish), this.hass.locale, this.hass.config);\n        const renderRuntime = () => `(runtime:\n      ${((new Date(this.trace.timestamp.finish).getTime() - new Date(this.trace.timestamp.start).getTime()) / 1000).toFixed(2)}\n      seconds)`;\n        let entry;\n        if (this.trace.state === \"running\") {\n          entry = {\n            description: \"Still running\",\n            icon: mdiProgressClock\n          };\n        } else if (this.trace.state === \"debugged\") {\n          entry = {\n            description: \"Debugged\",\n            icon: mdiProgressWrench\n          };\n        } else if (this.trace.script_execution === \"finished\") {\n          entry = {\n            description: `Finished at ${renderFinishedAt()} ${renderRuntime()}`,\n            icon: mdiCircle\n          };\n        } else if (this.trace.script_execution === \"aborted\") {\n          entry = {\n            description: `Aborted at ${renderFinishedAt()} ${renderRuntime()}`,\n            icon: mdiAlertCircle\n          };\n        } else if (this.trace.script_execution === \"cancelled\") {\n          entry = {\n            description: `Cancelled at ${renderFinishedAt()} ${renderRuntime()}`,\n            icon: mdiAlertCircle\n          };\n        } else {\n          let reason;\n          let isError = false;\n          let extra;\n          switch (this.trace.script_execution) {\n            case \"failed_conditions\":\n              reason = \"a condition failed\";\n              break;\n            case \"failed_single\":\n              reason = \"only a single execution is allowed\";\n              break;\n            case \"failed_max_runs\":\n              reason = \"maximum number of parallel runs reached\";\n              break;\n            case \"error\":\n              reason = \"an error was encountered\";\n              isError = true;\n              extra = html`<br /><br />${this.trace.error}`;\n              break;\n            default:\n              reason = `of unknown reason \"${this.trace.script_execution}\"`;\n              isError = true;\n          }\n          entry = {\n            description: html`Stopped because ${reason} at ${renderFinishedAt()}\n        ${renderRuntime()}${extra || \"\"}`,\n            icon: mdiAlertCircle,\n            className: isError ? \"error\" : undefined\n          };\n        }\n        entries.push(html`\n      <ha-timeline\n        lastItem\n        .icon=${entry.icon}\n        class=${ifDefined(entry.className)}\n      >\n        ${entry.description}\n      </ha-timeline>\n    `);\n        return html`${entries}`;\n      }\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value: function updated(props) {\n        _get(_getPrototypeOf(HaAutomationTracer.prototype), \"updated\", this).call(this, props);\n\n        // Pick first path when we load a new trace.\n        if (this.allowPick && props.has(\"trace\") && this.trace && this.selectedPath && !(this.selectedPath in this.trace.trace)) {\n          const element = this.shadowRoot.querySelector(\"ha-timeline[data-path]\");\n          if (element) {\n            fireEvent(this, \"value-changed\", {\n              value: element.dataset.path\n            });\n            this.selectedPath = element.dataset.path;\n          }\n        }\n        if (props.has(\"trace\") || props.has(\"selectedPath\")) {\n          this.shadowRoot.querySelectorAll(\"ha-timeline[data-path]\").forEach(el => {\n            toggleAttribute(el, \"selected\", this.selectedPath === el.dataset.path);\n            if (!this.allowPick || el.tabIndex === 0) {\n              return;\n            }\n            el.tabIndex = 0;\n            const selectEl = () => {\n              this.selectedPath = el.dataset.path;\n              fireEvent(this, \"value-changed\", {\n                value: el.dataset.path\n              });\n            };\n            el.addEventListener(\"click\", selectEl);\n            el.addEventListener(\"keydown\", ev => {\n              if (ev.key === \"Enter\" || ev.key === \" \") {\n                selectEl();\n              }\n            });\n            el.addEventListener(\"mouseover\", () => {\n              el.raised = true;\n            });\n            el.addEventListener(\"mouseout\", () => {\n              el.raised = false;\n            });\n          });\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return [css`\n        ha-timeline[lastItem].condition {\n          --timeline-ball-color: var(--error-color);\n        }\n        ha-timeline[data-path] {\n          cursor: pointer;\n        }\n        ha-timeline[selected] {\n          --timeline-ball-color: var(--primary-color);\n        }\n        ha-timeline:focus {\n          outline: none;\n          --timeline-ball-color: var(--accent-color);\n        }\n        .error {\n          --timeline-ball-color: var(--error-color);\n          color: var(--error-color);\n        }\n      `];\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","nothing","customElement","property","state","ifDefined","formatDateTimeWithSeconds","relativeTime","fireEvent","toggleAttribute","subscribeEntityRegistry","getActionType","describeAction","getDataFromPath","isTriggerPath","LOGBOOK_ENTRIES_BEFORE_FOLD","SIGNIFICANT_TIME_CHANGE","isSignificantTimeChange","a","b","Math","abs","getTime","RenderedTimeTracker","constructor","hass","entries","trace","lastReportedTime","Date","timestamp","start","setLastReportedTime","date","renderTime","from","to","push","locale","maybeRenderTime","LogbookRenderer","timeTracker","logbookEntries","curIndex","pendingItems","length","domain","curItem","hasNext","maybeRenderItem","logbookEntry","entryDate","when","previousEntryDate","_renderLogbookEntries","flush","parts","i","min","_renderLogbookEntryHelper","moreItems","mdiCircleOutline","entry","name","entity_id","message","ActionRenderer","entityReg","logbookRenderer","keys","Object","_getItem","renderItem","_renderItem","index","actionType","renderAllIterations","value","forEach","item","_renderIteration","path","_handleTrigger","data","config","err","_renderEntry","split","isTopLevel","replace","_handleChoose","_handleRepeat","_handleIf","_handleParallel","undefined","enabled","triggerStep","changed_variables","trigger","alias","mdiCircle","_chooseTrace$result","choosePath","startLevel","chooseTrace","defaultExecuted","result","choice","chooseConfig","_getDataFromPath","disabled","choiceNumeric","choiceConfig","choiceName","error","repeatPath","repeatConfig","_ifTrace$result","ifPath","ifTrace","ifConfig","parallelPath","parallelConfig","description","icon","mdiRecordCircleOutline","HaAutomationTracer","_decorate","_initialize","_LitElement","args","F","d","kind","decorators","attribute","key","type","Boolean","hassSubscribe","connection","entities","_entityReg","render","actionRenderer","renderFinishedAt","finish","renderRuntime","toFixed","mdiProgressClock","mdiProgressWrench","script_execution","mdiAlertCircle","reason","isError","extra","className","updated","props","_get","_getPrototypeOf","prototype","call","allowPick","has","selectedPath","element","shadowRoot","querySelector","dataset","querySelectorAll","el","tabIndex","selectEl","addEventListener","ev","raised","static","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/trace/hat-trace-timeline.ts"],"sourcesContent":["import {\n  mdiAlertCircle,\n  mdiCircle,\n  mdiCircleOutline,\n  mdiProgressClock,\n  mdiProgressWrench,\n  mdiRecordCircleOutline,\n} from \"@mdi/js\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n  nothing,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\nimport { formatDateTimeWithSeconds } from \"../../common/datetime/format_date_time\";\nimport { relativeTime } from \"../../common/datetime/relative_time\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { toggleAttribute } from \"../../common/dom/toggle_attribute\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { LogbookEntry } from \"../../data/logbook\";\nimport {\n  ChooseAction,\n  ChooseActionChoice,\n  getActionType,\n  IfAction,\n  ParallelAction,\n  RepeatAction,\n} from \"../../data/script\";\nimport { describeAction } from \"../../data/script_i18n\";\nimport {\n  ActionTraceStep,\n  AutomationTraceExtended,\n  ChooseActionTraceStep,\n  getDataFromPath,\n  IfActionTraceStep,\n  isTriggerPath,\n  TriggerTraceStep,\n} from \"../../data/trace\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-timeline\";\nimport type { HaTimeline } from \"./ha-timeline\";\n\nconst LOGBOOK_ENTRIES_BEFORE_FOLD = 2;\n\n/* eslint max-classes-per-file: \"off\" */\n\n// Report time entry when more than this time has passed\nconst SIGNIFICANT_TIME_CHANGE = 1000; // 1 seconds\n\nconst isSignificantTimeChange = (a: Date, b: Date) =>\n  Math.abs(b.getTime() - a.getTime()) > SIGNIFICANT_TIME_CHANGE;\n\nclass RenderedTimeTracker {\n  private lastReportedTime: Date;\n\n  constructor(\n    private hass: HomeAssistant,\n    private entries: TemplateResult[],\n    trace: AutomationTraceExtended\n  ) {\n    this.lastReportedTime = new Date(trace.timestamp.start);\n  }\n\n  setLastReportedTime(date: Date) {\n    this.lastReportedTime = date;\n  }\n\n  renderTime(from: Date, to: Date): void {\n    this.entries.push(html`\n      <ha-timeline label>\n        ${relativeTime(from, this.hass.locale, to, false)} later\n      </ha-timeline>\n    `);\n    this.lastReportedTime = to;\n  }\n\n  maybeRenderTime(timestamp: Date): boolean {\n    if (!isSignificantTimeChange(timestamp, this.lastReportedTime)) {\n      this.lastReportedTime = timestamp;\n      return false;\n    }\n\n    this.renderTime(this.lastReportedTime, timestamp);\n    return true;\n  }\n}\n\nclass LogbookRenderer {\n  private curIndex: number;\n\n  private pendingItems: Array<[Date, LogbookEntry]> = [];\n\n  constructor(\n    private entries: TemplateResult[],\n    private timeTracker: RenderedTimeTracker,\n    private logbookEntries: LogbookEntry[]\n  ) {\n    // Skip the \"automation got triggered item\"\n    this.curIndex =\n      logbookEntries.length > 0 && logbookEntries[0].domain === \"automation\"\n        ? 1\n        : 0;\n  }\n\n  get curItem() {\n    return this.logbookEntries[this.curIndex];\n  }\n\n  get hasNext() {\n    return this.curIndex < this.logbookEntries.length;\n  }\n\n  maybeRenderItem() {\n    const logbookEntry = this.curItem;\n    this.curIndex++;\n    const entryDate = new Date(logbookEntry.when * 1000);\n\n    if (this.pendingItems.length === 0) {\n      this.pendingItems.push([entryDate, logbookEntry]);\n      return;\n    }\n\n    const previousEntryDate =\n      this.pendingItems[this.pendingItems.length - 1][0];\n\n    // If logbook entry is too long after the last one,\n    // add a time passed label\n    if (isSignificantTimeChange(previousEntryDate, entryDate)) {\n      this._renderLogbookEntries();\n      this.timeTracker.renderTime(previousEntryDate, entryDate);\n    }\n\n    this.pendingItems.push([entryDate, logbookEntry]);\n  }\n\n  flush() {\n    if (this.pendingItems.length > 0) {\n      this._renderLogbookEntries();\n    }\n  }\n\n  private _renderLogbookEntries() {\n    this.timeTracker.maybeRenderTime(this.pendingItems[0][0]);\n\n    const parts: TemplateResult[] = [];\n\n    let i;\n\n    for (\n      i = 0;\n      i < Math.min(this.pendingItems.length, LOGBOOK_ENTRIES_BEFORE_FOLD);\n      i++\n    ) {\n      parts.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n    }\n\n    let moreItems: TemplateResult[] | undefined;\n\n    // If we didn't render all items, push rest into `moreItems`\n    if (i < this.pendingItems.length) {\n      moreItems = [];\n      for (; i < this.pendingItems.length; i++) {\n        moreItems.push(this._renderLogbookEntryHelper(this.pendingItems[i][1]));\n      }\n    }\n\n    this.entries.push(html`\n      <ha-timeline .icon=${mdiCircleOutline} .moreItems=${moreItems}>\n        ${parts}\n      </ha-timeline>\n    `);\n\n    // Clear rendered items.\n    this.timeTracker.setLastReportedTime(\n      this.pendingItems[this.pendingItems.length - 1][0]\n    );\n    this.pendingItems = [];\n  }\n\n  private _renderLogbookEntryHelper(entry: LogbookEntry) {\n    return html`${entry.name} (${entry.entity_id})\n      ${entry.message || `turned ${entry.state}`}<br />`;\n  }\n}\n\nclass ActionRenderer {\n  private curIndex = 0;\n\n  private keys: string[];\n\n  constructor(\n    private hass: HomeAssistant,\n    private entityReg: EntityRegistryEntry[],\n    private entries: TemplateResult[],\n    private trace: AutomationTraceExtended,\n    private logbookRenderer: LogbookRenderer,\n    private timeTracker: RenderedTimeTracker\n  ) {\n    this.keys = Object.keys(trace.trace);\n  }\n\n  get curItem() {\n    return this._getItem(this.curIndex);\n  }\n\n  get hasNext() {\n    return this.curIndex < this.keys.length;\n  }\n\n  renderItem() {\n    this.curIndex = this._renderItem(this.curIndex);\n  }\n\n  private _getItem(index: number) {\n    return this.trace.trace[this.keys[index]];\n  }\n\n  private _renderItem(\n    index: number,\n    actionType?: ReturnType<typeof getActionType>,\n    renderAllIterations?: boolean\n  ): number {\n    const value = this._getItem(index);\n\n    if (renderAllIterations) {\n      let i;\n      value.forEach((item) => {\n        i = this._renderIteration(index, item, actionType);\n      });\n      return i;\n    }\n    return this._renderIteration(index, value[0], actionType);\n  }\n\n  private _renderIteration(\n    index: number,\n    value: ActionTraceStep,\n    actionType?: ReturnType<typeof getActionType>\n  ) {\n    if (isTriggerPath(value.path)) {\n      return this._handleTrigger(index, value as TriggerTraceStep);\n    }\n\n    const timestamp = new Date(value.timestamp);\n\n    // Render all logbook items that are in front of this item.\n    while (\n      this.logbookRenderer.hasNext &&\n      new Date(this.logbookRenderer.curItem.when * 1000) < timestamp\n    ) {\n      this.logbookRenderer.maybeRenderItem();\n    }\n\n    this.logbookRenderer.flush();\n    this.timeTracker.maybeRenderTime(timestamp);\n\n    const path = value.path;\n    let data;\n    try {\n      data = getDataFromPath(this.trace.config, path);\n    } catch (err: any) {\n      this._renderEntry(\n        path,\n        `Unable to extract path ${path}. Download trace and report as bug`\n      );\n      return index + 1;\n    }\n\n    const parts = path.split(\"/\");\n    const isTopLevel = parts.length === 2;\n\n    if (!isTopLevel && !actionType) {\n      this._renderEntry(path, path.replace(/\\//g, \" \"));\n      return index + 1;\n    }\n\n    if (!actionType) {\n      actionType = getActionType(data);\n    }\n\n    if (actionType === \"choose\") {\n      return this._handleChoose(index);\n    }\n\n    if (actionType === \"repeat\") {\n      return this._handleRepeat(index);\n    }\n\n    if (actionType === \"if\") {\n      return this._handleIf(index);\n    }\n\n    if (actionType === \"parallel\") {\n      return this._handleParallel(index);\n    }\n\n    this._renderEntry(\n      path,\n      describeAction(this.hass, this.entityReg, data, actionType),\n      undefined,\n      data.enabled === false\n    );\n\n    let i = index + 1;\n\n    for (; i < this.keys.length; i++) {\n      if (this.keys[i].split(\"/\").length === parts.length) {\n        break;\n      }\n    }\n\n    return i;\n  }\n\n  private _handleTrigger(index: number, triggerStep: TriggerTraceStep): number {\n    this._renderEntry(\n      triggerStep.path,\n      `${\n        triggerStep.changed_variables.trigger.alias\n          ? `${triggerStep.changed_variables.trigger.alias} triggered`\n          : \"Triggered\"\n      } ${\n        triggerStep.path === \"trigger\"\n          ? \"manually\"\n          : `by the ${this.trace.trigger}`\n      } at\n    ${formatDateTimeWithSeconds(\n      new Date(triggerStep.timestamp),\n      this.hass.locale,\n      this.hass.config\n    )}`,\n      mdiCircle\n    );\n    return index + 1;\n  }\n\n  private _handleChoose(index: number): number {\n    // startLevel: choose root config\n\n    // +1: 'default\n    // +2: executed sequence\n\n    // +1: 'choose'\n    // +2: current choice\n\n    // +3: 'conditions'\n    // +4: evaluated condition\n\n    // +3: 'sequence'\n    // +4: executed sequence\n\n    const choosePath = this.keys[index];\n    const startLevel = choosePath.split(\"/\").length;\n\n    const chooseTrace = this._getItem(index)[0] as ChooseActionTraceStep;\n    const defaultExecuted = chooseTrace.result?.choice === \"default\";\n    const chooseConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as ChooseAction;\n    const disabled = chooseConfig.enabled === false;\n    const name = chooseConfig.alias || \"Choose\";\n\n    if (defaultExecuted) {\n      this._renderEntry(\n        choosePath,\n        `${name}: Default action executed`,\n        undefined,\n        disabled\n      );\n    } else if (chooseTrace.result) {\n      const choiceNumeric =\n        chooseTrace.result.choice !== \"default\"\n          ? chooseTrace.result.choice + 1\n          : undefined;\n      const choiceConfig = this._getDataFromPath(\n        `${this.keys[index]}/choose/${chooseTrace.result.choice}`\n      ) as ChooseActionChoice | undefined;\n      const choiceName = choiceConfig\n        ? `${choiceConfig.alias || `Option ${choiceNumeric}`} executed`\n        : `Error: ${chooseTrace.error}`;\n      this._renderEntry(\n        choosePath,\n        `${name}: ${choiceName}`,\n        undefined,\n        disabled\n      );\n    } else {\n      this._renderEntry(\n        choosePath,\n        `${name}: No action taken`,\n        undefined,\n        disabled\n      );\n    }\n\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (\n        (defaultExecuted && parts[startLevel + 1] === \"default\") ||\n        (!defaultExecuted && parts[startLevel + 3] === \"sequence\")\n      ) {\n        break;\n      }\n    }\n\n    // Render choice\n    while (i < this.keys.length) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We know it's an action sequence, so force the type like that\n      // for rendering.\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _handleRepeat(index: number): number {\n    const repeatPath = this.keys[index];\n    const startLevel = repeatPath.split(\"/\").length;\n\n    const repeatConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as RepeatAction;\n    const disabled = repeatConfig.enabled === false;\n\n    const name =\n      repeatConfig.alias ||\n      describeAction(this.hass, this.entityReg, repeatConfig);\n\n    this._renderEntry(repeatPath, name, undefined, disabled);\n\n    let i;\n\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)), true);\n    }\n\n    return i;\n  }\n\n  private _handleIf(index: number): number {\n    const ifPath = this.keys[index];\n    const startLevel = ifPath.split(\"/\").length;\n\n    const ifTrace = this._getItem(index)[0] as IfActionTraceStep;\n    const ifConfig = this._getDataFromPath(this.keys[index]) as IfAction;\n    const disabled = ifConfig.enabled === false;\n    const name = ifConfig.alias || \"If\";\n\n    if (ifTrace.result?.choice) {\n      const choiceConfig = this._getDataFromPath(\n        `${this.keys[index]}/${ifTrace.result.choice}/`\n      ) as any;\n      const choiceName = choiceConfig\n        ? `${choiceConfig.alias || `${ifTrace.result.choice} action executed`}`\n        : `Error: ${ifTrace.error}`;\n      this._renderEntry(ifPath, `${name}: ${choiceName}`, undefined, disabled);\n    } else {\n      this._renderEntry(\n        ifPath,\n        `${name}: No action taken`,\n        undefined,\n        disabled\n      );\n    }\n\n    let i;\n\n    // Skip over conditions\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = this.keys[i].split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      // We're going to skip all conditions\n      if (\n        parts[startLevel + 1] === \"condition\" ||\n        parts.length < startLevel + 2\n      ) {\n        continue;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _handleParallel(index: number): number {\n    const parallelPath = this.keys[index];\n    const startLevel = parallelPath.split(\"/\").length;\n\n    const parallelConfig = this._getDataFromPath(\n      this.keys[index]\n    ) as ParallelAction;\n\n    const disabled = parallelConfig.enabled === false;\n\n    const name = parallelConfig.alias || \"Execute in parallel\";\n\n    this._renderEntry(parallelPath, name, undefined, disabled);\n\n    let i;\n\n    for (i = index + 1; i < this.keys.length; i++) {\n      const path = this.keys[i];\n      const parts = path.split(\"/\");\n\n      // We're done if no more sequence in current level\n      if (parts.length <= startLevel) {\n        return i;\n      }\n\n      i = this._renderItem(i, getActionType(this._getDataFromPath(path)));\n    }\n\n    return i;\n  }\n\n  private _renderEntry(\n    path: string,\n    description: string,\n    icon = mdiRecordCircleOutline,\n    disabled = false\n  ) {\n    this.entries.push(html`\n      <ha-timeline .icon=${icon} data-path=${path} .notEnabled=${disabled}>\n        ${description}${disabled\n          ? html`<span class=\"disabled\"> (disabled)</span>`\n          : \"\"}\n      </ha-timeline>\n    `);\n  }\n\n  private _getDataFromPath(path: string) {\n    return getDataFromPath(this.trace.config, path);\n  }\n}\n\n@customElement(\"hat-trace-timeline\")\nexport class HaAutomationTracer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public trace?: AutomationTraceExtended;\n\n  @property({ attribute: false }) public logbookEntries?: LogbookEntry[];\n\n  @property({ attribute: false }) public selectedPath?: string;\n\n  @property({ type: Boolean }) public allowPick = false;\n\n  @state() private _entityReg: EntityRegistryEntry[] = [];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this._entityReg = entities;\n      }),\n    ];\n  }\n\n  protected render() {\n    if (!this.trace) {\n      return nothing;\n    }\n\n    const entries: TemplateResult[] = [];\n\n    const timeTracker = new RenderedTimeTracker(this.hass, entries, this.trace);\n    const logbookRenderer = new LogbookRenderer(\n      entries,\n      timeTracker,\n      this.logbookEntries || []\n    );\n    const actionRenderer = new ActionRenderer(\n      this.hass,\n      this._entityReg,\n      entries,\n      this.trace,\n      logbookRenderer,\n      timeTracker\n    );\n\n    while (actionRenderer.hasNext) {\n      actionRenderer.renderItem();\n    }\n\n    while (logbookRenderer.hasNext) {\n      logbookRenderer.maybeRenderItem();\n    }\n\n    logbookRenderer.flush();\n\n    // Render footer\n    const renderFinishedAt = () =>\n      formatDateTimeWithSeconds(\n        new Date(this.trace!.timestamp.finish!),\n        this.hass.locale,\n        this.hass.config\n      );\n    const renderRuntime = () => `(runtime:\n      ${(\n        (new Date(this.trace!.timestamp.finish!).getTime() -\n          new Date(this.trace!.timestamp.start).getTime()) /\n        1000\n      ).toFixed(2)}\n      seconds)`;\n\n    let entry: {\n      description: TemplateResult | string;\n      icon: string;\n      className?: string;\n    };\n\n    if (this.trace.state === \"running\") {\n      entry = {\n        description: \"Still running\",\n        icon: mdiProgressClock,\n      };\n    } else if (this.trace.state === \"debugged\") {\n      entry = {\n        description: \"Debugged\",\n        icon: mdiProgressWrench,\n      };\n    } else if (this.trace.script_execution === \"finished\") {\n      entry = {\n        description: `Finished at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiCircle,\n      };\n    } else if (this.trace.script_execution === \"aborted\") {\n      entry = {\n        description: `Aborted at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiAlertCircle,\n      };\n    } else if (this.trace.script_execution === \"cancelled\") {\n      entry = {\n        description: `Cancelled at ${renderFinishedAt()} ${renderRuntime()}`,\n        icon: mdiAlertCircle,\n      };\n    } else {\n      let reason: string;\n      let isError = false;\n      let extra: TemplateResult | undefined;\n\n      switch (this.trace.script_execution) {\n        case \"failed_conditions\":\n          reason = \"a condition failed\";\n          break;\n        case \"failed_single\":\n          reason = \"only a single execution is allowed\";\n          break;\n        case \"failed_max_runs\":\n          reason = \"maximum number of parallel runs reached\";\n          break;\n        case \"error\":\n          reason = \"an error was encountered\";\n          isError = true;\n          extra = html`<br /><br />${this.trace.error!}`;\n          break;\n        default:\n          reason = `of unknown reason \"${this.trace.script_execution}\"`;\n          isError = true;\n      }\n\n      entry = {\n        description: html`Stopped because ${reason} at ${renderFinishedAt()}\n        ${renderRuntime()}${extra || \"\"}`,\n        icon: mdiAlertCircle,\n        className: isError ? \"error\" : undefined,\n      };\n    }\n\n    entries.push(html`\n      <ha-timeline\n        lastItem\n        .icon=${entry.icon}\n        class=${ifDefined(entry.className)}\n      >\n        ${entry.description}\n      </ha-timeline>\n    `);\n\n    return html`${entries}`;\n  }\n\n  protected updated(props: PropertyValues) {\n    super.updated(props);\n\n    // Pick first path when we load a new trace.\n    if (\n      this.allowPick &&\n      props.has(\"trace\") &&\n      this.trace &&\n      this.selectedPath &&\n      !(this.selectedPath in this.trace.trace)\n    ) {\n      const element = this.shadowRoot!.querySelector<HaTimeline>(\n        \"ha-timeline[data-path]\"\n      );\n      if (element) {\n        fireEvent(this, \"value-changed\", { value: element.dataset.path });\n        this.selectedPath = element.dataset.path;\n      }\n    }\n\n    if (props.has(\"trace\") || props.has(\"selectedPath\")) {\n      this.shadowRoot!.querySelectorAll<HaTimeline>(\n        \"ha-timeline[data-path]\"\n      ).forEach((el) => {\n        toggleAttribute(el, \"selected\", this.selectedPath === el.dataset.path);\n        if (!this.allowPick || el.tabIndex === 0) {\n          return;\n        }\n        el.tabIndex = 0;\n        const selectEl = () => {\n          this.selectedPath = el.dataset.path;\n          fireEvent(this, \"value-changed\", { value: el.dataset.path });\n        };\n        el.addEventListener(\"click\", selectEl);\n        el.addEventListener(\"keydown\", (ev: KeyboardEvent) => {\n          if (ev.key === \"Enter\" || ev.key === \" \") {\n            selectEl();\n          }\n        });\n        el.addEventListener(\"mouseover\", () => {\n          el.raised = true;\n        });\n        el.addEventListener(\"mouseout\", () => {\n          el.raised = false;\n        });\n      });\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return [\n      css`\n        ha-timeline[lastItem].condition {\n          --timeline-ball-color: var(--error-color);\n        }\n        ha-timeline[data-path] {\n          cursor: pointer;\n        }\n        ha-timeline[selected] {\n          --timeline-ball-color: var(--primary-color);\n        }\n        ha-timeline:focus {\n          outline: none;\n          --timeline-ball-color: var(--accent-color);\n        }\n        .error {\n          --timeline-ball-color: var(--error-color);\n          color: var(--error-color);\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hat-trace-timeline\": HaAutomationTracer;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}