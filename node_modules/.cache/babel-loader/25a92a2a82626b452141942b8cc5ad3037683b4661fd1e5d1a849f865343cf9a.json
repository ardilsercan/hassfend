{"ast":null,"code":"import { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { TimeZone } from \"../../data/translation\";\nimport { UNIT_TO_MILLISECOND_CONVERT, formatDuration } from \"../datetime/duration\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTime } from \"../datetime/format_date_time\";\nimport { formatTime } from \"../datetime/format_time\";\nimport { formatNumber, getNumberFormatOptions, isNumericFromAttributes } from \"../number/format_number\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { computeDomain } from \"./compute_domain\";\nexport const computeStateDisplaySingleEntity = (localize, stateObj, locale, config, entity, state) => computeStateDisplayFromEntityAttributes(localize, locale, config, entity, stateObj.entity_id, stateObj.attributes, state !== undefined ? state : stateObj.state);\nexport const computeStateDisplay = (localize, stateObj, locale, config, entities, state) => {\n  const entity = entities === null || entities === void 0 ? void 0 : entities[stateObj.entity_id];\n  return computeStateDisplayFromEntityAttributes(localize, locale, config, entity, stateObj.entity_id, stateObj.attributes, state !== undefined ? state : stateObj.state);\n};\nexport const computeStateDisplayFromEntityAttributes = (localize, locale, config, entity, entityId, attributes, state) => {\n  if (state === UNKNOWN || state === UNAVAILABLE) {\n    return localize(`state.default.${state}`);\n  }\n\n  // Entities with a `unit_of_measurement` or `state_class` are numeric values and should use `formatNumber`\n  if (isNumericFromAttributes(attributes)) {\n    // state is duration\n    if (attributes.device_class === \"duration\" && attributes.unit_of_measurement && UNIT_TO_MILLISECOND_CONVERT[attributes.unit_of_measurement] && (entity === null || entity === void 0 ? void 0 : entity.display_precision) === undefined) {\n      try {\n        return formatDuration(state, attributes.unit_of_measurement);\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    if (attributes.device_class === \"monetary\") {\n      try {\n        return formatNumber(state, locale, {\n          style: \"currency\",\n          currency: attributes.unit_of_measurement,\n          minimumFractionDigits: 2,\n          // Override monetary options with number format\n          ...getNumberFormatOptions({\n            state,\n            attributes\n          }, entity)\n        });\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    const value = formatNumber(state, locale, getNumberFormatOptions({\n      state,\n      attributes\n    }, entity));\n    const unit = attributes.unit_of_measurement;\n    if (unit) {\n      return `${value}${blankBeforeUnit(unit, locale)}${unit}`;\n    }\n    return value;\n  }\n  const domain = computeDomain(entityId);\n  if (domain === \"datetime\") {\n    const time = new Date(state);\n    return formatDateTime(time, locale, config);\n  }\n  if ([\"date\", \"input_datetime\", \"time\"].includes(domain)) {\n    // If trying to display an explicit state, need to parse the explicit state to `Date` then format.\n    // Attributes aren't available, we have to use `state`.\n\n    // These are timezone agnostic, so we should NOT use the system timezone here.\n    try {\n      const components = state.split(\" \");\n      if (components.length === 2) {\n        // Date and time.\n        return formatDateTime(new Date(components.join(\"T\")), {\n          ...locale,\n          time_zone: TimeZone.local\n        }, config);\n      }\n      if (components.length === 1) {\n        if (state.includes(\"-\")) {\n          // Date only.\n          return formatDate(new Date(`${state}T00:00`), {\n            ...locale,\n            time_zone: TimeZone.local\n          }, config);\n        }\n        if (state.includes(\":\")) {\n          // Time only.\n          const now = new Date();\n          return formatTime(new Date(`${now.toISOString().split(\"T\")[0]}T${state}`), {\n            ...locale,\n            time_zone: TimeZone.local\n          }, config);\n        }\n      }\n      return state;\n    } catch (_e) {\n      // Formatting methods may throw error if date parsing doesn't go well,\n      // just return the state string in that case.\n      return state;\n    }\n  }\n\n  // `counter` `number` and `input_number` domains do not have a unit of measurement but should still use `formatNumber`\n  if (domain === \"counter\" || domain === \"number\" || domain === \"input_number\") {\n    // Format as an integer if the value and step are integers\n    return formatNumber(state, locale, getNumberFormatOptions({\n      state,\n      attributes\n    }, entity));\n  }\n\n  // state is a timestamp\n  if ([\"button\", \"event\", \"image\", \"input_button\", \"scene\", \"stt\", \"tts\", \"wake_word\"].includes(domain) || domain === \"sensor\" && attributes.device_class === \"timestamp\") {\n    try {\n      return formatDateTime(new Date(state), locale, config);\n    } catch (_err) {\n      return state;\n    }\n  }\n  return (entity === null || entity === void 0 ? void 0 : entity.translation_key) && localize(`component.${entity.platform}.entity.${domain}.${entity.translation_key}.state.${state}`) ||\n  // Return device class translation\n  attributes.device_class && localize(`component.${domain}.entity_component.${attributes.device_class}.state.${state}`) ||\n  // Return default translation\n  localize(`component.${domain}.entity_component._.state.${state}`) ||\n  // We don't know! Return the raw state.\n  state;\n};","map":{"version":3,"names":["UNAVAILABLE","UNKNOWN","TimeZone","UNIT_TO_MILLISECOND_CONVERT","formatDuration","formatDate","formatDateTime","formatTime","formatNumber","getNumberFormatOptions","isNumericFromAttributes","blankBeforeUnit","computeDomain","computeStateDisplaySingleEntity","localize","stateObj","locale","config","entity","state","computeStateDisplayFromEntityAttributes","entity_id","attributes","undefined","computeStateDisplay","entities","entityId","device_class","unit_of_measurement","display_precision","_err","style","currency","minimumFractionDigits","value","unit","domain","time","Date","includes","components","split","length","join","time_zone","local","now","toISOString","_e","translation_key","platform"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/entity/compute_state_display.ts"],"sourcesContent":["import { HassConfig, HassEntity } from \"home-assistant-js-websocket\";\nimport { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { EntityRegistryDisplayEntry } from \"../../data/entity_registry\";\nimport { FrontendLocaleData, TimeZone } from \"../../data/translation\";\nimport { HomeAssistant } from \"../../types\";\nimport {\n  UNIT_TO_MILLISECOND_CONVERT,\n  formatDuration,\n} from \"../datetime/duration\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTime } from \"../datetime/format_date_time\";\nimport { formatTime } from \"../datetime/format_time\";\nimport {\n  formatNumber,\n  getNumberFormatOptions,\n  isNumericFromAttributes,\n} from \"../number/format_number\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { LocalizeFunc } from \"../translations/localize\";\nimport { computeDomain } from \"./compute_domain\";\n\nexport const computeStateDisplaySingleEntity = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entity: EntityRegistryDisplayEntry | undefined,\n  state?: string\n): string =>\n  computeStateDisplayFromEntityAttributes(\n    localize,\n    locale,\n    config,\n    entity,\n    stateObj.entity_id,\n    stateObj.attributes,\n    state !== undefined ? state : stateObj.state\n  );\n\nexport const computeStateDisplay = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entities: HomeAssistant[\"entities\"],\n  state?: string\n): string => {\n  const entity = entities?.[stateObj.entity_id] as\n    | EntityRegistryDisplayEntry\n    | undefined;\n\n  return computeStateDisplayFromEntityAttributes(\n    localize,\n    locale,\n    config,\n    entity,\n    stateObj.entity_id,\n    stateObj.attributes,\n    state !== undefined ? state : stateObj.state\n  );\n};\n\nexport const computeStateDisplayFromEntityAttributes = (\n  localize: LocalizeFunc,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entity: EntityRegistryDisplayEntry | undefined,\n  entityId: string,\n  attributes: any,\n  state: string\n): string => {\n  if (state === UNKNOWN || state === UNAVAILABLE) {\n    return localize(`state.default.${state}`);\n  }\n\n  // Entities with a `unit_of_measurement` or `state_class` are numeric values and should use `formatNumber`\n  if (isNumericFromAttributes(attributes)) {\n    // state is duration\n    if (\n      attributes.device_class === \"duration\" &&\n      attributes.unit_of_measurement &&\n      UNIT_TO_MILLISECOND_CONVERT[attributes.unit_of_measurement] &&\n      entity?.display_precision === undefined\n    ) {\n      try {\n        return formatDuration(state, attributes.unit_of_measurement);\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    if (attributes.device_class === \"monetary\") {\n      try {\n        return formatNumber(state, locale, {\n          style: \"currency\",\n          currency: attributes.unit_of_measurement,\n          minimumFractionDigits: 2,\n          // Override monetary options with number format\n          ...getNumberFormatOptions(\n            { state, attributes } as HassEntity,\n            entity\n          ),\n        });\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n\n    const value = formatNumber(\n      state,\n      locale,\n      getNumberFormatOptions({ state, attributes } as HassEntity, entity)\n    );\n\n    const unit = attributes.unit_of_measurement;\n\n    if (unit) {\n      return `${value}${blankBeforeUnit(unit, locale)}${unit}`;\n    }\n\n    return value;\n  }\n\n  const domain = computeDomain(entityId);\n\n  if (domain === \"datetime\") {\n    const time = new Date(state);\n    return formatDateTime(time, locale, config);\n  }\n\n  if ([\"date\", \"input_datetime\", \"time\"].includes(domain)) {\n    // If trying to display an explicit state, need to parse the explicit state to `Date` then format.\n    // Attributes aren't available, we have to use `state`.\n\n    // These are timezone agnostic, so we should NOT use the system timezone here.\n    try {\n      const components = state.split(\" \");\n      if (components.length === 2) {\n        // Date and time.\n        return formatDateTime(\n          new Date(components.join(\"T\")),\n          { ...locale, time_zone: TimeZone.local },\n          config\n        );\n      }\n      if (components.length === 1) {\n        if (state.includes(\"-\")) {\n          // Date only.\n          return formatDate(\n            new Date(`${state}T00:00`),\n            { ...locale, time_zone: TimeZone.local },\n            config\n          );\n        }\n        if (state.includes(\":\")) {\n          // Time only.\n          const now = new Date();\n          return formatTime(\n            new Date(`${now.toISOString().split(\"T\")[0]}T${state}`),\n            { ...locale, time_zone: TimeZone.local },\n            config\n          );\n        }\n      }\n      return state;\n    } catch (_e) {\n      // Formatting methods may throw error if date parsing doesn't go well,\n      // just return the state string in that case.\n      return state;\n    }\n  }\n\n  // `counter` `number` and `input_number` domains do not have a unit of measurement but should still use `formatNumber`\n  if (\n    domain === \"counter\" ||\n    domain === \"number\" ||\n    domain === \"input_number\"\n  ) {\n    // Format as an integer if the value and step are integers\n    return formatNumber(\n      state,\n      locale,\n      getNumberFormatOptions({ state, attributes } as HassEntity, entity)\n    );\n  }\n\n  // state is a timestamp\n  if (\n    [\n      \"button\",\n      \"event\",\n      \"image\",\n      \"input_button\",\n      \"scene\",\n      \"stt\",\n      \"tts\",\n      \"wake_word\",\n    ].includes(domain) ||\n    (domain === \"sensor\" && attributes.device_class === \"timestamp\")\n  ) {\n    try {\n      return formatDateTime(new Date(state), locale, config);\n    } catch (_err) {\n      return state;\n    }\n  }\n\n  return (\n    (entity?.translation_key &&\n      localize(\n        `component.${entity.platform}.entity.${domain}.${entity.translation_key}.state.${state}`\n      )) ||\n    // Return device class translation\n    (attributes.device_class &&\n      localize(\n        `component.${domain}.entity_component.${attributes.device_class}.state.${state}`\n      )) ||\n    // Return default translation\n    localize(`component.${domain}.entity_component._.state.${state}`) ||\n    // We don't know! Return the raw state.\n    state\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}