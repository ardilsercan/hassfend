{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class ScrollerShim {\n  constructor(element) {\n    this._element = null;\n    const node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  get element() {\n    return this._element || document.scrollingElement || document.documentElement;\n  }\n  get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n  get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n  get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n  get viewportHeight() {\n    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n  }\n  get viewportWidth() {\n    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n  }\n  get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n  get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\nexport class ScrollerController extends ScrollerShim {\n  constructor(client, element) {\n    super(element);\n    this._clients = new Set();\n    this._retarget = null;\n    this._end = null;\n    this.__destination = null;\n    this.correctingScrollError = false;\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n    const node = this._node;\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n  get _destination() {\n    return this.__destination;\n  }\n  get scrolling() {\n    return this._destination !== null;\n  }\n  scrollTo(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    this._scrollTo(options);\n  }\n  scrollBy(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n  _nativeScrollTo(options) {\n    this._originalScrollTo.bind(this._element || window)(options);\n  }\n  _scrollTo(options, retarget = null, end = null) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n  _setDestination(options) {\n    let {\n      top,\n      left\n    } = options;\n    top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n    left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n      return false;\n    }\n    this.__destination = {\n      top,\n      left,\n      behavior: 'smooth'\n    };\n    return true;\n  }\n  _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n  _updateManagedScrollTo(coordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n  managedScrollTo(options, retarget, end) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n  correctScrollError(coordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n  _checkForArrival() {\n    if (this._destination !== null) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this;\n      let {\n        top,\n        left\n      } = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n  detach(client) {\n    this._clients.delete(client);\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n  _attach(client) {\n    this._clients.add(client);\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client – otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}","map":{"version":3,"names":["ScrollerShim","constructor","element","_element","node","window","_node","document","scrollingElement","documentElement","scrollTop","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","viewportHeight","getBoundingClientRect","height","innerHeight","viewportWidth","width","innerWidth","maxScrollTop","maxScrollLeft","ScrollerController","client","_clients","Set","_retarget","_end","__destination","correctingScrollError","_checkForArrival","bind","_updateManagedScrollTo","scrollTo","scrollBy","_originalScrollTo","_originalScrollBy","_originalScroll","scroll","_attach","_destination","scrolling","p1","p2","options","left","top","_scrollTo","undefined","_nativeScrollTo","retarget","end","behavior","_setDestination","_resetScrollState","Math","max","min","coordinates","managedScrollTo","correctScrollError","requestAnimationFrame","topDiff","abs","leftDiff","detach","delete","size","removeEventListener","add","addEventListener"],"sources":["src/ScrollerController.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client – otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}