{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n  _getDefaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n  constructor(hostSink, config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => this.config = config || this._getDefaultConfig());\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    this._setItems(items);\n  }\n  _setItems(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const {\n        index,\n        block\n      } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n  _updateLayout() {\n    // Override\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {\n        index,\n        block\n      } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || 'start'\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const {\n      block\n    } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned'\n    });\n  }\n  _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    });\n  }\n  _sendStateChangedMessage() {\n    const childPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null\n      },\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      },\n      childPositions\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({\n          emit: true\n        });\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}","map":{"version":3,"names":["dim1","direction","dim2","pos1","pos2","BaseLayout","_getDefaultConfig","constructor","hostSink","config","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","_hostSink","Promise","resolve","then","Object","assign","items","_setItems","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","change","Math","abs","reflowIfNeeded","force","_reflow","pin","options","index","block","max","min","length","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_updateVisibleIndices","_sendStateChangedMessage","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","type","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","Map","idx","set","message","scrollSize","range","first","last","scrollError","_num","emit","round"],"sources":["../../src/layouts/shared/BaseLayout.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}