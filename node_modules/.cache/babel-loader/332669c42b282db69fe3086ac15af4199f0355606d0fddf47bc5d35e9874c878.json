{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { TimeZone } from \"../../data/translation\";\nimport { UNIT_TO_MILLISECOND_CONVERT, formatDuration } from \"../datetime/duration\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTime } from \"../datetime/format_date_time\";\nimport { formatTime } from \"../datetime/format_time\";\nimport { formatNumber, getNumberFormatOptions, isNumericFromAttributes } from \"../number/format_number\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { computeDomain } from \"./compute_domain\";\nexport var computeStateDisplaySingleEntity = function computeStateDisplaySingleEntity(localize, stateObj, locale, config, entity, state) {\n  return computeStateDisplayFromEntityAttributes(localize, locale, config, entity, stateObj.entity_id, stateObj.attributes, state !== undefined ? state : stateObj.state);\n};\nexport var computeStateDisplay = function computeStateDisplay(localize, stateObj, locale, config, entities, state) {\n  var entity = entities === null || entities === void 0 ? void 0 : entities[stateObj.entity_id];\n  return computeStateDisplayFromEntityAttributes(localize, locale, config, entity, stateObj.entity_id, stateObj.attributes, state !== undefined ? state : stateObj.state);\n};\nexport var computeStateDisplayFromEntityAttributes = function computeStateDisplayFromEntityAttributes(localize, locale, config, entity, entityId, attributes, state) {\n  if (state === UNKNOWN || state === UNAVAILABLE) {\n    return localize(\"state.default.\".concat(state));\n  }\n\n  // Entities with a `unit_of_measurement` or `state_class` are numeric values and should use `formatNumber`\n  if (isNumericFromAttributes(attributes)) {\n    // state is duration\n    if (attributes.device_class === \"duration\" && attributes.unit_of_measurement && UNIT_TO_MILLISECOND_CONVERT[attributes.unit_of_measurement] && (entity === null || entity === void 0 ? void 0 : entity.display_precision) === undefined) {\n      try {\n        return formatDuration(state, attributes.unit_of_measurement);\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    if (attributes.device_class === \"monetary\") {\n      try {\n        return formatNumber(state, locale, Object.assign({\n          style: \"currency\",\n          currency: attributes.unit_of_measurement,\n          minimumFractionDigits: 2\n        }, getNumberFormatOptions({\n          state: state,\n          attributes: attributes\n        }, entity)));\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    var value = formatNumber(state, locale, getNumberFormatOptions({\n      state: state,\n      attributes: attributes\n    }, entity));\n    var unit = attributes.unit_of_measurement;\n    if (unit) {\n      return \"\".concat(value).concat(blankBeforeUnit(unit, locale)).concat(unit);\n    }\n    return value;\n  }\n  var domain = computeDomain(entityId);\n  if (domain === \"datetime\") {\n    var time = new Date(state);\n    return formatDateTime(time, locale, config);\n  }\n  if ([\"date\", \"input_datetime\", \"time\"].includes(domain)) {\n    // If trying to display an explicit state, need to parse the explicit state to `Date` then format.\n    // Attributes aren't available, we have to use `state`.\n\n    // These are timezone agnostic, so we should NOT use the system timezone here.\n    try {\n      var components = state.split(\" \");\n      if (components.length === 2) {\n        // Date and time.\n        return formatDateTime(new Date(components.join(\"T\")), Object.assign(Object.assign({}, locale), {}, {\n          time_zone: TimeZone.local\n        }), config);\n      }\n      if (components.length === 1) {\n        if (state.includes(\"-\")) {\n          // Date only.\n          return formatDate(new Date(\"\".concat(state, \"T00:00\")), Object.assign(Object.assign({}, locale), {}, {\n            time_zone: TimeZone.local\n          }), config);\n        }\n        if (state.includes(\":\")) {\n          // Time only.\n          var now = new Date();\n          return formatTime(new Date(\"\".concat(now.toISOString().split(\"T\")[0], \"T\").concat(state)), Object.assign(Object.assign({}, locale), {}, {\n            time_zone: TimeZone.local\n          }), config);\n        }\n      }\n      return state;\n    } catch (_e) {\n      // Formatting methods may throw error if date parsing doesn't go well,\n      // just return the state string in that case.\n      return state;\n    }\n  }\n\n  // `counter` `number` and `input_number` domains do not have a unit of measurement but should still use `formatNumber`\n  if (domain === \"counter\" || domain === \"number\" || domain === \"input_number\") {\n    // Format as an integer if the value and step are integers\n    return formatNumber(state, locale, getNumberFormatOptions({\n      state: state,\n      attributes: attributes\n    }, entity));\n  }\n\n  // state is a timestamp\n  if ([\"button\", \"event\", \"image\", \"input_button\", \"scene\", \"stt\", \"tts\", \"wake_word\"].includes(domain) || domain === \"sensor\" && attributes.device_class === \"timestamp\") {\n    try {\n      return formatDateTime(new Date(state), locale, config);\n    } catch (_err) {\n      return state;\n    }\n  }\n  return (entity === null || entity === void 0 ? void 0 : entity.translation_key) && localize(\"component.\".concat(entity.platform, \".entity.\").concat(domain, \".\").concat(entity.translation_key, \".state.\").concat(state)) ||\n  // Return device class translation\n  attributes.device_class && localize(\"component.\".concat(domain, \".entity_component.\").concat(attributes.device_class, \".state.\").concat(state)) ||\n  // Return default translation\n  localize(\"component.\".concat(domain, \".entity_component._.state.\").concat(state)) ||\n  // We don't know! Return the raw state.\n  state;\n};","map":{"version":3,"names":["UNAVAILABLE","UNKNOWN","TimeZone","UNIT_TO_MILLISECOND_CONVERT","formatDuration","formatDate","formatDateTime","formatTime","formatNumber","getNumberFormatOptions","isNumericFromAttributes","blankBeforeUnit","computeDomain","computeStateDisplaySingleEntity","localize","stateObj","locale","config","entity","state","computeStateDisplayFromEntityAttributes","entity_id","attributes","undefined","computeStateDisplay","entities","entityId","concat","device_class","unit_of_measurement","display_precision","_err","Object","assign","style","currency","minimumFractionDigits","value","unit","domain","time","Date","includes","components","split","length","join","time_zone","local","now","toISOString","_e","translation_key","platform"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/entity/compute_state_display.ts"],"sourcesContent":["import { HassConfig, HassEntity } from \"home-assistant-js-websocket\";\nimport { UNAVAILABLE, UNKNOWN } from \"../../data/entity\";\nimport { EntityRegistryDisplayEntry } from \"../../data/entity_registry\";\nimport { FrontendLocaleData, TimeZone } from \"../../data/translation\";\nimport { HomeAssistant } from \"../../types\";\nimport {\n  UNIT_TO_MILLISECOND_CONVERT,\n  formatDuration,\n} from \"../datetime/duration\";\nimport { formatDate } from \"../datetime/format_date\";\nimport { formatDateTime } from \"../datetime/format_date_time\";\nimport { formatTime } from \"../datetime/format_time\";\nimport {\n  formatNumber,\n  getNumberFormatOptions,\n  isNumericFromAttributes,\n} from \"../number/format_number\";\nimport { blankBeforeUnit } from \"../translations/blank_before_unit\";\nimport { LocalizeFunc } from \"../translations/localize\";\nimport { computeDomain } from \"./compute_domain\";\n\nexport const computeStateDisplaySingleEntity = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entity: EntityRegistryDisplayEntry | undefined,\n  state?: string\n): string =>\n  computeStateDisplayFromEntityAttributes(\n    localize,\n    locale,\n    config,\n    entity,\n    stateObj.entity_id,\n    stateObj.attributes,\n    state !== undefined ? state : stateObj.state\n  );\n\nexport const computeStateDisplay = (\n  localize: LocalizeFunc,\n  stateObj: HassEntity,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entities: HomeAssistant[\"entities\"],\n  state?: string\n): string => {\n  const entity = entities?.[stateObj.entity_id] as\n    | EntityRegistryDisplayEntry\n    | undefined;\n\n  return computeStateDisplayFromEntityAttributes(\n    localize,\n    locale,\n    config,\n    entity,\n    stateObj.entity_id,\n    stateObj.attributes,\n    state !== undefined ? state : stateObj.state\n  );\n};\n\nexport const computeStateDisplayFromEntityAttributes = (\n  localize: LocalizeFunc,\n  locale: FrontendLocaleData,\n  config: HassConfig,\n  entity: EntityRegistryDisplayEntry | undefined,\n  entityId: string,\n  attributes: any,\n  state: string\n): string => {\n  if (state === UNKNOWN || state === UNAVAILABLE) {\n    return localize(`state.default.${state}`);\n  }\n\n  // Entities with a `unit_of_measurement` or `state_class` are numeric values and should use `formatNumber`\n  if (isNumericFromAttributes(attributes)) {\n    // state is duration\n    if (\n      attributes.device_class === \"duration\" &&\n      attributes.unit_of_measurement &&\n      UNIT_TO_MILLISECOND_CONVERT[attributes.unit_of_measurement] &&\n      entity?.display_precision === undefined\n    ) {\n      try {\n        return formatDuration(state, attributes.unit_of_measurement);\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n    if (attributes.device_class === \"monetary\") {\n      try {\n        return formatNumber(state, locale, {\n          style: \"currency\",\n          currency: attributes.unit_of_measurement,\n          minimumFractionDigits: 2,\n          // Override monetary options with number format\n          ...getNumberFormatOptions(\n            { state, attributes } as HassEntity,\n            entity\n          ),\n        });\n      } catch (_err) {\n        // fallback to default\n      }\n    }\n\n    const value = formatNumber(\n      state,\n      locale,\n      getNumberFormatOptions({ state, attributes } as HassEntity, entity)\n    );\n\n    const unit = attributes.unit_of_measurement;\n\n    if (unit) {\n      return `${value}${blankBeforeUnit(unit, locale)}${unit}`;\n    }\n\n    return value;\n  }\n\n  const domain = computeDomain(entityId);\n\n  if (domain === \"datetime\") {\n    const time = new Date(state);\n    return formatDateTime(time, locale, config);\n  }\n\n  if ([\"date\", \"input_datetime\", \"time\"].includes(domain)) {\n    // If trying to display an explicit state, need to parse the explicit state to `Date` then format.\n    // Attributes aren't available, we have to use `state`.\n\n    // These are timezone agnostic, so we should NOT use the system timezone here.\n    try {\n      const components = state.split(\" \");\n      if (components.length === 2) {\n        // Date and time.\n        return formatDateTime(\n          new Date(components.join(\"T\")),\n          { ...locale, time_zone: TimeZone.local },\n          config\n        );\n      }\n      if (components.length === 1) {\n        if (state.includes(\"-\")) {\n          // Date only.\n          return formatDate(\n            new Date(`${state}T00:00`),\n            { ...locale, time_zone: TimeZone.local },\n            config\n          );\n        }\n        if (state.includes(\":\")) {\n          // Time only.\n          const now = new Date();\n          return formatTime(\n            new Date(`${now.toISOString().split(\"T\")[0]}T${state}`),\n            { ...locale, time_zone: TimeZone.local },\n            config\n          );\n        }\n      }\n      return state;\n    } catch (_e) {\n      // Formatting methods may throw error if date parsing doesn't go well,\n      // just return the state string in that case.\n      return state;\n    }\n  }\n\n  // `counter` `number` and `input_number` domains do not have a unit of measurement but should still use `formatNumber`\n  if (\n    domain === \"counter\" ||\n    domain === \"number\" ||\n    domain === \"input_number\"\n  ) {\n    // Format as an integer if the value and step are integers\n    return formatNumber(\n      state,\n      locale,\n      getNumberFormatOptions({ state, attributes } as HassEntity, entity)\n    );\n  }\n\n  // state is a timestamp\n  if (\n    [\n      \"button\",\n      \"event\",\n      \"image\",\n      \"input_button\",\n      \"scene\",\n      \"stt\",\n      \"tts\",\n      \"wake_word\",\n    ].includes(domain) ||\n    (domain === \"sensor\" && attributes.device_class === \"timestamp\")\n  ) {\n    try {\n      return formatDateTime(new Date(state), locale, config);\n    } catch (_err) {\n      return state;\n    }\n  }\n\n  return (\n    (entity?.translation_key &&\n      localize(\n        `component.${entity.platform}.entity.${domain}.${entity.translation_key}.state.${state}`\n      )) ||\n    // Return device class translation\n    (attributes.device_class &&\n      localize(\n        `component.${domain}.entity_component.${attributes.device_class}.state.${state}`\n      )) ||\n    // Return default translation\n    localize(`component.${domain}.entity_component._.state.${state}`) ||\n    // We don't know! Return the raw state.\n    state\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}