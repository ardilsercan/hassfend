{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nexport var BaseLayout = /*#__PURE__*/function () {\n  function BaseLayout(hostSink, config) {\n    var _this = this;\n    _classCallCheck(this, BaseLayout);\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(function () {\n      return _this.config = config || _this._getDefaultConfig();\n    });\n  }\n  _createClass(BaseLayout, [{\n    key: \"_getDefaultConfig\",\n    value: function _getDefaultConfig() {\n      return {\n        direction: 'vertical'\n      };\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return {\n        direction: this.direction\n      };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */,\n    set: function set(config) {\n      Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this._items;\n    },\n    set: function set(items) {\n      this._setItems(items);\n    }\n  }, {\n    key: \"_setItems\",\n    value: function _setItems(items) {\n      if (items !== this._items) {\n        this._items = items;\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    },\n    set: function set(dir) {\n      // Force it to be either horizontal or vertical.\n      dir = dir === 'horizontal' ? dir : 'vertical';\n      if (dir !== this._direction) {\n        this._direction = dir;\n        this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n        this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n        this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n        this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n        this._triggerReflow();\n      }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n  }, {\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    },\n    set: function set(dims) {\n      var _viewDim1 = this._viewDim1,\n        _viewDim2 = this._viewDim2;\n      Object.assign(this._viewportSize, dims);\n      if (_viewDim2 !== this._viewDim2) {\n        // this._viewDim2Changed();\n        this._scheduleLayoutUpdate();\n      } else if (_viewDim1 !== this._viewDim1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n  }, {\n    key: \"viewportScroll\",\n    get: function get() {\n      return this._latestCoords;\n    },\n    set: function set(coords) {\n      Object.assign(this._latestCoords, coords);\n      var oldPos = this._scrollPosition;\n      this._scrollPosition = this._latestCoords[this._positionDim];\n      var change = Math.abs(oldPos - this._scrollPosition);\n      if (change >= 1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n  }, {\n    key: \"reflowIfNeeded\",\n    value: function reflowIfNeeded() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (force || this._pendingReflow) {\n        this._pendingReflow = false;\n        this._reflow();\n      }\n    }\n  }, {\n    key: \"pin\",\n    get: function get() {\n      if (this._pin !== null) {\n        var _this$_pin = this._pin,\n          index = _this$_pin.index,\n          block = _this$_pin.block;\n        return {\n          index: Math.max(0, Math.min(index, this.items.length - 1)),\n          block: block\n        };\n      }\n      return null;\n    },\n    set: function set(options) {\n      this._pin = options;\n      this._triggerReflow();\n    }\n  }, {\n    key: \"_clampScrollPosition\",\n    value: function _clampScrollPosition(val) {\n      return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n  }, {\n    key: \"unpin\",\n    value: function unpin() {\n      if (this._pin !== null) {\n        this._sendUnpinnedMessage();\n        this._pin = null;\n      }\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout() {\n      // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n  }, {\n    key: \"_viewDim1\",\n    get: function get() {\n      return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n  }, {\n    key: \"_viewDim2\",\n    get: function get() {\n      return this._viewportSize[this._secondarySizeDim];\n    }\n  }, {\n    key: \"_scheduleReflow\",\n    value: function _scheduleReflow() {\n      this._pendingReflow = true;\n    }\n  }, {\n    key: \"_scheduleLayoutUpdate\",\n    value: function _scheduleLayoutUpdate() {\n      this._pendingLayoutUpdate = true;\n      this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n  }, {\n    key: \"_triggerReflow\",\n    value: function _triggerReflow() {\n      var _this2 = this;\n      this._scheduleLayoutUpdate();\n      // TODO graynorton@: reflowIfNeeded() isn't really supposed\n      // to be called internally. Address in larger cleanup\n      // of virtualizer / layout interaction pattern.\n      // this.reflowIfNeeded(true);\n      Promise.resolve().then(function () {\n        return _this2.reflowIfNeeded();\n      });\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      if (this._pendingLayoutUpdate) {\n        this._updateLayout();\n        this._pendingLayoutUpdate = false;\n      }\n      this._updateScrollSize();\n      this._setPositionFromPin();\n      this._getActiveItems();\n      this._updateVisibleIndices();\n      this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n  }, {\n    key: \"_setPositionFromPin\",\n    value: function _setPositionFromPin() {\n      if (this.pin !== null) {\n        var lastScrollPosition = this._scrollPosition;\n        var _this$pin = this.pin,\n          index = _this$pin.index,\n          block = _this$pin.block;\n        this._scrollPosition = this._calculateScrollIntoViewPosition({\n          index: index,\n          block: block || 'start'\n        }) - this.offsetWithinScroller[this._positionDim];\n        this._scrollError = lastScrollPosition - this._scrollPosition;\n      }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n  }, {\n    key: \"_calculateScrollIntoViewPosition\",\n    value: function _calculateScrollIntoViewPosition(options) {\n      var block = options.block;\n      var index = Math.min(this.items.length, Math.max(0, options.index));\n      var itemStartPosition = this._getItemPosition(index)[this._positionDim];\n      var scrollPosition = itemStartPosition;\n      if (block !== 'start') {\n        var itemSize = this._getItemSize(index)[this._sizeDim];\n        if (block === 'center') {\n          scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n        } else {\n          var itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n          if (block === 'end') {\n            scrollPosition = itemEndPosition;\n          } else {\n            // block === 'nearest'\n            var currentScrollPosition = this._scrollPosition;\n            scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n          }\n        }\n      }\n      scrollPosition += this.offsetWithinScroller[this._positionDim];\n      return this._clampScrollPosition(scrollPosition);\n    }\n  }, {\n    key: \"getScrollIntoViewCoordinates\",\n    value: function getScrollIntoViewCoordinates(options) {\n      return _defineProperty({}, this._positionDim, this._calculateScrollIntoViewPosition(options));\n    }\n  }, {\n    key: \"_sendUnpinnedMessage\",\n    value: function _sendUnpinnedMessage() {\n      this._hostSink({\n        type: 'unpinned'\n      });\n    }\n  }, {\n    key: \"_sendVisibilityChangedMessage\",\n    value: function _sendVisibilityChangedMessage() {\n      this._hostSink({\n        type: 'visibilityChanged',\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      });\n    }\n  }, {\n    key: \"_sendStateChangedMessage\",\n    value: function _sendStateChangedMessage() {\n      var childPositions = new Map();\n      if (this._first !== -1 && this._last !== -1) {\n        for (var idx = this._first; idx <= this._last; idx++) {\n          childPositions.set(idx, this._getItemPosition(idx));\n        }\n      }\n      var message = {\n        type: 'stateChanged',\n        scrollSize: _defineProperty(_defineProperty({}, this._sizeDim, this._scrollSize), this._secondarySizeDim, null),\n        range: {\n          first: this._first,\n          last: this._last,\n          firstVisible: this._firstVisible,\n          lastVisible: this._lastVisible\n        },\n        childPositions: childPositions\n      };\n      if (this._scrollError) {\n        message.scrollError = _defineProperty(_defineProperty({}, this._positionDim, this._scrollError), this._secondaryPositionDim, 0);\n        this._scrollError = 0;\n      }\n      this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n  }, {\n    key: \"_num\",\n    get: function get() {\n      if (this._first === -1 || this._last === -1) {\n        return 0;\n      }\n      return this._last - this._first + 1;\n    }\n  }, {\n    key: \"_checkThresholds\",\n    value: function _checkThresholds() {\n      if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n        this._scheduleReflow();\n      } else {\n        var min = Math.max(0, this._scrollPosition - this._overhang);\n        var max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n        if (this._physicalMin > min || this._physicalMax < max) {\n          this._scheduleReflow();\n        } else {\n          this._updateVisibleIndices({\n            emit: true\n          });\n        }\n      }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n  }, {\n    key: \"_updateVisibleIndices\",\n    value: function _updateVisibleIndices(options) {\n      if (this._first === -1 || this._last === -1) return;\n      var firstVisible = this._first;\n      while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n        firstVisible++;\n      }\n      var lastVisible = this._last;\n      while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n        lastVisible--;\n      }\n      if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n        this._firstVisible = firstVisible;\n        this._lastVisible = lastVisible;\n        if (options && options.emit) {\n          this._sendVisibilityChangedMessage();\n        }\n      }\n    }\n  }]);\n  return BaseLayout;\n}();","map":{"version":3,"names":["dim1","direction","dim2","pos1","pos2","BaseLayout","hostSink","config","_this","_classCallCheck","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","_hostSink","Promise","resolve","then","_getDefaultConfig","_createClass","key","value","get","set","Object","assign","items","_setItems","_scheduleReflow","dir","_triggerReflow","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","coords","oldPos","change","Math","abs","reflowIfNeeded","force","arguments","length","undefined","_reflow","_this$_pin","index","block","max","min","options","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_this2","_updateScrollSize","_setPositionFromPin","_getActiveItems","_updateVisibleIndices","_sendStateChangedMessage","pin","lastScrollPosition","_this$pin","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","_defineProperty","type","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","Map","idx","message","scrollSize","range","first","last","scrollError","_num","emit","round"],"sources":["../../src/layouts/shared/BaseLayout.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}