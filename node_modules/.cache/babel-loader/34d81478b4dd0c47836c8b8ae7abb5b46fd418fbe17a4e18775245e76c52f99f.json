{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\n/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport { ERR_INVALID_AUTH, ERR_CANNOT_CONNECT, ERR_HASS_HOST_REQUIRED } from \"./errors.js\";\nimport * as messages from \"./messages.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nvar DEBUG = false;\nexport var MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nexport var MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nexport var MSG_TYPE_AUTH_OK = \"auth_ok\";\nexport function createSocket(options) {\n  if (!options.auth) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  var auth = options.auth;\n  // Start refreshing expired tokens even before the WS connection is open.\n  // We know that we will need auth anyway.\n  var authRefreshTask = auth.expired ? auth.refreshAccessToken().then(function () {\n    authRefreshTask = undefined;\n  }, function () {\n    authRefreshTask = undefined;\n  }) : undefined;\n  // Convert from http:// -> ws://, https:// -> wss://\n  var url = auth.wsUrl;\n  if (DEBUG) {\n    console.log(\"[Auth phase] Initializing\", url);\n  }\n  function connect(triesLeft, promResolve, promReject) {\n    if (DEBUG) {\n      console.log(\"[Auth Phase] New connection\", url);\n    }\n    var socket = new WebSocket(url);\n    // If invalid auth, we will not try to reconnect.\n    var invalidAuth = false;\n    var closeMessage = function closeMessage() {\n      // If we are in error handler make sure close handler doesn't also fire.\n      socket.removeEventListener(\"close\", closeMessage);\n      if (invalidAuth) {\n        promReject(ERR_INVALID_AUTH);\n        return;\n      }\n      // Reject if we no longer have to retry\n      if (triesLeft === 0) {\n        // We never were connected and will not retry\n        promReject(ERR_CANNOT_CONNECT);\n        return;\n      }\n      var newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n      // Try again in a second\n      setTimeout(function () {\n        return connect(newTries, promResolve, promReject);\n      }, 1000);\n    };\n    // Auth is mandatory, so we can send the auth message right away.\n    var handleOpen = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!auth.expired) {\n                _context.next = 4;\n                break;\n              }\n              _context.next = 4;\n              return authRefreshTask ? authRefreshTask : auth.refreshAccessToken();\n            case 4:\n              socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n              _context.next = 11;\n              break;\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              // Refresh token failed\n              invalidAuth = _context.t0 === ERR_INVALID_AUTH;\n              socket.close();\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 7]]);\n      }));\n      return function handleOpen(_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    var handleMessage = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event) {\n        var message;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              message = JSON.parse(event.data);\n              if (DEBUG) {\n                console.log(\"[Auth phase] Received\", message);\n              }\n              _context2.t0 = message.type;\n              _context2.next = _context2.t0 === MSG_TYPE_AUTH_INVALID ? 5 : _context2.t0 === MSG_TYPE_AUTH_OK ? 8 : 16;\n              break;\n            case 5:\n              invalidAuth = true;\n              socket.close();\n              return _context2.abrupt(\"break\", 17);\n            case 8:\n              socket.removeEventListener(\"open\", handleOpen);\n              socket.removeEventListener(\"message\", handleMessage);\n              socket.removeEventListener(\"close\", closeMessage);\n              socket.removeEventListener(\"error\", closeMessage);\n              socket.haVersion = message.ha_version;\n              if (atLeastHaVersion(socket.haVersion, 2022, 9)) {\n                socket.send(JSON.stringify(messages.supportedFeatures()));\n              }\n              promResolve(socket);\n              return _context2.abrupt(\"break\", 17);\n            case 16:\n              if (DEBUG) {\n                // We already send response to this message when socket opens\n                if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n                  console.warn(\"[Auth phase] Unhandled message\", message);\n                }\n              }\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function handleMessage(_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    socket.addEventListener(\"open\", handleOpen);\n    socket.addEventListener(\"message\", handleMessage);\n    socket.addEventListener(\"close\", closeMessage);\n    socket.addEventListener(\"error\", closeMessage);\n  }\n  return new Promise(function (resolve, reject) {\n    return connect(options.setupRetry, resolve, reject);\n  });\n}","map":{"version":3,"names":["ERR_INVALID_AUTH","ERR_CANNOT_CONNECT","ERR_HASS_HOST_REQUIRED","messages","atLeastHaVersion","DEBUG","MSG_TYPE_AUTH_REQUIRED","MSG_TYPE_AUTH_INVALID","MSG_TYPE_AUTH_OK","createSocket","options","auth","authRefreshTask","expired","refreshAccessToken","then","undefined","url","wsUrl","console","log","connect","triesLeft","promResolve","promReject","socket","WebSocket","invalidAuth","closeMessage","removeEventListener","newTries","setTimeout","handleOpen","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","event","wrap","_callee$","_context","prev","next","send","JSON","stringify","accessToken","t0","close","stop","_x","apply","arguments","handleMessage","_ref2","_callee2","message","_callee2$","_context2","parse","data","type","abrupt","haVersion","ha_version","supportedFeatures","warn","_x2","addEventListener","Promise","resolve","reject","setupRetry"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/home-assistant-js-websocket/dist/socket.js"],"sourcesContent":["/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport { ERR_INVALID_AUTH, ERR_CANNOT_CONNECT, ERR_HASS_HOST_REQUIRED, } from \"./errors.js\";\nimport * as messages from \"./messages.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nconst DEBUG = false;\nexport const MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nexport const MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nexport const MSG_TYPE_AUTH_OK = \"auth_ok\";\nexport function createSocket(options) {\n    if (!options.auth) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    const auth = options.auth;\n    // Start refreshing expired tokens even before the WS connection is open.\n    // We know that we will need auth anyway.\n    let authRefreshTask = auth.expired\n        ? auth.refreshAccessToken().then(() => {\n            authRefreshTask = undefined;\n        }, () => {\n            authRefreshTask = undefined;\n        })\n        : undefined;\n    // Convert from http:// -> ws://, https:// -> wss://\n    const url = auth.wsUrl;\n    if (DEBUG) {\n        console.log(\"[Auth phase] Initializing\", url);\n    }\n    function connect(triesLeft, promResolve, promReject) {\n        if (DEBUG) {\n            console.log(\"[Auth Phase] New connection\", url);\n        }\n        const socket = new WebSocket(url);\n        // If invalid auth, we will not try to reconnect.\n        let invalidAuth = false;\n        const closeMessage = () => {\n            // If we are in error handler make sure close handler doesn't also fire.\n            socket.removeEventListener(\"close\", closeMessage);\n            if (invalidAuth) {\n                promReject(ERR_INVALID_AUTH);\n                return;\n            }\n            // Reject if we no longer have to retry\n            if (triesLeft === 0) {\n                // We never were connected and will not retry\n                promReject(ERR_CANNOT_CONNECT);\n                return;\n            }\n            const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n            // Try again in a second\n            setTimeout(() => connect(newTries, promResolve, promReject), 1000);\n        };\n        // Auth is mandatory, so we can send the auth message right away.\n        const handleOpen = async (event) => {\n            try {\n                if (auth.expired) {\n                    await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n                }\n                socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n            }\n            catch (err) {\n                // Refresh token failed\n                invalidAuth = err === ERR_INVALID_AUTH;\n                socket.close();\n            }\n        };\n        const handleMessage = async (event) => {\n            const message = JSON.parse(event.data);\n            if (DEBUG) {\n                console.log(\"[Auth phase] Received\", message);\n            }\n            switch (message.type) {\n                case MSG_TYPE_AUTH_INVALID:\n                    invalidAuth = true;\n                    socket.close();\n                    break;\n                case MSG_TYPE_AUTH_OK:\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"message\", handleMessage);\n                    socket.removeEventListener(\"close\", closeMessage);\n                    socket.removeEventListener(\"error\", closeMessage);\n                    socket.haVersion = message.ha_version;\n                    if (atLeastHaVersion(socket.haVersion, 2022, 9)) {\n                        socket.send(JSON.stringify(messages.supportedFeatures()));\n                    }\n                    promResolve(socket);\n                    break;\n                default:\n                    if (DEBUG) {\n                        // We already send response to this message when socket opens\n                        if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n                            console.warn(\"[Auth phase] Unhandled message\", message);\n                        }\n                    }\n            }\n        };\n        socket.addEventListener(\"open\", handleOpen);\n        socket.addEventListener(\"message\", handleMessage);\n        socket.addEventListener(\"close\", closeMessage);\n        socket.addEventListener(\"error\", closeMessage);\n    }\n    return new Promise((resolve, reject) => connect(options.setupRetry, resolve, reject));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}