{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin, builtCSS } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { scopeSubtree as _scopeSubtree } from '../utils/scope-subtree.js';\nimport { legacyOptimizations, legacyNoObservedAttributes } from '../utils/settings.js';\nimport { findObservedAttributesGetter } from '../mixins/disable-upgrade-mixin.js';\nimport { register } from '../utils/telemetry.js';\nvar DISABLED_ATTR = 'disable-upgrade';\nvar styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @appliesMixin DirMixin\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport var LegacyElementMixin = dedupingMixin(function (base) {\n  // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here\n  // (rather than on legacyElementBase) for unknown reasons.\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  var GesturesElement = GestureEventListeners(ElementMixin(base));\n\n  // Note, the DirMixin does nothing if css is built so avoid including it\n  // in that case.\n\n  /**\n   * @constructor\n   * @extends {GesturesElement}\n   * @private\n   */\n  var legacyElementBase = builtCSS ? GesturesElement : DirMixin(GesturesElement);\n  var observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  var DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  var LegacyElement = /*#__PURE__*/function (_legacyElementBase) {\n    _inherits(LegacyElement, _legacyElementBase);\n    function LegacyElement() {\n      var _this;\n      _classCallCheck(this, LegacyElement);\n      _this = _callSuper(this, LegacyElement);\n      /** @type {boolean} */\n      _this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      _this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      _this._debouncers;\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      /** @type {boolean|undefined} */\n      _this.__isUpgradeDisabled;\n      /** @type {boolean|undefined} */\n      _this.__needsAttributesAtConnected;\n      /** @type {boolean|undefined} */\n      _this._legacyForceObservedAttributes;\n      return _this;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     * @nocollapse\n     */\n    _createClass(LegacyElement, [{\n      key: \"created\",\n      value:\n      /**\n       * Legacy callback called during the `constructor`, for overriding\n       * by the user.\n       * @override\n       * @return {void}\n       */\n      function created() {}\n\n      /**\n       * Processes an attribute reaction when the `legacyNoObservedAttributes`\n       * setting is in use.\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @return {void}\n       */\n    }, {\n      key: \"__attributeReaction\",\n      value: function __attributeReaction(name, old, value) {\n        if (this.__dataAttributes && this.__dataAttributes[name] || name === DISABLED_ATTR) {\n          this.attributeChangedCallback(name, old, value, null);\n        }\n      }\n\n      /**\n       * Sets the value of an attribute.\n       * @override\n       */\n    }, {\n      key: \"setAttribute\",\n      value: function setAttribute(name, value) {\n        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n          var oldValue = this.getAttribute(name);\n          _get(_getPrototypeOf(LegacyElement.prototype), \"setAttribute\", this).call(this, name, value);\n          // value coerced to String for closure's benefit\n          this.__attributeReaction(name, oldValue, String(value));\n        } else {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"setAttribute\", this).call(this, name, value);\n        }\n      }\n\n      /**\n       * Removes an attribute.\n       * @override\n       */\n    }, {\n      key: \"removeAttribute\",\n      value: function removeAttribute(name) {\n        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n          var oldValue = this.getAttribute(name);\n          _get(_getPrototypeOf(LegacyElement.prototype), \"removeAttribute\", this).call(this, name);\n          this.__attributeReaction(name, oldValue, null);\n        } else {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"removeAttribute\", this).call(this, name);\n        }\n      }\n\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    }, {\n      key: \"_enableProperties\",\n      value:\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      // Prevent element from enabling properties when it's upgrade disabled.\n      // Normally overriding connectedCallback would be enough, but dom-* elements\n      /** @override */\n      function _enableProperties() {\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"_enableProperties\", this).call(this);\n        }\n      }\n\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      // If the element starts upgrade-disabled and a property is set for\n      // which an accessor exists, the default should not be applied.\n      // This additional check is needed because defaults are applied via\n      // `_initializeProperties` which is called after initial properties\n      // have been set when the element starts upgrade-disabled.\n      /** @override */\n    }, {\n      key: \"_canApplyPropertyDefault\",\n      value: function _canApplyPropertyDefault(property) {\n        return _get(_getPrototypeOf(LegacyElement.prototype), \"_canApplyPropertyDefault\", this).call(this, property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n      }\n\n      /**\n       * Provides an implementation of `connectedCallback`\n       * which adds Polymer legacy API's `attached` method.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        if (this.__needsAttributesAtConnected) {\n          this._takeAttributes();\n        }\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"connectedCallback\", this).call(this);\n          this.isAttached = true;\n          this.attached();\n        }\n      }\n\n      /**\n       * Legacy callback called during `connectedCallback`, for overriding\n       * by the user.\n       * @override\n       * @return {void}\n       */\n    }, {\n      key: \"attached\",\n      value: function attached() {}\n\n      /**\n       * Provides an implementation of `disconnectedCallback`\n       * which adds Polymer legacy API's `detached` method.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(LegacyElement.prototype), \"disconnectedCallback\", this).call(this);\n          this.isAttached = false;\n          this.detached();\n        }\n      }\n\n      /**\n       * Legacy callback called during `disconnectedCallback`, for overriding\n       * by the user.\n       * @override\n       * @return {void}\n       */\n    }, {\n      key: \"detached\",\n      value: function detached() {}\n\n      /**\n       * Provides an override implementation of `attributeChangedCallback`\n       * which adds the Polymer legacy API's `attributeChanged` method.\n       * @param {string} name Name of attribute.\n       * @param {?string} old Old value of attribute.\n       * @param {?string} value Current value of attribute.\n       * @param {?string} namespace Attribute namespace.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(name, old, value, namespace) {\n        if (old !== value) {\n          // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n          if (name == DISABLED_ATTR) {\n            // When disable-upgrade is removed, intialize properties and\n            // provoke connectedCallback if the element is already connected.\n            if (this.__isUpgradeDisabled && value == null) {\n              this._initializeProperties();\n              this.__isUpgradeDisabled = false;\n              if (wrap(this).isConnected) {\n                this.connectedCallback();\n              }\n            }\n          } else {\n            _get(_getPrototypeOf(LegacyElement.prototype), \"attributeChangedCallback\", this).call(this, name, old, value, namespace);\n            this.attributeChanged(name, old, value);\n          }\n        }\n      }\n\n      /**\n       * Legacy callback called during `attributeChangedChallback`, for overriding\n       * by the user.\n       * @param {string} name Name of attribute.\n       * @param {?string} old Old value of attribute.\n       * @param {?string} value Current value of attribute.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"attributeChanged\",\n      value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n      /**\n       * Overrides the default `Polymer.PropertyEffects` implementation to\n       * add support for class initialization via the `_registered` callback.\n       * This is called only when the first instance of the element is created.\n       *\n       * @return {void}\n       * @override\n       * @suppress {invalidCasts}\n       */\n    }, {\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        // Only auto-use disable-upgrade if legacyOptimizations is set.\n        if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {\n          this.__isUpgradeDisabled = true;\n        } else {\n          var proto = Object.getPrototypeOf(this);\n          if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {\n            this._registered();\n            // backstop in case the `_registered` implementation does not set this\n            proto.__hasRegisterFinished = true;\n          }\n          _get(_getPrototypeOf(LegacyElement.prototype), \"_initializeProperties\", this).call(this);\n          this.root = /** @type {HTMLElement} */this;\n          this.created();\n          // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.\n          if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n            if (this.hasAttributes()) {\n              this._takeAttributes();\n              // Element created from scratch or parser generated\n            } else if (!this.parentNode) {\n              this.__needsAttributesAtConnected = true;\n            }\n          }\n          // Ensure listeners are applied immediately so that they are\n          // added before declarative event listeners. This allows an element to\n          // decorate itself via an event prior to any declarative listeners\n          // seeing the event. Note, this ensures compatibility with 1.x ordering.\n          this._applyListeners();\n        }\n      }\n    }, {\n      key: \"_takeAttributes\",\n      value: function _takeAttributes() {\n        var a = this.attributes;\n        for (var i = 0, l = a.length; i < l; i++) {\n          var attr = a[i];\n          this.__attributeReaction(attr.name, null, attr.value);\n        }\n      }\n\n      /**\n       * Called automatically when an element is initializing.\n       * Users may override this method to perform class registration time\n       * work. The implementation should ensure the work is performed\n       * only once for the class.\n       * @protected\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_registered\",\n      value: function _registered() {}\n\n      /**\n       * Overrides the default `Polymer.PropertyEffects` implementation to\n       * add support for installing `hostAttributes` and `listeners`.\n       *\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        this._ensureAttributes();\n        _get(_getPrototypeOf(LegacyElement.prototype), \"ready\", this).call(this);\n      }\n\n      /**\n       * Ensures an element has required attributes. Called when the element\n       * is being readied via `ready`. Users should override to set the\n       * element's required attributes. The implementation should be sure\n       * to check and not override existing attributes added by\n       * the user of the element. Typically, setting attributes should be left\n       * to the element user and not done here; reasonable exceptions include\n       * setting aria roles and focusability.\n       * @protected\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_ensureAttributes\",\n      value: function _ensureAttributes() {}\n\n      /**\n       * Adds element event listeners. Called when the element\n       * is being readied via `ready`. Users should override to\n       * add any required element event listeners.\n       * In performance critical elements, the work done here should be kept\n       * to a minimum since it is done before the element is rendered. In\n       * these elements, consider adding listeners asynchronously so as not to\n       * block render.\n       * @protected\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_applyListeners\",\n      value: function _applyListeners() {}\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features. To customize\n       * how properties are serialized to attributes for attribute bindings and\n       * `reflectToAttribute: true` properties as well as this method, override\n       * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n       *\n       * @param {*} value Value to deserialize\n       * @return {string | undefined} Serialized value\n       * @override\n       */\n    }, {\n      key: \"serialize\",\n      value: function serialize(value) {\n        return this._serializeValue(value);\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.  To customize\n       * how attributes are deserialized to properties for in\n       * `attributeChangedCallback`, override `_deserializeValue` method\n       * provided by `Polymer.PropertyAccessors`.\n       *\n       * @param {string} value String to deserialize\n       * @param {*} type Type to deserialize the string to\n       * @return {*} Returns the deserialized value in the `type` given.\n       * @override\n       */\n    }, {\n      key: \"deserialize\",\n      value: function deserialize(value, type) {\n        return this._deserializeValue(value, type);\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect.\n       * @param {*=} value Property value to reflect.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"reflectPropertyToAttribute\",\n      value: function reflectPropertyToAttribute(property, attribute, value) {\n        this._propertyToAttribute(property, attribute, value);\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       *\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @param {Element} node Element to set attribute to.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"serializeValueToAttribute\",\n      value: function serializeValueToAttribute(value, attribute, node) {\n        this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);\n      }\n\n      /**\n       * Copies own properties (including accessor descriptors) from a source\n       * object to a target object.\n       *\n       * @param {Object} prototype Target object to copy properties to.\n       * @param {Object} api Source object to copy properties from.\n       * @return {Object} prototype object that was passed as first argument.\n       * @override\n       */\n    }, {\n      key: \"extend\",\n      value: function extend(prototype, api) {\n        if (!(prototype && api)) {\n          return prototype || api;\n        }\n        var n$ = Object.getOwnPropertyNames(api);\n        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {\n          var pd = Object.getOwnPropertyDescriptor(api, n);\n          if (pd) {\n            Object.defineProperty(prototype, n, pd);\n          }\n        }\n        return prototype;\n      }\n\n      /**\n       * Copies props from a source object to a target object.\n       *\n       * Note, this method uses a simple `for...in` strategy for enumerating\n       * properties.  To ensure only `ownProperties` are copied from source\n       * to target and that accessor implementations are copied, use `extend`.\n       *\n       * @param {!Object} target Target object to copy properties to.\n       * @param {!Object} source Source object to copy properties from.\n       * @return {!Object} Target object that was passed as first argument.\n       * @override\n       */\n    }, {\n      key: \"mixin\",\n      value: function mixin(target, source) {\n        for (var i in source) {\n          target[i] = source[i];\n        }\n        return target;\n      }\n\n      /**\n       * Sets the prototype of an object.\n       *\n       * Note this method is provided as backward-compatible legacy API\n       * only.  It is not directly called by any Polymer features.\n       * @param {Object} object The object on which to set the prototype.\n       * @param {Object} prototype The prototype that will be set on the given\n       * `object`.\n       * @return {Object} Returns the given `object` with its prototype set\n       * to the given `prototype` object.\n       * @override\n       */\n    }, {\n      key: \"chainObject\",\n      value: function chainObject(object, prototype) {\n        if (object && prototype && object !== prototype) {\n          object.__proto__ = prototype;\n        }\n        return object;\n      }\n\n      /* **** Begin Template **** */\n\n      /**\n       * Calls `importNode` on the `content` of the `template` specified and\n       * returns a document fragment containing the imported content.\n       *\n       * @param {HTMLTemplateElement} template HTML template element to instance.\n       * @return {!DocumentFragment} Document fragment containing the imported\n       *   template content.\n       * @override\n       * @suppress {missingProperties} go/missingfnprops\n       */\n    }, {\n      key: \"instanceTemplate\",\n      value: function instanceTemplate(template) {\n        var content = this.constructor._contentForTemplate(template);\n        var dom = /** @type {!DocumentFragment} */\n        document.importNode(content, true);\n        return dom;\n      }\n\n      /* **** Begin Events **** */\n\n      /**\n       * Dispatches a custom event with an optional detail value.\n       *\n       * @param {string} type Name of event type.\n       * @param {*=} detail Detail value containing event-specific\n       *   payload.\n       * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n       *     composed: (boolean|undefined) }=}\n       *  options Object specifying options.  These may include:\n       *  `bubbles` (boolean, defaults to `true`),\n       *  `cancelable` (boolean, defaults to false), and\n       *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n       * @return {!Event} The new event that was fired.\n       * @override\n       */\n    }, {\n      key: \"fire\",\n      value: function fire(type, detail, options) {\n        options = options || {};\n        detail = detail === null || detail === undefined ? {} : detail;\n        var event = new Event(type, {\n          bubbles: options.bubbles === undefined ? true : options.bubbles,\n          cancelable: Boolean(options.cancelable),\n          composed: options.composed === undefined ? true : options.composed\n        });\n        event.detail = detail;\n        var node = options.node || this;\n        wrap(node).dispatchEvent(event);\n        return event;\n      }\n\n      /**\n       * Convenience method to add an event listener on a given element,\n       * late bound to a named method on this element.\n       *\n       * @param {?EventTarget} node Element to add event listener to.\n       * @param {string} eventName Name of event to listen for.\n       * @param {string} methodName Name of handler method on `this` to call.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"listen\",\n      value: function listen(node, eventName, methodName) {\n        node = /** @type {!EventTarget} */node || this;\n        var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());\n        var bl = hbl.get(node);\n        if (!bl) {\n          bl = {};\n          hbl.set(node, bl);\n        }\n        var key = eventName + methodName;\n        if (!bl[key]) {\n          bl[key] = this._addMethodEventListenerToNode( /** @type {!Node} */node, eventName, methodName, this);\n        }\n      }\n\n      /**\n       * Convenience method to remove an event listener from a given element,\n       * late bound to a named method on this element.\n       *\n       * @param {?EventTarget} node Element to remove event listener from.\n       * @param {string} eventName Name of event to stop listening to.\n       * @param {string} methodName Name of handler method on `this` to not call\n       anymore.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"unlisten\",\n      value: function unlisten(node, eventName, methodName) {\n        node = /** @type {!EventTarget} */node || this;\n        var bl = this.__boundListeners && this.__boundListeners.get( /** @type {!Element} */node);\n        var key = eventName + methodName;\n        var handler = bl && bl[key];\n        if (handler) {\n          this._removeEventListenerFromNode( /** @type {!Node} */node, eventName, handler);\n          bl[key] = /** @type {?} */null;\n        }\n      }\n\n      /**\n       * Override scrolling behavior to all direction, one direction, or none.\n       *\n       * Valid scroll directions:\n       *   - 'all': scroll in any direction\n       *   - 'x': scroll only in the 'x' direction\n       *   - 'y': scroll only in the 'y' direction\n       *   - 'none': disable scrolling for this node\n       *\n       * @param {string=} direction Direction to allow scrolling\n       * Defaults to `all`.\n       * @param {Element=} node Element to apply scroll direction setting.\n       * Defaults to `this`.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"setScrollDirection\",\n      value: function setScrollDirection(direction, node) {\n        setTouchAction( /** @type {!Element} */node || this, DIRECTION_MAP[direction] || 'auto');\n      }\n      /* **** End Events **** */\n\n      /**\n       * Convenience method to run `querySelector` on this local DOM scope.\n       *\n       * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n       *\n       * @param {string} slctr Selector to run on this local DOM scope\n       * @return {Element} Element found by the selector, or null if not found.\n       * @override\n       */\n    }, {\n      key: \"$$\",\n      value: function $$(slctr) {\n        // Note, no need to `wrap` this because root is always patched\n        return this.root.querySelector(slctr);\n      }\n\n      /**\n       * Return the element whose local dom within which this element\n       * is contained. This is a shorthand for\n       * `this.getRootNode().host`.\n       * @this {Element}\n       * @return {?Node} The element whose local dom within which this element is\n       * contained.\n       * @override\n       */\n    }, {\n      key: \"domHost\",\n      get: function get() {\n        var root = wrap(this).getRootNode();\n        return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;\n      }\n\n      /**\n       * Force this element to distribute its children to its local dom.\n       * This should not be necessary as of Polymer 2.0.2 and is provided only\n       * for backwards compatibility.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"distributeContent\",\n      value: function distributeContent() {\n        var thisEl = /** @type {Element} */this;\n        var domApi = /** @type {PolymerDomApi} */dom(thisEl);\n        if (window.ShadyDOM && domApi.shadowRoot) {\n          ShadyDOM.flush();\n        }\n      }\n\n      /**\n       * Returns a list of nodes that are the effective childNodes. The effective\n       * childNodes list is the same as the element's childNodes except that\n       * any `<content>` elements are replaced with the list of nodes distributed\n       * to the `<content>`, the result of its `getDistributedNodes` method.\n       * @return {!Array<!Node>} List of effective child nodes.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n       *     HTMLElement\n       * @override\n       */\n    }, {\n      key: \"getEffectiveChildNodes\",\n      value: function getEffectiveChildNodes() {\n        var thisEl = /** @type {Element} */this;\n        var domApi = /** @type {PolymerDomApi} */dom(thisEl);\n        return domApi.getEffectiveChildNodes();\n      }\n\n      /**\n       * Returns a list of nodes distributed within this element that match\n       * `selector`. These can be dom children or elements distributed to\n       * children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {!Array<!Node>} List of distributed elements that match selector.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n       * HTMLElement\n       * @override\n       */\n    }, {\n      key: \"queryDistributedElements\",\n      value: function queryDistributedElements(selector) {\n        var thisEl = /** @type {Element} */this;\n        var domApi = /** @type {PolymerDomApi} */dom(thisEl);\n        return domApi.queryDistributedElements(selector);\n      }\n\n      /**\n       * Returns a list of elements that are the effective children. The effective\n       * children list is the same as the element's children except that\n       * any `<content>` elements are replaced with the list of elements\n       * distributed to the `<content>`.\n       *\n       * @return {!Array<!Node>} List of effective children.\n       * @override\n       */\n    }, {\n      key: \"getEffectiveChildren\",\n      value: function getEffectiveChildren() {\n        var list = this.getEffectiveChildNodes();\n        return list.filter(function ( /** @type {!Node} */n) {\n          return n.nodeType === Node.ELEMENT_NODE;\n        });\n      }\n\n      /**\n       * Returns a string of text content that is the concatenation of the\n       * text content's of the element's effective childNodes (the elements\n       * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n       *\n       * @return {string} List of effective children.\n       * @override\n       */\n    }, {\n      key: \"getEffectiveTextContent\",\n      value: function getEffectiveTextContent() {\n        var cn = this.getEffectiveChildNodes();\n        var tc = [];\n        for (var i = 0, c; c = cn[i]; i++) {\n          if (c.nodeType !== Node.COMMENT_NODE) {\n            tc.push(c.textContent);\n          }\n        }\n        return tc.join('');\n      }\n\n      /**\n       * Returns the first effective childNode within this element that\n       * match `selector`. These can be dom child nodes or elements distributed\n       * to children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {Node} First effective child node that matches selector.\n       * @override\n       */\n    }, {\n      key: \"queryEffectiveChildren\",\n      value: function queryEffectiveChildren(selector) {\n        var e$ = this.queryDistributedElements(selector);\n        return e$ && e$[0];\n      }\n\n      /**\n       * Returns a list of effective childNodes within this element that\n       * match `selector`. These can be dom child nodes or elements distributed\n       * to children that are insertion points.\n       * @param {string} selector Selector to run.\n       * @return {!Array<!Node>} List of effective child nodes that match\n       *     selector.\n       * @override\n       */\n    }, {\n      key: \"queryAllEffectiveChildren\",\n      value: function queryAllEffectiveChildren(selector) {\n        return this.queryDistributedElements(selector);\n      }\n\n      /**\n       * Returns a list of nodes distributed to this element's `<slot>`.\n       *\n       * If this element contains more than one `<slot>` in its local DOM,\n       * an optional selector may be passed to choose the desired content.\n       *\n       * @param {string=} slctr CSS selector to choose the desired\n       *   `<slot>`.  Defaults to `content`.\n       * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n       * @override\n       */\n    }, {\n      key: \"getContentChildNodes\",\n      value: function getContentChildNodes(slctr) {\n        // Note, no need to `wrap` this because root is always\n        var content = this.root.querySelector(slctr || 'slot');\n        return content ? /** @type {PolymerDomApi} */dom(content).getDistributedNodes() : [];\n      }\n\n      /**\n       * Returns a list of element children distributed to this element's\n       * `<slot>`.\n       *\n       * If this element contains more than one `<slot>` in its\n       * local DOM, an optional selector may be passed to choose the desired\n       * content.  This method differs from `getContentChildNodes` in that only\n       * elements are returned.\n       *\n       * @param {string=} slctr CSS selector to choose the desired\n       *   `<content>`.  Defaults to `content`.\n       * @return {!Array<!HTMLElement>} List of distributed nodes for the\n       *   `<slot>`.\n       * @suppress {invalidCasts}\n       * @override\n       */\n    }, {\n      key: \"getContentChildren\",\n      value: function getContentChildren(slctr) {\n        var children = /** @type {!Array<!HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {\n          return n.nodeType === Node.ELEMENT_NODE;\n        });\n        return children;\n      }\n\n      /**\n       * Checks whether an element is in this element's light DOM tree.\n       *\n       * @param {?Node} node The element to be checked.\n       * @return {boolean} true if node is in this element's light DOM tree.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n       * HTMLElement\n       * @override\n       */\n    }, {\n      key: \"isLightDescendant\",\n      value: function isLightDescendant(node) {\n        var thisNode = /** @type {Node} */this;\n        return thisNode !== node && wrap(thisNode).contains(node) && wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n      }\n\n      /**\n       * Checks whether an element is in this element's local DOM tree.\n       *\n       * @param {!Element} node The element to be checked.\n       * @return {boolean} true if node is in this element's local DOM tree.\n       * @override\n       */\n    }, {\n      key: \"isLocalDescendant\",\n      value: function isLocalDescendant(node) {\n        return this.root === wrap(node).getRootNode();\n      }\n\n      /**\n       * No-op for backwards compatibility. This should now be handled by\n       * ShadyCss library.\n       * @param  {!Element} container Container element to scope\n       * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n       * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n       * @override\n       */\n    }, {\n      key: \"scopeSubtree\",\n      value: function scopeSubtree(container) {\n        var shouldObserve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        return _scopeSubtree(container, shouldObserve);\n      }\n\n      /**\n       * Returns the computed style value for the given property.\n       * @param {string} property The css property name.\n       * @return {string} Returns the computed css property value for the given\n       * `property`.\n       * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n       *     HTMLElement\n       * @override\n       */\n    }, {\n      key: \"getComputedStyleValue\",\n      value: function getComputedStyleValue(property) {\n        return styleInterface.getComputedStyleValue( /** @type {!Element} */this, property);\n      }\n\n      // debounce\n\n      /**\n       * Call `debounce` to collapse multiple requests for a named task into\n       * one invocation which is made after the wait time has elapsed with\n       * no new request.  If no wait time is given, the callback will be called\n       * at microtask timing (guaranteed before paint).\n       *\n       *     debouncedClickAction(e) {\n       *       // will not call `processClick` more than once per 100ms\n       *       this.debounce('click', function() {\n       *        this.processClick();\n       *       } 100);\n       *     }\n       *\n       * @param {string} jobName String to identify the debounce job.\n       * @param {function():void} callback Function that is called (with `this`\n       *   context) when the wait time elapses.\n       * @param {number=} wait Optional wait time in milliseconds (ms) after the\n       *   last signal that must elapse before invoking `callback`\n       * @return {!Object} Returns a debouncer object on which exists the\n       * following methods: `isActive()` returns true if the debouncer is\n       * active; `cancel()` cancels the debouncer if it is active;\n       * `flush()` immediately invokes the debounced callback if the debouncer\n       * is active.\n       * @override\n       */\n    }, {\n      key: \"debounce\",\n      value: function debounce(jobName, callback, wait) {\n        this._debouncers = this._debouncers || {};\n        return this._debouncers[jobName] = Debouncer.debounce(this._debouncers[jobName], wait > 0 ? timeOut.after(wait) : microTask, callback.bind(this));\n      }\n\n      /**\n       * Returns whether a named debouncer is active.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {boolean} Whether the debouncer is active (has not yet fired).\n       * @override\n       */\n    }, {\n      key: \"isDebouncerActive\",\n      value: function isDebouncerActive(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n        return !!(debouncer && debouncer.isActive());\n      }\n\n      /**\n       * Immediately calls the debouncer `callback` and inactivates it.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"flushDebouncer\",\n      value: function flushDebouncer(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n        if (debouncer) {\n          debouncer.flush();\n        }\n      }\n\n      /**\n       * Cancels an active debouncer.  The `callback` will not be called.\n       *\n       * @param {string} jobName The name of the debouncer started with `debounce`\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"cancelDebouncer\",\n      value: function cancelDebouncer(jobName) {\n        this._debouncers = this._debouncers || {};\n        var debouncer = this._debouncers[jobName];\n        if (debouncer) {\n          debouncer.cancel();\n        }\n      }\n\n      /**\n       * Runs a callback function asynchronously.\n       *\n       * By default (if no waitTime is specified), async callbacks are run at\n       * microtask timing, which will occur before paint.\n       *\n       * @param {!Function} callback The callback function to run, bound to\n       *     `this`.\n       * @param {number=} waitTime Time to wait before calling the\n       *   `callback`.  If unspecified or 0, the callback will be run at microtask\n       *   timing (before paint).\n       * @return {number} Handle that may be used to cancel the async job.\n       * @override\n       */\n    }, {\n      key: \"async\",\n      value: function async(callback, waitTime) {\n        return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));\n      }\n\n      /**\n       * Cancels an async operation started with `async`.\n       *\n       * @param {number} handle Handle returned from original `async` call to\n       *   cancel.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"cancelAsync\",\n      value: function cancelAsync(handle) {\n        handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);\n      }\n\n      // other\n\n      /**\n       * Convenience method for creating an element and configuring it.\n       *\n       * @param {string} tag HTML element tag to create.\n       * @param {Object=} props Object of properties to configure on the\n       *    instance.\n       * @return {!Element} Newly created and configured element.\n       * @override\n       */\n    }, {\n      key: \"create\",\n      value: function create(tag, props) {\n        var elt = document.createElement(tag);\n        if (props) {\n          if (elt.setProperties) {\n            elt.setProperties(props);\n          } else {\n            for (var n in props) {\n              elt[n] = props[n];\n            }\n          }\n        }\n        return elt;\n      }\n\n      /**\n       * Polyfill for Element.prototype.matches, which is sometimes still\n       * prefixed.\n       *\n       * @param {string} selector Selector to test.\n       * @param {!Element=} node Element to test the selector against.\n       * @return {boolean} Whether the element matches the selector.\n       * @override\n       */\n    }, {\n      key: \"elementMatches\",\n      value: function elementMatches(selector, node) {\n        return matchesSelector(node || this, selector);\n      }\n\n      /**\n       * Toggles an HTML attribute on or off.\n       *\n       * @param {string} name HTML attribute name\n       * @param {boolean=} bool Boolean to force the attribute on or off.\n       *    When unspecified, the state of the attribute will be reversed.\n       * @return {boolean} true if the attribute now exists\n       * @override\n       */\n    }, {\n      key: \"toggleAttribute\",\n      value: function toggleAttribute(name, bool) {\n        var node = /** @type {Element} */this;\n        if (arguments.length === 3) {\n          node = /** @type {Element} */arguments[2];\n        }\n        if (arguments.length == 1) {\n          bool = !node.hasAttribute(name);\n        }\n        if (bool) {\n          wrap(node).setAttribute(name, '');\n          return true;\n        } else {\n          wrap(node).removeAttribute(name);\n          return false;\n        }\n      }\n\n      /**\n       * Toggles a CSS class on or off.\n       *\n       * @param {string} name CSS class name\n       * @param {boolean=} bool Boolean to force the class on or off.\n       *    When unspecified, the state of the class will be reversed.\n       * @param {Element=} node Node to target.  Defaults to `this`.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"toggleClass\",\n      value: function toggleClass(name, bool, node) {\n        node = /** @type {Element} */node || this;\n        if (arguments.length == 1) {\n          bool = !node.classList.contains(name);\n        }\n        if (bool) {\n          node.classList.add(name);\n        } else {\n          node.classList.remove(name);\n        }\n      }\n\n      /**\n       * Cross-platform helper for setting an element's CSS `transform` property.\n       *\n       * @param {string} transformText Transform setting.\n       * @param {Element=} node Element to apply the transform to.\n       * Defaults to `this`\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"transform\",\n      value: function transform(transformText, node) {\n        node = /** @type {Element} */node || this;\n        node.style.webkitTransform = transformText;\n        node.style.transform = transformText;\n      }\n\n      /**\n       * Cross-platform helper for setting an element's CSS `translate3d`\n       * property.\n       *\n       * @param {number|string} x X offset.\n       * @param {number|string} y Y offset.\n       * @param {number|string} z Z offset.\n       * @param {Element=} node Element to apply the transform to.\n       * Defaults to `this`.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"translate3d\",\n      value: function translate3d(x, y, z, node) {\n        node = /** @type {Element} */node || this;\n        this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n      }\n\n      /**\n       * Removes an item from an array, if it exists.\n       *\n       * If the array is specified by path, a change notification is\n       * generated, so that observers, data bindings and computed\n       * properties watching that path can update.\n       *\n       * If the array is passed directly, **no change\n       * notification is generated**.\n       *\n       * @param {string | !Array<number|string>} arrayOrPath Path to array from\n       *     which to remove the item\n       *   (or the array itself).\n       * @param {*} item Item to remove.\n       * @return {Array} Array containing item removed.\n       * @override\n       */\n    }, {\n      key: \"arrayDelete\",\n      value: function arrayDelete(arrayOrPath, item) {\n        var index;\n        if (Array.isArray(arrayOrPath)) {\n          index = arrayOrPath.indexOf(item);\n          if (index >= 0) {\n            return arrayOrPath.splice(index, 1);\n          }\n        } else {\n          var arr = get(this, arrayOrPath);\n          index = arr.indexOf(item);\n          if (index >= 0) {\n            return this.splice(arrayOrPath, index, 1);\n          }\n        }\n        return null;\n      }\n\n      // logging\n\n      /**\n       * Facades `console.log`/`warn`/`error` as override point.\n       *\n       * @param {string} level One of 'log', 'warn', 'error'\n       * @param {Array} args Array of strings or objects to log\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_logger\",\n      value: function _logger(level, args) {\n        var _console;\n        // accept ['foo', 'bar'] and [['foo', 'bar']]\n        if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n          args = args[0];\n        }\n        switch (level) {\n          case 'log':\n          case 'warn':\n          case 'error':\n            (_console = console)[level].apply(_console, _toConsumableArray(args));\n        }\n      }\n\n      /**\n       * Facades `console.log` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_log\",\n      value: function _log() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        this._logger('log', args);\n      }\n\n      /**\n       * Facades `console.warn` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_warn\",\n      value: function _warn() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        this._logger('warn', args);\n      }\n\n      /**\n       * Facades `console.error` as an override point.\n       *\n       * @param {...*} args Array of strings or objects to log\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_error\",\n      value: function _error() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        this._logger('error', args);\n      }\n\n      /**\n       * Formats a message using the element type an a method name.\n       *\n       * @param {string} methodName Method name to associate with message\n       * @param {...*} args Array of strings or objects to log\n       * @return {!Array} Array with formatting information for `console`\n       *   logging.\n       * @override\n       */\n    }, {\n      key: \"_logf\",\n      value: function _logf(methodName) {\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n        return ['[%s::%s]', this.is, methodName].concat(args);\n      }\n    }], [{\n      key: \"importMeta\",\n      get: function get() {\n        return this.prototype.importMeta;\n      }\n    }, {\n      key: \"observedAttributes\",\n      get: function get() {\n        if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {\n          // Ensure this element is property registered with the telemetry system.\n          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n            this.__observedAttributes = [];\n            register(this.prototype);\n          }\n          return this.__observedAttributes;\n        } else {\n          return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n        }\n      }\n    }]);\n    return LegacyElement;\n  }(legacyElementBase);\n  LegacyElement.prototype.is = '';\n  return LegacyElement;\n});","map":{"version":3,"names":["ElementMixin","builtCSS","GestureEventListeners","DirMixin","dedupingMixin","dom","matchesSelector","setTouchAction","Debouncer","timeOut","microTask","get","wrap","scopeSubtree","legacyOptimizations","legacyNoObservedAttributes","findObservedAttributesGetter","register","DISABLED_ATTR","styleInterface","window","ShadyCSS","LegacyElementMixin","base","GesturesElement","legacyElementBase","observedAttributesGetter","DIRECTION_MAP","LegacyElement","_legacyElementBase","_inherits","_this","_classCallCheck","_callSuper","isAttached","__boundListeners","_debouncers","__isUpgradeDisabled","__needsAttributesAtConnected","_legacyForceObservedAttributes","_createClass","key","value","created","__attributeReaction","name","old","__dataAttributes","attributeChangedCallback","setAttribute","oldValue","getAttribute","_get","_getPrototypeOf","prototype","call","String","removeAttribute","_enableProperties","_canApplyPropertyDefault","property","_isPropertyPending","connectedCallback","_takeAttributes","attached","disconnectedCallback","detached","namespace","_initializeProperties","isConnected","attributeChanged","hasAttribute","proto","Object","getPrototypeOf","hasOwnProperty","JSCompiler_renameProperty","_registered","__hasRegisterFinished","root","hasAttributes","parentNode","_applyListeners","a","attributes","i","l","length","attr","ready","_ensureAttributes","serialize","_serializeValue","deserialize","type","_deserializeValue","reflectPropertyToAttribute","attribute","_propertyToAttribute","serializeValueToAttribute","node","_valueToNodeAttribute","extend","api","n$","getOwnPropertyNames","n","pd","getOwnPropertyDescriptor","defineProperty","mixin","target","source","chainObject","object","__proto__","instanceTemplate","template","content","constructor","_contentForTemplate","document","importNode","fire","detail","options","undefined","event","Event","bubbles","cancelable","Boolean","composed","dispatchEvent","listen","eventName","methodName","hbl","WeakMap","bl","set","_addMethodEventListenerToNode","unlisten","handler","_removeEventListenerFromNode","setScrollDirection","direction","$$","slctr","querySelector","getRootNode","DocumentFragment","host","distributeContent","thisEl","domApi","ShadyDOM","shadowRoot","flush","getEffectiveChildNodes","queryDistributedElements","selector","getEffectiveChildren","list","filter","nodeType","Node","ELEMENT_NODE","getEffectiveTextContent","cn","tc","c","COMMENT_NODE","push","textContent","join","queryEffectiveChildren","e$","queryAllEffectiveChildren","getContentChildNodes","getDistributedNodes","getContentChildren","children","isLightDescendant","thisNode","contains","isLocalDescendant","container","shouldObserve","arguments","getComputedStyleValue","debounce","jobName","callback","wait","after","bind","isDebouncerActive","debouncer","isActive","flushDebouncer","cancelDebouncer","cancel","async","waitTime","run","cancelAsync","handle","create","tag","props","elt","createElement","setProperties","elementMatches","toggleAttribute","bool","toggleClass","classList","add","remove","transform","transformText","style","webkitTransform","translate3d","x","y","z","arrayDelete","arrayOrPath","item","index","Array","isArray","indexOf","splice","arr","_logger","level","args","_console","console","apply","_toConsumableArray","_log","_len","_key","_warn","_len2","_key2","_error","_len3","_key3","_logf","_len4","_key4","is","concat","importMeta","__observedAttributes"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin, builtCSS } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { scopeSubtree } from '../utils/scope-subtree.js';\nimport { legacyOptimizations, legacyNoObservedAttributes } from '../utils/settings.js';\nimport { findObservedAttributesGetter } from '../mixins/disable-upgrade-mixin.js';\nimport { register } from '../utils/telemetry.js';\n\nconst DISABLED_ATTR = 'disable-upgrade';\n\nlet styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @appliesMixin DirMixin\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport const LegacyElementMixin = dedupingMixin((base) => {\n\n  // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here\n  // (rather than on legacyElementBase) for unknown reasons.\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const GesturesElement = GestureEventListeners(ElementMixin(base));\n\n  // Note, the DirMixin does nothing if css is built so avoid including it\n  // in that case.\n\n  /**\n   * @constructor\n   * @extends {GesturesElement}\n   * @private\n   */\n  const legacyElementBase = builtCSS ? GesturesElement :\n    DirMixin(GesturesElement);\n\n  const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  const DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  class LegacyElement extends legacyElementBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      this._debouncers;\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      /** @type {boolean|undefined} */\n      this.__isUpgradeDisabled;\n      /** @type {boolean|undefined} */\n      this.__needsAttributesAtConnected;\n      /** @type {boolean|undefined} */\n      this._legacyForceObservedAttributes;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     * @nocollapse\n     */\n    static get importMeta() {\n      return this.prototype.importMeta;\n    }\n\n    /**\n     * Legacy callback called during the `constructor`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    created() {}\n\n    /**\n     * Processes an attribute reaction when the `legacyNoObservedAttributes`\n     * setting is in use.\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @return {void}\n     */\n    __attributeReaction(name, old, value) {\n      if ((this.__dataAttributes && this.__dataAttributes[name]) || name === DISABLED_ATTR) {\n        this.attributeChangedCallback(name, old, value, null);\n      }\n    }\n\n    /**\n     * Sets the value of an attribute.\n     * @override\n     */\n    setAttribute(name, value) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.setAttribute(name, value);\n        // value coerced to String for closure's benefit\n        this.__attributeReaction(name, oldValue, String(value));\n      } else {\n        super.setAttribute(name, value);\n      }\n    }\n\n    /**\n     * Removes an attribute.\n     * @override\n     */\n    removeAttribute(name) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.removeAttribute(name);\n        this.__attributeReaction(name, oldValue, null);\n      } else {\n        super.removeAttribute(name);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    static get observedAttributes() {\n      if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {\n        // Ensure this element is property registered with the telemetry system.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          this.__observedAttributes = [];\n          register(this.prototype);\n        }\n        return this.__observedAttributes;\n      } else {\n        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // Prevent element from enabling properties when it's upgrade disabled.\n    // Normally overriding connectedCallback would be enough, but dom-* elements\n    /** @override */\n    _enableProperties() {\n      if (!this.__isUpgradeDisabled) {\n        super._enableProperties();\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // If the element starts upgrade-disabled and a property is set for\n    // which an accessor exists, the default should not be applied.\n    // This additional check is needed because defaults are applied via\n    // `_initializeProperties` which is called after initial properties\n    // have been set when the element starts upgrade-disabled.\n    /** @override */\n    _canApplyPropertyDefault(property) {\n      return super._canApplyPropertyDefault(property) &&\n        !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n    }\n\n    /**\n     * Provides an implementation of `connectedCallback`\n     * which adds Polymer legacy API's `attached` method.\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      if (this.__needsAttributesAtConnected) {\n        this._takeAttributes();\n      }\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.connectedCallback();\n        this.isAttached = true;\n        this.attached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `connectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    attached() {}\n\n    /**\n     * Provides an implementation of `disconnectedCallback`\n     * which adds Polymer legacy API's `detached` method.\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.disconnectedCallback();\n        this.isAttached = false;\n        this.detached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `disconnectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    detached() {}\n\n    /**\n     * Provides an override implementation of `attributeChangedCallback`\n     * which adds the Polymer legacy API's `attributeChanged` method.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        if (name == DISABLED_ATTR) {\n          // When disable-upgrade is removed, intialize properties and\n          // provoke connectedCallback if the element is already connected.\n          if (this.__isUpgradeDisabled && value == null) {\n            this._initializeProperties();\n            this.__isUpgradeDisabled = false;\n            if (wrap(this).isConnected) {\n              this.connectedCallback();\n            }\n          }\n        } else {\n          super.attributeChangedCallback(name, old, value, namespace);\n          this.attributeChanged(name, old, value);\n        }\n      }\n    }\n\n    /**\n     * Legacy callback called during `attributeChangedChallback`, for overriding\n     * by the user.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     * @override\n     */\n    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for class initialization via the `_registered` callback.\n     * This is called only when the first instance of the element is created.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n    _initializeProperties() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      // Only auto-use disable-upgrade if legacyOptimizations is set.\n      if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {\n        this.__isUpgradeDisabled = true;\n      } else {\n        let proto = Object.getPrototypeOf(this);\n        if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {\n          this._registered();\n          // backstop in case the `_registered` implementation does not set this\n          proto.__hasRegisterFinished = true;\n        }\n        super._initializeProperties();\n        this.root = /** @type {HTMLElement} */(this);\n        this.created();\n        // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.\n        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n          if (this.hasAttributes()) {\n            this._takeAttributes();\n          // Element created from scratch or parser generated\n          } else if (!this.parentNode) {\n            this.__needsAttributesAtConnected = true;\n          }\n        }\n        // Ensure listeners are applied immediately so that they are\n        // added before declarative event listeners. This allows an element to\n        // decorate itself via an event prior to any declarative listeners\n        // seeing the event. Note, this ensures compatibility with 1.x ordering.\n        this._applyListeners();\n      }\n    }\n\n    _takeAttributes() {\n      const a = this.attributes;\n      for (let i=0, l=a.length; i < l; i++) {\n        const attr = a[i];\n        this.__attributeReaction(attr.name, null, attr.value);\n      }\n    }\n\n    /**\n     * Called automatically when an element is initializing.\n     * Users may override this method to perform class registration time\n     * work. The implementation should ensure the work is performed\n     * only once for the class.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _registered() {}\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for installing `hostAttributes` and `listeners`.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      this._ensureAttributes();\n      super.ready();\n    }\n\n    /**\n     * Ensures an element has required attributes. Called when the element\n     * is being readied via `ready`. Users should override to set the\n     * element's required attributes. The implementation should be sure\n     * to check and not override existing attributes added by\n     * the user of the element. Typically, setting attributes should be left\n     * to the element user and not done here; reasonable exceptions include\n     * setting aria roles and focusability.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _ensureAttributes() {}\n\n    /**\n     * Adds element event listeners. Called when the element\n     * is being readied via `ready`. Users should override to\n     * add any required element event listeners.\n     * In performance critical elements, the work done here should be kept\n     * to a minimum since it is done before the element is rendered. In\n     * these elements, consider adding listeners asynchronously so as not to\n     * block render.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _applyListeners() {}\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features. To customize\n     * how properties are serialized to attributes for attribute bindings and\n     * `reflectToAttribute: true` properties as well as this method, override\n     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {*} value Value to deserialize\n     * @return {string | undefined} Serialized value\n     * @override\n     */\n    serialize(value) {\n      return this._serializeValue(value);\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.  To customize\n     * how attributes are deserialized to properties for in\n     * `attributeChangedCallback`, override `_deserializeValue` method\n     * provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {string} value String to deserialize\n     * @param {*} type Type to deserialize the string to\n     * @return {*} Returns the deserialized value in the `type` given.\n     * @override\n     */\n    deserialize(value, type) {\n      return this._deserializeValue(value, type);\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect.\n     * @param {*=} value Property value to reflect.\n     * @return {void}\n     * @override\n     */\n    reflectPropertyToAttribute(property, attribute, value) {\n      this._propertyToAttribute(property, attribute, value);\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @param {Element} node Element to set attribute to.\n     * @return {void}\n     * @override\n     */\n    serializeValueToAttribute(value, attribute, node) {\n      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);\n    }\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     * @override\n     */\n    extend(prototype, api) {\n      if (!(prototype && api)) {\n        return prototype || api;\n      }\n      let n$ = Object.getOwnPropertyNames(api);\n      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n        let pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          Object.defineProperty(prototype, n, pd);\n        }\n      }\n      return prototype;\n    }\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @param {!Object} target Target object to copy properties to.\n     * @param {!Object} source Source object to copy properties from.\n     * @return {!Object} Target object that was passed as first argument.\n     * @override\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n\n    /**\n     * Sets the prototype of an object.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     * @param {Object} object The object on which to set the prototype.\n     * @param {Object} prototype The prototype that will be set on the given\n     * `object`.\n     * @return {Object} Returns the given `object` with its prototype set\n     * to the given `prototype` object.\n     * @override\n     */\n    chainObject(object, prototype) {\n      if (object && prototype && object !== prototype) {\n        object.__proto__ = prototype;\n      }\n      return object;\n    }\n\n    /* **** Begin Template **** */\n\n    /**\n     * Calls `importNode` on the `content` of the `template` specified and\n     * returns a document fragment containing the imported content.\n     *\n     * @param {HTMLTemplateElement} template HTML template element to instance.\n     * @return {!DocumentFragment} Document fragment containing the imported\n     *   template content.\n     * @override\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    instanceTemplate(template) {\n      let content = this.constructor._contentForTemplate(template);\n      let dom = /** @type {!DocumentFragment} */\n        (document.importNode(content, true));\n      return dom;\n    }\n\n    /* **** Begin Events **** */\n\n\n\n    /**\n     * Dispatches a custom event with an optional detail value.\n     *\n     * @param {string} type Name of event type.\n     * @param {*=} detail Detail value containing event-specific\n     *   payload.\n     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n     *     composed: (boolean|undefined) }=}\n     *  options Object specifying options.  These may include:\n     *  `bubbles` (boolean, defaults to `true`),\n     *  `cancelable` (boolean, defaults to false), and\n     *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n     * @return {!Event} The new event that was fired.\n     * @override\n     */\n    fire(type, detail, options) {\n      options = options || {};\n      detail = (detail === null || detail === undefined) ? {} : detail;\n      let event = new Event(type, {\n        bubbles: options.bubbles === undefined ? true : options.bubbles,\n        cancelable: Boolean(options.cancelable),\n        composed: options.composed === undefined ? true: options.composed\n      });\n      event.detail = detail;\n      let node = options.node || this;\n      wrap(node).dispatchEvent(event);\n      return event;\n    }\n\n    /**\n     * Convenience method to add an event listener on a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to add event listener to.\n     * @param {string} eventName Name of event to listen for.\n     * @param {string} methodName Name of handler method on `this` to call.\n     * @return {void}\n     * @override\n     */\n    listen(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let hbl = this.__boundListeners ||\n        (this.__boundListeners = new WeakMap());\n      let bl = hbl.get(node);\n      if (!bl) {\n        bl = {};\n        hbl.set(node, bl);\n      }\n      let key = eventName + methodName;\n      if (!bl[key]) {\n        bl[key] = this._addMethodEventListenerToNode(\n            /** @type {!Node} */ (node), eventName, methodName, this);\n      }\n    }\n\n    /**\n     * Convenience method to remove an event listener from a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to remove event listener from.\n     * @param {string} eventName Name of event to stop listening to.\n     * @param {string} methodName Name of handler method on `this` to not call\n     anymore.\n     * @return {void}\n     * @override\n     */\n    unlisten(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let bl = this.__boundListeners &&\n          this.__boundListeners.get(/** @type {!Element} */ (node));\n      let key = eventName + methodName;\n      let handler = bl && bl[key];\n      if (handler) {\n        this._removeEventListenerFromNode(\n            /** @type {!Node} */ (node), eventName, handler);\n        bl[key] = /** @type {?} */ (null);\n      }\n    }\n\n    /**\n     * Override scrolling behavior to all direction, one direction, or none.\n     *\n     * Valid scroll directions:\n     *   - 'all': scroll in any direction\n     *   - 'x': scroll only in the 'x' direction\n     *   - 'y': scroll only in the 'y' direction\n     *   - 'none': disable scrolling for this node\n     *\n     * @param {string=} direction Direction to allow scrolling\n     * Defaults to `all`.\n     * @param {Element=} node Element to apply scroll direction setting.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    setScrollDirection(direction, node) {\n      setTouchAction(\n          /** @type {!Element} */ (node || this),\n          DIRECTION_MAP[direction] || 'auto');\n    }\n    /* **** End Events **** */\n\n    /**\n     * Convenience method to run `querySelector` on this local DOM scope.\n     *\n     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n     *\n     * @param {string} slctr Selector to run on this local DOM scope\n     * @return {Element} Element found by the selector, or null if not found.\n     * @override\n     */\n    $$(slctr) {\n      // Note, no need to `wrap` this because root is always patched\n      return this.root.querySelector(slctr);\n    }\n\n    /**\n     * Return the element whose local dom within which this element\n     * is contained. This is a shorthand for\n     * `this.getRootNode().host`.\n     * @this {Element}\n     * @return {?Node} The element whose local dom within which this element is\n     * contained.\n     * @override\n     */\n    get domHost() {\n      let root = wrap(this).getRootNode();\n      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;\n    }\n\n    /**\n     * Force this element to distribute its children to its local dom.\n     * This should not be necessary as of Polymer 2.0.2 and is provided only\n     * for backwards compatibility.\n     * @return {void}\n     * @override\n     */\n    distributeContent() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */(dom(thisEl));\n      if (window.ShadyDOM && domApi.shadowRoot) {\n        ShadyDOM.flush();\n      }\n    }\n\n    /**\n     * Returns a list of nodes that are the effective childNodes. The effective\n     * childNodes list is the same as the element's childNodes except that\n     * any `<content>` elements are replaced with the list of nodes distributed\n     * to the `<content>`, the result of its `getDistributedNodes` method.\n     * @return {!Array<!Node>} List of effective child nodes.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getEffectiveChildNodes() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.getEffectiveChildNodes();\n    }\n\n    /**\n     * Returns a list of nodes distributed within this element that match\n     * `selector`. These can be dom children or elements distributed to\n     * children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of distributed elements that match selector.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    queryDistributedElements(selector) {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of elements that are the effective children. The effective\n     * children list is the same as the element's children except that\n     * any `<content>` elements are replaced with the list of elements\n     * distributed to the `<content>`.\n     *\n     * @return {!Array<!Node>} List of effective children.\n     * @override\n     */\n    getEffectiveChildren() {\n      let list = this.getEffectiveChildNodes();\n      return list.filter(function(/** @type {!Node} */ n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      });\n    }\n\n    /**\n     * Returns a string of text content that is the concatenation of the\n     * text content's of the element's effective childNodes (the elements\n     * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n     *\n     * @return {string} List of effective children.\n     * @override\n     */\n    getEffectiveTextContent() {\n      let cn = this.getEffectiveChildNodes();\n      let tc = [];\n      for (let i=0, c; (c = cn[i]); i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c.textContent);\n        }\n      }\n      return tc.join('');\n    }\n\n    /**\n     * Returns the first effective childNode within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {Node} First effective child node that matches selector.\n     * @override\n     */\n    queryEffectiveChildren(selector) {\n      let e$ = this.queryDistributedElements(selector);\n      return e$ && e$[0];\n    }\n\n    /**\n     * Returns a list of effective childNodes within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of effective child nodes that match\n     *     selector.\n     * @override\n     */\n    queryAllEffectiveChildren(selector) {\n      return this.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of nodes distributed to this element's `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its local DOM,\n     * an optional selector may be passed to choose the desired content.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<slot>`.  Defaults to `content`.\n     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n     * @override\n     */\n    getContentChildNodes(slctr) {\n      // Note, no need to `wrap` this because root is always\n      let content = this.root.querySelector(slctr || 'slot');\n      return content ?\n          /** @type {PolymerDomApi} */ (dom(content)).getDistributedNodes() :\n          [];\n    }\n\n    /**\n     * Returns a list of element children distributed to this element's\n     * `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its\n     * local DOM, an optional selector may be passed to choose the desired\n     * content.  This method differs from `getContentChildNodes` in that only\n     * elements are returned.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<content>`.  Defaults to `content`.\n     * @return {!Array<!HTMLElement>} List of distributed nodes for the\n     *   `<slot>`.\n     * @suppress {invalidCasts}\n     * @override\n     */\n    getContentChildren(slctr) {\n      let children = /** @type {!Array<!HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      }));\n      return children;\n    }\n\n    /**\n     * Checks whether an element is in this element's light DOM tree.\n     *\n     * @param {?Node} node The element to be checked.\n     * @return {boolean} true if node is in this element's light DOM tree.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    isLightDescendant(node) {\n      const thisNode = /** @type {Node} */ (this);\n      return thisNode !== node && wrap(thisNode).contains(node) &&\n        wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n    }\n\n    /**\n     * Checks whether an element is in this element's local DOM tree.\n     *\n     * @param {!Element} node The element to be checked.\n     * @return {boolean} true if node is in this element's local DOM tree.\n     * @override\n     */\n    isLocalDescendant(node) {\n      return this.root === wrap(node).getRootNode();\n    }\n\n    /**\n     * No-op for backwards compatibility. This should now be handled by\n     * ShadyCss library.\n     * @param  {!Element} container Container element to scope\n     * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n     * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n     * @override\n     */\n    scopeSubtree(container, shouldObserve = false) {\n      return scopeSubtree(container, shouldObserve);\n    }\n\n    /**\n     * Returns the computed style value for the given property.\n     * @param {string} property The css property name.\n     * @return {string} Returns the computed css property value for the given\n     * `property`.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getComputedStyleValue(property) {\n      return styleInterface.getComputedStyleValue(/** @type {!Element} */(this), property);\n    }\n\n    // debounce\n\n    /**\n     * Call `debounce` to collapse multiple requests for a named task into\n     * one invocation which is made after the wait time has elapsed with\n     * no new request.  If no wait time is given, the callback will be called\n     * at microtask timing (guaranteed before paint).\n     *\n     *     debouncedClickAction(e) {\n     *       // will not call `processClick` more than once per 100ms\n     *       this.debounce('click', function() {\n     *        this.processClick();\n     *       } 100);\n     *     }\n     *\n     * @param {string} jobName String to identify the debounce job.\n     * @param {function():void} callback Function that is called (with `this`\n     *   context) when the wait time elapses.\n     * @param {number=} wait Optional wait time in milliseconds (ms) after the\n     *   last signal that must elapse before invoking `callback`\n     * @return {!Object} Returns a debouncer object on which exists the\n     * following methods: `isActive()` returns true if the debouncer is\n     * active; `cancel()` cancels the debouncer if it is active;\n     * `flush()` immediately invokes the debounced callback if the debouncer\n     * is active.\n     * @override\n     */\n    debounce(jobName, callback, wait) {\n      this._debouncers = this._debouncers || {};\n      return this._debouncers[jobName] = Debouncer.debounce(\n            this._debouncers[jobName]\n          , wait > 0 ? timeOut.after(wait) : microTask\n          , callback.bind(this));\n    }\n\n    /**\n     * Returns whether a named debouncer is active.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {boolean} Whether the debouncer is active (has not yet fired).\n     * @override\n     */\n    isDebouncerActive(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      return !!(debouncer && debouncer.isActive());\n    }\n\n    /**\n     * Immediately calls the debouncer `callback` and inactivates it.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    flushDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.flush();\n      }\n    }\n\n    /**\n     * Cancels an active debouncer.  The `callback` will not be called.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    cancelDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.cancel();\n      }\n    }\n\n    /**\n     * Runs a callback function asynchronously.\n     *\n     * By default (if no waitTime is specified), async callbacks are run at\n     * microtask timing, which will occur before paint.\n     *\n     * @param {!Function} callback The callback function to run, bound to\n     *     `this`.\n     * @param {number=} waitTime Time to wait before calling the\n     *   `callback`.  If unspecified or 0, the callback will be run at microtask\n     *   timing (before paint).\n     * @return {number} Handle that may be used to cancel the async job.\n     * @override\n     */\n    async(callback, waitTime) {\n      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) :\n          ~microTask.run(callback.bind(this));\n    }\n\n    /**\n     * Cancels an async operation started with `async`.\n     *\n     * @param {number} handle Handle returned from original `async` call to\n     *   cancel.\n     * @return {void}\n     * @override\n     */\n    cancelAsync(handle) {\n      handle < 0 ? microTask.cancel(~handle) :\n          timeOut.cancel(handle);\n    }\n\n    // other\n\n    /**\n     * Convenience method for creating an element and configuring it.\n     *\n     * @param {string} tag HTML element tag to create.\n     * @param {Object=} props Object of properties to configure on the\n     *    instance.\n     * @return {!Element} Newly created and configured element.\n     * @override\n     */\n    create(tag, props) {\n      let elt = document.createElement(tag);\n      if (props) {\n        if (elt.setProperties) {\n          elt.setProperties(props);\n        } else {\n          for (let n in props) {\n            elt[n] = props[n];\n          }\n        }\n      }\n      return elt;\n    }\n\n    /**\n     * Polyfill for Element.prototype.matches, which is sometimes still\n     * prefixed.\n     *\n     * @param {string} selector Selector to test.\n     * @param {!Element=} node Element to test the selector against.\n     * @return {boolean} Whether the element matches the selector.\n     * @override\n     */\n    elementMatches(selector, node) {\n      return matchesSelector( (node || this), selector);\n    }\n\n    /**\n     * Toggles an HTML attribute on or off.\n     *\n     * @param {string} name HTML attribute name\n     * @param {boolean=} bool Boolean to force the attribute on or off.\n     *    When unspecified, the state of the attribute will be reversed.\n     * @return {boolean} true if the attribute now exists\n     * @override\n     */\n    toggleAttribute(name, bool) {\n      let node = /** @type {Element} */(this);\n      if (arguments.length === 3) {\n        node = /** @type {Element} */(arguments[2]);\n      }\n      if (arguments.length == 1) {\n        bool = !node.hasAttribute(name);\n      }\n      if (bool) {\n        wrap(node).setAttribute(name, '');\n        return true;\n      } else {\n        wrap(node).removeAttribute(name);\n        return false;\n      }\n    }\n\n\n    /**\n     * Toggles a CSS class on or off.\n     *\n     * @param {string} name CSS class name\n     * @param {boolean=} bool Boolean to force the class on or off.\n     *    When unspecified, the state of the class will be reversed.\n     * @param {Element=} node Node to target.  Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    toggleClass(name, bool, node) {\n      node = /** @type {Element} */ (node || this);\n      if (arguments.length == 1) {\n        bool = !node.classList.contains(name);\n      }\n      if (bool) {\n        node.classList.add(name);\n      } else {\n        node.classList.remove(name);\n      }\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `transform` property.\n     *\n     * @param {string} transformText Transform setting.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`\n     * @return {void}\n     * @override\n     */\n    transform(transformText, node) {\n      node = /** @type {Element} */ (node || this);\n      node.style.webkitTransform = transformText;\n      node.style.transform = transformText;\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `translate3d`\n     * property.\n     *\n     * @param {number|string} x X offset.\n     * @param {number|string} y Y offset.\n     * @param {number|string} z Z offset.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    translate3d(x, y, z, node) {\n      node = /** @type {Element} */ (node || this);\n      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n    }\n\n    /**\n     * Removes an item from an array, if it exists.\n     *\n     * If the array is specified by path, a change notification is\n     * generated, so that observers, data bindings and computed\n     * properties watching that path can update.\n     *\n     * If the array is passed directly, **no change\n     * notification is generated**.\n     *\n     * @param {string | !Array<number|string>} arrayOrPath Path to array from\n     *     which to remove the item\n     *   (or the array itself).\n     * @param {*} item Item to remove.\n     * @return {Array} Array containing item removed.\n     * @override\n     */\n    arrayDelete(arrayOrPath, item) {\n      let index;\n      if (Array.isArray(arrayOrPath)) {\n        index = arrayOrPath.indexOf(item);\n        if (index >= 0) {\n          return arrayOrPath.splice(index, 1);\n        }\n      } else {\n        let arr = get(this, arrayOrPath);\n        index = arr.indexOf(item);\n        if (index >= 0) {\n          return this.splice(arrayOrPath, index, 1);\n        }\n      }\n      return null;\n    }\n\n    // logging\n\n    /**\n     * Facades `console.log`/`warn`/`error` as override point.\n     *\n     * @param {string} level One of 'log', 'warn', 'error'\n     * @param {Array} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      switch(level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level](...args);\n      }\n    }\n\n    /**\n     * Facades `console.log` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _log(...args) {\n      this._logger('log', args);\n    }\n\n    /**\n     * Facades `console.warn` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _warn(...args) {\n      this._logger('warn', args);\n    }\n\n    /**\n     * Facades `console.error` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _error(...args) {\n      this._logger('error', args);\n    }\n\n    /**\n     * Formats a message using the element type an a method name.\n     *\n     * @param {string} methodName Method name to associate with message\n     * @param {...*} args Array of strings or objects to log\n     * @return {!Array} Array with formatting information for `console`\n     *   logging.\n     * @override\n     */\n    _logf(methodName, ...args) {\n      return ['[%s::%s]', this.is, methodName, ...args];\n    }\n\n  }\n\n  LegacyElement.prototype.is = '';\n\n  return LegacyElement;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}