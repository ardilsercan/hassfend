{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport '../../elevation/elevation.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../ripple/ripple.js';\nimport { html, isServer, LitElement, nothing } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { when } from 'lit/directives/when.js';\nimport { requestUpdateOnAriaChange } from '../../internal/aria/delegate.js';\nimport { dispatchActivationClick, isActivationClick } from '../../internal/events/form-label-activation.js';\nimport { redispatchEvent } from '../../internal/events/redispatch-event.js';\nimport { mixinElementInternals } from '../../labs/behaviors/element-internals.js';\nimport { getFormValue, mixinFormAssociated } from '../../labs/behaviors/form-associated.js';\n// Disable warning for classMap with destructuring\n// tslint:disable:no-implicit-dictionary-conversion\n// Separate variable needed for closure.\nconst sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));\n/**\n * Slider component.\n *\n *\n * @fires change {Event} The native `change` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)\n * --bubbles\n * @fires input {InputEvent} The native `input` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)\n * --bubbles --composed\n */\nexport class Slider extends sliderBaseClass {\n  /**\n   * The HTML name to use in form submission for a range slider's starting\n   * value. Use `name` instead if both the start and end values should use the\n   * same name.\n   */\n  get nameStart() {\n    var _this$getAttribute;\n    return (_this$getAttribute = this.getAttribute('name-start')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : this.name;\n  }\n  set nameStart(name) {\n    this.setAttribute('name-start', name);\n  }\n  /**\n   * The HTML name to use in form submission for a range slider's ending value.\n   * Use `name` instead if both the start and end values should use the same\n   * name.\n   */\n  get nameEnd() {\n    var _this$getAttribute2;\n    return (_this$getAttribute2 = this.getAttribute('name-end')) !== null && _this$getAttribute2 !== void 0 ? _this$getAttribute2 : this.nameStart;\n  }\n  set nameEnd(name) {\n    this.setAttribute('name-end', name);\n  }\n  // Note: start aria-* properties are only applied when range=true, which is\n  // why they do not need to handle both cases.\n  get renderAriaLabelStart() {\n    // Needed for closure conformance\n    const {\n      ariaLabel\n    } = this;\n    return this.ariaLabelStart || ariaLabel && `${ariaLabel} start` || this.valueLabelStart || String(this.valueStart);\n  }\n  get renderAriaValueTextStart() {\n    return this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart);\n  }\n  // Note: end aria-* properties are applied for single and range sliders, which\n  // is why it needs to handle `this.range` (while start aria-* properties do\n  // not).\n  get renderAriaLabelEnd() {\n    // Needed for closure conformance\n    const {\n      ariaLabel\n    } = this;\n    if (this.range) {\n      return this.ariaLabelEnd || ariaLabel && `${ariaLabel} end` || this.valueLabelEnd || String(this.valueEnd);\n    }\n    return ariaLabel || this.valueLabel || String(this.value);\n  }\n  get renderAriaValueTextEnd() {\n    if (this.range) {\n      return this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd);\n    }\n    // Needed for conformance\n    const {\n      ariaValueText\n    } = this;\n    return ariaValueText || this.valueLabel || String(this.value);\n  }\n  constructor() {\n    super();\n    /**\n     * The slider minimum value\n     */\n    this.min = 0;\n    /**\n     * The slider maximum value\n     */\n    this.max = 100;\n    /**\n     * An optional label for the slider's value displayed when range is\n     * false; if not set, the label is the value itself.\n     */\n    this.valueLabel = '';\n    /**\n     * An optional label for the slider's start value displayed when\n     * range is true; if not set, the label is the valueStart itself.\n     */\n    this.valueLabelStart = '';\n    /**\n     * An optional label for the slider's end value displayed when\n     * range is true; if not set, the label is the valueEnd itself.\n     */\n    this.valueLabelEnd = '';\n    /**\n     * Aria label for the slider's start handle displayed when\n     * range is true.\n     */\n    this.ariaLabelStart = '';\n    /**\n     * Aria value text for the slider's start value displayed when\n     * range is true.\n     */\n    this.ariaValueTextStart = '';\n    /**\n     * Aria label for the slider's end handle displayed when\n     * range is true.\n     */\n    this.ariaLabelEnd = '';\n    /**\n     * Aria value text for the slider's end value displayed when\n     * range is true.\n     */\n    this.ariaValueTextEnd = '';\n    /**\n     * The step between values.\n     */\n    this.step = 1;\n    /**\n     * Whether or not to show tick marks.\n     */\n    this.ticks = false;\n    /**\n     * Whether or not to show a value label when activated.\n     */\n    this.labeled = false;\n    /**\n     * Whether or not to show a value range. When false, the slider displays\n     * a slideable handle for the value property; when true, it displays\n     * slideable handles for the valueStart and valueEnd properties.\n     */\n    this.range = false;\n    // handle hover/pressed states are set manually since the handle\n    // does not receive pointer events so that the native inputs are\n    // interaction targets.\n    this.handleStartHover = false;\n    this.handleEndHover = false;\n    this.startOnTop = false;\n    this.handlesOverlapping = false;\n    // used in synthetic events generated to control ripple hover state.\n    this.ripplePointerId = 1;\n    // flag to prevent processing of re-dispatched input event.\n    this.isRedispatchingEvent = false;\n    if (!isServer) {\n      this.addEventListener('click', event => {\n        if (!isActivationClick(event) || !this.inputEnd) {\n          return;\n        }\n        this.focus();\n        dispatchActivationClick(this.inputEnd);\n      });\n    }\n  }\n  focus() {\n    var _this$inputEnd;\n    (_this$inputEnd = this.inputEnd) === null || _this$inputEnd === void 0 || _this$inputEnd.focus();\n  }\n  willUpdate(changed) {\n    var _this$inputStart, _this$inputEnd2;\n    this.renderValueStart = changed.has('valueStart') ? this.valueStart : (_this$inputStart = this.inputStart) === null || _this$inputStart === void 0 ? void 0 : _this$inputStart.valueAsNumber;\n    const endValueChanged = changed.has('valueEnd') && this.range || changed.has('value');\n    this.renderValueEnd = endValueChanged ? this.range ? this.valueEnd : this.value : (_this$inputEnd2 = this.inputEnd) === null || _this$inputEnd2 === void 0 ? void 0 : _this$inputEnd2.valueAsNumber;\n    // manually handle ripple hover state since the handle is pointer events\n    // none.\n    if (changed.get('handleStartHover') !== undefined) {\n      this.toggleRippleHover(this.rippleStart, this.handleStartHover);\n    } else if (changed.get('handleEndHover') !== undefined) {\n      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);\n    }\n  }\n  updated(changed) {\n    // Validate input rendered value and re-render if necessary. This ensures\n    // the rendred handle stays in sync with the input thumb which is used for\n    // interaction. These can get out of sync if a supplied value does not\n    // map to an exactly stepped value between min and max.\n    if (this.range) {\n      this.renderValueStart = this.inputStart.valueAsNumber;\n    }\n    this.renderValueEnd = this.inputEnd.valueAsNumber;\n    // update values if they are unset\n    // when using a range, default to equi-distant between\n    // min - valueStart - valueEnd - max\n    if (this.range) {\n      const segment = (this.max - this.min) / 3;\n      if (this.valueStart === undefined) {\n        this.inputStart.valueAsNumber = this.min + segment;\n        // read actual value from input\n        const v = this.inputStart.valueAsNumber;\n        this.valueStart = this.renderValueStart = v;\n      }\n      if (this.valueEnd === undefined) {\n        this.inputEnd.valueAsNumber = this.min + 2 * segment;\n        // read actual value from input\n        const v = this.inputEnd.valueAsNumber;\n        this.valueEnd = this.renderValueEnd = v;\n      }\n    } else {\n      var _this$value;\n      (_this$value = this.value) !== null && _this$value !== void 0 ? _this$value : this.value = this.renderValueEnd;\n    }\n    if (changed.has('range') || changed.has('renderValueStart') || changed.has('renderValueEnd') || this.isUpdatePending) {\n      var _this$handleStart, _this$handleEnd;\n      // Only check if the handle nubs are overlapping, as the ripple touch\n      // target extends subtantially beyond the boundary of the handle nub.\n      const startNub = (_this$handleStart = this.handleStart) === null || _this$handleStart === void 0 ? void 0 : _this$handleStart.querySelector('.handleNub');\n      const endNub = (_this$handleEnd = this.handleEnd) === null || _this$handleEnd === void 0 ? void 0 : _this$handleEnd.querySelector('.handleNub');\n      this.handlesOverlapping = isOverlapping(startNub, endNub);\n    }\n    // called to finish the update imediately;\n    // note, this is a no-op unless an update is scheduled\n    this.performUpdate();\n  }\n  render() {\n    var _this$renderValueStar, _this$renderValueEnd, _this$valueEnd, _this$valueStart;\n    const step = this.step === 0 ? 1 : this.step;\n    const range = Math.max(this.max - this.min, step);\n    const startFraction = this.range ? (((_this$renderValueStar = this.renderValueStart) !== null && _this$renderValueStar !== void 0 ? _this$renderValueStar : this.min) - this.min) / range : 0;\n    const endFraction = (((_this$renderValueEnd = this.renderValueEnd) !== null && _this$renderValueEnd !== void 0 ? _this$renderValueEnd : this.min) - this.min) / range;\n    const containerStyles = {\n      // for clipping inputs and active track.\n      '--_start-fraction': String(startFraction),\n      '--_end-fraction': String(endFraction),\n      // for generating tick marks\n      '--_tick-count': String(range / step)\n    };\n    const containerClasses = {\n      ranged: this.range\n    };\n    // optional label values to show in place of the value.\n    const labelStart = this.valueLabelStart || String(this.renderValueStart);\n    const labelEnd = (this.range ? this.valueLabelEnd : this.valueLabel) || String(this.renderValueEnd);\n    const inputStartProps = {\n      start: true,\n      value: this.renderValueStart,\n      ariaLabel: this.renderAriaLabelStart,\n      ariaValueText: this.renderAriaValueTextStart,\n      ariaMin: this.min,\n      ariaMax: (_this$valueEnd = this.valueEnd) !== null && _this$valueEnd !== void 0 ? _this$valueEnd : this.max\n    };\n    const inputEndProps = {\n      start: false,\n      value: this.renderValueEnd,\n      ariaLabel: this.renderAriaLabelEnd,\n      ariaValueText: this.renderAriaValueTextEnd,\n      ariaMin: this.range ? (_this$valueStart = this.valueStart) !== null && _this$valueStart !== void 0 ? _this$valueStart : this.min : this.min,\n      ariaMax: this.max\n    };\n    const handleStartProps = {\n      start: true,\n      hover: this.handleStartHover,\n      label: labelStart\n    };\n    const handleEndProps = {\n      start: false,\n      hover: this.handleEndHover,\n      label: labelEnd\n    };\n    const handleContainerClasses = {\n      hover: this.handleStartHover || this.handleEndHover\n    };\n    return html` <div\n      class=\"container ${classMap(containerClasses)}\"\n      style=${styleMap(containerStyles)}>\n      ${when(this.range, () => this.renderInput(inputStartProps))}\n      ${this.renderInput(inputEndProps)} ${this.renderTrack()}\n      <div class=\"handleContainerPadded\">\n        <div class=\"handleContainerBlock\">\n          <div class=\"handleContainer ${classMap(handleContainerClasses)}\">\n            ${when(this.range, () => this.renderHandle(handleStartProps))}\n            ${this.renderHandle(handleEndProps)}\n          </div>\n        </div>\n      </div>\n    </div>`;\n  }\n  renderTrack() {\n    return html`\n      <div class=\"track\"></div>\n      ${this.ticks ? html`<div class=\"tickmarks\"></div>` : nothing}\n    `;\n  }\n  renderLabel(value) {\n    return html`<div class=\"label\" aria-hidden=\"true\">\n      <span class=\"labelContent\" part=\"label\">${value}</span>\n    </div>`;\n  }\n  renderHandle({\n    start,\n    hover,\n    label\n  }) {\n    const onTop = !this.disabled && start === this.startOnTop;\n    const isOverlapping = !this.disabled && this.handlesOverlapping;\n    const name = start ? 'start' : 'end';\n    return html`<div\n      class=\"handle ${classMap({\n      [name]: true,\n      hover,\n      onTop,\n      isOverlapping\n    })}\">\n      <md-focus-ring part=\"focus-ring\" for=${name}></md-focus-ring>\n      <md-ripple\n        for=${name}\n        class=${name}\n        ?disabled=${this.disabled}></md-ripple>\n      <div class=\"handleNub\"><md-elevation></md-elevation></div>\n      ${when(this.labeled, () => this.renderLabel(label))}\n    </div>`;\n  }\n  renderInput({\n    start,\n    value,\n    ariaLabel,\n    ariaValueText,\n    ariaMin,\n    ariaMax\n  }) {\n    // Slider requires min/max set to the overall min/max for both inputs.\n    // This is reported to screen readers, which is why we need aria-valuemin\n    // and aria-valuemax.\n    const name = start ? `start` : `end`;\n    return html`<input\n      type=\"range\"\n      class=\"${classMap({\n      start,\n      end: !start\n    })}\"\n      @focus=${this.handleFocus}\n      @pointerdown=${this.handleDown}\n      @pointerup=${this.handleUp}\n      @pointerenter=${this.handleEnter}\n      @pointermove=${this.handleMove}\n      @pointerleave=${this.handleLeave}\n      @keydown=${this.handleKeydown}\n      @keyup=${this.handleKeyup}\n      @input=${this.handleInput}\n      @change=${this.handleChange}\n      id=${name}\n      .disabled=${this.disabled}\n      .min=${String(this.min)}\n      aria-valuemin=${ariaMin}\n      .max=${String(this.max)}\n      aria-valuemax=${ariaMax}\n      .step=${String(this.step)}\n      .value=${String(value)}\n      .tabIndex=${start ? 1 : 0}\n      aria-label=${ariaLabel || nothing}\n      aria-valuetext=${ariaValueText} />`;\n  }\n  async toggleRippleHover(ripple, hovering) {\n    const rippleEl = await ripple;\n    if (!rippleEl) {\n      return;\n    }\n    // TODO(b/269799771): improve slider ripple connection\n    if (hovering) {\n      rippleEl.handlePointerenter(new PointerEvent('pointerenter', {\n        isPrimary: true,\n        pointerId: this.ripplePointerId\n      }));\n    } else {\n      rippleEl.handlePointerleave(new PointerEvent('pointerleave', {\n        isPrimary: true,\n        pointerId: this.ripplePointerId\n      }));\n    }\n  }\n  handleFocus(event) {\n    this.updateOnTop(event.target);\n  }\n  startAction(event) {\n    const target = event.target;\n    const fixed = target === this.inputStart ? this.inputEnd : this.inputStart;\n    this.action = {\n      canFlip: event.type === 'pointerdown',\n      flipped: false,\n      target,\n      fixed,\n      values: new Map([[target, target.valueAsNumber], [fixed, fixed === null || fixed === void 0 ? void 0 : fixed.valueAsNumber]])\n    };\n  }\n  finishAction(event) {\n    this.action = undefined;\n  }\n  handleKeydown(event) {\n    this.startAction(event);\n  }\n  handleKeyup(event) {\n    this.finishAction(event);\n  }\n  handleDown(event) {\n    this.startAction(event);\n    this.ripplePointerId = event.pointerId;\n    const isStart = event.target === this.inputStart;\n    // Since handle moves to pointer on down and there may not be a move,\n    // it needs to be considered hovered..\n    this.handleStartHover = !this.disabled && isStart && Boolean(this.handleStart);\n    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);\n  }\n  async handleUp(event) {\n    if (!this.action) {\n      return;\n    }\n    const {\n      target,\n      values,\n      flipped\n    } = this.action;\n    //  Async here for Firefox because input can be after pointerup\n    //  when value is calmped.\n    await new Promise(requestAnimationFrame);\n    if (target !== undefined) {\n      // Ensure Safari focuses input so label renders.\n      // Ensure any flipped input is focused so the tab order is right.\n      target.focus();\n      // When action is flipped, change must be fired manually since the\n      // real event target did not change.\n      if (flipped && target.valueAsNumber !== values.get(target)) {\n        target.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n      }\n    }\n    this.finishAction(event);\n  }\n  /**\n   * The move handler tracks handle hovering to facilitate proper ripple\n   * behavior on the slider handle. This is needed because user interaction with\n   * the native input is leveraged to position the handle. Because the separate\n   * displayed handle element has pointer events disabled (to allow interaction\n   * with the input) and the input's handle is a pseudo-element, neither can be\n   * the ripple's interactive element. Therefore the input is the ripple's\n   * interactive element and has a `ripple` directive; however the ripple\n   * is gated on the handle being hovered. In addition, because the ripple\n   * hover state is being specially handled, it must be triggered independent\n   * of the directive. This is done based on the hover state when the\n   * slider is updated.\n   */\n  handleMove(event) {\n    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);\n    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);\n  }\n  handleEnter(event) {\n    this.handleMove(event);\n  }\n  handleLeave() {\n    this.handleStartHover = false;\n    this.handleEndHover = false;\n  }\n  updateOnTop(input) {\n    this.startOnTop = input.classList.contains('start');\n  }\n  needsClamping() {\n    if (!this.action) {\n      return false;\n    }\n    const {\n      target,\n      fixed\n    } = this.action;\n    const isStart = target === this.inputStart;\n    return isStart ? target.valueAsNumber > fixed.valueAsNumber : target.valueAsNumber < fixed.valueAsNumber;\n  }\n  // if start/end start coincident and the first drag input would e.g. move\n  // start > end, avoid clamping and \"flip\" to use the other input\n  // as the action target.\n  isActionFlipped() {\n    const {\n      action\n    } = this;\n    if (!action) {\n      return false;\n    }\n    const {\n      target,\n      fixed,\n      values\n    } = action;\n    if (action.canFlip) {\n      const coincident = values.get(target) === values.get(fixed);\n      if (coincident && this.needsClamping()) {\n        action.canFlip = false;\n        action.flipped = true;\n        action.target = fixed;\n        action.fixed = target;\n      }\n    }\n    return action.flipped;\n  }\n  // when flipped, apply the drag input to the flipped target and reset\n  // the actual target.\n  flipAction() {\n    if (!this.action) {\n      return false;\n    }\n    const {\n      target,\n      fixed,\n      values\n    } = this.action;\n    const changed = target.valueAsNumber !== fixed.valueAsNumber;\n    target.valueAsNumber = fixed.valueAsNumber;\n    fixed.valueAsNumber = values.get(fixed);\n    return changed;\n  }\n  // clamp such that start does not move beyond end and visa versa.\n  clampAction() {\n    if (!this.needsClamping() || !this.action) {\n      return false;\n    }\n    const {\n      target,\n      fixed\n    } = this.action;\n    target.valueAsNumber = fixed.valueAsNumber;\n    return true;\n  }\n  handleInput(event) {\n    // avoid processing a re-dispatched event\n    if (this.isRedispatchingEvent) {\n      return;\n    }\n    let stopPropagation = false;\n    let redispatch = false;\n    if (this.range) {\n      if (this.isActionFlipped()) {\n        stopPropagation = true;\n        redispatch = this.flipAction();\n      }\n      if (this.clampAction()) {\n        stopPropagation = true;\n        redispatch = false;\n      }\n    }\n    const target = event.target;\n    this.updateOnTop(target);\n    // update value only on interaction\n    if (this.range) {\n      this.valueStart = this.inputStart.valueAsNumber;\n      this.valueEnd = this.inputEnd.valueAsNumber;\n    } else {\n      this.value = this.inputEnd.valueAsNumber;\n    }\n    // control external visibility of input event\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n    // ensure event path is correct when flipped.\n    if (redispatch) {\n      this.isRedispatchingEvent = true;\n      redispatchEvent(target, event);\n      this.isRedispatchingEvent = false;\n    }\n  }\n  handleChange(event) {\n    var _this$action;\n    // prevent keyboard triggered changes from dispatching for\n    // clamped values; note, this only occurs for keyboard\n    const changeTarget = event.target;\n    const {\n      target,\n      values\n    } = (_this$action = this.action) !== null && _this$action !== void 0 ? _this$action : {};\n    const squelch = target && target.valueAsNumber === values.get(changeTarget);\n    if (!squelch) {\n      redispatchEvent(this, event);\n    }\n    // ensure keyboard triggered change clears action.\n    this.finishAction(event);\n  }\n  [getFormValue]() {\n    if (this.range) {\n      const data = new FormData();\n      data.append(this.nameStart, String(this.valueStart));\n      data.append(this.nameEnd, String(this.valueEnd));\n      return data;\n    }\n    return String(this.value);\n  }\n  formResetCallback() {\n    if (this.range) {\n      const valueStart = this.getAttribute('value-start');\n      this.valueStart = valueStart !== null ? Number(valueStart) : undefined;\n      const valueEnd = this.getAttribute('value-end');\n      this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;\n      return;\n    }\n    const value = this.getAttribute('value');\n    this.value = value !== null ? Number(value) : undefined;\n  }\n  formStateRestoreCallback(state) {\n    if (Array.isArray(state)) {\n      const [[, valueStart], [, valueEnd]] = state;\n      this.valueStart = Number(valueStart);\n      this.valueEnd = Number(valueEnd);\n      this.range = true;\n      return;\n    }\n    this.value = Number(state);\n    this.range = false;\n  }\n}\n(() => {\n  requestUpdateOnAriaChange(Slider);\n})();\n/** @nocollapse */\nSlider.shadowRootOptions = {\n  ...LitElement.shadowRootOptions,\n  delegatesFocus: true\n};\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"min\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"max\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"value\", void 0);\n__decorate([property({\n  type: Number,\n  attribute: 'value-start'\n})], Slider.prototype, \"valueStart\", void 0);\n__decorate([property({\n  type: Number,\n  attribute: 'value-end'\n})], Slider.prototype, \"valueEnd\", void 0);\n__decorate([property({\n  attribute: 'value-label'\n})], Slider.prototype, \"valueLabel\", void 0);\n__decorate([property({\n  attribute: 'value-label-start'\n})], Slider.prototype, \"valueLabelStart\", void 0);\n__decorate([property({\n  attribute: 'value-label-end'\n})], Slider.prototype, \"valueLabelEnd\", void 0);\n__decorate([property({\n  attribute: 'aria-label-start'\n})], Slider.prototype, \"ariaLabelStart\", void 0);\n__decorate([property({\n  attribute: 'aria-valuetext-start'\n})], Slider.prototype, \"ariaValueTextStart\", void 0);\n__decorate([property({\n  attribute: 'aria-label-end'\n})], Slider.prototype, \"ariaLabelEnd\", void 0);\n__decorate([property({\n  attribute: 'aria-valuetext-end'\n})], Slider.prototype, \"ariaValueTextEnd\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"step\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"ticks\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"labeled\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"range\", void 0);\n__decorate([query('input.start')], Slider.prototype, \"inputStart\", void 0);\n__decorate([query('.handle.start')], Slider.prototype, \"handleStart\", void 0);\n__decorate([queryAsync('md-ripple.start')], Slider.prototype, \"rippleStart\", void 0);\n__decorate([query('input.end')], Slider.prototype, \"inputEnd\", void 0);\n__decorate([query('.handle.end')], Slider.prototype, \"handleEnd\", void 0);\n__decorate([queryAsync('md-ripple.end')], Slider.prototype, \"rippleEnd\", void 0);\n__decorate([state()], Slider.prototype, \"handleStartHover\", void 0);\n__decorate([state()], Slider.prototype, \"handleEndHover\", void 0);\n__decorate([state()], Slider.prototype, \"startOnTop\", void 0);\n__decorate([state()], Slider.prototype, \"handlesOverlapping\", void 0);\n__decorate([state()], Slider.prototype, \"renderValueStart\", void 0);\n__decorate([state()], Slider.prototype, \"renderValueEnd\", void 0);\nfunction inBounds({\n  x,\n  y\n}, element) {\n  if (!element) {\n    return false;\n  }\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = element.getBoundingClientRect();\n  return x >= left && x <= right && y >= top && y <= bottom;\n}\nfunction isOverlapping(elA, elB) {\n  if (!(elA && elB)) {\n    return false;\n  }\n  const a = elA.getBoundingClientRect();\n  const b = elB.getBoundingClientRect();\n  return !(a.top > b.bottom || a.right < b.left || a.bottom < b.top || a.left > b.right);\n}","map":{"version":3,"names":["html","isServer","LitElement","nothing","property","query","queryAsync","state","classMap","styleMap","when","requestUpdateOnAriaChange","dispatchActivationClick","isActivationClick","redispatchEvent","mixinElementInternals","getFormValue","mixinFormAssociated","sliderBaseClass","Slider","nameStart","_this$getAttribute","getAttribute","name","setAttribute","nameEnd","_this$getAttribute2","renderAriaLabelStart","ariaLabel","ariaLabelStart","valueLabelStart","String","valueStart","renderAriaValueTextStart","ariaValueTextStart","renderAriaLabelEnd","range","ariaLabelEnd","valueLabelEnd","valueEnd","valueLabel","value","renderAriaValueTextEnd","ariaValueTextEnd","ariaValueText","constructor","min","max","step","ticks","labeled","handleStartHover","handleEndHover","startOnTop","handlesOverlapping","ripplePointerId","isRedispatchingEvent","addEventListener","event","inputEnd","focus","_this$inputEnd","willUpdate","changed","_this$inputStart","_this$inputEnd2","renderValueStart","has","inputStart","valueAsNumber","endValueChanged","renderValueEnd","get","undefined","toggleRippleHover","rippleStart","rippleEnd","updated","segment","v","_this$value","isUpdatePending","_this$handleStart","_this$handleEnd","startNub","handleStart","querySelector","endNub","handleEnd","isOverlapping","performUpdate","render","_this$renderValueStar","_this$renderValueEnd","_this$valueEnd","_this$valueStart","Math","startFraction","endFraction","containerStyles","containerClasses","ranged","labelStart","labelEnd","inputStartProps","start","ariaMin","ariaMax","inputEndProps","handleStartProps","hover","label","handleEndProps","handleContainerClasses","renderInput","renderTrack","renderHandle","renderLabel","onTop","disabled","end","handleFocus","handleDown","handleUp","handleEnter","handleMove","handleLeave","handleKeydown","handleKeyup","handleInput","handleChange","ripple","hovering","rippleEl","handlePointerenter","PointerEvent","isPrimary","pointerId","handlePointerleave","updateOnTop","target","startAction","fixed","action","canFlip","type","flipped","values","Map","finishAction","isStart","Boolean","Promise","requestAnimationFrame","dispatchEvent","Event","bubbles","inBounds","input","classList","contains","needsClamping","isActionFlipped","coincident","flipAction","clampAction","stopPropagation","redispatch","_this$action","changeTarget","squelch","data","FormData","append","formResetCallback","Number","formStateRestoreCallback","Array","isArray","shadowRootOptions","delegatesFocus","__decorate","attribute","x","y","element","top","left","bottom","right","getBoundingClientRect","elA","elB","a","b"],"sources":["slider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../elevation/elevation.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../ripple/ripple.js';\n\nimport {html, isServer, LitElement, nothing, PropertyValues} from 'lit';\nimport {property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\nimport {when} from 'lit/directives/when.js';\n\nimport {ARIAMixinStrict} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {\n  dispatchActivationClick,\n  isActivationClick,\n} from '../../internal/events/form-label-activation.js';\nimport {redispatchEvent} from '../../internal/events/redispatch-event.js';\nimport {mixinElementInternals} from '../../labs/behaviors/element-internals.js';\nimport {\n  getFormValue,\n  mixinFormAssociated,\n} from '../../labs/behaviors/form-associated.js';\nimport {MdRipple} from '../../ripple/ripple.js';\n\n// Disable warning for classMap with destructuring\n// tslint:disable:no-implicit-dictionary-conversion\n\n// Separate variable needed for closure.\nconst sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));\n\n/**\n * Slider component.\n *\n *\n * @fires change {Event} The native `change` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)\n * --bubbles\n * @fires input {InputEvent} The native `input` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)\n * --bubbles --composed\n */\nexport class Slider extends sliderBaseClass {\n  static {\n    requestUpdateOnAriaChange(Slider);\n  }\n\n  /** @nocollapse */\n  static override shadowRootOptions: ShadowRootInit = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  /**\n   * The slider minimum value\n   */\n  @property({type: Number}) min = 0;\n\n  /**\n   * The slider maximum value\n   */\n  @property({type: Number}) max = 100;\n\n  /**\n   * The slider value displayed when range is false.\n   */\n  @property({type: Number}) value?: number;\n\n  /**\n   * The slider start value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-start'}) valueStart?: number;\n\n  /**\n   * The slider end value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-end'}) valueEnd?: number;\n\n  /**\n   * An optional label for the slider's value displayed when range is\n   * false; if not set, the label is the value itself.\n   */\n  @property({attribute: 'value-label'}) valueLabel = '';\n\n  /**\n   * An optional label for the slider's start value displayed when\n   * range is true; if not set, the label is the valueStart itself.\n   */\n  @property({attribute: 'value-label-start'}) valueLabelStart = '';\n\n  /**\n   * An optional label for the slider's end value displayed when\n   * range is true; if not set, the label is the valueEnd itself.\n   */\n  @property({attribute: 'value-label-end'}) valueLabelEnd = '';\n\n  /**\n   * Aria label for the slider's start handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-start'}) ariaLabelStart = '';\n\n  /**\n   * Aria value text for the slider's start value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-start'}) ariaValueTextStart = '';\n\n  /**\n   * Aria label for the slider's end handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-end'}) ariaLabelEnd = '';\n\n  /**\n   * Aria value text for the slider's end value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-end'}) ariaValueTextEnd = '';\n\n  /**\n   * The step between values.\n   */\n  @property({type: Number}) step = 1;\n\n  /**\n   * Whether or not to show tick marks.\n   */\n  @property({type: Boolean}) ticks = false;\n\n  /**\n   * Whether or not to show a value label when activated.\n   */\n  @property({type: Boolean}) labeled = false;\n\n  /**\n   * Whether or not to show a value range. When false, the slider displays\n   * a slideable handle for the value property; when true, it displays\n   * slideable handles for the valueStart and valueEnd properties.\n   */\n  @property({type: Boolean}) range = false;\n\n  /**\n   * The HTML name to use in form submission for a range slider's starting\n   * value. Use `name` instead if both the start and end values should use the\n   * same name.\n   */\n  get nameStart() {\n    return this.getAttribute('name-start') ?? this.name;\n  }\n  set nameStart(name: string) {\n    this.setAttribute('name-start', name);\n  }\n\n  /**\n   * The HTML name to use in form submission for a range slider's ending value.\n   * Use `name` instead if both the start and end values should use the same\n   * name.\n   */\n  get nameEnd() {\n    return this.getAttribute('name-end') ?? this.nameStart;\n  }\n  set nameEnd(name: string) {\n    this.setAttribute('name-end', name);\n  }\n\n  @query('input.start') private readonly inputStart!: HTMLInputElement | null;\n  @query('.handle.start') private readonly handleStart!: HTMLDivElement | null;\n  @queryAsync('md-ripple.start')\n  private readonly rippleStart!: Promise<MdRipple | null>;\n\n  @query('input.end') private readonly inputEnd!: HTMLInputElement | null;\n  @query('.handle.end') private readonly handleEnd!: HTMLDivElement | null;\n  @queryAsync('md-ripple.end')\n  private readonly rippleEnd!: Promise<MdRipple | null>;\n\n  // handle hover/pressed states are set manually since the handle\n  // does not receive pointer events so that the native inputs are\n  // interaction targets.\n  @state() private handleStartHover = false;\n  @state() private handleEndHover = false;\n\n  @state() private startOnTop = false;\n  @state() private handlesOverlapping = false;\n\n  @state() private renderValueStart?: number;\n  @state() private renderValueEnd?: number;\n\n  // Note: start aria-* properties are only applied when range=true, which is\n  // why they do not need to handle both cases.\n  private get renderAriaLabelStart() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return (\n      this.ariaLabelStart ||\n      (ariaLabel && `${ariaLabel} start`) ||\n      this.valueLabelStart ||\n      String(this.valueStart)\n    );\n  }\n\n  private get renderAriaValueTextStart() {\n    return (\n      this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart)\n    );\n  }\n\n  // Note: end aria-* properties are applied for single and range sliders, which\n  // is why it needs to handle `this.range` (while start aria-* properties do\n  // not).\n  private get renderAriaLabelEnd() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    if (this.range) {\n      return (\n        this.ariaLabelEnd ||\n        (ariaLabel && `${ariaLabel} end`) ||\n        this.valueLabelEnd ||\n        String(this.valueEnd)\n      );\n    }\n\n    return ariaLabel || this.valueLabel || String(this.value);\n  }\n\n  private get renderAriaValueTextEnd() {\n    if (this.range) {\n      return (\n        this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd)\n      );\n    }\n\n    // Needed for conformance\n    const {ariaValueText} = this as ARIAMixinStrict;\n    return ariaValueText || this.valueLabel || String(this.value);\n  }\n\n  // used in synthetic events generated to control ripple hover state.\n  private ripplePointerId = 1;\n\n  // flag to prevent processing of re-dispatched input event.\n  private isRedispatchingEvent = false;\n\n  private action?: Action;\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('click', (event: MouseEvent) => {\n        if (!isActivationClick(event) || !this.inputEnd) {\n          return;\n        }\n        this.focus();\n        dispatchActivationClick(this.inputEnd);\n      });\n    }\n  }\n\n  override focus() {\n    this.inputEnd?.focus();\n  }\n\n  protected override willUpdate(changed: PropertyValues) {\n    this.renderValueStart = changed.has('valueStart')\n      ? this.valueStart\n      : this.inputStart?.valueAsNumber;\n    const endValueChanged =\n      (changed.has('valueEnd') && this.range) || changed.has('value');\n    this.renderValueEnd = endValueChanged\n      ? this.range\n        ? this.valueEnd\n        : this.value\n      : this.inputEnd?.valueAsNumber;\n    // manually handle ripple hover state since the handle is pointer events\n    // none.\n    if (changed.get('handleStartHover') !== undefined) {\n      this.toggleRippleHover(this.rippleStart, this.handleStartHover);\n    } else if (changed.get('handleEndHover') !== undefined) {\n      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);\n    }\n  }\n\n  protected override updated(changed: PropertyValues) {\n    // Validate input rendered value and re-render if necessary. This ensures\n    // the rendred handle stays in sync with the input thumb which is used for\n    // interaction. These can get out of sync if a supplied value does not\n    // map to an exactly stepped value between min and max.\n    if (this.range) {\n      this.renderValueStart = this.inputStart!.valueAsNumber;\n    }\n    this.renderValueEnd = this.inputEnd!.valueAsNumber;\n    // update values if they are unset\n    // when using a range, default to equi-distant between\n    // min - valueStart - valueEnd - max\n    if (this.range) {\n      const segment = (this.max - this.min) / 3;\n      if (this.valueStart === undefined) {\n        this.inputStart!.valueAsNumber = this.min + segment;\n        // read actual value from input\n        const v = this.inputStart!.valueAsNumber;\n        this.valueStart = this.renderValueStart = v;\n      }\n      if (this.valueEnd === undefined) {\n        this.inputEnd!.valueAsNumber = this.min + 2 * segment;\n        // read actual value from input\n        const v = this.inputEnd!.valueAsNumber;\n        this.valueEnd = this.renderValueEnd = v;\n      }\n    } else {\n      this.value ??= this.renderValueEnd;\n    }\n    if (\n      changed.has('range') ||\n      changed.has('renderValueStart') ||\n      changed.has('renderValueEnd') ||\n      this.isUpdatePending\n    ) {\n      // Only check if the handle nubs are overlapping, as the ripple touch\n      // target extends subtantially beyond the boundary of the handle nub.\n      const startNub = this.handleStart?.querySelector('.handleNub');\n      const endNub = this.handleEnd?.querySelector('.handleNub');\n      this.handlesOverlapping = isOverlapping(startNub, endNub);\n    }\n    // called to finish the update imediately;\n    // note, this is a no-op unless an update is scheduled\n    this.performUpdate();\n  }\n\n  protected override render() {\n    const step = this.step === 0 ? 1 : this.step;\n    const range = Math.max(this.max - this.min, step);\n    const startFraction = this.range\n      ? ((this.renderValueStart ?? this.min) - this.min) / range\n      : 0;\n    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;\n    const containerStyles = {\n      // for clipping inputs and active track.\n      '--_start-fraction': String(startFraction),\n      '--_end-fraction': String(endFraction),\n      // for generating tick marks\n      '--_tick-count': String(range / step),\n    };\n    const containerClasses = {ranged: this.range};\n\n    // optional label values to show in place of the value.\n    const labelStart = this.valueLabelStart || String(this.renderValueStart);\n    const labelEnd =\n      (this.range ? this.valueLabelEnd : this.valueLabel) ||\n      String(this.renderValueEnd);\n\n    const inputStartProps = {\n      start: true,\n      value: this.renderValueStart,\n      ariaLabel: this.renderAriaLabelStart,\n      ariaValueText: this.renderAriaValueTextStart,\n      ariaMin: this.min,\n      ariaMax: this.valueEnd ?? this.max,\n    };\n\n    const inputEndProps = {\n      start: false,\n      value: this.renderValueEnd,\n      ariaLabel: this.renderAriaLabelEnd,\n      ariaValueText: this.renderAriaValueTextEnd,\n      ariaMin: this.range ? this.valueStart ?? this.min : this.min,\n      ariaMax: this.max,\n    };\n\n    const handleStartProps = {\n      start: true,\n      hover: this.handleStartHover,\n      label: labelStart,\n    };\n\n    const handleEndProps = {\n      start: false,\n      hover: this.handleEndHover,\n      label: labelEnd,\n    };\n\n    const handleContainerClasses = {\n      hover: this.handleStartHover || this.handleEndHover,\n    };\n\n    return html` <div\n      class=\"container ${classMap(containerClasses)}\"\n      style=${styleMap(containerStyles)}>\n      ${when(this.range, () => this.renderInput(inputStartProps))}\n      ${this.renderInput(inputEndProps)} ${this.renderTrack()}\n      <div class=\"handleContainerPadded\">\n        <div class=\"handleContainerBlock\">\n          <div class=\"handleContainer ${classMap(handleContainerClasses)}\">\n            ${when(this.range, () => this.renderHandle(handleStartProps))}\n            ${this.renderHandle(handleEndProps)}\n          </div>\n        </div>\n      </div>\n    </div>`;\n  }\n\n  private renderTrack() {\n    return html`\n      <div class=\"track\"></div>\n      ${this.ticks ? html`<div class=\"tickmarks\"></div>` : nothing}\n    `;\n  }\n\n  private renderLabel(value: string) {\n    return html`<div class=\"label\" aria-hidden=\"true\">\n      <span class=\"labelContent\" part=\"label\">${value}</span>\n    </div>`;\n  }\n\n  private renderHandle({\n    start,\n    hover,\n    label,\n  }: {\n    start: boolean;\n    hover: boolean;\n    label: string;\n  }) {\n    const onTop = !this.disabled && start === this.startOnTop;\n    const isOverlapping = !this.disabled && this.handlesOverlapping;\n    const name = start ? 'start' : 'end';\n    return html`<div\n      class=\"handle ${classMap({\n        [name]: true,\n        hover,\n        onTop,\n        isOverlapping,\n      })}\">\n      <md-focus-ring part=\"focus-ring\" for=${name}></md-focus-ring>\n      <md-ripple\n        for=${name}\n        class=${name}\n        ?disabled=${this.disabled}></md-ripple>\n      <div class=\"handleNub\"><md-elevation></md-elevation></div>\n      ${when(this.labeled, () => this.renderLabel(label))}\n    </div>`;\n  }\n\n  private renderInput({\n    start,\n    value,\n    ariaLabel,\n    ariaValueText,\n    ariaMin,\n    ariaMax,\n  }: {\n    start: boolean;\n    value?: number;\n    ariaLabel: string;\n    ariaValueText: string;\n    ariaMin: number;\n    ariaMax: number;\n  }) {\n    // Slider requires min/max set to the overall min/max for both inputs.\n    // This is reported to screen readers, which is why we need aria-valuemin\n    // and aria-valuemax.\n    const name = start ? `start` : `end`;\n    return html`<input\n      type=\"range\"\n      class=\"${classMap({\n        start,\n        end: !start,\n      })}\"\n      @focus=${this.handleFocus}\n      @pointerdown=${this.handleDown}\n      @pointerup=${this.handleUp}\n      @pointerenter=${this.handleEnter}\n      @pointermove=${this.handleMove}\n      @pointerleave=${this.handleLeave}\n      @keydown=${this.handleKeydown}\n      @keyup=${this.handleKeyup}\n      @input=${this.handleInput}\n      @change=${this.handleChange}\n      id=${name}\n      .disabled=${this.disabled}\n      .min=${String(this.min)}\n      aria-valuemin=${ariaMin}\n      .max=${String(this.max)}\n      aria-valuemax=${ariaMax}\n      .step=${String(this.step)}\n      .value=${String(value)}\n      .tabIndex=${start ? 1 : 0}\n      aria-label=${ariaLabel || nothing}\n      aria-valuetext=${ariaValueText} />`;\n  }\n\n  private async toggleRippleHover(\n    ripple: Promise<MdRipple | null>,\n    hovering: boolean,\n  ) {\n    const rippleEl = await ripple;\n    if (!rippleEl) {\n      return;\n    }\n    // TODO(b/269799771): improve slider ripple connection\n    if (hovering) {\n      rippleEl.handlePointerenter(\n        new PointerEvent('pointerenter', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    } else {\n      rippleEl.handlePointerleave(\n        new PointerEvent('pointerleave', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    }\n  }\n\n  private handleFocus(event: Event) {\n    this.updateOnTop(event.target as HTMLInputElement);\n  }\n\n  private startAction(event: Event) {\n    const target = event.target as HTMLInputElement;\n    const fixed =\n      target === this.inputStart ? this.inputEnd! : this.inputStart!;\n    this.action = {\n      canFlip: event.type === 'pointerdown',\n      flipped: false,\n      target,\n      fixed,\n      values: new Map([\n        [target, target.valueAsNumber],\n        [fixed, fixed?.valueAsNumber],\n      ]),\n    };\n  }\n\n  private finishAction(event: Event) {\n    this.action = undefined;\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    this.startAction(event);\n  }\n\n  private handleKeyup(event: KeyboardEvent) {\n    this.finishAction(event);\n  }\n\n  private handleDown(event: PointerEvent) {\n    this.startAction(event);\n    this.ripplePointerId = event.pointerId;\n    const isStart = (event.target as HTMLInputElement) === this.inputStart;\n    // Since handle moves to pointer on down and there may not be a move,\n    // it needs to be considered hovered..\n    this.handleStartHover =\n      !this.disabled && isStart && Boolean(this.handleStart);\n    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);\n  }\n\n  private async handleUp(event: PointerEvent) {\n    if (!this.action) {\n      return;\n    }\n\n    const {target, values, flipped} = this.action;\n    //  Async here for Firefox because input can be after pointerup\n    //  when value is calmped.\n    await new Promise(requestAnimationFrame);\n    if (target !== undefined) {\n      // Ensure Safari focuses input so label renders.\n      // Ensure any flipped input is focused so the tab order is right.\n      target.focus();\n      // When action is flipped, change must be fired manually since the\n      // real event target did not change.\n      if (flipped && target.valueAsNumber !== values.get(target)!) {\n        target.dispatchEvent(new Event('change', {bubbles: true}));\n      }\n    }\n    this.finishAction(event);\n  }\n\n  /**\n   * The move handler tracks handle hovering to facilitate proper ripple\n   * behavior on the slider handle. This is needed because user interaction with\n   * the native input is leveraged to position the handle. Because the separate\n   * displayed handle element has pointer events disabled (to allow interaction\n   * with the input) and the input's handle is a pseudo-element, neither can be\n   * the ripple's interactive element. Therefore the input is the ripple's\n   * interactive element and has a `ripple` directive; however the ripple\n   * is gated on the handle being hovered. In addition, because the ripple\n   * hover state is being specially handled, it must be triggered independent\n   * of the directive. This is done based on the hover state when the\n   * slider is updated.\n   */\n  private handleMove(event: PointerEvent) {\n    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);\n    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);\n  }\n\n  private handleEnter(event: PointerEvent) {\n    this.handleMove(event);\n  }\n\n  private handleLeave() {\n    this.handleStartHover = false;\n    this.handleEndHover = false;\n  }\n\n  private updateOnTop(input: HTMLInputElement) {\n    this.startOnTop = input.classList.contains('start');\n  }\n\n  private needsClamping() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed} = this.action;\n    const isStart = target === this.inputStart;\n    return isStart\n      ? target.valueAsNumber > fixed.valueAsNumber\n      : target.valueAsNumber < fixed.valueAsNumber;\n  }\n\n  // if start/end start coincident and the first drag input would e.g. move\n  // start > end, avoid clamping and \"flip\" to use the other input\n  // as the action target.\n  private isActionFlipped() {\n    const {action} = this;\n    if (!action) {\n      return false;\n    }\n\n    const {target, fixed, values} = action;\n    if (action.canFlip) {\n      const coincident = values.get(target) === values.get(fixed);\n      if (coincident && this.needsClamping()) {\n        action.canFlip = false;\n        action.flipped = true;\n        action.target = fixed;\n        action.fixed = target;\n      }\n    }\n    return action.flipped;\n  }\n\n  // when flipped, apply the drag input to the flipped target and reset\n  // the actual target.\n  private flipAction() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed, values} = this.action;\n    const changed = target.valueAsNumber !== fixed.valueAsNumber;\n    target.valueAsNumber = fixed.valueAsNumber;\n    fixed.valueAsNumber = values.get(fixed)!;\n    return changed;\n  }\n\n  // clamp such that start does not move beyond end and visa versa.\n  private clampAction() {\n    if (!this.needsClamping() || !this.action) {\n      return false;\n    }\n    const {target, fixed} = this.action;\n    target.valueAsNumber = fixed.valueAsNumber;\n    return true;\n  }\n\n  private handleInput(event: InputEvent) {\n    // avoid processing a re-dispatched event\n    if (this.isRedispatchingEvent) {\n      return;\n    }\n    let stopPropagation = false;\n    let redispatch = false;\n    if (this.range) {\n      if (this.isActionFlipped()) {\n        stopPropagation = true;\n        redispatch = this.flipAction();\n      }\n      if (this.clampAction()) {\n        stopPropagation = true;\n        redispatch = false;\n      }\n    }\n    const target = event.target as HTMLInputElement;\n    this.updateOnTop(target);\n    // update value only on interaction\n    if (this.range) {\n      this.valueStart = this.inputStart!.valueAsNumber;\n      this.valueEnd = this.inputEnd!.valueAsNumber;\n    } else {\n      this.value = this.inputEnd!.valueAsNumber;\n    }\n    // control external visibility of input event\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n    // ensure event path is correct when flipped.\n    if (redispatch) {\n      this.isRedispatchingEvent = true;\n      redispatchEvent(target, event);\n      this.isRedispatchingEvent = false;\n    }\n  }\n\n  private handleChange(event: Event) {\n    // prevent keyboard triggered changes from dispatching for\n    // clamped values; note, this only occurs for keyboard\n    const changeTarget = event.target as HTMLInputElement;\n    const {target, values} = this.action ?? {};\n    const squelch =\n      target && target.valueAsNumber === values!.get(changeTarget)!;\n    if (!squelch) {\n      redispatchEvent(this, event);\n    }\n    // ensure keyboard triggered change clears action.\n    this.finishAction(event);\n  }\n\n  // Writable mixin properties for lit-html binding, needed for lit-analyzer\n  declare disabled: boolean;\n  declare name: string;\n\n  override [getFormValue]() {\n    if (this.range) {\n      const data = new FormData();\n      data.append(this.nameStart, String(this.valueStart));\n      data.append(this.nameEnd, String(this.valueEnd));\n      return data;\n    }\n\n    return String(this.value);\n  }\n\n  override formResetCallback() {\n    if (this.range) {\n      const valueStart = this.getAttribute('value-start');\n      this.valueStart = valueStart !== null ? Number(valueStart) : undefined;\n      const valueEnd = this.getAttribute('value-end');\n      this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;\n      return;\n    }\n    const value = this.getAttribute('value');\n    this.value = value !== null ? Number(value) : undefined;\n  }\n\n  override formStateRestoreCallback(\n    state: string | Array<[string, string]> | null,\n  ) {\n    if (Array.isArray(state)) {\n      const [[, valueStart], [, valueEnd]] = state;\n      this.valueStart = Number(valueStart);\n      this.valueEnd = Number(valueEnd);\n      this.range = true;\n      return;\n    }\n\n    this.value = Number(state);\n    this.range = false;\n  }\n}\n\nfunction inBounds({x, y}: PointerEvent, element?: HTMLElement | null) {\n  if (!element) {\n    return false;\n  }\n  const {top, left, bottom, right} = element.getBoundingClientRect();\n  return x >= left && x <= right && y >= top && y <= bottom;\n}\n\nfunction isOverlapping(\n  elA: Element | null | undefined,\n  elB: Element | null | undefined,\n) {\n  if (!(elA && elB)) {\n    return false;\n  }\n  const a = elA.getBoundingClientRect();\n  const b = elB.getBoundingClientRect();\n  return !(\n    a.top > b.bottom ||\n    a.right < b.left ||\n    a.bottom < b.top ||\n    a.left > b.right\n  );\n}\n\ninterface Action {\n  canFlip: boolean;\n  flipped: boolean;\n  target: HTMLInputElement;\n  fixed: HTMLInputElement;\n  values: Map<HTMLInputElement | undefined, number | undefined>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}