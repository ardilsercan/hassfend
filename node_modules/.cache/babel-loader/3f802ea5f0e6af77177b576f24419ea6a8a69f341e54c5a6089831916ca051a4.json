{"ast":null,"code":"/* eslint-disable no-console */\n// MIT License\n\n// Copyright (c) 2015 - present Microsoft Corporation\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nimport { CharCode } from \"./char-code\";\nconst _debug = false;\nconst _maxLen = 128;\nfunction initTable() {\n  const table = [];\n  const row = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case CharCode.Underline:\n    case CharCode.Dash:\n    case CharCode.Period:\n    case CharCode.Space:\n    case CharCode.Slash:\n    case CharCode.Backslash:\n    case CharCode.SingleQuote:\n    case CharCode.DoubleQuote:\n    case CharCode.Colon:\n    case CharCode.DollarSign:\n    case CharCode.LessThan:\n    case CharCode.OpenParen:\n    case CharCode.OpenSquareBracket:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case CharCode.Space:\n    case CharCode.Tab:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\nvar Arrow = /*#__PURE__*/function (Arrow) {\n  Arrow[Arrow[\"Diag\"] = 1] = \"Diag\";\n  Arrow[Arrow[\"Left\"] = 2] = \"Left\";\n  Arrow[Arrow[\"LeftLeft\"] = 3] = \"LeftLeft\";\n  return Arrow;\n}(Arrow || {});\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\n// export type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];// [number, number, number];\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  let row;\n  let column = 1;\n  let patternPos;\n  let wordPos;\n  const hasStrongFirstMatch = [false];\n\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = Arrow.LeftLeft;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = Arrow.Left;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = Arrow.Diag;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === Arrow.LeftLeft) {\n        diagColumn -= 2;\n      } else if (arrow === Arrow.Left) {\n        diagColumn -= 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (backwardsDiagLength > 1 &&\n    // only if we would have a contiguous match of 3 characters\n    patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] &&\n    // only if we can do a contiguous match diagonally\n    !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) &&\n    // only if the forwards chose diagonal is not an uppercase\n    backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n\n  // Add 1 penalty for each skipped character in the word\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else if (newMatchStart) {\n    // this would be the beginning of a new match (i.e. there would be a gap before this location)\n    score += isGapLocation ? 2 : 0;\n  } else {\n    // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n    score += isGapLocation ? 0 : 1;\n  }\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, _pad = \" \") {\n    while (s.length < n) {\n      s = _pad + s;\n    }\n    return s;\n  }\n  let ret = ` |   |${word.split(\"\").map(c => pad(c, 3)).join(\"|\")}\\n`;\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += \" |\";\n    } else {\n      ret += `${pattern[i - 1]}|`;\n    }\n    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join(\"|\") + \"\\n\";\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nfunction initArr(maxLen) {\n  const row = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nexport function createMatches(score) {\n  if (typeof score === \"undefined\") {\n    return [];\n  }\n  const res = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\n */\nexport function isEmojiImprecise(x) {\n  return x >= 0x1f1e6 && x <= 0x1f1ff || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129003 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129750;\n}","map":{"version":3,"names":["CharCode","_debug","_maxLen","initTable","table","row","i","push","slice","isSeparatorAtPos","value","index","length","code","codePointAt","Underline","Dash","Period","Space","Slash","Backslash","SingleQuote","DoubleQuote","Colon","DollarSign","LessThan","OpenParen","OpenSquareBracket","undefined","isEmojiImprecise","isWhitespaceAtPos","charCodeAt","Tab","isUpperCaseAtPos","pos","word","wordLow","isPatternInWord","patternLow","patternPos","patternLen","wordPos","wordLen","fillMinWordPosArr","_minWordMatchPos","Arrow","fuzzyScore","pattern","patternStart","wordStart","firstMatchCanBeWeak","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","_maxWordMatchPos","nextMaxWordMatchPos","score","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","_diag","diagScore","MAX_SAFE_INTEGER","_table","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","_arrows","LeftLeft","Left","Diag","Error","printTables","result","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","printTable","pad","s","n","_pad","ret","split","map","c","join","toString","substr","console","log","initArr","maxLen","createMatches","res","last","end","start","x"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/string/filter/filter.ts"],"sourcesContent":["/* eslint-disable no-console */\n// MIT License\n\n// Copyright (c) 2015 - present Microsoft Corporation\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nimport { CharCode } from \"./char-code\";\n\nconst _debug = false;\n\nexport interface Match {\n  start: number;\n  end: number;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n  const table: number[][] = [];\n  const row: number[] = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case CharCode.Underline:\n    case CharCode.Dash:\n    case CharCode.Period:\n    case CharCode.Space:\n    case CharCode.Slash:\n    case CharCode.Backslash:\n    case CharCode.SingleQuote:\n    case CharCode.DoubleQuote:\n    case CharCode.Colon:\n    case CharCode.DollarSign:\n    case CharCode.LessThan:\n    case CharCode.OpenParen:\n    case CharCode.OpenSquareBracket:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case CharCode.Space:\n    case CharCode.Tab:\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n  return word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(\n  patternLow: string,\n  patternPos: number,\n  patternLen: number,\n  wordLow: string,\n  wordPos: number,\n  wordLen: number,\n  fillMinWordPosArr = false\n): boolean {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\n\nenum Arrow {\n  Diag = 1,\n  Left = 2,\n  LeftLeft = 3,\n}\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\n// export type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];// [number, number, number];\nexport type FuzzyScore = Array<number>;\n\nexport function fuzzyScore(\n  pattern: string,\n  patternLow: string,\n  patternStart: number,\n  word: string,\n  wordLow: string,\n  wordStart: number,\n  firstMatchCanBeWeak: boolean\n): FuzzyScore | undefined {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n  if (\n    patternStart >= patternLen ||\n    wordStart >= wordLen ||\n    patternLen - patternStart > wordLen - wordStart\n  ) {\n    return undefined;\n  }\n\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (\n    !isPatternInWord(\n      patternLow,\n      patternStart,\n      patternLen,\n      wordLow,\n      wordStart,\n      wordLen,\n      true\n    )\n  ) {\n    return undefined;\n  }\n\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(\n    patternLen,\n    wordLen,\n    patternStart,\n    wordStart,\n    patternLow,\n    wordLow\n  );\n\n  let row: number;\n  let column = 1;\n  let patternPos: number;\n  let wordPos: number;\n\n  const hasStrongFirstMatch = [false];\n\n  // There will be a match, fill in tables\n  for (\n    row = 1, patternPos = patternStart;\n    patternPos < patternLen;\n    row++, patternPos++\n  ) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos =\n      patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n\n    for (\n      column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos;\n      wordPos < nextMaxWordMatchPos;\n      column++, wordPos++\n    ) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(\n          pattern,\n          patternLow,\n          patternPos,\n          patternStart,\n          word,\n          wordLow,\n          wordPos,\n          wordLen,\n          wordStart,\n          _diag[row - 1][column - 1] === 0,\n          hasStrongFirstMatch\n        );\n      }\n\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft\n        ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0)\n        : 0; // penalty for a gap start\n\n      const canComeLeftLeft =\n        wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft\n        ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0)\n        : 0; // penalty for a gap start\n\n      if (\n        canComeLeftLeft &&\n        (!canComeLeft || leftLeftScore >= leftScore) &&\n        (!canComeDiag || leftLeftScore >= diagScore)\n      ) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = Arrow.LeftLeft;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = Arrow.Left;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = Arrow.Diag;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n\n  row--;\n  column--;\n\n  const result: FuzzyScore = [_table[row][column], wordStart];\n\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === Arrow.LeftLeft) {\n        diagColumn -= 2;\n      } else if (arrow === Arrow.Left) {\n        diagColumn -= 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (\n      backwardsDiagLength > 1 && // only if we would have a contiguous match of 3 characters\n      patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && // only if we can do a contiguous match diagonally\n      !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && // only if the forwards chose diagonal is not an uppercase\n      backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n\n  // Add 1 penalty for each skipped character in the word\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n\n  return result;\n}\n\nfunction _doScore(\n  pattern: string,\n  patternLow: string,\n  patternPos: number,\n  patternStart: number,\n  word: string,\n  wordLow: string,\n  wordPos: number,\n  wordLen: number,\n  wordStart: number,\n  newMatchStart: boolean,\n  outFirstMatchStrong: boolean[]\n): number {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (\n    isUpperCaseAtPos(wordPos, word, wordLow) &&\n    (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))\n  ) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (\n    isSeparatorAtPos(wordLow, wordPos) &&\n    (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))\n  ) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (\n    isSeparatorAtPos(wordLow, wordPos - 1) ||\n    isWhitespaceAtPos(wordLow, wordPos - 1)\n  ) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n\n  if (!isGapLocation) {\n    isGapLocation =\n      isUpperCaseAtPos(wordPos, word, wordLow) ||\n      isSeparatorAtPos(wordLow, wordPos - 1) ||\n      isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else if (newMatchStart) {\n    // this would be the beginning of a new match (i.e. there would be a gap before this location)\n    score += isGapLocation ? 2 : 0;\n  } else {\n    // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n    score += isGapLocation ? 0 : 1;\n  }\n\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n\n  return score;\n}\n\nfunction printTable(\n  table: number[][],\n  pattern: string,\n  patternLen: number,\n  word: string,\n  wordLen: number\n): string {\n  function pad(s: string, n: number, _pad = \" \") {\n    while (s.length < n) {\n      s = _pad + s;\n    }\n    return s;\n  }\n  let ret = ` |   |${word\n    .split(\"\")\n    .map((c) => pad(c, 3))\n    .join(\"|\")}\\n`;\n\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += \" |\";\n    } else {\n      ret += `${pattern[i - 1]}|`;\n    }\n    ret +=\n      table[i]\n        .slice(0, wordLen + 1)\n        .map((n) => pad(n.toString(), 3))\n        .join(\"|\") + \"\\n\";\n  }\n  return ret;\n}\n\nfunction printTables(\n  pattern: string,\n  patternStart: number,\n  word: string,\n  wordStart: number\n): void {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\n\nfunction initArr(maxLen: number) {\n  const row: number[] = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\n\nfunction _fillInMaxWordMatchPos(\n  patternLen: number,\n  wordLen: number,\n  patternStart: number,\n  wordStart: number,\n  patternLow: string,\n  wordLow: string\n) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\n\nexport interface FuzzyScorer {\n  (\n    pattern: string,\n    lowPattern: string,\n    patternPos: number,\n    word: string,\n    lowWord: string,\n    wordPos: number,\n    firstMatchCanBeWeak: boolean\n  ): FuzzyScore | undefined;\n}\n\nexport function createMatches(score: undefined | FuzzyScore): Match[] {\n  if (typeof score === \"undefined\") {\n    return [];\n  }\n  const res: Match[] = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({ start: pos, end: pos + 1 });\n    }\n  }\n  return res;\n}\n\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/master/generate-emoji-test.js\n */\nexport function isEmojiImprecise(x: number): boolean {\n  return (\n    (x >= 0x1f1e6 && x <= 0x1f1ff) ||\n    x === 8986 ||\n    x === 8987 ||\n    x === 9200 ||\n    x === 9203 ||\n    (x >= 9728 && x <= 10175) ||\n    x === 11088 ||\n    x === 11093 ||\n    (x >= 127744 && x <= 128591) ||\n    (x >= 128640 && x <= 128764) ||\n    (x >= 128992 && x <= 129003) ||\n    (x >= 129280 && x <= 129535) ||\n    (x >= 129648 && x <= 129750)\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}