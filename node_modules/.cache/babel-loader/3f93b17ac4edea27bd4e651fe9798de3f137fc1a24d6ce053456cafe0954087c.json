{"ast":null,"code":"(function (root, factory) {\n  'use strict';\n\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n  } else {\n    root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n  }\n})(this, function (SourceMap, StackFrame) {\n  'use strict';\n\n  /**\n   * Make a X-Domain request to url and callback.\n   *\n   * @param {String} url\n   * @returns {Promise} with response text if fulfilled\n   */\n  function _xdr(url) {\n    return new Promise(function (resolve, reject) {\n      var req = new XMLHttpRequest();\n      req.open('get', url);\n      req.onerror = reject;\n      req.onreadystatechange = function onreadystatechange() {\n        if (req.readyState === 4) {\n          if (req.status >= 200 && req.status < 300 || url.substr(0, 7) === 'file://' && req.responseText) {\n            resolve(req.responseText);\n          } else {\n            reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n          }\n        }\n      };\n      req.send();\n    });\n  }\n\n  /**\n   * Convert a Base64-encoded string into its original representation.\n   * Used for inline sourcemaps.\n   *\n   * @param {String} b64str Base-64 encoded string\n   * @returns {String} original representation of the base64-encoded string.\n   */\n  function _atob(b64str) {\n    if (typeof window !== 'undefined' && window.atob) {\n      return window.atob(b64str);\n    } else {\n      throw new Error('You must supply a polyfill for window.atob in this environment');\n    }\n  }\n  function _parseJson(string) {\n    if (typeof JSON !== 'undefined' && JSON.parse) {\n      return JSON.parse(string);\n    } else {\n      throw new Error('You must supply a polyfill for JSON.parse in this environment');\n    }\n  }\n  function _findFunctionName(source, lineNumber /*, columnNumber*/) {\n    var syntaxes = [\n    // {name} = function ({args}) TODO args capture\n    /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n    // function {name}({args}) m[1]=name m[2]=args\n    /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n    // {name} = eval()\n    /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n    // fn_name() {\n    /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n    // {name} = () => {\n    /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/];\n    var lines = source.split('\\n');\n\n    // Walk backwards in the source lines until we find the line which matches one of the patterns above\n    var code = '';\n    var maxLines = Math.min(lineNumber, 20);\n    for (var i = 0; i < maxLines; ++i) {\n      // lineNo is 1-based, source[] is 0-based\n      var line = lines[lineNumber - i - 1];\n      var commentPos = line.indexOf('//');\n      if (commentPos >= 0) {\n        line = line.substr(0, commentPos);\n      }\n      if (line) {\n        code = line + code;\n        var len = syntaxes.length;\n        for (var index = 0; index < len; index++) {\n          var m = syntaxes[index].exec(code);\n          if (m && m[1]) {\n            return m[1];\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n  function _ensureSupportedEnvironment() {\n    if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n      throw new Error('Unable to consume source maps in older browsers');\n    }\n  }\n  function _ensureStackFrameIsLegit(stackframe) {\n    if (typeof stackframe !== 'object') {\n      throw new TypeError('Given StackFrame is not an object');\n    } else if (typeof stackframe.fileName !== 'string') {\n      throw new TypeError('Given file name is not a String');\n    } else if (typeof stackframe.lineNumber !== 'number' || stackframe.lineNumber % 1 !== 0 || stackframe.lineNumber < 1) {\n      throw new TypeError('Given line number must be a positive integer');\n    } else if (typeof stackframe.columnNumber !== 'number' || stackframe.columnNumber % 1 !== 0 || stackframe.columnNumber < 0) {\n      throw new TypeError('Given column number must be a non-negative integer');\n    }\n    return true;\n  }\n  function _findSourceMappingURL(source) {\n    var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n    var lastSourceMappingUrl;\n    var matchSourceMappingUrl;\n    // eslint-disable-next-line no-cond-assign\n    while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n      lastSourceMappingUrl = matchSourceMappingUrl[1];\n    }\n    if (lastSourceMappingUrl) {\n      return lastSourceMappingUrl;\n    } else {\n      throw new Error('sourceMappingURL not found');\n    }\n  }\n  function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n    return new Promise(function (resolve, reject) {\n      var loc = sourceMapConsumer.originalPositionFor({\n        line: stackframe.lineNumber,\n        column: stackframe.columnNumber\n      });\n      if (loc.source) {\n        // cache mapped sources\n        var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n        if (mappedSource) {\n          sourceCache[loc.source] = mappedSource;\n        }\n        resolve(\n        // given stackframe and source location, update stackframe\n        new StackFrame({\n          functionName: loc.name || stackframe.functionName,\n          args: stackframe.args,\n          fileName: loc.source,\n          lineNumber: loc.line,\n          columnNumber: loc.column\n        }));\n      } else {\n        reject(new Error('Could not get original source for given stackframe and source map'));\n      }\n    });\n  }\n\n  /**\n   * @constructor\n   * @param {Object} opts\n   *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n   *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n   *      opts.offline = True to prevent network requests.\n   *              Best effort without sources or source maps.\n   *      opts.ajax = Promise returning function to make X-Domain requests\n   */\n  return function StackTraceGPS(opts) {\n    if (!(this instanceof StackTraceGPS)) {\n      return new StackTraceGPS(opts);\n    }\n    opts = opts || {};\n    this.sourceCache = opts.sourceCache || {};\n    this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n    this.ajax = opts.ajax || _xdr;\n    this._atob = opts.atob || _atob;\n    this._get = function _get(location) {\n      return new Promise(function (resolve, reject) {\n        var isDataUrl = location.substr(0, 5) === 'data:';\n        if (this.sourceCache[location]) {\n          resolve(this.sourceCache[location]);\n        } else if (opts.offline && !isDataUrl) {\n          reject(new Error('Cannot make network requests in offline mode'));\n        } else {\n          if (isDataUrl) {\n            // data URLs can have parameters.\n            // see http://tools.ietf.org/html/rfc2397\n            var supportedEncodingRegexp = /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n            var match = location.match(supportedEncodingRegexp);\n            if (match) {\n              var sourceMapStart = match[0].length;\n              var encodedSource = location.substr(sourceMapStart);\n              var source = this._atob(encodedSource);\n              this.sourceCache[location] = source;\n              resolve(source);\n            } else {\n              reject(new Error('The encoding of the inline sourcemap is not supported'));\n            }\n          } else {\n            var xhrPromise = this.ajax(location, {\n              method: 'get'\n            });\n            // Cache the Promise to prevent duplicate in-flight requests\n            this.sourceCache[location] = xhrPromise;\n            xhrPromise.then(resolve, reject);\n          }\n        }\n      }.bind(this));\n    };\n\n    /**\n     * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n     * SourceMapConsumer in a per-instance cache.\n     *\n     * @param {String} sourceMappingURL = URL to fetch source map from\n     * @param {String} defaultSourceRoot = Default source root for source map if undefined\n     * @returns {Promise} that resolves a SourceMapConsumer\n     */\n    this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n      return new Promise(function (resolve) {\n        if (this.sourceMapConsumerCache[sourceMappingURL]) {\n          resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n        } else {\n          var sourceMapConsumerPromise = new Promise(function (resolve, reject) {\n            return this._get(sourceMappingURL).then(function (sourceMapSource) {\n              if (typeof sourceMapSource === 'string') {\n                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n              }\n              if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                sourceMapSource.sourceRoot = defaultSourceRoot;\n              }\n              resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n            }).catch(reject);\n          }.bind(this));\n          this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n          resolve(sourceMapConsumerPromise);\n        }\n      }.bind(this));\n    };\n\n    /**\n     * Given a StackFrame, enhance function name and use source maps for a\n     * better StackFrame.\n     *\n     * @param {StackFrame} stackframe object\n     * @returns {Promise} that resolves with with source-mapped StackFrame\n     */\n    this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n      return new Promise(function (resolve, reject) {\n        this.getMappedLocation(stackframe).then(function (mappedStackFrame) {\n          function resolveMappedStackFrame() {\n            resolve(mappedStackFrame);\n          }\n          this.findFunctionName(mappedStackFrame).then(resolve, resolveMappedStackFrame)\n          // eslint-disable-next-line no-unexpected-multiline\n          ['catch'](resolveMappedStackFrame);\n        }.bind(this), reject);\n      }.bind(this));\n    };\n\n    /**\n     * Given a StackFrame, guess function name from location information.\n     *\n     * @param {StackFrame} stackframe\n     * @returns {Promise} that resolves with enhanced StackFrame.\n     */\n    this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n      return new Promise(function (resolve, reject) {\n        _ensureStackFrameIsLegit(stackframe);\n        this._get(stackframe.fileName).then(function getSourceCallback(source) {\n          var lineNumber = stackframe.lineNumber;\n          var columnNumber = stackframe.columnNumber;\n          var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n          // Only replace functionName if we found something\n          if (guessedFunctionName) {\n            resolve(new StackFrame({\n              functionName: guessedFunctionName,\n              args: stackframe.args,\n              fileName: stackframe.fileName,\n              lineNumber: lineNumber,\n              columnNumber: columnNumber\n            }));\n          } else {\n            resolve(stackframe);\n          }\n        }, reject)['catch'](reject);\n      }.bind(this));\n    };\n\n    /**\n     * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n     *\n     * @param {StackFrame} stackframe\n     * @returns {Promise} that resolves with enhanced StackFrame.\n     */\n    this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n      return new Promise(function (resolve, reject) {\n        _ensureSupportedEnvironment();\n        _ensureStackFrameIsLegit(stackframe);\n        var sourceCache = this.sourceCache;\n        var fileName = stackframe.fileName;\n        this._get(fileName).then(function (source) {\n          var sourceMappingURL = _findSourceMappingURL(source);\n          var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n          var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n          if (sourceMappingURL[0] !== '/' && !isDataUrl && !/^https?:\\/\\/|^\\/\\//i.test(sourceMappingURL)) {\n            sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n          }\n          return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot).then(function (sourceMapConsumer) {\n            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache).then(resolve)['catch'](function () {\n              resolve(stackframe);\n            });\n          });\n        }.bind(this), reject)['catch'](reject);\n      }.bind(this));\n    };\n  };\n});","map":{"version":3,"names":["root","factory","define","amd","exports","module","require","StackTraceGPS","SourceMap","sourceMap","StackFrame","_xdr","url","Promise","resolve","reject","req","XMLHttpRequest","open","onerror","onreadystatechange","readyState","status","substr","responseText","Error","send","_atob","b64str","window","atob","_parseJson","string","JSON","parse","_findFunctionName","source","lineNumber","syntaxes","lines","split","code","maxLines","Math","min","i","line","commentPos","indexOf","len","length","index","m","exec","undefined","_ensureSupportedEnvironment","Object","defineProperty","create","_ensureStackFrameIsLegit","stackframe","TypeError","fileName","columnNumber","_findSourceMappingURL","sourceMappingUrlRegExp","lastSourceMappingUrl","matchSourceMappingUrl","_extractLocationInfoFromSourceMapSource","sourceMapConsumer","sourceCache","loc","originalPositionFor","column","mappedSource","sourceContentFor","functionName","name","args","opts","sourceMapConsumerCache","ajax","_get","location","isDataUrl","offline","supportedEncodingRegexp","match","sourceMapStart","encodedSource","xhrPromise","method","then","bind","_getSourceMapConsumer","sourceMappingURL","defaultSourceRoot","sourceMapConsumerPromise","sourceMapSource","replace","sourceRoot","SourceMapConsumer","catch","pinpoint","StackTraceGPS$$pinpoint","getMappedLocation","mappedStackFrame","resolveMappedStackFrame","findFunctionName","StackTraceGPS$$findFunctionName","getSourceCallback","guessedFunctionName","StackTraceGPS$$getMappedLocation","substring","lastIndexOf","test"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/stacktrace-gps/stacktrace-gps.js"],"sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace-gps', ['source-map', 'stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('source-map/lib/source-map-consumer'), require('stackframe'));\n    } else {\n        root.StackTraceGPS = factory(root.SourceMap || root.sourceMap, root.StackFrame);\n    }\n}(this, function(SourceMap, StackFrame) {\n    'use strict';\n\n    /**\n     * Make a X-Domain request to url and callback.\n     *\n     * @param {String} url\n     * @returns {Promise} with response text if fulfilled\n     */\n    function _xdr(url) {\n        return new Promise(function(resolve, reject) {\n            var req = new XMLHttpRequest();\n            req.open('get', url);\n            req.onerror = reject;\n            req.onreadystatechange = function onreadystatechange() {\n                if (req.readyState === 4) {\n                    if ((req.status >= 200 && req.status < 300) ||\n                        (url.substr(0, 7) === 'file://' && req.responseText)) {\n                        resolve(req.responseText);\n                    } else {\n                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));\n                    }\n                }\n            };\n            req.send();\n        });\n\n    }\n\n    /**\n     * Convert a Base64-encoded string into its original representation.\n     * Used for inline sourcemaps.\n     *\n     * @param {String} b64str Base-64 encoded string\n     * @returns {String} original representation of the base64-encoded string.\n     */\n    function _atob(b64str) {\n        if (typeof window !== 'undefined' && window.atob) {\n            return window.atob(b64str);\n        } else {\n            throw new Error('You must supply a polyfill for window.atob in this environment');\n        }\n    }\n\n    function _parseJson(string) {\n        if (typeof JSON !== 'undefined' && JSON.parse) {\n            return JSON.parse(string);\n        } else {\n            throw new Error('You must supply a polyfill for JSON.parse in this environment');\n        }\n    }\n\n    function _findFunctionName(source, lineNumber/*, columnNumber*/) {\n        var syntaxes = [\n            // {name} = function ({args}) TODO args capture\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/,\n            // function {name}({args}) m[1]=name m[2]=args\n            /function\\s+([^('\"`]*?)\\s*\\(([^)]*)\\)/,\n            // {name} = eval()\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/,\n            // fn_name() {\n            /\\b(?!(?:if|for|switch|while|with|catch)\\b)(?:(?:static)\\s+)?(\\S+)\\s*\\(.*?\\)\\s*\\{/,\n            // {name} = () => {\n            /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*\\(.*?\\)\\s*=>/\n        ];\n        var lines = source.split('\\n');\n\n        // Walk backwards in the source lines until we find the line which matches one of the patterns above\n        var code = '';\n        var maxLines = Math.min(lineNumber, 20);\n        for (var i = 0; i < maxLines; ++i) {\n            // lineNo is 1-based, source[] is 0-based\n            var line = lines[lineNumber - i - 1];\n            var commentPos = line.indexOf('//');\n            if (commentPos >= 0) {\n                line = line.substr(0, commentPos);\n            }\n\n            if (line) {\n                code = line + code;\n                var len = syntaxes.length;\n                for (var index = 0; index < len; index++) {\n                    var m = syntaxes[index].exec(code);\n                    if (m && m[1]) {\n                        return m[1];\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    function _ensureSupportedEnvironment() {\n        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {\n            throw new Error('Unable to consume source maps in older browsers');\n        }\n    }\n\n    function _ensureStackFrameIsLegit(stackframe) {\n        if (typeof stackframe !== 'object') {\n            throw new TypeError('Given StackFrame is not an object');\n        } else if (typeof stackframe.fileName !== 'string') {\n            throw new TypeError('Given file name is not a String');\n        } else if (typeof stackframe.lineNumber !== 'number' ||\n            stackframe.lineNumber % 1 !== 0 ||\n            stackframe.lineNumber < 1) {\n            throw new TypeError('Given line number must be a positive integer');\n        } else if (typeof stackframe.columnNumber !== 'number' ||\n            stackframe.columnNumber % 1 !== 0 ||\n            stackframe.columnNumber < 0) {\n            throw new TypeError('Given column number must be a non-negative integer');\n        }\n        return true;\n    }\n\n    function _findSourceMappingURL(source) {\n        var sourceMappingUrlRegExp = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/mg;\n        var lastSourceMappingUrl;\n        var matchSourceMappingUrl;\n        // eslint-disable-next-line no-cond-assign\n        while (matchSourceMappingUrl = sourceMappingUrlRegExp.exec(source)) {\n            lastSourceMappingUrl = matchSourceMappingUrl[1];\n        }\n        if (lastSourceMappingUrl) {\n            return lastSourceMappingUrl;\n        } else {\n            throw new Error('sourceMappingURL not found');\n        }\n    }\n\n    function _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache) {\n        return new Promise(function(resolve, reject) {\n            var loc = sourceMapConsumer.originalPositionFor({\n                line: stackframe.lineNumber,\n                column: stackframe.columnNumber\n            });\n\n            if (loc.source) {\n                // cache mapped sources\n                var mappedSource = sourceMapConsumer.sourceContentFor(loc.source);\n                if (mappedSource) {\n                    sourceCache[loc.source] = mappedSource;\n                }\n\n                resolve(\n                    // given stackframe and source location, update stackframe\n                    new StackFrame({\n                        functionName: loc.name || stackframe.functionName,\n                        args: stackframe.args,\n                        fileName: loc.source,\n                        lineNumber: loc.line,\n                        columnNumber: loc.column\n                    }));\n            } else {\n                reject(new Error('Could not get original source for given stackframe and source map'));\n            }\n        });\n    }\n\n    /**\n     * @constructor\n     * @param {Object} opts\n     *      opts.sourceCache = {url: \"Source String\"} => preload source cache\n     *      opts.sourceMapConsumerCache = {/path/file.js.map: SourceMapConsumer}\n     *      opts.offline = True to prevent network requests.\n     *              Best effort without sources or source maps.\n     *      opts.ajax = Promise returning function to make X-Domain requests\n     */\n    return function StackTraceGPS(opts) {\n        if (!(this instanceof StackTraceGPS)) {\n            return new StackTraceGPS(opts);\n        }\n        opts = opts || {};\n\n        this.sourceCache = opts.sourceCache || {};\n        this.sourceMapConsumerCache = opts.sourceMapConsumerCache || {};\n\n        this.ajax = opts.ajax || _xdr;\n\n        this._atob = opts.atob || _atob;\n\n        this._get = function _get(location) {\n            return new Promise(function(resolve, reject) {\n                var isDataUrl = location.substr(0, 5) === 'data:';\n                if (this.sourceCache[location]) {\n                    resolve(this.sourceCache[location]);\n                } else if (opts.offline && !isDataUrl) {\n                    reject(new Error('Cannot make network requests in offline mode'));\n                } else {\n                    if (isDataUrl) {\n                        // data URLs can have parameters.\n                        // see http://tools.ietf.org/html/rfc2397\n                        var supportedEncodingRegexp =\n                            /^data:application\\/json;([\\w=:\"-]+;)*base64,/;\n                        var match = location.match(supportedEncodingRegexp);\n                        if (match) {\n                            var sourceMapStart = match[0].length;\n                            var encodedSource = location.substr(sourceMapStart);\n                            var source = this._atob(encodedSource);\n                            this.sourceCache[location] = source;\n                            resolve(source);\n                        } else {\n                            reject(new Error('The encoding of the inline sourcemap is not supported'));\n                        }\n                    } else {\n                        var xhrPromise = this.ajax(location, {method: 'get'});\n                        // Cache the Promise to prevent duplicate in-flight requests\n                        this.sourceCache[location] = xhrPromise;\n                        xhrPromise.then(resolve, reject);\n                    }\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Creating SourceMapConsumers is expensive, so this wraps the creation of a\n         * SourceMapConsumer in a per-instance cache.\n         *\n         * @param {String} sourceMappingURL = URL to fetch source map from\n         * @param {String} defaultSourceRoot = Default source root for source map if undefined\n         * @returns {Promise} that resolves a SourceMapConsumer\n         */\n        this._getSourceMapConsumer = function _getSourceMapConsumer(sourceMappingURL, defaultSourceRoot) {\n            return new Promise(function(resolve) {\n                if (this.sourceMapConsumerCache[sourceMappingURL]) {\n                    resolve(this.sourceMapConsumerCache[sourceMappingURL]);\n                } else {\n                    var sourceMapConsumerPromise = new Promise(function(resolve, reject) {\n                        return this._get(sourceMappingURL).then(function(sourceMapSource) {\n                            if (typeof sourceMapSource === 'string') {\n                                sourceMapSource = _parseJson(sourceMapSource.replace(/^\\)\\]\\}'/, ''));\n                            }\n                            if (typeof sourceMapSource.sourceRoot === 'undefined') {\n                                sourceMapSource.sourceRoot = defaultSourceRoot;\n                            }\n\n                            resolve(new SourceMap.SourceMapConsumer(sourceMapSource));\n                        }).catch(reject);\n                    }.bind(this));\n                    this.sourceMapConsumerCache[sourceMappingURL] = sourceMapConsumerPromise;\n                    resolve(sourceMapConsumerPromise);\n                }\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, enhance function name and use source maps for a\n         * better StackFrame.\n         *\n         * @param {StackFrame} stackframe object\n         * @returns {Promise} that resolves with with source-mapped StackFrame\n         */\n        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {\n            return new Promise(function(resolve, reject) {\n                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {\n                    function resolveMappedStackFrame() {\n                        resolve(mappedStackFrame);\n                    }\n\n                    this.findFunctionName(mappedStackFrame)\n                        .then(resolve, resolveMappedStackFrame)\n                        // eslint-disable-next-line no-unexpected-multiline\n                        ['catch'](resolveMappedStackFrame);\n                }.bind(this), reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, guess function name from location information.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureStackFrameIsLegit(stackframe);\n                this._get(stackframe.fileName).then(function getSourceCallback(source) {\n                    var lineNumber = stackframe.lineNumber;\n                    var columnNumber = stackframe.columnNumber;\n                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);\n                    // Only replace functionName if we found something\n                    if (guessedFunctionName) {\n                        resolve(new StackFrame({\n                            functionName: guessedFunctionName,\n                            args: stackframe.args,\n                            fileName: stackframe.fileName,\n                            lineNumber: lineNumber,\n                            columnNumber: columnNumber\n                        }));\n                    } else {\n                        resolve(stackframe);\n                    }\n                }, reject)['catch'](reject);\n            }.bind(this));\n        };\n\n        /**\n         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.\n         *\n         * @param {StackFrame} stackframe\n         * @returns {Promise} that resolves with enhanced StackFrame.\n         */\n        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {\n            return new Promise(function(resolve, reject) {\n                _ensureSupportedEnvironment();\n                _ensureStackFrameIsLegit(stackframe);\n\n                var sourceCache = this.sourceCache;\n                var fileName = stackframe.fileName;\n                this._get(fileName).then(function(source) {\n                    var sourceMappingURL = _findSourceMappingURL(source);\n                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';\n                    var defaultSourceRoot = fileName.substring(0, fileName.lastIndexOf('/') + 1);\n\n                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\\/\\/|^\\/\\//i).test(sourceMappingURL)) {\n                        sourceMappingURL = defaultSourceRoot + sourceMappingURL;\n                    }\n\n                    return this._getSourceMapConsumer(sourceMappingURL, defaultSourceRoot)\n                        .then(function(sourceMapConsumer) {\n                            return _extractLocationInfoFromSourceMapSource(stackframe, sourceMapConsumer, sourceCache)\n                                .then(resolve)['catch'](function() {\n                                    resolve(stackframe);\n                                });\n                        });\n                }.bind(this), reject)['catch'](reject);\n            }.bind(this));\n        };\n    };\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}