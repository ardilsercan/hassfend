{"ast":null,"code":"import { addDays, addHours, addMilliseconds, addMonths, differenceInDays, differenceInMonths, endOfDay, startOfDay, isFirstDayOfMonth, isLastDayOfMonth } from \"date-fns/esm\";\nimport { getCollection } from \"home-assistant-js-websocket\";\nimport { calcDate, calcDateProperty } from \"../common/datetime/calc_date\";\nimport { formatTime24h } from \"../common/datetime/format_time\";\nimport { groupBy } from \"../common/util/group-by\";\nimport { getConfigEntries } from \"./config_entries\";\nimport { fetchStatistics, getStatisticMetadata } from \"./recorder\";\nconst energyCollectionKeys = [];\nexport const emptyFlowFromGridSourceEnergyPreference = () => ({\n  stat_energy_from: \"\",\n  stat_cost: null,\n  entity_energy_price: null,\n  number_energy_price: null\n});\nexport const emptyFlowToGridSourceEnergyPreference = () => ({\n  stat_energy_to: \"\",\n  stat_compensation: null,\n  entity_energy_price: null,\n  number_energy_price: null\n});\nexport const emptyGridSourceEnergyPreference = () => ({\n  type: \"grid\",\n  flow_from: [],\n  flow_to: [],\n  cost_adjustment_day: 0\n});\nexport const emptySolarEnergyPreference = () => ({\n  type: \"solar\",\n  stat_energy_from: \"\",\n  config_entry_solar_forecast: null\n});\nexport const emptyBatteryEnergyPreference = () => ({\n  type: \"battery\",\n  stat_energy_from: \"\",\n  stat_energy_to: \"\"\n});\nexport const emptyGasEnergyPreference = () => ({\n  type: \"gas\",\n  stat_energy_from: \"\",\n  stat_cost: null,\n  entity_energy_price: null,\n  number_energy_price: null\n});\nexport const emptyWaterEnergyPreference = () => ({\n  type: \"water\",\n  stat_energy_from: \"\",\n  stat_cost: null,\n  entity_energy_price: null,\n  number_energy_price: null\n});\nexport const getEnergyInfo = hass => hass.callWS({\n  type: \"energy/info\"\n});\nexport const getEnergyPreferenceValidation = async hass => {\n  await hass.loadBackendTranslation(\"issues\", \"energy\");\n  return hass.callWS({\n    type: \"energy/validate\"\n  });\n};\nexport const getEnergyPreferences = hass => hass.callWS({\n  type: \"energy/get_prefs\"\n});\nexport const saveEnergyPreferences = async (hass, prefs) => {\n  const newPrefs = hass.callWS({\n    type: \"energy/save_prefs\",\n    ...prefs\n  });\n  clearEnergyCollectionPreferences(hass);\n  return newPrefs;\n};\nexport const getFossilEnergyConsumption = async (hass, startTime, energy_statistic_ids, co2_statistic_id, endTime, period = \"hour\") => hass.callWS({\n  type: \"energy/fossil_energy_consumption\",\n  start_time: startTime.toISOString(),\n  end_time: endTime === null || endTime === void 0 ? void 0 : endTime.toISOString(),\n  energy_statistic_ids,\n  co2_statistic_id,\n  period\n});\nexport const energySourcesByType = prefs => groupBy(prefs.energy_sources, item => item.type);\nexport const getReferencedStatisticIds = (prefs, info, includeTypes) => {\n  const statIDs = [];\n  for (const source of prefs.energy_sources) {\n    if (includeTypes && !includeTypes.includes(source.type)) {\n      continue;\n    }\n    if (source.type === \"solar\") {\n      statIDs.push(source.stat_energy_from);\n      continue;\n    }\n    if (source.type === \"gas\" || source.type === \"water\") {\n      statIDs.push(source.stat_energy_from);\n      if (source.stat_cost) {\n        statIDs.push(source.stat_cost);\n      }\n      const costStatId = info.cost_sensors[source.stat_energy_from];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n      continue;\n    }\n    if (source.type === \"battery\") {\n      statIDs.push(source.stat_energy_from);\n      statIDs.push(source.stat_energy_to);\n      continue;\n    }\n\n    // grid source\n    for (const flowFrom of source.flow_from) {\n      statIDs.push(flowFrom.stat_energy_from);\n      if (flowFrom.stat_cost) {\n        statIDs.push(flowFrom.stat_cost);\n      }\n      const costStatId = info.cost_sensors[flowFrom.stat_energy_from];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n    }\n    for (const flowTo of source.flow_to) {\n      statIDs.push(flowTo.stat_energy_to);\n      if (flowTo.stat_compensation) {\n        statIDs.push(flowTo.stat_compensation);\n      }\n      const costStatId = info.cost_sensors[flowTo.stat_energy_to];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n    }\n  }\n  return statIDs;\n};\nconst getEnergyData = async (hass, prefs, start, end, compare) => {\n  const [configEntries, info] = await Promise.all([getConfigEntries(hass, {\n    domain: \"co2signal\"\n  }), getEnergyInfo(hass)]);\n  const co2SignalConfigEntry = configEntries.length ? configEntries[0] : undefined;\n  let co2SignalEntity;\n  if (co2SignalConfigEntry) {\n    for (const entity of Object.values(hass.entities)) {\n      if (entity.platform !== \"co2signal\") {\n        continue;\n      }\n\n      // The integration offers 2 entities. We want the % one.\n      const co2State = hass.states[entity.entity_id];\n      if (!co2State || co2State.attributes.unit_of_measurement !== \"%\") {\n        continue;\n      }\n      co2SignalEntity = co2State.entity_id;\n      break;\n    }\n  }\n  const consumptionStatIDs = [];\n  for (const source of prefs.energy_sources) {\n    // grid source\n    if (source.type === \"grid\") {\n      for (const flowFrom of source.flow_from) {\n        consumptionStatIDs.push(flowFrom.stat_energy_from);\n      }\n    }\n  }\n  const energyStatIds = getReferencedStatisticIds(prefs, info, [\"grid\", \"solar\", \"battery\", \"gas\"]);\n  const waterStatIds = getReferencedStatisticIds(prefs, info, [\"water\"]);\n  const allStatIDs = [...energyStatIds, ...waterStatIds];\n  const dayDifference = differenceInDays(end || new Date(), start);\n  const period = dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\";\n  const lengthUnit = hass.config.unit_system.length || \"\";\n  const energyUnits = {\n    energy: \"kWh\",\n    volume: lengthUnit === \"km\" ? \"m³\" : \"ft³\"\n  };\n  const waterUnits = {\n    volume: lengthUnit === \"km\" ? \"L\" : \"gal\"\n  };\n  const _energyStats = energyStatIds.length ? fetchStatistics(hass, start, end, energyStatIds, period, energyUnits, [\"change\"]) : {};\n  const _waterStats = waterStatIds.length ? fetchStatistics(hass, start, end, waterStatIds, period, waterUnits, [\"change\"]) : {};\n  let statsCompare;\n  let startCompare;\n  let endCompare;\n  let _energyStatsCompare = {};\n  let _waterStatsCompare = {};\n  if (compare) {\n    if (calcDateProperty(start, isFirstDayOfMonth, hass.locale, hass.config) && calcDateProperty(end || new Date(), isLastDayOfMonth, hass.locale, hass.config)) {\n      // When comparing a month (or multiple), we want to start at the begining of the month\n      startCompare = calcDate(start, addMonths, hass.locale, hass.config, -calcDateProperty(end || new Date(), differenceInMonths, hass.locale, hass.config, start) - 1);\n    } else {\n      startCompare = calcDate(start, addDays, hass.locale, hass.config, (dayDifference + 1) * -1);\n    }\n    endCompare = addMilliseconds(start, -1);\n    if (energyStatIds.length) {\n      _energyStatsCompare = fetchStatistics(hass, startCompare, endCompare, energyStatIds, period, energyUnits, [\"change\"]);\n    }\n    if (waterStatIds.length) {\n      _waterStatsCompare = fetchStatistics(hass, startCompare, endCompare, waterStatIds, period, waterUnits, [\"change\"]);\n    }\n  }\n  let _fossilEnergyConsumption;\n  let _fossilEnergyConsumptionCompare;\n  if (co2SignalEntity !== undefined) {\n    _fossilEnergyConsumption = getFossilEnergyConsumption(hass, start, consumptionStatIDs, co2SignalEntity, end, dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\");\n    if (compare) {\n      _fossilEnergyConsumptionCompare = getFossilEnergyConsumption(hass, startCompare, consumptionStatIDs, co2SignalEntity, endCompare, dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\");\n    }\n  }\n  const statsMetadata = {};\n  const _getStatisticMetadata = allStatIDs.length ? getStatisticMetadata(hass, allStatIDs) : [];\n  const [energyStats, waterStats, energyStatsCompare, waterStatsCompare, statsMetadataArray, fossilEnergyConsumption, fossilEnergyConsumptionCompare] = await Promise.all([_energyStats, _waterStats, _energyStatsCompare, _waterStatsCompare, _getStatisticMetadata, _fossilEnergyConsumption, _fossilEnergyConsumptionCompare]);\n  const stats = {\n    ...energyStats,\n    ...waterStats\n  };\n  if (compare) {\n    statsCompare = {\n      ...energyStatsCompare,\n      ...waterStatsCompare\n    };\n  }\n  if (allStatIDs.length) {\n    statsMetadataArray.forEach(x => {\n      statsMetadata[x.statistic_id] = x;\n    });\n  }\n  const data = {\n    start,\n    end,\n    startCompare,\n    endCompare,\n    info,\n    prefs,\n    stats,\n    statsMetadata,\n    statsCompare,\n    co2SignalConfigEntry,\n    co2SignalEntity,\n    fossilEnergyConsumption,\n    fossilEnergyConsumptionCompare\n  };\n  return data;\n};\nconst clearEnergyCollectionPreferences = hass => {\n  energyCollectionKeys.forEach(key => {\n    const energyCollection = getEnergyDataCollection(hass, {\n      key\n    });\n    energyCollection.clearPrefs();\n    if (energyCollection._active) {\n      energyCollection.refresh();\n    }\n  });\n};\nconst scheduleHourlyRefresh = collection => {\n  if (collection._refreshTimeout) {\n    clearTimeout(collection._refreshTimeout);\n  }\n  if (collection._active && (!collection.end || collection.end > new Date())) {\n    // The stats are created every hour\n    // Schedule a refresh for 20 minutes past the hour\n    // If the end is larger than the current time.\n    const nextFetch = new Date();\n    if (nextFetch.getMinutes() >= 20) {\n      nextFetch.setHours(nextFetch.getHours() + 1);\n    }\n    nextFetch.setMinutes(20, 0, 0);\n    collection._refreshTimeout = window.setTimeout(() => collection.refresh(), nextFetch.getTime() - Date.now());\n  }\n};\nexport const getEnergyDataCollection = (hass, options = {}) => {\n  let key = \"_energy\";\n  if (options.key) {\n    if (!options.key.startsWith(\"energy_\")) {\n      throw new Error(\"Key need to start with energy_\");\n    }\n    key = `_${options.key}`;\n  }\n  if (hass.connection[key]) {\n    return hass.connection[key];\n  }\n  energyCollectionKeys.push(options.key);\n  const collection = getCollection(hass.connection, key, async () => {\n    if (!collection.prefs) {\n      // This will raise if not found.\n      // Detect by checking `e.code === \"not_found\"\n      collection.prefs = await getEnergyPreferences(hass);\n    }\n    scheduleHourlyRefresh(collection);\n    return getEnergyData(hass, collection.prefs, collection.start, collection.end, collection.compare);\n  });\n  const origSubscribe = collection.subscribe;\n  collection.subscribe = subscriber => {\n    const unsub = origSubscribe(subscriber);\n    collection._active++;\n    if (collection._refreshTimeout === undefined) {\n      scheduleHourlyRefresh(collection);\n    }\n    return () => {\n      collection._active--;\n      if (collection._active < 1) {\n        clearTimeout(collection._refreshTimeout);\n        collection._refreshTimeout = undefined;\n      }\n      unsub();\n    };\n  };\n  collection._active = 0;\n  collection.prefs = options.prefs;\n  const now = new Date();\n  const hour = formatTime24h(now, hass.locale, hass.config).split(\":\")[0];\n  // Set start to start of today if we have data for today, otherwise yesterday\n  collection.start = calcDate(hour === \"0\" ? addDays(now, -1) : now, startOfDay, hass.locale, hass.config);\n  collection.end = calcDate(hour === \"0\" ? addDays(now, -1) : now, endOfDay, hass.locale, hass.config);\n  const scheduleUpdatePeriod = () => {\n    collection._updatePeriodTimeout = window.setTimeout(() => {\n      collection.start = calcDate(new Date(), startOfDay, hass.locale, hass.config);\n      collection.end = calcDate(new Date(), endOfDay, hass.locale, hass.config);\n      scheduleUpdatePeriod();\n    }, addHours(calcDate(now, endOfDay, hass.locale, hass.config), 1).getTime() - Date.now() // Switch to next day an hour after the day changed\n    );\n  };\n  scheduleUpdatePeriod();\n  collection.clearPrefs = () => {\n    collection.prefs = undefined;\n  };\n  collection.setPeriod = (newStart, newEnd) => {\n    var _collection$end;\n    collection.start = newStart;\n    collection.end = newEnd;\n    if (collection.start.getTime() === calcDate(new Date(), startOfDay, hass.locale, hass.config).getTime() && ((_collection$end = collection.end) === null || _collection$end === void 0 ? void 0 : _collection$end.getTime()) === calcDate(new Date(), endOfDay, hass.locale, hass.config).getTime() && !collection._updatePeriodTimeout) {\n      scheduleUpdatePeriod();\n    } else if (collection._updatePeriodTimeout) {\n      clearTimeout(collection._updatePeriodTimeout);\n      collection._updatePeriodTimeout = undefined;\n    }\n  };\n  collection.setCompare = compare => {\n    collection.compare = compare;\n  };\n  return collection;\n};\nexport const getEnergySolarForecasts = hass => hass.callWS({\n  type: \"energy/solar_forecast\"\n});\nconst energyGasUnitClass = [\"volume\", \"energy\"];\nexport const getEnergyGasUnitClass = (prefs, statisticsMetaData = {}, excludeSource) => {\n  for (const source of prefs.energy_sources) {\n    if (source.type !== \"gas\") {\n      continue;\n    }\n    if (excludeSource && excludeSource === source.stat_energy_from) {\n      continue;\n    }\n    const statisticIdWithMeta = statisticsMetaData[source.stat_energy_from];\n    if (energyGasUnitClass.includes(statisticIdWithMeta === null || statisticIdWithMeta === void 0 ? void 0 : statisticIdWithMeta.unit_class)) {\n      return statisticIdWithMeta.unit_class;\n    }\n  }\n  return undefined;\n};\nexport const getEnergyGasUnit = (hass, prefs, statisticsMetaData = {}) => {\n  const unitClass = getEnergyGasUnitClass(prefs, statisticsMetaData);\n  if (unitClass === undefined) {\n    return undefined;\n  }\n  return unitClass === \"energy\" ? \"kWh\" : hass.config.unit_system.length === \"km\" ? \"m³\" : \"ft³\";\n};\nexport const getEnergyWaterUnit = hass => hass.config.unit_system.length === \"km\" ? \"L\" : \"gal\";\nexport const energyStatisticHelpUrl = \"/docs/energy/faq/#troubleshooting-missing-entities\";","map":{"version":3,"names":["addDays","addHours","addMilliseconds","addMonths","differenceInDays","differenceInMonths","endOfDay","startOfDay","isFirstDayOfMonth","isLastDayOfMonth","getCollection","calcDate","calcDateProperty","formatTime24h","groupBy","getConfigEntries","fetchStatistics","getStatisticMetadata","energyCollectionKeys","emptyFlowFromGridSourceEnergyPreference","stat_energy_from","stat_cost","entity_energy_price","number_energy_price","emptyFlowToGridSourceEnergyPreference","stat_energy_to","stat_compensation","emptyGridSourceEnergyPreference","type","flow_from","flow_to","cost_adjustment_day","emptySolarEnergyPreference","config_entry_solar_forecast","emptyBatteryEnergyPreference","emptyGasEnergyPreference","emptyWaterEnergyPreference","getEnergyInfo","hass","callWS","getEnergyPreferenceValidation","loadBackendTranslation","getEnergyPreferences","saveEnergyPreferences","prefs","newPrefs","clearEnergyCollectionPreferences","getFossilEnergyConsumption","startTime","energy_statistic_ids","co2_statistic_id","endTime","period","start_time","toISOString","end_time","energySourcesByType","energy_sources","item","getReferencedStatisticIds","info","includeTypes","statIDs","source","includes","push","costStatId","cost_sensors","flowFrom","flowTo","getEnergyData","start","end","compare","configEntries","Promise","all","domain","co2SignalConfigEntry","length","undefined","co2SignalEntity","entity","Object","values","entities","platform","co2State","states","entity_id","attributes","unit_of_measurement","consumptionStatIDs","energyStatIds","waterStatIds","allStatIDs","dayDifference","Date","lengthUnit","config","unit_system","energyUnits","energy","volume","waterUnits","_energyStats","_waterStats","statsCompare","startCompare","endCompare","_energyStatsCompare","_waterStatsCompare","locale","_fossilEnergyConsumption","_fossilEnergyConsumptionCompare","statsMetadata","_getStatisticMetadata","energyStats","waterStats","energyStatsCompare","waterStatsCompare","statsMetadataArray","fossilEnergyConsumption","fossilEnergyConsumptionCompare","stats","forEach","x","statistic_id","data","key","energyCollection","getEnergyDataCollection","clearPrefs","_active","refresh","scheduleHourlyRefresh","collection","_refreshTimeout","clearTimeout","nextFetch","getMinutes","setHours","getHours","setMinutes","window","setTimeout","getTime","now","options","startsWith","Error","connection","origSubscribe","subscribe","subscriber","unsub","hour","split","scheduleUpdatePeriod","_updatePeriodTimeout","setPeriod","newStart","newEnd","_collection$end","setCompare","getEnergySolarForecasts","energyGasUnitClass","getEnergyGasUnitClass","statisticsMetaData","excludeSource","statisticIdWithMeta","unit_class","getEnergyGasUnit","unitClass","getEnergyWaterUnit","energyStatisticHelpUrl"],"sources":["/Users/sercanardil/Desktop/frontend/src/data/energy.ts"],"sourcesContent":["import {\n  addDays,\n  addHours,\n  addMilliseconds,\n  addMonths,\n  differenceInDays,\n  differenceInMonths,\n  endOfDay,\n  startOfDay,\n  isFirstDayOfMonth,\n  isLastDayOfMonth,\n} from \"date-fns/esm\";\nimport { Collection, getCollection } from \"home-assistant-js-websocket\";\nimport { calcDate, calcDateProperty } from \"../common/datetime/calc_date\";\nimport { formatTime24h } from \"../common/datetime/format_time\";\nimport { groupBy } from \"../common/util/group-by\";\nimport { HomeAssistant } from \"../types\";\nimport { ConfigEntry, getConfigEntries } from \"./config_entries\";\nimport {\n  fetchStatistics,\n  getStatisticMetadata,\n  Statistics,\n  StatisticsMetaData,\n  StatisticsUnitConfiguration,\n} from \"./recorder\";\n\nconst energyCollectionKeys: (string | undefined)[] = [];\n\nexport const emptyFlowFromGridSourceEnergyPreference =\n  (): FlowFromGridSourceEnergyPreference => ({\n    stat_energy_from: \"\",\n    stat_cost: null,\n    entity_energy_price: null,\n    number_energy_price: null,\n  });\n\nexport const emptyFlowToGridSourceEnergyPreference =\n  (): FlowToGridSourceEnergyPreference => ({\n    stat_energy_to: \"\",\n    stat_compensation: null,\n    entity_energy_price: null,\n    number_energy_price: null,\n  });\n\nexport const emptyGridSourceEnergyPreference =\n  (): GridSourceTypeEnergyPreference => ({\n    type: \"grid\",\n    flow_from: [],\n    flow_to: [],\n    cost_adjustment_day: 0,\n  });\n\nexport const emptySolarEnergyPreference =\n  (): SolarSourceTypeEnergyPreference => ({\n    type: \"solar\",\n    stat_energy_from: \"\",\n    config_entry_solar_forecast: null,\n  });\n\nexport const emptyBatteryEnergyPreference =\n  (): BatterySourceTypeEnergyPreference => ({\n    type: \"battery\",\n    stat_energy_from: \"\",\n    stat_energy_to: \"\",\n  });\n\nexport const emptyGasEnergyPreference = (): GasSourceTypeEnergyPreference => ({\n  type: \"gas\",\n  stat_energy_from: \"\",\n  stat_cost: null,\n  entity_energy_price: null,\n  number_energy_price: null,\n});\n\nexport const emptyWaterEnergyPreference =\n  (): WaterSourceTypeEnergyPreference => ({\n    type: \"water\",\n    stat_energy_from: \"\",\n    stat_cost: null,\n    entity_energy_price: null,\n    number_energy_price: null,\n  });\n\ninterface EnergySolarForecast {\n  wh_hours: Record<string, number>;\n}\nexport type EnergySolarForecasts = {\n  [config_entry_id: string]: EnergySolarForecast;\n};\n\nexport interface DeviceConsumptionEnergyPreference {\n  // This is an ever increasing value\n  stat_consumption: string;\n}\n\nexport interface FlowFromGridSourceEnergyPreference {\n  // kWh meter\n  stat_energy_from: string;\n\n  // $ meter\n  stat_cost: string | null;\n\n  // Can be used to generate costs if stat_cost omitted\n  entity_energy_price: string | null;\n  number_energy_price: number | null;\n}\n\nexport interface FlowToGridSourceEnergyPreference {\n  // kWh meter\n  stat_energy_to: string;\n\n  // $ meter\n  stat_compensation: string | null;\n\n  // Can be used to generate costs if stat_compensation omitted\n  entity_energy_price: string | null;\n  number_energy_price: number | null;\n}\n\nexport interface GridSourceTypeEnergyPreference {\n  type: \"grid\";\n\n  flow_from: FlowFromGridSourceEnergyPreference[];\n  flow_to: FlowToGridSourceEnergyPreference[];\n\n  cost_adjustment_day: number;\n}\n\nexport interface SolarSourceTypeEnergyPreference {\n  type: \"solar\";\n\n  stat_energy_from: string;\n  config_entry_solar_forecast: string[] | null;\n}\n\nexport interface BatterySourceTypeEnergyPreference {\n  type: \"battery\";\n  stat_energy_from: string;\n  stat_energy_to: string;\n}\nexport interface GasSourceTypeEnergyPreference {\n  type: \"gas\";\n\n  // kWh/volume meter\n  stat_energy_from: string;\n\n  // $ meter\n  stat_cost: string | null;\n\n  // Can be used to generate costs if stat_cost omitted\n  entity_energy_price: string | null;\n  number_energy_price: number | null;\n  unit_of_measurement?: string | null;\n}\n\nexport interface WaterSourceTypeEnergyPreference {\n  type: \"water\";\n\n  // volume meter\n  stat_energy_from: string;\n\n  // $ meter\n  stat_cost: string | null;\n\n  // Can be used to generate costs if stat_cost omitted\n  entity_energy_price: string | null;\n  number_energy_price: number | null;\n  unit_of_measurement?: string | null;\n}\n\ntype EnergySource =\n  | SolarSourceTypeEnergyPreference\n  | GridSourceTypeEnergyPreference\n  | BatterySourceTypeEnergyPreference\n  | GasSourceTypeEnergyPreference\n  | WaterSourceTypeEnergyPreference;\n\nexport interface EnergyPreferences {\n  energy_sources: EnergySource[];\n  device_consumption: DeviceConsumptionEnergyPreference[];\n}\n\nexport interface EnergyInfo {\n  cost_sensors: Record<string, string>;\n  solar_forecast_domains: string[];\n}\n\nexport interface EnergyValidationIssue {\n  type: string;\n  affected_entities: [string, unknown][];\n  translation_placeholders: Record<string, string>;\n}\n\nexport interface EnergyPreferencesValidation {\n  energy_sources: EnergyValidationIssue[][];\n  device_consumption: EnergyValidationIssue[][];\n}\n\nexport const getEnergyInfo = (hass: HomeAssistant) =>\n  hass.callWS<EnergyInfo>({\n    type: \"energy/info\",\n  });\n\nexport const getEnergyPreferenceValidation = async (hass: HomeAssistant) => {\n  await hass.loadBackendTranslation(\"issues\", \"energy\");\n  return hass.callWS<EnergyPreferencesValidation>({\n    type: \"energy/validate\",\n  });\n};\n\nexport const getEnergyPreferences = (hass: HomeAssistant) =>\n  hass.callWS<EnergyPreferences>({\n    type: \"energy/get_prefs\",\n  });\n\nexport const saveEnergyPreferences = async (\n  hass: HomeAssistant,\n  prefs: Partial<EnergyPreferences>\n) => {\n  const newPrefs = hass.callWS<EnergyPreferences>({\n    type: \"energy/save_prefs\",\n    ...prefs,\n  });\n  clearEnergyCollectionPreferences(hass);\n  return newPrefs;\n};\n\nexport interface FossilEnergyConsumption {\n  [date: string]: number;\n}\n\nexport const getFossilEnergyConsumption = async (\n  hass: HomeAssistant,\n  startTime: Date,\n  energy_statistic_ids: string[],\n  co2_statistic_id: string,\n  endTime?: Date,\n  period: \"5minute\" | \"hour\" | \"day\" | \"month\" = \"hour\"\n) =>\n  hass.callWS<FossilEnergyConsumption>({\n    type: \"energy/fossil_energy_consumption\",\n    start_time: startTime.toISOString(),\n    end_time: endTime?.toISOString(),\n    energy_statistic_ids,\n    co2_statistic_id,\n    period,\n  });\n\ninterface EnergySourceByType {\n  grid?: GridSourceTypeEnergyPreference[];\n  solar?: SolarSourceTypeEnergyPreference[];\n  battery?: BatterySourceTypeEnergyPreference[];\n  gas?: GasSourceTypeEnergyPreference[];\n  water?: WaterSourceTypeEnergyPreference[];\n}\n\nexport const energySourcesByType = (prefs: EnergyPreferences) =>\n  groupBy(prefs.energy_sources, (item) => item.type) as EnergySourceByType;\n\nexport interface EnergyData {\n  start: Date;\n  end?: Date;\n  startCompare?: Date;\n  endCompare?: Date;\n  prefs: EnergyPreferences;\n  info: EnergyInfo;\n  stats: Statistics;\n  statsMetadata: Record<string, StatisticsMetaData>;\n  statsCompare: Statistics;\n  co2SignalConfigEntry?: ConfigEntry;\n  co2SignalEntity?: string;\n  fossilEnergyConsumption?: FossilEnergyConsumption;\n  fossilEnergyConsumptionCompare?: FossilEnergyConsumption;\n}\n\nexport const getReferencedStatisticIds = (\n  prefs: EnergyPreferences,\n  info: EnergyInfo,\n  includeTypes?: string[]\n): string[] => {\n  const statIDs: string[] = [];\n\n  for (const source of prefs.energy_sources) {\n    if (includeTypes && !includeTypes.includes(source.type)) {\n      continue;\n    }\n\n    if (source.type === \"solar\") {\n      statIDs.push(source.stat_energy_from);\n      continue;\n    }\n\n    if (source.type === \"gas\" || source.type === \"water\") {\n      statIDs.push(source.stat_energy_from);\n\n      if (source.stat_cost) {\n        statIDs.push(source.stat_cost);\n      }\n      const costStatId = info.cost_sensors[source.stat_energy_from];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n      continue;\n    }\n\n    if (source.type === \"battery\") {\n      statIDs.push(source.stat_energy_from);\n      statIDs.push(source.stat_energy_to);\n      continue;\n    }\n\n    // grid source\n    for (const flowFrom of source.flow_from) {\n      statIDs.push(flowFrom.stat_energy_from);\n      if (flowFrom.stat_cost) {\n        statIDs.push(flowFrom.stat_cost);\n      }\n      const costStatId = info.cost_sensors[flowFrom.stat_energy_from];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n    }\n    for (const flowTo of source.flow_to) {\n      statIDs.push(flowTo.stat_energy_to);\n      if (flowTo.stat_compensation) {\n        statIDs.push(flowTo.stat_compensation);\n      }\n      const costStatId = info.cost_sensors[flowTo.stat_energy_to];\n      if (costStatId) {\n        statIDs.push(costStatId);\n      }\n    }\n  }\n\n  return statIDs;\n};\n\nconst getEnergyData = async (\n  hass: HomeAssistant,\n  prefs: EnergyPreferences,\n  start: Date,\n  end?: Date,\n  compare?: boolean\n): Promise<EnergyData> => {\n  const [configEntries, info] = await Promise.all([\n    getConfigEntries(hass, { domain: \"co2signal\" }),\n    getEnergyInfo(hass),\n  ]);\n\n  const co2SignalConfigEntry = configEntries.length\n    ? configEntries[0]\n    : undefined;\n\n  let co2SignalEntity: string | undefined;\n  if (co2SignalConfigEntry) {\n    for (const entity of Object.values(hass.entities)) {\n      if (entity.platform !== \"co2signal\") {\n        continue;\n      }\n\n      // The integration offers 2 entities. We want the % one.\n      const co2State = hass.states[entity.entity_id];\n      if (!co2State || co2State.attributes.unit_of_measurement !== \"%\") {\n        continue;\n      }\n\n      co2SignalEntity = co2State.entity_id;\n      break;\n    }\n  }\n\n  const consumptionStatIDs: string[] = [];\n  for (const source of prefs.energy_sources) {\n    // grid source\n    if (source.type === \"grid\") {\n      for (const flowFrom of source.flow_from) {\n        consumptionStatIDs.push(flowFrom.stat_energy_from);\n      }\n    }\n  }\n  const energyStatIds = getReferencedStatisticIds(prefs, info, [\n    \"grid\",\n    \"solar\",\n    \"battery\",\n    \"gas\",\n  ]);\n  const waterStatIds = getReferencedStatisticIds(prefs, info, [\"water\"]);\n\n  const allStatIDs = [...energyStatIds, ...waterStatIds];\n\n  const dayDifference = differenceInDays(end || new Date(), start);\n  const period =\n    dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\";\n\n  const lengthUnit = hass.config.unit_system.length || \"\";\n  const energyUnits: StatisticsUnitConfiguration = {\n    energy: \"kWh\",\n    volume: lengthUnit === \"km\" ? \"m³\" : \"ft³\",\n  };\n  const waterUnits: StatisticsUnitConfiguration = {\n    volume: lengthUnit === \"km\" ? \"L\" : \"gal\",\n  };\n\n  const _energyStats: Statistics | Promise<Statistics> = energyStatIds.length\n    ? fetchStatistics(hass!, start, end, energyStatIds, period, energyUnits, [\n        \"change\",\n      ])\n    : {};\n  const _waterStats: Statistics | Promise<Statistics> = waterStatIds.length\n    ? fetchStatistics(hass!, start, end, waterStatIds, period, waterUnits, [\n        \"change\",\n      ])\n    : {};\n\n  let statsCompare;\n  let startCompare;\n  let endCompare;\n  let _energyStatsCompare: Statistics | Promise<Statistics> = {};\n  let _waterStatsCompare: Statistics | Promise<Statistics> = {};\n\n  if (compare) {\n    if (\n      (calcDateProperty(\n        start,\n        isFirstDayOfMonth,\n        hass.locale,\n        hass.config\n      ) as boolean) &&\n      (calcDateProperty(\n        end || new Date(),\n        isLastDayOfMonth,\n        hass.locale,\n        hass.config\n      ) as boolean)\n    ) {\n      // When comparing a month (or multiple), we want to start at the begining of the month\n      startCompare = calcDate(\n        start,\n        addMonths,\n        hass.locale,\n        hass.config,\n        -(calcDateProperty(\n          end || new Date(),\n          differenceInMonths,\n          hass.locale,\n          hass.config,\n          start\n        ) as number) - 1\n      );\n    } else {\n      startCompare = calcDate(\n        start,\n        addDays,\n        hass.locale,\n        hass.config,\n        (dayDifference + 1) * -1\n      );\n    }\n    endCompare = addMilliseconds(start, -1);\n    if (energyStatIds.length) {\n      _energyStatsCompare = fetchStatistics(\n        hass!,\n        startCompare,\n        endCompare,\n        energyStatIds,\n        period,\n        energyUnits,\n        [\"change\"]\n      );\n    }\n    if (waterStatIds.length) {\n      _waterStatsCompare = fetchStatistics(\n        hass!,\n        startCompare,\n        endCompare,\n        waterStatIds,\n        period,\n        waterUnits,\n        [\"change\"]\n      );\n    }\n  }\n\n  let _fossilEnergyConsumption: undefined | Promise<FossilEnergyConsumption>;\n  let _fossilEnergyConsumptionCompare:\n    | undefined\n    | Promise<FossilEnergyConsumption>;\n  if (co2SignalEntity !== undefined) {\n    _fossilEnergyConsumption = getFossilEnergyConsumption(\n      hass!,\n      start,\n      consumptionStatIDs,\n      co2SignalEntity,\n      end,\n      dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\"\n    );\n    if (compare) {\n      _fossilEnergyConsumptionCompare = getFossilEnergyConsumption(\n        hass!,\n        startCompare,\n        consumptionStatIDs,\n        co2SignalEntity,\n        endCompare,\n        dayDifference > 35 ? \"month\" : dayDifference > 2 ? \"day\" : \"hour\"\n      );\n    }\n  }\n\n  const statsMetadata: Record<string, StatisticsMetaData> = {};\n  const _getStatisticMetadata:\n    | Promise<StatisticsMetaData[]>\n    | StatisticsMetaData[] = allStatIDs.length\n    ? getStatisticMetadata(hass, allStatIDs)\n    : [];\n  const [\n    energyStats,\n    waterStats,\n    energyStatsCompare,\n    waterStatsCompare,\n    statsMetadataArray,\n    fossilEnergyConsumption,\n    fossilEnergyConsumptionCompare,\n  ] = await Promise.all([\n    _energyStats,\n    _waterStats,\n    _energyStatsCompare,\n    _waterStatsCompare,\n    _getStatisticMetadata,\n    _fossilEnergyConsumption,\n    _fossilEnergyConsumptionCompare,\n  ]);\n  const stats = { ...energyStats, ...waterStats };\n  if (compare) {\n    statsCompare = { ...energyStatsCompare, ...waterStatsCompare };\n  }\n  if (allStatIDs.length) {\n    statsMetadataArray.forEach((x) => {\n      statsMetadata[x.statistic_id] = x;\n    });\n  }\n\n  const data: EnergyData = {\n    start,\n    end,\n    startCompare,\n    endCompare,\n    info,\n    prefs,\n    stats,\n    statsMetadata,\n    statsCompare,\n    co2SignalConfigEntry,\n    co2SignalEntity,\n    fossilEnergyConsumption,\n    fossilEnergyConsumptionCompare,\n  };\n\n  return data;\n};\n\nexport interface EnergyCollection extends Collection<EnergyData> {\n  start: Date;\n  end?: Date;\n  compare?: boolean;\n  prefs?: EnergyPreferences;\n  clearPrefs(): void;\n  setPeriod(newStart: Date, newEnd?: Date): void;\n  setCompare(compare: boolean): void;\n  _refreshTimeout?: number;\n  _updatePeriodTimeout?: number;\n  _active: number;\n}\n\nconst clearEnergyCollectionPreferences = (hass: HomeAssistant) => {\n  energyCollectionKeys.forEach((key) => {\n    const energyCollection = getEnergyDataCollection(hass, { key });\n    energyCollection.clearPrefs();\n    if (energyCollection._active) {\n      energyCollection.refresh();\n    }\n  });\n};\n\nconst scheduleHourlyRefresh = (collection: EnergyCollection) => {\n  if (collection._refreshTimeout) {\n    clearTimeout(collection._refreshTimeout);\n  }\n\n  if (collection._active && (!collection.end || collection.end > new Date())) {\n    // The stats are created every hour\n    // Schedule a refresh for 20 minutes past the hour\n    // If the end is larger than the current time.\n    const nextFetch = new Date();\n    if (nextFetch.getMinutes() >= 20) {\n      nextFetch.setHours(nextFetch.getHours() + 1);\n    }\n    nextFetch.setMinutes(20, 0, 0);\n\n    collection._refreshTimeout = window.setTimeout(\n      () => collection.refresh(),\n      nextFetch.getTime() - Date.now()\n    );\n  }\n};\n\nexport const getEnergyDataCollection = (\n  hass: HomeAssistant,\n  options: { prefs?: EnergyPreferences; key?: string } = {}\n): EnergyCollection => {\n  let key = \"_energy\";\n  if (options.key) {\n    if (!options.key.startsWith(\"energy_\")) {\n      throw new Error(\"Key need to start with energy_\");\n    }\n    key = `_${options.key}`;\n  }\n\n  if ((hass.connection as any)[key]) {\n    return (hass.connection as any)[key];\n  }\n\n  energyCollectionKeys.push(options.key);\n\n  const collection = getCollection<EnergyData>(\n    hass.connection,\n    key,\n    async () => {\n      if (!collection.prefs) {\n        // This will raise if not found.\n        // Detect by checking `e.code === \"not_found\"\n        collection.prefs = await getEnergyPreferences(hass);\n      }\n\n      scheduleHourlyRefresh(collection);\n\n      return getEnergyData(\n        hass,\n        collection.prefs,\n        collection.start,\n        collection.end,\n        collection.compare\n      );\n    }\n  ) as EnergyCollection;\n\n  const origSubscribe = collection.subscribe;\n\n  collection.subscribe = (subscriber: (data: EnergyData) => void) => {\n    const unsub = origSubscribe(subscriber);\n    collection._active++;\n\n    if (collection._refreshTimeout === undefined) {\n      scheduleHourlyRefresh(collection);\n    }\n\n    return () => {\n      collection._active--;\n      if (collection._active < 1) {\n        clearTimeout(collection._refreshTimeout);\n        collection._refreshTimeout = undefined;\n      }\n      unsub();\n    };\n  };\n\n  collection._active = 0;\n  collection.prefs = options.prefs;\n  const now = new Date();\n  const hour = formatTime24h(now, hass.locale, hass.config).split(\":\")[0];\n  // Set start to start of today if we have data for today, otherwise yesterday\n  collection.start = calcDate(\n    hour === \"0\" ? addDays(now, -1) : now,\n    startOfDay,\n    hass.locale,\n    hass.config\n  );\n  collection.end = calcDate(\n    hour === \"0\" ? addDays(now, -1) : now,\n    endOfDay,\n    hass.locale,\n    hass.config\n  );\n\n  const scheduleUpdatePeriod = () => {\n    collection._updatePeriodTimeout = window.setTimeout(\n      () => {\n        collection.start = calcDate(\n          new Date(),\n          startOfDay,\n          hass.locale,\n          hass.config\n        );\n        collection.end = calcDate(\n          new Date(),\n          endOfDay,\n          hass.locale,\n          hass.config\n        );\n        scheduleUpdatePeriod();\n      },\n      addHours(calcDate(now, endOfDay, hass.locale, hass.config), 1).getTime() -\n        Date.now() // Switch to next day an hour after the day changed\n    );\n  };\n  scheduleUpdatePeriod();\n\n  collection.clearPrefs = () => {\n    collection.prefs = undefined;\n  };\n  collection.setPeriod = (newStart: Date, newEnd?: Date) => {\n    collection.start = newStart;\n    collection.end = newEnd;\n    if (\n      collection.start.getTime() ===\n        calcDate(new Date(), startOfDay, hass.locale, hass.config).getTime() &&\n      collection.end?.getTime() ===\n        calcDate(new Date(), endOfDay, hass.locale, hass.config).getTime() &&\n      !collection._updatePeriodTimeout\n    ) {\n      scheduleUpdatePeriod();\n    } else if (collection._updatePeriodTimeout) {\n      clearTimeout(collection._updatePeriodTimeout);\n      collection._updatePeriodTimeout = undefined;\n    }\n  };\n  collection.setCompare = (compare: boolean) => {\n    collection.compare = compare;\n  };\n  return collection;\n};\n\nexport const getEnergySolarForecasts = (hass: HomeAssistant) =>\n  hass.callWS<EnergySolarForecasts>({\n    type: \"energy/solar_forecast\",\n  });\n\nconst energyGasUnitClass = [\"volume\", \"energy\"] as const;\nexport type EnergyGasUnitClass = (typeof energyGasUnitClass)[number];\n\nexport const getEnergyGasUnitClass = (\n  prefs: EnergyPreferences,\n  statisticsMetaData: Record<string, StatisticsMetaData> = {},\n  excludeSource?: string\n): EnergyGasUnitClass | undefined => {\n  for (const source of prefs.energy_sources) {\n    if (source.type !== \"gas\") {\n      continue;\n    }\n    if (excludeSource && excludeSource === source.stat_energy_from) {\n      continue;\n    }\n    const statisticIdWithMeta = statisticsMetaData[source.stat_energy_from];\n    if (\n      energyGasUnitClass.includes(\n        statisticIdWithMeta?.unit_class as EnergyGasUnitClass\n      )\n    ) {\n      return statisticIdWithMeta.unit_class as EnergyGasUnitClass;\n    }\n  }\n  return undefined;\n};\n\nexport const getEnergyGasUnit = (\n  hass: HomeAssistant,\n  prefs: EnergyPreferences,\n  statisticsMetaData: Record<string, StatisticsMetaData> = {}\n): string | undefined => {\n  const unitClass = getEnergyGasUnitClass(prefs, statisticsMetaData);\n  if (unitClass === undefined) {\n    return undefined;\n  }\n  return unitClass === \"energy\"\n    ? \"kWh\"\n    : hass.config.unit_system.length === \"km\"\n      ? \"m³\"\n      : \"ft³\";\n};\n\nexport const getEnergyWaterUnit = (hass: HomeAssistant): string | undefined =>\n  hass.config.unit_system.length === \"km\" ? \"L\" : \"gal\";\n\nexport const energyStatisticHelpUrl =\n  \"/docs/energy/faq/#troubleshooting-missing-entities\";\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}