{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n/**\n * Unique symbol for marking roots\n */\nconst selectionController = Symbol('selection controller');\n/**\n * Set of checkable elements with added metadata\n */\nexport class SingleSelectionSet {\n  constructor() {\n    this.selected = null;\n    this.ordered = null;\n    this.set = new Set();\n  }\n}\n/**\n * Controller that provides behavior similar to a native `<input type=\"radio\">`\n * group.\n *\n * Behaviors:\n *\n * - Selection via key navigation (currently LTR is supported)\n * - Deselection of other grouped, checkable controls upon selection\n * - Grouping of checkable elements by name\n *   - Defaults grouping scope to host shadow root\n *   - Document-wide scoping enabled\n * - Land focus only on checked element. Focuses leading element when none\n *   checked.\n *\n * Intended Usage:\n *\n * ```ts\n * class MyElement extends HTMLElement {\n *   private selectionController: SingleSelectionController | null = null;\n *   name = \"\";\n *   global = false;\n *\n *   private _checked = false;\n *   set checked(checked: boolean) {\n *     const oldVal = this._checked;\n *     if (checked === oldVal) return;\n *\n *     this._checked = checked;\n *\n *     if (this.selectionController) {\n *       this.selectionController.update(this)\n *     }\n *   }\n *\n *   get checked() {\n *     return this._checked;\n *   }\n *\n *   connectedCallback() {\n *     this.selectionController = SelectionController.getController(this);\n *     this.selectionController.register(this);\n *     this.selectionController.update(this);\n *   }\n *\n *   disconnectedCallback() {\n *     this.selectionController!.unregister(this);\n *     this.selectionController = null;\n *   }\n * }\n * ```\n */\nexport class SingleSelectionController {\n  constructor(element) {\n    this.sets = {};\n    this.focusedSet = null;\n    this.mouseIsDown = false;\n    this.updating = false;\n    element.addEventListener('keydown', e => {\n      this.keyDownHandler(e);\n    });\n    element.addEventListener('mousedown', () => {\n      this.mousedownHandler();\n    });\n    element.addEventListener('mouseup', () => {\n      this.mouseupHandler();\n    });\n  }\n  /**\n   * Get a controller for the given element. If no controller exists, one will\n   * be created. Defaults to getting the controller scoped to the element's root\n   * node shadow root unless `element.global` is true. Then, it will get a\n   * `window.document`-scoped controller.\n   *\n   * @param element Element from which to get / create a SelectionController. If\n   *     `element.global` is true, it gets a selection controller scoped to\n   *     `window.document`.\n   */\n  static getController(element) {\n    const useGlobal = !('global' in element) || 'global' in element && element.global;\n    const root = useGlobal ? document : element.getRootNode();\n    let controller = root[selectionController];\n    if (controller === undefined) {\n      controller = new SingleSelectionController(root);\n      root[selectionController] = controller;\n    }\n    return controller;\n  }\n  keyDownHandler(e) {\n    const element = e.target;\n    if (!('checked' in element)) {\n      return;\n    }\n    if (!this.has(element)) {\n      return;\n    }\n    if (e.key == 'ArrowRight' || e.key == 'ArrowDown') {\n      this.selectNext(element);\n    } else if (e.key == 'ArrowLeft' || e.key == 'ArrowUp') {\n      this.selectPrevious(element);\n    }\n  }\n  mousedownHandler() {\n    this.mouseIsDown = true;\n  }\n  mouseupHandler() {\n    this.mouseIsDown = false;\n  }\n  /**\n   * Whether or not the controller controls  the given element.\n   *\n   * @param element element to check\n   */\n  has(element) {\n    const set = this.getSet(element.name);\n    return set.set.has(element);\n  }\n  /**\n   * Selects and returns the controlled element previous to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which preceding element is fetched\n   */\n  selectPrevious(element) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const previous = order[i - 1] || order[order.length - 1];\n    this.select(previous);\n    return previous;\n  }\n  /**\n   * Selects and returns the controlled element next to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which following element is fetched\n   */\n  selectNext(element) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const next = order[i + 1] || order[0];\n    this.select(next);\n    return next;\n  }\n  select(element) {\n    element.click();\n  }\n  /**\n   * Focuses the selected element in the given element's selection set. User's\n   * mouse selection will override this focus.\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     focused.\n   * @deprecated update() method now handles focus management by setting\n   *     appropriate tabindex to form element.\n   */\n  focus(element) {\n    // Only manage focus state when using keyboard\n    if (this.mouseIsDown) {\n      return;\n    }\n    const set = this.getSet(element.name);\n    const currentFocusedSet = this.focusedSet;\n    this.focusedSet = set;\n    if (currentFocusedSet != set && set.selected && set.selected != element) {\n      set.selected.focus();\n    }\n  }\n  /**\n   * @return Returns true if atleast one radio is selected in the radio group.\n   */\n  isAnySelected(element) {\n    const set = this.getSet(element.name);\n    for (const e of set.set) {\n      if (e.checked) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the elements in the given element's selection set in document\n   * position order.\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     ordered.\n   */\n  getOrdered(element) {\n    const set = this.getSet(element.name);\n    if (!set.ordered) {\n      set.ordered = Array.from(set.set);\n      set.ordered.sort((a, b) => a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0);\n    }\n    return set.ordered;\n  }\n  /**\n   * Gets the selection set of the given name and creates one if it does not yet\n   * exist.\n   *\n   * @param name Name of set\n   */\n  getSet(name) {\n    if (!this.sets[name]) {\n      this.sets[name] = new SingleSelectionSet();\n    }\n    return this.sets[name];\n  }\n  /**\n   * Register the element in the selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  register(element) {\n    // TODO(b/168546148): Remove accessing 'name' via getAttribute() when new\n    // base class is created without single selection controller. Component\n    // maybe booted up after it is connected to DOM in which case properties\n    // (including `name`) are not updated yet.\n    const name = element.name || element.getAttribute('name') || '';\n    const set = this.getSet(name);\n    set.set.add(element);\n    set.ordered = null;\n  }\n  /**\n   * Unregister the element from selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  unregister(element) {\n    const set = this.getSet(element.name);\n    set.set.delete(element);\n    set.ordered = null;\n    if (set.selected == element) {\n      set.selected = null;\n    }\n  }\n  /**\n   * Unselects other elements in element's set if element is checked. Noop\n   * otherwise.\n   *\n   * @param element Element from which to calculate selection controller update.\n   */\n  update(element) {\n    if (this.updating) {\n      return;\n    }\n    this.updating = true;\n    const set = this.getSet(element.name);\n    if (element.checked) {\n      for (const e of set.set) {\n        if (e == element) {\n          continue;\n        }\n        e.checked = false;\n      }\n      set.selected = element;\n    }\n    // When tabbing through land focus on the checked radio in the group.\n    if (this.isAnySelected(element)) {\n      for (const e of set.set) {\n        if (e.formElementTabIndex === undefined) {\n          break;\n        }\n        e.formElementTabIndex = e.checked ? 0 : -1;\n      }\n    }\n    this.updating = false;\n  }\n}","map":{"version":3,"names":["selectionController","Symbol","SingleSelectionSet","constructor","selected","ordered","set","Set","SingleSelectionController","element","sets","focusedSet","mouseIsDown","updating","addEventListener","e","keyDownHandler","mousedownHandler","mouseupHandler","getController","useGlobal","global","root","document","getRootNode","controller","undefined","target","has","key","selectNext","selectPrevious","getSet","name","order","getOrdered","i","indexOf","previous","length","select","next","click","focus","currentFocusedSet","isAnySelected","checked","Array","from","sort","a","b","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","register","getAttribute","add","unregister","delete","update","formElementTabIndex"],"sources":["single-selection-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n/**\n * Unique symbol for marking roots\n */\nconst selectionController = Symbol('selection controller');\n\n/**\n * Set of checkable elements with added metadata\n */\nexport class SingleSelectionSet {\n  selected: CheckableElement|null = null;\n  ordered: CheckableElement[]|null = null;\n  readonly set = new Set<CheckableElement>();\n}\n\n/**\n * Element that is checkable consumed by\n * `SingleSelectionController` and `SingleSelectionSet`\n */\nexport type CheckableElement = HTMLElement&{\n  name: string;\n  checked: boolean;\n  formElementTabIndex?: number;\n};\n\n/**\n * Controller that provides behavior similar to a native `<input type=\"radio\">`\n * group.\n *\n * Behaviors:\n *\n * - Selection via key navigation (currently LTR is supported)\n * - Deselection of other grouped, checkable controls upon selection\n * - Grouping of checkable elements by name\n *   - Defaults grouping scope to host shadow root\n *   - Document-wide scoping enabled\n * - Land focus only on checked element. Focuses leading element when none\n *   checked.\n *\n * Intended Usage:\n *\n * ```ts\n * class MyElement extends HTMLElement {\n *   private selectionController: SingleSelectionController | null = null;\n *   name = \"\";\n *   global = false;\n *\n *   private _checked = false;\n *   set checked(checked: boolean) {\n *     const oldVal = this._checked;\n *     if (checked === oldVal) return;\n *\n *     this._checked = checked;\n *\n *     if (this.selectionController) {\n *       this.selectionController.update(this)\n *     }\n *   }\n *\n *   get checked() {\n *     return this._checked;\n *   }\n *\n *   connectedCallback() {\n *     this.selectionController = SelectionController.getController(this);\n *     this.selectionController.register(this);\n *     this.selectionController.update(this);\n *   }\n *\n *   disconnectedCallback() {\n *     this.selectionController!.unregister(this);\n *     this.selectionController = null;\n *   }\n * }\n * ```\n */\nexport class SingleSelectionController {\n  private readonly sets: {[name: string]: SingleSelectionSet} = {};\n\n  private focusedSet: SingleSelectionSet|null = null;\n\n  private mouseIsDown = false;\n\n  private updating = false;\n\n  /**\n   * Get a controller for the given element. If no controller exists, one will\n   * be created. Defaults to getting the controller scoped to the element's root\n   * node shadow root unless `element.global` is true. Then, it will get a\n   * `window.document`-scoped controller.\n   *\n   * @param element Element from which to get / create a SelectionController. If\n   *     `element.global` is true, it gets a selection controller scoped to\n   *     `window.document`.\n   */\n  static getController(element: HTMLElement|HTMLElement&{global: boolean}) {\n    const useGlobal =\n        !('global' in element) || ('global' in element && element.global);\n    const root = useGlobal ? document as Document &\n            {[selectionController]?: SingleSelectionController} :\n                             (element as Element).getRootNode() as Node &\n            {[selectionController]?: SingleSelectionController};\n    let controller = root[selectionController];\n    if (controller === undefined) {\n      controller = new SingleSelectionController(root);\n      root[selectionController] = controller;\n    }\n    return controller;\n  }\n\n  constructor(element: Node) {\n    element.addEventListener('keydown', (e: Event) => {\n      this.keyDownHandler(e as KeyboardEvent);\n    });\n    element.addEventListener('mousedown', () => {\n      this.mousedownHandler();\n    });\n    element.addEventListener('mouseup', () => {\n      this.mouseupHandler();\n    });\n  }\n\n  protected keyDownHandler(e: KeyboardEvent) {\n    const element = e.target as EventTarget | CheckableElement;\n    if (!('checked' in element)) {\n      return;\n    }\n    if (!this.has(element)) {\n      return;\n    }\n    if (e.key == 'ArrowRight' || e.key == 'ArrowDown') {\n      this.selectNext(element);\n    } else if (e.key == 'ArrowLeft' || e.key == 'ArrowUp') {\n      this.selectPrevious(element);\n    }\n  }\n\n  protected mousedownHandler() {\n    this.mouseIsDown = true;\n  }\n\n  protected mouseupHandler() {\n    this.mouseIsDown = false;\n  }\n\n  /**\n   * Whether or not the controller controls  the given element.\n   *\n   * @param element element to check\n   */\n  has(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    return set.set.has(element);\n  }\n\n  /**\n   * Selects and returns the controlled element previous to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which preceding element is fetched\n   */\n  selectPrevious(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const previous = order[i - 1] || order[order.length - 1];\n    this.select(previous);\n\n    return previous;\n  }\n\n  /**\n   * Selects and returns the controlled element next to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which following element is fetched\n   */\n  selectNext(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const next = order[i + 1] || order[0];\n    this.select(next);\n\n    return next;\n  }\n\n  select(element: CheckableElement) {\n    element.click();\n  }\n\n  /**\n   * Focuses the selected element in the given element's selection set. User's\n   * mouse selection will override this focus.\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     focused.\n   * @deprecated update() method now handles focus management by setting\n   *     appropriate tabindex to form element.\n   */\n  focus(element: CheckableElement) {\n    // Only manage focus state when using keyboard\n    if (this.mouseIsDown) {\n      return;\n    }\n    const set = this.getSet(element.name);\n    const currentFocusedSet = this.focusedSet;\n    this.focusedSet = set;\n    if (currentFocusedSet != set && set.selected && set.selected != element) {\n      set.selected.focus();\n    }\n  }\n\n  /**\n   * @return Returns true if atleast one radio is selected in the radio group.\n   */\n  isAnySelected(element: CheckableElement): boolean {\n    const set = this.getSet(element.name);\n\n    for (const e of set.set) {\n      if (e.checked) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the elements in the given element's selection set in document\n   * position order.\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     ordered.\n   */\n  getOrdered(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    if (!set.ordered) {\n      set.ordered = Array.from(set.set);\n      set.ordered.sort(\n          (a, b) =>\n              a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ?\n              1 :\n              0);\n    }\n    return set.ordered;\n  }\n\n  /**\n   * Gets the selection set of the given name and creates one if it does not yet\n   * exist.\n   *\n   * @param name Name of set\n   */\n  getSet(name: string): SingleSelectionSet {\n    if (!this.sets[name]) {\n      this.sets[name] = new SingleSelectionSet();\n    }\n    return this.sets[name];\n  }\n\n  /**\n   * Register the element in the selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  register(element: CheckableElement) {\n    // TODO(b/168546148): Remove accessing 'name' via getAttribute() when new\n    // base class is created without single selection controller. Component\n    // maybe booted up after it is connected to DOM in which case properties\n    // (including `name`) are not updated yet.\n    const name = element.name || element.getAttribute('name') || '';\n    const set = this.getSet(name);\n    set.set.add(element);\n    set.ordered = null;\n  }\n\n  /**\n   * Unregister the element from selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  unregister(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    set.set.delete(element);\n    set.ordered = null;\n    if (set.selected == element) {\n      set.selected = null;\n    }\n  }\n\n  /**\n   * Unselects other elements in element's set if element is checked. Noop\n   * otherwise.\n   *\n   * @param element Element from which to calculate selection controller update.\n   */\n  update(element: CheckableElement) {\n    if (this.updating) {\n      return;\n    }\n    this.updating = true;\n    const set = this.getSet(element.name);\n    if (element.checked) {\n      for (const e of set.set) {\n        if (e == element) {\n          continue;\n        }\n        e.checked = false;\n      }\n      set.selected = element;\n    }\n\n    // When tabbing through land focus on the checked radio in the group.\n    if (this.isAnySelected(element)) {\n      for (const e of set.set) {\n        if (e.formElementTabIndex === undefined) {\n          break;\n        }\n\n        e.formElementTabIndex = e.checked ? 0 : -1;\n      }\n    }\n    this.updating = false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}