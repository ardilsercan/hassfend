{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.array.concat.js\";\n/**\n * Call a function with result caching per entity.\n * @param cacheKey key to store the cache on hass object\n * @param cacheTime time to cache the results\n * @param func function to fetch the data\n * @param hass Indexline Technology object\n * @param entityId entity to fetch data for\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport var timeCacheEntityPromiseFunc = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cacheKey, cacheTime, func, hass, entityId) {\n    var _len,\n      args,\n      _key,\n      cache,\n      lastResult,\n      result,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n            args[_key - 5] = _args[_key];\n          }\n          cache = hass[cacheKey];\n          if (!cache) {\n            cache = hass[cacheKey] = {};\n          }\n          lastResult = cache[entityId];\n          if (!lastResult) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", lastResult);\n        case 6:\n          result = func.apply(void 0, [hass, entityId].concat(args));\n          cache[entityId] = result;\n          result.then(\n          // When successful, set timer to clear cache\n          function () {\n            return setTimeout(function () {\n              cache[entityId] = undefined;\n            }, cacheTime);\n          },\n          // On failure, clear cache right away\n          function () {\n            cache[entityId] = undefined;\n          });\n          return _context.abrupt(\"return\", result);\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function timeCacheEntityPromiseFunc(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["timeCacheEntityPromiseFunc","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","cacheKey","cacheTime","func","hass","entityId","_len","args","_key","cache","lastResult","result","_args","arguments","wrap","_callee$","_context","prev","next","length","Array","abrupt","apply","concat","then","setTimeout","undefined","stop","_x","_x2","_x3","_x4","_x5"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/util/time-cache-entity-promise-func.ts"],"sourcesContent":["import { HomeAssistant } from \"../../types\";\n\ninterface ResultCache<T> {\n  [entityId: string]: Promise<T> | undefined;\n}\n\n/**\n * Call a function with result caching per entity.\n * @param cacheKey key to store the cache on hass object\n * @param cacheTime time to cache the results\n * @param func function to fetch the data\n * @param hass Indexline Technology object\n * @param entityId entity to fetch data for\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCacheEntityPromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (hass: HomeAssistant, entityId: string, ...args: any[]) => Promise<T>,\n  hass: HomeAssistant,\n  entityId: string,\n  ...args: any[]\n): Promise<T> => {\n  let cache: ResultCache<T> | undefined = (hass as any)[cacheKey];\n\n  if (!cache) {\n    cache = hass[cacheKey] = {};\n  }\n\n  const lastResult = cache[entityId];\n\n  if (lastResult) {\n    return lastResult;\n  }\n\n  const result = func(hass, entityId, ...args);\n  cache[entityId] = result;\n\n  result.then(\n    // When successful, set timer to clear cache\n    () =>\n      setTimeout(() => {\n        cache![entityId] = undefined;\n      }, cacheTime),\n    // On failure, clear cache right away\n    () => {\n      cache![entityId] = undefined;\n    }\n  );\n\n  return result;\n};\n"],"mappings":";;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,0BAA0B;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QACxCC,QAAgB,EAChBC,SAAiB,EACjBC,IAA2E,EAC3EC,IAAmB,EACnBC,QAAgB;IAAA,IAAAC,IAAA;MAAAC,IAAA;MAAAC,IAAA;MAAAC,KAAA;MAAAC,UAAA;MAAAC,MAAA;MAAAC,KAAA,GAAAC,SAAA;IAAA,OAAAf,mBAAA,GAAAgB,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,KAAAZ,IAAA,GAAAM,KAAA,CAAAO,MAAA,EACbZ,IAAI,OAAAa,KAAA,CAAAd,IAAA,OAAAA,IAAA,WAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;YAAJD,IAAI,CAAAC,IAAA,QAAAI,KAAA,CAAAJ,IAAA;UAAA;UAEHC,KAAiC,GAAIL,IAAI,CAASH,QAAQ,CAAC;UAE/D,IAAI,CAACQ,KAAK,EAAE;YACVA,KAAK,GAAGL,IAAI,CAACH,QAAQ,CAAC,GAAG,CAAC,CAAC;UAC7B;UAEMS,UAAU,GAAGD,KAAK,CAACJ,QAAQ,CAAC;UAAA,KAE9BK,UAAU;YAAAM,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAK,MAAA,WACLX,UAAU;QAAA;UAGbC,MAAM,GAAGR,IAAI,CAAAmB,KAAA,UAAClB,IAAI,EAAEC,QAAQ,EAAAkB,MAAA,CAAKhB,IAAI,EAAC;UAC5CE,KAAK,CAACJ,QAAQ,CAAC,GAAGM,MAAM;UAExBA,MAAM,CAACa,IAAI;UACT;UACA;YAAA,OACEC,UAAU,CAAC,YAAM;cACfhB,KAAK,CAAEJ,QAAQ,CAAC,GAAGqB,SAAS;YAC9B,CAAC,EAAExB,SAAS,CAAC;UAAA;UACf;UACA,YAAM;YACJO,KAAK,CAAEJ,QAAQ,CAAC,GAAGqB,SAAS;UAC9B,CACF,CAAC;UAAC,OAAAV,QAAA,CAAAK,MAAA,WAEKV,MAAM;QAAA;QAAA;UAAA,OAAAK,QAAA,CAAAW,IAAA;MAAA;IAAA,GAAA3B,OAAA;EAAA,CACd;EAAA,gBApCYL,0BAA0BA,CAAAiC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;IAAA,OAAApC,IAAA,CAAA0B,KAAA,OAAAT,SAAA;EAAA;AAAA,GAoCtC"},"metadata":{},"sourceType":"module","externalDependencies":[]}