{"ast":null,"code":"import { fetchTranslationPreferences } from \"../data/translation\";\nimport { translationMetadata } from \"../resources/translations-metadata\";\nconst BASE_URL = `${__STATIC_PATH__}translations`;\nconst STORAGE = window.localStorage || {};\n\n// Store loaded translations in memory so translations are available immediately\n// when DOM is created in Polymer. Even a cache lookup creates noticeable latency.\nconst translations = {};\nasync function fetchTranslation(fingerprint) {\n  const response = await fetch(`${BASE_URL}/${fingerprint}`, {\n    credentials: \"same-origin\"\n  });\n  if (!response.ok) {\n    throw new Error(`Fail to fetch translation ${fingerprint}: HTTP response status is ${response.status}`);\n  }\n  return response.json();\n}\n\n// Chinese locales need map to Simplified or Traditional Chinese\nconst LOCALE_LOOKUP = {\n  \"zh-cn\": \"zh-Hans\",\n  \"zh-sg\": \"zh-Hans\",\n  \"zh-my\": \"zh-Hans\",\n  \"zh-tw\": \"zh-Hant\",\n  \"zh-hk\": \"zh-Hant\",\n  \"zh-mo\": \"zh-Hant\",\n  zh: \"zh-Hant\" // all other Chinese locales map to Traditional Chinese\n};\n\n/**\n * Search for a matching translation from most specific to general\n */\nexport function findAvailableLanguage(language) {\n  // In most case, the language has the same format with our translation meta data\n  if (language in translationMetadata.translations) {\n    return language;\n  }\n\n  // Perform case-insenstive comparison since browser isn't required to\n  // report languages with specific cases.\n  const langLower = language.toLowerCase();\n  if (langLower in LOCALE_LOOKUP) {\n    return LOCALE_LOOKUP[langLower];\n  }\n  const translation = Object.keys(translationMetadata.translations).find(lang => lang.toLowerCase() === langLower);\n  if (translation) {\n    return translation;\n  }\n  if (language.includes(\"-\")) {\n    return findAvailableLanguage(language.split(\"-\")[0]);\n  }\n  return undefined;\n}\n\n/**\n * Get user selected locale data from backend\n */\nexport async function getUserLocale(hass) {\n  const result = await fetchTranslationPreferences(hass);\n  const language = result === null || result === void 0 ? void 0 : result.language;\n  const number_format = result === null || result === void 0 ? void 0 : result.number_format;\n  const time_format = result === null || result === void 0 ? void 0 : result.time_format;\n  const date_format = result === null || result === void 0 ? void 0 : result.date_format;\n  const time_zone = result === null || result === void 0 ? void 0 : result.time_zone;\n  const first_weekday = result === null || result === void 0 ? void 0 : result.first_weekday;\n  if (language) {\n    const availableLanguage = findAvailableLanguage(language);\n    if (availableLanguage) {\n      return {\n        language: availableLanguage,\n        number_format,\n        time_format,\n        date_format,\n        time_zone,\n        first_weekday\n      };\n    }\n  }\n  return {\n    number_format,\n    time_format,\n    date_format,\n    time_zone,\n    first_weekday\n  };\n}\n\n/**\n * Get browser specific language\n */\nexport function getLocalLanguage() {\n  let language = null;\n  if (STORAGE.selectedLanguage) {\n    try {\n      const stored = JSON.parse(STORAGE.selectedLanguage);\n      if (stored) {\n        language = findAvailableLanguage(stored);\n        if (language) {\n          return language;\n        }\n      }\n    } catch (err) {\n      // Ignore parsing error.\n    }\n  }\n  if (navigator.languages) {\n    for (const locale of navigator.languages) {\n      language = findAvailableLanguage(locale);\n      if (language) {\n        return language;\n      }\n    }\n  }\n  language = findAvailableLanguage(navigator.language);\n  if (language) {\n    return language;\n  }\n  // Final fallback\n  return \"en\";\n}\nexport async function getTranslation(fragment, language) {\n  const metadata = translationMetadata.translations[language];\n  if (!(metadata !== null && metadata !== void 0 && metadata.hash)) {\n    if (language !== \"en\") {\n      return getTranslation(fragment, \"en\");\n    }\n    throw new Error(\"Language en is not found in metadata\");\n  }\n\n  // nl-abcd.jon or logbook/nl-abcd.json\n  const fingerprint = `${fragment ? fragment + \"/\" : \"\"}${language}-${metadata.hash}.json`;\n\n  // Fetch translation from the server\n  if (!translations[fingerprint]) {\n    translations[fingerprint] = fetchTranslation(fingerprint).then(data => ({\n      language,\n      data\n    })).catch(error => {\n      delete translations[fingerprint];\n      if (language !== \"en\") {\n        // Couldn't load selected translation. Try a fall back to en before failing.\n        return getTranslation(fragment, \"en\");\n      }\n      return Promise.reject(error);\n    });\n  }\n  return translations[fingerprint];\n}","map":{"version":3,"names":["fetchTranslationPreferences","translationMetadata","BASE_URL","__STATIC_PATH__","STORAGE","window","localStorage","translations","fetchTranslation","fingerprint","response","fetch","credentials","ok","Error","status","json","LOCALE_LOOKUP","zh","findAvailableLanguage","language","langLower","toLowerCase","translation","Object","keys","find","lang","includes","split","undefined","getUserLocale","hass","result","number_format","time_format","date_format","time_zone","first_weekday","availableLanguage","getLocalLanguage","selectedLanguage","stored","JSON","parse","err","navigator","languages","locale","getTranslation","fragment","metadata","hash","then","data","catch","error","Promise","reject"],"sources":["/Users/sercanardil/Desktop/frontend/src/util/common-translation.ts"],"sourcesContent":["import {\n  fetchTranslationPreferences,\n  FrontendLocaleData,\n} from \"../data/translation\";\nimport { translationMetadata } from \"../resources/translations-metadata\";\nimport { HomeAssistant } from \"../types\";\n\nconst BASE_URL = `${__STATIC_PATH__}translations`;\nconst STORAGE = window.localStorage || {};\n\n// Store loaded translations in memory so translations are available immediately\n// when DOM is created in Polymer. Even a cache lookup creates noticeable latency.\nconst translations = {};\n\nasync function fetchTranslation(fingerprint: string) {\n  const response = await fetch(`${BASE_URL}/${fingerprint}`, {\n    credentials: \"same-origin\",\n  });\n  if (!response.ok) {\n    throw new Error(\n      `Fail to fetch translation ${fingerprint}: HTTP response status is ${response.status}`\n    );\n  }\n  return response.json();\n}\n\n// Chinese locales need map to Simplified or Traditional Chinese\nconst LOCALE_LOOKUP = {\n  \"zh-cn\": \"zh-Hans\",\n  \"zh-sg\": \"zh-Hans\",\n  \"zh-my\": \"zh-Hans\",\n  \"zh-tw\": \"zh-Hant\",\n  \"zh-hk\": \"zh-Hant\",\n  \"zh-mo\": \"zh-Hant\",\n  zh: \"zh-Hant\", // all other Chinese locales map to Traditional Chinese\n};\n\n/**\n * Search for a matching translation from most specific to general\n */\nexport function findAvailableLanguage(language: string) {\n  // In most case, the language has the same format with our translation meta data\n  if (language in translationMetadata.translations) {\n    return language;\n  }\n\n  // Perform case-insenstive comparison since browser isn't required to\n  // report languages with specific cases.\n  const langLower = language.toLowerCase();\n\n  if (langLower in LOCALE_LOOKUP) {\n    return LOCALE_LOOKUP[langLower];\n  }\n\n  const translation = Object.keys(translationMetadata.translations).find(\n    (lang) => lang.toLowerCase() === langLower\n  );\n  if (translation) {\n    return translation;\n  }\n\n  if (language.includes(\"-\")) {\n    return findAvailableLanguage(language.split(\"-\")[0]);\n  }\n\n  return undefined;\n}\n\n/**\n * Get user selected locale data from backend\n */\nexport async function getUserLocale(\n  hass: HomeAssistant\n): Promise<Partial<FrontendLocaleData>> {\n  const result = await fetchTranslationPreferences(hass);\n  const language = result?.language;\n  const number_format = result?.number_format;\n  const time_format = result?.time_format;\n  const date_format = result?.date_format;\n  const time_zone = result?.time_zone;\n  const first_weekday = result?.first_weekday;\n  if (language) {\n    const availableLanguage = findAvailableLanguage(language);\n    if (availableLanguage) {\n      return {\n        language: availableLanguage,\n        number_format,\n        time_format,\n        date_format,\n        time_zone,\n        first_weekday,\n      };\n    }\n  }\n  return {\n    number_format,\n    time_format,\n    date_format,\n    time_zone,\n    first_weekday,\n  };\n}\n\n/**\n * Get browser specific language\n */\nexport function getLocalLanguage() {\n  let language = null;\n  if (STORAGE.selectedLanguage) {\n    try {\n      const stored = JSON.parse(STORAGE.selectedLanguage);\n      if (stored) {\n        language = findAvailableLanguage(stored);\n        if (language) {\n          return language;\n        }\n      }\n    } catch (err: any) {\n      // Ignore parsing error.\n    }\n  }\n  if (navigator.languages) {\n    for (const locale of navigator.languages) {\n      language = findAvailableLanguage(locale);\n      if (language) {\n        return language;\n      }\n    }\n  }\n  language = findAvailableLanguage(navigator.language);\n  if (language) {\n    return language;\n  }\n  // Final fallback\n  return \"en\";\n}\n\nexport async function getTranslation(\n  fragment: string | null,\n  language: string\n) {\n  const metadata = translationMetadata.translations[language];\n  if (!metadata?.hash) {\n    if (language !== \"en\") {\n      return getTranslation(fragment, \"en\");\n    }\n    throw new Error(\"Language en is not found in metadata\");\n  }\n\n  // nl-abcd.jon or logbook/nl-abcd.json\n  const fingerprint = `${fragment ? fragment + \"/\" : \"\"}${language}-${\n    metadata.hash\n  }.json`;\n\n  // Fetch translation from the server\n  if (!translations[fingerprint]) {\n    translations[fingerprint] = fetchTranslation(fingerprint)\n      .then((data) => ({ language, data }))\n      .catch((error) => {\n        delete translations[fingerprint];\n        if (language !== \"en\") {\n          // Couldn't load selected translation. Try a fall back to en before failing.\n          return getTranslation(fragment, \"en\");\n        }\n        return Promise.reject(error);\n      });\n  }\n  return translations[fingerprint];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}