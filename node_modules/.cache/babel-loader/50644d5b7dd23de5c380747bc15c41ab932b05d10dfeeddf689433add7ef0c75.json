{"ast":null,"code":"import IntlMessageFormat from \"intl-messageformat\";\nimport { polyfillLocaleData } from \"../../resources/locale-data-polyfill\";\n\n// Exclude some patterns from key type checking for now\n// These are intended to be removed as errors are fixed\n// Fixing component category will require tighter definition of types from backend and/or web socket\n\n// Tweaked from https://www.raygesualdo.com/posts/flattening-object-keys-with-typescript-types\n\n// Later, don't return string when HTML is passed, and don't allow undefined\n\n/**\n * Adapted from Polymer app-localize-behavior.\n *\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Optional dictionary of user defined formats, as explained here:\n * http://formatjs.io/guides/message-syntax/#custom-formats\n *\n * For example, a valid dictionary of formats would be:\n * this.formats = {\n *    number: { USD: { style: 'currency', currency: 'USD' } }\n * }\n */\n\nexport const computeLocalize = async (cache, language, resources, formats) => {\n  await import(\"../../resources/intl-polyfill\").then(() => polyfillLocaleData(language));\n\n  // Every time any of the parameters change, invalidate the strings cache.\n  cache._localizationCache = {};\n  return (key, ...args) => {\n    if (!key || !resources || !language || !resources[language]) {\n      return \"\";\n    }\n\n    // Cache the key/value pairs for the same language, so that we don't\n    // do extra work if we're just reusing strings across an application.\n    const translatedValue = resources[language][key];\n    if (!translatedValue) {\n      return \"\";\n    }\n    const messageKey = key + translatedValue;\n    let translatedMessage = cache._localizationCache[messageKey];\n    if (!translatedMessage) {\n      try {\n        translatedMessage = new IntlMessageFormat(translatedValue, language, formats);\n      } catch (err) {\n        return \"Translation error: \" + err.message;\n      }\n      cache._localizationCache[messageKey] = translatedMessage;\n    }\n    let argObject = {};\n    if (args.length === 1 && typeof args[0] === \"object\") {\n      argObject = args[0];\n    } else {\n      for (let i = 0; i < args.length; i += 2) {\n        // @ts-expect-error in some places the old format (key, value, key, value) is used\n        argObject[args[i]] = args[i + 1];\n      }\n    }\n    try {\n      return translatedMessage.format(argObject);\n    } catch (err) {\n      return \"Translation \" + err;\n    }\n  };\n};","map":{"version":3,"names":["IntlMessageFormat","polyfillLocaleData","computeLocalize","cache","language","resources","formats","then","_localizationCache","key","args","translatedValue","messageKey","translatedMessage","err","message","argObject","length","i","format"],"sources":["/workspaces/frontend/src/common/translations/localize.ts"],"sourcesContent":["import IntlMessageFormat from \"intl-messageformat\";\nimport type { HTMLTemplateResult } from \"lit\";\nimport { polyfillLocaleData } from \"../../resources/locale-data-polyfill\";\nimport { Resources, TranslationDict } from \"../../types\";\n\n// Exclude some patterns from key type checking for now\n// These are intended to be removed as errors are fixed\n// Fixing component category will require tighter definition of types from backend and/or web socket\nexport type LocalizeKeys =\n  | FlattenObjectKeys<Omit<TranslationDict, \"supervisor\">>\n  | `panel.${string}`\n  | `ui.card.alarm_control_panel.${string}`\n  | `ui.card.weather.attributes.${string}`\n  | `ui.card.weather.cardinal_direction.${string}`\n  | `ui.card.lawn_mower.actions.${string}`\n  | `ui.components.calendar.event.rrule.${string}`\n  | `ui.components.logbook.${string}`\n  | `ui.components.selectors.file.${string}`\n  | `ui.dialogs.entity_registry.editor.${string}`\n  | `ui.dialogs.more_info_control.lawn_mower.${string}`\n  | `ui.dialogs.more_info_control.vacuum.${string}`\n  | `ui.dialogs.quick-bar.commands.${string}`\n  | `ui.dialogs.unhealthy.reason.${string}`\n  | `ui.dialogs.unsupported.reason.${string}`\n  | `ui.panel.config.${string}.${\"caption\" | \"description\"}`\n  | `ui.panel.config.dashboard.${string}`\n  | `ui.panel.config.zha.${string}`\n  | `ui.panel.config.zwave_js.${string}`\n  | `ui.panel.lovelace.card.${string}`\n  | `ui.panel.lovelace.editor.${string}`\n  | `ui.panel.page-authorize.form.${string}`\n  | `component.${string}`;\n\n// Tweaked from https://www.raygesualdo.com/posts/flattening-object-keys-with-typescript-types\nexport type FlattenObjectKeys<\n  T extends Record<string, any>,\n  Key extends keyof T = keyof T,\n> = Key extends string\n  ? T[Key] extends Record<string, unknown>\n    ? `${Key}.${FlattenObjectKeys<T[Key]>}`\n    : `${Key}`\n  : never;\n\n// Later, don't return string when HTML is passed, and don't allow undefined\nexport type LocalizeFunc<Keys extends string = LocalizeKeys> = (\n  key: Keys,\n  values?: Record<\n    string,\n    string | number | HTMLTemplateResult | null | undefined\n  >\n) => string;\n\ninterface FormatType {\n  [format: string]: any;\n}\nexport interface FormatsType {\n  number: FormatType;\n  date: FormatType;\n  time: FormatType;\n}\n\n/**\n * Adapted from Polymer app-localize-behavior.\n *\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Optional dictionary of user defined formats, as explained here:\n * http://formatjs.io/guides/message-syntax/#custom-formats\n *\n * For example, a valid dictionary of formats would be:\n * this.formats = {\n *    number: { USD: { style: 'currency', currency: 'USD' } }\n * }\n */\n\nexport const computeLocalize = async <Keys extends string = LocalizeKeys>(\n  cache: any,\n  language: string,\n  resources: Resources,\n  formats?: FormatsType\n): Promise<LocalizeFunc<Keys>> => {\n  await import(\"../../resources/intl-polyfill\").then(() =>\n    polyfillLocaleData(language)\n  );\n\n  // Every time any of the parameters change, invalidate the strings cache.\n  cache._localizationCache = {};\n\n  return (key, ...args) => {\n    if (!key || !resources || !language || !resources[language]) {\n      return \"\";\n    }\n\n    // Cache the key/value pairs for the same language, so that we don't\n    // do extra work if we're just reusing strings across an application.\n    const translatedValue = resources[language][key];\n\n    if (!translatedValue) {\n      return \"\";\n    }\n\n    const messageKey = key + translatedValue;\n    let translatedMessage = cache._localizationCache[messageKey] as\n      | IntlMessageFormat\n      | undefined;\n\n    if (!translatedMessage) {\n      try {\n        translatedMessage = new IntlMessageFormat(\n          translatedValue,\n          language,\n          formats\n        );\n      } catch (err: any) {\n        return \"Translation error: \" + err.message;\n      }\n      cache._localizationCache[messageKey] = translatedMessage;\n    }\n\n    let argObject = {};\n    if (args.length === 1 && typeof args[0] === \"object\") {\n      argObject = args[0];\n    } else {\n      for (let i = 0; i < args.length; i += 2) {\n        // @ts-expect-error in some places the old format (key, value, key, value) is used\n        argObject[args[i]] = args[i + 1];\n      }\n    }\n\n    try {\n      return translatedMessage.format<string>(argObject) as string;\n    } catch (err: any) {\n      return \"Translation \" + err;\n    }\n  };\n};\n"],"mappings":"AAAA,OAAOA,iBAAiB,MAAM,oBAAoB;AAElD,SAASC,kBAAkB,QAAQ,sCAAsC;;AAGzE;AACA;AACA;;AA0BA;;AAUA;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAC7BC,KAAU,EACVC,QAAgB,EAChBC,SAAoB,EACpBC,OAAqB,KACW;EAChC,MAAM,MAAM,CAAC,+BAA+B,CAAC,CAACC,IAAI,CAAC,MACjDN,kBAAkB,CAACG,QAAQ,CAC7B,CAAC;;EAED;EACAD,KAAK,CAACK,kBAAkB,GAAG,CAAC,CAAC;EAE7B,OAAO,CAACC,GAAG,EAAE,GAAGC,IAAI,KAAK;IACvB,IAAI,CAACD,GAAG,IAAI,CAACJ,SAAS,IAAI,CAACD,QAAQ,IAAI,CAACC,SAAS,CAACD,QAAQ,CAAC,EAAE;MAC3D,OAAO,EAAE;IACX;;IAEA;IACA;IACA,MAAMO,eAAe,GAAGN,SAAS,CAACD,QAAQ,CAAC,CAACK,GAAG,CAAC;IAEhD,IAAI,CAACE,eAAe,EAAE;MACpB,OAAO,EAAE;IACX;IAEA,MAAMC,UAAU,GAAGH,GAAG,GAAGE,eAAe;IACxC,IAAIE,iBAAiB,GAAGV,KAAK,CAACK,kBAAkB,CAACI,UAAU,CAE9C;IAEb,IAAI,CAACC,iBAAiB,EAAE;MACtB,IAAI;QACFA,iBAAiB,GAAG,IAAIb,iBAAiB,CACvCW,eAAe,EACfP,QAAQ,EACRE,OACF,CAAC;MACH,CAAC,CAAC,OAAOQ,GAAQ,EAAE;QACjB,OAAO,qBAAqB,GAAGA,GAAG,CAACC,OAAO;MAC5C;MACAZ,KAAK,CAACK,kBAAkB,CAACI,UAAU,CAAC,GAAGC,iBAAiB;IAC1D;IAEA,IAAIG,SAAS,GAAG,CAAC,CAAC;IAClB,IAAIN,IAAI,CAACO,MAAM,KAAK,CAAC,IAAI,OAAOP,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;MACpDM,SAAS,GAAGN,IAAI,CAAC,CAAC,CAAC;IACrB,CAAC,MAAM;MACL,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,IAAI,CAACO,MAAM,EAAEC,CAAC,IAAI,CAAC,EAAE;QACvC;QACAF,SAAS,CAACN,IAAI,CAACQ,CAAC,CAAC,CAAC,GAAGR,IAAI,CAACQ,CAAC,GAAG,CAAC,CAAC;MAClC;IACF;IAEA,IAAI;MACF,OAAOL,iBAAiB,CAACM,MAAM,CAASH,SAAS,CAAC;IACpD,CAAC,CAAC,OAAOF,GAAQ,EAAE;MACjB,OAAO,cAAc,GAAGA,GAAG;IAC7B;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}