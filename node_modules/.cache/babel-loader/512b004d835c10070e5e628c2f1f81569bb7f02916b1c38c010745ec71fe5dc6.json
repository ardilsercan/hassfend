{"ast":null,"code":"var _window;\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { RangeChangedEvent, VisibilityChangedEvent, UnpinnedEvent } from './events.js';\nimport { ScrollerController } from './ScrollerController.js';\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver = (_window = window) === null || _window === void 0 ? void 0 : _window.ResizeObserver;\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor) {\n  _ResizeObserver = Ctor;\n}\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    /**\n     * Layout initialization is async because we dynamically load\n     * the default layout if none is specified. This state is to track\n     * whether init is complete.\n     */\n    this._layoutInitialized = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || {};\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n  _initObservers() {\n    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n    this._hostElementRO = new _ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n    this._scrollerController = new ScrollerController(this, this._clippingAncestors[0]);\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    var _this$_scrollerContro, _this$_mutationObserv, _this$_hostElementRO, _this$_childrenRO;\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    (_this$_scrollerContro = this._scrollerController) === null || _this$_scrollerContro === void 0 || _this$_scrollerContro.detach(this);\n    this._scrollerController = null;\n    (_this$_mutationObserv = this._mutationObserver) === null || _this$_mutationObserv === void 0 || _this$_mutationObserv.disconnect();\n    this._mutationObserver = null;\n    (_this$_hostElementRO = this._hostElementRO) === null || _this$_hostElementRO === void 0 || _this$_hostElementRO.disconnect();\n    this._hostElementRO = null;\n    (_this$_childrenRO = this._childrenRO) === null || _this$_childrenRO === void 0 || _this$_childrenRO.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  async updateLayoutConfig(layoutConfig) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor = layoutConfig.type ||\n    // The new config is compatible with the current layout,\n    // so we update the config and return true to indicate\n    // a successful update\n    DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n  async _initLayout(layoutConfig) {\n    let config;\n    let Ctor;\n    if (typeof layoutConfig.type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = layoutConfig.type;\n      // ...while the rest of the specifier is our layout config\n      const copy = {\n        ...layoutConfig\n      };\n      delete copy.type;\n      config = copy;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig;\n    }\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js')).FlowLayout;\n    }\n    this._layout = new Ctor(message => this._handleLayoutMessage(message), config);\n    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n  async _updateDOM(state) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    // Only update the layout and trigger a re-render if we have:\n    //   a) A layout\n    //   b) A scrollerController, which means we're connected\n    if (this._layout && this._scrollerController) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      var _this$_layout;\n      // This is a user-initiated scroll, so we unpin the layout\n      (_this$_layout = this._layout) === null || _this$_layout === void 0 || _this$_layout.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  _handleLayoutMessage(message) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _this$_scrollerContro2;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_this$_scrollerContro2 = this._scrollerController) === null || _this$_scrollerContro2 === void 0 ? void 0 : _this$_scrollerContro2.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = bottom - top;\n      const width = right - left;\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _this$_items;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_this$_items = this._items) === null || _this$_items === void 0 ? void 0 : _this$_items[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && pos !== null && pos !== void 0 && pos.has(index)) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    var _this$_layout2;\n    // Only measure if the layout requires it\n    if ((_this$_layout2 = this._layout) !== null && _this$_layout2 !== void 0 && _this$_layout2.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter(a => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}","map":{"version":3,"names":["RangeChangedEvent","VisibilityChangedEvent","UnpinnedEvent","ScrollerController","_ResizeObserver","_window","window","ResizeObserver","provideResizeObserver","Ctor","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","constructor","config","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","bind","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","_layoutInitialized","Error","hostElement","_init","items","Array","isArray","_schedule","_updateLayout","scroller","_initHostElement","layoutConfig","layout","_initLayout","_initObservers","MutationObserver","_finishDOMUpdate","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","connected","includeSelf","getClippingAncestors","_observeAndListen","observe","childList","push","addEventListener","forEach","ancestor","element","_children","child","target","disconnected","_this$_scrollerContro","_this$_mutationObserv","_this$_hostElementRO","_this$_childrenRO","removeEventListener","detach","disconnect","_rejectLayoutCompletePromise","style","display","position","contain","overflow","minHeight","_getSizer","sizer","querySelector","document","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","textContent","updateLayoutConfig","type","copy","undefined","FlowLayout","message","_handleLayoutMessage","measureChildren","updateItemSizes","listenForChildLoadEvents","startBenchmarking","performance","now","stopBenchmarking","timeElapsed","entries","getEntriesByName","virtualizationTime","filter","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","has","call","clear","width","height","getBoundingClientRect","getMargins","method","add","Promise","resolve","delete","_updateDOM","state","scrollSize","_adjustRange","range","childPositions","scrollError","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","correctingScrollError","_this$_layout","unpin","handleEvent","event","currentTarget","includes","firstVisible","lastVisible","dispatchEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","_this$_scrollerContro2","scrollingElement","top","left","bottom","right","hostElementBounds","innerHeight","innerWidth","ancestorBounds","map","unshift","bounds","Math","max","min","scrollingElementBounds","offsetWithinScroller","totalScrollSize","scrollWidth","scrollHeight","scrollTop","scrollLeft","viewportSize","viewportScroll","size","h","v","transform","minWidth","pos","xOffset","yOffset","index","boxSizing","first","last","correctScrollError","_this$_items","Infinity","scrollIntoView","options","_scrollElementIntoView","behavior","coordinates","getScrollIntoViewCoordinates","managedScrollTo","pin","layoutComplete","reject","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","requestAnimationFrame","_resolveLayoutCompletePromise","changes","_this$_layout2","change","set","contentRect","el","getComputedStyle","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","value","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","foundFixed","a"],"sources":["src/Virtualizer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined = window?.ResizeObserver;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n\n  _updateLayout() {\n    // Only update the layout and trigger a re-render if we have:\n    //   a) A layout\n    //   b) A scrollerController, which means we're connected\n    if (this._layout && this._scrollerController) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = bottom - top;\n      const width = right - left;\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}