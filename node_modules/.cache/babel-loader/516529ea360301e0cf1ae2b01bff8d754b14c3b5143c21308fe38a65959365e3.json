{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _templateObject;\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\n/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, isServer, LitElement } from 'lit';\nimport { queryAssignedElements } from 'lit/decorators.js';\nimport { Chip } from './chip.js';\n/**\n * A chip set component.\n */\nexport var ChipSet = /*#__PURE__*/function (_LitElement) {\n  _inherits(ChipSet, _LitElement);\n  function ChipSet() {\n    var _this;\n    _classCallCheck(this, ChipSet);\n    _this = _callSuper(this, ChipSet);\n    _this.internals =\n    // Cast needed for closure\n    _this.attachInternals();\n    if (!isServer) {\n      _this.addEventListener('focusin', _this.updateTabIndices.bind(_assertThisInitialized(_this)));\n      _this.addEventListener('update-focus', _this.updateTabIndices.bind(_assertThisInitialized(_this)));\n      _this.addEventListener('keydown', _this.handleKeyDown.bind(_assertThisInitialized(_this)));\n      _this.internals.role = 'toolbar';\n    }\n    return _this;\n  }\n  _createClass(ChipSet, [{\n    key: \"chips\",\n    get: function get() {\n      return this.childElements.filter(function (child) {\n        return child instanceof Chip;\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"<slot @slotchange=\", \"></slot>\"])), this.updateTabIndices);\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(event) {\n      var isLeft = event.key === 'ArrowLeft';\n      var isRight = event.key === 'ArrowRight';\n      var isHome = event.key === 'Home';\n      var isEnd = event.key === 'End';\n      // Ignore non-navigation keys\n      if (!isLeft && !isRight && !isHome && !isEnd) {\n        return;\n      }\n      var chips = this.chips;\n      // Don't try to select another chip if there aren't any.\n      if (chips.length < 2) {\n        return;\n      }\n      // Prevent default interactions, such as scrolling.\n      event.preventDefault();\n      if (isHome || isEnd) {\n        var index = isHome ? 0 : chips.length - 1;\n        chips[index].focus({\n          trailing: isEnd\n        });\n        this.updateTabIndices();\n        return;\n      }\n      // Check if moving forwards or backwards\n      var isRtl = getComputedStyle(this).direction === 'rtl';\n      var forwards = isRtl ? isLeft : isRight;\n      var focusedChip = chips.find(function (chip) {\n        return chip.matches(':focus-within');\n      });\n      if (!focusedChip) {\n        // If there is not already a chip focused, select the first or last chip\n        // based on the direction we're traveling.\n        var nextChip = forwards ? chips[0] : chips[chips.length - 1];\n        nextChip.focus({\n          trailing: !forwards\n        });\n        this.updateTabIndices();\n        return;\n      }\n      var currentIndex = chips.indexOf(focusedChip);\n      var nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;\n      // Search for the next sibling that is not disabled to select.\n      // If we return to the host index, there is nothing to select.\n      while (nextIndex !== currentIndex) {\n        if (nextIndex >= chips.length) {\n          // Return to start if moving past the last item.\n          nextIndex = 0;\n        } else if (nextIndex < 0) {\n          // Go to end if moving before the first item.\n          nextIndex = chips.length - 1;\n        }\n        // Check if the next sibling is disabled. If so,\n        // move the index and continue searching.\n        //\n        // Some toolbar items may be focusable when disabled for increased\n        // visibility.\n        var _nextChip = chips[nextIndex];\n        if (_nextChip.disabled && !_nextChip.alwaysFocusable) {\n          if (forwards) {\n            nextIndex++;\n          } else {\n            nextIndex--;\n          }\n          continue;\n        }\n        _nextChip.focus({\n          trailing: !forwards\n        });\n        this.updateTabIndices();\n        break;\n      }\n    }\n  }, {\n    key: \"updateTabIndices\",\n    value: function updateTabIndices() {\n      // The chip that should be focusable is either the chip that currently has\n      // focus or the first chip that can be focused.\n      var chips = this.chips;\n      var chipToFocus;\n      var _iterator = _createForOfIteratorHelper(chips),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chip = _step.value;\n          var isChipFocusable = chip.alwaysFocusable || !chip.disabled;\n          var chipIsFocused = chip.matches(':focus-within');\n          if (chipIsFocused && isChipFocusable) {\n            // Found the first chip that is actively focused. This overrides the\n            // first focusable chip found.\n            chipToFocus = chip;\n            continue;\n          }\n          if (isChipFocusable && !chipToFocus) {\n            chipToFocus = chip;\n          }\n          // Disable non-focused chips. If we disable all of them, we'll grant focus\n          // to the first focusable child that was found.\n          chip.tabIndex = -1;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (chipToFocus) {\n        chipToFocus.tabIndex = 0;\n      }\n    }\n  }]);\n  return ChipSet;\n}(LitElement);\n__decorate([queryAssignedElements()], ChipSet.prototype, \"childElements\", void 0);","map":{"version":3,"names":["html","isServer","LitElement","queryAssignedElements","Chip","ChipSet","_LitElement","_inherits","_this","_classCallCheck","_callSuper","internals","attachInternals","addEventListener","updateTabIndices","bind","_assertThisInitialized","handleKeyDown","role","_createClass","key","get","childElements","filter","child","value","render","_templateObject","_taggedTemplateLiteral","event","isLeft","isRight","isHome","isEnd","chips","length","preventDefault","index","focus","trailing","isRtl","getComputedStyle","direction","forwards","focusedChip","find","chip","matches","nextChip","currentIndex","indexOf","nextIndex","disabled","alwaysFocusable","chipToFocus","_iterator","_createForOfIteratorHelper","_step","s","n","done","isChipFocusable","chipIsFocused","tabIndex","err","e","f","__decorate"],"sources":["chip-set.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, isServer, LitElement} from 'lit';\nimport {queryAssignedElements} from 'lit/decorators.js';\n\nimport {Chip} from './chip.js';\n\n/**\n * A chip set component.\n */\nexport class ChipSet extends LitElement {\n  get chips() {\n    return this.childElements.filter(\n      (child): child is Chip => child instanceof Chip,\n    );\n  }\n\n  @queryAssignedElements() private readonly childElements!: HTMLElement[];\n  private readonly internals =\n    // Cast needed for closure\n    (this as HTMLElement).attachInternals();\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('focusin', this.updateTabIndices.bind(this));\n      this.addEventListener('update-focus', this.updateTabIndices.bind(this));\n      this.addEventListener('keydown', this.handleKeyDown.bind(this));\n      this.internals.role = 'toolbar';\n    }\n  }\n\n  protected override render() {\n    return html`<slot @slotchange=${this.updateTabIndices}></slot>`;\n  }\n\n  private handleKeyDown(event: KeyboardEvent) {\n    const isLeft = event.key === 'ArrowLeft';\n    const isRight = event.key === 'ArrowRight';\n    const isHome = event.key === 'Home';\n    const isEnd = event.key === 'End';\n    // Ignore non-navigation keys\n    if (!isLeft && !isRight && !isHome && !isEnd) {\n      return;\n    }\n\n    const {chips} = this as {chips: MaybeMultiActionChip[]};\n    // Don't try to select another chip if there aren't any.\n    if (chips.length < 2) {\n      return;\n    }\n\n    // Prevent default interactions, such as scrolling.\n    event.preventDefault();\n\n    if (isHome || isEnd) {\n      const index = isHome ? 0 : chips.length - 1;\n      chips[index].focus({trailing: isEnd});\n      this.updateTabIndices();\n      return;\n    }\n\n    // Check if moving forwards or backwards\n    const isRtl = getComputedStyle(this).direction === 'rtl';\n    const forwards = isRtl ? isLeft : isRight;\n    const focusedChip = chips.find((chip) => chip.matches(':focus-within'));\n    if (!focusedChip) {\n      // If there is not already a chip focused, select the first or last chip\n      // based on the direction we're traveling.\n      const nextChip = forwards ? chips[0] : chips[chips.length - 1];\n      nextChip.focus({trailing: !forwards});\n      this.updateTabIndices();\n      return;\n    }\n\n    const currentIndex = chips.indexOf(focusedChip);\n    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;\n    // Search for the next sibling that is not disabled to select.\n    // If we return to the host index, there is nothing to select.\n    while (nextIndex !== currentIndex) {\n      if (nextIndex >= chips.length) {\n        // Return to start if moving past the last item.\n        nextIndex = 0;\n      } else if (nextIndex < 0) {\n        // Go to end if moving before the first item.\n        nextIndex = chips.length - 1;\n      }\n\n      // Check if the next sibling is disabled. If so,\n      // move the index and continue searching.\n      //\n      // Some toolbar items may be focusable when disabled for increased\n      // visibility.\n      const nextChip = chips[nextIndex];\n      if (nextChip.disabled && !nextChip.alwaysFocusable) {\n        if (forwards) {\n          nextIndex++;\n        } else {\n          nextIndex--;\n        }\n\n        continue;\n      }\n\n      nextChip.focus({trailing: !forwards});\n      this.updateTabIndices();\n      break;\n    }\n  }\n\n  private updateTabIndices() {\n    // The chip that should be focusable is either the chip that currently has\n    // focus or the first chip that can be focused.\n    const {chips} = this;\n    let chipToFocus: Chip | undefined;\n    for (const chip of chips) {\n      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;\n      const chipIsFocused = chip.matches(':focus-within');\n      if (chipIsFocused && isChipFocusable) {\n        // Found the first chip that is actively focused. This overrides the\n        // first focusable chip found.\n        chipToFocus = chip;\n        continue;\n      }\n\n      if (isChipFocusable && !chipToFocus) {\n        chipToFocus = chip;\n      }\n\n      // Disable non-focused chips. If we disable all of them, we'll grant focus\n      // to the first focusable child that was found.\n      chip.tabIndex = -1;\n    }\n\n    if (chipToFocus) {\n      chipToFocus.tabIndex = 0;\n    }\n  }\n}\n\ninterface MaybeMultiActionChip extends Chip {\n  focus(options?: FocusOptions & {trailing?: boolean}): void;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}