{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Activates the first non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     first item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n */\nexport function activateFirstItem(items, isActivatable = isItemNotDisabled) {\n  // NOTE: These selector functions are static and not on the instance such\n  // that multiple operations can be chained and we do not have to re-query\n  // the DOM\n  const firstItem = getFirstActivatableItem(items, isActivatable);\n  if (firstItem) {\n    firstItem.tabIndex = 0;\n    firstItem.focus();\n  }\n  return firstItem;\n}\n/**\n * Activates the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     last item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @nocollapse\n */\nexport function activateLastItem(items, isActivatable = isItemNotDisabled) {\n  const lastItem = getLastActivatableItem(items, isActivatable);\n  if (lastItem) {\n    lastItem.tabIndex = 0;\n    lastItem.focus();\n  }\n  return lastItem;\n}\n/**\n * Deactivates the currently active item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to deactivate the\n *     active item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the deleselcted activated item including the item and\n *     the index of the item or `null` if none are deactivated.\n * @nocollapse\n */\nexport function deactivateActiveItem(items, isActivatable = isItemNotDisabled) {\n  const activeItem = getActiveItem(items, isActivatable);\n  if (activeItem) {\n    activeItem.item.tabIndex = -1;\n  }\n  return activeItem;\n}\n/**\n * Retrieves the first activated item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the first activated item including the item and the\n *     index of the item or `null` if none are activated.\n * @nocollapse\n */\nexport function getActiveItem(items, isActivatable = isItemNotDisabled) {\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (item.tabIndex === 0 && isActivatable(item)) {\n      return {\n        item,\n        index: i\n      };\n    }\n  }\n  return null;\n}\n/**\n * Retrieves the first non-disabled item of a given array of items. This\n * the first item that is not disabled.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The first activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getFirstActivatableItem(items, isActivatable = isItemNotDisabled) {\n  for (const item of items) {\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n  return null;\n}\n/**\n * Retrieves the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The last activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getLastActivatableItem(items, isActivatable = isItemNotDisabled) {\n  for (let i = items.length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n  return null;\n}\n/**\n * Retrieves the next non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The next activatable item or `null` if none are activatable.\n */\nexport function getNextItem(items, index, isActivatable = isItemNotDisabled) {\n  for (let i = 1; i < items.length; i++) {\n    const nextIndex = (i + index) % items.length;\n    const item = items[nextIndex];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n  return items[index] ? items[index] : null;\n}\n/**\n * Retrieves the previous non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The previous activatable item or `null` if none are activatable.\n */\nexport function getPrevItem(items, index, isActivatable = isItemNotDisabled) {\n  for (let i = 1; i < items.length; i++) {\n    const prevIndex = (index - i + items.length) % items.length;\n    const item = items[prevIndex];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n  return items[index] ? items[index] : null;\n}\n/**\n * Activates the next item and focuses it. If nothing is currently activated,\n * activates the first item.\n */\nexport function activateNextItem(items, activeItemRecord, isActivatable = isItemNotDisabled) {\n  if (activeItemRecord) {\n    const next = getNextItem(items, activeItemRecord.index, isActivatable);\n    if (next) {\n      next.tabIndex = 0;\n      next.focus();\n    }\n    return next;\n  } else {\n    return activateFirstItem(items, isActivatable);\n  }\n}\n/**\n * Activates the previous item and focuses it. If nothing is currently\n * activated, activates the last item.\n */\nexport function activatePreviousItem(items, activeItemRecord, isActivatable = isItemNotDisabled) {\n  if (activeItemRecord) {\n    const prev = getPrevItem(items, activeItemRecord.index, isActivatable);\n    if (prev) {\n      prev.tabIndex = 0;\n      prev.focus();\n    }\n    return prev;\n  } else {\n    return activateLastItem(items, isActivatable);\n  }\n}\n/**\n * Creates an event that requests the parent md-list to deactivate all other\n * items.\n */\nexport function createDeactivateItemsEvent() {\n  return new Event('deactivate-items', {\n    bubbles: true,\n    composed: true\n  });\n}\n/**\n * Creates an event that requests the menu to set `tabindex=0` on the item and\n * focus it. We use this pattern because List keeps track of what element is\n * active in the List by maintaining tabindex. We do not want list items\n * to set tabindex on themselves or focus themselves so that we can organize all\n * that logic in the parent List and Menus, and list item stays as dumb as\n * possible.\n */\nexport function createRequestActivationEvent() {\n  return new Event('request-activation', {\n    bubbles: true,\n    composed: true\n  });\n}\n/**\n * The default `isActivatable` function, which checks if an item is not\n * disabled.\n *\n * @param item The item to check.\n * @return true if `item.disabled` is `false.\n */\nfunction isItemNotDisabled(item) {\n  return !item.disabled;\n}","map":{"version":3,"names":["activateFirstItem","items","isActivatable","isItemNotDisabled","firstItem","getFirstActivatableItem","tabIndex","focus","activateLastItem","lastItem","getLastActivatableItem","deactivateActiveItem","activeItem","getActiveItem","item","i","length","index","getNextItem","nextIndex","getPrevItem","prevIndex","activateNextItem","activeItemRecord","next","activatePreviousItem","prev","createDeactivateItemsEvent","Event","bubbles","composed","createRequestActivationEvent","disabled"],"sources":["list-navigation-helpers.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport interface ListItem extends HTMLElement {\n  disabled: boolean;\n}\n\n/**\n * A record that describes a list item in a list with metadata such a reference\n * to the item and its index in the list.\n */\nexport interface ItemRecord<Item extends ListItem> {\n  item: Item;\n  index: number;\n}\n\n/**\n * Activates the first non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     first item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n */\nexport function activateFirstItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  // NOTE: These selector functions are static and not on the instance such\n  // that multiple operations can be chained and we do not have to re-query\n  // the DOM\n  const firstItem = getFirstActivatableItem(items, isActivatable);\n  if (firstItem) {\n    firstItem.tabIndex = 0;\n    firstItem.focus();\n  }\n  return firstItem;\n}\n\n/**\n * Activates the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to activate the\n *     last item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @nocollapse\n */\nexport function activateLastItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  const lastItem = getLastActivatableItem(items, isActivatable);\n  if (lastItem) {\n    lastItem.tabIndex = 0;\n    lastItem.focus();\n  }\n  return lastItem;\n}\n\n/**\n * Deactivates the currently active item of a given array of items.\n *\n * @param items {Array<ListItem>} The items from which to deactivate the\n *     active item.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the deleselcted activated item including the item and\n *     the index of the item or `null` if none are deactivated.\n * @nocollapse\n */\nexport function deactivateActiveItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  const activeItem = getActiveItem(items, isActivatable);\n  if (activeItem) {\n    activeItem.item.tabIndex = -1;\n  }\n  return activeItem;\n}\n\n/**\n * Retrieves the first activated item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return A record of the first activated item including the item and the\n *     index of the item or `null` if none are activated.\n * @nocollapse\n */\nexport function getActiveItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    if (item.tabIndex === 0 && isActivatable(item)) {\n      return {\n        item,\n        index: i,\n      } as ItemRecord<Item>;\n    }\n  }\n  return null;\n}\n\n/**\n * Retrieves the first non-disabled item of a given array of items. This\n * the first item that is not disabled.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The first activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getFirstActivatableItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  for (const item of items) {\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Retrieves the last non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The last activatable item or `null` if none are activatable.\n * @nocollapse\n */\nexport function getLastActivatableItem<Item extends ListItem>(\n  items: Item[],\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  for (let i = items.length - 1; i >= 0; i--) {\n    const item = items[i];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Retrieves the next non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The next activatable item or `null` if none are activatable.\n */\nexport function getNextItem<Item extends ListItem>(\n  items: Item[],\n  index: number,\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  for (let i = 1; i < items.length; i++) {\n    const nextIndex = (i + index) % items.length;\n    const item = items[nextIndex];\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return items[index] ? items[index] : null;\n}\n\n/**\n * Retrieves the previous non-disabled item of a given array of items.\n *\n * @param items {Array<ListItem>} The items to search.\n * @param index {{index: number}} The index to search from.\n * @param isActivatable Function to determine if an item can be  activated.\n *     Defaults to non-disabled items.\n * @return The previous activatable item or `null` if none are activatable.\n */\nexport function getPrevItem<Item extends ListItem>(\n  items: Item[],\n  index: number,\n  isActivatable = isItemNotDisabled<Item>,\n) {\n  for (let i = 1; i < items.length; i++) {\n    const prevIndex = (index - i + items.length) % items.length;\n    const item = items[prevIndex];\n\n    if (isActivatable(item)) {\n      return item;\n    }\n  }\n\n  return items[index] ? items[index] : null;\n}\n\n/**\n * Activates the next item and focuses it. If nothing is currently activated,\n * activates the first item.\n */\nexport function activateNextItem<Item extends ListItem>(\n  items: Item[],\n  activeItemRecord: null | ItemRecord<Item>,\n  isActivatable = isItemNotDisabled<Item>,\n): Item | null {\n  if (activeItemRecord) {\n    const next = getNextItem(items, activeItemRecord.index, isActivatable);\n\n    if (next) {\n      next.tabIndex = 0;\n      next.focus();\n    }\n\n    return next;\n  } else {\n    return activateFirstItem(items, isActivatable);\n  }\n}\n\n/**\n * Activates the previous item and focuses it. If nothing is currently\n * activated, activates the last item.\n */\nexport function activatePreviousItem<Item extends ListItem>(\n  items: Item[],\n  activeItemRecord: null | ItemRecord<Item>,\n  isActivatable = isItemNotDisabled<Item>,\n): Item | null {\n  if (activeItemRecord) {\n    const prev = getPrevItem(items, activeItemRecord.index, isActivatable);\n    if (prev) {\n      prev.tabIndex = 0;\n      prev.focus();\n    }\n    return prev;\n  } else {\n    return activateLastItem(items, isActivatable);\n  }\n}\n\n/**\n * Creates an event that requests the parent md-list to deactivate all other\n * items.\n */\nexport function createDeactivateItemsEvent() {\n  return new Event('deactivate-items', {bubbles: true, composed: true});\n}\n\n/**\n * The type of the event that requests the parent md-list to deactivate all\n * other items.\n */\nexport type DeactivateItemsEvent = ReturnType<\n  typeof createDeactivateItemsEvent\n>;\n\n/**\n * Creates an event that requests the menu to set `tabindex=0` on the item and\n * focus it. We use this pattern because List keeps track of what element is\n * active in the List by maintaining tabindex. We do not want list items\n * to set tabindex on themselves or focus themselves so that we can organize all\n * that logic in the parent List and Menus, and list item stays as dumb as\n * possible.\n */\nexport function createRequestActivationEvent() {\n  return new Event('request-activation', {bubbles: true, composed: true});\n}\n\n/**\n * The type of the event that requests the list activates and focuses the item.\n */\nexport type RequestActivationEvent = ReturnType<\n  typeof createRequestActivationEvent\n>;\n\n/**\n * The default `isActivatable` function, which checks if an item is not\n * disabled.\n *\n * @param item The item to check.\n * @return true if `item.disabled` is `false.\n */\nfunction isItemNotDisabled<Item extends ListItem>(item: Item) {\n  return !item.disabled;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}