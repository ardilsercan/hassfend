{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { TemplateInstanceBase, templatize, modelForElement as _modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { suppressTemplateNotifications } from '../utils/settings.js';\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\nvar domRepeatBase = OptionalMutableData(PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\nexport var DomRepeat = /*#__PURE__*/function (_domRepeatBase) {\n  _inherits(DomRepeat, _domRepeatBase);\n  function DomRepeat() {\n    var _this;\n    _classCallCheck(this, DomRepeat);\n    _this = _callSuper(this, DomRepeat);\n    _this.__instances = [];\n    _this.__renderDebouncer = null;\n    _this.__itemsIdxToInstIdx = {};\n    _this.__chunkCount = null;\n    _this.__renderStartTime = null;\n    _this.__itemsArrayChanged = false;\n    _this.__shouldMeasureChunk = false;\n    _this.__shouldContinueChunking = false;\n    _this.__chunkingId = 0;\n    _this.__sortFn = null;\n    _this.__filterFn = null;\n    _this.__observePaths = null;\n    /** @type {?function(new:TemplateInstanceBase, Object=)} */\n    _this.__ctor = null;\n    _this.__isDetached = true;\n    _this.template = null;\n    /** @type {TemplateInfo} */\n    _this._templateInfo;\n    return _this;\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  _createClass(DomRepeat, [{\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(DomRepeat.prototype), \"disconnectedCallback\", this).call(this);\n      this.__isDetached = true;\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__detachInstance(i);\n      }\n      // Stop chunking if one was in progress\n      if (this.__chunkingId) {\n        cancelAnimationFrame(this.__chunkingId);\n      }\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(DomRepeat.prototype), \"connectedCallback\", this).call(this);\n      if (!hideElementsGlobally()) {\n        this.style.display = 'none';\n      }\n      // only perform attachment if the element was previously detached.\n      if (this.__isDetached) {\n        this.__isDetached = false;\n        var wrappedParent = wrap(wrap(this).parentNode);\n        for (var i = 0; i < this.__instances.length; i++) {\n          this.__attachInstance(i, wrappedParent);\n        }\n        // Restart chunking if one was in progress when disconnected\n        if (this.__chunkingId) {\n          this.__render();\n        }\n      }\n    }\n  }, {\n    key: \"__ensureTemplatized\",\n    value: function __ensureTemplatized() {\n      var _this2 = this;\n      // Templatizing (generating the instance constructor) needs to wait\n      // until ready, since won't have its template content handed back to\n      // it until then\n      if (!this.__ctor) {\n        // When `removeNestedTemplates` is true, the \"template\" is the element\n        // itself, which has been given a `_templateInfo` property\n        var thisAsTemplate = /** @type {!HTMLTemplateElement} */\n        /** @type {!HTMLElement} */this;\n        var template = this.template = thisAsTemplate._templateInfo ? thisAsTemplate : ( /** @type {!HTMLTemplateElement} */this.querySelector('template'));\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          var observer = new MutationObserver(function () {\n            if (_this2.querySelector('template')) {\n              observer.disconnect();\n              _this2.__render();\n            } else {\n              throw new Error('dom-repeat requires a <template> child');\n            }\n          });\n          observer.observe(this, {\n            childList: true\n          });\n          return false;\n        }\n        // Template instance props that should be excluded from forwarding\n        var instanceProps = {};\n        instanceProps[this.as] = true;\n        instanceProps[this.indexAs] = true;\n        instanceProps[this.itemsIndexAs] = true;\n        this.__ctor = templatize(template, this, {\n          mutableData: this.mutableData,\n          parentModel: true,\n          instanceProps: instanceProps,\n          /**\n           * @this {DomRepeat}\n           * @param {string} prop Property to set\n           * @param {*} value Value to set property to\n           */\n          forwardHostProp: function forwardHostProp(prop, value) {\n            var i$ = this.__instances;\n            for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\n              inst.forwardHostProp(prop, value);\n            }\n          },\n          /**\n           * @this {DomRepeat}\n           * @param {Object} inst Instance to notify\n           * @param {string} prop Property to notify\n           * @param {*} value Value to notify\n           */\n          notifyInstanceProp: function notifyInstanceProp(inst, prop, value) {\n            if (matches(this.as, prop)) {\n              var idx = inst[this.itemsIndexAs];\n              if (prop == this.as) {\n                this.items[idx] = value;\n              }\n              var path = translate(this.as, \"\".concat(JSCompiler_renameProperty('items', this), \".\").concat(idx), prop);\n              this.notifyPath(path, value);\n            }\n          }\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"__getMethodHost\",\n    value: function __getMethodHost() {\n      // Technically this should be the owner of the outermost template.\n      // In shadow dom, this is always getRootNode().host, but we can\n      // approximate this via cooperation with our dataHost always setting\n      // `_methodHost` as long as there were bindings (or id's) on this\n      // instance causing it to get a dataHost.\n      return this.__dataHost._methodHost || this.__dataHost;\n    }\n  }, {\n    key: \"__functionFromPropertyValue\",\n    value: function __functionFromPropertyValue(functionOrMethodName) {\n      if (typeof functionOrMethodName === 'string') {\n        var methodName = functionOrMethodName;\n        var obj = this.__getMethodHost();\n        return function () {\n          return obj[methodName].apply(obj, arguments);\n        };\n      }\n      return functionOrMethodName;\n    }\n  }, {\n    key: \"__sortChanged\",\n    value: function __sortChanged(sort) {\n      this.__sortFn = this.__functionFromPropertyValue(sort);\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__filterChanged\",\n    value: function __filterChanged(filter) {\n      this.__filterFn = this.__functionFromPropertyValue(filter);\n      if (this.items) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__computeFrameTime\",\n    value: function __computeFrameTime(rate) {\n      return Math.ceil(1000 / rate);\n    }\n  }, {\n    key: \"__observeChanged\",\n    value: function __observeChanged() {\n      this.__observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n    }\n  }, {\n    key: \"__handleObservedPaths\",\n    value: function __handleObservedPaths(path) {\n      // Handle cases where path changes should cause a re-sort/filter\n      if (this.__sortFn || this.__filterFn) {\n        if (!path) {\n          // Always re-render if the item itself changed\n          this.__debounceRender(this.__render, this.delay);\n        } else if (this.__observePaths) {\n          // Otherwise, re-render if the path changed matches an observed path\n          var paths = this.__observePaths;\n          for (var i = 0; i < paths.length; i++) {\n            if (path.indexOf(paths[i]) === 0) {\n              this.__debounceRender(this.__render, this.delay);\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"__itemsChanged\",\n    value: function __itemsChanged(change) {\n      if (this.items && !Array.isArray(this.items)) {\n        console.warn('dom-repeat expected array for `items`, found', this.items);\n      }\n      // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n      // path to that instance synchronously (returns false for non-item paths)\n      if (!this.__handleItemPath(change.path, change.value)) {\n        // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n        // so queue a render.  Restart chunking when the items changed (for\n        // backward compatibility), unless `reuseChunkedInstances` option is set\n        if (change.path === 'items') {\n          this.__itemsArrayChanged = true;\n        }\n        this.__debounceRender(this.__render);\n      }\n    }\n\n    /**\n     * @param {function(this:DomRepeat)} fn Function to debounce.\n     * @param {number=} delay Delay in ms to debounce by.\n     */\n  }, {\n    key: \"__debounceRender\",\n    value: function __debounceRender(fn) {\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, delay > 0 ? timeOut.after(delay) : microTask, fn.bind(this));\n      enqueueDebouncer(this.__renderDebouncer);\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     * @return {void}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Queue this repeater, then flush all in order\n      this.__debounceRender(this.__render);\n      flush();\n    }\n  }, {\n    key: \"__render\",\n    value: function __render() {\n      var _this3 = this;\n      if (!this.__ensureTemplatized()) {\n        // No template found yet\n        return;\n      }\n      var items = this.items || [];\n      // Sort and filter the items into a mapping array from instance->item\n      var isntIdxToItemsIdx = this.__sortAndFilterItems(items);\n      // If we're chunking, increase the limit if there are new instances to\n      // create and schedule the next chunk\n      var limit = this.__calculateLimit(isntIdxToItemsIdx.length);\n      // Create, update, and/or remove instances\n      this.__updateInstances(items, limit, isntIdxToItemsIdx);\n      // If we're chunking, schedule a rAF task to measure/continue chunking.     \n      // Do this before any notifying events (renderedItemCount & dom-change)\n      // since those could modify items and enqueue a new full render which will\n      // pre-empt this measurement.\n      if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {\n        cancelAnimationFrame(this.__chunkingId);\n        this.__chunkingId = requestAnimationFrame(function () {\n          _this3.__chunkingId = null;\n          _this3.__continueChunking();\n        });\n      }\n      // Set rendered item count\n      this._setRenderedItemCount(this.__instances.length);\n      // Notify users\n      if (!suppressTemplateNotifications || this.notifyDomChange) {\n        this.dispatchEvent(new CustomEvent('dom-change', {\n          bubbles: true,\n          composed: true\n        }));\n      }\n    }\n  }, {\n    key: \"__sortAndFilterItems\",\n    value: function __sortAndFilterItems(items) {\n      var _this4 = this;\n      // Generate array maping the instance index to the items array index\n      var isntIdxToItemsIdx = new Array(items.length);\n      for (var i = 0; i < items.length; i++) {\n        isntIdxToItemsIdx[i] = i;\n      }\n      // Apply user filter\n      if (this.__filterFn) {\n        isntIdxToItemsIdx = isntIdxToItemsIdx.filter(function (i, idx, array) {\n          return _this4.__filterFn(items[i], idx, array);\n        });\n      }\n      // Apply user sort\n      if (this.__sortFn) {\n        isntIdxToItemsIdx.sort(function (a, b) {\n          return _this4.__sortFn(items[a], items[b]);\n        });\n      }\n      return isntIdxToItemsIdx;\n    }\n  }, {\n    key: \"__calculateLimit\",\n    value: function __calculateLimit(filteredItemCount) {\n      var limit = filteredItemCount;\n      var currentCount = this.__instances.length;\n      // When chunking, we increase the limit from the currently rendered count\n      // by the chunk count that is re-calculated after each rAF (with special\n      // cases for resetting the limit to initialCount after changing items)\n      if (this.initialCount) {\n        var newCount;\n        if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {\n          // Limit next render to the initial count\n          limit = Math.min(filteredItemCount, this.initialCount);\n          // Subtract off any existing instances to determine the number of\n          // instances that will be created\n          newCount = Math.max(limit - currentCount, 0);\n          // Initialize the chunk size with how many items we're creating\n          this.__chunkCount = newCount || 1;\n        } else {\n          // The number of new instances that will be created is based on the\n          // existing instances, the new list size, and the chunk size\n          newCount = Math.min(Math.max(filteredItemCount - currentCount, 0), this.__chunkCount);\n          // Update the limit based on how many new items we're making, limited\n          // buy the total size of the list\n          limit = Math.min(currentCount + newCount, filteredItemCount);\n        }\n        // Record some state about chunking for use in `__continueChunking`\n        this.__shouldMeasureChunk = newCount === this.__chunkCount;\n        this.__shouldContinueChunking = limit < filteredItemCount;\n        this.__renderStartTime = performance.now();\n      }\n      this.__itemsArrayChanged = false;\n      return limit;\n    }\n  }, {\n    key: \"__continueChunking\",\n    value: function __continueChunking() {\n      // Simple auto chunkSize throttling algorithm based on feedback loop:\n      // measure actual time between frames and scale chunk count by ratio of\n      // target/actual frame time.  Only modify chunk size if our measurement\n      // reflects the cost of a creating a full chunk's worth of instances; this\n      // avoids scaling up the chunk size if we e.g. quickly re-rendered instances\n      // in place\n      if (this.__shouldMeasureChunk) {\n        var renderTime = performance.now() - this.__renderStartTime;\n        var ratio = this._targetFrameTime / renderTime;\n        this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n      }\n      // Enqueue a new render if we haven't reached the full size of the list\n      if (this.__shouldContinueChunking) {\n        this.__debounceRender(this.__render);\n      }\n    }\n  }, {\n    key: \"__updateInstances\",\n    value: function __updateInstances(items, limit, isntIdxToItemsIdx) {\n      // items->inst map kept for item path forwarding\n      var itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n      var instIdx;\n      // Generate instances and assign items\n      for (instIdx = 0; instIdx < limit; instIdx++) {\n        var inst = this.__instances[instIdx];\n        var itemIdx = isntIdxToItemsIdx[instIdx];\n        var item = items[itemIdx];\n        itemsIdxToInstIdx[itemIdx] = instIdx;\n        if (inst) {\n          inst._setPendingProperty(this.as, item);\n          inst._setPendingProperty(this.indexAs, instIdx);\n          inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n          inst._flushProperties();\n        } else {\n          this.__insertInstance(item, instIdx, itemIdx);\n        }\n      }\n      // Remove any extra instances from previous state\n      for (var i = this.__instances.length - 1; i >= instIdx; i--) {\n        this.__detachAndRemoveInstance(i);\n      }\n    }\n  }, {\n    key: \"__detachInstance\",\n    value: function __detachInstance(idx) {\n      var inst = this.__instances[idx];\n      var wrappedRoot = wrap(inst.root);\n      for (var i = 0; i < inst.children.length; i++) {\n        var el = inst.children[i];\n        wrappedRoot.appendChild(el);\n      }\n      return inst;\n    }\n  }, {\n    key: \"__attachInstance\",\n    value: function __attachInstance(idx, parent) {\n      var inst = this.__instances[idx];\n      // Note, this is pre-wrapped as an optimization\n      parent.insertBefore(inst.root, this);\n    }\n  }, {\n    key: \"__detachAndRemoveInstance\",\n    value: function __detachAndRemoveInstance(idx) {\n      this.__detachInstance(idx);\n      this.__instances.splice(idx, 1);\n    }\n  }, {\n    key: \"__stampInstance\",\n    value: function __stampInstance(item, instIdx, itemIdx) {\n      var model = {};\n      model[this.as] = item;\n      model[this.indexAs] = instIdx;\n      model[this.itemsIndexAs] = itemIdx;\n      return new this.__ctor(model);\n    }\n  }, {\n    key: \"__insertInstance\",\n    value: function __insertInstance(item, instIdx, itemIdx) {\n      var inst = this.__stampInstance(item, instIdx, itemIdx);\n      var beforeRow = this.__instances[instIdx + 1];\n      var beforeNode = beforeRow ? beforeRow.children[0] : this;\n      wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n      this.__instances[instIdx] = inst;\n      return inst;\n    }\n\n    // Implements extension point from Templatize mixin\n    /**\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     * @param {boolean} hidden Set to true to hide the children;\n     * set to false to show them.\n     * @return {void}\n     * @protected\n     */\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren(hidden) {\n      for (var i = 0; i < this.__instances.length; i++) {\n        this.__instances[i]._showHideChildren(hidden);\n      }\n    }\n\n    // Called as a side effect of a host items.<key>.<path> path change,\n    // responsible for notifying item.<path> changes to inst for key\n  }, {\n    key: \"__handleItemPath\",\n    value: function __handleItemPath(path, value) {\n      var itemsPath = path.slice(6); // 'items.'.length == 6\n      var dot = itemsPath.indexOf('.');\n      var itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n      // If path was index into array...\n      if (itemsIdx == parseInt(itemsIdx, 10)) {\n        var itemSubPath = dot < 0 ? '' : itemsPath.substring(dot + 1);\n        // If the path is observed, it will trigger a full refresh\n        this.__handleObservedPaths(itemSubPath);\n        // Note, even if a rull refresh is triggered, always do the path\n        // notification because unless mutableData is used for dom-repeat\n        // and all elements in the instance subtree, a full refresh may\n        // not trigger the proper update.\n        var instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n        var inst = this.__instances[instIdx];\n        if (inst) {\n          var itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n          // This is effectively `notifyPath`, but avoids some of the overhead\n          // of the public API\n          inst._setPendingPropertyOrPath(itemPath, value, false, true);\n          inst._flushProperties();\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Returns the item associated with a given element stamped by\n     * this `dom-repeat`.\n     *\n     * Note, to modify sub-properties of the item,\n     * `modelForElement(el).set('item.<sub-prop>', value)`\n     * should be used.\n     *\n     * @param {!HTMLElement} el Element for which to return the item.\n     * @return {*} Item associated with the element.\n     */\n  }, {\n    key: \"itemForElement\",\n    value: function itemForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.as];\n    }\n\n    /**\n     * Returns the inst index for a given element stamped by this `dom-repeat`.\n     * If `sort` is provided, the index will reflect the sorted order (rather\n     * than the original array order).\n     *\n     * @param {!HTMLElement} el Element for which to return the index.\n     * @return {?number} Row index associated with the element (note this may\n     *   not correspond to the array index if a user `sort` is applied).\n     */\n  }, {\n    key: \"indexForElement\",\n    value: function indexForElement(el) {\n      var instance = this.modelForElement(el);\n      return instance && instance[this.indexAs];\n    }\n\n    /**\n     * Returns the template \"model\" associated with a given element, which\n     * serves as the binding scope for the template instance the element is\n     * contained in. A template model\n     * should be used to manipulate data associated with this template instance.\n     *\n     * Example:\n     *\n     *   let model = modelForElement(el);\n     *   if (model.index < 10) {\n     *     model.set('item.checked', true);\n     *   }\n     *\n     * @param {!HTMLElement} el Element for which to return a template model.\n     * @return {TemplateInstanceBase} Model representing the binding scope for\n     *   the element.\n     */\n  }, {\n    key: \"modelForElement\",\n    value: function modelForElement(el) {\n      return _modelForElement(this.template, el);\n    }\n  }], [{\n    key: \"is\",\n    get:\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    function get() {\n      return 'dom-repeat';\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      /**\n       * Fired whenever DOM is added or removed by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n      return {\n        /**\n         * An array containing items determining how many instances of the template\n         * to stamp and that that each template instance should bind to.\n         */\n        items: {\n          type: Array\n        },\n        /**\n         * The name of the variable to add to the binding scope for the array\n         * element associated with a given template instance.\n         */\n        as: {\n          type: String,\n          value: 'item'\n        },\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the sorted and filtered list of rendered items.\n         * Note, for the index in the `this.items` array, use the value of the\n         * `itemsIndexAs` property.\n         */\n        indexAs: {\n          type: String,\n          value: 'index'\n        },\n        /**\n         * The name of the variable to add to the binding scope with the index\n         * of the instance in the `this.items` array. Note, for the index of\n         * this instance in the sorted and filtered list of rendered items,\n         * use the value of the `indexAs` property.\n         */\n        itemsIndexAs: {\n          type: String,\n          value: 'itemsIndex'\n        },\n        /**\n         * A function that should determine the sort order of the items.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.sort`.\n         * Using a sort function has no effect on the underlying `items` array.\n         */\n        sort: {\n          type: Function,\n          observer: '__sortChanged'\n        },\n        /**\n         * A function that can be used to filter items out of the view.  This\n         * property should either be provided as a string, indicating a method\n         * name on the element's host, or else be an actual function.  The\n         * function should match the sort function passed to `Array.filter`.\n         * Using a filter function has no effect on the underlying `items` array.\n         */\n        filter: {\n          type: Function,\n          observer: '__filterChanged'\n        },\n        /**\n         * When using a `filter` or `sort` function, the `observe` property\n         * should be set to a space-separated list of the names of item\n         * sub-fields that should trigger a re-sort or re-filter when changed.\n         * These should generally be fields of `item` that the sort or filter\n         * function depends on.\n         */\n        observe: {\n          type: String,\n          observer: '__observeChanged'\n        },\n        /**\n         * When using a `filter` or `sort` function, the `delay` property\n         * determines a debounce time in ms after a change to observed item\n         * properties that must pass before the filter or sort is re-run.\n         * This is useful in rate-limiting shuffling of the view when\n         * item changes may be frequent.\n         */\n        delay: Number,\n        /**\n         * Count of currently rendered items after `filter` (if any) has been applied.\n         * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n         * set of template instances is rendered.\n         *\n         */\n        renderedItemCount: {\n          type: Number,\n          notify: !suppressTemplateNotifications,\n          readOnly: true\n        },\n        /**\n         * When greater than zero, defines an initial count of template instances\n         * to render after setting the `items` array, before the next paint, and\n         * puts the `dom-repeat` into \"chunking mode\".  The remaining items (and\n         * any future items as a result of pushing onto the array) will be created\n         * and rendered incrementally at each animation frame thereof until all\n         * instances have been rendered.\n         */\n        initialCount: {\n          type: Number\n        },\n        /**\n         * When `initialCount` is used, this property defines a frame rate (in\n         * fps) to target by throttling the number of instances rendered each\n         * frame to not exceed the budget for the target frame rate.  The\n         * framerate is effectively the number of `requestAnimationFrame`s that\n         * it tries to allow to actually fire in a given second. It does this\n         * by measuring the time between `rAF`s and continuously adjusting the\n         * number of items created each `rAF` to maintain the target framerate.\n         * Setting this to a higher number allows lower latency and higher\n         * throughput for event handlers and other tasks, but results in a\n         * longer time for the remaining items to complete rendering.\n         */\n        targetFramerate: {\n          type: Number,\n          value: 20\n        },\n        _targetFrameTime: {\n          type: Number,\n          computed: '__computeFrameTime(targetFramerate)'\n        },\n        /**\n         * When the global `suppressTemplateNotifications` setting is used, setting\n         * `notifyDomChange: true` will enable firing `dom-change` events on this\n         * element.\n         */\n        notifyDomChange: {\n          type: Boolean\n        },\n        /**\n         * When chunking is enabled via `initialCount` and the `items` array is\n         * set to a new array, this flag controls whether the previously rendered\n         * instances are reused or not.\n         *\n         * When `true`, any previously rendered template instances are updated in\n         * place to their new item values synchronously in one shot, and then any\n         * further items (if any) are chunked out.  When `false`, the list is\n         * returned back to its `initialCount` (any instances over the initial\n         * count are discarded) and the remainder of the list is chunked back in.\n         * Set this to `true` to avoid re-creating the list and losing scroll\n         * position, although note that when changing the list to completely\n         * different data the render thread will be blocked until all existing\n         * instances are updated to their new data.\n         */\n        reuseChunkedInstances: {\n          type: Boolean\n        }\n      };\n    }\n  }, {\n    key: \"observers\",\n    get: function get() {\n      return ['__itemsChanged(items.*)'];\n    }\n  }]);\n  return DomRepeat;\n}(domRepeatBase);\ncustomElements.define(DomRepeat.is, DomRepeat);","map":{"version":3,"names":["PolymerElement","TemplateInstanceBase","templatize","modelForElement","Debouncer","enqueueDebouncer","flush","OptionalMutableData","matches","translate","timeOut","microTask","wrap","hideElementsGlobally","suppressTemplateNotifications","domRepeatBase","DomRepeat","_domRepeatBase","_inherits","_this","_classCallCheck","_callSuper","__instances","__renderDebouncer","__itemsIdxToInstIdx","__chunkCount","__renderStartTime","__itemsArrayChanged","__shouldMeasureChunk","__shouldContinueChunking","__chunkingId","__sortFn","__filterFn","__observePaths","__ctor","__isDetached","template","_templateInfo","_createClass","key","value","disconnectedCallback","_get","_getPrototypeOf","prototype","call","i","length","__detachInstance","cancelAnimationFrame","connectedCallback","style","display","wrappedParent","parentNode","__attachInstance","__render","__ensureTemplatized","_this2","thisAsTemplate","querySelector","observer","MutationObserver","disconnect","Error","observe","childList","instanceProps","as","indexAs","itemsIndexAs","mutableData","parentModel","forwardHostProp","prop","i$","inst","notifyInstanceProp","idx","items","path","concat","JSCompiler_renameProperty","notifyPath","__getMethodHost","__dataHost","_methodHost","__functionFromPropertyValue","functionOrMethodName","methodName","obj","apply","arguments","__sortChanged","sort","__debounceRender","__filterChanged","filter","__computeFrameTime","rate","Math","ceil","__observeChanged","replace","split","__handleObservedPaths","delay","paths","indexOf","__itemsChanged","change","Array","isArray","console","warn","__handleItemPath","fn","undefined","debounce","after","bind","render","_this3","isntIdxToItemsIdx","__sortAndFilterItems","limit","__calculateLimit","__updateInstances","initialCount","requestAnimationFrame","__continueChunking","_setRenderedItemCount","notifyDomChange","dispatchEvent","CustomEvent","bubbles","composed","_this4","array","a","b","filteredItemCount","currentCount","newCount","reuseChunkedInstances","min","max","performance","now","renderTime","ratio","_targetFrameTime","round","itemsIdxToInstIdx","instIdx","itemIdx","item","_setPendingProperty","_flushProperties","__insertInstance","__detachAndRemoveInstance","wrappedRoot","root","children","el","appendChild","parent","insertBefore","splice","__stampInstance","model","beforeRow","beforeNode","_showHideChildren","hidden","itemsPath","slice","dot","itemsIdx","substring","parseInt","itemSubPath","itemPath","_setPendingPropertyOrPath","itemForElement","instance","indexForElement","get","type","String","Function","Number","renderedItemCount","notify","readOnly","targetFramerate","computed","Boolean","customElements","define","is"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/elements/dom-repeat.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { TemplateInstanceBase, templatize, modelForElement } from '../utils/templatize.js'; // eslint-disable-line no-unused-vars\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { OptionalMutableData } from '../mixins/mutable-data.js';\nimport { matches, translate } from '../utils/path.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { suppressTemplateNotifications } from '../utils/settings.js';\n\n/**\n * @constructor\n * @implements {Polymer_OptionalMutableData}\n * @extends {PolymerElement}\n * @private\n */\nconst domRepeatBase = OptionalMutableData(PolymerElement);\n\n/**\n * The `<dom-repeat>` element will automatically stamp and binds one instance\n * of template content to each object in a user-provided array.\n * `dom-repeat` accepts an `items` property, and one instance of the template\n * is stamped for each item into the DOM at the location of the `dom-repeat`\n * element.  The `item` property will be set on each instance's binding\n * scope, thus templates should bind to sub-properties of `item`.\n *\n * Example:\n *\n * ```html\n * <dom-module id=\"employee-list\">\n *\n *   <template>\n *\n *     <div> Employee list: </div>\n *     <dom-repeat items=\"{{employees}}\">\n *       <template>\n *         <div>First name: <span>{{item.first}}</span></div>\n *         <div>Last name: <span>{{item.last}}</span></div>\n *       </template>\n *     </dom-repeat>\n *\n *   </template>\n *\n * </dom-module>\n * ```\n *\n * With the following custom element definition:\n *\n * ```js\n * class EmployeeList extends PolymerElement {\n *   static get is() { return 'employee-list'; }\n *   static get properties() {\n *     return {\n *       employees: {\n *         value() {\n *           return [\n *             {first: 'Bob', last: 'Smith'},\n *             {first: 'Sally', last: 'Johnson'},\n *             ...\n *           ];\n *         }\n *       }\n *     };\n *   }\n * }\n * ```\n *\n * Notifications for changes to items sub-properties will be forwarded to template\n * instances, which will update via the normal structured data notification system.\n *\n * Mutations to the `items` array itself should be made using the Array\n * mutation API's on the PropertyEffects mixin (`push`, `pop`, `splice`,\n * `shift`, `unshift`), and template instances will be kept in sync with the\n * data in the array.\n *\n * Events caught by event handlers within the `dom-repeat` template will be\n * decorated with a `model` property, which represents the binding scope for\n * each template instance.  The model should be used to manipulate data on the\n * instance, for example `event.model.set('item.checked', true);`.\n *\n * Alternatively, the model for a template instance for an element stamped by\n * a `dom-repeat` can be obtained using the `modelForElement` API on the\n * `dom-repeat` that stamped it, for example\n * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.\n * This may be useful for manipulating instance data of event targets obtained\n * by event handlers on parents of the `dom-repeat` (event delegation).\n *\n * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a\n * `filter` and/or `sort` property.  This may be a string that names a function on\n * the host, or a function may be assigned to the property directly.  The functions\n * should implemented following the standard `Array` filter/sort API.\n *\n * In order to re-run the filter or sort functions based on changes to sub-fields\n * of `items`, the `observe` property may be set as a space-separated list of\n * `item` sub-fields that should cause a re-filter/sort when modified.  If\n * the filter or sort function depends on properties not contained in `items`,\n * the user should observe changes to those properties and call `render` to update\n * the view based on the dependency change.\n *\n * For example, for an `dom-repeat` with a filter of the following:\n *\n * ```js\n * isEngineer(item) {\n *   return item.type == 'engineer' || item.manager.type == 'engineer';\n * }\n * ```\n *\n * Then the `observe` property should be configured as follows:\n *\n * ```html\n * <dom-repeat items=\"{{employees}}\" filter=\"isEngineer\" observe=\"type manager.type\">\n * ```\n *\n * @customElement\n * @polymer\n * @extends {domRepeatBase}\n * @appliesMixin OptionalMutableData\n * @summary Custom element for stamping instance of a template bound to\n *   items in an array.\n */\nexport class DomRepeat extends domRepeatBase {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-repeat'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    /**\n     * Fired whenever DOM is added or removed by this template (by\n     * default, rendering occurs lazily).  To force immediate rendering, call\n     * `render`.\n     *\n     * @event dom-change\n     */\n    return {\n\n      /**\n       * An array containing items determining how many instances of the template\n       * to stamp and that that each template instance should bind to.\n       */\n      items: {\n        type: Array\n      },\n\n      /**\n       * The name of the variable to add to the binding scope for the array\n       * element associated with a given template instance.\n       */\n      as: {\n        type: String,\n        value: 'item'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the sorted and filtered list of rendered items.\n       * Note, for the index in the `this.items` array, use the value of the\n       * `itemsIndexAs` property.\n       */\n      indexAs: {\n        type: String,\n        value: 'index'\n      },\n\n      /**\n       * The name of the variable to add to the binding scope with the index\n       * of the instance in the `this.items` array. Note, for the index of\n       * this instance in the sorted and filtered list of rendered items,\n       * use the value of the `indexAs` property.\n       */\n      itemsIndexAs: {\n        type: String,\n        value: 'itemsIndex'\n      },\n\n      /**\n       * A function that should determine the sort order of the items.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.sort`.\n       * Using a sort function has no effect on the underlying `items` array.\n       */\n      sort: {\n        type: Function,\n        observer: '__sortChanged'\n      },\n\n      /**\n       * A function that can be used to filter items out of the view.  This\n       * property should either be provided as a string, indicating a method\n       * name on the element's host, or else be an actual function.  The\n       * function should match the sort function passed to `Array.filter`.\n       * Using a filter function has no effect on the underlying `items` array.\n       */\n      filter: {\n        type: Function,\n        observer: '__filterChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `observe` property\n       * should be set to a space-separated list of the names of item\n       * sub-fields that should trigger a re-sort or re-filter when changed.\n       * These should generally be fields of `item` that the sort or filter\n       * function depends on.\n       */\n      observe: {\n        type: String,\n        observer: '__observeChanged'\n      },\n\n      /**\n       * When using a `filter` or `sort` function, the `delay` property\n       * determines a debounce time in ms after a change to observed item\n       * properties that must pass before the filter or sort is re-run.\n       * This is useful in rate-limiting shuffling of the view when\n       * item changes may be frequent.\n       */\n      delay: Number,\n\n      /**\n       * Count of currently rendered items after `filter` (if any) has been applied.\n       * If \"chunking mode\" is enabled, `renderedItemCount` is updated each time a\n       * set of template instances is rendered.\n       *\n       */\n      renderedItemCount: {\n        type: Number,\n        notify: !suppressTemplateNotifications,\n        readOnly: true\n      },\n\n      /**\n       * When greater than zero, defines an initial count of template instances\n       * to render after setting the `items` array, before the next paint, and\n       * puts the `dom-repeat` into \"chunking mode\".  The remaining items (and\n       * any future items as a result of pushing onto the array) will be created\n       * and rendered incrementally at each animation frame thereof until all\n       * instances have been rendered.\n       */\n      initialCount: {\n        type: Number\n      },\n\n      /**\n       * When `initialCount` is used, this property defines a frame rate (in\n       * fps) to target by throttling the number of instances rendered each\n       * frame to not exceed the budget for the target frame rate.  The\n       * framerate is effectively the number of `requestAnimationFrame`s that\n       * it tries to allow to actually fire in a given second. It does this\n       * by measuring the time between `rAF`s and continuously adjusting the\n       * number of items created each `rAF` to maintain the target framerate.\n       * Setting this to a higher number allows lower latency and higher\n       * throughput for event handlers and other tasks, but results in a\n       * longer time for the remaining items to complete rendering.\n       */\n      targetFramerate: {\n        type: Number,\n        value: 20\n      },\n\n      _targetFrameTime: {\n        type: Number,\n        computed: '__computeFrameTime(targetFramerate)'\n      },\n\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      },\n\n      /**\n       * When chunking is enabled via `initialCount` and the `items` array is\n       * set to a new array, this flag controls whether the previously rendered\n       * instances are reused or not.\n       *\n       * When `true`, any previously rendered template instances are updated in\n       * place to their new item values synchronously in one shot, and then any\n       * further items (if any) are chunked out.  When `false`, the list is\n       * returned back to its `initialCount` (any instances over the initial\n       * count are discarded) and the remainder of the list is chunked back in.\n       * Set this to `true` to avoid re-creating the list and losing scroll\n       * position, although note that when changing the list to completely\n       * different data the render thread will be blocked until all existing\n       * instances are updated to their new data.\n       */\n      reuseChunkedInstances: {\n        type: Boolean\n      }\n\n    };\n\n  }\n\n  static get observers() {\n    return [ '__itemsChanged(items.*)' ];\n  }\n\n  constructor() {\n    super();\n    this.__instances = [];\n    this.__renderDebouncer = null;\n    this.__itemsIdxToInstIdx = {};\n    this.__chunkCount = null;\n    this.__renderStartTime = null;\n    this.__itemsArrayChanged = false;\n    this.__shouldMeasureChunk = false;\n    this.__shouldContinueChunking = false;\n    this.__chunkingId = 0;\n    this.__sortFn = null;\n    this.__filterFn = null;\n    this.__observePaths = null;\n    /** @type {?function(new:TemplateInstanceBase, Object=)} */\n    this.__ctor = null;\n    this.__isDetached = true;\n    this.template = null;\n    /** @type {TemplateInfo} */\n    this._templateInfo;\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__isDetached = true;\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__detachInstance(i);\n    }\n    // Stop chunking if one was in progress\n    if (this.__chunkingId) {\n      cancelAnimationFrame(this.__chunkingId);\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    // only perform attachment if the element was previously detached.\n    if (this.__isDetached) {\n      this.__isDetached = false;\n      let wrappedParent = wrap(wrap(this).parentNode);\n      for (let i=0; i<this.__instances.length; i++) {\n        this.__attachInstance(i, wrappedParent);\n      }\n      // Restart chunking if one was in progress when disconnected\n      if (this.__chunkingId) {\n        this.__render();\n      }\n    }\n  }\n\n  __ensureTemplatized() {\n    // Templatizing (generating the instance constructor) needs to wait\n    // until ready, since won't have its template content handed back to\n    // it until then\n    if (!this.__ctor) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\n          /** @type {!HTMLElement} */ (this));\n      let template = this.template = thisAsTemplate._templateInfo ?\n          thisAsTemplate :\n          /** @type {!HTMLTemplateElement} */ (this.querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (this.querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-repeat requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      // Template instance props that should be excluded from forwarding\n      let instanceProps = {};\n      instanceProps[this.as] = true;\n      instanceProps[this.indexAs] = true;\n      instanceProps[this.itemsIndexAs] = true;\n      this.__ctor = templatize(template, this, {\n        mutableData: this.mutableData,\n        parentModel: true,\n        instanceProps: instanceProps,\n        /**\n         * @this {DomRepeat}\n         * @param {string} prop Property to set\n         * @param {*} value Value to set property to\n         */\n        forwardHostProp: function(prop, value) {\n          let i$ = this.__instances;\n          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {\n            inst.forwardHostProp(prop, value);\n          }\n        },\n        /**\n         * @this {DomRepeat}\n         * @param {Object} inst Instance to notify\n         * @param {string} prop Property to notify\n         * @param {*} value Value to notify\n         */\n        notifyInstanceProp: function(inst, prop, value) {\n          if (matches(this.as, prop)) {\n            let idx = inst[this.itemsIndexAs];\n            if (prop == this.as) {\n              this.items[idx] = value;\n            }\n            let path = translate(this.as, `${JSCompiler_renameProperty('items', this)}.${idx}`, prop);\n            this.notifyPath(path, value);\n          }\n        }\n      });\n    }\n    return true;\n  }\n\n  __getMethodHost() {\n    // Technically this should be the owner of the outermost template.\n    // In shadow dom, this is always getRootNode().host, but we can\n    // approximate this via cooperation with our dataHost always setting\n    // `_methodHost` as long as there were bindings (or id's) on this\n    // instance causing it to get a dataHost.\n    return this.__dataHost._methodHost || this.__dataHost;\n  }\n\n  __functionFromPropertyValue(functionOrMethodName) {\n    if (typeof functionOrMethodName === 'string') {\n      let methodName = functionOrMethodName;\n      let obj = this.__getMethodHost();\n      return function() { return obj[methodName].apply(obj, arguments); };\n    }\n\n    return functionOrMethodName;\n  }\n\n  __sortChanged(sort) {\n    this.__sortFn = this.__functionFromPropertyValue(sort);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __filterChanged(filter) {\n    this.__filterFn = this.__functionFromPropertyValue(filter);\n    if (this.items) { this.__debounceRender(this.__render); }\n  }\n\n  __computeFrameTime(rate) {\n    return Math.ceil(1000/rate);\n  }\n\n  __observeChanged() {\n    this.__observePaths = this.observe &&\n      this.observe.replace('.*', '.').split(' ');\n  }\n\n  __handleObservedPaths(path) {\n    // Handle cases where path changes should cause a re-sort/filter\n    if (this.__sortFn || this.__filterFn) {\n      if (!path) {\n        // Always re-render if the item itself changed\n        this.__debounceRender(this.__render, this.delay);\n      } else if (this.__observePaths) {\n        // Otherwise, re-render if the path changed matches an observed path\n        let paths = this.__observePaths;\n        for (let i=0; i<paths.length; i++) {\n          if (path.indexOf(paths[i]) === 0) {\n            this.__debounceRender(this.__render, this.delay);\n          }\n        }\n      }\n    }\n  }\n\n  __itemsChanged(change) {\n    if (this.items && !Array.isArray(this.items)) {\n      console.warn('dom-repeat expected array for `items`, found', this.items);\n    }\n    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the\n    // path to that instance synchronously (returns false for non-item paths)\n    if (!this.__handleItemPath(change.path, change.value)) {\n      // Otherwise, the array was reset ('items') or spliced ('items.splices'),\n      // so queue a render.  Restart chunking when the items changed (for\n      // backward compatibility), unless `reuseChunkedInstances` option is set\n      if (change.path === 'items') {\n        this.__itemsArrayChanged = true;\n      }\n      this.__debounceRender(this.__render);\n    }\n  }\n\n  /**\n   * @param {function(this:DomRepeat)} fn Function to debounce.\n   * @param {number=} delay Delay in ms to debounce by.\n   */\n  __debounceRender(fn, delay = 0) {\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , delay > 0 ? timeOut.after(delay) : microTask\n        , fn.bind(this));\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   * @return {void}\n   */\n  render() {\n    // Queue this repeater, then flush all in order\n    this.__debounceRender(this.__render);\n    flush();\n  }\n\n  __render() {\n    if (!this.__ensureTemplatized()) {\n      // No template found yet\n      return;\n    }\n    let items = this.items || [];\n    // Sort and filter the items into a mapping array from instance->item\n    const isntIdxToItemsIdx = this.__sortAndFilterItems(items);\n    // If we're chunking, increase the limit if there are new instances to\n    // create and schedule the next chunk\n    const limit = this.__calculateLimit(isntIdxToItemsIdx.length);\n    // Create, update, and/or remove instances\n    this.__updateInstances(items, limit, isntIdxToItemsIdx);\n    // If we're chunking, schedule a rAF task to measure/continue chunking.     \n    // Do this before any notifying events (renderedItemCount & dom-change)\n    // since those could modify items and enqueue a new full render which will\n    // pre-empt this measurement.\n    if (this.initialCount &&\n       (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {\n      cancelAnimationFrame(this.__chunkingId);\n      this.__chunkingId = requestAnimationFrame(() => {\n        this.__chunkingId = null;\n        this.__continueChunking();\n      });\n    }\n    // Set rendered item count\n    this._setRenderedItemCount(this.__instances.length);\n    // Notify users\n    if (!suppressTemplateNotifications || this.notifyDomChange) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }\n\n  __sortAndFilterItems(items) {\n    // Generate array maping the instance index to the items array index\n    let isntIdxToItemsIdx = new Array(items.length);\n    for (let i=0; i<items.length; i++) {\n      isntIdxToItemsIdx[i] = i;\n    }\n    // Apply user filter\n    if (this.__filterFn) {\n      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>\n        this.__filterFn(items[i], idx, array));\n    }\n    // Apply user sort\n    if (this.__sortFn) {\n      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));\n    }\n    return isntIdxToItemsIdx;\n  }\n\n  __calculateLimit(filteredItemCount) {\n    let limit = filteredItemCount;\n    const currentCount = this.__instances.length;\n    // When chunking, we increase the limit from the currently rendered count\n    // by the chunk count that is re-calculated after each rAF (with special\n    // cases for resetting the limit to initialCount after changing items)\n    if (this.initialCount) {\n      let newCount;\n      if (!this.__chunkCount ||\n        (this.__itemsArrayChanged && !this.reuseChunkedInstances)) {\n        // Limit next render to the initial count\n        limit = Math.min(filteredItemCount, this.initialCount);\n        // Subtract off any existing instances to determine the number of\n        // instances that will be created\n        newCount = Math.max(limit - currentCount, 0);\n        // Initialize the chunk size with how many items we're creating\n        this.__chunkCount = newCount || 1;\n      } else {\n        // The number of new instances that will be created is based on the\n        // existing instances, the new list size, and the chunk size\n        newCount = Math.min(\n          Math.max(filteredItemCount - currentCount, 0), \n          this.__chunkCount);\n        // Update the limit based on how many new items we're making, limited\n        // buy the total size of the list\n        limit = Math.min(currentCount + newCount, filteredItemCount);\n      }\n      // Record some state about chunking for use in `__continueChunking`\n      this.__shouldMeasureChunk = newCount === this.__chunkCount;\n      this.__shouldContinueChunking = limit < filteredItemCount;\n      this.__renderStartTime = performance.now();\n    }\n    this.__itemsArrayChanged = false;\n    return limit;\n  }\n\n  __continueChunking() {\n    // Simple auto chunkSize throttling algorithm based on feedback loop:\n    // measure actual time between frames and scale chunk count by ratio of\n    // target/actual frame time.  Only modify chunk size if our measurement\n    // reflects the cost of a creating a full chunk's worth of instances; this\n    // avoids scaling up the chunk size if we e.g. quickly re-rendered instances\n    // in place\n    if (this.__shouldMeasureChunk) {\n      const renderTime = performance.now() - this.__renderStartTime;\n      const ratio = this._targetFrameTime / renderTime;\n      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;\n    }\n    // Enqueue a new render if we haven't reached the full size of the list\n    if (this.__shouldContinueChunking) {\n      this.__debounceRender(this.__render);\n    }\n  }\n  \n  __updateInstances(items, limit, isntIdxToItemsIdx) {\n    // items->inst map kept for item path forwarding\n    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};\n    let instIdx;\n    // Generate instances and assign items\n    for (instIdx=0; instIdx<limit; instIdx++) {\n      let inst = this.__instances[instIdx];\n      let itemIdx = isntIdxToItemsIdx[instIdx];\n      let item = items[itemIdx];\n      itemsIdxToInstIdx[itemIdx] = instIdx;\n      if (inst) {\n        inst._setPendingProperty(this.as, item);\n        inst._setPendingProperty(this.indexAs, instIdx);\n        inst._setPendingProperty(this.itemsIndexAs, itemIdx);\n        inst._flushProperties();\n      } else {\n        this.__insertInstance(item, instIdx, itemIdx);\n      }\n    }\n    // Remove any extra instances from previous state\n    for (let i=this.__instances.length-1; i>=instIdx; i--) {\n      this.__detachAndRemoveInstance(i);\n    }\n  }\n\n  __detachInstance(idx) {\n    let inst = this.__instances[idx];\n    const wrappedRoot = wrap(inst.root);\n    for (let i=0; i<inst.children.length; i++) {\n      let el = inst.children[i];\n      wrappedRoot.appendChild(el);\n    }\n    return inst;\n  }\n\n  __attachInstance(idx, parent) {\n    let inst = this.__instances[idx];\n    // Note, this is pre-wrapped as an optimization\n    parent.insertBefore(inst.root, this);\n  }\n\n  __detachAndRemoveInstance(idx) {\n    this.__detachInstance(idx);\n    this.__instances.splice(idx, 1);\n  }\n\n  __stampInstance(item, instIdx, itemIdx) {\n    let model = {};\n    model[this.as] = item;\n    model[this.indexAs] = instIdx;\n    model[this.itemsIndexAs] = itemIdx;\n    return new this.__ctor(model);\n  }\n\n  __insertInstance(item, instIdx, itemIdx) {\n    const inst = this.__stampInstance(item, instIdx, itemIdx);\n    let beforeRow = this.__instances[instIdx + 1];\n    let beforeNode = beforeRow ? beforeRow.children[0] : this;\n    wrap(wrap(this).parentNode).insertBefore(inst.root, beforeNode);\n    this.__instances[instIdx] = inst;\n    return inst;\n  }\n\n  // Implements extension point from Templatize mixin\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hidden Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n  _showHideChildren(hidden) {\n    for (let i=0; i<this.__instances.length; i++) {\n      this.__instances[i]._showHideChildren(hidden);\n    }\n  }\n\n  // Called as a side effect of a host items.<key>.<path> path change,\n  // responsible for notifying item.<path> changes to inst for key\n  __handleItemPath(path, value) {\n    let itemsPath = path.slice(6); // 'items.'.length == 6\n    let dot = itemsPath.indexOf('.');\n    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);\n    // If path was index into array...\n    if (itemsIdx == parseInt(itemsIdx, 10)) {\n      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);\n      // If the path is observed, it will trigger a full refresh\n      this.__handleObservedPaths(itemSubPath);\n      // Note, even if a rull refresh is triggered, always do the path\n      // notification because unless mutableData is used for dom-repeat\n      // and all elements in the instance subtree, a full refresh may\n      // not trigger the proper update.\n      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];\n      let inst = this.__instances[instIdx];\n      if (inst) {\n        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');\n        // This is effectively `notifyPath`, but avoids some of the overhead\n        // of the public API\n        inst._setPendingPropertyOrPath(itemPath, value, false, true);\n        inst._flushProperties();\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Returns the item associated with a given element stamped by\n   * this `dom-repeat`.\n   *\n   * Note, to modify sub-properties of the item,\n   * `modelForElement(el).set('item.<sub-prop>', value)`\n   * should be used.\n   *\n   * @param {!HTMLElement} el Element for which to return the item.\n   * @return {*} Item associated with the element.\n   */\n  itemForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.as];\n  }\n\n  /**\n   * Returns the inst index for a given element stamped by this `dom-repeat`.\n   * If `sort` is provided, the index will reflect the sorted order (rather\n   * than the original array order).\n   *\n   * @param {!HTMLElement} el Element for which to return the index.\n   * @return {?number} Row index associated with the element (note this may\n   *   not correspond to the array index if a user `sort` is applied).\n   */\n  indexForElement(el) {\n    let instance = this.modelForElement(el);\n    return instance && instance[this.indexAs];\n  }\n\n  /**\n   * Returns the template \"model\" associated with a given element, which\n   * serves as the binding scope for the template instance the element is\n   * contained in. A template model\n   * should be used to manipulate data associated with this template instance.\n   *\n   * Example:\n   *\n   *   let model = modelForElement(el);\n   *   if (model.index < 10) {\n   *     model.set('item.checked', true);\n   *   }\n   *\n   * @param {!HTMLElement} el Element for which to return a template model.\n   * @return {TemplateInstanceBase} Model representing the binding scope for\n   *   the element.\n   */\n  modelForElement(el) {\n    return modelForElement(this.template, el);\n  }\n\n}\n\ncustomElements.define(DomRepeat.is, DomRepeat);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAc,QAAQ,0BAA0B;AAEzD,SAASC,oBAAoB,EAAEC,UAAU,EAAEC,eAAe,IAAfA,gBAAe,QAAQ,wBAAwB,CAAC,CAAC;AAC5F,SAASC,SAAS,QAAQ,sBAAsB;AAChD,SAASC,gBAAgB,EAAEC,KAAK,QAAQ,mBAAmB;AAC3D,SAASC,mBAAmB,QAAQ,2BAA2B;AAC/D,SAASC,OAAO,EAAEC,SAAS,QAAQ,kBAAkB;AACrD,SAASC,OAAO,EAAEC,SAAS,QAAQ,mBAAmB;AACtD,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,oBAAoB,QAAQ,oCAAoC;AACzE,SAASC,6BAA6B,QAAQ,sBAAsB;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA,IAAMC,aAAa,GAAGR,mBAAmB,CAACP,cAAc,CAAC;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAagB,SAAS,0BAAAC,cAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,cAAA;EAyLpB,SAAAD,UAAA,EAAc;IAAA,IAAAG,KAAA;IAAAC,eAAA,OAAAJ,SAAA;IACZG,KAAA,GAAAE,UAAA,OAAAL,SAAA;IACAG,KAAA,CAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}