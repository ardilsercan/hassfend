{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar debouncerQueue = new Set();\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport var Debouncer = /*#__PURE__*/function () {\n  function Debouncer() {\n    _classCallCheck(this, Debouncer);\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  _createClass(Debouncer, [{\n    key: \"setConfig\",\n    value: function setConfig(asyncModule, callback) {\n      var _this = this;\n      this._asyncModule = asyncModule;\n      this._callback = callback;\n      this._timer = this._asyncModule.run(function () {\n        _this._timer = null;\n        debouncerQueue.delete(_this);\n        _this._callback();\n      });\n    }\n\n    /**\n     * Cancels an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.isActive()) {\n        this._cancelAsync();\n        // Canceling a debouncer removes its spot from the flush queue,\n        // so if a debouncer is manually canceled and re-debounced, it\n        // will reset its flush order (this is a very minor difference from 1.x)\n        // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n        debouncerQueue.delete(this);\n      }\n    }\n\n    /**\n     * Cancels a debouncer's async callback.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"_cancelAsync\",\n    value: function _cancelAsync() {\n      if (this.isActive()) {\n        this._asyncModule.cancel( /** @type {number} */this._timer);\n        this._timer = null;\n      }\n    }\n\n    /**\n     * Flushes an active debouncer and returns a reference to itself.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.isActive()) {\n        this.cancel();\n        this._callback();\n      }\n    }\n\n    /**\n     * Returns true if the debouncer is active.\n     *\n     * @return {boolean} True if active.\n     */\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this._timer != null;\n    }\n  }], [{\n    key: \"debounce\",\n    value:\n    /**\n     * Creates a debouncer if no debouncer is passed as a parameter\n     * or it cancels an active debouncer otherwise. The following\n     * example shows how a debouncer can be called multiple times within a\n     * microtask and \"debounced\" such that the provided callback function is\n     * called once. Add this method to a custom element:\n     *\n     * ```js\n     * import {microTask} from '@vaadin/component-base/src/async.js';\n     * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n     * // ...\n     *\n     * _debounceWork() {\n     *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n     *       microTask, () => this._doWork());\n     * }\n     * ```\n     *\n     * If the `_debounceWork` method is called multiple times within the same\n     * microtask, the `_doWork` function will be called only once at the next\n     * microtask checkpoint.\n     *\n     * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n     * this with a debouncer, you can use `enqueueDebouncer` and\n     * `flush`. For example, extend the above example by adding\n     * `enqueueDebouncer(this._debounceJob)` at the end of the\n     * `_debounceWork` method. Then in a test, call `flush` to ensure\n     * the debouncer has completed.\n     *\n     * @param {Debouncer?} debouncer Debouncer object.\n     * @param {!AsyncInterface} asyncModule Object with Async interface\n     * @param {function()} callback Callback to run.\n     * @return {!Debouncer} Returns a debouncer object.\n     */\n    function debounce(debouncer, asyncModule, callback) {\n      if (debouncer instanceof Debouncer) {\n        // Cancel the async callback, but leave in debouncerQueue if it was\n        // enqueued, to maintain 1.x flush order\n        debouncer._cancelAsync();\n      } else {\n        debouncer = new Debouncer();\n      }\n      debouncer.setConfig(asyncModule, callback);\n      return debouncer;\n    }\n  }]);\n  return Debouncer;\n}();\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport function enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n}\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport function flushDebouncers() {\n  var didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach(function (debouncer) {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(function () {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n}\nexport var flush = function flush() {\n  var debouncers;\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};","map":{"version":3,"names":["debouncerQueue","Set","Debouncer","_classCallCheck","_asyncModule","_callback","_timer","_createClass","key","value","setConfig","asyncModule","callback","_this","run","delete","cancel","isActive","_cancelAsync","flush","debounce","debouncer","enqueueDebouncer","add","flushDebouncers","didFlush","Boolean","size","forEach","e","setTimeout","debouncers"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@vaadin/component-base/src/debounce.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nconst debouncerQueue = new Set();\n\n/**\n * @summary Collapse multiple callbacks into one invocation after a timer.\n */\nexport class Debouncer {\n  /**\n   * Creates a debouncer if no debouncer is passed as a parameter\n   * or it cancels an active debouncer otherwise. The following\n   * example shows how a debouncer can be called multiple times within a\n   * microtask and \"debounced\" such that the provided callback function is\n   * called once. Add this method to a custom element:\n   *\n   * ```js\n   * import {microTask} from '@vaadin/component-base/src/async.js';\n   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';\n   * // ...\n   *\n   * _debounceWork() {\n   *   this._debounceJob = Debouncer.debounce(this._debounceJob,\n   *       microTask, () => this._doWork());\n   * }\n   * ```\n   *\n   * If the `_debounceWork` method is called multiple times within the same\n   * microtask, the `_doWork` function will be called only once at the next\n   * microtask checkpoint.\n   *\n   * Note: In testing it is often convenient to avoid asynchrony. To accomplish\n   * this with a debouncer, you can use `enqueueDebouncer` and\n   * `flush`. For example, extend the above example by adding\n   * `enqueueDebouncer(this._debounceJob)` at the end of the\n   * `_debounceWork` method. Then in a test, call `flush` to ensure\n   * the debouncer has completed.\n   *\n   * @param {Debouncer?} debouncer Debouncer object.\n   * @param {!AsyncInterface} asyncModule Object with Async interface\n   * @param {function()} callback Callback to run.\n   * @return {!Debouncer} Returns a debouncer object.\n   */\n  static debounce(debouncer, asyncModule, callback) {\n    if (debouncer instanceof Debouncer) {\n      // Cancel the async callback, but leave in debouncerQueue if it was\n      // enqueued, to maintain 1.x flush order\n      debouncer._cancelAsync();\n    } else {\n      debouncer = new Debouncer();\n    }\n    debouncer.setConfig(asyncModule, callback);\n    return debouncer;\n  }\n\n  constructor() {\n    this._asyncModule = null;\n    this._callback = null;\n    this._timer = null;\n  }\n\n  /**\n   * Sets the scheduler; that is, a module with the Async interface,\n   * a callback and optional arguments to be passed to the run function\n   * from the async module.\n   *\n   * @param {!AsyncInterface} asyncModule Object with Async interface.\n   * @param {function()} callback Callback to run.\n   * @return {void}\n   */\n  setConfig(asyncModule, callback) {\n    this._asyncModule = asyncModule;\n    this._callback = callback;\n    this._timer = this._asyncModule.run(() => {\n      this._timer = null;\n      debouncerQueue.delete(this);\n      this._callback();\n    });\n  }\n\n  /**\n   * Cancels an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  cancel() {\n    if (this.isActive()) {\n      this._cancelAsync();\n      // Canceling a debouncer removes its spot from the flush queue,\n      // so if a debouncer is manually canceled and re-debounced, it\n      // will reset its flush order (this is a very minor difference from 1.x)\n      // Re-debouncing via the `debounce` API retains the 1.x FIFO flush order\n      debouncerQueue.delete(this);\n    }\n  }\n\n  /**\n   * Cancels a debouncer's async callback.\n   *\n   * @return {void}\n   */\n  _cancelAsync() {\n    if (this.isActive()) {\n      this._asyncModule.cancel(/** @type {number} */ (this._timer));\n      this._timer = null;\n    }\n  }\n\n  /**\n   * Flushes an active debouncer and returns a reference to itself.\n   *\n   * @return {void}\n   */\n  flush() {\n    if (this.isActive()) {\n      this.cancel();\n      this._callback();\n    }\n  }\n\n  /**\n   * Returns true if the debouncer is active.\n   *\n   * @return {boolean} True if active.\n   */\n  isActive() {\n    return this._timer != null;\n  }\n}\n\n/**\n * Adds a `Debouncer` to a list of globally flushable tasks.\n *\n * @param {!Debouncer} debouncer Debouncer to enqueue\n * @return {void}\n */\nexport function enqueueDebouncer(debouncer) {\n  debouncerQueue.add(debouncer);\n}\n\n/**\n * Flushes any enqueued debouncers\n *\n * @return {boolean} Returns whether any debouncers were flushed\n */\nexport function flushDebouncers() {\n  const didFlush = Boolean(debouncerQueue.size);\n  // If new debouncers are added while flushing, Set.forEach will ensure\n  // newly added ones are also flushed\n  debouncerQueue.forEach((debouncer) => {\n    try {\n      debouncer.flush();\n    } catch (e) {\n      setTimeout(() => {\n        throw e;\n      });\n    }\n  });\n  return didFlush;\n}\n\nexport const flush = () => {\n  let debouncers;\n  do {\n    debouncers = flushDebouncers();\n  } while (debouncers);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}