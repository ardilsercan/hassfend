{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive } from '../directive.js';\n// A sentinel that indicates guard() hasn't rendered anything yet\nvar initialValue = {};\nvar GuardDirective = /*#__PURE__*/function (_Directive) {\n  _inherits(GuardDirective, _Directive);\n  function GuardDirective() {\n    var _this;\n    _classCallCheck(this, GuardDirective);\n    _this = _callSuper(this, GuardDirective, arguments);\n    _this._previousValue = initialValue;\n    return _this;\n  }\n  _createClass(GuardDirective, [{\n    key: \"render\",\n    value: function render(_value, f) {\n      return f();\n    }\n  }, {\n    key: \"update\",\n    value: function update(_part, _ref) {\n      var _this2 = this;\n      var _ref2 = _slicedToArray(_ref, 2),\n        value = _ref2[0],\n        f = _ref2[1];\n      if (Array.isArray(value)) {\n        // Dirty-check arrays by item\n        if (Array.isArray(this._previousValue) && this._previousValue.length === value.length && value.every(function (v, i) {\n          return v === _this2._previousValue[i];\n        })) {\n          return noChange;\n        }\n      } else if (this._previousValue === value) {\n        // Dirty-check non-arrays by identity\n        return noChange;\n      }\n      // Copy the value if it's an array so that if it's mutated we don't forget\n      // what the previous values were.\n      this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n      var r = this.render(value, f);\n      return r;\n    }\n  }]);\n  return GuardDirective;\n}(Directive);\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport var guard = directive(GuardDirective);","map":{"version":3,"names":["noChange","directive","Directive","initialValue","GuardDirective","_Directive","_inherits","_this","_classCallCheck","_previousValue","_createClass","key","value","render","_value","f","update","_part","_ref","_this2","_ref2","_slicedToArray","Array","isArray","length","every","v","i","from","r","guard"],"sources":["../../src/directives/guard.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {noChange, Part} from '../lit-html.js';\nimport {directive, Directive, DirectiveParameters} from '../directive.js';\n\n// A sentinel that indicates guard() hasn't rendered anything yet\nconst initialValue = {};\n\nclass GuardDirective extends Directive {\n  private _previousValue: unknown = initialValue;\n\n  render(_value: unknown, f: () => unknown) {\n    return f();\n  }\n\n  override update(_part: Part, [value, f]: DirectiveParameters<this>) {\n    if (Array.isArray(value)) {\n      // Dirty-check arrays by item\n      if (\n        Array.isArray(this._previousValue) &&\n        this._previousValue.length === value.length &&\n        value.every((v, i) => v === (this._previousValue as Array<unknown>)[i])\n      ) {\n        return noChange;\n      }\n    } else if (this._previousValue === value) {\n      // Dirty-check non-arrays by identity\n      return noChange;\n    }\n\n    // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n    this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    const r = this.render(value, f);\n    return r;\n  }\n}\n\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard = directive(GuardDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {GuardDirective};\n"],"mappings":";;;;;;;;;;AAAA;;;;;AAMA,SAAQA,QAAQ,QAAa,gBAAgB;AAC7C,SAAQC,SAAS,EAAEC,SAAS,QAA4B,iBAAiB;AAEzE;AACA,IAAMC,YAAY,GAAG,EAAE;AAAC,IAElBC,cAAe,0BAAAC,UAAA;EAAAC,SAAA,CAAAF,cAAA,EAAAC,UAAA;EAArB,SAAAD,eAAA;IAAA,IAAAG,KAAA;IAAAC,eAAA,OAAAJ,cAAA;;IACUG,KAAA,CAAAE,cAAc,GAAYN,YAAY;IAAC,OAAAI,KAAA;EA2BjD;EAACG,YAAA,CAAAN,cAAA;IAAAO,GAAA;IAAAC,KAAA,EAzBC,SAAAC,OAAOC,MAAe,EAAEC,CAAgB;MACtC,OAAOA,CAAC,EAAE;IACZ;EAAC;IAAAJ,GAAA;IAAAC,KAAA,EAEQ,SAAAI,OAAOC,KAAW,EAAAC,IAAA,EAAuC;MAAA,IAAAC,MAAA;MAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAH,IAAA;QAApCN,KAAK,GAAAQ,KAAA;QAAEL,CAAC,GAAAK,KAAA;MACpC,IAAIE,KAAK,CAACC,OAAO,CAACX,KAAK,CAAC,EAAE;QACxB;QACA,IACEU,KAAK,CAACC,OAAO,CAAC,IAAI,CAACd,cAAc,CAAC,IAClC,IAAI,CAACA,cAAc,CAACe,MAAM,KAAKZ,KAAK,CAACY,MAAM,IAC3CZ,KAAK,CAACa,KAAK,CAAC,UAACC,CAAC,EAAEC,CAAC;UAAA,OAAKD,CAAC,KAAMP,MAAI,CAACV,cAAiC,CAACkB,CAAC,CAAC;QAAA,EAAC,EACvE;UACA,OAAO3B,QAAQ;;OAElB,MAAM,IAAI,IAAI,CAACS,cAAc,KAAKG,KAAK,EAAE;QACxC;QACA,OAAOZ,QAAQ;;MAGjB;MACA;MACA,IAAI,CAACS,cAAc,GAAGa,KAAK,CAACC,OAAO,CAACX,KAAK,CAAC,GAAGU,KAAK,CAACM,IAAI,CAAChB,KAAK,CAAC,GAAGA,KAAK;MACtE,IAAMiB,CAAC,GAAG,IAAI,CAAChB,MAAM,CAACD,KAAK,EAAEG,CAAC,CAAC;MAC/B,OAAOc,CAAC;IACV;EAAC;EAAA,OAAAzB,cAAA;AAAA,EA3B0BF,SAAS;AA8BtC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA,OAAO,IAAM4B,KAAK,GAAG7B,SAAS,CAACG,cAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}