{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\nimport { ValueNotifier } from '../value-notifier.js';\nexport class ContextProviderEvent extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  constructor(context) {\n    super('context-provider', {\n      bubbles: true,\n      composed: true\n    });\n    this.context = context;\n  }\n}\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider extends ValueNotifier {\n  constructor(host, contextOrOptions, initialValue) {\n    super(contextOrOptions.context !== undefined ? contextOrOptions.initialValue : initialValue);\n    this.onContextRequest = ev => {\n      // Only call the callback if the context matches.\n      // Also, in case an element is a consumer AND a provider\n      // of the same context, we want to avoid the element to self-register.\n      // The check on composedPath (as opposed to ev.target) is to cover cases\n      // where the consumer is in the shadowDom of the provider (in which case,\n      // event.target === this.host because of event retargeting).\n      const consumerHost = ev.composedPath()[0];\n      if (ev.context !== this.context || consumerHost === this.host) {\n        return;\n      }\n      ev.stopPropagation();\n      this.addCallback(ev.callback, consumerHost, ev.subscribe);\n    };\n    /**\n     * When we get a provider request event, that means a child of this element\n     * has just woken up. If it's a provider of our context, then we may need to\n     * re-parent our subscriptions, because is a more specific provider than us\n     * for its subtree.\n     */\n    this.onProviderRequest = ev => {\n      // Ignore events when the context doesn't match.\n      // Also, in case an element is a consumer AND a provider\n      // of the same context it shouldn't provide to itself.\n      // We use composedPath (as opposed to ev.target) to cover cases\n      // where the consumer is in the shadowDom of the provider (in which case,\n      // event.target === this.host because of event retargeting).\n      const childProviderHost = ev.composedPath()[0];\n      if (ev.context !== this.context || childProviderHost === this.host) {\n        return;\n      }\n      // Re-parent all of our subscriptions in case this new child provider\n      // should take them over.\n      const seen = new Set();\n      for (const [callback, {\n        consumerHost\n      }] of this.subscriptions) {\n        // Prevent infinite loops in the case where a one host element\n        // is providing the same context multiple times.\n        //\n        // While normally it's a no-op to attempt to re-parent a subscription\n        // that already has its proper parent, in the case where there's more\n        // than one ValueProvider for the same context on the same hostElement,\n        // they will each call the consumer, and since they will each have their\n        // own dispose function, a well behaved consumer will notice the change\n        // in dispose function and call their old one.\n        //\n        // This will cause the subscriptions to thrash, but worse, without this\n        // set check here, we can end up in an infinite loop, as we add and remove\n        // the same subscriptions onto the end of the map over and over.\n        if (seen.has(callback)) {\n          continue;\n        }\n        seen.add(callback);\n        consumerHost.dispatchEvent(new ContextRequestEvent(this.context, callback, true));\n      }\n      ev.stopPropagation();\n    };\n    this.host = host;\n    if (contextOrOptions.context !== undefined) {\n      this.context = contextOrOptions.context;\n    } else {\n      this.context = contextOrOptions;\n    }\n    this.attachListeners();\n    this.host.addController(this);\n  }\n  attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n  hostConnected() {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}","map":{"version":3,"names":["ContextRequestEvent","ValueNotifier","ContextProviderEvent","Event","constructor","context","bubbles","composed","ContextProvider","host","contextOrOptions","initialValue","undefined","onContextRequest","ev","consumerHost","composedPath","stopPropagation","addCallback","callback","subscribe","onProviderRequest","childProviderHost","seen","Set","subscriptions","has","add","dispatchEvent","attachListeners","addController","addEventListener","hostConnected"],"sources":["../../../src/lib/controllers/context-provider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>\n> extends Event {\n  readonly context: C;\n\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  constructor(context: C) {\n    super('context-provider', {bubbles: true, composed: true});\n    this.context = context;\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider<T extends Context<unknown, unknown>>\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  protected readonly host: ReactiveElement;\n  private readonly context: T;\n\n  constructor(host: ReactiveElement, options: Options<T>);\n  /** @deprecated Use new ContextProvider(host, options) */\n  constructor(host: ReactiveElement, context: T, initialValue?: ContextType<T>);\n  constructor(\n    host: ReactiveElement,\n    contextOrOptions: T | Options<T>,\n    initialValue?: ContextType<T>\n  ) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n    this.host.addController(this);\n  }\n\n  onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const consumerHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || consumerHost === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, consumerHost, ev.subscribe);\n  };\n\n  /**\n   * When we get a provider request event, that means a child of this element\n   * has just woken up. If it's a provider of our context, then we may need to\n   * re-parent our subscriptions, because is a more specific provider than us\n   * for its subtree.\n   */\n  onProviderRequest = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ): void => {\n    // Ignore events when the context doesn't match.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context it shouldn't provide to itself.\n    // We use composedPath (as opposed to ev.target) to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const childProviderHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || childProviderHost === this.host) {\n      return;\n    }\n    // Re-parent all of our subscriptions in case this new child provider\n    // should take them over.\n    const seen = new Set<unknown>();\n    for (const [callback, {consumerHost}] of this.subscriptions) {\n      // Prevent infinite loops in the case where a one host element\n      // is providing the same context multiple times.\n      //\n      // While normally it's a no-op to attempt to re-parent a subscription\n      // that already has its proper parent, in the case where there's more\n      // than one ValueProvider for the same context on the same hostElement,\n      // they will each call the consumer, and since they will each have their\n      // own dispose function, a well behaved consumer will notice the change\n      // in dispose function and call their old one.\n      //\n      // This will cause the subscriptions to thrash, but worse, without this\n      // set check here, we can end up in an infinite loop, as we add and remove\n      // the same subscriptions onto the end of the map over and over.\n      if (seen.has(callback)) {\n        continue;\n      }\n      seen.add(callback);\n      consumerHost.dispatchEvent(\n        new ContextRequestEvent(this.context, callback, true)\n      );\n    }\n    ev.stopPropagation();\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}\n"],"mappings":"AAAA;;;;;AAMA,SAAQA,mBAAmB,QAAO,6BAA6B;AAE/D,SAAQC,aAAa,QAAO,sBAAsB;AAalD,OAAM,MAAOC,oBAEX,SAAQC,KAAK;EAGb;;;;EAIAC,YAAYC,OAAU;IACpB,KAAK,CAAC,kBAAkB,EAAE;MAACC,OAAO,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAI,CAAC,CAAC;IAC1D,IAAI,CAACF,OAAO,GAAGA,OAAO;EACxB;;AAQF;;;;;;;;AAQA,OAAM,MAAOG,eACX,SAAQP,aAA6B;EASrCG,YACEK,IAAqB,EACrBC,gBAAgC,EAChCC,YAA6B;IAE7B,KAAK,CACFD,gBAA+B,CAACL,OAAO,KAAKO,SAAS,GACjDF,gBAA+B,CAACC,YAAY,GAC7CA,YAAY,CACjB;IAWH,KAAAE,gBAAgB,GACdC,EAAkD,IAC1C;MACR;MACA;MACA;MACA;MACA;MACA;MACA,MAAMC,YAAY,GAAGD,EAAE,CAACE,YAAY,EAAE,CAAC,CAAC,CAAY;MACpD,IAAIF,EAAE,CAACT,OAAO,KAAK,IAAI,CAACA,OAAO,IAAIU,YAAY,KAAK,IAAI,CAACN,IAAI,EAAE;QAC7D;;MAEFK,EAAE,CAACG,eAAe,EAAE;MACpB,IAAI,CAACC,WAAW,CAACJ,EAAE,CAACK,QAAQ,EAAEJ,YAAY,EAAED,EAAE,CAACM,SAAS,CAAC;IAC3D,CAAC;IAED;;;;;;IAMA,KAAAC,iBAAiB,GACfP,EAAmD,IAC3C;MACR;MACA;MACA;MACA;MACA;MACA;MACA,MAAMQ,iBAAiB,GAAGR,EAAE,CAACE,YAAY,EAAE,CAAC,CAAC,CAAY;MACzD,IAAIF,EAAE,CAACT,OAAO,KAAK,IAAI,CAACA,OAAO,IAAIiB,iBAAiB,KAAK,IAAI,CAACb,IAAI,EAAE;QAClE;;MAEF;MACA;MACA,MAAMc,IAAI,GAAG,IAAIC,GAAG,EAAW;MAC/B,KAAK,MAAM,CAACL,QAAQ,EAAE;QAACJ;MAAY,CAAC,CAAC,IAAI,IAAI,CAACU,aAAa,EAAE;QAC3D;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAIF,IAAI,CAACG,GAAG,CAACP,QAAQ,CAAC,EAAE;UACtB;;QAEFI,IAAI,CAACI,GAAG,CAACR,QAAQ,CAAC;QAClBJ,YAAY,CAACa,aAAa,CACxB,IAAI5B,mBAAmB,CAAC,IAAI,CAACK,OAAO,EAAEc,QAAQ,EAAE,IAAI,CAAC,CACtD;;MAEHL,EAAE,CAACG,eAAe,EAAE;IACtB,CAAC;IAxEC,IAAI,CAACR,IAAI,GAAGA,IAAI;IAChB,IAAKC,gBAA+B,CAACL,OAAO,KAAKO,SAAS,EAAE;MAC1D,IAAI,CAACP,OAAO,GAAIK,gBAA+B,CAACL,OAAO;KACxD,MAAM;MACL,IAAI,CAACA,OAAO,GAAGK,gBAAqB;;IAEtC,IAAI,CAACmB,eAAe,EAAE;IACtB,IAAI,CAACpB,IAAI,CAACqB,aAAa,CAAC,IAAI,CAAC;EAC/B;EAkEQD,eAAeA,CAAA;IACrB,IAAI,CAACpB,IAAI,CAACsB,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAAClB,gBAAgB,CAAC;IACpE,IAAI,CAACJ,IAAI,CAACsB,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAACV,iBAAiB,CAAC;EACxE;EAEAW,aAAaA,CAAA;IACX;IACA,IAAI,CAACvB,IAAI,CAACmB,aAAa,CAAC,IAAI1B,oBAAoB,CAAC,IAAI,CAACG,OAAO,CAAC,CAAC;EACjE"},"metadata":{},"sourceType":"module","externalDependencies":[]}