{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.entries.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport { clear, get, set, createStore, promisifyRequest } from \"idb-keyval\";\nimport { promiseTimeout } from \"../common/util/promise-timeout\";\nimport { iconMetadata } from \"../resources/icon-metadata\";\nexport var iconStore = createStore(\"hass-icon-db\", \"mdi-icon-store\");\nexport var MDI_PREFIXES = [\"mdi\", \"hass\", \"hassio\", \"hademo\"];\nvar toRead = [];\n\n// Queue up as many icon fetches in 1 transaction\nexport var getIcon = function getIcon(iconName) {\n  return new Promise(function (resolve, reject) {\n    toRead.push([iconName, resolve, reject]);\n    if (toRead.length > 1) {\n      return;\n    }\n    var readIcons = function readIcons() {\n      return iconStore(\"readonly\", function (store) {\n        var _loop = function _loop() {\n          var _toRead$_i = _slicedToArray(_toRead[_i], 3),\n            iconName_ = _toRead$_i[0],\n            resolve_ = _toRead$_i[1],\n            reject_ = _toRead$_i[2];\n          promisifyRequest(store.get(iconName_)).then(function (icon) {\n            return resolve_(icon);\n          }).catch(function (e) {\n            return reject_(e);\n          });\n        };\n        for (var _i = 0, _toRead = toRead; _i < _toRead.length; _i++) {\n          _loop();\n        }\n        toRead = [];\n      });\n    };\n    promiseTimeout(1000, readIcons()).catch(function (e) {\n      // Firefox in private mode doesn't support IDB\n      // Safari sometime doesn't open the DB so we time out\n      for (var _i2 = 0, _toRead2 = toRead; _i2 < _toRead2.length; _i2++) {\n        var _toRead2$_i = _slicedToArray(_toRead2[_i2], 3),\n          reject_ = _toRead2$_i[2];\n        reject_(e);\n      }\n      toRead = [];\n    });\n  });\n};\nexport var findIconChunk = function findIconChunk(icon) {\n  var lastChunk;\n  var _iterator = _createForOfIteratorHelper(iconMetadata.parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunk = _step.value;\n      if (chunk.start !== undefined && icon < chunk.start) {\n        break;\n      }\n      lastChunk = chunk;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return lastChunk.file;\n};\nexport var writeCache = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chunks) {\n    var keys, iconsSets;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          keys = Object.keys(chunks);\n          _context.next = 3;\n          return Promise.all(Object.values(chunks));\n        case 3:\n          iconsSets = _context.sent;\n          // We do a batch opening the store just once, for (considerable) performance\n          iconStore(\"readwrite\", function (store) {\n            iconsSets.forEach(function (icons, idx) {\n              Object.entries(icons).forEach(function (_ref2) {\n                var _ref3 = _slicedToArray(_ref2, 2),\n                  name = _ref3[0],\n                  path = _ref3[1];\n                store.put(path, name);\n              });\n              delete chunks[keys[idx]];\n            });\n          });\n        case 5:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function writeCache(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var checkCacheVersion = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var version;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return get(\"_version\", iconStore);\n        case 2:\n          version = _context2.sent;\n          if (version) {\n            _context2.next = 7;\n            break;\n          }\n          set(\"_version\", iconMetadata.version, iconStore);\n          _context2.next = 11;\n          break;\n        case 7:\n          if (!(version !== iconMetadata.version)) {\n            _context2.next = 11;\n            break;\n          }\n          _context2.next = 10;\n          return clear(iconStore);\n        case 10:\n          set(\"_version\", iconMetadata.version, iconStore);\n        case 11:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function checkCacheVersion() {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["clear","get","set","createStore","promisifyRequest","promiseTimeout","iconMetadata","iconStore","MDI_PREFIXES","toRead","getIcon","iconName","Promise","resolve","reject","push","length","readIcons","store","_loop","_toRead$_i","_slicedToArray","_toRead","_i","iconName_","resolve_","reject_","then","icon","catch","e","_i2","_toRead2","_toRead2$_i","findIconChunk","lastChunk","_iterator","_createForOfIteratorHelper","parts","_step","s","n","done","chunk","value","start","undefined","err","f","file","writeCache","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","chunks","keys","iconsSets","wrap","_callee$","_context","prev","next","Object","all","values","sent","forEach","icons","idx","entries","_ref2","_ref3","name","path","put","stop","_x","apply","arguments","checkCacheVersion","_ref4","_callee2","version","_callee2$","_context2"],"sources":["/workspaces/frontend/src/data/iconsets.ts"],"sourcesContent":["import { clear, get, set, createStore, promisifyRequest } from \"idb-keyval\";\nimport { promiseTimeout } from \"../common/util/promise-timeout\";\nimport { iconMetadata } from \"../resources/icon-metadata\";\nimport { IconMeta } from \"../types\";\n\nexport interface Icons {\n  [key: string]: string;\n}\n\nexport interface Chunks {\n  [key: string]: Promise<Icons>;\n}\n\nexport const iconStore = createStore(\"hass-icon-db\", \"mdi-icon-store\");\n\nexport const MDI_PREFIXES = [\"mdi\", \"hass\", \"hassio\", \"hademo\"];\n\nlet toRead: Array<\n  [string, (iconPath: string | undefined) => void, (e: any) => void]\n> = [];\n\n// Queue up as many icon fetches in 1 transaction\nexport const getIcon = (iconName: string) =>\n  new Promise<string | undefined>((resolve, reject) => {\n    toRead.push([iconName, resolve, reject]);\n\n    if (toRead.length > 1) {\n      return;\n    }\n\n    const readIcons = () =>\n      iconStore(\"readonly\", (store) => {\n        for (const [iconName_, resolve_, reject_] of toRead) {\n          promisifyRequest<string | undefined>(store.get(iconName_))\n            .then((icon) => resolve_(icon))\n            .catch((e) => reject_(e));\n        }\n        toRead = [];\n      });\n\n    promiseTimeout(1000, readIcons()).catch((e) => {\n      // Firefox in private mode doesn't support IDB\n      // Safari sometime doesn't open the DB so we time out\n      for (const [, , reject_] of toRead) {\n        reject_(e);\n      }\n      toRead = [];\n    });\n  });\n\nexport const findIconChunk = (icon: string): string => {\n  let lastChunk: IconMeta;\n  for (const chunk of iconMetadata.parts) {\n    if (chunk.start !== undefined && icon < chunk.start) {\n      break;\n    }\n    lastChunk = chunk;\n  }\n  return lastChunk!.file;\n};\n\nexport const writeCache = async (chunks: Chunks) => {\n  const keys = Object.keys(chunks);\n  const iconsSets: Icons[] = await Promise.all(Object.values(chunks));\n  // We do a batch opening the store just once, for (considerable) performance\n  iconStore(\"readwrite\", (store) => {\n    iconsSets.forEach((icons, idx) => {\n      Object.entries(icons).forEach(([name, path]) => {\n        store.put(path, name);\n      });\n      delete chunks[keys[idx]];\n    });\n  });\n};\n\nexport const checkCacheVersion = async () => {\n  const version = await get(\"_version\", iconStore);\n\n  if (!version) {\n    set(\"_version\", iconMetadata.version, iconStore);\n  } else if (version !== iconMetadata.version) {\n    await clear(iconStore);\n    set(\"_version\", iconMetadata.version, iconStore);\n  }\n};\n"],"mappings":";;;;;;;;;;;;;;;;AAAA,SAASA,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAEC,WAAW,EAAEC,gBAAgB,QAAQ,YAAY;AAC3E,SAASC,cAAc,QAAQ,gCAAgC;AAC/D,SAASC,YAAY,QAAQ,4BAA4B;AAWzD,OAAO,IAAMC,SAAS,GAAGJ,WAAW,CAAC,cAAc,EAAE,gBAAgB,CAAC;AAEtE,OAAO,IAAMK,YAAY,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAC;AAE/D,IAAIC,MAEH,GAAG,EAAE;;AAEN;AACA,OAAO,IAAMC,OAAO,GAAG,SAAVA,OAAOA,CAAIC,QAAgB;EAAA,OACtC,IAAIC,OAAO,CAAqB,UAACC,OAAO,EAAEC,MAAM,EAAK;IACnDL,MAAM,CAACM,IAAI,CAAC,CAACJ,QAAQ,EAAEE,OAAO,EAAEC,MAAM,CAAC,CAAC;IAExC,IAAIL,MAAM,CAACO,MAAM,GAAG,CAAC,EAAE;MACrB;IACF;IAEA,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAA;MAAA,OACbV,SAAS,CAAC,UAAU,EAAE,UAACW,KAAK,EAAK;QAAA,IAAAC,KAAA,YAAAA,MAAA,EACsB;UAAhD,IAAAC,UAAA,GAAAC,cAAA,CAAAC,OAAA,CAAAC,EAAA;YAAOC,SAAS,GAAAJ,UAAA;YAAEK,QAAQ,GAAAL,UAAA;YAAEM,OAAO,GAAAN,UAAA;UACtChB,gBAAgB,CAAqBc,KAAK,CAACjB,GAAG,CAACuB,SAAS,CAAC,CAAC,CACvDG,IAAI,CAAC,UAACC,IAAI;YAAA,OAAKH,QAAQ,CAACG,IAAI,CAAC;UAAA,EAAC,CAC9BC,KAAK,CAAC,UAACC,CAAC;YAAA,OAAKJ,OAAO,CAACI,CAAC,CAAC;UAAA,EAAC;QAC7B,CAAC;QAJD,SAAAP,EAAA,MAAAD,OAAA,GAA6Cb,MAAM,EAAAc,EAAA,GAAAD,OAAA,CAAAN,MAAA,EAAAO,EAAA;UAAAJ,KAAA;QAAA;QAKnDV,MAAM,GAAG,EAAE;MACb,CAAC,CAAC;IAAA;IAEJJ,cAAc,CAAC,IAAI,EAAEY,SAAS,CAAC,CAAC,CAAC,CAACY,KAAK,CAAC,UAACC,CAAC,EAAK;MAC7C;MACA;MACA,SAAAC,GAAA,MAAAC,QAAA,GAA4BvB,MAAM,EAAAsB,GAAA,GAAAC,QAAA,CAAAhB,MAAA,EAAAe,GAAA,IAAE;QAA/B,IAAAE,WAAA,GAAAZ,cAAA,CAAAW,QAAA,CAAAD,GAAA;UAAWL,OAAO,GAAAO,WAAA;QACrBP,OAAO,CAACI,CAAC,CAAC;MACZ;MACArB,MAAM,GAAG,EAAE;IACb,CAAC,CAAC;EACJ,CAAC,CAAC;AAAA;AAEJ,OAAO,IAAMyB,aAAa,GAAG,SAAhBA,aAAaA,CAAIN,IAAY,EAAa;EACrD,IAAIO,SAAmB;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACJ/B,YAAY,CAACgC,KAAK;IAAAC,KAAA;EAAA;IAAtC,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAAwC;MAAA,IAA7BC,KAAK,GAAAJ,KAAA,CAAAK,KAAA;MACd,IAAID,KAAK,CAACE,KAAK,KAAKC,SAAS,IAAIlB,IAAI,GAAGe,KAAK,CAACE,KAAK,EAAE;QACnD;MACF;MACAV,SAAS,GAAGQ,KAAK;IACnB;EAAC,SAAAI,GAAA;IAAAX,SAAA,CAAAN,CAAA,CAAAiB,GAAA;EAAA;IAAAX,SAAA,CAAAY,CAAA;EAAA;EACD,OAAOb,SAAS,CAAEc,IAAI;AACxB,CAAC;AAED,OAAO,IAAMC,UAAU;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAAOC,MAAc;IAAA,IAAAC,IAAA,EAAAC,SAAA;IAAA,OAAAL,mBAAA,GAAAM,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UACvCN,IAAI,GAAGO,MAAM,CAACP,IAAI,CAACD,MAAM,CAAC;UAAAK,QAAA,CAAAE,IAAA;UAAA,OACCnD,OAAO,CAACqD,GAAG,CAACD,MAAM,CAACE,MAAM,CAACV,MAAM,CAAC,CAAC;QAAA;UAA7DE,SAAkB,GAAAG,QAAA,CAAAM,IAAA;UACxB;UACA5D,SAAS,CAAC,WAAW,EAAE,UAACW,KAAK,EAAK;YAChCwC,SAAS,CAACU,OAAO,CAAC,UAACC,KAAK,EAAEC,GAAG,EAAK;cAChCN,MAAM,CAACO,OAAO,CAACF,KAAK,CAAC,CAACD,OAAO,CAAC,UAAAI,KAAA,EAAkB;gBAAA,IAAAC,KAAA,GAAApD,cAAA,CAAAmD,KAAA;kBAAhBE,IAAI,GAAAD,KAAA;kBAAEE,IAAI,GAAAF,KAAA;gBACxCvD,KAAK,CAAC0D,GAAG,CAACD,IAAI,EAAED,IAAI,CAAC;cACvB,CAAC,CAAC;cACF,OAAOlB,MAAM,CAACC,IAAI,CAACa,GAAG,CAAC,CAAC;YAC1B,CAAC,CAAC;UACJ,CAAC,CAAC;QAAC;QAAA;UAAA,OAAAT,QAAA,CAAAgB,IAAA;MAAA;IAAA,GAAAtB,OAAA;EAAA,CACJ;EAAA,gBAZYL,UAAUA,CAAA4B,EAAA;IAAA,OAAA3B,IAAA,CAAA4B,KAAA,OAAAC,SAAA;EAAA;AAAA,GAYtB;AAED,OAAO,IAAMC,iBAAiB;EAAA,IAAAC,KAAA,GAAA9B,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAA6B,SAAA;IAAA,IAAAC,OAAA;IAAA,OAAA/B,mBAAA,GAAAM,IAAA,UAAA0B,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAxB,IAAA,GAAAwB,SAAA,CAAAvB,IAAA;QAAA;UAAAuB,SAAA,CAAAvB,IAAA;UAAA,OACT9D,GAAG,CAAC,UAAU,EAAEM,SAAS,CAAC;QAAA;UAA1C6E,OAAO,GAAAE,SAAA,CAAAnB,IAAA;UAAA,IAERiB,OAAO;YAAAE,SAAA,CAAAvB,IAAA;YAAA;UAAA;UACV7D,GAAG,CAAC,UAAU,EAAEI,YAAY,CAAC8E,OAAO,EAAE7E,SAAS,CAAC;UAAC+E,SAAA,CAAAvB,IAAA;UAAA;QAAA;UAAA,MACxCqB,OAAO,KAAK9E,YAAY,CAAC8E,OAAO;YAAAE,SAAA,CAAAvB,IAAA;YAAA;UAAA;UAAAuB,SAAA,CAAAvB,IAAA;UAAA,OACnC/D,KAAK,CAACO,SAAS,CAAC;QAAA;UACtBL,GAAG,CAAC,UAAU,EAAEI,YAAY,CAAC8E,OAAO,EAAE7E,SAAS,CAAC;QAAC;QAAA;UAAA,OAAA+E,SAAA,CAAAT,IAAA;MAAA;IAAA,GAAAM,QAAA;EAAA,CAEpD;EAAA,gBATYF,iBAAiBA,CAAA;IAAA,OAAAC,KAAA,CAAAH,KAAA,OAAAC,SAAA;EAAA;AAAA,GAS7B"},"metadata":{},"sourceType":"module","externalDependencies":[]}