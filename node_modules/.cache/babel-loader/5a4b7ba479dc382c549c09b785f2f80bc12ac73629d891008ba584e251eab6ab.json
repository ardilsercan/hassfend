{"ast":null,"code":"import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _templateObject;\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { isToday } from \"date-fns\";\nimport { css, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { setupLeafletMap } from \"../../common/dom/setup-leaflet-map\";\nimport { formatTimeWithSeconds, formatTimeWeekday } from \"../../common/datetime/format_time\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { loadPolyfillIfNeeded } from \"../../resources/resize-observer.polyfill\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\nimport { isTouch } from \"../../util/is_touch\";\nvar getEntityId = function getEntityId(entity) {\n  return typeof entity === \"string\" ? entity : entity.entity_id;\n};\nexport var HaMap = _decorate([customElement(\"ha-map\")], function (_initialize, _ReactiveElement) {\n  var HaMap = /*#__PURE__*/function (_ReactiveElement2) {\n    _inherits(HaMap, _ReactiveElement2);\n    function HaMap() {\n      var _this;\n      _classCallCheck(this, HaMap);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, HaMap, [].concat(args));\n      _initialize(_assertThisInitialized(_this));\n      return _this;\n    }\n    return _createClass(HaMap);\n  }(_ReactiveElement);\n  return {\n    F: HaMap,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"entities\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"paths\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"layers\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"autoFit\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"renderPassive\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"interactiveZones\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"fitZones\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"darkMode\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"zoom\",\n      value: function value() {\n        return 14;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_loaded\",\n      value: function value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"leafletMap\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"Leaflet\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_resizeObserver\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_mapItems\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapFocusItems\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapZones\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapPaths\",\n      value: function value() {\n        return [];\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HaMap.prototype), \"connectedCallback\", this).call(this);\n        this._loadMap();\n        this._attachObserver();\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaMap.prototype), \"disconnectedCallback\", this).call(this);\n        if (this.leafletMap) {\n          this.leafletMap.remove();\n          this.leafletMap = undefined;\n          this.Leaflet = undefined;\n        }\n        this._loaded = false;\n        if (this._resizeObserver) {\n          this._resizeObserver.unobserve(this);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"update\",\n      value: function update(changedProps) {\n        var _oldHass$themes, _this$hass$themes;\n        _get(_getPrototypeOf(HaMap.prototype), \"update\", this).call(this, changedProps);\n        if (!this._loaded) {\n          return;\n        }\n        var autoFitRequired = false;\n        var oldHass = changedProps.get(\"hass\");\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n          this._drawEntities();\n          autoFitRequired = true;\n        } else if (this._loaded && oldHass && this.entities) {\n          // Check if any state has changed\n          var _iterator = _createForOfIteratorHelper(this.entities),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var entity = _step.value;\n              if (oldHass.states[getEntityId(entity)] !== this.hass.states[getEntityId(entity)]) {\n                this._drawEntities();\n                autoFitRequired = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n          this._drawPaths();\n        }\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n          this._drawLayers(changedProps.get(\"layers\"));\n          autoFitRequired = true;\n        }\n        if (changedProps.has(\"_loaded\") || this.autoFit && autoFitRequired) {\n          this.fitMap();\n        }\n        if (changedProps.has(\"zoom\")) {\n          this.leafletMap.setZoom(this.zoom);\n        }\n        if (!changedProps.has(\"darkMode\") && (!changedProps.has(\"hass\") || oldHass && ((_oldHass$themes = oldHass.themes) === null || _oldHass$themes === void 0 ? void 0 : _oldHass$themes.darkMode) === ((_this$hass$themes = this.hass.themes) === null || _this$hass$themes === void 0 ? void 0 : _this$hass$themes.darkMode))) {\n          return;\n        }\n        this._updateMapStyle();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_updateMapStyle\",\n      value: function _updateMapStyle() {\n        var _this$hass$themes$dar;\n        var darkMode = this.darkMode || ((_this$hass$themes$dar = this.hass.themes.darkMode) !== null && _this$hass$themes$dar !== void 0 ? _this$hass$themes$dar : false);\n        var forcedDark = this.darkMode;\n        var map = this.renderRoot.querySelector(\"#map\");\n        map.classList.toggle(\"dark\", darkMode);\n        map.classList.toggle(\"forced-dark\", forcedDark);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_loadMap\",\n      value: function () {\n        var _loadMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          var map, _yield$setupLeafletMa, _yield$setupLeafletMa2;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                map = this.shadowRoot.getElementById(\"map\");\n                if (!map) {\n                  map = document.createElement(\"div\");\n                  map.id = \"map\";\n                  this.shadowRoot.append(map);\n                }\n                _context.next = 4;\n                return setupLeafletMap(map);\n              case 4:\n                _yield$setupLeafletMa = _context.sent;\n                _yield$setupLeafletMa2 = _slicedToArray(_yield$setupLeafletMa, 2);\n                this.leafletMap = _yield$setupLeafletMa2[0];\n                this.Leaflet = _yield$setupLeafletMa2[1];\n                this._updateMapStyle();\n                this._loaded = true;\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, this);\n        }));\n        function _loadMap() {\n          return _loadMap2.apply(this, arguments);\n        }\n        return _loadMap;\n      }()\n    }, {\n      kind: \"method\",\n      key: \"fitMap\",\n      value: function fitMap(options) {\n        var _this$layers, _this$layers2, _options$pad;\n        if (!this.leafletMap || !this.Leaflet || !this.hass) {\n          return;\n        }\n        if (!this._mapFocusItems.length && !((_this$layers = this.layers) !== null && _this$layers !== void 0 && _this$layers.length)) {\n          this.leafletMap.setView(new this.Leaflet.LatLng(this.hass.config.latitude, this.hass.config.longitude), (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom);\n          return;\n        }\n        var bounds = this.Leaflet.latLngBounds(this._mapFocusItems ? this._mapFocusItems.map(function (item) {\n          return item.getLatLng();\n        }) : []);\n        if (this.fitZones) {\n          var _this$_mapZones;\n          (_this$_mapZones = this._mapZones) === null || _this$_mapZones === void 0 || _this$_mapZones.forEach(function (zone) {\n            bounds.extend(\"getBounds\" in zone ? zone.getBounds() : zone.getLatLng());\n          });\n        }\n        (_this$layers2 = this.layers) === null || _this$layers2 === void 0 || _this$layers2.forEach(function (layer) {\n          bounds.extend(\"getBounds\" in layer ? layer.getBounds() : layer.getLatLng());\n        });\n        bounds = bounds.pad((_options$pad = options === null || options === void 0 ? void 0 : options.pad) !== null && _options$pad !== void 0 ? _options$pad : 0.5);\n        this.leafletMap.fitBounds(bounds, {\n          maxZoom: (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"fitBounds\",\n      value: function fitBounds(boundingbox, options) {\n        var _options$pad2;\n        if (!this.leafletMap || !this.Leaflet || !this.hass) {\n          return;\n        }\n        var bounds = this.Leaflet.latLngBounds(boundingbox).pad((_options$pad2 = options === null || options === void 0 ? void 0 : options.pad) !== null && _options$pad2 !== void 0 ? _options$pad2 : 0.5);\n        this.leafletMap.fitBounds(bounds, {\n          maxZoom: (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawLayers\",\n      value: function _drawLayers(prevLayers) {\n        if (prevLayers) {\n          prevLayers.forEach(function (layer) {\n            return layer.remove();\n          });\n        }\n        if (!this.layers) {\n          return;\n        }\n        var map = this.leafletMap;\n        this.layers.forEach(function (layer) {\n          map.addLayer(layer);\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_computePathTooltip\",\n      value: function _computePathTooltip(path, point) {\n        var formattedTime;\n        if (path.fullDatetime) {\n          formattedTime = formatDateTime(point.timestamp, this.hass.locale, this.hass.config);\n        } else if (isToday(point.timestamp)) {\n          formattedTime = formatTimeWithSeconds(point.timestamp, this.hass.locale, this.hass.config);\n        } else {\n          formattedTime = formatTimeWeekday(point.timestamp, this.hass.locale, this.hass.config);\n        }\n        return \"\".concat(path.name, \"<br>\").concat(formattedTime);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawPaths\",\n      value: function _drawPaths() {\n        var _this2 = this;\n        var hass = this.hass;\n        var map = this.leafletMap;\n        var Leaflet = this.Leaflet;\n        if (!hass || !map || !Leaflet) {\n          return;\n        }\n        if (this._mapPaths.length) {\n          this._mapPaths.forEach(function (marker) {\n            return marker.remove();\n          });\n          this._mapPaths = [];\n        }\n        if (!this.paths) {\n          return;\n        }\n        var darkPrimaryColor = getComputedStyle(this).getPropertyValue(\"--dark-primary-color\");\n        this.paths.forEach(function (path) {\n          var opacityStep;\n          var baseOpacity;\n          if (path.gradualOpacity) {\n            opacityStep = path.gradualOpacity / (path.points.length - 2);\n            baseOpacity = 1 - path.gradualOpacity;\n          }\n          for (var _pointIndex = 0; _pointIndex < path.points.length - 1; _pointIndex++) {\n            var opacity = path.gradualOpacity ? baseOpacity + _pointIndex * opacityStep : undefined;\n\n            // DRAW point\n            _this2._mapPaths.push(Leaflet.circleMarker(path.points[_pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity: opacity,\n              fillOpacity: opacity,\n              interactive: true\n            }).bindTooltip(_this2._computePathTooltip(path, path.points[_pointIndex]), {\n              direction: \"top\"\n            }));\n\n            // DRAW line between this and next point\n            _this2._mapPaths.push(Leaflet.polyline([path.points[_pointIndex].point, path.points[_pointIndex + 1].point], {\n              color: path.color || darkPrimaryColor,\n              opacity: opacity,\n              interactive: false\n            }));\n          }\n          var pointIndex = path.points.length - 1;\n          if (pointIndex >= 0) {\n            var _opacity = path.gradualOpacity ? baseOpacity + pointIndex * opacityStep : undefined;\n            // DRAW end path point\n            _this2._mapPaths.push(Leaflet.circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity: _opacity,\n              fillOpacity: _opacity,\n              interactive: true\n            }).bindTooltip(_this2._computePathTooltip(path, path.points[pointIndex]), {\n              direction: \"top\"\n            }));\n          }\n          _this2._mapPaths.forEach(function (marker) {\n            return map.addLayer(marker);\n          });\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawEntities\",\n      value: function _drawEntities() {\n        var hass = this.hass;\n        var map = this.leafletMap;\n        var Leaflet = this.Leaflet;\n        if (!hass || !map || !Leaflet) {\n          return;\n        }\n        if (this._mapItems.length) {\n          this._mapItems.forEach(function (marker) {\n            return marker.remove();\n          });\n          this._mapItems = [];\n          this._mapFocusItems = [];\n        }\n        if (this._mapZones.length) {\n          this._mapZones.forEach(function (marker) {\n            return marker.remove();\n          });\n          this._mapZones = [];\n        }\n        if (!this.entities) {\n          return;\n        }\n        var computedStyles = getComputedStyle(this);\n        var zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n        var passiveZoneColor = computedStyles.getPropertyValue(\"--secondary-text-color\");\n        var darkPrimaryColor = computedStyles.getPropertyValue(\"--dark-primary-color\");\n        var className = this.darkMode || this.hass.themes.darkMode ? \"dark\" : \"light\";\n        var _iterator2 = _createForOfIteratorHelper(this.entities),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var entity = _step2.value;\n            var stateObj = hass.states[getEntityId(entity)];\n            if (!stateObj) {\n              continue;\n            }\n            var customTitle = typeof entity !== \"string\" ? entity.name : undefined;\n            var title = customTitle !== null && customTitle !== void 0 ? customTitle : computeStateName(stateObj);\n            var _stateObj$attributes = stateObj.attributes,\n              latitude = _stateObj$attributes.latitude,\n              longitude = _stateObj$attributes.longitude,\n              passive = _stateObj$attributes.passive,\n              icon = _stateObj$attributes.icon,\n              radius = _stateObj$attributes.radius,\n              entityPicture = _stateObj$attributes.entity_picture,\n              gpsAccuracy = _stateObj$attributes.gps_accuracy;\n            if (!(latitude && longitude)) {\n              continue;\n            }\n            if (computeStateDomain(stateObj) === \"zone\") {\n              // DRAW ZONE\n              if (passive && !this.renderPassive) {\n                continue;\n              }\n\n              // create icon\n              var iconHTML = \"\";\n              if (icon) {\n                var el = document.createElement(\"ha-icon\");\n                el.setAttribute(\"icon\", icon);\n                iconHTML = el.outerHTML;\n              } else {\n                var _el = document.createElement(\"span\");\n                _el.innerHTML = title;\n                iconHTML = _el.outerHTML;\n              }\n\n              // create marker with the icon\n              this._mapZones.push(Leaflet.marker([latitude, longitude], {\n                icon: Leaflet.divIcon({\n                  html: iconHTML,\n                  iconSize: [24, 24],\n                  className: className\n                }),\n                interactive: this.interactiveZones,\n                title: title\n              }));\n\n              // create circle around it\n              this._mapZones.push(Leaflet.circle([latitude, longitude], {\n                interactive: false,\n                color: passive ? passiveZoneColor : zoneColor,\n                radius: radius\n              }));\n              continue;\n            }\n\n            // DRAW ENTITY\n            // create icon\n            var entityName = typeof entity !== \"string\" && entity.label_mode === \"state\" ? this.hass.formatEntityState(stateObj) : customTitle !== null && customTitle !== void 0 ? customTitle : title.split(\" \").map(function (part) {\n              return part[0];\n            }).join(\"\").substr(0, 3);\n\n            // create marker with the icon\n            var marker = Leaflet.marker([latitude, longitude], {\n              icon: Leaflet.divIcon({\n                html: \"\\n              <ha-entity-marker\\n                entity-id=\\\"\".concat(getEntityId(entity), \"\\\"\\n                entity-name=\\\"\").concat(entityName, \"\\\"\\n                entity-picture=\\\"\").concat(entityPicture ? this.hass.hassUrl(entityPicture) : \"\", \"\\\"\\n                \").concat(typeof entity !== \"string\" ? \"entity-color=\\\"\".concat(entity.color, \"\\\"\") : \"\", \"\\n              ></ha-entity-marker>\\n            \"),\n                iconSize: [48, 48],\n                className: \"\"\n              }),\n              title: title\n            });\n            this._mapItems.push(marker);\n            if (typeof entity === \"string\" || entity.focus !== false) {\n              this._mapFocusItems.push(marker);\n            }\n\n            // create circle around if entity has accuracy\n            if (gpsAccuracy) {\n              this._mapItems.push(Leaflet.circle([latitude, longitude], {\n                interactive: false,\n                color: darkPrimaryColor,\n                radius: gpsAccuracy\n              }));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this._mapItems.forEach(function (marker) {\n          return map.addLayer(marker);\n        });\n        this._mapZones.forEach(function (marker) {\n          return map.addLayer(marker);\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_attachObserver\",\n      value: function () {\n        var _attachObserver2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var _this3 = this;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._resizeObserver) {\n                  _context2.next = 4;\n                  break;\n                }\n                _context2.next = 3;\n                return loadPolyfillIfNeeded();\n              case 3:\n                this._resizeObserver = new ResizeObserver(function () {\n                  var _this3$leafletMap;\n                  (_this3$leafletMap = _this3.leafletMap) === null || _this3$leafletMap === void 0 || _this3$leafletMap.invalidateSize({\n                    debounceMoveend: true\n                  });\n                });\n              case 4:\n                this._resizeObserver.observe(this);\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2, this);\n        }));\n        function _attachObserver() {\n          return _attachObserver2.apply(this, arguments);\n        }\n        return _attachObserver;\n      }()\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      :host {\\n        display: block;\\n        height: 300px;\\n      }\\n      #map {\\n        height: 100%;\\n      }\\n      #map.dark {\\n        background: #090909;\\n      }\\n      #map.forced-dark {\\n        --map-filter: invert(0.9) hue-rotate(170deg) brightness(1.5)\\n          contrast(1.2) saturate(0.3);\\n      }\\n      #map:active {\\n        cursor: grabbing;\\n        cursor: -moz-grabbing;\\n        cursor: -webkit-grabbing;\\n      }\\n      .light {\\n        color: #000000;\\n      }\\n      .dark {\\n        color: #ffffff;\\n      }\\n      .leaflet-tile-pane {\\n        filter: var(--map-filter);\\n      }\\n      .dark .leaflet-bar a {\\n        background-color: var(--card-background-color, #1c1c1c);\\n        color: #ffffff;\\n      }\\n      .leaflet-marker-draggable {\\n        cursor: move !important;\\n      }\\n      .leaflet-edit-resize {\\n        border-radius: 50%;\\n        cursor: nesw-resize !important;\\n      }\\n      .named-icon {\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n        flex-direction: column;\\n        text-align: center;\\n        color: var(--primary-text-color);\\n      }\\n      .leaflet-pane {\\n        z-index: 0 !important;\\n      }\\n      .leaflet-control,\\n      .leaflet-top,\\n      .leaflet-bottom {\\n        z-index: 1 !important;\\n      }\\n      .leaflet-tooltip {\\n        padding: 8px;\\n        font-size: 90%;\\n        background: rgba(80, 80, 80, 0.9) !important;\\n        color: white !important;\\n        border-radius: 4px;\\n        box-shadow: none !important;\\n        text-align: center;\\n      }\\n    \"])));\n      }\n    }]\n  };\n}, ReactiveElement);","map":{"version":3,"names":["isToday","css","ReactiveElement","customElement","property","state","setupLeafletMap","formatTimeWithSeconds","formatTimeWeekday","formatDateTime","computeStateDomain","computeStateName","loadPolyfillIfNeeded","isTouch","getEntityId","entity","entity_id","HaMap","_decorate","_initialize","_ReactiveElement","_ReactiveElement2","_inherits","_this","_classCallCheck","_len","arguments","length","args","Array","_key","_callSuper","concat","_assertThisInitialized","_createClass","F","d","kind","decorators","attribute","key","value","type","Boolean","Number","connectedCallback","_get","_getPrototypeOf","prototype","call","_loadMap","_attachObserver","disconnectedCallback","leafletMap","remove","undefined","Leaflet","_loaded","_resizeObserver","unobserve","update","changedProps","_oldHass$themes","_this$hass$themes","autoFitRequired","oldHass","get","has","_drawEntities","entities","_iterator","_createForOfIteratorHelper","_step","s","n","done","states","hass","err","e","f","_drawPaths","_drawLayers","autoFit","fitMap","setZoom","zoom","themes","darkMode","_updateMapStyle","_this$hass$themes$dar","forcedDark","map","renderRoot","querySelector","classList","toggle","_loadMap2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_yield$setupLeafletMa","_yield$setupLeafletMa2","wrap","_callee$","_context","prev","next","shadowRoot","getElementById","document","createElement","id","append","sent","_slicedToArray","stop","apply","options","_this$layers","_this$layers2","_options$pad","_mapFocusItems","layers","setView","LatLng","config","latitude","longitude","bounds","latLngBounds","item","getLatLng","fitZones","_this$_mapZones","_mapZones","forEach","zone","extend","getBounds","layer","pad","fitBounds","maxZoom","boundingbox","_options$pad2","prevLayers","addLayer","_computePathTooltip","path","point","formattedTime","fullDatetime","timestamp","locale","name","_this2","_mapPaths","marker","paths","darkPrimaryColor","getComputedStyle","getPropertyValue","opacityStep","baseOpacity","gradualOpacity","points","pointIndex","opacity","push","circleMarker","radius","color","fillOpacity","interactive","bindTooltip","direction","polyline","_mapItems","computedStyles","zoneColor","passiveZoneColor","className","_iterator2","_step2","stateObj","customTitle","title","_stateObj$attributes","attributes","passive","icon","entityPicture","entity_picture","gpsAccuracy","gps_accuracy","renderPassive","iconHTML","el","setAttribute","outerHTML","innerHTML","divIcon","html","iconSize","interactiveZones","circle","entityName","label_mode","formatEntityState","split","part","join","substr","hassUrl","focus","_attachObserver2","_callee2","_this3","_callee2$","_context2","ResizeObserver","_this3$leafletMap","invalidateSize","debounceMoveend","observe","static","styles","_templateObject","_taggedTemplateLiteral"],"sources":["/workspaces/frontend/src/components/map/ha-map.ts"],"sourcesContent":["import type {\n  Circle,\n  CircleMarker,\n  LatLngTuple,\n  LatLngExpression,\n  Layer,\n  Map,\n  Marker,\n  Polyline,\n} from \"leaflet\";\nimport { isToday } from \"date-fns\";\nimport { css, CSSResultGroup, PropertyValues, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport {\n  LeafletModuleType,\n  setupLeafletMap,\n} from \"../../common/dom/setup-leaflet-map\";\nimport {\n  formatTimeWithSeconds,\n  formatTimeWeekday,\n} from \"../../common/datetime/format_time\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { loadPolyfillIfNeeded } from \"../../resources/resize-observer.polyfill\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\nimport { isTouch } from \"../../util/is_touch\";\n\nconst getEntityId = (entity: string | HaMapEntity): string =>\n  typeof entity === \"string\" ? entity : entity.entity_id;\n\nexport interface HaMapPathPoint {\n  point: LatLngTuple;\n  timestamp: Date;\n}\nexport interface HaMapPaths {\n  points: HaMapPathPoint[];\n  color?: string;\n  name?: string;\n  gradualOpacity?: number;\n  fullDatetime?: boolean;\n}\n\nexport interface HaMapEntity {\n  entity_id: string;\n  color: string;\n  label_mode?: \"name\" | \"state\";\n  name?: string;\n  focus?: boolean;\n}\n\n@customElement(\"ha-map\")\nexport class HaMap extends ReactiveElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entities?: string[] | HaMapEntity[];\n\n  @property({ attribute: false }) public paths?: HaMapPaths[];\n\n  @property({ attribute: false }) public layers?: Layer[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Boolean }) public renderPassive = false;\n\n  @property({ type: Boolean }) public interactiveZones = false;\n\n  @property({ type: Boolean }) public fitZones = false;\n\n  @property({ type: Boolean }) public darkMode = false;\n\n  @property({ type: Number }) public zoom = 14;\n\n  @state() private _loaded = false;\n\n  public leafletMap?: Map;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _resizeObserver?: ResizeObserver;\n\n  private _mapItems: Array<Marker | Circle> = [];\n\n  private _mapFocusItems: Array<Marker | Circle> = [];\n\n  private _mapZones: Array<Marker | Circle> = [];\n\n  private _mapPaths: Array<Polyline | CircleMarker> = [];\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._loadMap();\n    this._attachObserver();\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    if (this.leafletMap) {\n      this.leafletMap.remove();\n      this.leafletMap = undefined;\n      this.Leaflet = undefined;\n    }\n\n    this._loaded = false;\n\n    if (this._resizeObserver) {\n      this._resizeObserver.unobserve(this);\n    }\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    if (!this._loaded) {\n      return;\n    }\n    let autoFitRequired = false;\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n      this._drawEntities();\n      autoFitRequired = true;\n    } else if (this._loaded && oldHass && this.entities) {\n      // Check if any state has changed\n      for (const entity of this.entities) {\n        if (\n          oldHass.states[getEntityId(entity)] !==\n          this.hass!.states[getEntityId(entity)]\n        ) {\n          this._drawEntities();\n          autoFitRequired = true;\n          break;\n        }\n      }\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n      this._drawPaths();\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n      this._drawLayers(changedProps.get(\"layers\") as Layer[] | undefined);\n      autoFitRequired = true;\n    }\n\n    if (changedProps.has(\"_loaded\") || (this.autoFit && autoFitRequired)) {\n      this.fitMap();\n    }\n\n    if (changedProps.has(\"zoom\")) {\n      this.leafletMap!.setZoom(this.zoom);\n    }\n\n    if (\n      !changedProps.has(\"darkMode\") &&\n      (!changedProps.has(\"hass\") ||\n        (oldHass && oldHass.themes?.darkMode === this.hass.themes?.darkMode))\n    ) {\n      return;\n    }\n    this._updateMapStyle();\n  }\n\n  private _updateMapStyle(): void {\n    const darkMode = this.darkMode || (this.hass.themes.darkMode ?? false);\n    const forcedDark = this.darkMode;\n    const map = this.renderRoot.querySelector(\"#map\");\n    map!.classList.toggle(\"dark\", darkMode);\n    map!.classList.toggle(\"forced-dark\", forcedDark);\n  }\n\n  private async _loadMap(): Promise<void> {\n    let map = this.shadowRoot!.getElementById(\"map\");\n    if (!map) {\n      map = document.createElement(\"div\");\n      map.id = \"map\";\n      this.shadowRoot!.append(map);\n    }\n    [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n    this._updateMapStyle();\n    this._loaded = true;\n  }\n\n  public fitMap(options?: { zoom?: number; pad?: number }): void {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n\n    if (!this._mapFocusItems.length && !this.layers?.length) {\n      this.leafletMap.setView(\n        new this.Leaflet.LatLng(\n          this.hass.config.latitude,\n          this.hass.config.longitude\n        ),\n        options?.zoom || this.zoom\n      );\n      return;\n    }\n\n    let bounds = this.Leaflet.latLngBounds(\n      this._mapFocusItems\n        ? this._mapFocusItems.map((item) => item.getLatLng())\n        : []\n    );\n\n    if (this.fitZones) {\n      this._mapZones?.forEach((zone) => {\n        bounds.extend(\n          \"getBounds\" in zone ? zone.getBounds() : zone.getLatLng()\n        );\n      });\n    }\n\n    this.layers?.forEach((layer: any) => {\n      bounds.extend(\n        \"getBounds\" in layer ? layer.getBounds() : layer.getLatLng()\n      );\n    });\n\n    bounds = bounds.pad(options?.pad ?? 0.5);\n\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  public fitBounds(\n    boundingbox: LatLngExpression[],\n    options?: { zoom?: number; pad?: number }\n  ) {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n    const bounds = this.Leaflet.latLngBounds(boundingbox).pad(\n      options?.pad ?? 0.5\n    );\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  private _drawLayers(prevLayers: Layer[] | undefined): void {\n    if (prevLayers) {\n      prevLayers.forEach((layer) => layer.remove());\n    }\n    if (!this.layers) {\n      return;\n    }\n    const map = this.leafletMap!;\n    this.layers.forEach((layer) => {\n      map.addLayer(layer);\n    });\n  }\n\n  private _computePathTooltip(path: HaMapPaths, point: HaMapPathPoint): string {\n    let formattedTime: string;\n    if (path.fullDatetime) {\n      formattedTime = formatDateTime(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else if (isToday(point.timestamp)) {\n      formattedTime = formatTimeWithSeconds(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else {\n      formattedTime = formatTimeWeekday(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    }\n    return `${path.name}<br>${formattedTime}`;\n  }\n\n  private _drawPaths(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n    if (this._mapPaths.length) {\n      this._mapPaths.forEach((marker) => marker.remove());\n      this._mapPaths = [];\n    }\n    if (!this.paths) {\n      return;\n    }\n\n    const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    this.paths.forEach((path) => {\n      let opacityStep: number;\n      let baseOpacity: number;\n      if (path.gradualOpacity) {\n        opacityStep = path.gradualOpacity / (path.points.length - 2);\n        baseOpacity = 1 - path.gradualOpacity;\n      }\n\n      for (\n        let pointIndex = 0;\n        pointIndex < path.points.length - 1;\n        pointIndex++\n      ) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n\n        // DRAW point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n\n        // DRAW line between this and next point\n        this._mapPaths.push(\n          Leaflet!.polyline(\n            [path.points[pointIndex].point, path.points[pointIndex + 1].point],\n            {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false,\n            }\n          )\n        );\n      }\n      const pointIndex = path.points.length - 1;\n      if (pointIndex >= 0) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n        // DRAW end path point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n      }\n      this._mapPaths.forEach((marker) => map.addLayer(marker));\n    });\n  }\n\n  private _drawEntities(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n\n    if (this._mapItems.length) {\n      this._mapItems.forEach((marker) => marker.remove());\n      this._mapItems = [];\n      this._mapFocusItems = [];\n    }\n\n    if (this._mapZones.length) {\n      this._mapZones.forEach((marker) => marker.remove());\n      this._mapZones = [];\n    }\n\n    if (!this.entities) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n    const passiveZoneColor = computedStyles.getPropertyValue(\n      \"--secondary-text-color\"\n    );\n\n    const darkPrimaryColor = computedStyles.getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    const className =\n      this.darkMode || this.hass.themes.darkMode ? \"dark\" : \"light\";\n\n    for (const entity of this.entities) {\n      const stateObj = hass.states[getEntityId(entity)];\n      if (!stateObj) {\n        continue;\n      }\n      const customTitle = typeof entity !== \"string\" ? entity.name : undefined;\n      const title = customTitle ?? computeStateName(stateObj);\n      const {\n        latitude,\n        longitude,\n        passive,\n        icon,\n        radius,\n        entity_picture: entityPicture,\n        gps_accuracy: gpsAccuracy,\n      } = stateObj.attributes;\n\n      if (!(latitude && longitude)) {\n        continue;\n      }\n\n      if (computeStateDomain(stateObj) === \"zone\") {\n        // DRAW ZONE\n        if (passive && !this.renderPassive) {\n          continue;\n        }\n\n        // create icon\n        let iconHTML = \"\";\n        if (icon) {\n          const el = document.createElement(\"ha-icon\");\n          el.setAttribute(\"icon\", icon);\n          iconHTML = el.outerHTML;\n        } else {\n          const el = document.createElement(\"span\");\n          el.innerHTML = title;\n          iconHTML = el.outerHTML;\n        }\n\n        // create marker with the icon\n        this._mapZones.push(\n          Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: iconHTML,\n              iconSize: [24, 24],\n              className,\n            }),\n            interactive: this.interactiveZones,\n            title,\n          })\n        );\n\n        // create circle around it\n        this._mapZones.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: passive ? passiveZoneColor : zoneColor,\n            radius,\n          })\n        );\n\n        continue;\n      }\n\n      // DRAW ENTITY\n      // create icon\n      const entityName =\n        typeof entity !== \"string\" && entity.label_mode === \"state\"\n          ? this.hass.formatEntityState(stateObj)\n          : customTitle ??\n            title\n              .split(\" \")\n              .map((part) => part[0])\n              .join(\"\")\n              .substr(0, 3);\n\n      // create marker with the icon\n      const marker = Leaflet.marker([latitude, longitude], {\n        icon: Leaflet.divIcon({\n          html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${\n                  entityPicture ? this.hass.hassUrl(entityPicture) : \"\"\n                }\"\n                ${\n                  typeof entity !== \"string\"\n                    ? `entity-color=\"${entity.color}\"`\n                    : \"\"\n                }\n              ></ha-entity-marker>\n            `,\n          iconSize: [48, 48],\n          className: \"\",\n        }),\n        title: title,\n      });\n      this._mapItems.push(marker);\n      if (typeof entity === \"string\" || entity.focus !== false) {\n        this._mapFocusItems.push(marker);\n      }\n\n      // create circle around if entity has accuracy\n      if (gpsAccuracy) {\n        this._mapItems.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: darkPrimaryColor,\n            radius: gpsAccuracy,\n          })\n        );\n      }\n    }\n\n    this._mapItems.forEach((marker) => map.addLayer(marker));\n    this._mapZones.forEach((marker) => map.addLayer(marker));\n  }\n\n  private async _attachObserver(): Promise<void> {\n    if (!this._resizeObserver) {\n      await loadPolyfillIfNeeded();\n      this._resizeObserver = new ResizeObserver(() => {\n        this.leafletMap?.invalidateSize({ debounceMoveend: true });\n      });\n    }\n    this._resizeObserver.observe(this);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n      }\n      #map.forced-dark {\n        --map-filter: invert(0.9) hue-rotate(170deg) brightness(1.5)\n          contrast(1.2) saturate(0.3);\n      }\n      #map:active {\n        cursor: grabbing;\n        cursor: -moz-grabbing;\n        cursor: -webkit-grabbing;\n      }\n      .light {\n        color: #000000;\n      }\n      .dark {\n        color: #ffffff;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: var(--card-background-color, #1c1c1c);\n        color: #ffffff;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n      .leaflet-tooltip {\n        padding: 8px;\n        font-size: 90%;\n        background: rgba(80, 80, 80, 0.9) !important;\n        color: white !important;\n        border-radius: 4px;\n        box-shadow: none !important;\n        text-align: center;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-map\": HaMap;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}