{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _templateObject;\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\n/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, LitElement } from 'lit';\nimport { property, queryAll } from 'lit/decorators.js';\n/**\n * An item layout component.\n */\nexport var Item = /*#__PURE__*/function (_LitElement) {\n  _inherits(Item, _LitElement);\n  function Item() {\n    var _this;\n    _classCallCheck(this, Item);\n    _this = _callSuper(this, Item, arguments);\n    /**\n     * Only needed for SSR.\n     *\n     * Add this attribute when an item has two lines to avoid a Flash Of Unstyled\n     * Content. This attribute is not needed for single line items or items with\n     * three or more lines.\n     */\n    _this.multiline = false;\n    return _this;\n  }\n  _createClass(Item, [{\n    key: \"render\",\n    value: function render() {\n      return html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <slot name=\\\"container\\\"></slot>\\n      <slot class=\\\"non-text\\\" name=\\\"start\\\"></slot>\\n      <div class=\\\"text\\\">\\n        <slot name=\\\"overline\\\" @slotchange=\", \"></slot>\\n        <slot\\n          class=\\\"default-slot\\\"\\n          @slotchange=\", \"></slot>\\n        <slot name=\\\"headline\\\" @slotchange=\", \"></slot>\\n        <slot\\n          name=\\\"supporting-text\\\"\\n          @slotchange=\", \"></slot>\\n      </div>\\n      <slot class=\\\"non-text\\\" name=\\\"trailing-supporting-text\\\"></slot>\\n      <slot class=\\\"non-text\\\" name=\\\"end\\\"></slot>\\n    \"])), this.handleTextSlotChange, this.handleTextSlotChange, this.handleTextSlotChange, this.handleTextSlotChange);\n    }\n  }, {\n    key: \"handleTextSlotChange\",\n    value: function handleTextSlotChange() {\n      // Check if there's more than one text slot with content. If so, the item is\n      // multiline, which has a different min-height than single line items.\n      var isMultiline = false;\n      var slotsWithContent = 0;\n      var _iterator = _createForOfIteratorHelper(this.textSlots),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var slot = _step.value;\n          if (slotHasContent(slot)) {\n            slotsWithContent += 1;\n          }\n          if (slotsWithContent > 1) {\n            isMultiline = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.multiline = isMultiline;\n    }\n  }]);\n  return Item;\n}(LitElement);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], Item.prototype, \"multiline\", void 0);\n__decorate([queryAll('.text slot')], Item.prototype, \"textSlots\", void 0);\nfunction slotHasContent(slot) {\n  var _iterator2 = _createForOfIteratorHelper(slot.assignedNodes({\n      flatten: true\n    })),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node$textContent;\n      var node = _step2.value;\n      // Assume there's content if there's an element slotted in\n      var isElement = node.nodeType === Node.ELEMENT_NODE;\n      // If there's only text nodes for the default slot, check if there's\n      // non-whitespace.\n      var isTextWithContent = node.nodeType === Node.TEXT_NODE && ((_node$textContent = node.textContent) === null || _node$textContent === void 0 ? void 0 : _node$textContent.match(/\\S/));\n      if (isElement || isTextWithContent) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return false;\n}","map":{"version":3,"names":["html","LitElement","property","queryAll","Item","_LitElement","_inherits","_this","_classCallCheck","multiline","_createClass","key","value","render","_templateObject","_taggedTemplateLiteral","handleTextSlotChange","isMultiline","slotsWithContent","_iterator","_createForOfIteratorHelper","textSlots","_step","s","n","done","slot","slotHasContent","err","e","f","__decorate","type","Boolean","reflect","_iterator2","assignedNodes","flatten","_step2","_node$textContent","node","isElement","nodeType","Node","ELEMENT_NODE","isTextWithContent","TEXT_NODE","textContent","match"],"sources":["item.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, LitElement} from 'lit';\nimport {property, queryAll} from 'lit/decorators.js';\n\n/**\n * An item layout component.\n */\nexport class Item extends LitElement {\n  /**\n   * Only needed for SSR.\n   *\n   * Add this attribute when an item has two lines to avoid a Flash Of Unstyled\n   * Content. This attribute is not needed for single line items or items with\n   * three or more lines.\n   */\n  @property({type: Boolean, reflect: true}) multiline = false;\n\n  @queryAll('.text slot') private readonly textSlots!: HTMLSlotElement[];\n\n  override render() {\n    return html`\n      <slot name=\"container\"></slot>\n      <slot class=\"non-text\" name=\"start\"></slot>\n      <div class=\"text\">\n        <slot name=\"overline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          class=\"default-slot\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n        <slot name=\"headline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          name=\"supporting-text\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n      </div>\n      <slot class=\"non-text\" name=\"trailing-supporting-text\"></slot>\n      <slot class=\"non-text\" name=\"end\"></slot>\n    `;\n  }\n\n  private handleTextSlotChange() {\n    // Check if there's more than one text slot with content. If so, the item is\n    // multiline, which has a different min-height than single line items.\n    let isMultiline = false;\n    let slotsWithContent = 0;\n    for (const slot of this.textSlots) {\n      if (slotHasContent(slot)) {\n        slotsWithContent += 1;\n      }\n\n      if (slotsWithContent > 1) {\n        isMultiline = true;\n        break;\n      }\n    }\n\n    this.multiline = isMultiline;\n  }\n}\n\nfunction slotHasContent(slot: HTMLSlotElement) {\n  for (const node of slot.assignedNodes({flatten: true})) {\n    // Assume there's content if there's an element slotted in\n    const isElement = node.nodeType === Node.ELEMENT_NODE;\n    // If there's only text nodes for the default slot, check if there's\n    // non-whitespace.\n    const isTextWithContent =\n      node.nodeType === Node.TEXT_NODE && node.textContent?.match(/\\S/);\n    if (isElement || isTextWithContent) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":";;;;;;;;;AAAA;;;;;;AAMA,SAAQA,IAAI,EAAEC,UAAU,QAAO,KAAK;AACpC,SAAQC,QAAQ,EAAEC,QAAQ,QAAO,mBAAmB;AAEpD;;;AAGA,WAAaC,IAAK,0BAAAC,WAAA;EAAAC,SAAA,CAAAF,IAAA,EAAAC,WAAA;EAAlB,SAAAD,KAAA;IAAA,IAAAG,KAAA;IAAAC,eAAA,OAAAJ,IAAA;;IACE;;;;;;;IAO0CG,KAAA,CAAAE,SAAS,GAAG,KAAK;IAAC,OAAAF,KAAA;EAyC9D;EAACG,YAAA,CAAAN,IAAA;IAAAO,GAAA;IAAAC,KAAA,EArCU,SAAAC,OAAA,EAAM;MACb,OAAOb,IAAI,CAAAc,eAAA,KAAAA,eAAA,GAAAC,sBAAA,ujBAI6B,IAAI,CAACC,oBAAoB,EAG7C,IAAI,CAACA,oBAAoB,EACL,IAAI,CAACA,oBAAoB,EAG7C,IAAI,CAACA,oBAAoB;IAK/C;EAAC;IAAAL,GAAA;IAAAC,KAAA,EAEO,SAAAI,qBAAA,EAAoB;MAC1B;MACA;MACA,IAAIC,WAAW,GAAG,KAAK;MACvB,IAAIC,gBAAgB,GAAG,CAAC;MAAC,IAAAC,SAAA,GAAAC,0BAAA,CACN,IAAI,CAACC,SAAS;QAAAC,KAAA;MAAA;QAAjC,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAAmC;UAAA,IAAxBC,IAAI,GAAAJ,KAAA,CAAAV,KAAA;UACb,IAAIe,cAAc,CAACD,IAAI,CAAC,EAAE;YACxBR,gBAAgB,IAAI,CAAC;;UAGvB,IAAIA,gBAAgB,GAAG,CAAC,EAAE;YACxBD,WAAW,GAAG,IAAI;YAClB;;;MAEH,SAAAW,GAAA;QAAAT,SAAA,CAAAU,CAAA,CAAAD,GAAA;MAAA;QAAAT,SAAA,CAAAW,CAAA;MAAA;MAED,IAAI,CAACrB,SAAS,GAAGQ,WAAW;IAC9B;EAAC;EAAA,OAAAb,IAAA;AAAA,EAhDuBH,UAAU;AAQQ8B,UAAA,EAAzC7B,QAAQ,CAAC;EAAC8B,IAAI,EAAEC,OAAO;EAAEC,OAAO,EAAE;AAAI,CAAC,CAAC,C,sCAAmB;AAEnBH,UAAA,EAAxC5B,QAAQ,CAAC,YAAY,CAAC,C,sCAAgD;AAyCzE,SAASwB,cAAcA,CAACD,IAAqB;EAAA,IAAAS,UAAA,GAAAf,0BAAA,CACxBM,IAAI,CAACU,aAAa,CAAC;MAACC,OAAO,EAAE;IAAI,CAAC,CAAC;IAAAC,MAAA;EAAA;IAAtD,KAAAH,UAAA,CAAAZ,CAAA,MAAAe,MAAA,GAAAH,UAAA,CAAAX,CAAA,IAAAC,IAAA,GAAwD;MAAA,IAAAc,iBAAA;MAAA,IAA7CC,IAAI,GAAAF,MAAA,CAAA1B,KAAA;MACb;MACA,IAAM6B,SAAS,GAAGD,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACC,YAAY;MACrD;MACA;MACA,IAAMC,iBAAiB,GACrBL,IAAI,CAACE,QAAQ,KAAKC,IAAI,CAACG,SAAS,MAAAP,iBAAA,GAAIC,IAAI,CAACO,WAAW,cAAAR,iBAAA,uBAAhBA,iBAAA,CAAkBS,KAAK,CAAC,IAAI,CAAC;MACnE,IAAIP,SAAS,IAAII,iBAAiB,EAAE;QAClC,OAAO,IAAI;;;EAEd,SAAAjB,GAAA;IAAAO,UAAA,CAAAN,CAAA,CAAAD,GAAA;EAAA;IAAAO,UAAA,CAAAL,CAAA;EAAA;EAED,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}