{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n// Make TypeScript not remove the imports.\nimport '@material/mwc-tab/mwc-tab.js';\nimport '@material/mwc-tab-scroller/mwc-tab-scroller.js';\nimport { BaseElement } from '@material/mwc-base/base-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { TabBase } from '@material/mwc-tab/mwc-tab-base.js';\nimport MDCTabBarFoundation from '@material/tab-bar/foundation.js';\nimport { html } from 'lit';\nimport { property, query } from 'lit/decorators.js';\nexport class TabBarBase extends BaseElement {\n  constructor() {\n    super(...arguments);\n    this.mdcFoundationClass = MDCTabBarFoundation;\n    this.activeIndex = 0;\n    this._previousActiveIndex = -1;\n  }\n  _handleTabInteraction(e) {\n    this.mdcFoundation.handleTabInteraction(e);\n  }\n  _handleKeydown(e) {\n    this.mdcFoundation.handleKeyDown(e);\n  }\n  // TODO(sorvell): can scroller be optional for perf?\n  render() {\n    return html`\n      <div class=\"mdc-tab-bar\" role=\"tablist\"\n          @MDCTab:interacted=\"${this._handleTabInteraction}\"\n          @keydown=\"${this._handleKeydown}\">\n        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>\n      </div>\n      `;\n  }\n  // TODO(sorvell): probably want to memoize this and use a `slotChange` event\n  _getTabs() {\n    return this.tabsSlot.assignedNodes({\n      flatten: true\n    }).filter(e => e instanceof TabBase);\n  }\n  _getTab(index) {\n    return this._getTabs()[index];\n  }\n  createAdapter() {\n    return {\n      scrollTo: scrollX => this.scrollerElement.scrollToPosition(scrollX),\n      incrementScroll: scrollXIncrement => this.scrollerElement.incrementScrollPosition(scrollXIncrement),\n      getScrollPosition: () => this.scrollerElement.getScrollPosition(),\n      getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),\n      getOffsetWidth: () => this.mdcRoot.offsetWidth,\n      isRTL: () => window.getComputedStyle(this.mdcRoot).getPropertyValue('direction') === 'rtl',\n      setActiveTab: index => this.mdcFoundation.activateTab(index),\n      activateTabAtIndex: (index, clientRect) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.activate(clientRect);\n        }\n        this._previousActiveIndex = index;\n      },\n      deactivateTabAtIndex: index => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.deactivate();\n        }\n      },\n      focusTabAtIndex: index => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.focus();\n        }\n      },\n      // TODO(sorvell): tab may not be able to synchronously answer\n      // `computeIndicatorClientRect` if an update is pending or it has not yet\n      // updated. If this is necessary, LitElement may need a `forceUpdate`\n      // method.\n      getTabIndicatorClientRectAtIndex: index => {\n        const tab = this._getTab(index);\n        return tab !== undefined ? tab.computeIndicatorClientRect() : new DOMRect();\n      },\n      getTabDimensionsAtIndex: index => {\n        const tab = this._getTab(index);\n        return tab !== undefined ? tab.computeDimensions() : {\n          rootLeft: 0,\n          rootRight: 0,\n          contentLeft: 0,\n          contentRight: 0\n        };\n      },\n      getPreviousActiveTabIndex: () => {\n        return this._previousActiveIndex;\n      },\n      getFocusedTabIndex: () => {\n        const tabElements = this._getTabs();\n        const activeElement = this.getRootNode().activeElement;\n        return tabElements.indexOf(activeElement);\n      },\n      getIndexOfTabById: id => {\n        const tabElements = this._getTabs();\n        for (let i = 0; i < tabElements.length; i++) {\n          if (tabElements[i].id === id) {\n            return i;\n          }\n        }\n        return -1;\n      },\n      getTabListLength: () => this._getTabs().length,\n      notifyTabActivated: index => {\n        // Synchronize the tabs `activeIndex` to the foundation.\n        // This is needed when a tab is changed via a click, for example.\n        this.activeIndex = index;\n        this.dispatchEvent(new CustomEvent(MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {\n          detail: {\n            index\n          },\n          bubbles: true,\n          cancelable: true\n        }));\n      }\n    };\n  }\n  firstUpdated() {\n    // NOTE: Delay creating foundation until scroller is fully updated.\n    // This is necessary because the foundation/adapter synchronously addresses\n    // the scroller element.\n  }\n  async getUpdateComplete() {\n    const result = await super.getUpdateComplete();\n    await this.scrollerElement.updateComplete;\n    if (this.mdcFoundation === undefined) {\n      this.createFoundation();\n    }\n    return result;\n  }\n  scrollIndexIntoView(index) {\n    this.mdcFoundation.scrollIntoView(index);\n  }\n}\n__decorate([query('.mdc-tab-bar')], TabBarBase.prototype, \"mdcRoot\", void 0);\n__decorate([query('mwc-tab-scroller')], TabBarBase.prototype, \"scrollerElement\", void 0);\n__decorate([query('slot')], TabBarBase.prototype, \"tabsSlot\", void 0);\n__decorate([observer(async function () {\n  await this.updateComplete;\n  // only provoke the foundation if we are out of sync with it, i.e.\n  // ignore an foundation generated set.\n  // use `activeIndex` directly to avoid staleness if it was set before the\n  // first render.\n  if (this.activeIndex !== this._previousActiveIndex) {\n    this.mdcFoundation.activateTab(this.activeIndex);\n  }\n}), property({\n  type: Number\n})], TabBarBase.prototype, \"activeIndex\", void 0);","map":{"version":3,"names":["BaseElement","observer","TabBase","MDCTabBarFoundation","html","property","query","TabBarBase","constructor","mdcFoundationClass","activeIndex","_previousActiveIndex","_handleTabInteraction","e","mdcFoundation","handleTabInteraction","_handleKeydown","handleKeyDown","render","_getTabs","tabsSlot","assignedNodes","flatten","filter","_getTab","index","createAdapter","scrollTo","scrollX","scrollerElement","scrollToPosition","incrementScroll","scrollXIncrement","incrementScrollPosition","getScrollPosition","getScrollContentWidth","getOffsetWidth","mdcRoot","offsetWidth","isRTL","window","getComputedStyle","getPropertyValue","setActiveTab","activateTab","activateTabAtIndex","clientRect","tab","undefined","activate","deactivateTabAtIndex","deactivate","focusTabAtIndex","focus","getTabIndicatorClientRectAtIndex","computeIndicatorClientRect","DOMRect","getTabDimensionsAtIndex","computeDimensions","rootLeft","rootRight","contentLeft","contentRight","getPreviousActiveTabIndex","getFocusedTabIndex","tabElements","activeElement","getRootNode","indexOf","getIndexOfTabById","id","i","length","getTabListLength","notifyTabActivated","dispatchEvent","CustomEvent","strings","TAB_ACTIVATED_EVENT","detail","bubbles","cancelable","firstUpdated","getUpdateComplete","result","updateComplete","createFoundation","scrollIndexIntoView","scrollIntoView","__decorate","type","Number"],"sources":["mwc-tab-bar-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n// Make TypeScript not remove the imports.\nimport '@material/mwc-tab/mwc-tab.js';\nimport '@material/mwc-tab-scroller/mwc-tab-scroller.js';\n\nimport {BaseElement} from '@material/mwc-base/base-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {Tab} from '@material/mwc-tab/mwc-tab.js';\nimport {TabScroller} from '@material/mwc-tab-scroller/mwc-tab-scroller.js';\nimport {TabBase} from '@material/mwc-tab/mwc-tab-base.js';\nimport {MDCTabBarAdapter} from '@material/tab-bar/adapter.js';\nimport MDCTabBarFoundation from '@material/tab-bar/foundation.js';\nimport {MDCTabInteractionEvent} from '@material/tab/types.js';\nimport {html} from 'lit';\nimport {property, query} from 'lit/decorators.js';\n\nexport class TabBarBase extends BaseElement {\n  protected mdcFoundation!: MDCTabBarFoundation;\n\n  protected readonly mdcFoundationClass = MDCTabBarFoundation;\n\n  @query('.mdc-tab-bar') protected mdcRoot!: HTMLElement;\n\n  @query('mwc-tab-scroller') protected scrollerElement!: TabScroller;\n\n  // tabsSlot should have type HTMLSlotElement, but when TypeScript's\n  // emitDecoratorMetadata is enabled, the HTMLSlotElement constructor will\n  // be emitted into the runtime, which will cause an \"HTMLSlotElement is\n  // undefined\" error in browsers that don't define it (e.g. IE11).\n  @query('slot') protected tabsSlot!: HTMLElement;\n\n  @observer(async function(this: TabBarBase) {\n    await this.updateComplete;\n    // only provoke the foundation if we are out of sync with it, i.e.\n    // ignore an foundation generated set.\n    // use `activeIndex` directly to avoid staleness if it was set before the\n    // first render.\n    if (this.activeIndex !== this._previousActiveIndex) {\n      this.mdcFoundation.activateTab(this.activeIndex);\n    }\n  })\n  @property({type: Number})\n  activeIndex = 0;\n\n  protected _previousActiveIndex = -1;\n\n  protected _handleTabInteraction(e: MDCTabInteractionEvent) {\n    this.mdcFoundation.handleTabInteraction(e);\n  }\n\n  protected _handleKeydown(e: KeyboardEvent) {\n    this.mdcFoundation.handleKeyDown(e);\n  }\n\n  // TODO(sorvell): can scroller be optional for perf?\n  protected override render() {\n    return html`\n      <div class=\"mdc-tab-bar\" role=\"tablist\"\n          @MDCTab:interacted=\"${this._handleTabInteraction}\"\n          @keydown=\"${this._handleKeydown}\">\n        <mwc-tab-scroller><slot></slot></mwc-tab-scroller>\n      </div>\n      `;\n  }\n\n  // TODO(sorvell): probably want to memoize this and use a `slotChange` event\n  protected _getTabs() {\n    return (this.tabsSlot as HTMLSlotElement)\n               .assignedNodes({flatten: true})\n               .filter((e: Node) => e instanceof TabBase) as Tab[];\n  }\n\n  protected _getTab(index: number) {\n    return this._getTabs()[index];\n  }\n\n  protected createAdapter(): MDCTabBarAdapter {\n    return {\n      scrollTo: (scrollX: number) =>\n          this.scrollerElement.scrollToPosition(scrollX),\n      incrementScroll: (scrollXIncrement: number) =>\n          this.scrollerElement.incrementScrollPosition(scrollXIncrement),\n      getScrollPosition: () => this.scrollerElement.getScrollPosition(),\n      getScrollContentWidth: () => this.scrollerElement.getScrollContentWidth(),\n      getOffsetWidth: () => this.mdcRoot.offsetWidth,\n      isRTL: () => window.getComputedStyle(this.mdcRoot)\n                       .getPropertyValue('direction') === 'rtl',\n      setActiveTab: (index: number) => this.mdcFoundation.activateTab(index),\n      activateTabAtIndex: (index: number, clientRect: DOMRect) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.activate(clientRect);\n        }\n        this._previousActiveIndex = index;\n      },\n      deactivateTabAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.deactivate();\n        }\n      },\n      focusTabAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        if (tab !== undefined) {\n          tab.focus();\n        }\n      },\n      // TODO(sorvell): tab may not be able to synchronously answer\n      // `computeIndicatorClientRect` if an update is pending or it has not yet\n      // updated. If this is necessary, LitElement may need a `forceUpdate`\n      // method.\n      getTabIndicatorClientRectAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        return tab !== undefined ? tab.computeIndicatorClientRect() :\n                                   new DOMRect();\n      },\n      getTabDimensionsAtIndex: (index: number) => {\n        const tab = this._getTab(index);\n        return tab !== undefined ?\n            tab.computeDimensions() :\n            {rootLeft: 0, rootRight: 0, contentLeft: 0, contentRight: 0};\n      },\n      getPreviousActiveTabIndex: () => {\n        return this._previousActiveIndex;\n      },\n      getFocusedTabIndex: () => {\n        const tabElements = this._getTabs();\n        const activeElement =\n            (this.getRootNode() as ShadowRoot).activeElement as Tab;\n        return tabElements.indexOf(activeElement);\n      },\n      getIndexOfTabById: (id: string) => {\n        const tabElements = this._getTabs();\n        for (let i = 0; i < tabElements.length; i++) {\n          if (tabElements[i].id === id) {\n            return i;\n          }\n        }\n        return -1;\n      },\n      getTabListLength: () => this._getTabs().length,\n      notifyTabActivated: (index: number) => {\n        // Synchronize the tabs `activeIndex` to the foundation.\n        // This is needed when a tab is changed via a click, for example.\n        this.activeIndex = index;\n        this.dispatchEvent(new CustomEvent(\n            MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT,\n            {detail: {index}, bubbles: true, cancelable: true}));\n      },\n    };\n  }\n\n  protected override firstUpdated() {\n    // NOTE: Delay creating foundation until scroller is fully updated.\n    // This is necessary because the foundation/adapter synchronously addresses\n    // the scroller element.\n  }\n\n  protected override async getUpdateComplete() {\n    const result = await super.getUpdateComplete();\n    await this.scrollerElement.updateComplete;\n    if (this.mdcFoundation === undefined) {\n      this.createFoundation();\n    }\n    return result;\n  }\n\n  scrollIndexIntoView(index: number) {\n    this.mdcFoundation.scrollIntoView(index);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}