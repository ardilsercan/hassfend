{"ast":null,"code":"import { strokeWidth } from \"../../../../data/graph\";\nconst average = items => items.reduce((sum, entry) => sum + parseFloat(entry.state), 0) / items.length;\nconst lastValue = items => parseFloat(items[items.length - 1].state) || 0;\nconst calcPoints = (history, hours, width, detail, min, max) => {\n  const coords = [];\n  const height = 80;\n  let yRatio = (max - min) / height;\n  yRatio = yRatio !== 0 ? yRatio : height;\n  let xRatio = width / (hours - (detail === 1 ? 1 : 0));\n  xRatio = isFinite(xRatio) ? xRatio : width;\n  const first = history.filter(Boolean)[0];\n  let last = [average(first), lastValue(first)];\n  const getCoords = (item, i, offset = 0, depth = 1) => {\n    if (depth > 1 && item) {\n      return item.forEach((subItem, index) => getCoords(subItem, i, index, depth - 1));\n    }\n    const x = xRatio * (i + offset / 6);\n    if (item) {\n      last = [average(item), lastValue(item)];\n    }\n    const y = height + strokeWidth / 2 - ((item ? last[0] : last[1]) - min) / yRatio;\n    return coords.push([x, y]);\n  };\n  for (let i = 0; i < history.length; i += 1) {\n    getCoords(history[i], i, 0, detail);\n  }\n  if (coords.length === 1) {\n    coords[1] = [width, coords[0][1]];\n  }\n  coords.push([width, coords[coords.length - 1][1]]);\n  return coords;\n};\nexport const coordinates = (history, hours, width, detail, limits) => {\n  history.forEach(item => {\n    item.state = Number(item.state);\n  });\n  history = history.filter(item => !Number.isNaN(item.state));\n  const min = (limits === null || limits === void 0 ? void 0 : limits.min) !== undefined ? limits.min : Math.min(...history.map(item => item.state));\n  const max = (limits === null || limits === void 0 ? void 0 : limits.max) !== undefined ? limits.max : Math.max(...history.map(item => item.state));\n  const now = new Date().getTime();\n  const reduce = (res, item, point) => {\n    const age = now - new Date(item.last_changed).getTime();\n    let key = Math.abs(age / (1000 * 3600) - hours);\n    if (point) {\n      key = (key - Math.floor(key)) * 60;\n      key = Number((Math.round(key / 10) * 10).toString()[0]);\n    } else {\n      key = Math.floor(key);\n    }\n    if (!res[key]) {\n      res[key] = [];\n    }\n    res[key].push(item);\n    return res;\n  };\n  history = history.reduce((res, item) => reduce(res, item, false), []);\n  if (detail > 1) {\n    history = history.map(entry => entry.reduce((res, item) => reduce(res, item, true), []));\n  }\n  if (!history.length) {\n    return undefined;\n  }\n  return calcPoints(history, hours, width, detail, min, max);\n};\nexport const coordinatesMinimalResponseCompressedState = (history, hours, width, detail, limits) => {\n  if (!history) {\n    return undefined;\n  }\n  const numericHistory = history.map(item => ({\n    state: Number(item.s),\n    // With minimal response and compressed state, we don't have last_changed,\n    // so we use last_updated since its always the same as last_changed since\n    // we already filtered out states that are the same.\n    last_changed: item.lu * 1000\n  }));\n  return coordinates(numericHistory, hours, width, detail, limits);\n};","map":{"version":3,"names":["strokeWidth","average","items","reduce","sum","entry","parseFloat","state","length","lastValue","calcPoints","history","hours","width","detail","min","max","coords","height","yRatio","xRatio","isFinite","first","filter","Boolean","last","getCoords","item","i","offset","depth","forEach","subItem","index","x","y","push","coordinates","limits","Number","isNaN","undefined","Math","map","now","Date","getTime","res","point","age","last_changed","key","abs","floor","round","toString","coordinatesMinimalResponseCompressedState","numericHistory","s","lu"],"sources":["/Users/sercanardil/Desktop/frontend/src/panels/lovelace/common/graph/coordinates.ts"],"sourcesContent":["import { strokeWidth } from \"../../../../data/graph\";\nimport { EntityHistoryState } from \"../../../../data/history\";\n\nconst average = (items: any[]): number =>\n  items.reduce((sum, entry) => sum + parseFloat(entry.state), 0) / items.length;\n\nconst lastValue = (items: any[]): number =>\n  parseFloat(items[items.length - 1].state) || 0;\n\nconst calcPoints = (\n  history: any,\n  hours: number,\n  width: number,\n  detail: number,\n  min: number,\n  max: number\n): number[][] => {\n  const coords = [] as number[][];\n  const height = 80;\n  let yRatio = (max - min) / height;\n  yRatio = yRatio !== 0 ? yRatio : height;\n  let xRatio = width / (hours - (detail === 1 ? 1 : 0));\n  xRatio = isFinite(xRatio) ? xRatio : width;\n\n  const first = history.filter(Boolean)[0];\n  let last = [average(first), lastValue(first)];\n\n  const getCoords = (item: any[], i: number, offset = 0, depth = 1) => {\n    if (depth > 1 && item) {\n      return item.forEach((subItem, index) =>\n        getCoords(subItem, i, index, depth - 1)\n      );\n    }\n\n    const x = xRatio * (i + offset / 6);\n\n    if (item) {\n      last = [average(item), lastValue(item)];\n    }\n    const y =\n      height + strokeWidth / 2 - ((item ? last[0] : last[1]) - min) / yRatio;\n    return coords.push([x, y]);\n  };\n\n  for (let i = 0; i < history.length; i += 1) {\n    getCoords(history[i], i, 0, detail);\n  }\n\n  if (coords.length === 1) {\n    coords[1] = [width, coords[0][1]];\n  }\n\n  coords.push([width, coords[coords.length - 1][1]]);\n  return coords;\n};\n\nexport const coordinates = (\n  history: any,\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number }\n): number[][] | undefined => {\n  history.forEach((item) => {\n    item.state = Number(item.state);\n  });\n  history = history.filter((item) => !Number.isNaN(item.state));\n\n  const min =\n    limits?.min !== undefined\n      ? limits.min\n      : Math.min(...history.map((item) => item.state));\n  const max =\n    limits?.max !== undefined\n      ? limits.max\n      : Math.max(...history.map((item) => item.state));\n  const now = new Date().getTime();\n\n  const reduce = (res, item, point) => {\n    const age = now - new Date(item.last_changed).getTime();\n\n    let key = Math.abs(age / (1000 * 3600) - hours);\n    if (point) {\n      key = (key - Math.floor(key)) * 60;\n      key = Number((Math.round(key / 10) * 10).toString()[0]);\n    } else {\n      key = Math.floor(key);\n    }\n    if (!res[key]) {\n      res[key] = [];\n    }\n    res[key].push(item);\n    return res;\n  };\n\n  history = history.reduce((res, item) => reduce(res, item, false), []);\n  if (detail > 1) {\n    history = history.map((entry) =>\n      entry.reduce((res, item) => reduce(res, item, true), [])\n    );\n  }\n\n  if (!history.length) {\n    return undefined;\n  }\n\n  return calcPoints(history, hours, width, detail, min, max);\n};\n\ninterface NumericEntityHistoryState {\n  state: number;\n  last_changed: number;\n}\n\nexport const coordinatesMinimalResponseCompressedState = (\n  history: EntityHistoryState[],\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number }\n): number[][] | undefined => {\n  if (!history) {\n    return undefined;\n  }\n  const numericHistory: NumericEntityHistoryState[] = history.map((item) => ({\n    state: Number(item.s),\n    // With minimal response and compressed state, we don't have last_changed,\n    // so we use last_updated since its always the same as last_changed since\n    // we already filtered out states that are the same.\n    last_changed: item.lu * 1000,\n  }));\n  return coordinates(numericHistory, hours, width, detail, limits);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}