{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { get } from '@vaadin/component-base/src/path-utils.js';\nimport { generateUniqueId } from '@vaadin/component-base/src/unique-id-utils.js';\nimport { Virtualizer } from '@vaadin/component-base/src/virtualizer.js';\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxScrollerMixin = superClass => class ComboBoxScrollerMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * A full set of items to filter the visible options from.\n       * Set to an empty array when combo-box is not opened.\n       */\n      items: {\n        type: Array,\n        observer: '__itemsChanged'\n      },\n      /**\n       * Index of an item that has focus outline and is scrolled into view.\n       * The actual focus still remains in the input field.\n       */\n      focusedIndex: {\n        type: Number,\n        observer: '__focusedIndexChanged'\n      },\n      /**\n       * Set to true while combo-box fetches new page from the data provider.\n       */\n      loading: {\n        type: Boolean,\n        observer: '__loadingChanged'\n      },\n      /**\n       * Whether the combo-box is currently opened or not. If set to false,\n       * calling `scrollIntoView` does not have any effect.\n       */\n      opened: {\n        type: Boolean,\n        observer: '__openedChanged'\n      },\n      /**\n       * The selected item from the `items` array.\n       */\n      selectedItem: {\n        type: Object,\n        observer: '__selectedItemChanged'\n      },\n      /**\n       * Path for the id of the item, used to detect whether the item is selected.\n       */\n      itemIdPath: {\n        type: String\n      },\n      /**\n       * Reference to the owner (combo-box owner), used by the item elements.\n       */\n      owner: {\n        type: Object\n      },\n      /**\n       * Function used to set a label for every combo-box item.\n       */\n      getItemLabel: {\n        type: Object\n      },\n      /**\n       * Function used to render the content of every combo-box item.\n       */\n      renderer: {\n        type: Object,\n        observer: '__rendererChanged'\n      },\n      /**\n       * Used to propagate the `theme` attribute from the host element.\n       */\n      theme: {\n        type: String\n      }\n    };\n  }\n  constructor() {\n    super();\n    this.__boundOnItemClick = this.__onItemClick.bind(this);\n  }\n\n  /** @private */\n  get _viewportTotalPaddingBottom() {\n    if (this._cachedViewportTotalPaddingBottom === undefined) {\n      const itemsStyle = window.getComputedStyle(this.$.selector);\n      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map(v => {\n        return parseInt(v, 10);\n      }).reduce((sum, v) => {\n        return sum + v;\n      });\n    }\n    return this._cachedViewportTotalPaddingBottom;\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'listbox');\n\n    // Ensure every instance has unique ID\n    this.id = `${this.localName}-${generateUniqueId()}`;\n\n    // Allow extensions to customize tag name for the items\n    this.__hostTagName = this.constructor.is.replace('-scroller', '');\n    this.addEventListener('click', e => e.stopPropagation());\n    this.__patchWheelOverScrolling();\n    this.__virtualizer = new Virtualizer({\n      createElements: this.__createElements.bind(this),\n      updateElement: this._updateElement.bind(this),\n      elementsContainer: this,\n      scrollTarget: this,\n      scrollContainer: this.$.selector\n    });\n  }\n\n  /**\n   * Requests an update for the virtualizer to re-render items.\n   */\n  requestContentUpdate() {\n    if (this.__virtualizer) {\n      this.__virtualizer.update();\n    }\n  }\n\n  /**\n   * Scrolls an item at given index into view and adjusts `scrollTop`\n   * so that the element gets fully visible on Arrow Down key press.\n   * @param {number} index\n   */\n  scrollIntoView(index) {\n    if (!(this.opened && index >= 0)) {\n      return;\n    }\n    const visibleItemsCount = this._visibleItemsCount();\n    let targetIndex = index;\n    if (index > this.__virtualizer.lastVisibleIndex - 1) {\n      // Index is below the bottom, scrolling down. Make the item appear at the bottom.\n      // First scroll to target (will be at the top of the scroller) to make sure it's rendered.\n      this.__virtualizer.scrollToIndex(index);\n      // Then calculate the index for the following scroll (to get the target to bottom of the scroller).\n      targetIndex = index - visibleItemsCount + 1;\n    } else if (index > this.__virtualizer.firstVisibleIndex) {\n      // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set\n      // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.\n      targetIndex = this.__virtualizer.firstVisibleIndex;\n    }\n    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));\n\n    // Sometimes the item is partly below the bottom edge, detect and adjust.\n    const lastPhysicalItem = [...this.children].find(el => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex);\n    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {\n      return;\n    }\n    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();\n    const scrollerRect = this.getBoundingClientRect();\n    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;\n    if (scrollTopAdjust > 0) {\n      this.scrollTop += scrollTopAdjust;\n    }\n  }\n\n  /**\n   * @param {string | object} item\n   * @param {string | object} selectedItem\n   * @param {string} itemIdPath\n   * @protected\n   */\n  _isItemSelected(item, selectedItem, itemIdPath) {\n    if (item instanceof ComboBoxPlaceholder) {\n      return false;\n    } else if (itemIdPath && item !== undefined && selectedItem !== undefined) {\n      return get(itemIdPath, item) === get(itemIdPath, selectedItem);\n    }\n    return item === selectedItem;\n  }\n\n  /** @private */\n  __itemsChanged(items) {\n    if (this.__virtualizer && items) {\n      this.__virtualizer.size = items.length;\n      this.__virtualizer.flush();\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __loadingChanged() {\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  __openedChanged(opened) {\n    if (opened) {\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __selectedItemChanged() {\n    this.requestContentUpdate();\n  }\n\n  /** @private */\n  __focusedIndexChanged(index, oldIndex) {\n    if (index !== oldIndex) {\n      this.requestContentUpdate();\n    }\n\n    // Do not jump back to the previously focused item while loading\n    // when requesting next page from the data provider on scroll.\n    if (index >= 0 && !this.loading) {\n      this.scrollIntoView(index);\n    }\n  }\n\n  /** @private */\n  __rendererChanged(renderer, oldRenderer) {\n    if (renderer || oldRenderer) {\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __createElements(count) {\n    return [...Array(count)].map(() => {\n      const item = document.createElement(`${this.__hostTagName}-item`);\n      item.addEventListener('click', this.__boundOnItemClick);\n      // Negative tabindex prevents the item content from being focused.\n      item.tabIndex = '-1';\n      item.style.width = '100%';\n      return item;\n    });\n  }\n\n  /**\n   * @param {HTMLElement} el\n   * @param {number} index\n   * @protected\n   */\n  _updateElement(el, index) {\n    const item = this.items[index];\n    const focusedIndex = this.focusedIndex;\n    const selected = this._isItemSelected(item, this.selectedItem, this.itemIdPath);\n    el.setProperties({\n      item,\n      index,\n      label: this.getItemLabel(item),\n      selected,\n      renderer: this.renderer,\n      focused: !this.loading && focusedIndex === index\n    });\n    el.id = `${this.__hostTagName}-item-${index}`;\n    el.setAttribute('role', index !== undefined ? 'option' : false);\n    el.setAttribute('aria-selected', selected.toString());\n    el.setAttribute('aria-posinset', index + 1);\n    el.setAttribute('aria-setsize', this.items.length);\n    if (this.theme) {\n      el.setAttribute('theme', this.theme);\n    } else {\n      el.removeAttribute('theme');\n    }\n    if (item instanceof ComboBoxPlaceholder) {\n      this.__requestItemByIndex(index);\n    }\n  }\n\n  /** @private */\n  __onItemClick(e) {\n    this.dispatchEvent(new CustomEvent('selection-changed', {\n      detail: {\n        item: e.currentTarget.item\n      }\n    }));\n  }\n\n  /**\n   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.\n   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow\n   * scrolling the parent similarly to touch scrolling.\n   * @private\n   */\n  __patchWheelOverScrolling() {\n    this.$.selector.addEventListener('wheel', e => {\n      const scrolledToTop = this.scrollTop === 0;\n      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;\n      if (scrolledToTop && e.deltaY < 0) {\n        e.preventDefault();\n      } else if (scrolledToBottom && e.deltaY > 0) {\n        e.preventDefault();\n      }\n    });\n  }\n\n  /**\n   * Dispatches an `index-requested` event for the given index to notify\n   * the data provider that it should start loading the page containing the requested index.\n   *\n   * The event is dispatched asynchronously to prevent an immediate page request and therefore\n   * a possible infinite recursion in case the data provider implements page request cancelation logic\n   * by invoking data provider page callbacks with an empty array.\n   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array\n   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,\n   * the scroller will synchronously request the page again which may lead to looping in the end.\n   * That was the case for the Flow counterpart:\n   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828\n   * @private\n   */\n  __requestItemByIndex(index) {\n    requestAnimationFrame(() => {\n      this.dispatchEvent(new CustomEvent('index-requested', {\n        detail: {\n          index,\n          currentScrollerPos: this._oldScrollerPosition\n        }\n      }));\n    });\n  }\n\n  /** @private */\n  _visibleItemsCount() {\n    // Ensure items are positioned\n    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);\n    const hasItems = this.__virtualizer.size > 0;\n    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;\n  }\n};","map":{"version":3,"names":["get","generateUniqueId","Virtualizer","ComboBoxPlaceholder","ComboBoxScrollerMixin","superClass","properties","items","type","Array","observer","focusedIndex","Number","loading","Boolean","opened","selectedItem","Object","itemIdPath","String","owner","getItemLabel","renderer","theme","constructor","__boundOnItemClick","__onItemClick","bind","_viewportTotalPaddingBottom","_cachedViewportTotalPaddingBottom","undefined","itemsStyle","window","getComputedStyle","$","selector","paddingBottom","borderBottomWidth","map","v","parseInt","reduce","sum","ready","setAttribute","id","localName","__hostTagName","is","replace","addEventListener","e","stopPropagation","__patchWheelOverScrolling","__virtualizer","createElements","__createElements","updateElement","_updateElement","elementsContainer","scrollTarget","scrollContainer","requestContentUpdate","update","scrollIntoView","index","visibleItemsCount","_visibleItemsCount","targetIndex","lastVisibleIndex","scrollToIndex","firstVisibleIndex","Math","max","lastPhysicalItem","children","find","el","hidden","lastPhysicalItemRect","getBoundingClientRect","scrollerRect","scrollTopAdjust","bottom","scrollTop","_isItemSelected","item","__itemsChanged","size","length","flush","__loadingChanged","__openedChanged","__selectedItemChanged","__focusedIndexChanged","oldIndex","__rendererChanged","oldRenderer","count","document","createElement","tabIndex","style","width","selected","setProperties","label","focused","toString","removeAttribute","__requestItemByIndex","dispatchEvent","CustomEvent","detail","currentTarget","scrolledToTop","scrolledToBottom","scrollHeight","clientHeight","deltaY","preventDefault","requestAnimationFrame","currentScrollerPos","_oldScrollerPosition","hasItems"],"sources":["/workspaces/frontend/node_modules/@vaadin/combo-box/src/vaadin-combo-box-scroller-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { get } from '@vaadin/component-base/src/path-utils.js';\nimport { generateUniqueId } from '@vaadin/component-base/src/unique-id-utils.js';\nimport { Virtualizer } from '@vaadin/component-base/src/virtualizer.js';\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxScrollerMixin = (superClass) =>\n  class ComboBoxScrollerMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * A full set of items to filter the visible options from.\n         * Set to an empty array when combo-box is not opened.\n         */\n        items: {\n          type: Array,\n          observer: '__itemsChanged',\n        },\n\n        /**\n         * Index of an item that has focus outline and is scrolled into view.\n         * The actual focus still remains in the input field.\n         */\n        focusedIndex: {\n          type: Number,\n          observer: '__focusedIndexChanged',\n        },\n\n        /**\n         * Set to true while combo-box fetches new page from the data provider.\n         */\n        loading: {\n          type: Boolean,\n          observer: '__loadingChanged',\n        },\n\n        /**\n         * Whether the combo-box is currently opened or not. If set to false,\n         * calling `scrollIntoView` does not have any effect.\n         */\n        opened: {\n          type: Boolean,\n          observer: '__openedChanged',\n        },\n\n        /**\n         * The selected item from the `items` array.\n         */\n        selectedItem: {\n          type: Object,\n          observer: '__selectedItemChanged',\n        },\n\n        /**\n         * Path for the id of the item, used to detect whether the item is selected.\n         */\n        itemIdPath: {\n          type: String,\n        },\n\n        /**\n         * Reference to the owner (combo-box owner), used by the item elements.\n         */\n        owner: {\n          type: Object,\n        },\n\n        /**\n         * Function used to set a label for every combo-box item.\n         */\n        getItemLabel: {\n          type: Object,\n        },\n\n        /**\n         * Function used to render the content of every combo-box item.\n         */\n        renderer: {\n          type: Object,\n          observer: '__rendererChanged',\n        },\n\n        /**\n         * Used to propagate the `theme` attribute from the host element.\n         */\n        theme: {\n          type: String,\n        },\n      };\n    }\n\n    constructor() {\n      super();\n      this.__boundOnItemClick = this.__onItemClick.bind(this);\n    }\n\n    /** @private */\n    get _viewportTotalPaddingBottom() {\n      if (this._cachedViewportTotalPaddingBottom === undefined) {\n        const itemsStyle = window.getComputedStyle(this.$.selector);\n        this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth]\n          .map((v) => {\n            return parseInt(v, 10);\n          })\n          .reduce((sum, v) => {\n            return sum + v;\n          });\n      }\n\n      return this._cachedViewportTotalPaddingBottom;\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n\n      this.setAttribute('role', 'listbox');\n\n      // Ensure every instance has unique ID\n      this.id = `${this.localName}-${generateUniqueId()}`;\n\n      // Allow extensions to customize tag name for the items\n      this.__hostTagName = this.constructor.is.replace('-scroller', '');\n\n      this.addEventListener('click', (e) => e.stopPropagation());\n\n      this.__patchWheelOverScrolling();\n\n      this.__virtualizer = new Virtualizer({\n        createElements: this.__createElements.bind(this),\n        updateElement: this._updateElement.bind(this),\n        elementsContainer: this,\n        scrollTarget: this,\n        scrollContainer: this.$.selector,\n      });\n    }\n\n    /**\n     * Requests an update for the virtualizer to re-render items.\n     */\n    requestContentUpdate() {\n      if (this.__virtualizer) {\n        this.__virtualizer.update();\n      }\n    }\n\n    /**\n     * Scrolls an item at given index into view and adjusts `scrollTop`\n     * so that the element gets fully visible on Arrow Down key press.\n     * @param {number} index\n     */\n    scrollIntoView(index) {\n      if (!(this.opened && index >= 0)) {\n        return;\n      }\n\n      const visibleItemsCount = this._visibleItemsCount();\n\n      let targetIndex = index;\n\n      if (index > this.__virtualizer.lastVisibleIndex - 1) {\n        // Index is below the bottom, scrolling down. Make the item appear at the bottom.\n        // First scroll to target (will be at the top of the scroller) to make sure it's rendered.\n        this.__virtualizer.scrollToIndex(index);\n        // Then calculate the index for the following scroll (to get the target to bottom of the scroller).\n        targetIndex = index - visibleItemsCount + 1;\n      } else if (index > this.__virtualizer.firstVisibleIndex) {\n        // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set\n        // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.\n        targetIndex = this.__virtualizer.firstVisibleIndex;\n      }\n      this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));\n\n      // Sometimes the item is partly below the bottom edge, detect and adjust.\n      const lastPhysicalItem = [...this.children].find(\n        (el) => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex,\n      );\n      if (!lastPhysicalItem || index !== lastPhysicalItem.index) {\n        return;\n      }\n      const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();\n      const scrollerRect = this.getBoundingClientRect();\n      const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;\n      if (scrollTopAdjust > 0) {\n        this.scrollTop += scrollTopAdjust;\n      }\n    }\n\n    /**\n     * @param {string | object} item\n     * @param {string | object} selectedItem\n     * @param {string} itemIdPath\n     * @protected\n     */\n    _isItemSelected(item, selectedItem, itemIdPath) {\n      if (item instanceof ComboBoxPlaceholder) {\n        return false;\n      } else if (itemIdPath && item !== undefined && selectedItem !== undefined) {\n        return get(itemIdPath, item) === get(itemIdPath, selectedItem);\n      }\n      return item === selectedItem;\n    }\n\n    /** @private */\n    __itemsChanged(items) {\n      if (this.__virtualizer && items) {\n        this.__virtualizer.size = items.length;\n        this.__virtualizer.flush();\n        this.requestContentUpdate();\n      }\n    }\n\n    /** @private */\n    __loadingChanged() {\n      this.requestContentUpdate();\n    }\n\n    /** @private */\n    __openedChanged(opened) {\n      if (opened) {\n        this.requestContentUpdate();\n      }\n    }\n\n    /** @private */\n    __selectedItemChanged() {\n      this.requestContentUpdate();\n    }\n\n    /** @private */\n    __focusedIndexChanged(index, oldIndex) {\n      if (index !== oldIndex) {\n        this.requestContentUpdate();\n      }\n\n      // Do not jump back to the previously focused item while loading\n      // when requesting next page from the data provider on scroll.\n      if (index >= 0 && !this.loading) {\n        this.scrollIntoView(index);\n      }\n    }\n\n    /** @private */\n    __rendererChanged(renderer, oldRenderer) {\n      if (renderer || oldRenderer) {\n        this.requestContentUpdate();\n      }\n    }\n\n    /** @private */\n    __createElements(count) {\n      return [...Array(count)].map(() => {\n        const item = document.createElement(`${this.__hostTagName}-item`);\n        item.addEventListener('click', this.__boundOnItemClick);\n        // Negative tabindex prevents the item content from being focused.\n        item.tabIndex = '-1';\n        item.style.width = '100%';\n        return item;\n      });\n    }\n\n    /**\n     * @param {HTMLElement} el\n     * @param {number} index\n     * @protected\n     */\n    _updateElement(el, index) {\n      const item = this.items[index];\n      const focusedIndex = this.focusedIndex;\n      const selected = this._isItemSelected(item, this.selectedItem, this.itemIdPath);\n\n      el.setProperties({\n        item,\n        index,\n        label: this.getItemLabel(item),\n        selected,\n        renderer: this.renderer,\n        focused: !this.loading && focusedIndex === index,\n      });\n\n      el.id = `${this.__hostTagName}-item-${index}`;\n      el.setAttribute('role', index !== undefined ? 'option' : false);\n      el.setAttribute('aria-selected', selected.toString());\n      el.setAttribute('aria-posinset', index + 1);\n      el.setAttribute('aria-setsize', this.items.length);\n\n      if (this.theme) {\n        el.setAttribute('theme', this.theme);\n      } else {\n        el.removeAttribute('theme');\n      }\n\n      if (item instanceof ComboBoxPlaceholder) {\n        this.__requestItemByIndex(index);\n      }\n    }\n\n    /** @private */\n    __onItemClick(e) {\n      this.dispatchEvent(new CustomEvent('selection-changed', { detail: { item: e.currentTarget.item } }));\n    }\n\n    /**\n     * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.\n     * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow\n     * scrolling the parent similarly to touch scrolling.\n     * @private\n     */\n    __patchWheelOverScrolling() {\n      this.$.selector.addEventListener('wheel', (e) => {\n        const scrolledToTop = this.scrollTop === 0;\n        const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;\n        if (scrolledToTop && e.deltaY < 0) {\n          e.preventDefault();\n        } else if (scrolledToBottom && e.deltaY > 0) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    /**\n     * Dispatches an `index-requested` event for the given index to notify\n     * the data provider that it should start loading the page containing the requested index.\n     *\n     * The event is dispatched asynchronously to prevent an immediate page request and therefore\n     * a possible infinite recursion in case the data provider implements page request cancelation logic\n     * by invoking data provider page callbacks with an empty array.\n     * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array\n     * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,\n     * the scroller will synchronously request the page again which may lead to looping in the end.\n     * That was the case for the Flow counterpart:\n     * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828\n     * @private\n     */\n    __requestItemByIndex(index) {\n      requestAnimationFrame(() => {\n        this.dispatchEvent(\n          new CustomEvent('index-requested', {\n            detail: {\n              index,\n              currentScrollerPos: this._oldScrollerPosition,\n            },\n          }),\n        );\n      });\n    }\n\n    /** @private */\n    _visibleItemsCount() {\n      // Ensure items are positioned\n      this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);\n      const hasItems = this.__virtualizer.size > 0;\n      return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}