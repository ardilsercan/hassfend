{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\n// prettier-ignore\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport { forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText } from './style-util.js';\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\nimport { detectMixin as _detectMixin } from './common-utils.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nvar APPLY_NAME_CLEAN = /;\\s*/m;\nvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nvar IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nvar MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nvar PropertyEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nvar DependantsEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nvar MixinMapEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nvar MixinMap = /*#__PURE__*/function () {\n  function MixinMap() {\n    _classCallCheck(this, MixinMap);\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  _createClass(MixinMap, [{\n    key: \"set\",\n    value: function set(name, props) {\n      name = name.trim();\n      this._map[name] = {\n        properties: props,\n        dependants: {}\n      };\n    }\n    /**\n     * @param {string} name\n     * @return {MixinMapEntry}\n     */\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      name = name.trim();\n      return this._map[name] || null;\n    }\n  }]);\n  return MixinMap;\n}();\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nvar invalidCallback = null;\n\n/** @unrestricted */\nvar ApplyShim = /*#__PURE__*/function () {\n  function ApplyShim() {\n    _classCallCheck(this, ApplyShim);\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  _createClass(ApplyShim, [{\n    key: \"detectMixin\",\n    value: function detectMixin(cssText) {\n      return _detectMixin(cssText);\n    }\n\n    /**\n     * Gather styles into one style for easier processing\n     * @param {!HTMLTemplateElement} template\n     * @return {HTMLStyleElement}\n     */\n  }, {\n    key: \"gatherStyles\",\n    value: function gatherStyles(template) {\n      var styleText = gatherStyleText(template.content);\n      if (styleText) {\n        var style = /** @type {!HTMLStyleElement} */document.createElement('style');\n        style.textContent = styleText;\n        template.content.insertBefore(style, template.content.firstChild);\n        return style;\n      }\n      return null;\n    }\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @return {StyleNode}\n     */\n  }, {\n    key: \"transformTemplate\",\n    value: function transformTemplate(template, elementName) {\n      if (template._gatheredStyle === undefined) {\n        template._gatheredStyle = this.gatherStyles(template);\n      }\n      /** @type {HTMLStyleElement} */\n      var style = template._gatheredStyle;\n      return style ? this.transformStyle(style, elementName) : null;\n    }\n    /**\n     * @param {!HTMLStyleElement} style\n     * @param {string} elementName\n     * @return {StyleNode}\n     */\n  }, {\n    key: \"transformStyle\",\n    value: function transformStyle(style) {\n      var elementName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var ast = rulesForStyle(style);\n      this.transformRules(ast, elementName);\n      style.textContent = toCssText(ast);\n      return ast;\n    }\n    /**\n     * @param {!HTMLStyleElement} style\n     * @return {StyleNode}\n     */\n  }, {\n    key: \"transformCustomStyle\",\n    value: function transformCustomStyle(style) {\n      var _this = this;\n      var ast = rulesForStyle(style);\n      forEachRule(ast, function (rule) {\n        if (rule['selector'] === ':root') {\n          rule['selector'] = 'html';\n        }\n        _this.transformRule(rule);\n      });\n      style.textContent = toCssText(ast);\n      return ast;\n    }\n    /**\n     * @param {StyleNode} rules\n     * @param {string} elementName\n     */\n  }, {\n    key: \"transformRules\",\n    value: function transformRules(rules, elementName) {\n      var _this2 = this;\n      this._currentElement = elementName;\n      forEachRule(rules, function (r) {\n        _this2.transformRule(r);\n      });\n      this._currentElement = null;\n    }\n    /**\n     * @param {!StyleNode} rule\n     */\n  }, {\n    key: \"transformRule\",\n    value: function transformRule(rule) {\n      rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n      // :root was only used for variable assignment in property shim,\n      // but generates invalid selectors with real properties.\n      // replace with `:host > *`, which serves the same effect\n      if (rule['selector'] === ':root') {\n        rule['selector'] = ':host > *';\n      }\n    }\n    /**\n     * @param {string} cssText\n     * @param {!StyleNode} rule\n     * @return {string}\n     */\n  }, {\n    key: \"transformCssText\",\n    value: function transformCssText(cssText, rule) {\n      var _this3 = this;\n      // produce variables\n      cssText = cssText.replace(VAR_ASSIGN, function (matchText, propertyName, valueProperty, valueMixin) {\n        return _this3._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule);\n      });\n      // consume mixins\n      return this._consumeCssProperties(cssText, rule);\n    }\n    /**\n     * @param {string} property\n     * @return {string}\n     */\n  }, {\n    key: \"_getInitialValueForProperty\",\n    value: function _getInitialValueForProperty(property) {\n      if (!this._measureElement) {\n        this._measureElement = /** @type {HTMLMetaElement} */document.createElement('meta');\n        this._measureElement.setAttribute('apply-shim-measure', '');\n        this._measureElement.style.all = 'initial';\n        document.head.appendChild(this._measureElement);\n      }\n      return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n    }\n    /**\n     * Walk over all rules before this rule to find fallbacks for mixins\n     *\n     * @param {!StyleNode} startRule\n     * @return {!Object}\n     */\n  }, {\n    key: \"_fallbacksFromPreviousRules\",\n    value: function _fallbacksFromPreviousRules(startRule) {\n      var _this4 = this;\n      // find the \"top\" rule\n      var topRule = startRule;\n      while (topRule['parent']) {\n        topRule = topRule['parent'];\n      }\n      var fallbacks = {};\n      var seenStartRule = false;\n      forEachRule(topRule, function (r) {\n        // stop when we hit the input rule\n        seenStartRule = seenStartRule || r === startRule;\n        if (seenStartRule) {\n          return;\n        }\n        // NOTE: Only matching selectors are \"safe\" for this fallback processing\n        // It would be prohibitive to run `matchesSelector()` on each selector,\n        // so we cheat and only check if the same selector string is used, which\n        // guarantees things like specificity matching\n        if (r['selector'] === startRule['selector']) {\n          Object.assign(fallbacks, _this4._cssTextToMap(r['parsedCssText']));\n        }\n      });\n      return fallbacks;\n    }\n    /**\n     * replace mixin consumption with variable consumption\n     * @param {string} text\n     * @param {!StyleNode=} rule\n     * @return {string}\n     */\n  }, {\n    key: \"_consumeCssProperties\",\n    value: function _consumeCssProperties(text, rule) {\n      /** @type {Array} */\n      var m = null;\n      // loop over text until all mixins with defintions have been applied\n      while (m = MIXIN_MATCH.exec(text)) {\n        var matchText = m[0];\n        var mixinName = m[1];\n        var idx = m.index;\n        // collect properties before apply to be \"defaults\" if mixin might override them\n        // match includes a \"prefix\", so find the start and end positions of @apply\n        var applyPos = idx + matchText.indexOf('@apply');\n        var afterApplyPos = idx + matchText.length;\n        // find props defined before this @apply\n        var textBeforeApply = text.slice(0, applyPos);\n        var textAfterApply = text.slice(afterApplyPos);\n        var defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n        Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n        var replacement = this._atApplyToCssProperties(mixinName, defaults);\n        // use regex match position to replace mixin, keep linear processing time\n        text = \"\".concat(textBeforeApply).concat(replacement).concat(textAfterApply);\n        // move regex search to _after_ replacement\n        MIXIN_MATCH.lastIndex = idx + replacement.length;\n      }\n      return text;\n    }\n    /**\n     * produce variable consumption at the site of mixin consumption\n     * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n     * Example:\n     *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n     *\n     * @param {string} mixinName\n     * @param {Object} fallbacks\n     * @return {string}\n     */\n  }, {\n    key: \"_atApplyToCssProperties\",\n    value: function _atApplyToCssProperties(mixinName, fallbacks) {\n      mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n      var vars = [];\n      var mixinEntry = this._map.get(mixinName);\n      // if we depend on a mixin before it is created\n      // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n      if (!mixinEntry) {\n        this._map.set(mixinName, {});\n        mixinEntry = this._map.get(mixinName);\n      }\n      if (mixinEntry) {\n        if (this._currentElement) {\n          mixinEntry.dependants[this._currentElement] = true;\n        }\n        var p, parts, f;\n        var properties = mixinEntry.properties;\n        for (p in properties) {\n          f = fallbacks && fallbacks[p];\n          parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n          if (f) {\n            parts.push(',', f.replace(IMPORTANT, ''));\n          }\n          parts.push(')');\n          if (IMPORTANT.test(properties[p])) {\n            parts.push(' !important');\n          }\n          vars.push(parts.join(''));\n        }\n      }\n      return vars.join('; ');\n    }\n\n    /**\n     * @param {string} property\n     * @param {string} value\n     * @return {string}\n     */\n  }, {\n    key: \"_replaceInitialOrInherit\",\n    value: function _replaceInitialOrInherit(property, value) {\n      var match = INITIAL_INHERIT.exec(value);\n      if (match) {\n        if (match[1]) {\n          // initial\n          // replace `initial` with the concrete initial value for this property\n          value = this._getInitialValueForProperty(property);\n        } else {\n          // inherit\n          // with this purposfully illegal value, the variable will be invalid at\n          // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n          // and for inheriting values, will behave similarly\n          // we cannot support the same behavior for non inheriting values like 'border'\n          value = 'apply-shim-inherit';\n        }\n      }\n      return value;\n    }\n\n    /**\n     * \"parse\" a mixin definition into a map of properties and values\n     * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n     * @param {string} text\n     * @param {boolean=} replaceInitialOrInherit\n     * @return {!Object<string, string>}\n     */\n  }, {\n    key: \"_cssTextToMap\",\n    value: function _cssTextToMap(text) {\n      var replaceInitialOrInherit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var props = text.split(';');\n      var property, value;\n      var out = {};\n      for (var i = 0, p, sp; i < props.length; i++) {\n        p = props[i];\n        if (p) {\n          sp = p.split(':');\n          // ignore lines that aren't definitions like @media\n          if (sp.length > 1) {\n            property = sp[0].trim();\n            // some properties may have ':' in the value, like data urls\n            value = sp.slice(1).join(':');\n            if (replaceInitialOrInherit) {\n              value = this._replaceInitialOrInherit(property, value);\n            }\n            out[property] = value;\n          }\n        }\n      }\n      return out;\n    }\n\n    /**\n     * @param {MixinMapEntry} mixinEntry\n     */\n  }, {\n    key: \"_invalidateMixinEntry\",\n    value: function _invalidateMixinEntry(mixinEntry) {\n      if (!invalidCallback) {\n        return;\n      }\n      for (var elementName in mixinEntry.dependants) {\n        if (elementName !== this._currentElement) {\n          invalidCallback(elementName);\n        }\n      }\n    }\n\n    /**\n     * @param {string} matchText\n     * @param {string} propertyName\n     * @param {?string} valueProperty\n     * @param {?string} valueMixin\n     * @param {!StyleNode} rule\n     * @return {string}\n     */\n  }, {\n    key: \"_produceCssProperties\",\n    value: function _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n      var _this5 = this;\n      // handle case where property value is a mixin\n      if (valueProperty) {\n        // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n        processVariableAndFallback(valueProperty, function (prefix, value) {\n          if (value && _this5._map.get(value)) {\n            valueMixin = \"@apply \".concat(value, \";\");\n          }\n        });\n      }\n      if (!valueMixin) {\n        return matchText;\n      }\n      var mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n      var prefix = matchText.slice(0, matchText.indexOf('--'));\n      // `initial` and `inherit` as properties in a map should be replaced because\n      // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n      // and would set the variable value, rather than carry the keyword to the `var()` usage.\n      var mixinValues = this._cssTextToMap(mixinAsProperties, true);\n      var combinedProps = mixinValues;\n      var mixinEntry = this._map.get(propertyName);\n      var oldProps = mixinEntry && mixinEntry.properties;\n      if (oldProps) {\n        // NOTE: since we use mixin, the map of properties is updated here\n        // and this is what we want.\n        combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n      } else {\n        this._map.set(propertyName, combinedProps);\n      }\n      var out = [];\n      var p, v;\n      // set variables defined by current mixin\n      var needToInvalidate = false;\n      for (p in combinedProps) {\n        v = mixinValues[p];\n        // if property not defined by current mixin, set initial\n        if (v === undefined) {\n          v = 'initial';\n        }\n        if (oldProps && !(p in oldProps)) {\n          needToInvalidate = true;\n        }\n        out.push(\"\".concat(propertyName).concat(MIXIN_VAR_SEP).concat(p, \": \").concat(v));\n      }\n      if (needToInvalidate) {\n        this._invalidateMixinEntry(mixinEntry);\n      }\n      if (mixinEntry) {\n        mixinEntry.properties = combinedProps;\n      }\n      // because the mixinMap is global, the mixin might conflict with\n      // a different scope's simple variable definition:\n      // Example:\n      // some style somewhere:\n      // --mixin1:{ ... }\n      // --mixin2: var(--mixin1);\n      // some other element:\n      // --mixin1: 10px solid red;\n      // --foo: var(--mixin1);\n      // In this case, we leave the original variable definition in place.\n      if (valueProperty) {\n        prefix = \"\".concat(matchText, \";\").concat(prefix);\n      }\n      return \"\".concat(prefix).concat(out.join('; '), \";\");\n    }\n  }]);\n  return ApplyShim;\n}();\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */get: function get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */set: function set(cb) {\n    invalidCallback = cb;\n  }\n});\nexport default ApplyShim;","map":{"version":3,"names":["_classCallCheck","_createClass","forEachRule","processVariableAndFallback","rulesForStyle","toCssText","gatherStyleText","MIXIN_MATCH","VAR_ASSIGN","detectMixin","StyleNode","APPLY_NAME_CLEAN","INITIAL_INHERIT","IMPORTANT","MIXIN_VAR_SEP","PropertyEntry","DependantsEntry","MixinMapEntry","MixinMap","_map","key","value","set","name","props","trim","properties","dependants","get","invalidCallback","ApplyShim","_currentElement","_measureElement","cssText","gatherStyles","template","styleText","content","style","document","createElement","textContent","insertBefore","firstChild","transformTemplate","elementName","_gatheredStyle","undefined","transformStyle","arguments","length","ast","transformRules","transformCustomStyle","_this","rule","transformRule","rules","_this2","r","transformCssText","_this3","replace","matchText","propertyName","valueProperty","valueMixin","_produceCssProperties","_consumeCssProperties","_getInitialValueForProperty","property","setAttribute","all","head","appendChild","window","getComputedStyle","getPropertyValue","_fallbacksFromPreviousRules","startRule","_this4","topRule","fallbacks","seenStartRule","Object","assign","_cssTextToMap","text","m","exec","mixinName","idx","index","applyPos","indexOf","afterApplyPos","textBeforeApply","slice","textAfterApply","defaults","replacement","_atApplyToCssProperties","concat","lastIndex","vars","mixinEntry","p","parts","f","push","test","join","_replaceInitialOrInherit","match","replaceInitialOrInherit","split","out","i","sp","_invalidateMixinEntry","_this5","prefix","mixinAsProperties","mixinValues","combinedProps","oldProps","create","v","needToInvalidate","prototype","defineProperty","cb"],"sources":["/workspaces/frontend/node_modules/@webcomponents/shadycss/src/apply-shim.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\n// prettier-ignore\nimport {forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText} from './style-util.js';\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex.js';\nimport {detectMixin} from './common-utils.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nlet PropertyEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nlet DependantsEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nlet MixinMapEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {},\n    };\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n    if (styleText) {\n      const style = /** @type {!HTMLStyleElement} */ (document.createElement(\n        'style'\n      ));\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, (rule) => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n      this.transformRule(rule);\n    });\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, (r) => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(\n      VAR_ASSIGN,\n      (matchText, propertyName, valueProperty, valueMixin) =>\n        this._produceCssProperties(\n          matchText,\n          propertyName,\n          valueProperty,\n          valueMixin,\n          rule\n        )\n    );\n    // consume mixins\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */ (document.createElement(\n        'meta'\n      ));\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window\n      .getComputedStyle(this._measureElement)\n      .getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, (r) => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n      if (seenStartRule) {\n        return;\n      }\n      // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while ((m = MIXIN_MATCH.exec(text))) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n        parts.push(')');\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = sp.slice(1).join(':');\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  _produceCssProperties(\n    matchText,\n    propertyName,\n    valueProperty,\n    valueMixin,\n    rule\n  ) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`;\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] =\n  ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] =\n  ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  },\n});\n\nexport default ApplyShim;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AAAA,OAAAA,eAAA;AAAA,OAAAC,YAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,SAAQC,WAAW,EAAEC,0BAA0B,EAAEC,aAAa,EAAEC,SAAS,EAAEC,eAAe,QAAO,iBAAiB;AAClH,SAAQC,WAAW,EAAEC,UAAU,QAAO,mBAAmB;AACzD,SAAQC,WAAW,IAAXA,YAAW,QAAO,mBAAmB;AAC7C,SAAQC,SAAS,QAAO,gBAAgB,CAAC,CAAC;;AAE1C,IAAMC,gBAAgB,GAAG,OAAO;AAChC,IAAMC,eAAe,GAAG,6BAA6B;AACrD,IAAMC,SAAS,GAAG,eAAe;;AAEjC;AACA;AACA,IAAMC,aAAa,GAAG,KAAK;;AAE3B;AACA;AACA;AACA,IAAIC,aAAa,CAAC,CAAC;;AAEnB;AACA;AACA;AACA,IAAIC,eAAe,CAAC,CAAC;;AAErB;AACA;AACA;AACA;AACA;AACA,IAAIC,aAAa,CAAC,CAAC;;AAEnB;AACA;AAAA,IACMC,QAAQ;EACZ,SAAAA,SAAA,EAAc;IAAAlB,eAAA,OAAAkB,QAAA;IACZ;IACA,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;EAChB;EACA;AACF;AACA;AACA;EAHElB,YAAA,CAAAiB,QAAA;IAAAE,GAAA;IAAAC,KAAA,EAIA,SAAAC,IAAIC,IAAI,EAAEC,KAAK,EAAE;MACfD,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,CAAC;MAClB,IAAI,CAACN,IAAI,CAACI,IAAI,CAAC,GAAG;QAChBG,UAAU,EAAEF,KAAK;QACjBG,UAAU,EAAE,CAAC;MACf,CAAC;IACH;IACA;AACF;AACA;AACA;EAHE;IAAAP,GAAA;IAAAC,KAAA,EAIA,SAAAO,IAAIL,IAAI,EAAE;MACRA,IAAI,GAAGA,IAAI,CAACE,IAAI,CAAC,CAAC;MAClB,OAAO,IAAI,CAACN,IAAI,CAACI,IAAI,CAAC,IAAI,IAAI;IAChC;EAAC;EAAA,OAAAL,QAAA;AAAA;AAGH;AACA;AACA;AACA;AACA,IAAIW,eAAe,GAAG,IAAI;;AAE1B;AAAA,IACMC,SAAS;EACb,SAAAA,UAAA,EAAc;IAAA9B,eAAA,OAAA8B,SAAA;IACZ;IACA,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B;IACA,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACb,IAAI,GAAG,IAAID,QAAQ,CAAC,CAAC;EAC5B;EACA;AACF;AACA;AACA;AACA;EAJEjB,YAAA,CAAA6B,SAAA;IAAAV,GAAA;IAAAC,KAAA,EAKA,SAAAZ,YAAYwB,OAAO,EAAE;MACnB,OAAOxB,YAAW,CAACwB,OAAO,CAAC;IAC7B;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAAb,GAAA;IAAAC,KAAA,EAKA,SAAAa,aAAaC,QAAQ,EAAE;MACrB,IAAMC,SAAS,GAAG9B,eAAe,CAAC6B,QAAQ,CAACE,OAAO,CAAC;MACnD,IAAID,SAAS,EAAE;QACb,IAAME,KAAK,GAAG,gCAAkCC,QAAQ,CAACC,aAAa,CACpE,OACF,CAAE;QACFF,KAAK,CAACG,WAAW,GAAGL,SAAS;QAC7BD,QAAQ,CAACE,OAAO,CAACK,YAAY,CAACJ,KAAK,EAAEH,QAAQ,CAACE,OAAO,CAACM,UAAU,CAAC;QACjE,OAAOL,KAAK;MACd;MACA,OAAO,IAAI;IACb;IACA;AACF;AACA;AACA;AACA;EAJE;IAAAlB,GAAA;IAAAC,KAAA,EAKA,SAAAuB,kBAAkBT,QAAQ,EAAEU,WAAW,EAAE;MACvC,IAAIV,QAAQ,CAACW,cAAc,KAAKC,SAAS,EAAE;QACzCZ,QAAQ,CAACW,cAAc,GAAG,IAAI,CAACZ,YAAY,CAACC,QAAQ,CAAC;MACvD;MACA;MACA,IAAMG,KAAK,GAAGH,QAAQ,CAACW,cAAc;MACrC,OAAOR,KAAK,GAAG,IAAI,CAACU,cAAc,CAACV,KAAK,EAAEO,WAAW,CAAC,GAAG,IAAI;IAC/D;IACA;AACF;AACA;AACA;AACA;EAJE;IAAAzB,GAAA;IAAAC,KAAA,EAKA,SAAA2B,eAAeV,KAAK,EAAoB;MAAA,IAAlBO,WAAW,GAAAI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,EAAE;MACpC,IAAIE,GAAG,GAAG/C,aAAa,CAACkC,KAAK,CAAC;MAC9B,IAAI,CAACc,cAAc,CAACD,GAAG,EAAEN,WAAW,CAAC;MACrCP,KAAK,CAACG,WAAW,GAAGpC,SAAS,CAAC8C,GAAG,CAAC;MAClC,OAAOA,GAAG;IACZ;IACA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAAgC,qBAAqBf,KAAK,EAAE;MAAA,IAAAgB,KAAA;MAC1B,IAAIH,GAAG,GAAG/C,aAAa,CAACkC,KAAK,CAAC;MAC9BpC,WAAW,CAACiD,GAAG,EAAE,UAACI,IAAI,EAAK;QACzB,IAAIA,IAAI,CAAC,UAAU,CAAC,KAAK,OAAO,EAAE;UAChCA,IAAI,CAAC,UAAU,CAAC,GAAG,MAAM;QAC3B;QACAD,KAAI,CAACE,aAAa,CAACD,IAAI,CAAC;MAC1B,CAAC,CAAC;MACFjB,KAAK,CAACG,WAAW,GAAGpC,SAAS,CAAC8C,GAAG,CAAC;MAClC,OAAOA,GAAG;IACZ;IACA;AACF;AACA;AACA;EAHE;IAAA/B,GAAA;IAAAC,KAAA,EAIA,SAAA+B,eAAeK,KAAK,EAAEZ,WAAW,EAAE;MAAA,IAAAa,MAAA;MACjC,IAAI,CAAC3B,eAAe,GAAGc,WAAW;MAClC3C,WAAW,CAACuD,KAAK,EAAE,UAACE,CAAC,EAAK;QACxBD,MAAI,CAACF,aAAa,CAACG,CAAC,CAAC;MACvB,CAAC,CAAC;MACF,IAAI,CAAC5B,eAAe,GAAG,IAAI;IAC7B;IACA;AACF;AACA;EAFE;IAAAX,GAAA;IAAAC,KAAA,EAGA,SAAAmC,cAAcD,IAAI,EAAE;MAClBA,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAACK,gBAAgB,CAACL,IAAI,CAAC,eAAe,CAAC,EAAEA,IAAI,CAAC;MACpE;MACA;MACA;MACA,IAAIA,IAAI,CAAC,UAAU,CAAC,KAAK,OAAO,EAAE;QAChCA,IAAI,CAAC,UAAU,CAAC,GAAG,WAAW;MAChC;IACF;IACA;AACF;AACA;AACA;AACA;EAJE;IAAAnC,GAAA;IAAAC,KAAA,EAKA,SAAAuC,iBAAiB3B,OAAO,EAAEsB,IAAI,EAAE;MAAA,IAAAM,MAAA;MAC9B;MACA5B,OAAO,GAAGA,OAAO,CAAC6B,OAAO,CACvBtD,UAAU,EACV,UAACuD,SAAS,EAAEC,YAAY,EAAEC,aAAa,EAAEC,UAAU;QAAA,OACjDL,MAAI,CAACM,qBAAqB,CACxBJ,SAAS,EACTC,YAAY,EACZC,aAAa,EACbC,UAAU,EACVX,IACF,CAAC;MAAA,CACL,CAAC;MACD;MACA,OAAO,IAAI,CAACa,qBAAqB,CAACnC,OAAO,EAAEsB,IAAI,CAAC;IAClD;IACA;AACF;AACA;AACA;EAHE;IAAAnC,GAAA;IAAAC,KAAA,EAIA,SAAAgD,4BAA4BC,QAAQ,EAAE;MACpC,IAAI,CAAC,IAAI,CAACtC,eAAe,EAAE;QACzB,IAAI,CAACA,eAAe,GAAG,8BAAgCO,QAAQ,CAACC,aAAa,CAC3E,MACF,CAAE;QACF,IAAI,CAACR,eAAe,CAACuC,YAAY,CAAC,oBAAoB,EAAE,EAAE,CAAC;QAC3D,IAAI,CAACvC,eAAe,CAACM,KAAK,CAACkC,GAAG,GAAG,SAAS;QAC1CjC,QAAQ,CAACkC,IAAI,CAACC,WAAW,CAAC,IAAI,CAAC1C,eAAe,CAAC;MACjD;MACA,OAAO2C,MAAM,CACVC,gBAAgB,CAAC,IAAI,CAAC5C,eAAe,CAAC,CACtC6C,gBAAgB,CAACP,QAAQ,CAAC;IAC/B;IACA;AACF;AACA;AACA;AACA;AACA;EALE;IAAAlD,GAAA;IAAAC,KAAA,EAMA,SAAAyD,4BAA4BC,SAAS,EAAE;MAAA,IAAAC,MAAA;MACrC;MACA,IAAIC,OAAO,GAAGF,SAAS;MACvB,OAAOE,OAAO,CAAC,QAAQ,CAAC,EAAE;QACxBA,OAAO,GAAGA,OAAO,CAAC,QAAQ,CAAC;MAC7B;MACA,IAAMC,SAAS,GAAG,CAAC,CAAC;MACpB,IAAIC,aAAa,GAAG,KAAK;MACzBjF,WAAW,CAAC+E,OAAO,EAAE,UAACtB,CAAC,EAAK;QAC1B;QACAwB,aAAa,GAAGA,aAAa,IAAIxB,CAAC,KAAKoB,SAAS;QAChD,IAAII,aAAa,EAAE;UACjB;QACF;QACA;QACA;QACA;QACA;QACA,IAAIxB,CAAC,CAAC,UAAU,CAAC,KAAKoB,SAAS,CAAC,UAAU,CAAC,EAAE;UAC3CK,MAAM,CAACC,MAAM,CAACH,SAAS,EAAEF,MAAI,CAACM,aAAa,CAAC3B,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC;QAClE;MACF,CAAC,CAAC;MACF,OAAOuB,SAAS;IAClB;IACA;AACF;AACA;AACA;AACA;AACA;EALE;IAAA9D,GAAA;IAAAC,KAAA,EAMA,SAAA+C,sBAAsBmB,IAAI,EAAEhC,IAAI,EAAE;MAChC;MACA,IAAIiC,CAAC,GAAG,IAAI;MACZ;MACA,OAAQA,CAAC,GAAGjF,WAAW,CAACkF,IAAI,CAACF,IAAI,CAAC,EAAG;QACnC,IAAIxB,SAAS,GAAGyB,CAAC,CAAC,CAAC,CAAC;QACpB,IAAIE,SAAS,GAAGF,CAAC,CAAC,CAAC,CAAC;QACpB,IAAIG,GAAG,GAAGH,CAAC,CAACI,KAAK;QACjB;QACA;QACA,IAAIC,QAAQ,GAAGF,GAAG,GAAG5B,SAAS,CAAC+B,OAAO,CAAC,QAAQ,CAAC;QAChD,IAAIC,aAAa,GAAGJ,GAAG,GAAG5B,SAAS,CAACb,MAAM;QAC1C;QACA,IAAI8C,eAAe,GAAGT,IAAI,CAACU,KAAK,CAAC,CAAC,EAAEJ,QAAQ,CAAC;QAC7C,IAAIK,cAAc,GAAGX,IAAI,CAACU,KAAK,CAACF,aAAa,CAAC;QAC9C,IAAII,QAAQ,GAAG5C,IAAI,GAAG,IAAI,CAACuB,2BAA2B,CAACvB,IAAI,CAAC,GAAG,CAAC,CAAC;QACjE6B,MAAM,CAACC,MAAM,CAACc,QAAQ,EAAE,IAAI,CAACb,aAAa,CAACU,eAAe,CAAC,CAAC;QAC5D,IAAII,WAAW,GAAG,IAAI,CAACC,uBAAuB,CAACX,SAAS,EAAES,QAAQ,CAAC;QACnE;QACAZ,IAAI,MAAAe,MAAA,CAAMN,eAAe,EAAAM,MAAA,CAAGF,WAAW,EAAAE,MAAA,CAAGJ,cAAc,CAAE;QAC1D;QACA3F,WAAW,CAACgG,SAAS,GAAGZ,GAAG,GAAGS,WAAW,CAAClD,MAAM;MAClD;MACA,OAAOqC,IAAI;IACb;IACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EATE;IAAAnE,GAAA;IAAAC,KAAA,EAUA,SAAAgF,wBAAwBX,SAAS,EAAER,SAAS,EAAE;MAC5CQ,SAAS,GAAGA,SAAS,CAAC5B,OAAO,CAACnD,gBAAgB,EAAE,EAAE,CAAC;MACnD,IAAI6F,IAAI,GAAG,EAAE;MACb,IAAIC,UAAU,GAAG,IAAI,CAACtF,IAAI,CAACS,GAAG,CAAC8D,SAAS,CAAC;MACzC;MACA;MACA,IAAI,CAACe,UAAU,EAAE;QACf,IAAI,CAACtF,IAAI,CAACG,GAAG,CAACoE,SAAS,EAAE,CAAC,CAAC,CAAC;QAC5Be,UAAU,GAAG,IAAI,CAACtF,IAAI,CAACS,GAAG,CAAC8D,SAAS,CAAC;MACvC;MACA,IAAIe,UAAU,EAAE;QACd,IAAI,IAAI,CAAC1E,eAAe,EAAE;UACxB0E,UAAU,CAAC9E,UAAU,CAAC,IAAI,CAACI,eAAe,CAAC,GAAG,IAAI;QACpD;QACA,IAAI2E,CAAC,EAAEC,KAAK,EAAEC,CAAC;QACf,IAAMlF,UAAU,GAAG+E,UAAU,CAAC/E,UAAU;QACxC,KAAKgF,CAAC,IAAIhF,UAAU,EAAE;UACpBkF,CAAC,GAAG1B,SAAS,IAAIA,SAAS,CAACwB,CAAC,CAAC;UAC7BC,KAAK,GAAG,CAACD,CAAC,EAAE,QAAQ,EAAEhB,SAAS,EAAE5E,aAAa,EAAE4F,CAAC,CAAC;UAClD,IAAIE,CAAC,EAAE;YACLD,KAAK,CAACE,IAAI,CAAC,GAAG,EAAED,CAAC,CAAC9C,OAAO,CAACjD,SAAS,EAAE,EAAE,CAAC,CAAC;UAC3C;UACA8F,KAAK,CAACE,IAAI,CAAC,GAAG,CAAC;UACf,IAAIhG,SAAS,CAACiG,IAAI,CAACpF,UAAU,CAACgF,CAAC,CAAC,CAAC,EAAE;YACjCC,KAAK,CAACE,IAAI,CAAC,aAAa,CAAC;UAC3B;UACAL,IAAI,CAACK,IAAI,CAACF,KAAK,CAACI,IAAI,CAAC,EAAE,CAAC,CAAC;QAC3B;MACF;MACA,OAAOP,IAAI,CAACO,IAAI,CAAC,IAAI,CAAC;IACxB;;IAEA;AACF;AACA;AACA;AACA;EAJE;IAAA3F,GAAA;IAAAC,KAAA,EAKA,SAAA2F,yBAAyB1C,QAAQ,EAAEjD,KAAK,EAAE;MACxC,IAAI4F,KAAK,GAAGrG,eAAe,CAAC6E,IAAI,CAACpE,KAAK,CAAC;MACvC,IAAI4F,KAAK,EAAE;QACT,IAAIA,KAAK,CAAC,CAAC,CAAC,EAAE;UACZ;UACA;UACA5F,KAAK,GAAG,IAAI,CAACgD,2BAA2B,CAACC,QAAQ,CAAC;QACpD,CAAC,MAAM;UACL;UACA;UACA;UACA;UACA;UACAjD,KAAK,GAAG,oBAAoB;QAC9B;MACF;MACA,OAAOA,KAAK;IACd;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;EANE;IAAAD,GAAA;IAAAC,KAAA,EAOA,SAAAiE,cAAcC,IAAI,EAAmC;MAAA,IAAjC2B,uBAAuB,GAAAjE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAF,SAAA,GAAAE,SAAA,MAAG,KAAK;MACjD,IAAIzB,KAAK,GAAG+D,IAAI,CAAC4B,KAAK,CAAC,GAAG,CAAC;MAC3B,IAAI7C,QAAQ,EAAEjD,KAAK;MACnB,IAAI+F,GAAG,GAAG,CAAC,CAAC;MACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEX,CAAC,EAAEY,EAAE,EAAED,CAAC,GAAG7F,KAAK,CAAC0B,MAAM,EAAEmE,CAAC,EAAE,EAAE;QAC5CX,CAAC,GAAGlF,KAAK,CAAC6F,CAAC,CAAC;QACZ,IAAIX,CAAC,EAAE;UACLY,EAAE,GAAGZ,CAAC,CAACS,KAAK,CAAC,GAAG,CAAC;UACjB;UACA,IAAIG,EAAE,CAACpE,MAAM,GAAG,CAAC,EAAE;YACjBoB,QAAQ,GAAGgD,EAAE,CAAC,CAAC,CAAC,CAAC7F,IAAI,CAAC,CAAC;YACvB;YACAJ,KAAK,GAAGiG,EAAE,CAACrB,KAAK,CAAC,CAAC,CAAC,CAACc,IAAI,CAAC,GAAG,CAAC;YAC7B,IAAIG,uBAAuB,EAAE;cAC3B7F,KAAK,GAAG,IAAI,CAAC2F,wBAAwB,CAAC1C,QAAQ,EAAEjD,KAAK,CAAC;YACxD;YACA+F,GAAG,CAAC9C,QAAQ,CAAC,GAAGjD,KAAK;UACvB;QACF;MACF;MACA,OAAO+F,GAAG;IACZ;;IAEA;AACF;AACA;EAFE;IAAAhG,GAAA;IAAAC,KAAA,EAGA,SAAAkG,sBAAsBd,UAAU,EAAE;MAChC,IAAI,CAAC5E,eAAe,EAAE;QACpB;MACF;MACA,KAAK,IAAIgB,WAAW,IAAI4D,UAAU,CAAC9E,UAAU,EAAE;QAC7C,IAAIkB,WAAW,KAAK,IAAI,CAACd,eAAe,EAAE;UACxCF,eAAe,CAACgB,WAAW,CAAC;QAC9B;MACF;IACF;;IAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAAzB,GAAA;IAAAC,KAAA,EAQA,SAAA8C,sBACEJ,SAAS,EACTC,YAAY,EACZC,aAAa,EACbC,UAAU,EACVX,IAAI,EACJ;MAAA,IAAAiE,MAAA;MACA;MACA,IAAIvD,aAAa,EAAE;QACjB;QACA9D,0BAA0B,CAAC8D,aAAa,EAAE,UAACwD,MAAM,EAAEpG,KAAK,EAAK;UAC3D,IAAIA,KAAK,IAAImG,MAAI,CAACrG,IAAI,CAACS,GAAG,CAACP,KAAK,CAAC,EAAE;YACjC6C,UAAU,aAAAoC,MAAA,CAAajF,KAAK,MAAG;UACjC;QACF,CAAC,CAAC;MACJ;MACA,IAAI,CAAC6C,UAAU,EAAE;QACf,OAAOH,SAAS;MAClB;MACA,IAAI2D,iBAAiB,GAAG,IAAI,CAACtD,qBAAqB,CAAC,EAAE,GAAGF,UAAU,EAAEX,IAAI,CAAC;MACzE,IAAIkE,MAAM,GAAG1D,SAAS,CAACkC,KAAK,CAAC,CAAC,EAAElC,SAAS,CAAC+B,OAAO,CAAC,IAAI,CAAC,CAAC;MACxD;MACA;MACA;MACA,IAAI6B,WAAW,GAAG,IAAI,CAACrC,aAAa,CAACoC,iBAAiB,EAAE,IAAI,CAAC;MAC7D,IAAIE,aAAa,GAAGD,WAAW;MAC/B,IAAIlB,UAAU,GAAG,IAAI,CAACtF,IAAI,CAACS,GAAG,CAACoC,YAAY,CAAC;MAC5C,IAAI6D,QAAQ,GAAGpB,UAAU,IAAIA,UAAU,CAAC/E,UAAU;MAClD,IAAImG,QAAQ,EAAE;QACZ;QACA;QACAD,aAAa,GAAGxC,MAAM,CAACC,MAAM,CAACD,MAAM,CAAC0C,MAAM,CAACD,QAAQ,CAAC,EAAEF,WAAW,CAAC;MACrE,CAAC,MAAM;QACL,IAAI,CAACxG,IAAI,CAACG,GAAG,CAAC0C,YAAY,EAAE4D,aAAa,CAAC;MAC5C;MACA,IAAIR,GAAG,GAAG,EAAE;MACZ,IAAIV,CAAC,EAAEqB,CAAC;MACR;MACA,IAAIC,gBAAgB,GAAG,KAAK;MAC5B,KAAKtB,CAAC,IAAIkB,aAAa,EAAE;QACvBG,CAAC,GAAGJ,WAAW,CAACjB,CAAC,CAAC;QAClB;QACA,IAAIqB,CAAC,KAAKhF,SAAS,EAAE;UACnBgF,CAAC,GAAG,SAAS;QACf;QACA,IAAIF,QAAQ,IAAI,EAAEnB,CAAC,IAAImB,QAAQ,CAAC,EAAE;UAChCG,gBAAgB,GAAG,IAAI;QACzB;QACAZ,GAAG,CAACP,IAAI,IAAAP,MAAA,CAAItC,YAAY,EAAAsC,MAAA,CAAGxF,aAAa,EAAAwF,MAAA,CAAGI,CAAC,QAAAJ,MAAA,CAAKyB,CAAC,CAAE,CAAC;MACvD;MACA,IAAIC,gBAAgB,EAAE;QACpB,IAAI,CAACT,qBAAqB,CAACd,UAAU,CAAC;MACxC;MACA,IAAIA,UAAU,EAAE;QACdA,UAAU,CAAC/E,UAAU,GAAGkG,aAAa;MACvC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI3D,aAAa,EAAE;QACjBwD,MAAM,MAAAnB,MAAA,CAAMvC,SAAS,OAAAuC,MAAA,CAAImB,MAAM,CAAE;MACnC;MACA,UAAAnB,MAAA,CAAUmB,MAAM,EAAAnB,MAAA,CAAGc,GAAG,CAACL,IAAI,CAAC,IAAI,CAAC;IACnC;EAAC;EAAA,OAAAjF,SAAA;AAAA;AAGH;AACA;AACAA,SAAS,CAACmG,SAAS,CAAC,aAAa,CAAC,GAAGnG,SAAS,CAACmG,SAAS,CAACxH,WAAW;AACpEqB,SAAS,CAACmG,SAAS,CAAC,gBAAgB,CAAC,GAAGnG,SAAS,CAACmG,SAAS,CAACjF,cAAc;AAC1ElB,SAAS,CAACmG,SAAS,CAAC,sBAAsB,CAAC,GACzCnG,SAAS,CAACmG,SAAS,CAAC5E,oBAAoB;AAC1CvB,SAAS,CAACmG,SAAS,CAAC,gBAAgB,CAAC,GAAGnG,SAAS,CAACmG,SAAS,CAAC7E,cAAc;AAC1EtB,SAAS,CAACmG,SAAS,CAAC,eAAe,CAAC,GAAGnG,SAAS,CAACmG,SAAS,CAACzE,aAAa;AACxE1B,SAAS,CAACmG,SAAS,CAAC,mBAAmB,CAAC,GACtCnG,SAAS,CAACmG,SAAS,CAACrF,iBAAiB;AACvCd,SAAS,CAACmG,SAAS,CAAC,YAAY,CAAC,GAAGnH,aAAa;AACjD;AACAsE,MAAM,CAAC8C,cAAc,CAACpG,SAAS,CAACmG,SAAS,EAAE,iBAAiB,EAAE;EAC5D,kCACArG,GAAG,WAAAA,IAAA,EAAG;IACJ,OAAOC,eAAe;EACxB,CAAC;EACD,oCACAP,GAAG,WAAAA,IAAC6G,EAAE,EAAE;IACNtG,eAAe,GAAGsG,EAAE;EACtB;AACF,CAAC,CAAC;AAEF,eAAerG,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}