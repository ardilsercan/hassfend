{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport IntlMessageFormat from \"intl-messageformat\";\nimport { polyfillLocaleData } from \"../../resources/locale-data-polyfill\";\n\n// Exclude some patterns from key type checking for now\n// These are intended to be removed as errors are fixed\n// Fixing component category will require tighter definition of types from backend and/or web socket\n\n// Tweaked from https://www.raygesualdo.com/posts/flattening-object-keys-with-typescript-types\n\n// Later, don't return string when HTML is passed, and don't allow undefined\n\n/**\n * Adapted from Polymer app-localize-behavior.\n *\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Optional dictionary of user defined formats, as explained here:\n * http://formatjs.io/guides/message-syntax/#custom-formats\n *\n * For example, a valid dictionary of formats would be:\n * this.formats = {\n *    number: { USD: { style: 'currency', currency: 'USD' } }\n * }\n */\n\nexport var computeLocalize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cache, language, resources, formats) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return import(\"../../resources/intl-polyfill\").then(function () {\n            return polyfillLocaleData(language);\n          });\n        case 2:\n          // Every time any of the parameters change, invalidate the strings cache.\n          cache._localizationCache = {};\n          return _context.abrupt(\"return\", function (key) {\n            if (!key || !resources || !language || !resources[language]) {\n              return \"\";\n            }\n\n            // Cache the key/value pairs for the same language, so that we don't\n            // do extra work if we're just reusing strings across an application.\n            var translatedValue = resources[language][key];\n            if (!translatedValue) {\n              return \"\";\n            }\n            var messageKey = key + translatedValue;\n            var translatedMessage = cache._localizationCache[messageKey];\n            if (!translatedMessage) {\n              try {\n                translatedMessage = new IntlMessageFormat(translatedValue, language, formats);\n              } catch (err) {\n                return \"Translation error: \" + err.message;\n              }\n              cache._localizationCache[messageKey] = translatedMessage;\n            }\n            var argObject = {};\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            if (args.length === 1 && _typeof(args[0]) === \"object\") {\n              argObject = args[0];\n            } else {\n              for (var i = 0; i < args.length; i += 2) {\n                // @ts-expect-error in some places the old format (key, value, key, value) is used\n                argObject[args[i]] = args[i + 1];\n              }\n            }\n            try {\n              return translatedMessage.format(argObject);\n            } catch (err) {\n              return \"Translation \" + err;\n            }\n          });\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function computeLocalize(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["IntlMessageFormat","polyfillLocaleData","computeLocalize","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","cache","language","resources","formats","wrap","_callee$","_context","prev","next","then","_localizationCache","abrupt","key","translatedValue","messageKey","translatedMessage","err","message","argObject","_len","arguments","length","args","Array","_key","_typeof","i","format","stop","_x","_x2","_x3","_x4","apply"],"sources":["/workspaces/frontend/src/common/translations/localize.ts"],"sourcesContent":["import IntlMessageFormat from \"intl-messageformat\";\nimport type { HTMLTemplateResult } from \"lit\";\nimport { polyfillLocaleData } from \"../../resources/locale-data-polyfill\";\nimport { Resources, TranslationDict } from \"../../types\";\n\n// Exclude some patterns from key type checking for now\n// These are intended to be removed as errors are fixed\n// Fixing component category will require tighter definition of types from backend and/or web socket\nexport type LocalizeKeys =\n  | FlattenObjectKeys<Omit<TranslationDict, \"supervisor\">>\n  | `panel.${string}`\n  | `ui.card.alarm_control_panel.${string}`\n  | `ui.card.weather.attributes.${string}`\n  | `ui.card.weather.cardinal_direction.${string}`\n  | `ui.card.lawn_mower.actions.${string}`\n  | `ui.components.calendar.event.rrule.${string}`\n  | `ui.components.logbook.${string}`\n  | `ui.components.selectors.file.${string}`\n  | `ui.dialogs.entity_registry.editor.${string}`\n  | `ui.dialogs.more_info_control.lawn_mower.${string}`\n  | `ui.dialogs.more_info_control.vacuum.${string}`\n  | `ui.dialogs.quick-bar.commands.${string}`\n  | `ui.dialogs.unhealthy.reason.${string}`\n  | `ui.dialogs.unsupported.reason.${string}`\n  | `ui.panel.config.${string}.${\"caption\" | \"description\"}`\n  | `ui.panel.config.dashboard.${string}`\n  | `ui.panel.config.zha.${string}`\n  | `ui.panel.config.zwave_js.${string}`\n  | `ui.panel.lovelace.card.${string}`\n  | `ui.panel.lovelace.editor.${string}`\n  | `ui.panel.page-authorize.form.${string}`\n  | `component.${string}`;\n\n// Tweaked from https://www.raygesualdo.com/posts/flattening-object-keys-with-typescript-types\nexport type FlattenObjectKeys<\n  T extends Record<string, any>,\n  Key extends keyof T = keyof T,\n> = Key extends string\n  ? T[Key] extends Record<string, unknown>\n    ? `${Key}.${FlattenObjectKeys<T[Key]>}`\n    : `${Key}`\n  : never;\n\n// Later, don't return string when HTML is passed, and don't allow undefined\nexport type LocalizeFunc<Keys extends string = LocalizeKeys> = (\n  key: Keys,\n  values?: Record<\n    string,\n    string | number | HTMLTemplateResult | null | undefined\n  >\n) => string;\n\ninterface FormatType {\n  [format: string]: any;\n}\nexport interface FormatsType {\n  number: FormatType;\n  date: FormatType;\n  time: FormatType;\n}\n\n/**\n * Adapted from Polymer app-localize-behavior.\n *\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Optional dictionary of user defined formats, as explained here:\n * http://formatjs.io/guides/message-syntax/#custom-formats\n *\n * For example, a valid dictionary of formats would be:\n * this.formats = {\n *    number: { USD: { style: 'currency', currency: 'USD' } }\n * }\n */\n\nexport const computeLocalize = async <Keys extends string = LocalizeKeys>(\n  cache: any,\n  language: string,\n  resources: Resources,\n  formats?: FormatsType\n): Promise<LocalizeFunc<Keys>> => {\n  await import(\"../../resources/intl-polyfill\").then(() =>\n    polyfillLocaleData(language)\n  );\n\n  // Every time any of the parameters change, invalidate the strings cache.\n  cache._localizationCache = {};\n\n  return (key, ...args) => {\n    if (!key || !resources || !language || !resources[language]) {\n      return \"\";\n    }\n\n    // Cache the key/value pairs for the same language, so that we don't\n    // do extra work if we're just reusing strings across an application.\n    const translatedValue = resources[language][key];\n\n    if (!translatedValue) {\n      return \"\";\n    }\n\n    const messageKey = key + translatedValue;\n    let translatedMessage = cache._localizationCache[messageKey] as\n      | IntlMessageFormat\n      | undefined;\n\n    if (!translatedMessage) {\n      try {\n        translatedMessage = new IntlMessageFormat(\n          translatedValue,\n          language,\n          formats\n        );\n      } catch (err: any) {\n        return \"Translation error: \" + err.message;\n      }\n      cache._localizationCache[messageKey] = translatedMessage;\n    }\n\n    let argObject = {};\n    if (args.length === 1 && typeof args[0] === \"object\") {\n      argObject = args[0];\n    } else {\n      for (let i = 0; i < args.length; i += 2) {\n        // @ts-expect-error in some places the old format (key, value, key, value) is used\n        argObject[args[i]] = args[i + 1];\n      }\n    }\n\n    try {\n      return translatedMessage.format<string>(argObject) as string;\n    } catch (err: any) {\n      return \"Translation \" + err;\n    }\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}