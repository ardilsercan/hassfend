{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { formatNumber, numberFormatToLocale, getNumberFormatOptions } from \"../../common/number/format_number\";\nimport { getDisplayUnit, getStatisticLabel, getStatisticMetadata, statisticsHaveType } from \"../../data/recorder\";\nimport \"./ha-chart-base\";\nexport const supportedStatTypeMap = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"sum\",\n  change: \"sum\"\n};\nexport let StatisticsChart = _decorate([customElement(\"statistics-chart\")], function (_initialize, _LitElement) {\n  class StatisticsChart extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: StatisticsChart,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"statisticsData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"metadata\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"names\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Array\n      })],\n      key: \"statTypes\",\n      value() {\n        return [\"sum\", \"min\", \"mean\", \"max\"];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"chartType\",\n      value() {\n        return \"line\";\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"hideLegend\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"logarithmicScale\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"isLoadingData\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"period\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartData\",\n      value() {\n        return {\n          datasets: []\n        };\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_statisticIds\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [query(\"ha-chart-base\")],\n      key: \"_chart\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_computedStyle\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"resize\",\n      value() {\n        return options => {\n          var _this$_chart;\n          (_this$_chart = this._chart) === null || _this$_chart === void 0 || _this$_chart.resize(options);\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        return changedProps.size > 1 || !changedProps.has(\"hass\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated || changedProps.has(\"unit\") || changedProps.has(\"period\") || changedProps.has(\"chartType\") || changedProps.has(\"logarithmicScale\") || changedProps.has(\"hideLegend\")) {\n          this._createOptions();\n        }\n        if (changedProps.has(\"statisticsData\") || changedProps.has(\"statTypes\") || changedProps.has(\"chartType\") || changedProps.has(\"hideLegend\")) {\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated() {\n        this._computedStyle = getComputedStyle(this);\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!isComponentLoaded(this.hass, \"history\")) {\n          return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n        }\n        if (this.isLoadingData && !this.statisticsData) {\n          return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.loading_statistics\")}\n      </div>`;\n        }\n        if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n          return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.no_statistics_found\")}\n      </div>`;\n        }\n        return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_createOptions\",\n      value: function _createOptions(unit) {\n        this._chartOptions = {\n          parsing: false,\n          animation: false,\n          interaction: {\n            mode: \"nearest\",\n            axis: \"x\"\n          },\n          scales: {\n            x: {\n              type: \"time\",\n              adapters: {\n                date: {\n                  locale: this.hass.locale,\n                  config: this.hass.config\n                }\n              },\n              ticks: {\n                source: this.chartType === \"bar\" ? \"data\" : undefined,\n                maxRotation: 0,\n                sampleSize: 5,\n                autoSkipPadding: 20,\n                major: {\n                  enabled: true\n                },\n                font: context => context.tick && context.tick.major ? {\n                  weight: \"bold\"\n                } : {}\n              },\n              time: {\n                tooltipFormat: \"datetime\",\n                unit: this.chartType === \"bar\" && this.period && [\"hour\", \"day\", \"week\", \"month\"].includes(this.period) ? this.period : undefined\n              }\n            },\n            y: {\n              beginAtZero: this.chartType === \"bar\",\n              ticks: {\n                maxTicksLimit: 7\n              },\n              title: {\n                display: unit || this.unit,\n                text: unit || this.unit\n              },\n              type: this.logarithmicScale ? \"logarithmic\" : \"linear\"\n            }\n          },\n          plugins: {\n            tooltip: {\n              callbacks: {\n                label: context => `${context.dataset.label}: ${formatNumber(context.parsed.y, this.hass.locale, getNumberFormatOptions(undefined, this.hass.entities[this._statisticIds[context.datasetIndex]]))} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"}`\n              }\n            },\n            filler: {\n              propagate: true\n            },\n            legend: {\n              display: !this.hideLegend,\n              labels: {\n                usePointStyle: true\n              }\n            }\n          },\n          elements: {\n            line: {\n              tension: 0.4,\n              cubicInterpolationMode: \"monotone\",\n              borderWidth: 1.5\n            },\n            bar: {\n              borderWidth: 1.5,\n              borderRadius: 4\n            },\n            point: {\n              hitRadius: 50\n            }\n          },\n          // @ts-expect-error\n          locale: numberFormatToLocale(this.hass.locale)\n        };\n      }\n    }, {\n      kind: \"field\",\n      key: \"_getStatisticsMetaData\",\n      value() {\n        return memoizeOne(async statisticIds => {\n          const statsMetadataArray = await getStatisticMetadata(this.hass, statisticIds);\n          const statisticsMetaData = {};\n          statsMetadataArray.forEach(x => {\n            statisticsMetaData[x.statistic_id] = x;\n          });\n          return statisticsMetaData;\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: async function _generateData() {\n        if (!this.statisticsData) {\n          return;\n        }\n        const statisticsMetaData = this.metadata || (await this._getStatisticsMetaData(Object.keys(this.statisticsData)));\n        let colorIndex = 0;\n        const statisticsData = Object.entries(this.statisticsData);\n        const totalDataSets = [];\n        const statisticIds = [];\n        let endTime;\n        if (statisticsData.length === 0) {\n          return;\n        }\n        endTime = this.endTime ||\n        // Get the highest date from the last date of each statistic\n        new Date(Math.max(...statisticsData.map(([_, stats]) => new Date(stats[stats.length - 1].start).getTime())));\n        if (endTime > new Date()) {\n          endTime = new Date();\n        }\n        let unit;\n        const names = this.names || {};\n        statisticsData.forEach(([statistic_id, stats]) => {\n          const meta = statisticsMetaData === null || statisticsMetaData === void 0 ? void 0 : statisticsMetaData[statistic_id];\n          let name = names[statistic_id];\n          if (name === undefined) {\n            name = getStatisticLabel(this.hass, statistic_id, meta);\n          }\n          if (!this.unit) {\n            if (unit === undefined) {\n              unit = getDisplayUnit(this.hass, statistic_id, meta);\n            } else if (unit !== null && unit !== getDisplayUnit(this.hass, statistic_id, meta)) {\n              // Clear unit if not all statistics have same unit\n              unit = null;\n            }\n          }\n\n          // array containing [value1, value2, etc]\n          let prevValues = null;\n          let prevEndTime;\n\n          // The datasets for the current statistic\n          const statDataSets = [];\n          const pushData = (start, end, dataValues) => {\n            if (!dataValues) return;\n            if (start > end) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n            statDataSets.forEach((d, i) => {\n              if (this.chartType === \"line\" && prevEndTime && prevValues && prevEndTime.getTime() !== start.getTime()) {\n                // if the end of the previous data doesn't match the start of the current data,\n                // we have to draw a gap so add a value at the end time, and then an empty value.\n                d.data.push({\n                  x: prevEndTime.getTime(),\n                  y: prevValues[i]\n                });\n                // @ts-expect-error\n                d.data.push({\n                  x: prevEndTime.getTime(),\n                  y: null\n                });\n              }\n              d.data.push({\n                x: start.getTime(),\n                y: dataValues[i]\n              });\n            });\n            prevValues = dataValues;\n            prevEndTime = end;\n          };\n          const color = getGraphColorByIndex(colorIndex, this._computedStyle || getComputedStyle(this));\n          colorIndex++;\n          const statTypes = [];\n          const hasMean = this.statTypes.includes(\"mean\") && statisticsHaveType(stats, \"mean\");\n          const drawBands = hasMean || this.statTypes.includes(\"min\") && statisticsHaveType(stats, \"min\") && this.statTypes.includes(\"max\") && statisticsHaveType(stats, \"max\");\n          const sortedTypes = drawBands ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          }) : this.statTypes;\n          sortedTypes.forEach(type => {\n            if (statisticsHaveType(stats, type)) {\n              const band = drawBands && (type === \"min\" || type === \"max\");\n              statTypes.push(type);\n              statDataSets.push({\n                label: name ? `${name} (${this.hass.localize(`ui.components.statistics_charts.statistic_types.${type}`)})\n            ` : this.hass.localize(`ui.components.statistics_charts.statistic_types.${type}`),\n                fill: drawBands ? type === \"min\" && hasMean ? \"+1\" : type === \"max\" ? \"-1\" : false : false,\n                borderColor: band && hasMean ? color + (this.hideLegend ? \"00\" : \"7F\") : color,\n                backgroundColor: band ? color + \"3F\" : color + \"7F\",\n                pointRadius: 0,\n                data: [],\n                // @ts-ignore\n                unit: meta === null || meta === void 0 ? void 0 : meta.unit_of_measurement,\n                band\n              });\n              statisticIds.push(statistic_id);\n            }\n          });\n          let prevDate = null;\n          // Process chart data.\n          let firstSum = null;\n          stats.forEach(stat => {\n            const startDate = new Date(stat.start);\n            if (prevDate === startDate) {\n              return;\n            }\n            prevDate = startDate;\n            const dataValues = [];\n            statTypes.forEach(type => {\n              var _val;\n              let val;\n              if (type === \"sum\") {\n                if (firstSum === null || firstSum === undefined) {\n                  val = 0;\n                  firstSum = stat.sum;\n                } else {\n                  val = (stat.sum || 0) - firstSum;\n                }\n              } else {\n                val = stat[type];\n              }\n              dataValues.push((_val = val) !== null && _val !== void 0 ? _val : null);\n            });\n            pushData(startDate, new Date(stat.end), dataValues);\n          });\n\n          // Concat two arrays\n          Array.prototype.push.apply(totalDataSets, statDataSets);\n        });\n        if (unit) {\n          this._createOptions(unit);\n        }\n        this._chartData = {\n          datasets: totalDataSets\n        };\n        this._statisticIds = statisticIds;\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","customElement","property","state","query","memoizeOne","getGraphColorByIndex","isComponentLoaded","formatNumber","numberFormatToLocale","getNumberFormatOptions","getDisplayUnit","getStatisticLabel","getStatisticMetadata","statisticsHaveType","supportedStatTypeMap","mean","min","max","sum","change","StatisticsChart","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Array","Boolean","datasets","options","_this$_chart","_chart","resize","shouldUpdate","changedProps","size","has","willUpdate","hasUpdated","_createOptions","_generateData","firstUpdated","_computedStyle","getComputedStyle","render","hass","localize","isLoadingData","statisticsData","Object","keys","length","_chartData","_chartOptions","chartType","unit","parsing","animation","interaction","mode","axis","scales","x","adapters","date","locale","config","ticks","source","undefined","maxRotation","sampleSize","autoSkipPadding","major","enabled","font","context","tick","weight","time","tooltipFormat","period","includes","y","beginAtZero","maxTicksLimit","title","display","text","logarithmicScale","plugins","tooltip","callbacks","label","dataset","parsed","entities","_statisticIds","datasetIndex","filler","propagate","legend","hideLegend","labels","usePointStyle","elements","line","tension","cubicInterpolationMode","borderWidth","bar","borderRadius","point","hitRadius","statisticIds","statsMetadataArray","statisticsMetaData","forEach","statistic_id","metadata","_getStatisticsMetaData","colorIndex","entries","totalDataSets","endTime","Date","Math","map","_","stats","start","getTime","names","meta","name","prevValues","prevEndTime","statDataSets","pushData","end","dataValues","i","data","push","color","statTypes","hasMean","drawBands","sortedTypes","sort","a","b","band","fill","borderColor","backgroundColor","pointRadius","unit_of_measurement","prevDate","firstSum","stat","startDate","_val","val","prototype","apply","static","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/chart/statistics-chart.ts"],"sourcesContent":["import type {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ChartType,\n} from \"chart.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n  getNumberFormatOptions,\n} from \"../../common/number/format_number\";\nimport {\n  getDisplayUnit,\n  getStatisticLabel,\n  getStatisticMetadata,\n  Statistics,\n  statisticsHaveType,\n  StatisticsMetaData,\n  StatisticType,\n} from \"../../data/recorder\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"./ha-chart-base\";\nimport type { ChartResizeOptions, HaChartBase } from \"./ha-chart-base\";\n\nexport const supportedStatTypeMap: Record<StatisticType, StatisticType> = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"sum\",\n  change: \"sum\",\n};\n\n@customElement(\"statistics-chart\")\nexport class StatisticsChart extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public statisticsData?: Statistics;\n\n  @property({ attribute: false }) public metadata?: Record<\n    string,\n    StatisticsMetaData\n  >;\n\n  @property({ attribute: false }) public names?: Record<string, string>;\n\n  @property() public unit?: string;\n\n  @property({ attribute: false }) public endTime?: Date;\n\n  @property({ type: Array }) public statTypes: Array<StatisticType> = [\n    \"sum\",\n    \"min\",\n    \"mean\",\n    \"max\",\n  ];\n\n  @property() public chartType: ChartType = \"line\";\n\n  @property({ type: Boolean }) public hideLegend = false;\n\n  @property({ type: Boolean }) public logarithmicScale = false;\n\n  @property({ type: Boolean }) public isLoadingData = false;\n\n  @property() public period?: string;\n\n  @state() private _chartData: ChartData = { datasets: [] };\n\n  @state() private _statisticIds: string[] = [];\n\n  @state() private _chartOptions?: ChartOptions;\n\n  @query(\"ha-chart-base\") private _chart?: HaChartBase;\n\n  private _computedStyle?: CSSStyleDeclaration;\n\n  public resize = (options?: ChartResizeOptions): void => {\n    this._chart?.resize(options);\n  };\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return changedProps.size > 1 || !changedProps.has(\"hass\");\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (\n      !this.hasUpdated ||\n      changedProps.has(\"unit\") ||\n      changedProps.has(\"period\") ||\n      changedProps.has(\"chartType\") ||\n      changedProps.has(\"logarithmicScale\") ||\n      changedProps.has(\"hideLegend\")\n    ) {\n      this._createOptions();\n    }\n    if (\n      changedProps.has(\"statisticsData\") ||\n      changedProps.has(\"statTypes\") ||\n      changedProps.has(\"chartType\") ||\n      changedProps.has(\"hideLegend\")\n    ) {\n      this._generateData();\n    }\n  }\n\n  public firstUpdated() {\n    this._computedStyle = getComputedStyle(this);\n  }\n\n  protected render(): TemplateResult {\n    if (!isComponentLoaded(this.hass, \"history\")) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n    }\n\n    if (this.isLoadingData && !this.statisticsData) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.loading_statistics\"\n        )}\n      </div>`;\n    }\n\n    if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n      return html`<div class=\"info\">\n        ${this.hass.localize(\n          \"ui.components.statistics_charts.no_statistics_found\"\n        )}\n      </div>`;\n    }\n\n    return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n  }\n\n  private _createOptions(unit?: string) {\n    this._chartOptions = {\n      parsing: false,\n      animation: false,\n      interaction: {\n        mode: \"nearest\",\n        axis: \"x\",\n      },\n      scales: {\n        x: {\n          type: \"time\",\n          adapters: {\n            date: {\n              locale: this.hass.locale,\n              config: this.hass.config,\n            },\n          },\n          ticks: {\n            source: this.chartType === \"bar\" ? \"data\" : undefined,\n            maxRotation: 0,\n            sampleSize: 5,\n            autoSkipPadding: 20,\n            major: {\n              enabled: true,\n            },\n            font: (context) =>\n              context.tick && context.tick.major\n                ? ({ weight: \"bold\" } as any)\n                : {},\n          },\n          time: {\n            tooltipFormat: \"datetime\",\n            unit:\n              this.chartType === \"bar\" &&\n              this.period &&\n              [\"hour\", \"day\", \"week\", \"month\"].includes(this.period)\n                ? this.period\n                : undefined,\n          },\n        },\n        y: {\n          beginAtZero: this.chartType === \"bar\",\n          ticks: {\n            maxTicksLimit: 7,\n          },\n          title: {\n            display: unit || this.unit,\n            text: unit || this.unit,\n          },\n          type: this.logarithmicScale ? \"logarithmic\" : \"linear\",\n        },\n      },\n      plugins: {\n        tooltip: {\n          callbacks: {\n            label: (context) =>\n              `${context.dataset.label}: ${formatNumber(\n                context.parsed.y,\n                this.hass.locale,\n                getNumberFormatOptions(\n                  undefined,\n                  this.hass.entities[this._statisticIds[context.datasetIndex]]\n                )\n              )} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"\n              }`,\n          },\n        },\n        filler: {\n          propagate: true,\n        },\n        legend: {\n          display: !this.hideLegend,\n          labels: {\n            usePointStyle: true,\n          },\n        },\n      },\n      elements: {\n        line: {\n          tension: 0.4,\n          cubicInterpolationMode: \"monotone\",\n          borderWidth: 1.5,\n        },\n        bar: { borderWidth: 1.5, borderRadius: 4 },\n        point: {\n          hitRadius: 50,\n        },\n      },\n      // @ts-expect-error\n      locale: numberFormatToLocale(this.hass.locale),\n    };\n  }\n\n  private _getStatisticsMetaData = memoizeOne(\n    async (statisticIds: string[] | undefined) => {\n      const statsMetadataArray = await getStatisticMetadata(\n        this.hass,\n        statisticIds\n      );\n      const statisticsMetaData = {};\n      statsMetadataArray.forEach((x) => {\n        statisticsMetaData[x.statistic_id] = x;\n      });\n      return statisticsMetaData;\n    }\n  );\n\n  private async _generateData() {\n    if (!this.statisticsData) {\n      return;\n    }\n\n    const statisticsMetaData =\n      this.metadata ||\n      (await this._getStatisticsMetaData(Object.keys(this.statisticsData)));\n\n    let colorIndex = 0;\n    const statisticsData = Object.entries(this.statisticsData);\n    const totalDataSets: ChartDataset<\"line\">[] = [];\n    const statisticIds: string[] = [];\n    let endTime: Date;\n\n    if (statisticsData.length === 0) {\n      return;\n    }\n\n    endTime =\n      this.endTime ||\n      // Get the highest date from the last date of each statistic\n      new Date(\n        Math.max(\n          ...statisticsData.map(([_, stats]) =>\n            new Date(stats[stats.length - 1].start).getTime()\n          )\n        )\n      );\n\n    if (endTime > new Date()) {\n      endTime = new Date();\n    }\n\n    let unit: string | undefined | null;\n\n    const names = this.names || {};\n    statisticsData.forEach(([statistic_id, stats]) => {\n      const meta = statisticsMetaData?.[statistic_id];\n      let name = names[statistic_id];\n      if (name === undefined) {\n        name = getStatisticLabel(this.hass, statistic_id, meta);\n      }\n\n      if (!this.unit) {\n        if (unit === undefined) {\n          unit = getDisplayUnit(this.hass, statistic_id, meta);\n        } else if (\n          unit !== null &&\n          unit !== getDisplayUnit(this.hass, statistic_id, meta)\n        ) {\n          // Clear unit if not all statistics have same unit\n          unit = null;\n        }\n      }\n\n      // array containing [value1, value2, etc]\n      let prevValues: Array<number | null> | null = null;\n      let prevEndTime: Date | undefined;\n\n      // The datasets for the current statistic\n      const statDataSets: ChartDataset<\"line\">[] = [];\n\n      const pushData = (\n        start: Date,\n        end: Date,\n        dataValues: Array<number | null> | null\n      ) => {\n        if (!dataValues) return;\n        if (start > end) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        statDataSets.forEach((d, i) => {\n          if (\n            this.chartType === \"line\" &&\n            prevEndTime &&\n            prevValues &&\n            prevEndTime.getTime() !== start.getTime()\n          ) {\n            // if the end of the previous data doesn't match the start of the current data,\n            // we have to draw a gap so add a value at the end time, and then an empty value.\n            d.data.push({ x: prevEndTime.getTime(), y: prevValues[i]! });\n            // @ts-expect-error\n            d.data.push({ x: prevEndTime.getTime(), y: null });\n          }\n          d.data.push({ x: start.getTime(), y: dataValues[i]! });\n        });\n        prevValues = dataValues;\n        prevEndTime = end;\n      };\n\n      const color = getGraphColorByIndex(\n        colorIndex,\n        this._computedStyle || getComputedStyle(this)\n      );\n      colorIndex++;\n\n      const statTypes: this[\"statTypes\"] = [];\n\n      const hasMean =\n        this.statTypes.includes(\"mean\") && statisticsHaveType(stats, \"mean\");\n      const drawBands =\n        hasMean ||\n        (this.statTypes.includes(\"min\") &&\n          statisticsHaveType(stats, \"min\") &&\n          this.statTypes.includes(\"max\") &&\n          statisticsHaveType(stats, \"max\"));\n\n      const sortedTypes = drawBands\n        ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          })\n        : this.statTypes;\n\n      sortedTypes.forEach((type) => {\n        if (statisticsHaveType(stats, type)) {\n          const band = drawBands && (type === \"min\" || type === \"max\");\n          statTypes.push(type);\n          statDataSets.push({\n            label: name\n              ? `${name} (${this.hass.localize(\n                  `ui.components.statistics_charts.statistic_types.${type}`\n                )})\n            `\n              : this.hass.localize(\n                  `ui.components.statistics_charts.statistic_types.${type}`\n                ),\n            fill: drawBands\n              ? type === \"min\" && hasMean\n                ? \"+1\"\n                : type === \"max\"\n                  ? \"-1\"\n                  : false\n              : false,\n            borderColor:\n              band && hasMean ? color + (this.hideLegend ? \"00\" : \"7F\") : color,\n            backgroundColor: band ? color + \"3F\" : color + \"7F\",\n            pointRadius: 0,\n            data: [],\n            // @ts-ignore\n            unit: meta?.unit_of_measurement,\n            band,\n          });\n          statisticIds.push(statistic_id);\n        }\n      });\n\n      let prevDate: Date | null = null;\n      // Process chart data.\n      let firstSum: number | null | undefined = null;\n      stats.forEach((stat) => {\n        const startDate = new Date(stat.start);\n        if (prevDate === startDate) {\n          return;\n        }\n        prevDate = startDate;\n        const dataValues: Array<number | null> = [];\n        statTypes.forEach((type) => {\n          let val: number | null | undefined;\n          if (type === \"sum\") {\n            if (firstSum === null || firstSum === undefined) {\n              val = 0;\n              firstSum = stat.sum;\n            } else {\n              val = (stat.sum || 0) - firstSum;\n            }\n          } else {\n            val = stat[type];\n          }\n          dataValues.push(val ?? null);\n        });\n        pushData(startDate, new Date(stat.end), dataValues);\n      });\n\n      // Concat two arrays\n      Array.prototype.push.apply(totalDataSets, statDataSets);\n    });\n\n    if (unit) {\n      this._createOptions(unit);\n    }\n\n    this._chartData = {\n      datasets: totalDataSets,\n    };\n    this._statisticIds = statisticIds;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"statistics-chart\": StatisticsChart;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}