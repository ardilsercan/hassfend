{"ast":null,"code":"import { parseQuery } from \"./util.js\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH, ERR_INVALID_AUTH_CALLBACK, ERR_INVALID_HTTPS_TO_HTTP } from \"./errors.js\";\nexport const genClientId = () => `${location.protocol}//${location.host}/`;\nexport const genExpires = expires_in => {\n  return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n  // Get current url but without # part.\n  const {\n    protocol,\n    host,\n    pathname,\n    search\n  } = location;\n  return `${protocol}//${host}${pathname}${search}`;\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n  let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n  if (clientId !== null) {\n    authorizeUrl += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n  if (state) {\n    authorizeUrl += `&state=${encodeURIComponent(state)}`;\n  }\n  return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n  // Add either ?auth_callback=1 or &auth_callback=1\n  redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n  document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nasync function tokenRequest(hassUrl, clientId, data) {\n  // Browsers don't allow fetching tokens from https -> http.\n  // Throw an error because it's a pain to debug this.\n  // Guard against not working in node.\n  const l = typeof location !== \"undefined\" && location;\n  if (l && l.protocol === \"https:\") {\n    // Ensure that the hassUrl is hosted on https.\n    const a = document.createElement(\"a\");\n    a.href = hassUrl;\n    if (a.protocol === \"http:\" && a.hostname !== \"localhost\") {\n      throw ERR_INVALID_HTTPS_TO_HTTP;\n    }\n  }\n  const formData = new FormData();\n  if (clientId !== null) {\n    formData.append(\"client_id\", clientId);\n  }\n  Object.keys(data).forEach(key => {\n    formData.append(key, data[key]);\n  });\n  const resp = await fetch(`${hassUrl}/auth/token`, {\n    method: \"POST\",\n    credentials: \"same-origin\",\n    body: formData\n  });\n  if (!resp.ok) {\n    throw resp.status === 400 /* auth invalid */ || resp.status === 403 /* user not active */ ? ERR_INVALID_AUTH : new Error(\"Unable to fetch tokens\");\n  }\n  const tokens = await resp.json();\n  tokens.hassUrl = hassUrl;\n  tokens.clientId = clientId;\n  tokens.expires = genExpires(tokens.expires_in);\n  return tokens;\n}\nfunction fetchToken(hassUrl, clientId, code) {\n  return tokenRequest(hassUrl, clientId, {\n    code,\n    grant_type: \"authorization_code\"\n  });\n}\nfunction encodeOAuthState(state) {\n  return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n  return JSON.parse(atob(encoded));\n}\nexport class Auth {\n  constructor(data, saveTokens) {\n    this.data = data;\n    this._saveTokens = saveTokens;\n  }\n  get wsUrl() {\n    // Convert from http:// -> ws://, https:// -> wss://\n    return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n  }\n  get accessToken() {\n    return this.data.access_token;\n  }\n  get expired() {\n    return Date.now() > this.data.expires;\n  }\n  /**\n   * Refresh the access token.\n   */\n  async refreshAccessToken() {\n    if (!this.data.refresh_token) throw new Error(\"No refresh_token\");\n    const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n      grant_type: \"refresh_token\",\n      refresh_token: this.data.refresh_token\n    });\n    // Access token response does not contain refresh token.\n    data.refresh_token = this.data.refresh_token;\n    this.data = data;\n    if (this._saveTokens) this._saveTokens(data);\n  }\n  /**\n   * Revoke the refresh & access tokens.\n   */\n  async revoke() {\n    if (!this.data.refresh_token) throw new Error(\"No refresh_token to revoke\");\n    const formData = new FormData();\n    formData.append(\"token\", this.data.refresh_token);\n    // There is no error checking, as revoke will always return 200\n    await fetch(`${this.data.hassUrl}/auth/revoke`, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      body: formData\n    });\n    if (this._saveTokens) {\n      this._saveTokens(null);\n    }\n  }\n}\nexport function createLongLivedTokenAuth(hassUrl, access_token) {\n  return new Auth({\n    hassUrl,\n    clientId: null,\n    expires: Date.now() + 1e11,\n    refresh_token: \"\",\n    access_token,\n    expires_in: 1e11\n  });\n}\nexport async function getAuth(options = {}) {\n  let data;\n  let hassUrl = options.hassUrl;\n  // Strip trailing slash.\n  if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n    hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n  }\n  const clientId = options.clientId !== undefined ? options.clientId : genClientId();\n  const limitHassInstance = options.limitHassInstance === true;\n  // Use auth code if it was passed in\n  if (options.authCode && hassUrl) {\n    data = await fetchToken(hassUrl, clientId, options.authCode);\n    if (options.saveTokens) {\n      options.saveTokens(data);\n    }\n  }\n  // Check if we came back from an authorize redirect\n  if (!data) {\n    const query = parseQuery(location.search.substr(1));\n    // Check if we got redirected here from authorize page\n    if (\"auth_callback\" in query) {\n      // Restore state\n      const state = decodeOAuthState(query.state);\n      if (limitHassInstance && (state.hassUrl !== hassUrl || state.clientId !== clientId)) {\n        throw ERR_INVALID_AUTH_CALLBACK;\n      }\n      data = await fetchToken(state.hassUrl, state.clientId, query.code);\n      if (options.saveTokens) {\n        options.saveTokens(data);\n      }\n    }\n  }\n  // Check for stored tokens\n  if (!data && options.loadTokens) {\n    data = await options.loadTokens();\n  }\n  if (data) {\n    return new Auth(data, options.saveTokens);\n  }\n  if (hassUrl === undefined) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n  redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n    hassUrl,\n    clientId\n  }));\n  // Just don't resolve while we navigate to next page\n  return new Promise(() => {});\n}","map":{"version":3,"names":["parseQuery","ERR_HASS_HOST_REQUIRED","ERR_INVALID_AUTH","ERR_INVALID_AUTH_CALLBACK","ERR_INVALID_HTTPS_TO_HTTP","genClientId","location","protocol","host","genExpires","expires_in","Date","now","genRedirectUrl","pathname","search","genAuthorizeUrl","hassUrl","clientId","redirectUrl","state","authorizeUrl","encodeURIComponent","redirectAuthorize","includes","document","href","tokenRequest","data","l","a","createElement","hostname","formData","FormData","append","Object","keys","forEach","key","resp","fetch","method","credentials","body","ok","status","Error","tokens","json","expires","fetchToken","code","grant_type","encodeOAuthState","btoa","JSON","stringify","decodeOAuthState","encoded","parse","atob","Auth","constructor","saveTokens","_saveTokens","wsUrl","substr","accessToken","access_token","expired","refreshAccessToken","refresh_token","revoke","createLongLivedTokenAuth","getAuth","options","length","undefined","limitHassInstance","authCode","query","loadTokens","Promise"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/home-assistant-js-websocket/dist/auth.js"],"sourcesContent":["import { parseQuery } from \"./util.js\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH, ERR_INVALID_AUTH_CALLBACK, ERR_INVALID_HTTPS_TO_HTTP, } from \"./errors.js\";\nexport const genClientId = () => `${location.protocol}//${location.host}/`;\nexport const genExpires = (expires_in) => {\n    return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n    // Get current url but without # part.\n    const { protocol, host, pathname, search } = location;\n    return `${protocol}//${host}${pathname}${search}`;\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n    let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n    if (clientId !== null) {\n        authorizeUrl += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n    if (state) {\n        authorizeUrl += `&state=${encodeURIComponent(state)}`;\n    }\n    return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n    // Add either ?auth_callback=1 or &auth_callback=1\n    redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n    document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nasync function tokenRequest(hassUrl, clientId, data) {\n    // Browsers don't allow fetching tokens from https -> http.\n    // Throw an error because it's a pain to debug this.\n    // Guard against not working in node.\n    const l = typeof location !== \"undefined\" && location;\n    if (l && l.protocol === \"https:\") {\n        // Ensure that the hassUrl is hosted on https.\n        const a = document.createElement(\"a\");\n        a.href = hassUrl;\n        if (a.protocol === \"http:\" && a.hostname !== \"localhost\") {\n            throw ERR_INVALID_HTTPS_TO_HTTP;\n        }\n    }\n    const formData = new FormData();\n    if (clientId !== null) {\n        formData.append(\"client_id\", clientId);\n    }\n    Object.keys(data).forEach((key) => {\n        formData.append(key, data[key]);\n    });\n    const resp = await fetch(`${hassUrl}/auth/token`, {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        body: formData,\n    });\n    if (!resp.ok) {\n        throw resp.status === 400 /* auth invalid */ ||\n            resp.status === 403 /* user not active */\n            ? ERR_INVALID_AUTH\n            : new Error(\"Unable to fetch tokens\");\n    }\n    const tokens = await resp.json();\n    tokens.hassUrl = hassUrl;\n    tokens.clientId = clientId;\n    tokens.expires = genExpires(tokens.expires_in);\n    return tokens;\n}\nfunction fetchToken(hassUrl, clientId, code) {\n    return tokenRequest(hassUrl, clientId, {\n        code,\n        grant_type: \"authorization_code\",\n    });\n}\nfunction encodeOAuthState(state) {\n    return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n    return JSON.parse(atob(encoded));\n}\nexport class Auth {\n    constructor(data, saveTokens) {\n        this.data = data;\n        this._saveTokens = saveTokens;\n    }\n    get wsUrl() {\n        // Convert from http:// -> ws://, https:// -> wss://\n        return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n    }\n    get accessToken() {\n        return this.data.access_token;\n    }\n    get expired() {\n        return Date.now() > this.data.expires;\n    }\n    /**\n     * Refresh the access token.\n     */\n    async refreshAccessToken() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token\");\n        const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n            grant_type: \"refresh_token\",\n            refresh_token: this.data.refresh_token,\n        });\n        // Access token response does not contain refresh token.\n        data.refresh_token = this.data.refresh_token;\n        this.data = data;\n        if (this._saveTokens)\n            this._saveTokens(data);\n    }\n    /**\n     * Revoke the refresh & access tokens.\n     */\n    async revoke() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token to revoke\");\n        const formData = new FormData();\n        formData.append(\"token\", this.data.refresh_token);\n        // There is no error checking, as revoke will always return 200\n        await fetch(`${this.data.hassUrl}/auth/revoke`, {\n            method: \"POST\",\n            credentials: \"same-origin\",\n            body: formData,\n        });\n        if (this._saveTokens) {\n            this._saveTokens(null);\n        }\n    }\n}\nexport function createLongLivedTokenAuth(hassUrl, access_token) {\n    return new Auth({\n        hassUrl,\n        clientId: null,\n        expires: Date.now() + 1e11,\n        refresh_token: \"\",\n        access_token,\n        expires_in: 1e11,\n    });\n}\nexport async function getAuth(options = {}) {\n    let data;\n    let hassUrl = options.hassUrl;\n    // Strip trailing slash.\n    if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n        hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n    }\n    const clientId = options.clientId !== undefined ? options.clientId : genClientId();\n    const limitHassInstance = options.limitHassInstance === true;\n    // Use auth code if it was passed in\n    if (options.authCode && hassUrl) {\n        data = await fetchToken(hassUrl, clientId, options.authCode);\n        if (options.saveTokens) {\n            options.saveTokens(data);\n        }\n    }\n    // Check if we came back from an authorize redirect\n    if (!data) {\n        const query = parseQuery(location.search.substr(1));\n        // Check if we got redirected here from authorize page\n        if (\"auth_callback\" in query) {\n            // Restore state\n            const state = decodeOAuthState(query.state);\n            if (limitHassInstance &&\n                (state.hassUrl !== hassUrl || state.clientId !== clientId)) {\n                throw ERR_INVALID_AUTH_CALLBACK;\n            }\n            data = await fetchToken(state.hassUrl, state.clientId, query.code);\n            if (options.saveTokens) {\n                options.saveTokens(data);\n            }\n        }\n    }\n    // Check for stored tokens\n    if (!data && options.loadTokens) {\n        data = await options.loadTokens();\n    }\n    if (data) {\n        return new Auth(data, options.saveTokens);\n    }\n    if (hassUrl === undefined) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n    redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n        hassUrl,\n        clientId,\n    }));\n    // Just don't resolve while we navigate to next page\n    return new Promise(() => { });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}