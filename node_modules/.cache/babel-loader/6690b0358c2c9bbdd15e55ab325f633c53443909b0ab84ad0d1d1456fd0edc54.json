{"ast":null,"code":"/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport './boot.js';\nimport { wrap } from './wrap.js';\nconst ShadyDOM = window.ShadyDOM;\nconst ShadyCSS = window.ShadyCSS;\n\n/**\n * Return true if node scope is correct.\n *\n * @param {!Element} node Node to check scope\n * @param {!Node} scope Scope reference\n * @return {boolean} True if node is in scope\n */\nfunction sameScope(node, scope) {\n  return wrap(node).getRootNode() === scope;\n}\n\n/**\n * Ensure that elements in a ShadowDOM container are scoped correctly.\n * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.\n * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.\n *\n * @param  {!Element} container Container element to scope\n * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n */\nexport function scopeSubtree(container, shouldObserve = false) {\n  // If using native ShadowDOM, abort\n  if (!ShadyDOM || !ShadyCSS) {\n    return null;\n  }\n  // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself\n  if (!ShadyDOM['handlesDynamicScoping']) {\n    return null;\n  }\n  const ScopingShim = ShadyCSS['ScopingShim'];\n  // if ScopingShim is not available, abort\n  if (!ScopingShim) {\n    return null;\n  }\n  // capture correct scope for container\n  const containerScope = ScopingShim['scopeForNode'](container);\n  const root = wrap(container).getRootNode();\n  const scopify = node => {\n    if (!sameScope(node, root)) {\n      return;\n    }\n    // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1\n    const elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));\n    elements.push(node);\n    for (let i = 0; i < elements.length; i++) {\n      const el = elements[i];\n      if (!sameScope(el, root)) {\n        continue;\n      }\n      const currentScope = ScopingShim['currentScopeForNode'](el);\n      if (currentScope !== containerScope) {\n        if (currentScope !== '') {\n          ScopingShim['unscopeNode'](el, currentScope);\n        }\n        ScopingShim['scopeNode'](el, containerScope);\n      }\n    }\n  };\n\n  // scope everything in container\n  scopify(container);\n  if (shouldObserve) {\n    const mo = new MutationObserver(mxns => {\n      for (let i = 0; i < mxns.length; i++) {\n        const mxn = mxns[i];\n        for (let j = 0; j < mxn.addedNodes.length; j++) {\n          const addedNode = mxn.addedNodes[j];\n          if (addedNode.nodeType === Node.ELEMENT_NODE) {\n            scopify(addedNode);\n          }\n        }\n      }\n    });\n    mo.observe(container, {\n      childList: true,\n      subtree: true\n    });\n    return mo;\n  } else {\n    return null;\n  }\n}","map":{"version":3,"names":["wrap","ShadyDOM","window","ShadyCSS","sameScope","node","scope","getRootNode","scopeSubtree","container","shouldObserve","ScopingShim","containerScope","root","scopify","elements","Array","from","call","push","i","length","el","currentScope","mo","MutationObserver","mxns","mxn","j","addedNodes","addedNode","nodeType","Node","ELEMENT_NODE","observe","childList","subtree"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/utils/scope-subtree.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport './boot.js';\nimport {wrap} from './wrap.js';\n\nconst ShadyDOM = window.ShadyDOM;\nconst ShadyCSS = window.ShadyCSS;\n\n/**\n * Return true if node scope is correct.\n *\n * @param {!Element} node Node to check scope\n * @param {!Node} scope Scope reference\n * @return {boolean} True if node is in scope\n */\nfunction sameScope(node, scope) {\n  return wrap(node).getRootNode() === scope;\n}\n\n/**\n * Ensure that elements in a ShadowDOM container are scoped correctly.\n * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.\n * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.\n *\n * @param  {!Element} container Container element to scope\n * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n */\nexport function scopeSubtree(container, shouldObserve = false) {\n  // If using native ShadowDOM, abort\n  if (!ShadyDOM || !ShadyCSS) {\n    return null;\n  }\n  // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself\n  if (!ShadyDOM['handlesDynamicScoping']) {\n    return null;\n  }\n  const ScopingShim = ShadyCSS['ScopingShim'];\n  // if ScopingShim is not available, abort\n  if (!ScopingShim) {\n    return null;\n  }\n  // capture correct scope for container\n  const containerScope = ScopingShim['scopeForNode'](container);\n  const root = wrap(container).getRootNode();\n\n  const scopify = (node) => {\n    if (!sameScope(node, root)) {\n      return;\n    }\n    // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1\n    const elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));\n    elements.push(node);\n    for (let i = 0; i < elements.length; i++) {\n      const el = elements[i];\n      if (!sameScope(el, root)) {\n        continue;\n      }\n      const currentScope = ScopingShim['currentScopeForNode'](el);\n      if (currentScope !== containerScope) {\n        if (currentScope !== '') {\n          ScopingShim['unscopeNode'](el, currentScope);\n        }\n        ScopingShim['scopeNode'](el, containerScope);\n      }\n    }\n  };\n\n  // scope everything in container\n  scopify(container);\n\n  if (shouldObserve) {\n    const mo = new MutationObserver((mxns) => {\n      for (let i = 0; i < mxns.length; i++) {\n        const mxn = mxns[i];\n        for (let j = 0; j < mxn.addedNodes.length; j++) {\n          const addedNode = mxn.addedNodes[j];\n          if (addedNode.nodeType === Node.ELEMENT_NODE) {\n            scopify(addedNode);\n          }\n        }\n      }\n    });\n    mo.observe(container, {childList: true, subtree: true});\n    return mo;\n  } else {\n    return null;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}