{"ast":null,"code":"/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Indexline Technology object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCachePromiseFunc = async (cacheKey, cacheTime, func, generateCacheKey, hass, ...args) => {\n  const anyHass = hass;\n  const lastResult = anyHass[cacheKey];\n  const checkCachedResult = result => {\n    if (!generateCacheKey || generateCacheKey(hass, result.result) === result.cacheKey) {\n      return result.result;\n    }\n    anyHass[cacheKey] = undefined;\n    return timeCachePromiseFunc(cacheKey, cacheTime, func, generateCacheKey, hass, ...args);\n  };\n\n  // If we have a cached result, return it if it's still valid\n  if (lastResult) {\n    return lastResult instanceof Promise ? lastResult.then(checkCachedResult) : checkCachedResult(lastResult);\n  }\n  const resultPromise = func(hass, ...args);\n  anyHass[cacheKey] = resultPromise;\n  resultPromise.then(\n  // When successful, set timer to clear cache\n  result => {\n    anyHass[cacheKey] = {\n      result,\n      cacheKey: generateCacheKey === null || generateCacheKey === void 0 ? void 0 : generateCacheKey(hass, result)\n    };\n    setTimeout(() => {\n      anyHass[cacheKey] = undefined;\n    }, cacheTime);\n  },\n  // On failure, clear cache right away\n  () => {\n    anyHass[cacheKey] = undefined;\n  });\n  return resultPromise;\n};","map":{"version":3,"names":["timeCachePromiseFunc","cacheKey","cacheTime","func","generateCacheKey","hass","args","anyHass","lastResult","checkCachedResult","result","undefined","Promise","then","resultPromise","setTimeout"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/util/time-cache-function-promise.ts"],"sourcesContent":["import { HomeAssistant } from \"../../types\";\n\ninterface CacheResult<T> {\n  result: T;\n  cacheKey: any;\n}\n\n/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Indexline Technology object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCachePromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (hass: HomeAssistant, ...args: any[]) => Promise<T>,\n  generateCacheKey:\n    | ((hass: HomeAssistant, lastResult: T) => unknown)\n    | undefined,\n  hass: HomeAssistant,\n  ...args: any[]\n): Promise<T> => {\n  const anyHass = hass as any;\n  const lastResult: Promise<CacheResult<T>> | CacheResult<T> | undefined =\n    anyHass[cacheKey];\n\n  const checkCachedResult = (result: CacheResult<T>): T | Promise<T> => {\n    if (\n      !generateCacheKey ||\n      generateCacheKey(hass, result.result) === result.cacheKey\n    ) {\n      return result.result;\n    }\n\n    anyHass[cacheKey] = undefined;\n    return timeCachePromiseFunc(\n      cacheKey,\n      cacheTime,\n      func,\n      generateCacheKey,\n      hass,\n      ...args\n    );\n  };\n\n  // If we have a cached result, return it if it's still valid\n  if (lastResult) {\n    return lastResult instanceof Promise\n      ? lastResult.then(checkCachedResult)\n      : checkCachedResult(lastResult);\n  }\n\n  const resultPromise = func(hass, ...args);\n  anyHass[cacheKey] = resultPromise;\n\n  resultPromise.then(\n    // When successful, set timer to clear cache\n    (result) => {\n      anyHass[cacheKey] = {\n        result,\n        cacheKey: generateCacheKey?.(hass, result),\n      };\n      setTimeout(() => {\n        anyHass[cacheKey] = undefined;\n      }, cacheTime);\n    },\n    // On failure, clear cache right away\n    () => {\n      anyHass[cacheKey] = undefined;\n    }\n  );\n\n  return resultPromise;\n};\n"],"mappings":"AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,oBAAoB,GAAG,MAAAA,CAClCC,QAAgB,EAChBC,SAAiB,EACjBC,IAAyD,EACzDC,gBAEa,EACbC,IAAmB,EACnB,GAAGC,IAAW,KACC;EACf,MAAMC,OAAO,GAAGF,IAAW;EAC3B,MAAMG,UAAgE,GACpED,OAAO,CAACN,QAAQ,CAAC;EAEnB,MAAMQ,iBAAiB,GAAIC,MAAsB,IAAqB;IACpE,IACE,CAACN,gBAAgB,IACjBA,gBAAgB,CAACC,IAAI,EAAEK,MAAM,CAACA,MAAM,CAAC,KAAKA,MAAM,CAACT,QAAQ,EACzD;MACA,OAAOS,MAAM,CAACA,MAAM;IACtB;IAEAH,OAAO,CAACN,QAAQ,CAAC,GAAGU,SAAS;IAC7B,OAAOX,oBAAoB,CACzBC,QAAQ,EACRC,SAAS,EACTC,IAAI,EACJC,gBAAgB,EAChBC,IAAI,EACJ,GAAGC,IACL,CAAC;EACH,CAAC;;EAED;EACA,IAAIE,UAAU,EAAE;IACd,OAAOA,UAAU,YAAYI,OAAO,GAChCJ,UAAU,CAACK,IAAI,CAACJ,iBAAiB,CAAC,GAClCA,iBAAiB,CAACD,UAAU,CAAC;EACnC;EAEA,MAAMM,aAAa,GAAGX,IAAI,CAACE,IAAI,EAAE,GAAGC,IAAI,CAAC;EACzCC,OAAO,CAACN,QAAQ,CAAC,GAAGa,aAAa;EAEjCA,aAAa,CAACD,IAAI;EAChB;EACCH,MAAM,IAAK;IACVH,OAAO,CAACN,QAAQ,CAAC,GAAG;MAClBS,MAAM;MACNT,QAAQ,EAAEG,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAGC,IAAI,EAAEK,MAAM;IAC3C,CAAC;IACDK,UAAU,CAAC,MAAM;MACfR,OAAO,CAACN,QAAQ,CAAC,GAAGU,SAAS;IAC/B,CAAC,EAAET,SAAS,CAAC;EACf,CAAC;EACD;EACA,MAAM;IACJK,OAAO,CAACN,QAAQ,CAAC,GAAGU,SAAS;EAC/B,CACF,CAAC;EAED,OAAOG,aAAa;AACtB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}