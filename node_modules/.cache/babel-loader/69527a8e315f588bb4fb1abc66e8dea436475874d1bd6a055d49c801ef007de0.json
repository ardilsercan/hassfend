{"ast":null,"code":"/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n// IE11 has a bug where an element with (1) `overflow: auto;`, (2) size based on\n// its content's natural size, (3) absolute positioning (either `absolute` or\n// `fixed`), and (4) use `max-width` to constrain its width will place its\n// vertical scrollbar outside the area constrained by `max-width`.\n//\n// Unlike other browsers, IE11 doesn't support changing the size of scrollbars\n// with CSS, so we don't need to read this value live from the element in\n// question when trying to work around the bug.\nlet verticalScrollbarMaxWidthBugOffset = undefined;\nconst getVerticalScrollbarMaxWidthBugOffset = () => {\n  if (verticalScrollbarMaxWidthBugOffset !== undefined) {\n    return verticalScrollbarMaxWidthBugOffset;\n  }\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    overflow: 'auto',\n    position: 'fixed',\n    left: '0px',\n    top: '0px',\n    maxWidth: '100px',\n    maxHeight: '100px'\n  });\n  const content = document.createElement('div');\n  content.style.width = '200px';\n  content.style.height = '200px';\n  container.appendChild(content);\n  document.body.appendChild(container);\n  verticalScrollbarMaxWidthBugOffset = Math.abs(container.offsetWidth - 100) > 1 ? container.offsetWidth - container.clientWidth : 0;\n  document.body.removeChild(container);\n  return verticalScrollbarMaxWidthBugOffset;\n};\n\n/**\n`Polymer.IronFitBehavior` fits an element in another element using `max-height`\nand `max-width`, and optionally centers it in the window or another element.\n\nThe element will only be sized and/or positioned if it has not already been\nsized and/or positioned by CSS.\n\nCSS properties            | Action\n--------------------------|-------------------------------------------\n`position` set            | Element is not centered horizontally or vertically\n`top` or `bottom` set     | Element is not vertically centered\n`left` or `right` set     | Element is not horizontally centered\n`max-height` set          | Element respects `max-height`\n`max-width` set           | Element respects `max-width`\n\n`Polymer.IronFitBehavior` can position an element into another element using\n`verticalAlign` and `horizontalAlign`. This will override the element's css\nposition.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" horizontal-align=\"auto\">\n        Positioned into the container\n      </iron-fit-impl>\n    </div>\n\nUse `noOverlap` to position the element around another element without\noverlapping it.\n\n    <div class=\"container\">\n      <iron-fit-impl no-overlap vertical-align=\"auto\" horizontal-align=\"auto\">\n        Positioned around the container\n      </iron-fit-impl>\n    </div>\n\nUse `horizontalOffset, verticalOffset` to offset the element from its\n`positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to\nkeep the element within `fitInto` boundaries, while preserving the element's\nCSS margin values.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" vertical-offset=\"20\">\n        With vertical offset\n      </iron-fit-impl>\n    </div>\n\n@demo demo/index.html\n@polymerBehavior\n*/\nexport const IronFitBehavior = {\n  properties: {\n    /**\n     * The element that will receive a `max-height`/`width`. By default it is\n     * the same as `this`, but it can be set to a child element. This is useful,\n     * for example, for implementing a scrolling region inside the element.\n     * @type {!Element}\n     */\n    sizingTarget: {\n      type: Object,\n      value: function () {\n        return this;\n      }\n    },\n    /**\n     * The element to fit `this` into.\n     */\n    fitInto: {\n      type: Object,\n      value: window\n    },\n    /**\n     * Will position the element around the positionTarget without overlapping\n     * it.\n     */\n    noOverlap: {\n      type: Boolean\n    },\n    /**\n     * The element that should be used to position the element. If not set, it\n     * will default to the parent node.\n     * @type {!Element}\n     */\n    positionTarget: {\n      type: Element\n    },\n    /**\n     * The orientation against which to align the element horizontally\n     * relative to the `positionTarget`. Possible values are \"left\", \"right\",\n     * \"center\", \"auto\".\n     */\n    horizontalAlign: {\n      type: String\n    },\n    /**\n     * The orientation against which to align the element vertically\n     * relative to the `positionTarget`. Possible values are \"top\", \"bottom\",\n     * \"middle\", \"auto\".\n     */\n    verticalAlign: {\n      type: String\n    },\n    /**\n     * If true, it will use `horizontalAlign` and `verticalAlign` values as\n     * preferred alignment and if there's not enough space, it will pick the\n     * values which minimize the cropping.\n     */\n    dynamicAlign: {\n      type: Boolean\n    },\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `horizontalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `horizontalAlign`.\n     *\n     * If `horizontalAlign` is \"left\" or \"center\", this offset will increase or\n     * decrease the distance to the left side of the screen: a negative offset\n     * will move the dropdown to the left; a positive one, to the right.\n     *\n     * Conversely if `horizontalAlign` is \"right\", this offset will increase\n     * or decrease the distance to the right side of the screen: a negative\n     * offset will move the dropdown to the right; a positive one, to the left.\n     */\n    horizontalOffset: {\n      type: Number,\n      value: 0,\n      notify: true\n    },\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `verticalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `verticalAlign`.\n     *\n     * If `verticalAlign` is \"top\" or \"middle\", this offset will increase or\n     * decrease the distance to the top side of the screen: a negative offset\n     * will move the dropdown upwards; a positive one, downwards.\n     *\n     * Conversely if `verticalAlign` is \"bottom\", this offset will increase\n     * or decrease the distance to the bottom side of the screen: a negative\n     * offset will move the dropdown downwards; a positive one, upwards.\n     */\n    verticalOffset: {\n      type: Number,\n      value: 0,\n      notify: true\n    },\n    /**\n     * Set to true to auto-fit on attach.\n     */\n    autoFitOnAttach: {\n      type: Boolean,\n      value: false\n    },\n    /**\n     * If true and scrollbars are added to `sizingTarget` after it is\n     * positioned, the size of the added scrollbars will be added to its\n     * `maxWidth` and `maxHeight`.\n     */\n    expandSizingTargetForScrollbars: {\n      type: Boolean,\n      value: false\n    },\n    /** @type {?Object} */\n    _fitInfo: {\n      type: Object\n    }\n  },\n  get _fitWidth() {\n    var fitWidth;\n    if (this.fitInto === window) {\n      fitWidth = this.fitInto.innerWidth;\n    } else {\n      fitWidth = this.fitInto.getBoundingClientRect().width;\n    }\n    return fitWidth;\n  },\n  get _fitHeight() {\n    var fitHeight;\n    if (this.fitInto === window) {\n      fitHeight = this.fitInto.innerHeight;\n    } else {\n      fitHeight = this.fitInto.getBoundingClientRect().height;\n    }\n    return fitHeight;\n  },\n  get _fitLeft() {\n    var fitLeft;\n    if (this.fitInto === window) {\n      fitLeft = 0;\n    } else {\n      fitLeft = this.fitInto.getBoundingClientRect().left;\n    }\n    return fitLeft;\n  },\n  get _fitTop() {\n    var fitTop;\n    if (this.fitInto === window) {\n      fitTop = 0;\n    } else {\n      fitTop = this.fitInto.getBoundingClientRect().top;\n    }\n    return fitTop;\n  },\n  /**\n   * The element that should be used to position the element,\n   * if no position target is configured.\n   */\n  get _defaultPositionTarget() {\n    var parent = dom(this).parentNode;\n    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      parent = parent.host;\n    }\n    return parent;\n  },\n  /**\n   * The horizontal align value, accounting for the RTL/LTR text direction.\n   */\n  get _localeHorizontalAlign() {\n    if (this._isRTL) {\n      // In RTL, \"left\" becomes \"right\".\n      if (this.horizontalAlign === 'right') {\n        return 'left';\n      }\n      if (this.horizontalAlign === 'left') {\n        return 'right';\n      }\n    }\n    return this.horizontalAlign;\n  },\n  /**\n   * True if the element should be positioned instead of centered.\n   * @private\n   */\n  get __shouldPosition() {\n    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;\n  },\n  /**\n   * True if the component is RTL.\n   * @private\n   */\n  get _isRTL() {\n    // Memoize this to avoid expensive calculations & relayouts.\n    // Make sure we do it only once\n    if (typeof this._memoizedIsRTL === 'undefined') {\n      this._memoizedIsRTL = window.getComputedStyle(this).direction == 'rtl';\n    }\n    return this._memoizedIsRTL;\n  },\n  /** @override */\n  attached: function () {\n    this.positionTarget = this.positionTarget || this._defaultPositionTarget;\n    if (this.autoFitOnAttach) {\n      if (window.getComputedStyle(this).display === 'none') {\n        setTimeout(function () {\n          this.fit();\n        }.bind(this));\n      } else {\n        // NOTE: shadydom applies distribution asynchronously\n        // for performance reasons webcomponents/shadydom#120\n        // Flush to get correct layout info.\n        window.ShadyDOM && ShadyDOM.flush();\n        this.fit();\n      }\n    }\n  },\n  /** @override */\n  detached: function () {\n    if (this.__deferredFit) {\n      clearTimeout(this.__deferredFit);\n      this.__deferredFit = null;\n    }\n  },\n  /**\n   * Positions and fits the element into the `fitInto` element.\n   */\n  fit: function () {\n    this.position();\n    this.constrain();\n    this.center();\n  },\n  /**\n   * Memoize information needed to position and size the target element.\n   * @suppress {deprecated}\n   */\n  _discoverInfo: function () {\n    if (this._fitInfo) {\n      return;\n    }\n    var target = window.getComputedStyle(this);\n    var sizer = window.getComputedStyle(this.sizingTarget);\n    this._fitInfo = {\n      inlineStyle: {\n        top: this.style.top || '',\n        left: this.style.left || '',\n        position: this.style.position || ''\n      },\n      sizerInlineStyle: {\n        maxWidth: this.sizingTarget.style.maxWidth || '',\n        maxHeight: this.sizingTarget.style.maxHeight || '',\n        boxSizing: this.sizingTarget.style.boxSizing || ''\n      },\n      positionedBy: {\n        vertically: target.top !== 'auto' ? 'top' : target.bottom !== 'auto' ? 'bottom' : null,\n        horizontally: target.left !== 'auto' ? 'left' : target.right !== 'auto' ? 'right' : null\n      },\n      sizedBy: {\n        height: sizer.maxHeight !== 'none',\n        width: sizer.maxWidth !== 'none',\n        minWidth: parseInt(sizer.minWidth, 10) || 0,\n        minHeight: parseInt(sizer.minHeight, 10) || 0\n      },\n      margin: {\n        top: parseInt(target.marginTop, 10) || 0,\n        right: parseInt(target.marginRight, 10) || 0,\n        bottom: parseInt(target.marginBottom, 10) || 0,\n        left: parseInt(target.marginLeft, 10) || 0\n      }\n    };\n  },\n  /**\n   * Resets the target element's position and size constraints, and clear\n   * the memoized data.\n   */\n  resetFit: function () {\n    var info = this._fitInfo || {};\n    for (var property in info.sizerInlineStyle) {\n      this.sizingTarget.style[property] = info.sizerInlineStyle[property];\n    }\n    for (var property in info.inlineStyle) {\n      this.style[property] = info.inlineStyle[property];\n    }\n    this._fitInfo = null;\n  },\n  /**\n   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after\n   * the element or the `fitInto` element has been resized, or if any of the\n   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.\n   * It preserves the scroll position of the sizingTarget.\n   */\n  refit: function () {\n    var scrollLeft = this.sizingTarget.scrollLeft;\n    var scrollTop = this.sizingTarget.scrollTop;\n    this.resetFit();\n    this.fit();\n    this.sizingTarget.scrollLeft = scrollLeft;\n    this.sizingTarget.scrollTop = scrollTop;\n  },\n  /**\n   * Positions the element according to `horizontalAlign, verticalAlign`.\n   */\n  position: function () {\n    if (!this.__shouldPosition) {\n      // needs to be centered, and it is done after constrain.\n      return;\n    }\n    this._discoverInfo();\n    window.ShadyDOM && window.ShadyDOM.flush();\n    this.style.position = 'fixed';\n    // Need border-box for margin/padding.\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // Set to 0, 0 in order to discover any offset caused by parent stacking\n    // contexts.\n    this.style.left = '0px';\n    this.style.top = '0px';\n    var rect = this.getBoundingClientRect();\n    var positionRect = this.__getNormalizedRect(this.positionTarget);\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    let unpositionedOffsetWidth;\n    let unpositionedOffsetHeight;\n    let unpositionedClientWidth;\n    let unpositionedClientHeight;\n    if (this.expandSizingTargetForScrollbars) {\n      unpositionedOffsetWidth = this.sizingTarget.offsetWidth;\n      unpositionedOffsetHeight = this.sizingTarget.offsetHeight;\n      unpositionedClientWidth = this.sizingTarget.clientWidth;\n      unpositionedClientHeight = this.sizingTarget.clientHeight;\n    }\n    var margin = this._fitInfo.margin;\n\n    // Consider the margin as part of the size for position calculations.\n    var size = {\n      width: rect.width + margin.left + margin.right,\n      height: rect.height + margin.top + margin.bottom\n    };\n    var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, rect, positionRect, fitRect);\n    var left = position.left + margin.left;\n    var top = position.top + margin.top;\n\n    // We first limit right/bottom within fitInto respecting the margin,\n    // then use those values to limit top/left.\n    var right = Math.min(fitRect.right - margin.right, left + rect.width);\n    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);\n\n    // Keep left/top within fitInto respecting the margin.\n    left = Math.max(fitRect.left + margin.left, Math.min(left, right - this._fitInfo.sizedBy.minWidth));\n    top = Math.max(fitRect.top + margin.top, Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));\n\n    // Use right/bottom to set maxWidth/maxHeight, and respect\n    // minWidth/minHeight.\n    const maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth);\n    const maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight);\n    this.sizingTarget.style.maxWidth = maxWidth + 'px';\n    this.sizingTarget.style.maxHeight = maxHeight + 'px';\n\n    // Remove the offset caused by any stacking context.\n    const leftPosition = left - rect.left;\n    const topPosition = top - rect.top;\n    this.style.left = `${leftPosition}px`;\n    this.style.top = `${topPosition}px`;\n    if (this.expandSizingTargetForScrollbars) {\n      // Expand the height first - i.e. in the typical block direction - in case\n      // this expands the element enough to remove the vertical scrollbar.\n\n      const positionedOffsetHeight = this.sizingTarget.offsetHeight;\n      const positionedClientHeight = this.sizingTarget.clientHeight;\n      const unpositionedHeightDelta = unpositionedOffsetHeight - unpositionedClientHeight;\n      const positionedHeightDelta = positionedOffsetHeight - positionedClientHeight;\n      const sizingTargetScrollbarHeight = positionedHeightDelta - unpositionedHeightDelta;\n      if (sizingTargetScrollbarHeight > 0) {\n        // Expand `maxHeight` by `sizingTargetScrollbarHeight` up to the overall\n        // allowed height within `fitRect`.\n        const fitRectMaxHeight = fitRect.height - margin.top - margin.bottom;\n        const newMaxHeight = Math.min(fitRectMaxHeight, maxHeight + sizingTargetScrollbarHeight);\n        this.sizingTarget.style.maxHeight = `${newMaxHeight}px`;\n\n        // Measure the element's real change in height. This may not equal\n        // `sizingTargetScrollbarHeight` if the overflow amount is less than the\n        // scrollbar size.\n        const offsetHeight = this.sizingTarget.offsetHeight;\n        const addedHeight = offsetHeight - positionedOffsetHeight;\n\n        // Adjust the top position if the alignment requires it.\n        let newTopPosition;\n        if (position.verticalAlign === 'top') {\n          newTopPosition = topPosition;\n        } else if (position.verticalAlign === 'middle') {\n          newTopPosition = topPosition - addedHeight / 2;\n        } else if (position.verticalAlign === 'bottom') {\n          newTopPosition = topPosition - addedHeight;\n        }\n\n        // Constrain the new top position based on `fitRect` again.\n        newTopPosition = Math.max(fitRect.top + margin.top, Math.min(newTopPosition, fitRect.bottom - margin.bottom - offsetHeight));\n        this.style.top = `${newTopPosition}px`;\n      }\n      const positionedOffsetWidth = this.sizingTarget.offsetWidth;\n      const positionedClientWidth = this.sizingTarget.clientWidth;\n      const unpositionedWidthDelta = unpositionedOffsetWidth - unpositionedClientWidth;\n      const positionedWidthDelta = positionedOffsetWidth - positionedClientWidth;\n      const sizingTargetScrollbarWidth = positionedWidthDelta - unpositionedWidthDelta;\n      if (sizingTargetScrollbarWidth > 0) {\n        const maxWidthBugOffset = getVerticalScrollbarMaxWidthBugOffset();\n\n        // Expand `maxWidth` by `sizingTargetScrollbarWidth` up to the overall\n        // allowed width within `fitRect`.\n        const fitRectMaxWidth = fitRect.width - margin.left - margin.right;\n        const newMaxWidth = Math.min(fitRectMaxWidth, maxWidth + sizingTargetScrollbarWidth - maxWidthBugOffset);\n        this.sizingTarget.style.maxWidth = `${newMaxWidth}px`;\n\n        // Measure the element's real change in width. This may not equal\n        // `sizingTargetScrollbarWidth` if the overflow amount is less than the\n        // scrollbar size.\n        const offsetWidth = this.sizingTarget.offsetWidth + maxWidthBugOffset;\n        const addedWidth = offsetWidth - positionedOffsetWidth;\n\n        // Adjust the left position if the alignment requires it.\n        let newLeftPosition;\n        if (position.horizontalAlign === 'left') {\n          newLeftPosition = leftPosition;\n        } else if (position.horizontalAlign === 'center') {\n          newLeftPosition = leftPosition - addedWidth / 2;\n        } else if (position.horizontalAlign === 'right') {\n          newLeftPosition = leftPosition - addedWidth;\n        }\n\n        // Constrain the new left position based on `fitRect` again.\n        newLeftPosition = Math.max(fitRect.left + margin.left, Math.min(newLeftPosition, fitRect.right - margin.right - offsetWidth));\n        this.style.left = `${newLeftPosition}px`;\n      }\n    }\n  },\n  /**\n   * Constrains the size of the element to `fitInto` by setting `max-height`\n   * and/or `max-width`.\n   */\n  constrain: function () {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n    var info = this._fitInfo;\n    // position at (0px, 0px) if not already positioned, so we can measure the\n    // natural size.\n    if (!info.positionedBy.vertically) {\n      this.style.position = 'fixed';\n      this.style.top = '0px';\n    }\n    if (!info.positionedBy.horizontally) {\n      this.style.position = 'fixed';\n      this.style.left = '0px';\n    }\n\n    // need border-box for margin/padding\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // constrain the width and height if not already set\n    var rect = this.getBoundingClientRect();\n    if (!info.sizedBy.height) {\n      this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');\n    }\n    if (!info.sizedBy.width) {\n      this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');\n    }\n  },\n  /**\n   * @protected\n   * @deprecated\n   */\n  _sizeDimension: function (rect, positionedBy, start, end, extent) {\n    this.__sizeDimension(rect, positionedBy, start, end, extent);\n  },\n  /**\n   * @private\n   */\n  __sizeDimension: function (rect, positionedBy, start, end, extent) {\n    var info = this._fitInfo;\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    var max = extent === 'Width' ? fitRect.width : fitRect.height;\n    var flip = positionedBy === end;\n    var offset = flip ? max - rect[end] : rect[start];\n    var margin = info.margin[flip ? start : end];\n    var offsetExtent = 'offset' + extent;\n    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];\n    this.sizingTarget.style['max' + extent] = max - margin - offset - sizingOffset + 'px';\n  },\n  /**\n   * Centers horizontally and vertically if not already positioned. This also\n   * sets `position:fixed`.\n   */\n  center: function () {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n    var positionedBy = this._fitInfo.positionedBy;\n    if (positionedBy.vertically && positionedBy.horizontally) {\n      // Already positioned.\n      return;\n    }\n    // Need position:fixed to center\n    this.style.position = 'fixed';\n    // Take into account the offset caused by parents that create stacking\n    // contexts (e.g. with transform: translate3d). Translate to 0,0 and\n    // measure the bounding rect.\n    if (!positionedBy.vertically) {\n      this.style.top = '0px';\n    }\n    if (!positionedBy.horizontally) {\n      this.style.left = '0px';\n    }\n    // It will take in consideration margins and transforms\n    var rect = this.getBoundingClientRect();\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    if (!positionedBy.vertically) {\n      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;\n      this.style.top = top + 'px';\n    }\n    if (!positionedBy.horizontally) {\n      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;\n      this.style.left = left + 'px';\n    }\n  },\n  __getNormalizedRect: function (target) {\n    if (target === document.documentElement || target === window) {\n      return {\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      };\n    }\n    return target.getBoundingClientRect();\n  },\n  __getOffscreenArea: function (position, size, fitRect) {\n    var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));\n    var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));\n    return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;\n  },\n  __getPosition: function (hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {\n    // All the possible configurations.\n    // Ordered as top-left, top-right, bottom-left, bottom-right.\n    var positions = [{\n      verticalAlign: 'top',\n      horizontalAlign: 'left',\n      top: positionRect.top + this.verticalOffset,\n      left: positionRect.left + this.horizontalOffset\n    }, {\n      verticalAlign: 'top',\n      horizontalAlign: 'right',\n      top: positionRect.top + this.verticalOffset,\n      left: positionRect.right - size.width - this.horizontalOffset\n    }, {\n      verticalAlign: 'bottom',\n      horizontalAlign: 'left',\n      top: positionRect.bottom - size.height - this.verticalOffset,\n      left: positionRect.left + this.horizontalOffset\n    }, {\n      verticalAlign: 'bottom',\n      horizontalAlign: 'right',\n      top: positionRect.bottom - size.height - this.verticalOffset,\n      left: positionRect.right - size.width - this.horizontalOffset\n    }];\n    if (this.noOverlap) {\n      // Duplicate.\n      for (var i = 0, l = positions.length; i < l; i++) {\n        var copy = {};\n        for (var key in positions[i]) {\n          copy[key] = positions[i][key];\n        }\n        positions.push(copy);\n      }\n      // Horizontal overlap only.\n      positions[0].top = positions[1].top += positionRect.height;\n      positions[2].top = positions[3].top -= positionRect.height;\n      // Vertical overlap only.\n      positions[4].left = positions[6].left += positionRect.width;\n      positions[5].left = positions[7].left -= positionRect.width;\n    }\n\n    // Consider auto as null for coding convenience.\n    vAlign = vAlign === 'auto' ? null : vAlign;\n    hAlign = hAlign === 'auto' ? null : hAlign;\n    if (!hAlign || hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'top',\n        horizontalAlign: 'center',\n        top: positionRect.top + this.verticalOffset + (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 + positionRect.width / 2 + this.horizontalOffset\n      });\n      positions.push({\n        verticalAlign: 'bottom',\n        horizontalAlign: 'center',\n        top: positionRect.bottom - size.height - this.verticalOffset - (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 + positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n    if (!vAlign || vAlign === 'middle') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'left',\n        top: positionRect.top - sizeNoMargins.height / 2 + positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset + (this.noOverlap ? positionRect.width : 0)\n      });\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'right',\n        top: positionRect.top - sizeNoMargins.height / 2 + positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset - (this.noOverlap ? positionRect.width : 0)\n      });\n    }\n    if (vAlign === 'middle' && hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'center',\n        top: positionRect.top - sizeNoMargins.height / 2 + positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left - sizeNoMargins.width / 2 + positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n    var position;\n    for (var i = 0; i < positions.length; i++) {\n      var candidate = positions[i];\n      var vAlignOk = candidate.verticalAlign === vAlign;\n      var hAlignOk = candidate.horizontalAlign === hAlign;\n\n      // If both vAlign and hAlign are defined, return exact match.\n      // For dynamicAlign and noOverlap we'll have more than one candidate, so\n      // we'll have to check the offscreenArea to make the best choice.\n      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {\n        position = candidate;\n        break;\n      }\n\n      // Align is ok if alignment preferences are respected. If no preferences,\n      // it is considered ok.\n      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);\n\n      // Filter out elements that don't match the alignment (if defined).\n      // With dynamicAlign, we need to consider all the positions to find the\n      // one that minimizes the cropped area.\n      if (!this.dynamicAlign && !alignOk) {\n        continue;\n      }\n      candidate.offscreenArea = this.__getOffscreenArea(candidate, size, fitRect);\n      // If not cropped and respects the align requirements, keep it.\n      // This allows to prefer positions overlapping horizontally over the\n      // ones overlapping vertically.\n      if (candidate.offscreenArea === 0 && alignOk) {\n        position = candidate;\n        break;\n      }\n      position = position || candidate;\n      var diff = candidate.offscreenArea - position.offscreenArea;\n      // Check which crops less. If it crops equally, check if at least one\n      // align setting is ok.\n      if (diff < 0 || diff === 0 && (vAlignOk || hAlignOk)) {\n        position = candidate;\n      }\n    }\n    return position;\n  }\n};","map":{"version":3,"names":["dom","verticalScrollbarMaxWidthBugOffset","undefined","getVerticalScrollbarMaxWidthBugOffset","container","document","createElement","Object","assign","style","overflow","position","left","top","maxWidth","maxHeight","content","width","height","appendChild","body","Math","abs","offsetWidth","clientWidth","removeChild","IronFitBehavior","properties","sizingTarget","type","value","fitInto","window","noOverlap","Boolean","positionTarget","Element","horizontalAlign","String","verticalAlign","dynamicAlign","horizontalOffset","Number","notify","verticalOffset","autoFitOnAttach","expandSizingTargetForScrollbars","_fitInfo","_fitWidth","fitWidth","innerWidth","getBoundingClientRect","_fitHeight","fitHeight","innerHeight","_fitLeft","fitLeft","_fitTop","fitTop","_defaultPositionTarget","parent","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","_localeHorizontalAlign","_isRTL","__shouldPosition","_memoizedIsRTL","getComputedStyle","direction","attached","display","setTimeout","fit","bind","ShadyDOM","flush","detached","__deferredFit","clearTimeout","constrain","center","_discoverInfo","target","sizer","inlineStyle","sizerInlineStyle","boxSizing","positionedBy","vertically","bottom","horizontally","right","sizedBy","minWidth","parseInt","minHeight","margin","marginTop","marginRight","marginBottom","marginLeft","resetFit","info","property","refit","scrollLeft","scrollTop","rect","positionRect","__getNormalizedRect","fitRect","unpositionedOffsetWidth","unpositionedOffsetHeight","unpositionedClientWidth","unpositionedClientHeight","offsetHeight","clientHeight","size","__getPosition","min","max","leftPosition","topPosition","positionedOffsetHeight","positionedClientHeight","unpositionedHeightDelta","positionedHeightDelta","sizingTargetScrollbarHeight","fitRectMaxHeight","newMaxHeight","addedHeight","newTopPosition","positionedOffsetWidth","positionedClientWidth","unpositionedWidthDelta","positionedWidthDelta","sizingTargetScrollbarWidth","maxWidthBugOffset","fitRectMaxWidth","newMaxWidth","addedWidth","newLeftPosition","__sizeDimension","_sizeDimension","start","end","extent","flip","offset","offsetExtent","sizingOffset","documentElement","__getOffscreenArea","verticalCrop","horizontalCrop","hAlign","vAlign","sizeNoMargins","positions","i","l","length","copy","key","push","candidate","vAlignOk","hAlignOk","alignOk","offscreenArea","diff"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/iron-fit-behavior/iron-fit-behavior.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\n// IE11 has a bug where an element with (1) `overflow: auto;`, (2) size based on\n// its content's natural size, (3) absolute positioning (either `absolute` or\n// `fixed`), and (4) use `max-width` to constrain its width will place its\n// vertical scrollbar outside the area constrained by `max-width`.\n//\n// Unlike other browsers, IE11 doesn't support changing the size of scrollbars\n// with CSS, so we don't need to read this value live from the element in\n// question when trying to work around the bug.\nlet verticalScrollbarMaxWidthBugOffset = undefined;\nconst getVerticalScrollbarMaxWidthBugOffset = () => {\n  if (verticalScrollbarMaxWidthBugOffset !== undefined) {\n    return verticalScrollbarMaxWidthBugOffset;\n  }\n\n  const container = document.createElement('div');\n  Object.assign(container.style, {\n    overflow: 'auto',\n    position: 'fixed',\n    left: '0px',\n    top: '0px',\n    maxWidth: '100px',\n    maxHeight: '100px',\n  });\n\n  const content = document.createElement('div');\n  content.style.width = '200px';\n  content.style.height = '200px';\n  container.appendChild(content);\n\n  document.body.appendChild(container);\n  verticalScrollbarMaxWidthBugOffset =\n      Math.abs(container.offsetWidth - 100) > 1 ?\n      container.offsetWidth - container.clientWidth :\n      0;\n  document.body.removeChild(container);\n\n  return verticalScrollbarMaxWidthBugOffset;\n};\n\n/**\n`Polymer.IronFitBehavior` fits an element in another element using `max-height`\nand `max-width`, and optionally centers it in the window or another element.\n\nThe element will only be sized and/or positioned if it has not already been\nsized and/or positioned by CSS.\n\nCSS properties            | Action\n--------------------------|-------------------------------------------\n`position` set            | Element is not centered horizontally or vertically\n`top` or `bottom` set     | Element is not vertically centered\n`left` or `right` set     | Element is not horizontally centered\n`max-height` set          | Element respects `max-height`\n`max-width` set           | Element respects `max-width`\n\n`Polymer.IronFitBehavior` can position an element into another element using\n`verticalAlign` and `horizontalAlign`. This will override the element's css\nposition.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" horizontal-align=\"auto\">\n        Positioned into the container\n      </iron-fit-impl>\n    </div>\n\nUse `noOverlap` to position the element around another element without\noverlapping it.\n\n    <div class=\"container\">\n      <iron-fit-impl no-overlap vertical-align=\"auto\" horizontal-align=\"auto\">\n        Positioned around the container\n      </iron-fit-impl>\n    </div>\n\nUse `horizontalOffset, verticalOffset` to offset the element from its\n`positionTarget`; `Polymer.IronFitBehavior` will collapse these in order to\nkeep the element within `fitInto` boundaries, while preserving the element's\nCSS margin values.\n\n    <div class=\"container\">\n      <iron-fit-impl vertical-align=\"top\" vertical-offset=\"20\">\n        With vertical offset\n      </iron-fit-impl>\n    </div>\n\n@demo demo/index.html\n@polymerBehavior\n*/\nexport const IronFitBehavior = {\n\n  properties: {\n\n    /**\n     * The element that will receive a `max-height`/`width`. By default it is\n     * the same as `this`, but it can be set to a child element. This is useful,\n     * for example, for implementing a scrolling region inside the element.\n     * @type {!Element}\n     */\n    sizingTarget: {\n      type: Object,\n      value: function() {\n        return this;\n      }\n    },\n\n    /**\n     * The element to fit `this` into.\n     */\n    fitInto: {type: Object, value: window},\n\n    /**\n     * Will position the element around the positionTarget without overlapping\n     * it.\n     */\n    noOverlap: {type: Boolean},\n\n    /**\n     * The element that should be used to position the element. If not set, it\n     * will default to the parent node.\n     * @type {!Element}\n     */\n    positionTarget: {type: Element},\n\n    /**\n     * The orientation against which to align the element horizontally\n     * relative to the `positionTarget`. Possible values are \"left\", \"right\",\n     * \"center\", \"auto\".\n     */\n    horizontalAlign: {type: String},\n\n    /**\n     * The orientation against which to align the element vertically\n     * relative to the `positionTarget`. Possible values are \"top\", \"bottom\",\n     * \"middle\", \"auto\".\n     */\n    verticalAlign: {type: String},\n\n    /**\n     * If true, it will use `horizontalAlign` and `verticalAlign` values as\n     * preferred alignment and if there's not enough space, it will pick the\n     * values which minimize the cropping.\n     */\n    dynamicAlign: {type: Boolean},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `horizontalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `horizontalAlign`.\n     *\n     * If `horizontalAlign` is \"left\" or \"center\", this offset will increase or\n     * decrease the distance to the left side of the screen: a negative offset\n     * will move the dropdown to the left; a positive one, to the right.\n     *\n     * Conversely if `horizontalAlign` is \"right\", this offset will increase\n     * or decrease the distance to the right side of the screen: a negative\n     * offset will move the dropdown to the right; a positive one, to the left.\n     */\n    horizontalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * A pixel value that will be added to the position calculated for the\n     * given `verticalAlign`, in the direction of alignment. You can think\n     * of it as increasing or decreasing the distance to the side of the\n     * screen given by `verticalAlign`.\n     *\n     * If `verticalAlign` is \"top\" or \"middle\", this offset will increase or\n     * decrease the distance to the top side of the screen: a negative offset\n     * will move the dropdown upwards; a positive one, downwards.\n     *\n     * Conversely if `verticalAlign` is \"bottom\", this offset will increase\n     * or decrease the distance to the bottom side of the screen: a negative\n     * offset will move the dropdown downwards; a positive one, upwards.\n     */\n    verticalOffset: {type: Number, value: 0, notify: true},\n\n    /**\n     * Set to true to auto-fit on attach.\n     */\n    autoFitOnAttach: {type: Boolean, value: false},\n\n    /**\n     * If true and scrollbars are added to `sizingTarget` after it is\n     * positioned, the size of the added scrollbars will be added to its\n     * `maxWidth` and `maxHeight`.\n     */\n    expandSizingTargetForScrollbars: {type: Boolean, value: false},\n\n    /** @type {?Object} */\n    _fitInfo: {type: Object}\n  },\n\n  get _fitWidth() {\n    var fitWidth;\n    if (this.fitInto === window) {\n      fitWidth = this.fitInto.innerWidth;\n    } else {\n      fitWidth = this.fitInto.getBoundingClientRect().width;\n    }\n    return fitWidth;\n  },\n\n  get _fitHeight() {\n    var fitHeight;\n    if (this.fitInto === window) {\n      fitHeight = this.fitInto.innerHeight;\n    } else {\n      fitHeight = this.fitInto.getBoundingClientRect().height;\n    }\n    return fitHeight;\n  },\n\n  get _fitLeft() {\n    var fitLeft;\n    if (this.fitInto === window) {\n      fitLeft = 0;\n    } else {\n      fitLeft = this.fitInto.getBoundingClientRect().left;\n    }\n    return fitLeft;\n  },\n\n  get _fitTop() {\n    var fitTop;\n    if (this.fitInto === window) {\n      fitTop = 0;\n    } else {\n      fitTop = this.fitInto.getBoundingClientRect().top;\n    }\n    return fitTop;\n  },\n\n  /**\n   * The element that should be used to position the element,\n   * if no position target is configured.\n   */\n  get _defaultPositionTarget() {\n    var parent = dom(this).parentNode;\n\n    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      parent = parent.host;\n    }\n\n    return parent;\n  },\n\n  /**\n   * The horizontal align value, accounting for the RTL/LTR text direction.\n   */\n  get _localeHorizontalAlign() {\n    if (this._isRTL) {\n      // In RTL, \"left\" becomes \"right\".\n      if (this.horizontalAlign === 'right') {\n        return 'left';\n      }\n      if (this.horizontalAlign === 'left') {\n        return 'right';\n      }\n    }\n    return this.horizontalAlign;\n  },\n\n  /**\n   * True if the element should be positioned instead of centered.\n   * @private\n   */\n  get __shouldPosition() {\n    return (this.horizontalAlign || this.verticalAlign) && this.positionTarget;\n  },\n\n  /**\n   * True if the component is RTL.\n   * @private\n   */\n  get _isRTL() {\n    // Memoize this to avoid expensive calculations & relayouts.\n    // Make sure we do it only once\n    if (typeof this._memoizedIsRTL === 'undefined') {\n      this._memoizedIsRTL = window.getComputedStyle(this).direction == 'rtl';\n    }\n    return this._memoizedIsRTL;\n  },\n\n  /** @override */\n  attached: function() {\n    this.positionTarget = this.positionTarget || this._defaultPositionTarget;\n    if (this.autoFitOnAttach) {\n      if (window.getComputedStyle(this).display === 'none') {\n        setTimeout(function() {\n          this.fit();\n        }.bind(this));\n      } else {\n        // NOTE: shadydom applies distribution asynchronously\n        // for performance reasons webcomponents/shadydom#120\n        // Flush to get correct layout info.\n        window.ShadyDOM && ShadyDOM.flush();\n        this.fit();\n      }\n    }\n  },\n\n  /** @override */\n  detached: function() {\n    if (this.__deferredFit) {\n      clearTimeout(this.__deferredFit);\n      this.__deferredFit = null;\n    }\n  },\n\n  /**\n   * Positions and fits the element into the `fitInto` element.\n   */\n  fit: function() {\n    this.position();\n    this.constrain();\n    this.center();\n  },\n\n  /**\n   * Memoize information needed to position and size the target element.\n   * @suppress {deprecated}\n   */\n  _discoverInfo: function() {\n    if (this._fitInfo) {\n      return;\n    }\n    var target = window.getComputedStyle(this);\n    var sizer = window.getComputedStyle(this.sizingTarget);\n\n    this._fitInfo = {\n      inlineStyle: {\n        top: this.style.top || '',\n        left: this.style.left || '',\n        position: this.style.position || ''\n      },\n      sizerInlineStyle: {\n        maxWidth: this.sizingTarget.style.maxWidth || '',\n        maxHeight: this.sizingTarget.style.maxHeight || '',\n        boxSizing: this.sizingTarget.style.boxSizing || ''\n      },\n      positionedBy: {\n        vertically: target.top !== 'auto' ?\n            'top' :\n            (target.bottom !== 'auto' ? 'bottom' : null),\n        horizontally: target.left !== 'auto' ?\n            'left' :\n            (target.right !== 'auto' ? 'right' : null)\n      },\n      sizedBy: {\n        height: sizer.maxHeight !== 'none',\n        width: sizer.maxWidth !== 'none',\n        minWidth: parseInt(sizer.minWidth, 10) || 0,\n        minHeight: parseInt(sizer.minHeight, 10) || 0\n      },\n      margin: {\n        top: parseInt(target.marginTop, 10) || 0,\n        right: parseInt(target.marginRight, 10) || 0,\n        bottom: parseInt(target.marginBottom, 10) || 0,\n        left: parseInt(target.marginLeft, 10) || 0\n      }\n    };\n  },\n\n  /**\n   * Resets the target element's position and size constraints, and clear\n   * the memoized data.\n   */\n  resetFit: function() {\n    var info = this._fitInfo || {};\n    for (var property in info.sizerInlineStyle) {\n      this.sizingTarget.style[property] = info.sizerInlineStyle[property];\n    }\n    for (var property in info.inlineStyle) {\n      this.style[property] = info.inlineStyle[property];\n    }\n\n    this._fitInfo = null;\n  },\n\n  /**\n   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after\n   * the element or the `fitInto` element has been resized, or if any of the\n   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.\n   * It preserves the scroll position of the sizingTarget.\n   */\n  refit: function() {\n    var scrollLeft = this.sizingTarget.scrollLeft;\n    var scrollTop = this.sizingTarget.scrollTop;\n    this.resetFit();\n    this.fit();\n    this.sizingTarget.scrollLeft = scrollLeft;\n    this.sizingTarget.scrollTop = scrollTop;\n  },\n\n  /**\n   * Positions the element according to `horizontalAlign, verticalAlign`.\n   */\n  position: function() {\n    if (!this.__shouldPosition) {\n      // needs to be centered, and it is done after constrain.\n      return;\n    }\n    this._discoverInfo();\n\n    window.ShadyDOM && window.ShadyDOM.flush();\n\n    this.style.position = 'fixed';\n    // Need border-box for margin/padding.\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // Set to 0, 0 in order to discover any offset caused by parent stacking\n    // contexts.\n    this.style.left = '0px';\n    this.style.top = '0px';\n\n    var rect = this.getBoundingClientRect();\n    var positionRect = this.__getNormalizedRect(this.positionTarget);\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n\n    let unpositionedOffsetWidth;\n    let unpositionedOffsetHeight;\n    let unpositionedClientWidth;\n    let unpositionedClientHeight;\n    if (this.expandSizingTargetForScrollbars) {\n      unpositionedOffsetWidth = this.sizingTarget.offsetWidth;\n      unpositionedOffsetHeight = this.sizingTarget.offsetHeight;\n      unpositionedClientWidth = this.sizingTarget.clientWidth;\n      unpositionedClientHeight = this.sizingTarget.clientHeight;\n    }\n\n    var margin = this._fitInfo.margin;\n\n    // Consider the margin as part of the size for position calculations.\n    var size = {\n      width: rect.width + margin.left + margin.right,\n      height: rect.height + margin.top + margin.bottom\n    };\n\n    var position = this.__getPosition(\n        this._localeHorizontalAlign,\n        this.verticalAlign,\n        size,\n        rect,\n        positionRect,\n        fitRect);\n\n    var left = position.left + margin.left;\n    var top = position.top + margin.top;\n\n    // We first limit right/bottom within fitInto respecting the margin,\n    // then use those values to limit top/left.\n    var right = Math.min(fitRect.right - margin.right, left + rect.width);\n    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);\n\n    // Keep left/top within fitInto respecting the margin.\n    left = Math.max(\n        fitRect.left + margin.left,\n        Math.min(left, right - this._fitInfo.sizedBy.minWidth));\n    top = Math.max(\n        fitRect.top + margin.top,\n        Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));\n\n    // Use right/bottom to set maxWidth/maxHeight, and respect\n    // minWidth/minHeight.\n    const maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth);\n    const maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight);\n    this.sizingTarget.style.maxWidth = maxWidth + 'px';\n    this.sizingTarget.style.maxHeight = maxHeight + 'px';\n\n    // Remove the offset caused by any stacking context.\n    const leftPosition = left - rect.left;\n    const topPosition = top - rect.top;\n    this.style.left = `${leftPosition}px`;\n    this.style.top = `${topPosition}px`;\n\n    if (this.expandSizingTargetForScrollbars) {\n      // Expand the height first - i.e. in the typical block direction - in case\n      // this expands the element enough to remove the vertical scrollbar.\n\n      const positionedOffsetHeight = this.sizingTarget.offsetHeight;\n      const positionedClientHeight = this.sizingTarget.clientHeight;\n      const unpositionedHeightDelta =\n          unpositionedOffsetHeight - unpositionedClientHeight;\n      const positionedHeightDelta =\n          positionedOffsetHeight - positionedClientHeight;\n\n      const sizingTargetScrollbarHeight =\n          positionedHeightDelta - unpositionedHeightDelta;\n      if (sizingTargetScrollbarHeight > 0) {\n        // Expand `maxHeight` by `sizingTargetScrollbarHeight` up to the overall\n        // allowed height within `fitRect`.\n        const fitRectMaxHeight = fitRect.height - margin.top - margin.bottom;\n        const newMaxHeight =\n            Math.min(fitRectMaxHeight, maxHeight + sizingTargetScrollbarHeight);\n        this.sizingTarget.style.maxHeight = `${newMaxHeight}px`;\n\n        // Measure the element's real change in height. This may not equal\n        // `sizingTargetScrollbarHeight` if the overflow amount is less than the\n        // scrollbar size.\n        const offsetHeight = this.sizingTarget.offsetHeight;\n        const addedHeight = offsetHeight - positionedOffsetHeight;\n\n        // Adjust the top position if the alignment requires it.\n        let newTopPosition;\n        if (position.verticalAlign === 'top') {\n          newTopPosition = topPosition;\n        } else if (position.verticalAlign === 'middle') {\n          newTopPosition = topPosition - addedHeight / 2;\n        } else if (position.verticalAlign === 'bottom') {\n          newTopPosition = topPosition - addedHeight;\n        }\n\n        // Constrain the new top position based on `fitRect` again.\n        newTopPosition = Math.max(\n            fitRect.top + margin.top,\n            Math.min(\n                newTopPosition, fitRect.bottom - margin.bottom - offsetHeight));\n        this.style.top = `${newTopPosition}px`;\n      }\n\n      const positionedOffsetWidth = this.sizingTarget.offsetWidth;\n      const positionedClientWidth = this.sizingTarget.clientWidth;\n      const unpositionedWidthDelta =\n          unpositionedOffsetWidth - unpositionedClientWidth;\n      const positionedWidthDelta =\n          positionedOffsetWidth - positionedClientWidth;\n\n      const sizingTargetScrollbarWidth =\n          positionedWidthDelta - unpositionedWidthDelta;\n      if (sizingTargetScrollbarWidth > 0) {\n        const maxWidthBugOffset = getVerticalScrollbarMaxWidthBugOffset();\n\n        // Expand `maxWidth` by `sizingTargetScrollbarWidth` up to the overall\n        // allowed width within `fitRect`.\n        const fitRectMaxWidth = fitRect.width - margin.left - margin.right;\n        const newMaxWidth = Math.min(\n            fitRectMaxWidth,\n            maxWidth + sizingTargetScrollbarWidth - maxWidthBugOffset);\n        this.sizingTarget.style.maxWidth = `${newMaxWidth}px`;\n\n        // Measure the element's real change in width. This may not equal\n        // `sizingTargetScrollbarWidth` if the overflow amount is less than the\n        // scrollbar size.\n        const offsetWidth = this.sizingTarget.offsetWidth + maxWidthBugOffset;\n        const addedWidth = offsetWidth - positionedOffsetWidth;\n\n        // Adjust the left position if the alignment requires it.\n        let newLeftPosition;\n        if (position.horizontalAlign === 'left') {\n          newLeftPosition = leftPosition;\n        } else if (position.horizontalAlign === 'center') {\n          newLeftPosition = leftPosition - addedWidth / 2;\n        } else if (position.horizontalAlign === 'right') {\n          newLeftPosition = leftPosition - addedWidth;\n        }\n\n        // Constrain the new left position based on `fitRect` again.\n        newLeftPosition = Math.max(\n            fitRect.left + margin.left,\n            Math.min(\n                newLeftPosition, fitRect.right - margin.right - offsetWidth));\n        this.style.left = `${newLeftPosition}px`;\n      }\n    }\n  },\n\n  /**\n   * Constrains the size of the element to `fitInto` by setting `max-height`\n   * and/or `max-width`.\n   */\n  constrain: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var info = this._fitInfo;\n    // position at (0px, 0px) if not already positioned, so we can measure the\n    // natural size.\n    if (!info.positionedBy.vertically) {\n      this.style.position = 'fixed';\n      this.style.top = '0px';\n    }\n    if (!info.positionedBy.horizontally) {\n      this.style.position = 'fixed';\n      this.style.left = '0px';\n    }\n\n    // need border-box for margin/padding\n    this.sizingTarget.style.boxSizing = 'border-box';\n    // constrain the width and height if not already set\n    var rect = this.getBoundingClientRect();\n    if (!info.sizedBy.height) {\n      this.__sizeDimension(\n          rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');\n    }\n    if (!info.sizedBy.width) {\n      this.__sizeDimension(\n          rect, info.positionedBy.horizontally, 'left', 'right', 'Width');\n    }\n  },\n\n  /**\n   * @protected\n   * @deprecated\n   */\n  _sizeDimension: function(rect, positionedBy, start, end, extent) {\n    this.__sizeDimension(rect, positionedBy, start, end, extent);\n  },\n\n  /**\n   * @private\n   */\n  __sizeDimension: function(rect, positionedBy, start, end, extent) {\n    var info = this._fitInfo;\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    var max = extent === 'Width' ? fitRect.width : fitRect.height;\n    var flip = (positionedBy === end);\n    var offset = flip ? max - rect[end] : rect[start];\n    var margin = info.margin[flip ? start : end];\n    var offsetExtent = 'offset' + extent;\n    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];\n    this.sizingTarget.style['max' + extent] =\n        (max - margin - offset - sizingOffset) + 'px';\n  },\n\n  /**\n   * Centers horizontally and vertically if not already positioned. This also\n   * sets `position:fixed`.\n   */\n  center: function() {\n    if (this.__shouldPosition) {\n      return;\n    }\n    this._discoverInfo();\n\n    var positionedBy = this._fitInfo.positionedBy;\n    if (positionedBy.vertically && positionedBy.horizontally) {\n      // Already positioned.\n      return;\n    }\n    // Need position:fixed to center\n    this.style.position = 'fixed';\n    // Take into account the offset caused by parents that create stacking\n    // contexts (e.g. with transform: translate3d). Translate to 0,0 and\n    // measure the bounding rect.\n    if (!positionedBy.vertically) {\n      this.style.top = '0px';\n    }\n    if (!positionedBy.horizontally) {\n      this.style.left = '0px';\n    }\n    // It will take in consideration margins and transforms\n    var rect = this.getBoundingClientRect();\n    var fitRect = this.__getNormalizedRect(this.fitInto);\n    if (!positionedBy.vertically) {\n      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;\n      this.style.top = top + 'px';\n    }\n    if (!positionedBy.horizontally) {\n      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;\n      this.style.left = left + 'px';\n    }\n  },\n\n  __getNormalizedRect: function(target) {\n    if (target === document.documentElement || target === window) {\n      return {\n        top: 0,\n        left: 0,\n        width: window.innerWidth,\n        height: window.innerHeight,\n        right: window.innerWidth,\n        bottom: window.innerHeight\n      };\n    }\n    return target.getBoundingClientRect();\n  },\n\n  __getOffscreenArea: function(position, size, fitRect) {\n    var verticalCrop = Math.min(0, position.top) +\n        Math.min(0, fitRect.bottom - (position.top + size.height));\n    var horizontalCrop = Math.min(0, position.left) +\n        Math.min(0, fitRect.right - (position.left + size.width));\n    return Math.abs(verticalCrop) * size.width +\n        Math.abs(horizontalCrop) * size.height;\n  },\n\n\n  __getPosition: function(\n      hAlign, vAlign, size, sizeNoMargins, positionRect, fitRect) {\n    // All the possible configurations.\n    // Ordered as top-left, top-right, bottom-left, bottom-right.\n    var positions = [\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'left',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'top',\n        horizontalAlign: 'right',\n        top: positionRect.top + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'left',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset\n      },\n      {\n        verticalAlign: 'bottom',\n        horizontalAlign: 'right',\n        top: positionRect.bottom - size.height - this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset\n      }\n    ];\n\n    if (this.noOverlap) {\n      // Duplicate.\n      for (var i = 0, l = positions.length; i < l; i++) {\n        var copy = {};\n        for (var key in positions[i]) {\n          copy[key] = positions[i][key];\n        }\n        positions.push(copy);\n      }\n      // Horizontal overlap only.\n      positions[0].top = positions[1].top += positionRect.height;\n      positions[2].top = positions[3].top -= positionRect.height;\n      // Vertical overlap only.\n      positions[4].left = positions[6].left += positionRect.width;\n      positions[5].left = positions[7].left -= positionRect.width;\n    }\n\n    // Consider auto as null for coding convenience.\n    vAlign = vAlign === 'auto' ? null : vAlign;\n    hAlign = hAlign === 'auto' ? null : hAlign;\n\n    if (!hAlign || hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'top',\n        horizontalAlign: 'center',\n        top: positionRect.top + this.verticalOffset +\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n      positions.push({\n        verticalAlign: 'bottom',\n        horizontalAlign: 'center',\n        top: positionRect.bottom - size.height - this.verticalOffset -\n            (this.noOverlap ? positionRect.height : 0),\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    if (!vAlign || vAlign === 'middle') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'left',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left + this.horizontalOffset +\n            (this.noOverlap ? positionRect.width : 0)\n      });\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'right',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.right - size.width - this.horizontalOffset -\n            (this.noOverlap ? positionRect.width : 0)\n      });\n    }\n\n    if (vAlign === 'middle' && hAlign === 'center') {\n      positions.push({\n        verticalAlign: 'middle',\n        horizontalAlign: 'center',\n        top: positionRect.top - sizeNoMargins.height / 2 +\n            positionRect.height / 2 + this.verticalOffset,\n        left: positionRect.left - sizeNoMargins.width / 2 +\n            positionRect.width / 2 + this.horizontalOffset\n      });\n    }\n\n    var position;\n    for (var i = 0; i < positions.length; i++) {\n      var candidate = positions[i];\n      var vAlignOk = candidate.verticalAlign === vAlign;\n      var hAlignOk = candidate.horizontalAlign === hAlign;\n\n      // If both vAlign and hAlign are defined, return exact match.\n      // For dynamicAlign and noOverlap we'll have more than one candidate, so\n      // we'll have to check the offscreenArea to make the best choice.\n      if (!this.dynamicAlign && !this.noOverlap && vAlignOk && hAlignOk) {\n        position = candidate;\n        break;\n      }\n\n      // Align is ok if alignment preferences are respected. If no preferences,\n      // it is considered ok.\n      var alignOk = (!vAlign || vAlignOk) && (!hAlign || hAlignOk);\n\n      // Filter out elements that don't match the alignment (if defined).\n      // With dynamicAlign, we need to consider all the positions to find the\n      // one that minimizes the cropped area.\n      if (!this.dynamicAlign && !alignOk) {\n        continue;\n      }\n\n      candidate.offscreenArea =\n          this.__getOffscreenArea(candidate, size, fitRect);\n      // If not cropped and respects the align requirements, keep it.\n      // This allows to prefer positions overlapping horizontally over the\n      // ones overlapping vertically.\n      if (candidate.offscreenArea === 0 && alignOk) {\n        position = candidate;\n        break;\n      }\n      position = position || candidate;\n      var diff = candidate.offscreenArea - position.offscreenArea;\n      // Check which crops less. If it crops equally, check if at least one\n      // align setting is ok.\n      if (diff < 0 || (diff === 0 && (vAlignOk || hAlignOk))) {\n        position = candidate;\n      }\n    }\n\n    return position;\n  }\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}