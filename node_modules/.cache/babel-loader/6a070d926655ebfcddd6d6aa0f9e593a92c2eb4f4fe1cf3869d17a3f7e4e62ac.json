{"ast":null,"code":"import \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.global-this.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n!function (i) {\n  \"function\" == typeof define && define.amd ? define(i) : i();\n}(function () {\n  \"use strict\";\n\n  /**\n       * @license\n       * Copyright 2017 Google LLC\n       * SPDX-License-Identifier: BSD-3-Clause\n       */\n  var i,\n    n,\n    o = \"__scoped\";\n  null !== (i = globalThis.reactiveElementPolyfillSupport) && void 0 !== i || (globalThis.reactiveElementPolyfillSupport = function (i) {\n    var n = i.ReactiveElement;\n    if (void 0 !== window.ShadyCSS && (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)) {\n      var t = n.prototype;\n      window.ShadyDOM && window.ShadyDOM.inUse && !0 === window.ShadyDOM.noPatch && window.ShadyDOM.patchElementProto(t);\n      var d = t.createRenderRoot;\n      t.createRenderRoot = function () {\n        var i,\n          n,\n          t,\n          w = this.localName;\n        if (window.ShadyCSS.nativeShadow) return d.call(this);\n        if (!this.constructor.hasOwnProperty(o)) {\n          this.constructor[o] = !0;\n          var v = this.constructor.elementStyles.map(function (i) {\n            return i instanceof CSSStyleSheet ? Array.from(i.cssRules).reduce(function (i, n) {\n              return i + n.cssText;\n            }, \"\") : i.cssText;\n          });\n          null === (n = null === (i = window.ShadyCSS) || void 0 === i ? void 0 : i.ScopingShim) || void 0 === n || n.prepareAdoptedCssText(v, w), void 0 === this.constructor._$AJ && window.ShadyCSS.prepareTemplateStyles(document.createElement(\"template\"), w);\n        }\n        return null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);\n      };\n      var w = t.connectedCallback;\n      t.connectedCallback = function () {\n        w.call(this), this.hasUpdated && window.ShadyCSS.styleElement(this);\n      };\n      var v = t._$AE;\n      t._$AE = function (i) {\n        this.hasUpdated || window.ShadyCSS.styleElement(this), v.call(this, i);\n      };\n    }\n  });\n  var t,\n    d = new Set(),\n    w = new Map();\n  null !== (n = globalThis.litHtmlPolyfillSupport) && void 0 !== n || (globalThis.litHtmlPolyfillSupport = function (i, n) {\n    if (void 0 !== window.ShadyCSS && (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)) {\n      var o = function o(i) {\n          return void 0 !== i && !d.has(i);\n        },\n        t = function t(i) {\n          var n = w.get(i);\n          return void 0 === n && w.set(i, n = []), n;\n        },\n        v = new Map(),\n        l = i.createElement;\n      i.createElement = function (n, d) {\n        var w = l.call(i, n, d),\n          v = null == d ? void 0 : d.scope;\n        if (void 0 !== v && (window.ShadyCSS.nativeShadow || window.ShadyCSS.prepareTemplateDom(w, v), o(v))) {\n          var r = t(v),\n            u = w.content.querySelectorAll(\"style\");\n          r.push.apply(r, Array.from(u).map(function (i) {\n            var n;\n            return null === (n = i.parentNode) || void 0 === n || n.removeChild(i), i.textContent;\n          }));\n        }\n        return w;\n      };\n      var r = document.createDocumentFragment(),\n        u = document.createComment(\"\"),\n        s = n.prototype,\n        e = s._$AI;\n      s._$AI = function (i, n) {\n        var v, l;\n        void 0 === n && (n = this);\n        var s = this._$AA.parentNode,\n          a = null === (v = this.options) || void 0 === v ? void 0 : v.scope;\n        if (s instanceof ShadowRoot && o(a)) {\n          var h = this._$AA,\n            f = this._$AB;\n          r.appendChild(u), this._$AA = u, this._$AB = null, e.call(this, i, n);\n          var c = (null == i ? void 0 : i._$litType$) ? this._$AH._$AD.el : document.createElement(\"template\");\n          if (function (i, n) {\n            var o,\n              v = t(i),\n              l = 0 !== v.length;\n            l && ((o = document.createElement(\"style\")).textContent = v.join(\"\\n\"), n.content.appendChild(o)), d.add(i), w.delete(i), window.ShadyCSS.prepareTemplateStyles(n, i), l && window.ShadyCSS.nativeShadow && null !== (o = n.content.querySelector(\"style\")) && n.content.appendChild(o);\n          }(a, c), r.removeChild(u), null === (l = window.ShadyCSS) || void 0 === l ? void 0 : l.nativeShadow) {\n            var y = c.content.querySelector(\"style\");\n            null !== y && r.appendChild(y.cloneNode(!0));\n          }\n          s.insertBefore(r, f), this._$AA = h, this._$AB = f;\n        } else e.call(this, i, n);\n      }, s._$AC = function (n) {\n        var o,\n          t = null === (o = this.options) || void 0 === o ? void 0 : o.scope,\n          d = v.get(t);\n        void 0 === d && v.set(t, d = new Map());\n        var w = d.get(n.strings);\n        return void 0 === w && d.set(n.strings, w = new i(n, this.options)), w;\n      };\n    }\n  }), null !== (t = globalThis.litElementPolyfillSupport) && void 0 !== t || (globalThis.litElementPolyfillSupport = function (i) {\n    var n = i.LitElement;\n    if (void 0 !== window.ShadyCSS && (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)) {\n      n._$AJ = !0;\n      var o = n.prototype,\n        t = o.createRenderRoot;\n      o.createRenderRoot = function () {\n        return this.renderOptions.scope = this.localName, t.call(this);\n      };\n    }\n  });\n});","map":{"version":3,"names":["o","i","globalThis","reactiveElementPolyfillSupport","n","ReactiveElement","window","ShadyCSS","nativeShadow","ApplyShim","t","prototype","ShadyDOM","inUse","noPatch","patchElementProto","d","createRenderRoot","w","localName","call","constructor","hasOwnProperty","v","elementStyles","map","CSSStyleSheet","Array","from","cssRules","reduce","cssText","ScopingShim","prepareAdoptedCssText","_$AJ","prepareTemplateStyles","document","createElement","shadowRoot","attachShadow","shadowRootOptions","connectedCallback","hasUpdated","styleElement","_$AE","Set","Map","litHtmlPolyfillSupport","has","get","set","l","scope","prepareTemplateDom","r","u","content","querySelectorAll","push","apply","parentNode","removeChild","textContent","createDocumentFragment","createComment","s","e","_$AI","_$AA","a","options","ShadowRoot","h","f","_$AB","appendChild","c","_$litType$","_$AH","_$AD","el","length","join","add","delete","querySelector","y","cloneNode","insertBefore","_$AC","strings","litElementPolyfillSupport","LitElement","renderOptions"],"sources":["../reactive-element/src/polyfill-support.ts","../lit-html/src/polyfill-support.ts","../lit-element/src/polyfill-support.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * ReactiveElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property.\n *\n * @packageDocumentation\n */\n\nexport {};\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\nconst SCOPED = '__scoped';\n\ntype CSSResults = Array<{cssText: string} | CSSStyleSheet>;\n\ninterface PatchableReactiveElementConstructor {\n  [SCOPED]: boolean;\n  elementStyles: CSSResults;\n  shadowRootOptions: ShadowRootInit;\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableReactiveElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableReactiveElement;\n  constructor: PatchableReactiveElementConstructor;\n  connectedCallback(): void;\n  hasUpdated: boolean;\n  _$didUpdate(changedProperties: unknown): void;\n  createRenderRoot(): Element | ShadowRoot;\n  renderOptions: RenderOptions;\n}\n\n// Note, explicitly use `var` here so that this can be re-defined when\n// bundled.\n// eslint-disable-next-line no-var\nvar DEV_MODE = true;\n\nconst polyfillSupport = ({\n  ReactiveElement,\n}: {\n  ReactiveElement: PatchableReactiveElement;\n}) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making ReactiveElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const elementProto = ReactiveElement.prototype;\n\n  // In noPatch mode, patch the ReactiveElement prototype so that no\n  // ReactiveElements must be wrapped.\n  if (\n    window.ShadyDOM &&\n    window.ShadyDOM.inUse &&\n    window.ShadyDOM.noPatch === true\n  ) {\n    window.ShadyDOM.patchElementProto(elementProto);\n  }\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const createRenderRoot = elementProto.createRenderRoot;\n  elementProto.createRenderRoot = function (this: PatchableReactiveElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS.\n    const name = this.localName;\n    // If using native Shadow DOM must adoptStyles normally,\n    // otherwise do nothing.\n    if (window.ShadyCSS!.nativeShadow) {\n      return createRenderRoot.call(this);\n    } else {\n      if (!this.constructor.hasOwnProperty(SCOPED)) {\n        (this.constructor as PatchableReactiveElementConstructor)[SCOPED] =\n          true;\n        // Use ShadyCSS's `prepareAdoptedCssText` to shim adoptedStyleSheets.\n        const css = (\n          this.constructor as PatchableReactiveElementConstructor\n        ).elementStyles.map((v) =>\n          v instanceof CSSStyleSheet\n            ? Array.from(v.cssRules).reduce(\n                (a: string, r: CSSRule) => (a += r.cssText),\n                ''\n              )\n            : v.cssText\n        );\n        window.ShadyCSS?.ScopingShim?.prepareAdoptedCssText(css, name);\n        if (this.constructor._$handlesPrepareStyles === undefined) {\n          window.ShadyCSS!.prepareTemplateStyles(\n            document.createElement('template'),\n            name\n          );\n        }\n      }\n      return (\n        this.shadowRoot ??\n        this.attachShadow(\n          (this.constructor as PatchableReactiveElementConstructor)\n            .shadowRootOptions\n        )\n      );\n    }\n  };\n\n  /**\n   * Patch connectedCallback to apply ShadyCSS custom properties shimming.\n   */\n  const connectedCallback = elementProto.connectedCallback;\n  elementProto.connectedCallback = function (this: PatchableReactiveElement) {\n    connectedCallback.call(this);\n    // Note, must do first update separately so that we're ensured\n    // that rendering has completed before calling this.\n    if (this.hasUpdated) {\n      window.ShadyCSS!.styleElement(this);\n    }\n  };\n\n  /**\n   * Patch update to apply ShadyCSS custom properties shimming for first\n   * update.\n   */\n  const didUpdate = elementProto._$didUpdate;\n  elementProto._$didUpdate = function (\n    this: PatchableReactiveElement,\n    changedProperties: unknown\n  ) {\n    // Note, must do first update here so rendering has completed before\n    // calling this and styles are correct by updated/firstUpdated.\n    if (!this.hasUpdated) {\n      window.ShadyCSS!.styleElement(this);\n    }\n    didUpdate.call(this, changedProperties);\n  };\n};\n\nif (DEV_MODE) {\n  globalThis.reactiveElementPolyfillSupportDevMode ??= polyfillSupport;\n} else {\n  globalThis.reactiveElementPolyfillSupport ??= polyfillSupport;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * lit-html patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill.\n * Scoping classes are added to DOM nodes to facilitate CSS scoping that\n * simulates the style scoping Shadow DOM provides. ShadyDOM does this scoping\n * to all elements added to the DOM. This module provides an important\n * optimization for this process by pre-scoping lit-html template\n * DOM. This means ShadyDOM does not have to scope each instance of the\n * template DOM. Instead, each template is scoped only once.\n *\n * Creating scoped CSS is not covered by this module. It is, however, integrated\n * into the lit-element and @lit/reactive-element packages. See the ShadyCSS docs\n * for how to apply scoping to CSS:\n * https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#usage.\n *\n * @packageDocumentation\n */\n\nexport {};\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface ShadyTemplateResult {\n  strings: TemplateStringsArray;\n  // This property needs to remain unminified.\n  ['_$litType$']?: string;\n}\n\n// Note, this is a dummy type as the full type here is big.\ninterface Directive {\n  __directive?: Directive;\n}\n\ninterface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\ninterface PatchableChildPartConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableChildPart;\n}\n\ninterface PatchableChildPart {\n  __directive?: Directive;\n  _$committedValue: unknown;\n  _$startNode: ChildNode;\n  _$endNode: ChildNode | null;\n  options: RenderOptions;\n  _$setValue(value: unknown, directiveParent: DirectiveParent): void;\n  _$getTemplate(result: ShadyTemplateResult): HTMLTemplateElement;\n}\n\ninterface PatchableTemplate {\n  el: HTMLTemplateElement;\n}\n\ninterface PatchableTemplateConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableTemplate;\n  createElement(html: string, options?: RenderOptions): HTMLTemplateElement;\n}\n\ninterface PatchableTemplateInstance {\n  _$template: PatchableTemplate;\n}\n\n// Scopes that have had styling prepared. Note, must only be done once per\n// scope.\nconst styledScopes: Set<string> = new Set();\n// Map of css per scope. This is collected during first scope render, used when\n// styling is prepared, and then discarded.\nconst scopeCssStore: Map<string, string[]> = new Map();\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\n// Note, explicitly use `var` here so that this can be re-defined when\n// bundled.\n// eslint-disable-next-line no-var\nvar DEV_MODE = true;\n\n/**\n * lit-html patches. These properties cannot be renamed.\n * * ChildPart.prototype._$getTemplate\n * * ChildPart.prototype._$setValue\n */\nconst polyfillSupport: NonNullable<typeof litHtmlPolyfillSupport> = (\n  Template: PatchableTemplateConstructor,\n  ChildPart: PatchableChildPartConstructor\n) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making lit-html compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const wrap =\n    ENABLE_SHADYDOM_NOPATCH &&\n    window.ShadyDOM?.inUse &&\n    window.ShadyDOM?.noPatch === true\n      ? window.ShadyDOM!.wrap\n      : (node: Node) => node;\n\n  const needsPrepareStyles = (name: string | undefined) =>\n    name !== undefined && !styledScopes.has(name);\n\n  const cssForScope = (name: string) => {\n    let scopeCss = scopeCssStore.get(name);\n    if (scopeCss === undefined) {\n      scopeCssStore.set(name, (scopeCss = []));\n    }\n    return scopeCss;\n  };\n\n  const prepareStyles = (name: string, template: HTMLTemplateElement) => {\n    // Get styles\n    const scopeCss = cssForScope(name);\n    const hasScopeCss = scopeCss.length !== 0;\n    if (hasScopeCss) {\n      const style = document.createElement('style');\n      style.textContent = scopeCss.join('\\n');\n      // Note, it's important to add the style to the *end* of the template so\n      // it doesn't mess up part indices.\n      template.content.appendChild(style);\n    }\n    // Mark this scope as styled.\n    styledScopes.add(name);\n    // Remove stored data since it's no longer needed.\n    scopeCssStore.delete(name);\n    // ShadyCSS removes scopes and removes the style under ShadyDOM and leaves\n    // it under native Shadow DOM\n    window.ShadyCSS!.prepareTemplateStyles(template, name);\n    // Note, under native Shadow DOM, the style is added to the beginning of the\n    // template. It must be moved to the *end* of the template so it doesn't\n    // mess up part indices.\n    if (hasScopeCss && window.ShadyCSS!.nativeShadow) {\n      // If there were styles but the CSS text was empty, ShadyCSS will\n      // eliminate the style altogether, so the style here could be null\n      const style = template.content.querySelector('style');\n      if (style !== null) {\n        template.content.appendChild(style);\n      }\n    }\n  };\n\n  const scopedTemplateCache = new Map<\n    string | undefined,\n    Map<TemplateStringsArray, PatchableTemplate>\n  >();\n\n  /**\n   * Override to extract style elements from the template\n   * and store all style.textContent in the shady scope data.\n   * Note, it's ok to patch Template since it's only used via ChildPart.\n   */\n  const originalCreateElement = Template.createElement;\n  Template.createElement = function (html: string, options?: RenderOptions) {\n    const element = originalCreateElement.call(Template, html, options);\n    const scope = options?.scope;\n    if (scope !== undefined) {\n      if (!window.ShadyCSS!.nativeShadow) {\n        window.ShadyCSS!.prepareTemplateDom(element, scope);\n      }\n      // Process styles only if this scope is being prepared. Otherwise,\n      // leave styles as is for back compat with Lit1.\n      if (needsPrepareStyles(scope)) {\n        const scopeCss = cssForScope(scope);\n        // Remove styles and store textContent.\n        const styles = element.content.querySelectorAll(\n          'style'\n        ) as NodeListOf<HTMLStyleElement>;\n        // Store the css in this template in the scope css and remove the <style>\n        // from the template _before_ the node-walk captures part indices\n        scopeCss.push(\n          ...Array.from(styles).map((style) => {\n            style.parentNode?.removeChild(style);\n            return style.textContent!;\n          })\n        );\n      }\n    }\n    return element;\n  };\n\n  const renderContainer = document.createDocumentFragment();\n  const renderContainerMarker = document.createComment('');\n\n  const childPartProto = ChildPart.prototype;\n  /**\n   * Patch to apply gathered css via ShadyCSS. This is done only once per scope.\n   */\n  const setValue = childPartProto._$setValue;\n  childPartProto._$setValue = function (\n    this: PatchableChildPart,\n    value: unknown,\n    directiveParent: DirectiveParent = this\n  ) {\n    const container = wrap(this._$startNode).parentNode!;\n    const scope = this.options?.scope;\n    if (container instanceof ShadowRoot && needsPrepareStyles(scope)) {\n      // Note, @apply requires outer => inner scope rendering on initial\n      // scope renders to apply property values correctly. Style preparation\n      // is tied to rendering into `shadowRoot`'s and this is typically done by\n      // custom elements. If this is done in `connectedCallback`, as is typical,\n      // the code below ensures the right order since content is rendered\n      // into a fragment first so the hosting element can prepare styles first.\n      // If rendering is done in the constructor, this won't work, but that's\n      // not supported in ShadyDOM anyway.\n      const startNode = this._$startNode;\n      const endNode = this._$endNode;\n\n      // Temporarily move this part into the renderContainer.\n      renderContainer.appendChild(renderContainerMarker);\n      this._$startNode = renderContainerMarker;\n      this._$endNode = null;\n\n      // Note, any nested template results render here and their styles will\n      // be extracted and collected.\n      setValue.call(this, value, directiveParent);\n\n      // Get the template for this result or create a dummy one if a result\n      // is not being rendered.\n      // This property needs to remain unminified.\n      const template = (value as ShadyTemplateResult)?.['_$litType$']\n        ? (this._$committedValue as PatchableTemplateInstance)._$template.el\n        : document.createElement('template');\n      prepareStyles(scope!, template);\n\n      // Note, this is the temporary startNode.\n      renderContainer.removeChild(renderContainerMarker);\n      // When using native Shadow DOM, include prepared style in shadowRoot.\n      if (window.ShadyCSS?.nativeShadow) {\n        const style = template.content.querySelector('style');\n        if (style !== null) {\n          renderContainer.appendChild(style.cloneNode(true));\n        }\n      }\n      container.insertBefore(renderContainer, endNode);\n      // Move part back to original container.\n      this._$startNode = startNode;\n      this._$endNode = endNode;\n    } else {\n      setValue.call(this, value, directiveParent);\n    }\n  };\n\n  /**\n   * Patch ChildPart._$getTemplate to look up templates in a cache bucketed\n   * by element name.\n   */\n  childPartProto._$getTemplate = function (\n    this: PatchableChildPart,\n    result: ShadyTemplateResult\n  ) {\n    const scope = this.options?.scope;\n    let templateCache = scopedTemplateCache.get(scope);\n    if (templateCache === undefined) {\n      scopedTemplateCache.set(scope, (templateCache = new Map()));\n    }\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(\n        result.strings,\n        (template = new Template(result, this.options))\n      );\n    }\n    return template;\n  };\n};\n\nif (ENABLE_SHADYDOM_NOPATCH) {\n  polyfillSupport.noPatchSupported = ENABLE_SHADYDOM_NOPATCH;\n}\n\nif (DEV_MODE) {\n  globalThis.litHtmlPolyfillSupportDevMode ??= polyfillSupport;\n} else {\n  globalThis.litHtmlPolyfillSupport ??= polyfillSupport;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * LitElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property and styles included\n * in the render method. There are some limitations to be aware of:\n * * only styles that are included in the first render of a component are scoped.\n * * In addition, support for the deprecated `@apply` feature of ShadyCSS is\n * only provided for styles included in the template and not styles provided\n * via the static styles property.\n * * Lit parts cannot be used in styles included in the template.\n *\n * @packageDocumentation\n */\n\nimport '@lit/reactive-element/polyfill-support.js';\nimport 'lit-html/polyfill-support.js';\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface PatchableLitElementConstructor {\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableLitElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableLitElement;\n  constructor: PatchableLitElementConstructor;\n  createRenderRoot(): Element | ShadowRoot;\n  renderOptions: RenderOptions;\n}\n\n// Note, explicitly use `var` here so that this can be re-defined when\n// bundled.\n// eslint-disable-next-line no-var\nvar DEV_MODE = true;\n\nconst polyfillSupport = ({LitElement}: {LitElement: PatchableLitElement}) => {\n  // polyfill-support is only needed if ShadyCSS or the ApplyShim is in use\n  // We test at the point of patching, which makes it safe to load\n  // webcomponentsjs and polyfill-support in either order\n  if (\n    window.ShadyCSS === undefined ||\n    (window.ShadyCSS.nativeShadow && !window.ShadyCSS.ApplyShim)\n  ) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making LitElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  (\n    LitElement as unknown as PatchableLitElementConstructor\n  )._$handlesPrepareStyles = true;\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const litElementProto = LitElement.prototype;\n  const createRenderRoot = litElementProto.createRenderRoot;\n  litElementProto.createRenderRoot = function (this: PatchableLitElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS. This is needed under Shady and also Shadow DOM,\n    // due to @apply.\n    this.renderOptions.scope = this.localName;\n    return createRenderRoot.call(this);\n  };\n};\n\nif (DEV_MODE) {\n  globalThis.litElementPolyfillSupportDevMode ??= polyfillSupport;\n} else {\n  globalThis.litElementPolyfillSupport ??= polyfillSupport;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}