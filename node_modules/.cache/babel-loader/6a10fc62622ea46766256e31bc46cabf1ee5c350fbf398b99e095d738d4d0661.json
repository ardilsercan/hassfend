{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport '../utils/boot.js';\nimport { wrap } from '../utils/wrap.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { root, isAncestor, isDescendant, get as _get2, translate, isPath, set as _set, normalize } from '../utils/path.js';\n/* for notify, reflect */\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertyAccessors } from './property-accessors.js';\n/* for annotated effects */\nimport { TemplateStamp } from './template-stamp.js';\nimport { sanitizeDOMValue, legacyUndefined, orderedComputed, removeNestedTemplates, fastDomIf } from '../utils/settings.js';\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nvar dedupeId = 0;\nvar NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nvar TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\nvar COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nvar capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nvar DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nvar DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  var effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (var p in effects) {\n        var protoFx = effects[p];\n        // Perf optimization over Array.slice\n        var instFx = effects[p] = Array(protoFx.length);\n        for (var i = 0; i < protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    var ran = false;\n    var id = dedupeId++;\n    for (var prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      var rootProperty = hasPaths ? root(prop) : prop;\n      var fxs = effects[rootProperty];\n      if (fxs) {\n        for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  var ran = false;\n  var rootProperty = hasPaths ? root(prop) : prop;\n  var fxs = effects[rootProperty];\n  if (fxs) {\n    for (var i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    var triggerPath = /** @type {string} */trigger.name;\n    return triggerPath == path || !!(trigger.structured && isAncestor(triggerPath, path)) || !!(trigger.wildcard && isDescendant(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  var fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  var changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  var fxs = inst[TYPES.NOTIFY];\n  var notified;\n  var id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (var prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  var host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  var rootProperty = root(path);\n  if (rootProperty !== path) {\n    var eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  var detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  wrap( /** @type {!HTMLElement} */inst).dispatchEvent(new CustomEvent(eventName, {\n    detail: detail\n  }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  var rootProperty = hasPaths ? root(property) : property;\n  var path = rootProperty != property ? property : null;\n  var value = path ? _get2(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property]; // specifically for .splices\n  }\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  var value;\n  var detail = /** @type {Object} */event.detail;\n  var fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  var value = inst.__data[property];\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */inst);\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  var computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      var order = getComputedOrder(inst);\n      var queue = [];\n      for (var p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      var info;\n      while (info = queue.shift()) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n      Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      var inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign( /** @type {!Object} */oldProps, inst.__dataOld);\n        Object.assign( /** @type {!Object} */changedProps, inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nvar insertEffect = function insertEffect(info, queue, order) {\n  var start = 0;\n  var end = queue.length - 1;\n  var idx = -1;\n  while (start <= end) {\n    var mid = start + end >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    var cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nvar enqueueEffectsFor = function enqueueEffectsFor(prop, computeEffects, queue, order, hasPaths) {\n  var rootProperty = hasPaths ? root(prop) : prop;\n  var fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (var i = 0; i < fxs.length; i++) {\n      var fx = fxs[i];\n      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  var ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    var effects = inst[TYPES.COMPUTE];\n    var _dependencyCounts = dependencyCounts(inst),\n      counts = _dependencyCounts.counts,\n      ready = _dependencyCounts.ready,\n      total = _dependencyCounts.total;\n    var curr;\n    while (curr = ready.shift()) {\n      ordered.set(curr, ordered.size);\n      var computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(function (fx) {\n          // Note `methodInfo` is where the computed property name is stored\n          var computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      var el = /** @type {HTMLElement} */inst;\n      console.warn(\"Computed graph for \".concat(el.localName, \" incomplete; circular?\"));\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  var infoForComputed = inst[COMPUTE_INFO];\n  var counts = {};\n  var computedDeps = inst[TYPES.COMPUTE];\n  var ready = [];\n  var total = 0;\n  // Count dependencies for each computed property\n  for (var p in infoForComputed) {\n    var info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] = info.args.filter(function (a) {\n      return !a.literal;\n    }).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (var _p in computedDeps) {\n    if (!infoForComputed[_p]) {\n      ready.push(_p);\n    }\n  }\n  return {\n    counts: counts,\n    ready: ready,\n    total: total\n  };\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  var result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  var computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  var links = inst.__dataLinkedPaths;\n  if (links) {\n    var link;\n    for (var a in links) {\n      var b = links[a];\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  var /** Binding */binding = {\n    kind: kind,\n    target: target,\n    parts: parts,\n    literal: literal,\n    isCompound: parts.length !== 1\n  };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    var _binding$parts$ = binding.parts[0],\n      event = _binding$parts$.event,\n      negate = _binding$parts$.negate;\n    binding.listenerEvent = event || camelToDashCase(target) + '-changed';\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  var index = templateInfo.nodeInfoList.length;\n  for (var i = 0; i < binding.parts.length; i++) {\n    var part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target + ' because \"-\" is not a valid attribute starting character');\n    } else {\n      var dependencies = part.dependencies;\n      var info = {\n        index: index,\n        binding: binding,\n        part: part,\n        evaluator: constructor\n      };\n      for (var j = 0; j < dependencies.length; j++) {\n        var trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info: info,\n          trigger: trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  var node = nodeList[info.index];\n  var binding = info.binding;\n  var part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    var value = props[path];\n    path = translate(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    var _value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (_value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, _value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute( /** @type {Element} */node, value, binding.target);\n  } else {\n    // Property binding\n    var prop = binding.target;\n    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    var storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' || binding.target === 'value' && (node.localName === 'input' || node.localName === 'textarea')) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  var nodeList = templateInfo.nodeList,\n    nodeInfoList = templateInfo.nodeInfoList;\n  if (nodeInfoList.length) {\n    for (var i = 0; i < nodeInfoList.length; i++) {\n      var info = nodeInfoList[i];\n      var node = nodeList[i];\n      var bindings = info.bindings;\n      if (bindings) {\n        for (var _i = 0; _i < bindings.length; _i++) {\n          var binding = bindings[_i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    var storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});\n    var parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    var literals = new Array(parts.length);\n    for (var j = 0; j < parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    var target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = wrap(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    var part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function (e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || dynamicFn && (_typeof(dynamicFn) !== 'object' || dynamicFn[sig.methodName]);\n  var info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo: methodInfo,\n    dynamicFn: dynamicFn\n  };\n  for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn,\n        info: info,\n        trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn,\n      info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  var context = inst._methodHost || inst;\n  var fn = context[info.methodName];\n  if (fn) {\n    var args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\nvar emptyArray = [];\n\n// Regular expressions used for binding\nvar IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nvar NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nvar SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nvar DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nvar STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nvar ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\\\s*' + ')';\nvar ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nvar ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nvar BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nvar OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nvar CLOSE_BRACKET = '(?:]]|}})';\nvar NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nvar EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nvar bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  var s = '';\n  for (var i = 0; i < parts.length; i++) {\n    var literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  var m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    var methodName = m[1];\n    var sig = {\n      methodName: methodName,\n      static: true,\n      args: emptyArray\n    };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      var args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function (rawArg) {\n    var arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  var arg = rawArg.trim()\n  // replace comma entity with comma\n  .replace(/&comma;/g, ',')\n  // repair extra escape sequences; note only commas strictly need\n  // escaping, but we allow any other char to be escaped since its\n  // likely users will do this\n  .replace(/\\\\(.)/g, '$1');\n  // basic argument descriptor\n  var a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  var fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch (fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = root(arg);\n    // detect structured path (has dots)\n    a.structured = isPath(arg);\n    if (a.structured) {\n      a.wildcard = arg.slice(-2) == '.*';\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\nfunction getArgValue(data, props, path) {\n  var value = _get2(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction _notifySplices(inst, array, path, splices) {\n  var splicesData = {\n    indexSplices: splices\n  };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  _notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nexport var PropertyEffects = dedupingMixin(function (superClass) {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  var propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  var PropertyEffects = /*#__PURE__*/function (_propertyEffectsBase) {\n    _inherits(PropertyEffects, _propertyEffectsBase);\n    function PropertyEffects() {\n      var _this;\n      _classCallCheck(this, PropertyEffects);\n      _this = _callSuper(this, PropertyEffects);\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      _this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      _this.__dataClientsReady;\n      /** @type {Array} */\n      _this.__dataPendingClients;\n      /** @type {Object} */\n      _this.__dataToNotify;\n      /** @type {Object} */\n      _this.__dataLinkedPaths;\n      /** @type {boolean} */\n      _this.__dataHasPaths;\n      /** @type {Object} */\n      _this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      _this.__dataHost;\n      /** @type {!Object} */\n      _this.__dataTemp;\n      /** @type {boolean} */\n      _this.__dataClientsInitialized;\n      /** @type {!Object} */\n      _this.__data;\n      /** @type {!Object|null} */\n      _this.__dataPending;\n      /** @type {!Object} */\n      _this.__dataOld;\n      /** @type {Object} */\n      _this.__computeEffects;\n      /** @type {Object} */\n      _this.__computeInfo;\n      /** @type {Object} */\n      _this.__reflectEffects;\n      /** @type {Object} */\n      _this.__notifyEffects;\n      /** @type {Object} */\n      _this.__propagateEffects;\n      /** @type {Object} */\n      _this.__observeEffects;\n      /** @type {Object} */\n      _this.__readOnly;\n      /** @type {!TemplateInfo} */\n      _this.__templateInfo;\n      /** @type {boolean} */\n      _this._overrideLegacyUndefined;\n      return _this;\n    }\n    _createClass(PropertyEffects, [{\n      key: \"PROPERTY_EFFECT_TYPES\",\n      get: function get() {\n        return TYPES;\n      }\n\n      /**\n       * @override\n       * @return {void}\n       */\n    }, {\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        _get(_getPrototypeOf(PropertyEffects.prototype), \"_initializeProperties\", this).call(this);\n        this._registerHost();\n        this.__dataClientsReady = false;\n        this.__dataPendingClients = null;\n        this.__dataToNotify = null;\n        this.__dataLinkedPaths = null;\n        this.__dataHasPaths = false;\n        // May be set on instance prior to upgrade\n        this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n        this.__dataHost = this.__dataHost || null;\n        this.__dataTemp = {};\n        this.__dataClientsInitialized = false;\n      }\n    }, {\n      key: \"_registerHost\",\n      value: function _registerHost() {\n        if (hostStack.length) {\n          var host = hostStack[hostStack.length - 1];\n          host._enqueueClient(this);\n          // This ensures even non-bound elements have a host set, as\n          // long as they upgrade synchronously\n          this.__dataHost = host;\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessors` implementation to provide a\n       * more efficient implementation of initializing properties from\n       * the prototype on the instance.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the prototype\n       * @return {void}\n       */\n    }, {\n      key: \"_initializeProtoProperties\",\n      value: function _initializeProtoProperties(props) {\n        this.__data = Object.create(props);\n        this.__dataPending = Object.create(props);\n        this.__dataOld = {};\n      }\n\n      /**\n       * Overrides `PropertyAccessors` implementation to avoid setting\n       * `_setProperty`'s `shouldNotify: true`.\n       *\n       * @override\n       * @param {Object} props Properties to initialize on the instance\n       * @return {void}\n       */\n    }, {\n      key: \"_initializeInstanceProperties\",\n      value: function _initializeInstanceProperties(props) {\n        var readOnly = this[TYPES.READ_ONLY];\n        for (var prop in props) {\n          if (!readOnly || !readOnly[prop]) {\n            this.__dataPending = this.__dataPending || {};\n            this.__dataOld = this.__dataOld || {};\n            this.__data[prop] = this.__dataPending[prop] = props[prop];\n          }\n        }\n      }\n\n      // Prototype setup ----------------------------------------\n\n      /**\n       * Equivalent to static `addPropertyEffect` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_addPropertyEffect\",\n      value: function _addPropertyEffect(property, type, effect) {\n        this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n        // effects are accumulated into arrays per property based on type\n        var effects = ensureOwnEffectMap(this, type, true)[property];\n        if (!effects) {\n          effects = this[type][property] = [];\n        }\n        effects.push(effect);\n      }\n\n      /**\n       * Removes the given property effect.\n       *\n       * @override\n       * @param {string} property Property the effect was associated with\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object to remove\n       * @return {void}\n       */\n    }, {\n      key: \"_removePropertyEffect\",\n      value: function _removePropertyEffect(property, type, effect) {\n        var effects = ensureOwnEffectMap(this, type, true)[property];\n        var idx = effects.indexOf(effect);\n        if (idx >= 0) {\n          effects.splice(idx, 1);\n        }\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a property effect\n       * of a certain type.\n       *\n       * @override\n       * @param {string} property Property name\n       * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @return {boolean} True if the prototype/instance has an effect of this\n       *     type\n       * @protected\n       */\n    }, {\n      key: \"_hasPropertyEffect\",\n      value: function _hasPropertyEffect(property, type) {\n        var effects = this[type];\n        return Boolean(effects && effects[property]);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"read only\"\n       * accessor for the given property.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this\n       *     type\n       * @protected\n       */\n    }, {\n      key: \"_hasReadOnlyEffect\",\n      value: function _hasReadOnlyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"notify\"\n       * property effect for the given property.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this\n       *     type\n       * @protected\n       */\n    }, {\n      key: \"_hasNotifyEffect\",\n      value: function _hasNotifyEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.NOTIFY);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"reflect to\n       * attribute\" property effect for the given property.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this\n       *     type\n       * @protected\n       */\n    }, {\n      key: \"_hasReflectEffect\",\n      value: function _hasReflectEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.REFLECT);\n      }\n\n      /**\n       * Returns whether the current prototype/instance has a \"computed\"\n       * property effect for the given property.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {boolean} True if the prototype/instance has an effect of this\n       *     type\n       * @protected\n       */\n    }, {\n      key: \"_hasComputedEffect\",\n      value: function _hasComputedEffect(property) {\n        return this._hasPropertyEffect(property, TYPES.COMPUTE);\n      }\n\n      // Runtime ----------------------------------------\n\n      /**\n       * Sets a pending property or path.  If the root property of the path in\n       * question had no accessor, the path is set, otherwise it is enqueued\n       * via `_setPendingProperty`.\n       *\n       * This function isolates relatively expensive functionality necessary\n       * for the public API (`set`, `setProperties`, `notifyPath`, and property\n       * change listeners via {{...}} bindings), such that it is only done\n       * when paths enter the system, and not at every propagation step.  It\n       * also sets a `__dataHasPaths` flag on the instance which is used to\n       * fast-path slower path-matching code in the property effects host paths.\n       *\n       * `path` can be a path string or array of path parts as accepted by the\n       * public API.\n       *\n       * @override\n       * @param {string | !Array<number|string>} path Path to set\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify Set to true if this change should\n       *  cause a property notification event dispatch\n       * @param {boolean=} isPathNotification If the path being set is a path\n       *   notification of an already changed value, as opposed to a request\n       *   to set and notify the change.  In the latter `false` case, a dirty\n       *   check is performed and then the value is set to the path before\n       *   enqueuing the pending property change.\n       * @return {boolean} Returns true if the property/path was enqueued in\n       *   the pending changes bag.\n       * @protected\n       */\n    }, {\n      key: \"_setPendingPropertyOrPath\",\n      value: function _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n        if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {\n          // Dirty check changes being set to a path against the actual object,\n          // since this is the entry point for paths into the system; from here\n          // the only dirty checks are against the `__dataTemp` cache to prevent\n          // duplicate work in the same turn only. Note, if this was a notification\n          // of a change already set to a path (isPathNotification: true),\n          // we always let the change through and skip the `set` since it was\n          // already dirty checked at the point of entry and the underlying\n          // object has already been updated\n          if (!isPathNotification) {\n            var old = _get2(this, path);\n            path = /** @type {string} */_set(this, path, value);\n            // Use property-accessor's simpler dirty check\n            if (!path || !_get(_getPrototypeOf(PropertyEffects.prototype), \"_shouldPropertyChange\", this).call(this, path, value, old)) {\n              return false;\n            }\n          }\n          this.__dataHasPaths = true;\n          if (this._setPendingProperty( /**@type{string}*/path, value, shouldNotify)) {\n            computeLinkedPaths(this, /**@type{string}*/path, value);\n            return true;\n          }\n        } else {\n          if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n            return this._setPendingProperty( /**@type{string}*/path, value, shouldNotify);\n          } else {\n            this[path] = value;\n          }\n        }\n        return false;\n      }\n\n      /**\n       * Applies a value to a non-Polymer element/node's property.\n       *\n       * The implementation makes a best-effort at binding interop:\n       * Some native element properties have side-effects when\n       * re-setting the same value (e.g. setting `<input>.value` resets the\n       * cursor position), so we do a dirty-check before setting the value.\n       * However, for better interop with non-Polymer custom elements that\n       * accept objects, we explicitly re-set object changes coming from the\n       * Polymer world (which may include deep object changes without the\n       * top reference changing), erring on the side of providing more\n       * information.\n       *\n       * Users may override this method to provide alternate approaches.\n       *\n       * @override\n       * @param {!Node} node The node to set a property on\n       * @param {string} prop The property to set\n       * @param {*} value The value to set\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_setUnmanagedPropertyToNode\",\n      value: function _setUnmanagedPropertyToNode(node, prop, value) {\n        // It is a judgment call that resetting primitives is\n        // \"bad\" and resettings objects is also \"good\"; alternatively we could\n        // implement a whitelist of tag & property values that should never\n        // be reset (e.g. <input>.value && <select>.value)\n        if (value !== node[prop] || _typeof(value) == 'object') {\n          // Note, className needs style scoping so this needs wrapping.\n          if (prop === 'className') {\n            node = /** @type {!Node} */wrap(node);\n          }\n          node[prop] = value;\n        }\n      }\n\n      /**\n       * Overrides the `PropertiesChanged` implementation to introduce special\n       * dirty check logic depending on the property & value being set:\n       *\n       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n       * 2. Object set to simple property (e.g. 'prop': {...})\n       *    Stored in `__dataTemp` and `__data`, dirty checked against\n       *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n       * 3. Primitive value set to simple property (e.g. 'prop': 42)\n       *    Stored in `__data`, dirty checked against `__data`\n       *\n       * The dirty-check is important to prevent cycles due to two-way\n       * notification, but paths and objects are only dirty checked against any\n       * previous value set during this turn via a \"temporary cache\" that is\n       * cleared when the last `_propertiesChanged` exits. This is so:\n       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n       *    due to array mutations like shift/unshift/splice; this is fine\n       *    since path changes are dirty-checked at user entry points like `set`\n       * b. dirty-checking for objects only lasts one turn to allow the user\n       *    to mutate the object in-place and re-set it with the same identity\n       *    and have all sub-properties re-propagated in a subsequent turn.\n       *\n       * The temp cache is not necessarily sufficient to prevent invalid array\n       * paths, since a splice can happen during the same turn (with pathological\n       * user code); we could introduce a \"fixup\" for temporarily cached array\n       * paths if needed: https://github.com/Polymer/polymer/issues/4227\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} shouldNotify True if property should fire notification\n       *   event (applies only for `notify: true` properties)\n       * @return {boolean} Returns true if the property changed\n       */\n    }, {\n      key: \"_setPendingProperty\",\n      value: function _setPendingProperty(property, value, shouldNotify) {\n        var propIsPath = this.__dataHasPaths && isPath(property);\n        var prevProps = propIsPath ? this.__dataTemp : this.__data;\n        if (this._shouldPropertyChange(property, value, prevProps[property])) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (!(property in this.__dataOld)) {\n            this.__dataOld[property] = this.__data[property];\n          }\n          // Paths are stored in temporary cache (cleared at end of turn),\n          // which is used for dirty-checking, all others stored in __data\n          if (propIsPath) {\n            this.__dataTemp[property] = value;\n          } else {\n            this.__data[property] = value;\n          }\n          // All changes go into pending property bag, passed to _propertiesChanged\n          this.__dataPending[property] = value;\n          // Track properties that should notify separately\n          if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {\n            this.__dataToNotify = this.__dataToNotify || {};\n            this.__dataToNotify[property] = shouldNotify;\n          }\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Overrides base implementation to ensure all accessors set `shouldNotify`\n       * to true, for per-property notification tracking.\n       *\n       * @override\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       */\n    }, {\n      key: \"_setProperty\",\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Overrides `PropertyAccessor`'s default async queuing of\n       * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n       * manually flushed), the function no-ops; otherwise flushes\n       * `_propertiesChanged` synchronously.\n       *\n       * @override\n       * @return {void}\n       */\n    }, {\n      key: \"_invalidateProperties\",\n      value: function _invalidateProperties() {\n        if (this.__dataReady) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Enqueues the given client on a list of pending clients, whose\n       * pending property changes can later be flushed via a call to\n       * `_flushClients`.\n       *\n       * @override\n       * @param {Object} client PropertyEffects client to enqueue\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_enqueueClient\",\n      value: function _enqueueClient(client) {\n        this.__dataPendingClients = this.__dataPendingClients || [];\n        if (client !== this) {\n          this.__dataPendingClients.push(client);\n        }\n      }\n\n      /**\n       * Flushes any clients previously enqueued via `_enqueueClient`, causing\n       * their `_flushProperties` method to run.\n       *\n       * @override\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_flushClients\",\n      value: function _flushClients() {\n        if (!this.__dataClientsReady) {\n          this.__dataClientsReady = true;\n          this._readyClients();\n          // Override point where accessors are turned on; importantly,\n          // this is after clients have fully readied, providing a guarantee\n          // that any property effects occur only after all clients are ready.\n          this.__dataReady = true;\n        } else {\n          this.__enableOrFlushClients();\n        }\n      }\n\n      // NOTE: We ensure clients either enable or flush as appropriate. This\n      // handles two corner cases:\n      // (1) clients flush properly when connected/enabled before the host\n      // enables; e.g.\n      //   (a) Templatize stamps with no properties and does not flush and\n      //   (b) the instance is inserted into dom and\n      //   (c) then the instance flushes.\n      // (2) clients enable properly when not connected/enabled when the host\n      // flushes; e.g.\n      //   (a) a template is runtime stamped and not yet connected/enabled\n      //   (b) a host sets a property, causing stamped dom to flush\n      //   (c) the stamped dom enables.\n    }, {\n      key: \"__enableOrFlushClients\",\n      value: function __enableOrFlushClients() {\n        var clients = this.__dataPendingClients;\n        if (clients) {\n          this.__dataPendingClients = null;\n          for (var i = 0; i < clients.length; i++) {\n            var client = clients[i];\n            if (!client.__dataEnabled) {\n              client._enableProperties();\n            } else if (client.__dataPending) {\n              client._flushProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Perform any initial setup on client dom. Called before the first\n       * `_flushProperties` call on client dom and before any element\n       * observers are called.\n       *\n       * @override\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_readyClients\",\n      value: function _readyClients() {\n        this.__enableOrFlushClients();\n      }\n\n      /**\n       * Sets a bag of property changes to this instance, and\n       * synchronously processes all effects of the properties as a batch.\n       *\n       * Property names must be simple properties, not paths.  Batched\n       * path propagation is not supported.\n       *\n       * @override\n       * @param {Object} props Bag of one or more key-value pairs whose key is\n       *   a property and value is the new value to set for that property.\n       * @param {boolean=} setReadOnly When true, any private values set in\n       *   `props` will be set. By default, `setProperties` will not set\n       *   `readOnly: true` root properties.\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"setProperties\",\n      value: function setProperties(props, setReadOnly) {\n        for (var path in props) {\n          if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n            //TODO(kschaaf): explicitly disallow paths in setProperty?\n            // wildcard observers currently only pass the first changed path\n            // in the `info` object, and you could do some odd things batching\n            // paths, e.g. {'foo.bar': {...}, 'foo': null}\n            this._setPendingPropertyOrPath(path, props[path], true);\n          }\n        }\n        this._invalidateProperties();\n      }\n\n      /**\n       * Overrides `PropertyAccessors` so that property accessor\n       * side effects are not enabled until after client dom is fully ready.\n       * Also calls `_flushClients` callback to ensure client dom is enabled\n       * that was not enabled as a result of flushing properties.\n       *\n       * @override\n       * @return {void}\n       */\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        // It is important that `super.ready()` is not called here as it\n        // immediately turns on accessors. Instead, we wait until `readyClients`\n        // to enable accessors to provide a guarantee that clients are ready\n        // before processing any accessors side effects.\n        this._flushProperties();\n        // If no data was pending, `_flushProperties` will not `flushClients`\n        // so ensure this is done.\n        if (!this.__dataClientsReady) {\n          this._flushClients();\n        }\n        // Before ready, client notifications do not trigger _flushProperties.\n        // Therefore a flush is necessary here if data has been set.\n        if (this.__dataPending) {\n          this._flushProperties();\n        }\n      }\n\n      /**\n       * Implements `PropertyAccessors`'s properties changed callback.\n       *\n       * Runs each class of effects for the batch of changed properties in\n       * a specific order (compute, propagate, reflect, observe, notify).\n       *\n       * @override\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       */\n    }, {\n      key: \"_propertiesChanged\",\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {\n        // ----------------------------\n        // let c = Object.getOwnPropertyNames(changedProps || {});\n        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n        // if (window.debug) { debugger; }\n        // ----------------------------\n        var hasPaths = this.__dataHasPaths;\n        this.__dataHasPaths = false;\n        var notifyProps;\n        // Compute properties\n        runComputedEffects(this, changedProps, oldProps, hasPaths);\n        // Clear notify properties prior to possible reentry (propagate, observe),\n        // but after computing effects have a chance to add to them\n        notifyProps = this.__dataToNotify;\n        this.__dataToNotify = null;\n        // Propagate properties to clients\n        this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n        // Flush clients\n        this._flushClients();\n        // Reflect properties\n        runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n        // Observe properties\n        runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n        // Notify properties to host\n        if (notifyProps) {\n          runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n        }\n        // Clear temporary cache at end of turn\n        if (this.__dataCounter == 1) {\n          this.__dataTemp = {};\n        }\n        // ----------------------------\n        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n        // ----------------------------\n      }\n\n      /**\n       * Called to propagate any property changes to stamped template nodes\n       * managed by this element.\n       *\n       * @override\n       * @param {Object} changedProps Bag of changed properties\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_propagatePropertyChanges\",\n      value: function _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n        if (this[TYPES.PROPAGATE]) {\n          runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n        }\n        if (this.__templateInfo) {\n          this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n        }\n      }\n    }, {\n      key: \"_runEffectsForTemplate\",\n      value: function _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n        var _this2 = this;\n        var baseRunEffects = function baseRunEffects(changedProps, hasPaths) {\n          runEffects(_this2, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);\n          for (var info = templateInfo.firstChild; info; info = info.nextSibling) {\n            _this2._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n          }\n        };\n        if (templateInfo.runEffects) {\n          templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n        } else {\n          baseRunEffects(changedProps, hasPaths);\n        }\n      }\n\n      /**\n       * Aliases one data path as another, such that path notifications from one\n       * are routed to the other.\n       *\n       * @override\n       * @param {string | !Array<string|number>} to Target path to link.\n       * @param {string | !Array<string|number>} from Source path to link.\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"linkPaths\",\n      value: function linkPaths(to, from) {\n        to = normalize(to);\n        from = normalize(from);\n        this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n        this.__dataLinkedPaths[to] = from;\n      }\n\n      /**\n       * Removes a data path alias previously established with `_linkPaths`.\n       *\n       * Note, the path to unlink should be the target (`to`) used when\n       * linking the paths.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Target path to unlink.\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"unlinkPaths\",\n      value: function unlinkPaths(path) {\n        path = normalize(path);\n        if (this.__dataLinkedPaths) {\n          delete this.__dataLinkedPaths[path];\n        }\n      }\n\n      /**\n       * Notify that an array has changed.\n       *\n       * Example:\n       *\n       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n       *     ...\n       *     this.items.splice(1, 1, {name: 'Sam'});\n       *     this.items.push({name: 'Bob'});\n       *     this.notifySplices('items', [\n       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n       *         object: this.items, type: 'splice' },\n       *       { index: 3, removed: [], addedCount: 1,\n       *         object: this.items, type: 'splice'}\n       *     ]);\n       *\n       * @param {string} path Path that should be notified.\n       * @param {Array} splices Array of splice records indicating ordered\n       *   changes that occurred to the array. Each record should have the\n       *   following fields:\n       *    * index: index at which the change occurred\n       *    * removed: array of items that were removed from this index\n       *    * addedCount: number of new items added at this index\n       *    * object: a reference to the array in question\n       *    * type: the string literal 'splice'\n       *\n       *   Note that splice records _must_ be normalized such that they are\n       *   reported in index order (raw results from `Object.observe` are not\n       *   ordered and must be normalized/merged before notifying).\n       *\n       * @override\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"notifySplices\",\n      value: function notifySplices(path, splices) {\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array} */_get2(this, path, info);\n        _notifySplices(this, array, info.path, splices);\n      }\n\n      /**\n       * Convenience method for reading a value from a path.\n       *\n       * Note, if any part in the path is undefined, this method returns\n       * `undefined` (this method does not throw when dereferencing undefined\n       * paths).\n       *\n       * @override\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n       * @param {Object=} root Root object from which the path is evaluated.\n       * @return {*} Value at the path, or `undefined` if any part of the path\n       *   is undefined.\n       * @public\n       */\n    }, {\n      key: \"get\",\n      value: function get(path, root) {\n        return _get2(root || this, path);\n      }\n\n      /**\n       * Convenience method for setting a value to a path and notifying any\n       * elements bound to the same path.\n       *\n       * Note, if any part in the path except for the last is undefined,\n       * this method does nothing (this method does not throw when\n       * dereferencing undefined paths).\n       *\n       * @override\n       * @param {(string|!Array<(string|number)>)} path Path to the value\n       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n       *   bracketed expressions are not supported; string-based path parts\n       *   *must* be separated by dots.  Note that when dereferencing array\n       *   indices, the index may be used as a dotted part directly\n       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n       * @param {*} value Value to set at the specified path.\n       * @param {Object=} root Root object from which the path is evaluated.\n       *   When specified, no notification will occur.\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"set\",\n      value: function set(path, value, root) {\n        if (root) {\n          _set(root, path, value);\n        } else {\n          if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][( /** @type {string} */path)]) {\n            if (this._setPendingPropertyOrPath(path, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n        }\n      }\n\n      /**\n       * Adds items onto the end of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to push onto array\n       * @return {number} New length of the array.\n       * @public\n       */\n    }, {\n      key: \"push\",\n      value: function push(path) {\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array}*/_get2(this, path, info);\n        var len = array.length;\n        for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          items[_key - 1] = arguments[_key];\n        }\n        var ret = array.push.apply(array, items);\n        if (items.length) {\n          notifySplice(this, array, info.path, len, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the end of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n    }, {\n      key: \"pop\",\n      value: function pop(path) {\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array} */_get2(this, path, info);\n        var hadLength = Boolean(array.length);\n        var ret = array.pop();\n        if (hadLength) {\n          notifySplice(this, array, info.path, array.length, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Starting from the start index specified, removes 0 or more items\n       * from the array and inserts 0 or more new items in their place.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.splice`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {number} start Index from which to start removing/inserting.\n       * @param {number=} deleteCount Number of items to remove.\n       * @param {...*} items Items to insert into array.\n       * @return {!Array} Array of removed items.\n       * @public\n       */\n    }, {\n      key: \"splice\",\n      value: function splice(path, start, deleteCount) {\n        for (var _len2 = arguments.length, items = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n          items[_key2 - 3] = arguments[_key2];\n        }\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array} */_get2(this, path, info);\n        // Normalize fancy native splice handling of crazy start values\n        if (start < 0) {\n          start = array.length - Math.floor(-start);\n        } else if (start) {\n          start = Math.floor(start);\n        }\n        // array.splice does different things based on the number of arguments\n        // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n        // do different things. In the former, the whole array is cleared. In the\n        // latter, no items are removed.\n        // This means that we need to detect whether 1. one of the arguments\n        // is actually passed in and then 2. determine how many arguments\n        // we should pass on to the native array.splice\n        //\n        var ret;\n        // Omit any additional arguments if they were not passed in\n        if (arguments.length === 2) {\n          ret = array.splice(start);\n          // Either start was undefined and the others were defined, but in this\n          // case we can safely pass on all arguments\n          //\n          // Note: this includes the case where none of the arguments were passed in,\n          // e.g. this.splice('array'). However, if both start and deleteCount\n          // are undefined, array.splice will not modify the array (as expected)\n        } else {\n          ret = array.splice.apply(array, [start, deleteCount].concat(items));\n        }\n        // At the end, check whether any items were passed in (e.g. insertions)\n        // or if the return array contains items (e.g. deletions).\n        // Only notify if items were added or deleted.\n        if (items.length || ret.length) {\n          notifySplice(this, array, info.path, start, items.length, ret);\n        }\n        return ret;\n      }\n\n      /**\n       * Removes an item from the beginning of array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.pop`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Path to array.\n       * @return {*} Item that was removed.\n       * @public\n       */\n    }, {\n      key: \"shift\",\n      value: function shift(path) {\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array} */_get2(this, path, info);\n        var hadLength = Boolean(array.length);\n        var ret = array.shift();\n        if (hadLength) {\n          notifySplice(this, array, info.path, 0, 0, [ret]);\n        }\n        return ret;\n      }\n\n      /**\n       * Adds items onto the beginning of the array at the path specified.\n       *\n       * The arguments after `path` and return value match that of\n       * `Array.prototype.push`.\n       *\n       * This method notifies other paths to the same array that a\n       * splice occurred to the array.\n       *\n       * @override\n       * @param {string | !Array<string|number>} path Path to array.\n       * @param {...*} items Items to insert info array\n       * @return {number} New length of the array.\n       * @public\n       */\n    }, {\n      key: \"unshift\",\n      value: function unshift(path) {\n        var info = {\n          path: ''\n        };\n        var array = /** @type {Array} */_get2(this, path, info);\n        for (var _len3 = arguments.length, items = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          items[_key3 - 1] = arguments[_key3];\n        }\n        var ret = array.unshift.apply(array, items);\n        if (items.length) {\n          notifySplice(this, array, info.path, 0, items.length, []);\n        }\n        return ret;\n      }\n\n      /**\n       * Notify that a path has changed.\n       *\n       * Example:\n       *\n       *     this.item.user.name = 'Bob';\n       *     this.notifyPath('item.user.name');\n       *\n       * @override\n       * @param {string} path Path that should be notified.\n       * @param {*=} value Value at the path (optional).\n       * @return {void}\n       * @public\n       */\n    }, {\n      key: \"notifyPath\",\n      value: function notifyPath(path, value) {\n        /** @type {string} */\n        var propPath;\n        if (arguments.length == 1) {\n          // Get value if not supplied\n          var info = {\n            path: ''\n          };\n          value = _get2(this, path, info);\n          propPath = info.path;\n        } else if (Array.isArray(path)) {\n          // Normalize path if needed\n          propPath = normalize(path);\n        } else {\n          propPath = /** @type{string} */path;\n        }\n        if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Equivalent to static `createReadOnlyProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_createReadOnlyProperty\",\n      value: function _createReadOnlyProperty(property, protectedSetter) {\n        this._addPropertyEffect(property, TYPES.READ_ONLY);\n        if (protectedSetter) {\n          this['_set' + upper(property)] = /** @this {PropertyEffects} */function (value) {\n            this._setProperty(property, value);\n          };\n        }\n      }\n\n      /**\n       * Equivalent to static `createPropertyObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method\n       *     to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_createPropertyObserver\",\n      value: function _createPropertyObserver(property, method, dynamicFn) {\n        var info = {\n          property: property,\n          method: method,\n          dynamicFn: Boolean(dynamicFn)\n        };\n        this._addPropertyEffect(property, TYPES.OBSERVE, {\n          fn: runObserverEffect,\n          info: info,\n          trigger: {\n            name: property\n          }\n        });\n        if (dynamicFn) {\n          this._addPropertyEffect( /** @type {string} */method, TYPES.OBSERVE, {\n            fn: runObserverEffect,\n            info: info,\n            trigger: {\n              name: method\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createMethodObserver` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_createMethodObserver\",\n      value: function _createMethodObserver(expression, dynamicFn) {\n        var sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n        }\n        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n      }\n\n      /**\n       * Equivalent to static `createNotifyingProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_createNotifyingProperty\",\n      value: function _createNotifyingProperty(property) {\n        this._addPropertyEffect(property, TYPES.NOTIFY, {\n          fn: runNotifyEffect,\n          info: {\n            eventName: camelToDashCase(property) + '-changed',\n            property: property\n          }\n        });\n      }\n\n      /**\n       * Equivalent to static `createReflectedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       * @suppress {missingProperties} go/missingfnprops\n       */\n    }, {\n      key: \"_createReflectedProperty\",\n      value: function _createReflectedProperty(property) {\n        var attr = this.constructor.attributeNameForProperty(property);\n        if (attr[0] === '-') {\n          console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n        } else {\n          this._addPropertyEffect(property, TYPES.REFLECT, {\n            fn: runReflectEffect,\n            info: {\n              attrName: attr\n            }\n          });\n        }\n      }\n\n      /**\n       * Equivalent to static `createComputedProperty` API but can be called on\n       * an instance to add effects at runtime.  See that method for\n       * full API docs.\n       *\n       * @override\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       *   whether method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_createComputedProperty\",\n      value: function _createComputedProperty(property, expression, dynamicFn) {\n        var sig = parseMethod(expression);\n        if (!sig) {\n          throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n        }\n        var info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n        // Effects are normally stored as map of dependency->effect, but for\n        // ordered computation, we also need tree of computedProp->dependencies\n        ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n      }\n\n      /**\n       * Gather the argument values for a method specified in the provided array\n       * of argument metadata.\n       *\n       * The `path` and `value` arguments are used to fill in wildcard descriptor\n       * when the method is being called as a result of a path notification.\n       *\n       * @param {!Array<!MethodArg>} args Array of argument metadata\n       * @param {string} path Property/path name that triggered the method effect\n       * @param {Object} props Bag of current property changes\n       * @return {!Array<*>} Array of argument values\n       * @private\n       */\n    }, {\n      key: \"_marshalArgs\",\n      value: function _marshalArgs(args, path, props) {\n        var data = this.__data;\n        var values = [];\n        for (var i = 0, l = args.length; i < l; i++) {\n          var _args$i = args[i],\n            name = _args$i.name,\n            structured = _args$i.structured,\n            wildcard = _args$i.wildcard,\n            value = _args$i.value,\n            literal = _args$i.literal;\n          if (!literal) {\n            if (wildcard) {\n              var matches = isDescendant(name, path);\n              var pathValue = getArgValue(data, props, matches ? path : name);\n              value = {\n                path: matches ? path : name,\n                value: pathValue,\n                base: matches ? _get2(data, name) : pathValue\n              };\n            } else {\n              value = structured ? getArgValue(data, props, name) : data[name];\n            }\n          }\n          // When the `legacyUndefined` flag is enabled, pass a no-op value\n          // so that the observer, computed property, or compound binding is aborted.\n          if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n            return NOOP;\n          }\n          values[i] = value;\n        }\n        return values;\n      }\n\n      // -- static class methods ------------\n\n      /**\n       * Ensures an accessor exists for the specified property, and adds\n       * to a list of \"property effects\" that will run when the accessor for\n       * the specified property is set.  Effects are grouped by \"type\", which\n       * roughly corresponds to a phase in effect processing.  The effect\n       * metadata should be in the following form:\n       *\n       *     {\n       *       fn: effectFunction, // Reference to function to call to perform effect\n       *       info: { ... }       // Effect metadata passed to function\n       *       trigger: {          // Optional triggering metadata; if not provided\n       *         name: string      // the property is treated as a wildcard\n       *         structured: boolean\n       *         wildcard: boolean\n       *       }\n       *     }\n       *\n       * Effects are called from `_propertiesChanged` in the following order by\n       * type:\n       *\n       * 1. COMPUTE\n       * 2. PROPAGATE\n       * 3. REFLECT\n       * 4. OBSERVE\n       * 5. NOTIFY\n       *\n       * Effect functions are called with the following signature:\n       *\n       *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n       *\n       * @param {string} property Property that should trigger the effect\n       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"_bindTemplate\",\n      value:\n      // -- binding ----------------------------------------------\n\n      /*\n       * Overview of binding flow:\n       *\n       * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n       *  `_bindTemplate(t, false)` called directly during finalization - parses\n       *  the template (for the first time), and then assigns that _prototypical_\n       *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n       *  this case `wasPreBound` is false; this is the first time we're binding\n       *  it, thus we create accessors.\n       *\n       * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n       *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n       *   returned matches the prebound one, and so this is `wasPreBound == true`\n       *   state; thus we _skip_ creating accessors, but _do_ create an instance\n       *   of the template info to serve as the start of our linked list (needs to\n       *   be an instance, not the prototypical one, so that we can add `nodeList`\n       *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n       *   bindings, and so we can chain runtime-stamped template infos off of\n       *   it). At this point, the call to `_stampTemplate` calls\n       *   `applyTemplateInfo` for each nested `<template>` found during parsing\n       *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n       *   `templateInfo` to the `<template>` so that we have the instance-time\n       *   parent to link the `templateInfo` under in the case it was\n       *   runtime-stamped.\n       *\n       * During subsequent runtime stamping (`instanceBinding==true`,\n       *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n       *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n       *   because it was either a different template altogether, or even if it\n       *   was the same template, the step above created a instance of the info;\n       *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n       *   link a instance into the linked list.\n       */\n\n      /**\n       * Equivalent to static `bindTemplate` API but can be called on an instance\n       * to add effects at runtime.  See that method for full API docs.\n       *\n       * This method may be called on the prototype (for prototypical template\n       * binding, to avoid creating accessors every instance) once per prototype,\n       * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n       * create and link an instance of the template metadata associated with a\n       * particular stamping.\n       *\n       * @override\n       * @param {!HTMLTemplateElement} template Template containing binding\n       * bindings\n       * @param {boolean=} instanceBinding When false (default), performs\n       * \"prototypical\" binding of the template and overwrites any previously\n       * bound template for the class. When true (as passed from\n       * `_stampTemplate`), the template info is instanced and linked into the\n       * list of bound templates.\n       * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n       * this is an instance of the prototypical template info\n       * @protected\n       * @suppress {missingProperties} go/missingfnprops\n       */\n      function _bindTemplate(template, instanceBinding) {\n        var templateInfo = this.constructor._parseTemplate(template);\n        var wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n        // Optimization: since this is called twice for proto-bound templates,\n        // don't attempt to recreate accessors if this template was pre-bound\n        if (!wasPreBound) {\n          for (var prop in templateInfo.propertyEffects) {\n            this._createPropertyAccessor(prop);\n          }\n        }\n        if (instanceBinding) {\n          // For instance-time binding, create instance of template metadata\n          // and link into tree of templates if necessary\n          templateInfo = /** @type {!TemplateInfo} */Object.create(templateInfo);\n          templateInfo.wasPreBound = wasPreBound;\n          if (!this.__templateInfo) {\n            // Set the info to the root of the tree\n            this.__templateInfo = templateInfo;\n          } else {\n            // Append this template info onto the end of its parent template's\n            // list, which will determine the tree structure via which property\n            // effects are run; if this template was not nested in another\n            // template, use the root template (the first stamped one) as the\n            // parent. Note, `parent` is the `templateInfo` instance for this\n            // template's parent (containing) template, which was set up in\n            // `applyTemplateInfo`.  While a given template's `parent` is set\n            // apriori, it is only added to the parent's child list at the point\n            // that it is being bound, since a template may or may not ever be\n            // stamped, and may be stamped more than once (in which case instances\n            // of the template info will be in the tree under its parent more than\n            // once).\n            var parent = template._parentTemplateInfo || this.__templateInfo;\n            var previous = parent.lastChild;\n            templateInfo.parent = parent;\n            parent.lastChild = templateInfo;\n            templateInfo.previousSibling = previous;\n            if (previous) {\n              previous.nextSibling = templateInfo;\n            } else {\n              parent.firstChild = templateInfo;\n            }\n          }\n        } else {\n          this.__preBoundTemplateInfo = templateInfo;\n        }\n        return templateInfo;\n      }\n\n      /**\n       * Adds a property effect to the given template metadata, which is run\n       * at the \"propagate\" stage of `_propertiesChanged` when the template\n       * has been bound to the element via `_bindTemplate`.\n       *\n       * The `effect` object should match the format in `_addPropertyEffect`.\n       *\n       * @param {Object} templateInfo Template metadata to add effect to\n       * @param {string} prop Property that should trigger the effect\n       * @param {Object=} effect Effect metadata object\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"_stampTemplate\",\n      value:\n      /**\n       * Stamps the provided template and performs instance-time setup for\n       * Polymer template features, including data bindings, declarative event\n       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n       * is returned containing the stamped DOM, ready for insertion into the\n       * DOM.\n       *\n       * This method may be called more than once; however note that due to\n       * `shadycss` polyfill limitations, only styles from templates prepared\n       * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n       * to the shadow root and support CSS custom properties), and note that\n       * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n       * any styles required by in runtime-stamped templates must be included\n       * in the main element template.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @param {TemplateInfo=} templateInfo Optional bound template info associated\n       *   with the template to be stamped; if omitted the template will be\n       *   automatically bound.\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       * @protected\n       */\n      function _stampTemplate(template, templateInfo) {\n        templateInfo = templateInfo || ( /** @type {!TemplateInfo} */this._bindTemplate(template, true));\n        // Ensures that created dom is `_enqueueClient`'d to this element so\n        // that it can be flushed on next call to `_flushProperties`\n        hostStack.push(this);\n        var dom = _get(_getPrototypeOf(PropertyEffects.prototype), \"_stampTemplate\", this).call(this, template, templateInfo);\n        hostStack.pop();\n        // Add template-instance-specific data to instanced templateInfo\n        templateInfo.nodeList = dom.nodeList;\n        // Capture child nodes to allow unstamping of non-prototypical templates\n        if (!templateInfo.wasPreBound) {\n          var nodes = templateInfo.childNodes = [];\n          for (var n = dom.firstChild; n; n = n.nextSibling) {\n            nodes.push(n);\n          }\n        }\n        dom.templateInfo = templateInfo;\n        // Setup compound storage, 2-way listeners, and dataHost for bindings\n        setupBindings(this, templateInfo);\n        // Flush properties into template nodes; the check on `__dataClientsReady`\n        // ensures we don't needlessly run effects for an element's initial\n        // prototypical template stamping since they will happen as a part of the\n        // first call to `_propertiesChanged`. This flag is set to true\n        // after running the initial propagate effects, and immediately before\n        // flushing clients. Since downstream clients could cause stamping on\n        // this host (e.g. a fastDomIf `dom-if` being forced to render\n        // synchronously), this flag ensures effects for runtime-stamped templates\n        // are run at this point during the initial element boot-up.\n        if (this.__dataClientsReady) {\n          this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n          this._flushClients();\n        }\n        return dom;\n      }\n\n      /**\n       * Removes and unbinds the nodes previously contained in the provided\n       * DocumentFragment returned from `_stampTemplate`.\n       *\n       * @override\n       * @param {!StampedTemplate} dom DocumentFragment previously returned\n       *   from `_stampTemplate` associated with the nodes to be removed\n       * @return {void}\n       * @protected\n       */\n    }, {\n      key: \"_removeBoundDom\",\n      value: function _removeBoundDom(dom) {\n        // Unlink template info; Note that while the child is unlinked from its\n        // parent list, a template's `parent` reference is never removed, since\n        // this is is determined by the tree structure and applied at\n        // `applyTemplateInfo` time.\n        var templateInfo = dom.templateInfo;\n        var previousSibling = templateInfo.previousSibling,\n          nextSibling = templateInfo.nextSibling,\n          parent = templateInfo.parent;\n        if (previousSibling) {\n          previousSibling.nextSibling = nextSibling;\n        } else if (parent) {\n          parent.firstChild = nextSibling;\n        }\n        if (nextSibling) {\n          nextSibling.previousSibling = previousSibling;\n        } else if (parent) {\n          parent.lastChild = previousSibling;\n        }\n        templateInfo.nextSibling = templateInfo.previousSibling = null;\n        // Remove stamped nodes\n        var nodes = templateInfo.childNodes;\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          wrap(wrap(node).parentNode).removeChild(node);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       * @nocollapse\n       */\n    }], [{\n      key: \"addPropertyEffect\",\n      value: function addPropertyEffect(property, type, effect) {\n        this.prototype._addPropertyEffect(property, type, effect);\n      }\n\n      /**\n       * Creates a single-property observer for the given property.\n       *\n       * @param {string} property Property name\n       * @param {string|function(*,*)} method Function or name of observer method to call\n       * @param {boolean=} dynamicFn Whether the method name should be included as\n       *   a dependency to the effect.\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createPropertyObserver\",\n      value: function createPropertyObserver(property, method, dynamicFn) {\n        this.prototype._createPropertyObserver(property, method, dynamicFn);\n      }\n\n      /**\n       * Creates a multi-property \"method observer\" based on the provided\n       * expression, which should be a string in the form of a normal JavaScript\n       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n       * should correspond to a property or path in the context of this\n       * prototype (or instance), or may be a literal string or number.\n       *\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n       * @return {void}\n       *   whether method names should be included as a dependency to the effect.\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createMethodObserver\",\n      value: function createMethodObserver(expression, dynamicFn) {\n        this.prototype._createMethodObserver(expression, dynamicFn);\n      }\n\n      /**\n       * Causes the setter for the given property to dispatch `<property>-changed`\n       * events to notify of changes to the property.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createNotifyingProperty\",\n      value: function createNotifyingProperty(property) {\n        this.prototype._createNotifyingProperty(property);\n      }\n\n      /**\n       * Creates a read-only accessor for the given property.\n       *\n       * To set the property, use the protected `_setProperty` API.\n       * To create a custom protected setter (e.g. `_setMyProp()` for\n       * property `myProp`), pass `true` for `protectedSetter`.\n       *\n       * Note, if the property will have other property effects, this method\n       * should be called first, before adding other effects.\n       *\n       * @param {string} property Property name\n       * @param {boolean=} protectedSetter Creates a custom protected setter\n       *   when `true`.\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createReadOnlyProperty\",\n      value: function createReadOnlyProperty(property, protectedSetter) {\n        this.prototype._createReadOnlyProperty(property, protectedSetter);\n      }\n\n      /**\n       * Causes the setter for the given property to reflect the property value\n       * to a (dash-cased) attribute of the same name.\n       *\n       * @param {string} property Property name\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createReflectedProperty\",\n      value: function createReflectedProperty(property) {\n        this.prototype._createReflectedProperty(property);\n      }\n\n      /**\n       * Creates a computed property whose value is set to the result of the\n       * method described by the given `expression` each time one or more\n       * arguments to the method changes.  The expression should be a string\n       * in the form of a normal JavaScript function signature:\n       * `'methodName(arg1, [..., argn])'`\n       *\n       * @param {string} property Name of computed property to set\n       * @param {string} expression Method expression\n       * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n       *   method names should be included as a dependency to the effect.\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"createComputedProperty\",\n      value: function createComputedProperty(property, expression, dynamicFn) {\n        this.prototype._createComputedProperty(property, expression, dynamicFn);\n      }\n\n      /**\n       * Parses the provided template to ensure binding effects are created\n       * for them, and then ensures property accessors are created for any\n       * dependent properties in the template.  Binding effects for bound\n       * templates are stored in a linked list on the instance so that\n       * templates can be efficiently stamped and unstamped.\n       *\n       * @param {!HTMLTemplateElement} template Template containing binding\n       *   bindings\n       * @return {!TemplateInfo} Template metadata object\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"bindTemplate\",\n      value: function bindTemplate(template) {\n        return this.prototype._bindTemplate(template);\n      }\n    }, {\n      key: \"_addTemplatePropertyEffect\",\n      value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {\n        var hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n        hostProps[prop] = true;\n        var effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n        var propEffects = effects[prop] = effects[prop] || [];\n        propEffects.push(effect);\n      }\n    }, {\n      key: \"_parseTemplateNode\",\n      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        var noted = propertyEffectsBase._parseTemplateNode.call(this, node, templateInfo, nodeInfo);\n        if (node.nodeType === Node.TEXT_NODE) {\n          var parts = this._parseBindings(node.textContent, templateInfo);\n          if (parts) {\n            // Initialize the textContent with any literal parts\n            // NOTE: default to a space here so the textNode remains; some browsers\n            // (IE) omit an empty textNode following cloneNode/importNode.\n            node.textContent = literalFromParts(parts) || ' ';\n            addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n            noted = true;\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * parsing bindings from attributes.  A `bindings`\n       * array is added to `nodeInfo` and populated with binding metadata\n       * with information capturing the binding target, and a `parts` array\n       * with one or more metadata objects capturing the source(s) of the\n       * binding.\n       *\n       * @param {Element} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNodeAttribute\",\n      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        var parts = this._parseBindings(value, templateInfo);\n        if (parts) {\n          // Attribute or property\n          var origName = name;\n          var kind = 'property';\n          // The only way we see a capital letter here is if the attr has\n          // a capital letter in it per spec. In this case, to make sure\n          // this binding works, we go ahead and make the binding to the attribute.\n          if (capitalAttributeRegex.test(name)) {\n            kind = 'attribute';\n          } else if (name[name.length - 1] == '$') {\n            name = name.slice(0, -1);\n            kind = 'attribute';\n          }\n          // Initialize attribute bindings with any literal parts\n          var literal = literalFromParts(parts);\n          if (literal && kind == 'attribute') {\n            // Ensure a ShadyCSS template scoped style is not removed\n            // when a class$ binding's initial literal value is set.\n            if (name == 'class' && node.hasAttribute('class')) {\n              literal += ' ' + node.getAttribute(name);\n            }\n            node.setAttribute(name, literal);\n          }\n          // support disable-upgrade\n          if (kind == 'attribute' && origName == 'disable-upgrade$') {\n            node.setAttribute(name, '');\n          }\n          // Clear attribute before removing, since IE won't allow removing\n          // `value` attribute if it previously had a value (can't\n          // unconditionally set '' before removing since attributes with `$`\n          // can't be set using setAttribute)\n          if (node.localName === 'input' && origName === 'value') {\n            node.setAttribute(origName, '');\n          }\n          // Remove annotation\n          node.removeAttribute(origName);\n          // Case hackery: attributes are lower-case, but bind targets\n          // (properties) are case sensitive. Gambit is to map dash-case to\n          // camel-case: `foo-bar` becomes `fooBar`.\n          // Attribute bindings are excepted.\n          if (kind === 'property') {\n            name = dashToCamelCase(name);\n          }\n          addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n          return true;\n        } else {\n          // TODO(https://github.com/google/closure-compiler/issues/3240):\n          //     Change back to just super.methodCall()\n          return propertyEffectsBase._parseTemplateNodeAttribute.call(this, node, templateInfo, nodeInfo, name, value);\n        }\n      }\n\n      /**\n       * Overrides default `TemplateStamp` implementation to add support for\n       * binding the properties that a nested template depends on to the template\n       * as `_host_<property>`.\n       *\n       * @param {Node} node Node to parse\n       * @param {TemplateInfo} templateInfo Template metadata for current template\n       * @param {NodeInfo} nodeInfo Node metadata for current template node\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @protected\n       * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNestedTemplate\",\n      value: function _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        var noted = propertyEffectsBase._parseTemplateNestedTemplate.call(this, node, templateInfo, nodeInfo);\n        var parent = node.parentNode;\n        var nestedTemplateInfo = nodeInfo.templateInfo;\n        var isDomIf = parent.localName === 'dom-if';\n        var isDomRepeat = parent.localName === 'dom-repeat';\n        // Remove nested template and redirect its host bindings & templateInfo\n        // onto the parent (dom-if/repeat element)'s nodeInfo\n        if (removeNestedTemplates && (isDomIf || isDomRepeat)) {\n          parent.removeChild(node);\n          // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n          // templateInfo, and use that for any host property bindings below\n          nodeInfo = nodeInfo.parentInfo;\n          nodeInfo.templateInfo = nestedTemplateInfo;\n          // Ensure the parent dom-if/repeat is noted since it now may have host\n          // bindings; it may not have been if it did not have its own bindings\n          nodeInfo.noted = true;\n          noted = false;\n        }\n        // Merge host props into outer template and add bindings\n        var hostProps = nestedTemplateInfo.hostProps;\n        if (fastDomIf && isDomIf) {\n          // `fastDomIf` mode uses runtime-template stamping to add accessors/\n          // effects to properties used in its template; as such we don't need to\n          // tax the host element with `_host_` bindings for the `dom-if`.\n          // However, in the event it is nested in a `dom-repeat`, it is still\n          // important that its host properties are added to the\n          // TemplateInstance's `hostProps` so that they are forwarded to the\n          // TemplateInstance.\n          if (hostProps) {\n            templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps);\n            // Ensure the dom-if is noted so that it has a __dataHost, since\n            // `fastDomIf` uses the host for runtime template stamping; note this\n            // was already ensured above in the `removeNestedTemplates` case\n            if (!removeNestedTemplates) {\n              nodeInfo.parentInfo.noted = true;\n            }\n          }\n        } else {\n          var mode = '{';\n          for (var source in hostProps) {\n            var parts = [{\n              mode: mode,\n              source: source,\n              dependencies: [source],\n              hostProp: true\n            }];\n            addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n          }\n        }\n        return noted;\n      }\n\n      /**\n       * Called to parse text in a template (either attribute values or\n       * textContent) into binding metadata.\n       *\n       * Any overrides of this method should return an array of binding part\n       * metadata  representing one or more bindings found in the provided text\n       * and any \"literal\" text in between.  Any non-literal parts will be passed\n       * to `_evaluateBinding` when any dependencies change.  The only required\n       * fields of each \"part\" in the returned array are as follows:\n       *\n       * - `dependencies` - Array containing trigger metadata for each property\n       *   that should trigger the binding to update\n       * - `literal` - String containing text if the part represents a literal;\n       *   in this case no `dependencies` are needed\n       *\n       * Additional metadata for use by `_evaluateBinding` may be provided in\n       * each part object as needed.\n       *\n       * The default implementation handles the following types of bindings\n       * (one or more may be intermixed with literal strings):\n       * - Property binding: `[[prop]]`\n       * - Path binding: `[[object.prop]]`\n       * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n       * - Two-way property or path bindings (supports negation):\n       *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n       * - Inline computed method (supports negation):\n       *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n       *\n       * The default implementation uses a regular expression for best\n       * performance. However, the regular expression uses a white-list of\n       * allowed characters in a data-binding, which causes problems for\n       * data-bindings that do use characters not in this white-list.\n       *\n       * Instead of updating the white-list with all allowed characters,\n       * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n       * that uses a state machine instead. This state machine is able to handle\n       * all characters. However, it is slightly less performant, therefore we\n       * extracted it into a separate optional mixin.\n       *\n       * @param {string} text Text to parse from attribute or textContent\n       * @param {Object} templateInfo Current template metadata\n       * @return {Array<!BindingPart>} Array of binding part metadata\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseBindings\",\n      value: function _parseBindings(text, templateInfo) {\n        var parts = [];\n        var lastIndex = 0;\n        var m;\n        // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n        // Regex matches:\n        //        Iteration 1:  Iteration 2:\n        // m[1]: '{{'          '[['\n        // m[2]: ''            '!'\n        // m[3]: 'prop'        'compute(foo,bar)'\n        while ((m = bindingRegex.exec(text)) !== null) {\n          // Add literal part\n          if (m.index > lastIndex) {\n            parts.push({\n              literal: text.slice(lastIndex, m.index)\n            });\n          }\n          // Add binding part\n          var mode = m[1][0];\n          var negate = Boolean(m[2]);\n          var source = m[3].trim();\n          var customEvent = false,\n            notifyEvent = '',\n            colon = -1;\n          if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n            notifyEvent = source.substring(colon + 2);\n            source = source.substring(0, colon);\n            customEvent = true;\n          }\n          var signature = parseMethod(source);\n          var dependencies = [];\n          if (signature) {\n            // Inline computed function\n            var args = signature.args,\n              methodName = signature.methodName;\n            for (var i = 0; i < args.length; i++) {\n              var arg = args[i];\n              if (!arg.literal) {\n                dependencies.push(arg);\n              }\n            }\n            var dynamicFns = templateInfo.dynamicFns;\n            if (dynamicFns && dynamicFns[methodName] || signature.static) {\n              dependencies.push(methodName);\n              signature.dynamicFn = true;\n            }\n          } else {\n            // Property or path\n            dependencies.push(source);\n          }\n          parts.push({\n            source: source,\n            mode: mode,\n            negate: negate,\n            customEvent: customEvent,\n            signature: signature,\n            dependencies: dependencies,\n            event: notifyEvent\n          });\n          lastIndex = bindingRegex.lastIndex;\n        }\n        // Add a final literal part\n        if (lastIndex && lastIndex < text.length) {\n          var literal = text.substring(lastIndex);\n          if (literal) {\n            parts.push({\n              literal: literal\n            });\n          }\n        }\n        if (parts.length) {\n          return parts;\n        } else {\n          return null;\n        }\n      }\n\n      /**\n       * Called to evaluate a previously parsed binding part based on a set of\n       * one or more changed dependencies.\n       *\n       * @param {!Polymer_PropertyEffects} inst Element that should be used as\n       *     scope for binding dependencies\n       * @param {BindingPart} part Binding part metadata\n       * @param {string} path Property/path that triggered this effect\n       * @param {Object} props Bag of current property changes\n       * @param {Object} oldProps Bag of previous values for changed properties\n       * @param {boolean} hasPaths True with `props` contains one or more paths\n       * @return {*} Value the binding part evaluated to\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"_evaluateBinding\",\n      value: function _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n        var value;\n        if (part.signature) {\n          value = runMethodEffect(inst, path, props, oldProps, part.signature);\n        } else if (path != part.source) {\n          value = _get2(inst, part.source);\n        } else {\n          if (hasPaths && isPath(path)) {\n            value = _get2(inst, path);\n          } else {\n            value = inst.__data[path];\n          }\n        }\n        if (part.negate) {\n          value = !value;\n        }\n        return value;\n      }\n    }]);\n    return PropertyEffects;\n  }(propertyEffectsBase);\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nvar hostStack = [];","map":{"version":3,"names":["wrap","dedupingMixin","root","isAncestor","isDescendant","get","translate","isPath","set","normalize","camelToDashCase","dashToCamelCase","PropertyAccessors","TemplateStamp","sanitizeDOMValue","legacyUndefined","orderedComputed","removeNestedTemplates","fastDomIf","dedupeId","NOOP","TYPES","COMPUTE","REFLECT","NOTIFY","PROPAGATE","OBSERVE","READ_ONLY","COMPUTE_INFO","capitalAttributeRegex","DataTrigger","DataEffect","ensureOwnEffectMap","model","type","cloneArrays","effects","hasOwnProperty","Object","create","p","protoFx","instFx","Array","length","i","runEffects","inst","props","oldProps","hasPaths","extraArgs","ran","id","prop","rootProperty","fxs","l","fx","info","lastRun","pathMatchesTrigger","trigger","fn","runEffectsForProperty","path","triggerPath","name","structured","wildcard","runObserverEffect","property","method","changedProp","call","__data","dynamicFn","console","warn","runNotifyEffects","notifyProps","notified","notifyPath","host","__dataHost","_invalidateProperties","eventName","dispatchNotifyEvent","value","detail","queueProperty","dispatchEvent","CustomEvent","runNotifyEffect","undefined","handleNotification","event","fromProp","toPath","negate","fromPath","currentTarget","_setPendingPropertyOrPath","Boolean","runReflectEffect","attrName","_propertyToAttribute","runComputedEffects","changedProps","computeEffects","order","getComputedOrder","queue","enqueueEffectsFor","shift","runComputedEffect","methodInfo","assign","__dataOld","__dataPending","inputProps","insertEffect","start","end","idx","mid","cmp","splice","ordered","constructor","__orderedComputedDeps","Map","_dependencyCounts","dependencyCounts","counts","ready","total","curr","size","computedByCurr","forEach","computedProp","push","el","concat","localName","infoForComputed","computedDeps","args","filter","a","literal","result","runMethodEffect","__dataHasAccessor","_setPendingProperty","computeLinkedPaths","links","__dataLinkedPaths","link","b","addBinding","templateInfo","nodeInfo","kind","target","parts","bindings","binding","isCompound","shouldAddListener","_binding$parts$","listenerEvent","listenerNegate","index","nodeInfoList","part","compoundIndex","addEffectForBindingPart","dependencies","evaluator","j","parseArg","_addTemplatePropertyEffect","runBindingEffect","nodeList","node","source","__isPropertyEffectsClient","_enqueueClient","_evaluateBinding","applyBindingValue","computeBindingValue","_valueToNodeAttribute","_setUnmanagedPropertyToNode","storage","__dataCompoundStorage","join","mode","setupBindings","setupCompoundStorage","addNotifyListener","literals","addEventListener","e","createMethodEffect","sig","effectFn","static","_typeof","methodName","arg","_addPropertyEffect","context","_methodHost","_marshalArgs","apply","emptyArray","IDENT","NUMBER","SQUOTE_STRING","DQUOTE_STRING","STRING","ARGUMENT","ARGUMENTS","ARGUMENT_LIST","BINDING","OPEN_BRACKET","CLOSE_BRACKET","NEGATE","EXPRESSION","bindingRegex","RegExp","literalFromParts","s","parseMethod","expression","m","match","trim","replace","split","parseArgs","argList","map","rawArg","fc","slice","Number","getArgValue","data","notifySplices","array","splices","splicesData","indexSplices","_overrideLegacyUndefined","notifySplice","addedCount","removed","object","upper","toUpperCase","substring","PropertyEffects","superClass","propertyEffectsBase","_propertyEffectsBase","_inherits","_this","_classCallCheck","_callSuper","__dataClientsReady","__dataPendingClients","__dataToNotify","__dataHasPaths","__dataTemp","__dataClientsInitialized","__computeEffects","__computeInfo","__reflectEffects","__notifyEffects","__propagateEffects","__observeEffects","__readOnly","__templateInfo","_createClass","key","_initializeProperties","_get","_getPrototypeOf","prototype","_registerHost","hostStack","_initializeProtoProperties","_initializeInstanceProperties","readOnly","effect","_createPropertyAccessor","_removePropertyEffect","indexOf","_hasPropertyEffect","_hasReadOnlyEffect","_hasNotifyEffect","_hasReflectEffect","_hasComputedEffect","shouldNotify","isPathNotification","isArray","old","propIsPath","prevProps","_shouldPropertyChange","_setProperty","__dataReady","_flushProperties","client","_flushClients","_readyClients","__enableOrFlushClients","clients","__dataEnabled","_enableProperties","setProperties","setReadOnly","_propertiesChanged","currentProps","_propagatePropertyChanges","__dataCounter","_runEffectsForTemplate","_this2","baseRunEffects","propertyEffects","firstChild","nextSibling","linkPaths","to","from","unlinkPaths","len","_len","arguments","items","_key","ret","pop","hadLength","deleteCount","_len2","_key2","Math","floor","unshift","_len3","_key3","propPath","_createReadOnlyProperty","protectedSetter","_createPropertyObserver","_createMethodObserver","Error","_createNotifyingProperty","_createReflectedProperty","attr","attributeNameForProperty","_createComputedProperty","values","_args$i","matches","pathValue","base","_bindTemplate","template","instanceBinding","_parseTemplate","wasPreBound","__preBoundTemplateInfo","parent","_parentTemplateInfo","previous","lastChild","previousSibling","_stampTemplate","dom","nodes","childNodes","n","_removeBoundDom","parentNode","removeChild","addPropertyEffect","createPropertyObserver","createMethodObserver","createNotifyingProperty","createReadOnlyProperty","createReflectedProperty","createComputedProperty","bindTemplate","hostProps","propEffects","_parseTemplateNode","noted","nodeType","Node","TEXT_NODE","_parseBindings","textContent","_parseTemplateNodeAttribute","origName","test","hasAttribute","getAttribute","setAttribute","removeAttribute","_parseTemplateNestedTemplate","nestedTemplateInfo","isDomIf","isDomRepeat","parentInfo","hostProp","text","lastIndex","exec","customEvent","notifyEvent","colon","signature","dynamicFns"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/mixins/property-effects.js"],"sourcesContent":["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport '../utils/boot.js';\nimport { wrap } from '../utils/wrap.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { root, isAncestor, isDescendant, get, translate, isPath, set, normalize } from '../utils/path.js';\n/* for notify, reflect */\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertyAccessors } from './property-accessors.js';\n/* for annotated effects */\nimport { TemplateStamp } from './template-stamp.js';\nimport { sanitizeDOMValue, legacyUndefined, orderedComputed, removeNestedTemplates, fastDomIf } from '../utils/settings.js';\n\n// Monotonically increasing unique ID used for de-duping effects triggered\n// from multiple properties in the same turn\nlet dedupeId = 0;\n\nconst NOOP = [];\n\n/**\n * Property effect types; effects are stored on the prototype using these keys\n * @enum {string}\n */\nconst TYPES = {\n  COMPUTE: '__computeEffects',\n  REFLECT: '__reflectEffects',\n  NOTIFY: '__notifyEffects',\n  PROPAGATE: '__propagateEffects',\n  OBSERVE: '__observeEffects',\n  READ_ONLY: '__readOnly'\n};\n\nconst COMPUTE_INFO = '__computeInfo';\n\n/** @const {!RegExp} */\nconst capitalAttributeRegex = /[A-Z]/;\n\n/**\n * @typedef {{\n * name: (string | undefined),\n * structured: (boolean | undefined),\n * wildcard: (boolean | undefined)\n * }}\n */\nlet DataTrigger; //eslint-disable-line no-unused-vars\n\n/**\n * @typedef {{\n * info: ?,\n * trigger: (!DataTrigger | undefined),\n * fn: (!Function | undefined)\n * }}\n */\nlet DataEffect; //eslint-disable-line no-unused-vars\n\n/**\n * Ensures that the model has an own-property map of effects for the given type.\n * The model may be a prototype or an instance.\n *\n * Property effects are stored as arrays of effects by property in a map,\n * by named type on the model. e.g.\n *\n *   __computeEffects: {\n *     foo: [ ... ],\n *     bar: [ ... ]\n *   }\n *\n * If the model does not yet have an effect map for the type, one is created\n * and returned.  If it does, but it is not an own property (i.e. the\n * prototype had effects), the the map is deeply cloned and the copy is\n * set on the model and returned, ready for new effects to be added.\n *\n * @param {Object} model Prototype or instance\n * @param {string} type Property effect type\n * @param {boolean=} cloneArrays Clone any arrays assigned to the map when\n *   extending a superclass map onto this subclass\n * @return {Object} The own-property map of effects for the given type\n * @private\n */\nfunction ensureOwnEffectMap(model, type, cloneArrays) {\n  let effects = model[type];\n  if (!effects) {\n    effects = model[type] = {};\n  } else if (!model.hasOwnProperty(type)) {\n    effects = model[type] = Object.create(model[type]);\n    if (cloneArrays) {\n      for (let p in effects) {\n        let protoFx = effects[p];\n        // Perf optimization over Array.slice\n        let instFx = effects[p] = Array(protoFx.length);\n        for (let i=0; i<protoFx.length; i++) {\n          instFx[i] = protoFx[i];\n        }\n      }\n    }\n  }\n  return effects;\n}\n\n// -- effects ----------------------------------------------\n\n/**\n * Runs all effects of a given type for the given set of property changes\n * on an instance.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {?Object} effects Object map of property-to-Array of effects\n * @param {?Object} props Bag of current property changes\n * @param {?Object=} oldProps Bag of previous values for changed properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {\n  if (effects) {\n    let ran = false;\n    const id = dedupeId++;\n    for (let prop in props) {\n      // Inline `runEffectsForProperty` for perf.\n      let rootProperty = hasPaths ? root(prop) : prop;\n      let fxs = effects[rootProperty];\n      if (fxs) {\n        for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n          if ((!fx.info || fx.info.lastRun !== id) &&\n              (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n            if (fx.info) {\n              fx.info.lastRun = id;\n            }\n            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n            ran = true;\n          }\n        }\n      }\n    }\n    return ran;\n  }\n  return false;\n}\n\n/**\n * Runs a list of effects for a given property.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {!Object} effects Object map of property-to-Array of effects\n * @param {number} dedupeId Counter used for de-duping effects\n * @param {string} prop Name of changed property\n * @param {*} props Changed properties\n * @param {*} oldProps Old properties\n * @param {boolean=} hasPaths True with `props` contains one or more paths\n * @param {*=} extraArgs Additional metadata to pass to effect function\n * @return {boolean} True if an effect ran for this property\n * @private\n */\nfunction runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {\n  let ran = false;\n  let rootProperty = hasPaths ? root(prop) : prop;\n  let fxs = effects[rootProperty];\n  if (fxs) {\n    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {\n      if ((!fx.info || fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        if (fx.info) {\n          fx.info.lastRun = dedupeId;\n        }\n        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);\n        ran = true;\n      }\n    }\n  }\n  return ran;\n}\n\n/**\n * Determines whether a property/path that has changed matches the trigger\n * criteria for an effect.  A trigger is a descriptor with the following\n * structure, which matches the descriptors returned from `parseArg`.\n * e.g. for `foo.bar.*`:\n * ```\n * trigger: {\n *   name: 'a.b',\n *   structured: true,\n *   wildcard: true\n * }\n * ```\n * If no trigger is given, the path is deemed to match.\n *\n * @param {string} path Path or property that changed\n * @param {?DataTrigger} trigger Descriptor\n * @return {boolean} Whether the path matched the trigger\n */\nfunction pathMatchesTrigger(path, trigger) {\n  if (trigger) {\n    let triggerPath = /** @type {string} */ (trigger.name);\n    return (triggerPath == path) ||\n        !!(trigger.structured && isAncestor(triggerPath, path)) ||\n        !!(trigger.wildcard && isDescendant(triggerPath, path));\n  } else {\n    return true;\n  }\n}\n\n/**\n * Implements the \"observer\" effect.\n *\n * Calls the method with `info.methodName` on the instance, passing the\n * new and old values.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runObserverEffect(inst, property, props, oldProps, info) {\n  let fn = typeof info.method === \"string\" ? inst[info.method] : info.method;\n  let changedProp = info.property;\n  if (fn) {\n    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);\n  } else if (!info.dynamicFn) {\n    console.warn('observer method `' + info.method + '` not defined');\n  }\n}\n\n/**\n * Runs \"notify\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * will dispatch path notification events in the case that the property\n * changed was a path and the root property for that path didn't have a\n * \"notify\" effect.  This is to maintain 1.0 behavior that did not require\n * `notify: true` to ensure object sub-property notifications were\n * sent.\n *\n * @param {!Polymer_PropertyEffects} inst The instance with effects to run\n * @param {Object} notifyProps Bag of properties to notify\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {\n  // Notify\n  let fxs = inst[TYPES.NOTIFY];\n  let notified;\n  let id = dedupeId++;\n  // Try normal notify effects; if none, fall back to try path notification\n  for (let prop in notifyProps) {\n    if (notifyProps[prop]) {\n      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {\n        notified = true;\n      } else if (hasPaths && notifyPath(inst, prop, props)) {\n        notified = true;\n      }\n    }\n  }\n  // Flush host if we actually notified and host was batching\n  // And the host has already initialized clients; this prevents\n  // an issue with a host observing data changes before clients are ready.\n  let host;\n  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {\n    host._invalidateProperties();\n  }\n}\n\n/**\n * Dispatches {property}-changed events with path information in the detail\n * object to indicate a sub-path of the property was changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} path The path that was changed\n * @param {Object} props Bag of current property changes\n * @return {boolean} Returns true if the path was notified\n * @private\n */\nfunction notifyPath(inst, path, props) {\n  let rootProperty = root(path);\n  if (rootProperty !== path) {\n    let eventName = camelToDashCase(rootProperty) + '-changed';\n    dispatchNotifyEvent(inst, eventName, props[path], path);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Dispatches {property}-changed events to indicate a property (or path)\n * changed.\n *\n * @param {!Polymer_PropertyEffects} inst The element from which to fire the\n *     event\n * @param {string} eventName The name of the event to send\n *     ('{property}-changed')\n * @param {*} value The value of the changed property\n * @param {string | null | undefined} path If a sub-path of this property\n *     changed, the path that changed (optional).\n * @return {void}\n * @private\n * @suppress {invalidCasts}\n */\nfunction dispatchNotifyEvent(inst, eventName, value, path) {\n  let detail = {\n    value: value,\n    queueProperty: true\n  };\n  if (path) {\n    detail.path = path;\n  }\n  // As a performance optimization, we could elide the wrap here since notifying\n  // events are non-bubbling and shouldn't need retargeting. However, a very\n  // small number of internal tests failed in obscure ways, which may indicate\n  // user code relied on timing differences resulting from ShadyDOM flushing\n  // as a result of the wrapped `dispatchEvent`.\n  wrap(/** @type {!HTMLElement} */(inst)).dispatchEvent(new CustomEvent(eventName, { detail }));\n}\n\n/**\n * Implements the \"notify\" effect.\n *\n * Dispatches a non-bubbling event named `info.eventName` on the instance\n * with a detail object containing the new `value`.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {\n  let rootProperty = hasPaths ? root(property) : property;\n  let path = rootProperty != property ? property : null;\n  let value = path ? get(inst, path) : inst.__data[property];\n  if (path && value === undefined) {\n    value = props[property];  // specifically for .splices\n  }\n  dispatchNotifyEvent(inst, info.eventName, value, path);\n}\n\n/**\n * Handler function for 2-way notification events. Receives context\n * information captured in the `addNotifyListener` closure from the\n * `__notifyListeners` metadata.\n *\n * Sets the value of the notified property to the host property or path.  If\n * the event contained path information, translate that path to the host\n * scope's name for that path first.\n *\n * @param {CustomEvent} event Notification event (e.g. '<property>-changed')\n * @param {!Polymer_PropertyEffects} inst Host element instance handling the\n *     notification event\n * @param {string} fromProp Child element property that was bound\n * @param {string} toPath Host property/path that was bound\n * @param {boolean} negate Whether the binding was negated\n * @return {void}\n * @private\n */\nfunction handleNotification(event, inst, fromProp, toPath, negate) {\n  let value;\n  let detail = /** @type {Object} */(event.detail);\n  let fromPath = detail && detail.path;\n  if (fromPath) {\n    toPath = translate(fromProp, toPath, fromPath);\n    value = detail && detail.value;\n  } else {\n    value = event.currentTarget[fromProp];\n  }\n  value = negate ? !value : value;\n  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {\n    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))\n      && (!detail || !detail.queueProperty)) {\n      inst._invalidateProperties();\n    }\n  }\n}\n\n/**\n * Implements the \"reflect\" effect.\n *\n * Sets the attribute named `info.attrName` to the given property value.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {void}\n * @private\n */\nfunction runReflectEffect(inst, property, props, oldProps, info) {\n  let value = inst.__data[property];\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, info.attrName, 'attribute', /** @type {Node} */(inst));\n  }\n  inst._propertyToAttribute(property, info.attrName, value);\n}\n\n/**\n * Runs \"computed\" effects for a set of changed properties.\n *\n * This method differs from the generic `runEffects` method in that it\n * continues to run computed effects based on the output of each pass until\n * there are no more newly computed properties.  This ensures that all\n * properties that will be computed by the initial set of changes are\n * computed before other effects (binding propagation, observers, and notify)\n * run.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {?Object} changedProps Bag of changed properties\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @return {void}\n * @private\n */\nfunction runComputedEffects(inst, changedProps, oldProps, hasPaths) {\n  let computeEffects = inst[TYPES.COMPUTE];\n  if (computeEffects) {\n    if (orderedComputed) {\n      // Runs computed effects in efficient order by keeping a topologically-\n      // sorted queue of compute effects to run, and inserting subsequently\n      // invalidated effects as they are run\n      dedupeId++;\n      const order = getComputedOrder(inst);\n      const queue = [];\n      for (let p in changedProps) {\n        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);\n      }\n      let info;\n      while ((info = queue.shift())) {\n        if (runComputedEffect(inst, '', changedProps, oldProps, info)) {\n          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);\n        }\n      }\n      Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n      Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n      inst.__dataPending = null;\n    } else {\n      // Original Polymer 2.x computed effects order, which continues running\n      // effects until no further computed properties have been invalidated\n      let inputProps = changedProps;\n      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {\n        Object.assign(/** @type {!Object} */ (oldProps), inst.__dataOld);\n        Object.assign(/** @type {!Object} */ (changedProps), inst.__dataPending);\n        inputProps = inst.__dataPending;\n        inst.__dataPending = null;\n      }\n    }\n  }\n}\n\n/**\n * Inserts a computed effect into a queue, given the specified order. Performs\n * the insert using a binary search.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {Object} info Property effects metadata\n * @param {Array<Object>} queue Ordered queue of effects\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n */\nconst insertEffect = (info, queue, order) => {\n  let start = 0;\n  let end = queue.length - 1;\n  let idx = -1;\n  while (start <= end) {\n    const mid = (start + end) >> 1;\n    // Note `methodInfo` is where the computed property name is stored in\n    // the effect metadata\n    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);\n    if (cmp < 0) {\n      start = mid + 1;\n    } else if (cmp > 0) {\n      end = mid - 1;\n    } else {\n      idx = mid;\n      break;\n    }\n  }\n  if (idx < 0) {\n    idx = end + 1;\n  }\n  queue.splice(idx, 0, info);\n};\n\n/**\n * Inserts all downstream computed effects invalidated by the specified property\n * into the topologically-sorted queue of effects to be run.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {string} prop Property name\n * @param {Object} computeEffects Computed effects for this element\n * @param {Array<Object>} queue Topologically-sorted queue of computed effects\n *   to be run\n * @param {Map<string,number>} order Map of computed property name->topological\n *   sort order\n * @param {boolean} hasPaths True with `changedProps` contains one or more paths\n */\nconst enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {\n  const rootProperty = hasPaths ? root(prop) : prop;\n  const fxs = computeEffects[rootProperty];\n  if (fxs) {\n    for (let i=0; i<fxs.length; i++) {\n      const fx = fxs[i];\n      if ((fx.info.lastRun !== dedupeId) &&\n          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {\n        fx.info.lastRun = dedupeId;\n        insertEffect(fx.info, queue, order);\n      }\n    }\n  }\n};\n\n/**\n * Generates and retrieves a memoized map of computed property name to its\n * topologically-sorted order.\n *\n * The map is generated by first assigning a \"dependency count\" to each property\n * (defined as number properties it depends on, including its method for\n * \"dynamic functions\"). Any properties that have no dependencies are added to\n * the `ready` queue, which are properties whose order can be added to the final\n * order map. Properties are popped off the `ready` queue one by one and a.) added as\n * the next property in the order map, and b.) each property that it is a\n * dependency for has its dep count decremented (and if that property's dep\n * count goes to zero, it is added to the `ready` queue), until all properties\n * have been visited and ordered.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to retrieve the computed\n *   effect order for.\n * @return {Map<string,number>} Map of computed property name->topological sort\n *   order\n */\nfunction getComputedOrder(inst) {\n  let ordered = inst.constructor.__orderedComputedDeps;\n  if (!ordered) {\n    ordered = new Map();\n    const effects = inst[TYPES.COMPUTE];\n    let {counts, ready, total} = dependencyCounts(inst);\n    let curr;\n    while ((curr = ready.shift())) {\n      ordered.set(curr, ordered.size);\n      const computedByCurr = effects[curr];\n      if (computedByCurr) {\n        computedByCurr.forEach(fx => {\n          // Note `methodInfo` is where the computed property name is stored\n          const computedProp = fx.info.methodInfo;\n          --total;\n          if (--counts[computedProp] === 0) {\n            ready.push(computedProp);\n          }\n        });\n      }\n    }\n    if (total !== 0) {\n      const el = /** @type {HTMLElement} */ (inst);\n      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);\n    }\n    inst.constructor.__orderedComputedDeps = ordered;\n  }\n  return ordered;\n}\n\n/**\n * Generates a map of property-to-dependency count (`counts`, where \"dependency\n * count\" is the number of dependencies a given property has assuming it is a\n * computed property, otherwise 0).  It also returns a pre-populated list of\n * `ready` properties that have no dependencies and a `total` count, which is\n * used for error-checking the graph.\n *\n * Used by `orderedComputed: true` computed property algorithm.\n *\n * @param {!Polymer_PropertyEffects} inst The instance to generate dependency\n *   counts for.\n * @return {!Object} Object containing `counts` map (property-to-dependency\n *   count) and pre-populated `ready` array of properties that had zero\n *   dependencies.\n */\nfunction dependencyCounts(inst) {\n  const infoForComputed = inst[COMPUTE_INFO];\n  const counts = {};\n  const computedDeps = inst[TYPES.COMPUTE];\n  const ready = [];\n  let total = 0;\n  // Count dependencies for each computed property\n  for (let p in infoForComputed) {\n    const info = infoForComputed[p];\n    // Be sure to add the method name itself in case of \"dynamic functions\"\n    total += counts[p] =\n      info.args.filter(a => !a.literal).length + (info.dynamicFn ? 1 : 0);\n  }\n  // Build list of ready properties (that aren't themselves computed)\n  for (let p in computedDeps) {\n    if (!infoForComputed[p]) {\n      ready.push(p);\n    }\n  }\n  return {counts, ready, total};\n}\n\n/**\n * Implements the \"computed property\" effect by running the method with the\n * values of the arguments specified in the `info` object and setting the\n * return value to the computed property specified.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {?Object} changedProps Bag of current property changes\n * @param {?Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {boolean} True when the property being computed changed\n * @private\n */\nfunction runComputedEffect(inst, property, changedProps, oldProps, info) {\n  // Dirty check dependencies and run if any invalid\n  let result = runMethodEffect(inst, property, changedProps, oldProps, info);\n  // Abort if method returns a no-op result\n  if (result === NOOP) {\n    return false;\n  }\n  let computedProp = info.methodInfo;\n  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {\n    return inst._setPendingProperty(computedProp, result, true);\n  } else {\n    inst[computedProp] = result;\n    return false;\n  }\n}\n\n/**\n * Computes path changes based on path links set up using the `linkPaths`\n * API.\n *\n * @param {!Polymer_PropertyEffects} inst The instance whose props are changing\n * @param {string} path Path that has changed\n * @param {*} value Value of changed path\n * @return {void}\n * @private\n */\nfunction computeLinkedPaths(inst, path, value) {\n  let links = inst.__dataLinkedPaths;\n  if (links) {\n    let link;\n    for (let a in links) {\n      let b = links[a];\n      if (isDescendant(a, path)) {\n        link = translate(a, b, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      } else if (isDescendant(b, path)) {\n        link = translate(b, a, path);\n        inst._setPendingPropertyOrPath(link, value, true, true);\n      }\n    }\n  }\n}\n\n// -- bindings ----------------------------------------------\n\n/**\n * Adds binding metadata to the current `nodeInfo`, and binding effects\n * for all part dependencies to `templateInfo`.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {NodeInfo} nodeInfo Node metadata for current template node\n * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'\n * @param {string} target Target property name\n * @param {!Array<!BindingPart>} parts Array of binding part metadata\n * @param {string=} literal Literal text surrounding binding parts (specified\n *   only for 'property' bindings, since these must be initialized as part\n *   of boot-up)\n * @return {void}\n * @private\n */\nfunction addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {\n  // Create binding metadata and add to nodeInfo\n  nodeInfo.bindings = nodeInfo.bindings || [];\n  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };\n  nodeInfo.bindings.push(binding);\n  // Add listener info to binding metadata\n  if (shouldAddListener(binding)) {\n    let {event, negate} = binding.parts[0];\n    binding.listenerEvent = event || (camelToDashCase(target) + '-changed');\n    binding.listenerNegate = negate;\n  }\n  // Add \"propagate\" property effects to templateInfo\n  let index = templateInfo.nodeInfoList.length;\n  for (let i=0; i<binding.parts.length; i++) {\n    let part = binding.parts[i];\n    part.compoundIndex = i;\n    addEffectForBindingPart(constructor, templateInfo, binding, part, index);\n  }\n}\n\n/**\n * Adds property effects to the given `templateInfo` for the given binding\n * part.\n *\n * @param {Function} constructor Class that `_parseTemplate` is currently\n *   running on\n * @param {TemplateInfo} templateInfo Template metadata for current template\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {number} index Index into `nodeInfoList` for this node\n * @return {void}\n */\nfunction addEffectForBindingPart(constructor, templateInfo, binding, part, index) {\n  if (!part.literal) {\n    if (binding.kind === 'attribute' && binding.target[0] === '-') {\n      console.warn('Cannot set attribute ' + binding.target +\n        ' because \"-\" is not a valid attribute starting character');\n    } else {\n      let dependencies = part.dependencies;\n      let info = { index, binding, part, evaluator: constructor };\n      for (let j=0; j<dependencies.length; j++) {\n        let trigger = dependencies[j];\n        if (typeof trigger == 'string') {\n          trigger = parseArg(trigger);\n          trigger.wildcard = true;\n        }\n        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {\n          fn: runBindingEffect,\n          info, trigger\n        });\n      }\n    }\n  }\n}\n\n/**\n * Implements the \"binding\" (property/path binding) effect.\n *\n * Note that binding syntax is overridable via `_parseBindings` and\n * `_evaluateBinding`.  This method will call `_evaluateBinding` for any\n * non-literal parts returned from `_parseBindings`.  However,\n * there is no support for _path_ bindings via custom binding parts,\n * as this is specific to Polymer's path binding syntax.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} path Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @param {boolean} hasPaths True with `props` contains one or more paths\n * @param {Array} nodeList List of nodes associated with `nodeInfoList` template\n *   metadata\n * @return {void}\n * @private\n */\nfunction runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {\n  let node = nodeList[info.index];\n  let binding = info.binding;\n  let part = info.part;\n  // Subpath notification: transform path and set to client\n  // e.g.: foo=\"{{obj.sub}}\", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop\n  if (hasPaths && part.source && (path.length > part.source.length) &&\n      (binding.kind == 'property') && !binding.isCompound &&\n      node.__isPropertyEffectsClient &&\n      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {\n    let value = props[path];\n    path = translate(part.source, binding.target, path);\n    if (node._setPendingPropertyOrPath(path, value, false, true)) {\n      inst._enqueueClient(node);\n    }\n  } else {\n    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);\n    // Propagate value to child\n    // Abort if value is a no-op result\n    if (value !== NOOP) {\n      applyBindingValue(inst, node, binding, part, value);\n    }\n  }\n}\n\n/**\n * Sets the value for an \"binding\" (binding) effect to a node,\n * either as a property or attribute.\n *\n * @param {!Polymer_PropertyEffects} inst The instance owning the binding effect\n * @param {Node} node Target node for binding\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @param {*} value Value to set\n * @return {void}\n * @private\n */\nfunction applyBindingValue(inst, node, binding, part, value) {\n  value = computeBindingValue(node, value, binding, part);\n  if (sanitizeDOMValue) {\n    value = sanitizeDOMValue(value, binding.target, binding.kind, node);\n  }\n  if (binding.kind == 'attribute') {\n    // Attribute binding\n    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);\n  } else {\n    // Property binding\n    let prop = binding.target;\n    if (node.__isPropertyEffectsClient &&\n        node.__dataHasAccessor && node.__dataHasAccessor[prop]) {\n      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {\n        if (node._setPendingProperty(prop, value)) {\n          inst._enqueueClient(node);\n        }\n      }\n    } else {\n      // In legacy no-batching mode, bindings applied before dataReady are\n      // equivalent to the \"apply config\" phase, which only set managed props\n      inst._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n}\n\n/**\n * Transforms an \"binding\" effect value based on compound & negation\n * effect metadata, as well as handling for special-case properties\n *\n * @param {Node} node Node the value will be set to\n * @param {*} value Value to set\n * @param {!Binding} binding Binding metadata\n * @param {!BindingPart} part Binding part metadata\n * @return {*} Transformed value to set\n * @private\n */\nfunction computeBindingValue(node, value, binding, part) {\n  if (binding.isCompound) {\n    let storage = node.__dataCompoundStorage[binding.target];\n    storage[part.compoundIndex] = value;\n    value = storage.join('');\n  }\n  if (binding.kind !== 'attribute') {\n    // Some browsers serialize `undefined` to `\"undefined\"`\n    if (binding.target === 'textContent' ||\n        (binding.target === 'value' &&\n          (node.localName === 'input' || node.localName === 'textarea'))) {\n      value = value == undefined ? '' : value;\n    }\n  }\n  return value;\n}\n\n/**\n * Returns true if a binding's metadata meets all the requirements to allow\n * 2-way binding, and therefore a `<property>-changed` event listener should be\n * added:\n * - used curly braces\n * - is a property (not attribute) binding\n * - is not a textContent binding\n * - is not compound\n *\n * @param {!Binding} binding Binding metadata\n * @return {boolean} True if 2-way listener should be added\n * @private\n */\nfunction shouldAddListener(binding) {\n  return Boolean(binding.target) &&\n         binding.kind != 'attribute' &&\n         binding.kind != 'text' &&\n         !binding.isCompound &&\n         binding.parts[0].mode === '{';\n}\n\n/**\n * Setup compound binding storage structures, notify listeners, and dataHost\n * references onto the bound nodeList.\n *\n * @param {!Polymer_PropertyEffects} inst Instance that bas been previously\n *     bound\n * @param {TemplateInfo} templateInfo Template metadata\n * @return {void}\n * @private\n */\nfunction setupBindings(inst, templateInfo) {\n  // Setup compound storage, dataHost, and notify listeners\n  let {nodeList, nodeInfoList} = templateInfo;\n  if (nodeInfoList.length) {\n    for (let i=0; i < nodeInfoList.length; i++) {\n      let info = nodeInfoList[i];\n      let node = nodeList[i];\n      let bindings = info.bindings;\n      if (bindings) {\n        for (let i=0; i<bindings.length; i++) {\n          let binding = bindings[i];\n          setupCompoundStorage(node, binding);\n          addNotifyListener(node, inst, binding);\n        }\n      }\n      // This ensures all bound elements have a host set, regardless\n      // of whether they upgrade synchronous to creation\n      node.__dataHost = inst;\n    }\n  }\n}\n\n/**\n * Initializes `__dataCompoundStorage` local storage on a bound node with\n * initial literal data for compound bindings, and sets the joined\n * literal parts to the bound property.\n *\n * When changes to compound parts occur, they are first set into the compound\n * storage array for that property, and then the array is joined to result in\n * the final value set to the property/attribute.\n *\n * @param {Node} node Bound node to initialize\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction setupCompoundStorage(node, binding) {\n  if (binding.isCompound) {\n    // Create compound storage map\n    let storage = node.__dataCompoundStorage ||\n      (node.__dataCompoundStorage = {});\n    let parts = binding.parts;\n    // Copy literals from parts into storage for this binding\n    let literals = new Array(parts.length);\n    for (let j=0; j<parts.length; j++) {\n      literals[j] = parts[j].literal;\n    }\n    let target = binding.target;\n    storage[target] = literals;\n    // Configure properties with their literal parts\n    if (binding.literal && binding.kind == 'property') {\n      // Note, className needs style scoping so this needs wrapping.\n      // We may also want to consider doing this for `textContent` and\n      // `innerHTML`.\n      if (target === 'className') {\n        node = wrap(node);\n      }\n      node[target] = binding.literal;\n    }\n  }\n}\n\n/**\n * Adds a 2-way binding notification event listener to the node specified\n *\n * @param {Object} node Child element to add listener to\n * @param {!Polymer_PropertyEffects} inst Host element instance to handle\n *     notification event\n * @param {Binding} binding Binding metadata\n * @return {void}\n * @private\n */\nfunction addNotifyListener(node, inst, binding) {\n  if (binding.listenerEvent) {\n    let part = binding.parts[0];\n    node.addEventListener(binding.listenerEvent, function(e) {\n      handleNotification(e, inst, binding.target, part.source, part.negate);\n    });\n  }\n}\n\n// -- for method-based effects (complexObserver & computed) --------------\n\n/**\n * Adds property effects for each argument in the method signature (and\n * optionally, for the method name if `dynamic` is true) that calls the\n * provided effect function.\n *\n * @param {Element | Object} model Prototype or instance\n * @param {!MethodSignature} sig Method signature metadata\n * @param {string} type Type of property effect to add\n * @param {Function} effectFn Function to run when arguments change\n * @param {*=} methodInfo Effect-specific information to be included in\n *   method effect metadata\n * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n *   method names should be included as a dependency to the effect. Note,\n *   defaults to true if the signature is static (sig.static is true).\n * @return {!Object} Effect metadata for this method effect\n * @private\n */\nfunction createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {\n  dynamicFn = sig.static || (dynamicFn &&\n    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));\n  let info = {\n    methodName: sig.methodName,\n    args: sig.args,\n    methodInfo,\n    dynamicFn\n  };\n  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {\n    if (!arg.literal) {\n      model._addPropertyEffect(arg.rootProperty, type, {\n        fn: effectFn, info: info, trigger: arg\n      });\n    }\n  }\n  if (dynamicFn) {\n    model._addPropertyEffect(sig.methodName, type, {\n      fn: effectFn, info: info\n    });\n  }\n  return info;\n}\n\n/**\n * Calls a method with arguments marshaled from properties on the instance\n * based on the method signature contained in the effect metadata.\n *\n * Multi-property observers, computed properties, and inline computing\n * functions call this function to invoke the method, then use the return\n * value accordingly.\n *\n * @param {!Polymer_PropertyEffects} inst The instance the effect will be run on\n * @param {string} property Name of property\n * @param {Object} props Bag of current property changes\n * @param {Object} oldProps Bag of previous values for changed properties\n * @param {?} info Effect metadata\n * @return {*} Returns the return value from the method invocation\n * @private\n */\nfunction runMethodEffect(inst, property, props, oldProps, info) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  let context = inst._methodHost || inst;\n  let fn = context[info.methodName];\n  if (fn) {\n    let args = inst._marshalArgs(info.args, property, props);\n    return args === NOOP ? NOOP : fn.apply(context, args);\n  } else if (!info.dynamicFn) {\n    console.warn('method `' + info.methodName + '` not defined');\n  }\n}\n\nconst emptyArray = [];\n\n// Regular expressions used for binding\nconst IDENT  = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nconst NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nconst SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nconst DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nconst STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nconst ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\\\s*' + ')';\nconst ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nconst ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' +\n                              '(?:' + ARGUMENTS + '?' + ')' +\n                            '\\\\)\\\\s*' + ')';\nconst BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3\nconst OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nconst CLOSE_BRACKET = '(?:]]|}})';\nconst NEGATE = '(?:(!)\\\\s*)?'; // Group 2\nconst EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nconst bindingRegex = new RegExp(EXPRESSION, \"g\");\n\n/**\n * Create a string from binding parts of all the literal parts\n *\n * @param {!Array<BindingPart>} parts All parts to stringify\n * @return {string} String made from the literal parts\n */\nfunction literalFromParts(parts) {\n  let s = '';\n  for (let i=0; i<parts.length; i++) {\n    let literal = parts[i].literal;\n    s += literal || '';\n  }\n  return s;\n}\n\n/**\n * Parses an expression string for a method signature, and returns a metadata\n * describing the method in terms of `methodName`, `static` (whether all the\n * arguments are literals), and an array of `args`\n *\n * @param {string} expression The expression to parse\n * @return {?MethodSignature} The method metadata object if a method expression was\n *   found, otherwise `undefined`\n * @private\n */\nfunction parseMethod(expression) {\n  // tries to match valid javascript property names\n  let m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\n  if (m) {\n    let methodName = m[1];\n    let sig = { methodName, static: true, args: emptyArray };\n    if (m[2].trim()) {\n      // replace escaped commas with comma entity, split on un-escaped commas\n      let args = m[2].replace(/\\\\,/g, '&comma;').split(',');\n      return parseArgs(args, sig);\n    } else {\n      return sig;\n    }\n  }\n  return null;\n}\n\n/**\n * Parses an array of arguments and sets the `args` property of the supplied\n * signature metadata object. Sets the `static` property to false if any\n * argument is a non-literal.\n *\n * @param {!Array<string>} argList Array of argument names\n * @param {!MethodSignature} sig Method signature metadata object\n * @return {!MethodSignature} The updated signature metadata object\n * @private\n */\nfunction parseArgs(argList, sig) {\n  sig.args = argList.map(function(rawArg) {\n    let arg = parseArg(rawArg);\n    if (!arg.literal) {\n      sig.static = false;\n    }\n    return arg;\n  }, this);\n  return sig;\n}\n\n/**\n * Parses an individual argument, and returns an argument metadata object\n * with the following fields:\n *\n *   {\n *     value: 'prop',        // property/path or literal value\n *     literal: false,       // whether argument is a literal\n *     structured: false,    // whether the property is a path\n *     rootProperty: 'prop', // the root property of the path\n *     wildcard: false       // whether the argument was a wildcard '.*' path\n *   }\n *\n * @param {string} rawArg The string value of the argument\n * @return {!MethodArg} Argument metadata object\n * @private\n */\nfunction parseArg(rawArg) {\n  // clean up whitespace\n  let arg = rawArg.trim()\n    // replace comma entity with comma\n    .replace(/&comma;/g, ',')\n    // repair extra escape sequences; note only commas strictly need\n    // escaping, but we allow any other char to be escaped since its\n    // likely users will do this\n    .replace(/\\\\(.)/g, '$1')\n    ;\n  // basic argument descriptor\n  let a = {\n    name: arg,\n    value: '',\n    literal: false\n  };\n  // detect literal value (must be String or Number)\n  let fc = arg[0];\n  if (fc === '-') {\n    fc = arg[1];\n  }\n  if (fc >= '0' && fc <= '9') {\n    fc = '#';\n  }\n  switch(fc) {\n    case \"'\":\n    case '\"':\n      a.value = arg.slice(1, -1);\n      a.literal = true;\n      break;\n    case '#':\n      a.value = Number(arg);\n      a.literal = true;\n      break;\n  }\n  // if not literal, look for structured path\n  if (!a.literal) {\n    a.rootProperty = root(arg);\n    // detect structured path (has dots)\n    a.structured = isPath(arg);\n    if (a.structured) {\n      a.wildcard = (arg.slice(-2) == '.*');\n      if (a.wildcard) {\n        a.name = arg.slice(0, -2);\n      }\n    }\n  }\n  return a;\n}\n\nfunction getArgValue(data, props, path) {\n  let value = get(data, path);\n  // when data is not stored e.g. `splices`, get the value from changedProps\n  // TODO(kschaaf): Note, this can cause a rare issue where the wildcard\n  // info.value could pull a stale value out of changedProps during a reentrant\n  // change that sets the value back to undefined.\n  // https://github.com/Polymer/polymer/issues/5479\n  if (value === undefined) {\n    value = props[path];\n  }\n  return value;\n}\n\n// data api\n\n/**\n * Sends array splice notifications (`.splices` and `.length`)\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {Array} splices Array of splice records\n * @return {void}\n * @private\n */\nfunction notifySplices(inst, array, path, splices) {\n  const splicesData = { indexSplices: splices };\n  // Legacy behavior stored splices in `__data__` so it was *not* ephemeral.\n  // To match this behavior, we store splices directly on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    array.splices = splicesData;\n  }\n  inst.notifyPath(path + '.splices', splicesData);\n  inst.notifyPath(path + '.length', array.length);\n  // Clear splice data only when it's stored on the array.\n  if (legacyUndefined && !inst._overrideLegacyUndefined) {\n    splicesData.indexSplices = [];\n  }\n}\n\n/**\n * Creates a splice record and sends an array splice notification for\n * the described mutation\n *\n * Note: this implementation only accepts normalized paths\n *\n * @param {!Polymer_PropertyEffects} inst Instance to send notifications to\n * @param {Array} array The array the mutations occurred on\n * @param {string} path The path to the array that was mutated\n * @param {number} index Index at which the array mutation occurred\n * @param {number} addedCount Number of added items\n * @param {Array} removed Array of removed items\n * @return {void}\n * @private\n */\nfunction notifySplice(inst, array, path, index, addedCount, removed) {\n  notifySplices(inst, array, path, [{\n    index: index,\n    addedCount: addedCount,\n    removed: removed,\n    object: array,\n    type: 'splice'\n  }]);\n}\n\n/**\n * Returns an upper-cased version of the string.\n *\n * @param {string} name String to uppercase\n * @return {string} Uppercased string\n * @private\n */\nfunction upper(name) {\n  return name[0].toUpperCase() + name.substring(1);\n}\n\n/**\n * Element class mixin that provides meta-programming for Polymer's template\n * binding and data observation (collectively, \"property effects\") system.\n *\n * This mixin uses provides the following key static methods for adding\n * property effects to an element class:\n * - `addPropertyEffect`\n * - `createPropertyObserver`\n * - `createMethodObserver`\n * - `createNotifyingProperty`\n * - `createReadOnlyProperty`\n * - `createReflectedProperty`\n * - `createComputedProperty`\n * - `bindTemplate`\n *\n * Each method creates one or more property accessors, along with metadata\n * used by this mixin's implementation of `_propertiesChanged` to perform\n * the property effects.\n *\n * Underscored versions of the above methods also exist on the element\n * prototype for adding property effects on instances at runtime.\n *\n * Note that this mixin overrides several `PropertyAccessors` methods, in\n * many cases to maintain guarantees provided by the Polymer 1.x features;\n * notably it changes property accessors to be synchronous by default\n * whereas the default when using `PropertyAccessors` standalone is to be\n * async by default.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin TemplateStamp\n * @appliesMixin PropertyAccessors\n * @summary Element class mixin that provides meta-programming for Polymer's\n * template binding and data observation system.\n */\nexport const PropertyEffects = dedupingMixin(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @implements {Polymer_TemplateStamp}\n   * @unrestricted\n   * @private\n   */\n  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyEffects}\n   * @extends {propertyEffectsBase}\n   * @unrestricted\n   */\n  class PropertyEffects extends propertyEffectsBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      // Used to identify users of this mixin, ala instanceof\n      this.__isPropertyEffectsClient = true;\n      /** @type {boolean} */\n      this.__dataClientsReady;\n      /** @type {Array} */\n      this.__dataPendingClients;\n      /** @type {Object} */\n      this.__dataToNotify;\n      /** @type {Object} */\n      this.__dataLinkedPaths;\n      /** @type {boolean} */\n      this.__dataHasPaths;\n      /** @type {Object} */\n      this.__dataCompoundStorage;\n      /** @type {Polymer_PropertyEffects} */\n      this.__dataHost;\n      /** @type {!Object} */\n      this.__dataTemp;\n      /** @type {boolean} */\n      this.__dataClientsInitialized;\n      /** @type {!Object} */\n      this.__data;\n      /** @type {!Object|null} */\n      this.__dataPending;\n      /** @type {!Object} */\n      this.__dataOld;\n      /** @type {Object} */\n      this.__computeEffects;\n      /** @type {Object} */\n      this.__computeInfo;\n      /** @type {Object} */\n      this.__reflectEffects;\n      /** @type {Object} */\n      this.__notifyEffects;\n      /** @type {Object} */\n      this.__propagateEffects;\n      /** @type {Object} */\n      this.__observeEffects;\n      /** @type {Object} */\n      this.__readOnly;\n      /** @type {!TemplateInfo} */\n      this.__templateInfo;\n      /** @type {boolean} */\n      this._overrideLegacyUndefined;\n    }\n\n    get PROPERTY_EFFECT_TYPES() {\n      return TYPES;\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n    _initializeProperties() {\n      super._initializeProperties();\n      this._registerHost();\n      this.__dataClientsReady = false;\n      this.__dataPendingClients = null;\n      this.__dataToNotify = null;\n      this.__dataLinkedPaths = null;\n      this.__dataHasPaths = false;\n      // May be set on instance prior to upgrade\n      this.__dataCompoundStorage = this.__dataCompoundStorage || null;\n      this.__dataHost = this.__dataHost || null;\n      this.__dataTemp = {};\n      this.__dataClientsInitialized = false;\n    }\n\n    _registerHost() {\n      if (hostStack.length) {\n        let host = hostStack[hostStack.length-1];\n        host._enqueueClient(this);\n        // This ensures even non-bound elements have a host set, as\n        // long as they upgrade synchronously\n        this.__dataHost = host;\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to provide a\n     * more efficient implementation of initializing properties from\n     * the prototype on the instance.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the prototype\n     * @return {void}\n     */\n    _initializeProtoProperties(props) {\n      this.__data = Object.create(props);\n      this.__dataPending = Object.create(props);\n      this.__dataOld = {};\n    }\n\n    /**\n     * Overrides `PropertyAccessors` implementation to avoid setting\n     * `_setProperty`'s `shouldNotify: true`.\n     *\n     * @override\n     * @param {Object} props Properties to initialize on the instance\n     * @return {void}\n     */\n    _initializeInstanceProperties(props) {\n      let readOnly = this[TYPES.READ_ONLY];\n      for (let prop in props) {\n        if (!readOnly || !readOnly[prop]) {\n          this.__dataPending = this.__dataPending || {};\n          this.__dataOld = this.__dataOld || {};\n          this.__data[prop] = this.__dataPending[prop] = props[prop];\n        }\n      }\n    }\n\n    // Prototype setup ----------------------------------------\n\n    /**\n     * Equivalent to static `addPropertyEffect` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     */\n    _addPropertyEffect(property, type, effect) {\n      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);\n      // effects are accumulated into arrays per property based on type\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      if (!effects) {\n        effects = this[type][property] = [];\n      }\n      effects.push(effect);\n    }\n\n    /**\n     * Removes the given property effect.\n     *\n     * @override\n     * @param {string} property Property the effect was associated with\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object to remove\n     * @return {void}\n     */\n    _removePropertyEffect(property, type, effect) {\n      let effects = ensureOwnEffectMap(this, type, true)[property];\n      let idx = effects.indexOf(effect);\n      if (idx >= 0) {\n        effects.splice(idx, 1);\n      }\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a property effect\n     * of a certain type.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasPropertyEffect(property, type) {\n      let effects = this[type];\n      return Boolean(effects && effects[property]);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"read only\"\n     * accessor for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReadOnlyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.READ_ONLY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"notify\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasNotifyEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.NOTIFY);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"reflect to\n     * attribute\" property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasReflectEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.REFLECT);\n    }\n\n    /**\n     * Returns whether the current prototype/instance has a \"computed\"\n     * property effect for the given property.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {boolean} True if the prototype/instance has an effect of this\n     *     type\n     * @protected\n     */\n    _hasComputedEffect(property) {\n      return this._hasPropertyEffect(property, TYPES.COMPUTE);\n    }\n\n    // Runtime ----------------------------------------\n\n    /**\n     * Sets a pending property or path.  If the root property of the path in\n     * question had no accessor, the path is set, otherwise it is enqueued\n     * via `_setPendingProperty`.\n     *\n     * This function isolates relatively expensive functionality necessary\n     * for the public API (`set`, `setProperties`, `notifyPath`, and property\n     * change listeners via {{...}} bindings), such that it is only done\n     * when paths enter the system, and not at every propagation step.  It\n     * also sets a `__dataHasPaths` flag on the instance which is used to\n     * fast-path slower path-matching code in the property effects host paths.\n     *\n     * `path` can be a path string or array of path parts as accepted by the\n     * public API.\n     *\n     * @override\n     * @param {string | !Array<number|string>} path Path to set\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify Set to true if this change should\n     *  cause a property notification event dispatch\n     * @param {boolean=} isPathNotification If the path being set is a path\n     *   notification of an already changed value, as opposed to a request\n     *   to set and notify the change.  In the latter `false` case, a dirty\n     *   check is performed and then the value is set to the path before\n     *   enqueuing the pending property change.\n     * @return {boolean} Returns true if the property/path was enqueued in\n     *   the pending changes bag.\n     * @protected\n     */\n    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {\n      if (isPathNotification ||\n          root(Array.isArray(path) ? path[0] : path) !== path) {\n        // Dirty check changes being set to a path against the actual object,\n        // since this is the entry point for paths into the system; from here\n        // the only dirty checks are against the `__dataTemp` cache to prevent\n        // duplicate work in the same turn only. Note, if this was a notification\n        // of a change already set to a path (isPathNotification: true),\n        // we always let the change through and skip the `set` since it was\n        // already dirty checked at the point of entry and the underlying\n        // object has already been updated\n        if (!isPathNotification) {\n          let old = get(this, path);\n          path = /** @type {string} */ (set(this, path, value));\n          // Use property-accessor's simpler dirty check\n          if (!path || !super._shouldPropertyChange(path, value, old)) {\n            return false;\n          }\n        }\n        this.__dataHasPaths = true;\n        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {\n          computeLinkedPaths(this, /**@type{string}*/ (path), value);\n          return true;\n        }\n      } else {\n        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {\n          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);\n        } else {\n          this[path] = value;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Applies a value to a non-Polymer element/node's property.\n     *\n     * The implementation makes a best-effort at binding interop:\n     * Some native element properties have side-effects when\n     * re-setting the same value (e.g. setting `<input>.value` resets the\n     * cursor position), so we do a dirty-check before setting the value.\n     * However, for better interop with non-Polymer custom elements that\n     * accept objects, we explicitly re-set object changes coming from the\n     * Polymer world (which may include deep object changes without the\n     * top reference changing), erring on the side of providing more\n     * information.\n     *\n     * Users may override this method to provide alternate approaches.\n     *\n     * @override\n     * @param {!Node} node The node to set a property on\n     * @param {string} prop The property to set\n     * @param {*} value The value to set\n     * @return {void}\n     * @protected\n     */\n    _setUnmanagedPropertyToNode(node, prop, value) {\n      // It is a judgment call that resetting primitives is\n      // \"bad\" and resettings objects is also \"good\"; alternatively we could\n      // implement a whitelist of tag & property values that should never\n      // be reset (e.g. <input>.value && <select>.value)\n      if (value !== node[prop] || typeof value == 'object') {\n        // Note, className needs style scoping so this needs wrapping.\n        if (prop === 'className') {\n          node = /** @type {!Node} */(wrap(node));\n        }\n        node[prop] = value;\n      }\n    }\n\n    /**\n     * Overrides the `PropertiesChanged` implementation to introduce special\n     * dirty check logic depending on the property & value being set:\n     *\n     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})\n     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`\n     * 2. Object set to simple property (e.g. 'prop': {...})\n     *    Stored in `__dataTemp` and `__data`, dirty checked against\n     *    `__dataTemp` by default implementation of `_shouldPropertyChange`\n     * 3. Primitive value set to simple property (e.g. 'prop': 42)\n     *    Stored in `__data`, dirty checked against `__data`\n     *\n     * The dirty-check is important to prevent cycles due to two-way\n     * notification, but paths and objects are only dirty checked against any\n     * previous value set during this turn via a \"temporary cache\" that is\n     * cleared when the last `_propertiesChanged` exits. This is so:\n     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated\n     *    due to array mutations like shift/unshift/splice; this is fine\n     *    since path changes are dirty-checked at user entry points like `set`\n     * b. dirty-checking for objects only lasts one turn to allow the user\n     *    to mutate the object in-place and re-set it with the same identity\n     *    and have all sub-properties re-propagated in a subsequent turn.\n     *\n     * The temp cache is not necessarily sufficient to prevent invalid array\n     * paths, since a splice can happen during the same turn (with pathological\n     * user code); we could introduce a \"fixup\" for temporarily cached array\n     * paths if needed: https://github.com/Polymer/polymer/issues/4227\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} shouldNotify True if property should fire notification\n     *   event (applies only for `notify: true` properties)\n     * @return {boolean} Returns true if the property changed\n     */\n    _setPendingProperty(property, value, shouldNotify) {\n      let propIsPath = this.__dataHasPaths && isPath(property);\n      let prevProps = propIsPath ? this.__dataTemp : this.__data;\n      if (this._shouldPropertyChange(property, value, prevProps[property])) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (!(property in this.__dataOld)) {\n          this.__dataOld[property] = this.__data[property];\n        }\n        // Paths are stored in temporary cache (cleared at end of turn),\n        // which is used for dirty-checking, all others stored in __data\n        if (propIsPath) {\n          this.__dataTemp[property] = value;\n        } else {\n          this.__data[property] = value;\n        }\n        // All changes go into pending property bag, passed to _propertiesChanged\n        this.__dataPending[property] = value;\n        // Track properties that should notify separately\n        if (propIsPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {\n          this.__dataToNotify = this.__dataToNotify || {};\n          this.__dataToNotify[property] = shouldNotify;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Overrides base implementation to ensure all accessors set `shouldNotify`\n     * to true, for per-property notification tracking.\n     *\n     * @override\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Overrides `PropertyAccessor`'s default async queuing of\n     * `_propertiesChanged`: if `__dataReady` is false (has not yet been\n     * manually flushed), the function no-ops; otherwise flushes\n     * `_propertiesChanged` synchronously.\n     *\n     * @override\n     * @return {void}\n     */\n    _invalidateProperties() {\n      if (this.__dataReady) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Enqueues the given client on a list of pending clients, whose\n     * pending property changes can later be flushed via a call to\n     * `_flushClients`.\n     *\n     * @override\n     * @param {Object} client PropertyEffects client to enqueue\n     * @return {void}\n     * @protected\n     */\n    _enqueueClient(client) {\n      this.__dataPendingClients = this.__dataPendingClients || [];\n      if (client !== this) {\n        this.__dataPendingClients.push(client);\n      }\n    }\n\n    /**\n     * Flushes any clients previously enqueued via `_enqueueClient`, causing\n     * their `_flushProperties` method to run.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _flushClients() {\n      if (!this.__dataClientsReady) {\n        this.__dataClientsReady = true;\n        this._readyClients();\n        // Override point where accessors are turned on; importantly,\n        // this is after clients have fully readied, providing a guarantee\n        // that any property effects occur only after all clients are ready.\n        this.__dataReady = true;\n      } else {\n        this.__enableOrFlushClients();\n      }\n    }\n\n    // NOTE: We ensure clients either enable or flush as appropriate. This\n    // handles two corner cases:\n    // (1) clients flush properly when connected/enabled before the host\n    // enables; e.g.\n    //   (a) Templatize stamps with no properties and does not flush and\n    //   (b) the instance is inserted into dom and\n    //   (c) then the instance flushes.\n    // (2) clients enable properly when not connected/enabled when the host\n    // flushes; e.g.\n    //   (a) a template is runtime stamped and not yet connected/enabled\n    //   (b) a host sets a property, causing stamped dom to flush\n    //   (c) the stamped dom enables.\n    __enableOrFlushClients() {\n      let clients = this.__dataPendingClients;\n      if (clients) {\n        this.__dataPendingClients = null;\n        for (let i=0; i < clients.length; i++) {\n          let client = clients[i];\n          if (!client.__dataEnabled) {\n            client._enableProperties();\n          } else if (client.__dataPending) {\n            client._flushProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Perform any initial setup on client dom. Called before the first\n     * `_flushProperties` call on client dom and before any element\n     * observers are called.\n     *\n     * @override\n     * @return {void}\n     * @protected\n     */\n    _readyClients() {\n      this.__enableOrFlushClients();\n    }\n\n    /**\n     * Sets a bag of property changes to this instance, and\n     * synchronously processes all effects of the properties as a batch.\n     *\n     * Property names must be simple properties, not paths.  Batched\n     * path propagation is not supported.\n     *\n     * @override\n     * @param {Object} props Bag of one or more key-value pairs whose key is\n     *   a property and value is the new value to set for that property.\n     * @param {boolean=} setReadOnly When true, any private values set in\n     *   `props` will be set. By default, `setProperties` will not set\n     *   `readOnly: true` root properties.\n     * @return {void}\n     * @public\n     */\n    setProperties(props, setReadOnly) {\n      for (let path in props) {\n        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {\n          //TODO(kschaaf): explicitly disallow paths in setProperty?\n          // wildcard observers currently only pass the first changed path\n          // in the `info` object, and you could do some odd things batching\n          // paths, e.g. {'foo.bar': {...}, 'foo': null}\n          this._setPendingPropertyOrPath(path, props[path], true);\n        }\n      }\n      this._invalidateProperties();\n    }\n\n    /**\n     * Overrides `PropertyAccessors` so that property accessor\n     * side effects are not enabled until after client dom is fully ready.\n     * Also calls `_flushClients` callback to ensure client dom is enabled\n     * that was not enabled as a result of flushing properties.\n     *\n     * @override\n     * @return {void}\n     */\n    ready() {\n      // It is important that `super.ready()` is not called here as it\n      // immediately turns on accessors. Instead, we wait until `readyClients`\n      // to enable accessors to provide a guarantee that clients are ready\n      // before processing any accessors side effects.\n      this._flushProperties();\n      // If no data was pending, `_flushProperties` will not `flushClients`\n      // so ensure this is done.\n      if (!this.__dataClientsReady) {\n        this._flushClients();\n      }\n      // Before ready, client notifications do not trigger _flushProperties.\n      // Therefore a flush is necessary here if data has been set.\n      if (this.__dataPending) {\n        this._flushProperties();\n      }\n    }\n\n    /**\n     * Implements `PropertyAccessors`'s properties changed callback.\n     *\n     * Runs each class of effects for the batch of changed properties in\n     * a specific order (compute, propagate, reflect, observe, notify).\n     *\n     * @override\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) {\n      // ----------------------------\n      // let c = Object.getOwnPropertyNames(changedProps || {});\n      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);\n      // if (window.debug) { debugger; }\n      // ----------------------------\n      let hasPaths = this.__dataHasPaths;\n      this.__dataHasPaths = false;\n      let notifyProps;\n      // Compute properties\n      runComputedEffects(this, changedProps, oldProps, hasPaths);\n      // Clear notify properties prior to possible reentry (propagate, observe),\n      // but after computing effects have a chance to add to them\n      notifyProps = this.__dataToNotify;\n      this.__dataToNotify = null;\n      // Propagate properties to clients\n      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);\n      // Flush clients\n      this._flushClients();\n      // Reflect properties\n      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);\n      // Observe properties\n      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);\n      // Notify properties to host\n      if (notifyProps) {\n        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);\n      }\n      // Clear temporary cache at end of turn\n      if (this.__dataCounter == 1) {\n        this.__dataTemp = {};\n      }\n      // ----------------------------\n      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);\n      // ----------------------------\n    }\n\n    /**\n     * Called to propagate any property changes to stamped template nodes\n     * managed by this element.\n     *\n     * @override\n     * @param {Object} changedProps Bag of changed properties\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {void}\n     * @protected\n     */\n    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {\n      if (this[TYPES.PROPAGATE]) {\n        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);\n      }\n      if (this.__templateInfo) {\n        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);\n      }\n    }\n\n    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {\n      const baseRunEffects = (changedProps, hasPaths) => {\n        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,\n          hasPaths, templateInfo.nodeList);\n        for (let info=templateInfo.firstChild; info; info=info.nextSibling) {\n          this._runEffectsForTemplate(info, changedProps, oldProps, hasPaths);\n        }\n      };\n      if (templateInfo.runEffects) {\n        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);\n      } else {\n        baseRunEffects(changedProps, hasPaths);\n      }\n    }\n\n    /**\n     * Aliases one data path as another, such that path notifications from one\n     * are routed to the other.\n     *\n     * @override\n     * @param {string | !Array<string|number>} to Target path to link.\n     * @param {string | !Array<string|number>} from Source path to link.\n     * @return {void}\n     * @public\n     */\n    linkPaths(to, from) {\n      to = normalize(to);\n      from = normalize(from);\n      this.__dataLinkedPaths = this.__dataLinkedPaths || {};\n      this.__dataLinkedPaths[to] = from;\n    }\n\n    /**\n     * Removes a data path alias previously established with `_linkPaths`.\n     *\n     * Note, the path to unlink should be the target (`to`) used when\n     * linking the paths.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Target path to unlink.\n     * @return {void}\n     * @public\n     */\n    unlinkPaths(path) {\n      path = normalize(path);\n      if (this.__dataLinkedPaths) {\n        delete this.__dataLinkedPaths[path];\n      }\n    }\n\n    /**\n     * Notify that an array has changed.\n     *\n     * Example:\n     *\n     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];\n     *     ...\n     *     this.items.splice(1, 1, {name: 'Sam'});\n     *     this.items.push({name: 'Bob'});\n     *     this.notifySplices('items', [\n     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,\n     *         object: this.items, type: 'splice' },\n     *       { index: 3, removed: [], addedCount: 1,\n     *         object: this.items, type: 'splice'}\n     *     ]);\n     *\n     * @param {string} path Path that should be notified.\n     * @param {Array} splices Array of splice records indicating ordered\n     *   changes that occurred to the array. Each record should have the\n     *   following fields:\n     *    * index: index at which the change occurred\n     *    * removed: array of items that were removed from this index\n     *    * addedCount: number of new items added at this index\n     *    * object: a reference to the array in question\n     *    * type: the string literal 'splice'\n     *\n     *   Note that splice records _must_ be normalized such that they are\n     *   reported in index order (raw results from `Object.observe` are not\n     *   ordered and must be normalized/merged before notifying).\n     *\n     * @override\n     * @return {void}\n     * @public\n     */\n    notifySplices(path, splices) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      notifySplices(this, array, info.path, splices);\n    }\n\n    /**\n     * Convenience method for reading a value from a path.\n     *\n     * Note, if any part in the path is undefined, this method returns\n     * `undefined` (this method does not throw when dereferencing undefined\n     * paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `users.12.name` or `['users', 12, 'name']`).\n     * @param {Object=} root Root object from which the path is evaluated.\n     * @return {*} Value at the path, or `undefined` if any part of the path\n     *   is undefined.\n     * @public\n     */\n    get(path, root) {\n      return get(root || this, path);\n    }\n\n    /**\n     * Convenience method for setting a value to a path and notifying any\n     * elements bound to the same path.\n     *\n     * Note, if any part in the path except for the last is undefined,\n     * this method does nothing (this method does not throw when\n     * dereferencing undefined paths).\n     *\n     * @override\n     * @param {(string|!Array<(string|number)>)} path Path to the value\n     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)\n     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that\n     *   bracketed expressions are not supported; string-based path parts\n     *   *must* be separated by dots.  Note that when dereferencing array\n     *   indices, the index may be used as a dotted part directly\n     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).\n     * @param {*} value Value to set at the specified path.\n     * @param {Object=} root Root object from which the path is evaluated.\n     *   When specified, no notification will occur.\n     * @return {void}\n     * @public\n     */\n    set(path, value, root) {\n      if (root) {\n        set(root, path, value);\n      } else {\n        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {\n          if (this._setPendingPropertyOrPath(path, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n      }\n    }\n\n    /**\n     * Adds items onto the end of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to push onto array\n     * @return {number} New length of the array.\n     * @public\n     */\n    push(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array}*/(get(this, path, info));\n      let len = array.length;\n      let ret = array.push(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, len, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the end of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    pop(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.pop();\n      if (hadLength) {\n        notifySplice(this, array, info.path, array.length, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Starting from the start index specified, removes 0 or more items\n     * from the array and inserts 0 or more new items in their place.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.splice`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {number} start Index from which to start removing/inserting.\n     * @param {number=} deleteCount Number of items to remove.\n     * @param {...*} items Items to insert into array.\n     * @return {!Array} Array of removed items.\n     * @public\n     */\n    splice(path, start, deleteCount, ...items) {\n      let info = {path : ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      // Normalize fancy native splice handling of crazy start values\n      if (start < 0) {\n        start = array.length - Math.floor(-start);\n      } else if (start) {\n        start = Math.floor(start);\n      }\n      // array.splice does different things based on the number of arguments\n      // you pass in. Therefore, array.splice(0) and array.splice(0, undefined)\n      // do different things. In the former, the whole array is cleared. In the\n      // latter, no items are removed.\n      // This means that we need to detect whether 1. one of the arguments\n      // is actually passed in and then 2. determine how many arguments\n      // we should pass on to the native array.splice\n      //\n      let ret;\n      // Omit any additional arguments if they were not passed in\n      if (arguments.length === 2) {\n        ret = array.splice(start);\n      // Either start was undefined and the others were defined, but in this\n      // case we can safely pass on all arguments\n      //\n      // Note: this includes the case where none of the arguments were passed in,\n      // e.g. this.splice('array'). However, if both start and deleteCount\n      // are undefined, array.splice will not modify the array (as expected)\n      } else {\n        ret = array.splice(start, deleteCount, ...items);\n      }\n      // At the end, check whether any items were passed in (e.g. insertions)\n      // or if the return array contains items (e.g. deletions).\n      // Only notify if items were added or deleted.\n      if (items.length || ret.length) {\n        notifySplice(this, array, info.path, start, items.length, ret);\n      }\n      return ret;\n    }\n\n    /**\n     * Removes an item from the beginning of array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.pop`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @return {*} Item that was removed.\n     * @public\n     */\n    shift(path) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let hadLength = Boolean(array.length);\n      let ret = array.shift();\n      if (hadLength) {\n        notifySplice(this, array, info.path, 0, 0, [ret]);\n      }\n      return ret;\n    }\n\n    /**\n     * Adds items onto the beginning of the array at the path specified.\n     *\n     * The arguments after `path` and return value match that of\n     * `Array.prototype.push`.\n     *\n     * This method notifies other paths to the same array that a\n     * splice occurred to the array.\n     *\n     * @override\n     * @param {string | !Array<string|number>} path Path to array.\n     * @param {...*} items Items to insert info array\n     * @return {number} New length of the array.\n     * @public\n     */\n    unshift(path, ...items) {\n      let info = {path: ''};\n      let array = /** @type {Array} */(get(this, path, info));\n      let ret = array.unshift(...items);\n      if (items.length) {\n        notifySplice(this, array, info.path, 0, items.length, []);\n      }\n      return ret;\n    }\n\n    /**\n     * Notify that a path has changed.\n     *\n     * Example:\n     *\n     *     this.item.user.name = 'Bob';\n     *     this.notifyPath('item.user.name');\n     *\n     * @override\n     * @param {string} path Path that should be notified.\n     * @param {*=} value Value at the path (optional).\n     * @return {void}\n     * @public\n     */\n    notifyPath(path, value) {\n      /** @type {string} */\n      let propPath;\n      if (arguments.length == 1) {\n        // Get value if not supplied\n        let info = {path: ''};\n        value = get(this, path, info);\n        propPath = info.path;\n      } else if (Array.isArray(path)) {\n        // Normalize path if needed\n        propPath = normalize(path);\n      } else {\n        propPath = /** @type{string} */(path);\n      }\n      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Equivalent to static `createReadOnlyProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     */\n    _createReadOnlyProperty(property, protectedSetter) {\n      this._addPropertyEffect(property, TYPES.READ_ONLY);\n      if (protectedSetter) {\n        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {\n          this._setProperty(property, value);\n        };\n      }\n    }\n\n    /**\n     * Equivalent to static `createPropertyObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method\n     *     to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createPropertyObserver(property, method, dynamicFn) {\n      let info = { property, method, dynamicFn: Boolean(dynamicFn) };\n      this._addPropertyEffect(property, TYPES.OBSERVE, {\n        fn: runObserverEffect, info, trigger: {name: property}\n      });\n      if (dynamicFn) {\n        this._addPropertyEffect(/** @type {string} */(method), TYPES.OBSERVE, {\n          fn: runObserverEffect, info, trigger: {name: method}\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createMethodObserver` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createMethodObserver(expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed observer expression '\" + expression + \"'\");\n      }\n      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);\n    }\n\n    /**\n     * Equivalent to static `createNotifyingProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     */\n    _createNotifyingProperty(property) {\n      this._addPropertyEffect(property, TYPES.NOTIFY, {\n        fn: runNotifyEffect,\n        info: {\n          eventName: camelToDashCase(property) + '-changed',\n          property: property\n        }\n      });\n    }\n\n    /**\n     * Equivalent to static `createReflectedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _createReflectedProperty(property) {\n      let attr = this.constructor.attributeNameForProperty(property);\n      if (attr[0] === '-') {\n        console.warn('Property ' + property + ' cannot be reflected to attribute ' +\n          attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');\n      } else {\n        this._addPropertyEffect(property, TYPES.REFLECT, {\n          fn: runReflectEffect,\n          info: {\n            attrName: attr\n          }\n        });\n      }\n    }\n\n    /**\n     * Equivalent to static `createComputedProperty` API but can be called on\n     * an instance to add effects at runtime.  See that method for\n     * full API docs.\n     *\n     * @override\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     *   whether method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     */\n    _createComputedProperty(property, expression, dynamicFn) {\n      let sig = parseMethod(expression);\n      if (!sig) {\n        throw new Error(\"Malformed computed expression '\" + expression + \"'\");\n      }\n      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);\n      // Effects are normally stored as map of dependency->effect, but for\n      // ordered computation, we also need tree of computedProp->dependencies\n      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;\n    }\n\n    /**\n     * Gather the argument values for a method specified in the provided array\n     * of argument metadata.\n     *\n     * The `path` and `value` arguments are used to fill in wildcard descriptor\n     * when the method is being called as a result of a path notification.\n     *\n     * @param {!Array<!MethodArg>} args Array of argument metadata\n     * @param {string} path Property/path name that triggered the method effect\n     * @param {Object} props Bag of current property changes\n     * @return {!Array<*>} Array of argument values\n     * @private\n     */\n    _marshalArgs(args, path, props) {\n      const data = this.__data;\n      const values = [];\n      for (let i=0, l=args.length; i<l; i++) {\n        let {name, structured, wildcard, value, literal} = args[i];\n        if (!literal) {\n          if (wildcard) {\n            const matches = isDescendant(name, path);\n            const pathValue = getArgValue(data, props, matches ? path : name);\n            value = {\n              path: matches ? path : name,\n              value: pathValue,\n              base: matches ? get(data, name) : pathValue\n            };\n          } else {\n            value = structured ? getArgValue(data, props, name) : data[name];\n          }\n        }\n        // When the `legacyUndefined` flag is enabled, pass a no-op value\n        // so that the observer, computed property, or compound binding is aborted.\n        if (legacyUndefined && !this._overrideLegacyUndefined && value === undefined && args.length > 1) {\n          return NOOP;\n        }\n        values[i] = value;\n      }\n      return values;\n    }\n\n    // -- static class methods ------------\n\n    /**\n     * Ensures an accessor exists for the specified property, and adds\n     * to a list of \"property effects\" that will run when the accessor for\n     * the specified property is set.  Effects are grouped by \"type\", which\n     * roughly corresponds to a phase in effect processing.  The effect\n     * metadata should be in the following form:\n     *\n     *     {\n     *       fn: effectFunction, // Reference to function to call to perform effect\n     *       info: { ... }       // Effect metadata passed to function\n     *       trigger: {          // Optional triggering metadata; if not provided\n     *         name: string      // the property is treated as a wildcard\n     *         structured: boolean\n     *         wildcard: boolean\n     *       }\n     *     }\n     *\n     * Effects are called from `_propertiesChanged` in the following order by\n     * type:\n     *\n     * 1. COMPUTE\n     * 2. PROPAGATE\n     * 3. REFLECT\n     * 4. OBSERVE\n     * 5. NOTIFY\n     *\n     * Effect functions are called with the following signature:\n     *\n     *     effectFunction(inst, path, props, oldProps, info, hasPaths)\n     *\n     * @param {string} property Property that should trigger the effect\n     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static addPropertyEffect(property, type, effect) {\n      this.prototype._addPropertyEffect(property, type, effect);\n    }\n\n    /**\n     * Creates a single-property observer for the given property.\n     *\n     * @param {string} property Property name\n     * @param {string|function(*,*)} method Function or name of observer method to call\n     * @param {boolean=} dynamicFn Whether the method name should be included as\n     *   a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createPropertyObserver(property, method, dynamicFn) {\n      this.prototype._createPropertyObserver(property, method, dynamicFn);\n    }\n\n    /**\n     * Creates a multi-property \"method observer\" based on the provided\n     * expression, which should be a string in the form of a normal JavaScript\n     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument\n     * should correspond to a property or path in the context of this\n     * prototype (or instance), or may be a literal string or number.\n     *\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating\n     * @return {void}\n     *   whether method names should be included as a dependency to the effect.\n     * @protected\n     * @nocollapse\n     */\n    static createMethodObserver(expression, dynamicFn) {\n      this.prototype._createMethodObserver(expression, dynamicFn);\n    }\n\n    /**\n     * Causes the setter for the given property to dispatch `<property>-changed`\n     * events to notify of changes to the property.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createNotifyingProperty(property) {\n      this.prototype._createNotifyingProperty(property);\n    }\n\n    /**\n     * Creates a read-only accessor for the given property.\n     *\n     * To set the property, use the protected `_setProperty` API.\n     * To create a custom protected setter (e.g. `_setMyProp()` for\n     * property `myProp`), pass `true` for `protectedSetter`.\n     *\n     * Note, if the property will have other property effects, this method\n     * should be called first, before adding other effects.\n     *\n     * @param {string} property Property name\n     * @param {boolean=} protectedSetter Creates a custom protected setter\n     *   when `true`.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReadOnlyProperty(property, protectedSetter) {\n      this.prototype._createReadOnlyProperty(property, protectedSetter);\n    }\n\n    /**\n     * Causes the setter for the given property to reflect the property value\n     * to a (dash-cased) attribute of the same name.\n     *\n     * @param {string} property Property name\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createReflectedProperty(property) {\n      this.prototype._createReflectedProperty(property);\n    }\n\n    /**\n     * Creates a computed property whose value is set to the result of the\n     * method described by the given `expression` each time one or more\n     * arguments to the method changes.  The expression should be a string\n     * in the form of a normal JavaScript function signature:\n     * `'methodName(arg1, [..., argn])'`\n     *\n     * @param {string} property Name of computed property to set\n     * @param {string} expression Method expression\n     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether\n     *   method names should be included as a dependency to the effect.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createComputedProperty(property, expression, dynamicFn) {\n      this.prototype._createComputedProperty(property, expression, dynamicFn);\n    }\n\n    /**\n     * Parses the provided template to ensure binding effects are created\n     * for them, and then ensures property accessors are created for any\n     * dependent properties in the template.  Binding effects for bound\n     * templates are stored in a linked list on the instance so that\n     * templates can be efficiently stamped and unstamped.\n     *\n     * @param {!HTMLTemplateElement} template Template containing binding\n     *   bindings\n     * @return {!TemplateInfo} Template metadata object\n     * @protected\n     * @nocollapse\n     */\n    static bindTemplate(template) {\n      return this.prototype._bindTemplate(template);\n    }\n\n    // -- binding ----------------------------------------------\n\n    /*\n     * Overview of binding flow:\n     *\n     * During finalization (`instanceBinding==false`, `wasPreBound==false`):\n     *  `_bindTemplate(t, false)` called directly during finalization - parses\n     *  the template (for the first time), and then assigns that _prototypical_\n     *  template info to `__preboundTemplateInfo` _on the prototype_; note in\n     *  this case `wasPreBound` is false; this is the first time we're binding\n     *  it, thus we create accessors.\n     *\n     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):\n     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`\n     *   returned matches the prebound one, and so this is `wasPreBound == true`\n     *   state; thus we _skip_ creating accessors, but _do_ create an instance\n     *   of the template info to serve as the start of our linked list (needs to\n     *   be an instance, not the prototypical one, so that we can add `nodeList`\n     *   to it to contain the `nodeInfo`-ordered list of instance nodes for\n     *   bindings, and so we can chain runtime-stamped template infos off of\n     *   it). At this point, the call to `_stampTemplate` calls\n     *   `applyTemplateInfo` for each nested `<template>` found during parsing\n     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_\n     *   `templateInfo` to the `<template>` so that we have the instance-time\n     *   parent to link the `templateInfo` under in the case it was\n     *   runtime-stamped.\n     *\n     * During subsequent runtime stamping (`instanceBinding==true`,\n     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`\n     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,\n     *   because it was either a different template altogether, or even if it\n     *   was the same template, the step above created a instance of the info;\n     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_\n     *   link a instance into the linked list.\n     */\n\n    /**\n     * Equivalent to static `bindTemplate` API but can be called on an instance\n     * to add effects at runtime.  See that method for full API docs.\n     *\n     * This method may be called on the prototype (for prototypical template\n     * binding, to avoid creating accessors every instance) once per prototype,\n     * and will be called with `runtimeBinding: true` by `_stampTemplate` to\n     * create and link an instance of the template metadata associated with a\n     * particular stamping.\n     *\n     * @override\n     * @param {!HTMLTemplateElement} template Template containing binding\n     * bindings\n     * @param {boolean=} instanceBinding When false (default), performs\n     * \"prototypical\" binding of the template and overwrites any previously\n     * bound template for the class. When true (as passed from\n     * `_stampTemplate`), the template info is instanced and linked into the\n     * list of bound templates.\n     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,\n     * this is an instance of the prototypical template info\n     * @protected\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    _bindTemplate(template, instanceBinding) {\n      let templateInfo = this.constructor._parseTemplate(template);\n      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;\n      // Optimization: since this is called twice for proto-bound templates,\n      // don't attempt to recreate accessors if this template was pre-bound\n      if (!wasPreBound) {\n        for (let prop in templateInfo.propertyEffects) {\n          this._createPropertyAccessor(prop);\n        }\n      }\n      if (instanceBinding) {\n        // For instance-time binding, create instance of template metadata\n        // and link into tree of templates if necessary\n        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));\n        templateInfo.wasPreBound = wasPreBound;\n        if (!this.__templateInfo) {\n          // Set the info to the root of the tree\n          this.__templateInfo = templateInfo;\n        } else {\n          // Append this template info onto the end of its parent template's\n          // list, which will determine the tree structure via which property\n          // effects are run; if this template was not nested in another\n          // template, use the root template (the first stamped one) as the\n          // parent. Note, `parent` is the `templateInfo` instance for this\n          // template's parent (containing) template, which was set up in\n          // `applyTemplateInfo`.  While a given template's `parent` is set\n          // apriori, it is only added to the parent's child list at the point\n          // that it is being bound, since a template may or may not ever be\n          // stamped, and may be stamped more than once (in which case instances\n          // of the template info will be in the tree under its parent more than\n          // once).\n          const parent = template._parentTemplateInfo || this.__templateInfo;\n          const previous = parent.lastChild;\n          templateInfo.parent = parent;\n          parent.lastChild = templateInfo;\n          templateInfo.previousSibling = previous;\n          if (previous) {\n            previous.nextSibling = templateInfo;\n          } else {\n            parent.firstChild = templateInfo;\n          }\n        }\n      } else {\n        this.__preBoundTemplateInfo = templateInfo;\n      }\n      return templateInfo;\n    }\n\n    /**\n     * Adds a property effect to the given template metadata, which is run\n     * at the \"propagate\" stage of `_propertiesChanged` when the template\n     * has been bound to the element via `_bindTemplate`.\n     *\n     * The `effect` object should match the format in `_addPropertyEffect`.\n     *\n     * @param {Object} templateInfo Template metadata to add effect to\n     * @param {string} prop Property that should trigger the effect\n     * @param {Object=} effect Effect metadata object\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static _addTemplatePropertyEffect(templateInfo, prop, effect) {\n      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};\n      hostProps[prop] = true;\n      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};\n      let propEffects = effects[prop] = effects[prop] || [];\n      propEffects.push(effect);\n    }\n\n    /**\n     * Stamps the provided template and performs instance-time setup for\n     * Polymer template features, including data bindings, declarative event\n     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment\n     * is returned containing the stamped DOM, ready for insertion into the\n     * DOM.\n     *\n     * This method may be called more than once; however note that due to\n     * `shadycss` polyfill limitations, only styles from templates prepared\n     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped\n     * to the shadow root and support CSS custom properties), and note that\n     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,\n     * any styles required by in runtime-stamped templates must be included\n     * in the main element template.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional bound template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically bound.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     * @protected\n     */\n    _stampTemplate(template, templateInfo) {\n      templateInfo =  templateInfo || /** @type {!TemplateInfo} */(this._bindTemplate(template, true));\n      // Ensures that created dom is `_enqueueClient`'d to this element so\n      // that it can be flushed on next call to `_flushProperties`\n      hostStack.push(this);\n      let dom = super._stampTemplate(template, templateInfo);\n      hostStack.pop();\n      // Add template-instance-specific data to instanced templateInfo\n      templateInfo.nodeList = dom.nodeList;\n      // Capture child nodes to allow unstamping of non-prototypical templates\n      if (!templateInfo.wasPreBound) {\n        let nodes = templateInfo.childNodes = [];\n        for (let n=dom.firstChild; n; n=n.nextSibling) {\n          nodes.push(n);\n        }\n      }\n      dom.templateInfo = templateInfo;\n      // Setup compound storage, 2-way listeners, and dataHost for bindings\n      setupBindings(this, templateInfo);\n      // Flush properties into template nodes; the check on `__dataClientsReady`\n      // ensures we don't needlessly run effects for an element's initial\n      // prototypical template stamping since they will happen as a part of the\n      // first call to `_propertiesChanged`. This flag is set to true\n      // after running the initial propagate effects, and immediately before\n      // flushing clients. Since downstream clients could cause stamping on\n      // this host (e.g. a fastDomIf `dom-if` being forced to render\n      // synchronously), this flag ensures effects for runtime-stamped templates\n      // are run at this point during the initial element boot-up.\n      if (this.__dataClientsReady) {\n        this._runEffectsForTemplate(templateInfo, this.__data, null, false);\n        this._flushClients();\n      }\n      return dom;\n    }\n\n    /**\n     * Removes and unbinds the nodes previously contained in the provided\n     * DocumentFragment returned from `_stampTemplate`.\n     *\n     * @override\n     * @param {!StampedTemplate} dom DocumentFragment previously returned\n     *   from `_stampTemplate` associated with the nodes to be removed\n     * @return {void}\n     * @protected\n     */\n    _removeBoundDom(dom) {\n      // Unlink template info; Note that while the child is unlinked from its\n      // parent list, a template's `parent` reference is never removed, since\n      // this is is determined by the tree structure and applied at\n      // `applyTemplateInfo` time.\n      const templateInfo = dom.templateInfo;\n      const {previousSibling, nextSibling, parent} = templateInfo;\n      if (previousSibling) {\n        previousSibling.nextSibling = nextSibling;\n      } else if (parent) {\n        parent.firstChild = nextSibling;\n      }\n      if (nextSibling) {\n        nextSibling.previousSibling = previousSibling;\n      } else if (parent) {\n        parent.lastChild = previousSibling;\n      }\n      templateInfo.nextSibling = templateInfo.previousSibling = null;\n      // Remove stamped nodes\n      let nodes = templateInfo.childNodes;\n      for (let i=0; i<nodes.length; i++) {\n        let node = nodes[i];\n        wrap(wrap(node).parentNode).removeChild(node);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNode.call(\n        this, node, templateInfo, nodeInfo);\n      if (node.nodeType === Node.TEXT_NODE) {\n        let parts = this._parseBindings(node.textContent, templateInfo);\n        if (parts) {\n          // Initialize the textContent with any literal parts\n          // NOTE: default to a space here so the textNode remains; some browsers\n          // (IE) omit an empty textNode following cloneNode/importNode.\n          node.textContent = literalFromParts(parts) || ' ';\n          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);\n          noted = true;\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * parsing bindings from attributes.  A `bindings`\n     * array is added to `nodeInfo` and populated with binding metadata\n     * with information capturing the binding target, and a `parts` array\n     * with one or more metadata objects capturing the source(s) of the\n     * binding.\n     *\n     * @param {Element} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      let parts = this._parseBindings(value, templateInfo);\n      if (parts) {\n        // Attribute or property\n        let origName = name;\n        let kind = 'property';\n        // The only way we see a capital letter here is if the attr has\n        // a capital letter in it per spec. In this case, to make sure\n        // this binding works, we go ahead and make the binding to the attribute.\n        if (capitalAttributeRegex.test(name)) {\n          kind = 'attribute';\n        } else if (name[name.length-1] == '$') {\n          name = name.slice(0, -1);\n          kind = 'attribute';\n        }\n        // Initialize attribute bindings with any literal parts\n        let literal = literalFromParts(parts);\n        if (literal && kind == 'attribute') {\n          // Ensure a ShadyCSS template scoped style is not removed\n          // when a class$ binding's initial literal value is set.\n          if (name == 'class' && node.hasAttribute('class')) {\n            literal += ' ' + node.getAttribute(name);\n          }\n          node.setAttribute(name, literal);\n        }\n        // support disable-upgrade\n        if (kind == 'attribute' && origName == 'disable-upgrade$') {\n          node.setAttribute(name, '');\n        }\n        // Clear attribute before removing, since IE won't allow removing\n        // `value` attribute if it previously had a value (can't\n        // unconditionally set '' before removing since attributes with `$`\n        // can't be set using setAttribute)\n        if (node.localName === 'input' && origName === 'value') {\n          node.setAttribute(origName, '');\n        }\n        // Remove annotation\n        node.removeAttribute(origName);\n        // Case hackery: attributes are lower-case, but bind targets\n        // (properties) are case sensitive. Gambit is to map dash-case to\n        // camel-case: `foo-bar` becomes `fooBar`.\n        // Attribute bindings are excepted.\n        if (kind === 'property') {\n          name = dashToCamelCase(name);\n        }\n        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);\n        return true;\n      } else {\n        // TODO(https://github.com/google/closure-compiler/issues/3240):\n        //     Change back to just super.methodCall()\n        return propertyEffectsBase._parseTemplateNodeAttribute.call(\n          this, node, templateInfo, nodeInfo, name, value);\n      }\n    }\n\n    /**\n     * Overrides default `TemplateStamp` implementation to add support for\n     * binding the properties that a nested template depends on to the template\n     * as `_host_<property>`.\n     *\n     * @param {Node} node Node to parse\n     * @param {TemplateInfo} templateInfo Template metadata for current template\n     * @param {NodeInfo} nodeInfo Node metadata for current template node\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @protected\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(\n        this, node, templateInfo, nodeInfo);\n      const parent = node.parentNode;\n      const nestedTemplateInfo = nodeInfo.templateInfo;\n      const isDomIf = parent.localName === 'dom-if';\n      const isDomRepeat = parent.localName === 'dom-repeat';\n      // Remove nested template and redirect its host bindings & templateInfo\n      // onto the parent (dom-if/repeat element)'s nodeInfo\n      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {\n        parent.removeChild(node);\n        // Use the parent's nodeInfo (for the dom-if/repeat) to record the\n        // templateInfo, and use that for any host property bindings below\n        nodeInfo = nodeInfo.parentInfo;\n        nodeInfo.templateInfo = nestedTemplateInfo;\n        // Ensure the parent dom-if/repeat is noted since it now may have host\n        // bindings; it may not have been if it did not have its own bindings\n        nodeInfo.noted = true;\n        noted = false;\n      }\n      // Merge host props into outer template and add bindings\n      let hostProps = nestedTemplateInfo.hostProps;\n      if (fastDomIf && isDomIf) {\n        // `fastDomIf` mode uses runtime-template stamping to add accessors/\n        // effects to properties used in its template; as such we don't need to\n        // tax the host element with `_host_` bindings for the `dom-if`.\n        // However, in the event it is nested in a `dom-repeat`, it is still\n        // important that its host properties are added to the\n        // TemplateInstance's `hostProps` so that they are forwarded to the\n        // TemplateInstance.\n        if (hostProps) {\n          templateInfo.hostProps =\n            Object.assign(templateInfo.hostProps || {}, hostProps);\n          // Ensure the dom-if is noted so that it has a __dataHost, since\n          // `fastDomIf` uses the host for runtime template stamping; note this\n          // was already ensured above in the `removeNestedTemplates` case\n          if (!removeNestedTemplates) {\n            nodeInfo.parentInfo.noted = true;\n          }\n        }\n      } else {\n        let mode = '{';\n        for (let source in hostProps) {\n          let parts = [{ mode, source, dependencies: [source], hostProp: true }];\n          addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);\n        }\n      }\n      return noted;\n    }\n\n    /**\n     * Called to parse text in a template (either attribute values or\n     * textContent) into binding metadata.\n     *\n     * Any overrides of this method should return an array of binding part\n     * metadata  representing one or more bindings found in the provided text\n     * and any \"literal\" text in between.  Any non-literal parts will be passed\n     * to `_evaluateBinding` when any dependencies change.  The only required\n     * fields of each \"part\" in the returned array are as follows:\n     *\n     * - `dependencies` - Array containing trigger metadata for each property\n     *   that should trigger the binding to update\n     * - `literal` - String containing text if the part represents a literal;\n     *   in this case no `dependencies` are needed\n     *\n     * Additional metadata for use by `_evaluateBinding` may be provided in\n     * each part object as needed.\n     *\n     * The default implementation handles the following types of bindings\n     * (one or more may be intermixed with literal strings):\n     * - Property binding: `[[prop]]`\n     * - Path binding: `[[object.prop]]`\n     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`\n     * - Two-way property or path bindings (supports negation):\n     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`\n     * - Inline computed method (supports negation):\n     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`\n     *\n     * The default implementation uses a regular expression for best\n     * performance. However, the regular expression uses a white-list of\n     * allowed characters in a data-binding, which causes problems for\n     * data-bindings that do use characters not in this white-list.\n     *\n     * Instead of updating the white-list with all allowed characters,\n     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)\n     * that uses a state machine instead. This state machine is able to handle\n     * all characters. However, it is slightly less performant, therefore we\n     * extracted it into a separate optional mixin.\n     *\n     * @param {string} text Text to parse from attribute or textContent\n     * @param {Object} templateInfo Current template metadata\n     * @return {Array<!BindingPart>} Array of binding part metadata\n     * @protected\n     * @nocollapse\n     */\n    static _parseBindings(text, templateInfo) {\n      let parts = [];\n      let lastIndex = 0;\n      let m;\n      // Example: \"literal1{{prop}}literal2[[!compute(foo,bar)]]final\"\n      // Regex matches:\n      //        Iteration 1:  Iteration 2:\n      // m[1]: '{{'          '[['\n      // m[2]: ''            '!'\n      // m[3]: 'prop'        'compute(foo,bar)'\n      while ((m = bindingRegex.exec(text)) !== null) {\n        // Add literal part\n        if (m.index > lastIndex) {\n          parts.push({literal: text.slice(lastIndex, m.index)});\n        }\n        // Add binding part\n        let mode = m[1][0];\n        let negate = Boolean(m[2]);\n        let source = m[3].trim();\n        let customEvent = false, notifyEvent = '', colon = -1;\n        if (mode == '{' && (colon = source.indexOf('::')) > 0) {\n          notifyEvent = source.substring(colon + 2);\n          source = source.substring(0, colon);\n          customEvent = true;\n        }\n        let signature = parseMethod(source);\n        let dependencies = [];\n        if (signature) {\n          // Inline computed function\n          let {args, methodName} = signature;\n          for (let i=0; i<args.length; i++) {\n            let arg = args[i];\n            if (!arg.literal) {\n              dependencies.push(arg);\n            }\n          }\n          let dynamicFns = templateInfo.dynamicFns;\n          if (dynamicFns && dynamicFns[methodName] || signature.static) {\n            dependencies.push(methodName);\n            signature.dynamicFn = true;\n          }\n        } else {\n          // Property or path\n          dependencies.push(source);\n        }\n        parts.push({\n          source, mode, negate, customEvent, signature, dependencies,\n          event: notifyEvent\n        });\n        lastIndex = bindingRegex.lastIndex;\n      }\n      // Add a final literal part\n      if (lastIndex && lastIndex < text.length) {\n        let literal = text.substring(lastIndex);\n        if (literal) {\n          parts.push({\n            literal: literal\n          });\n        }\n      }\n      if (parts.length) {\n        return parts;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Called to evaluate a previously parsed binding part based on a set of\n     * one or more changed dependencies.\n     *\n     * @param {!Polymer_PropertyEffects} inst Element that should be used as\n     *     scope for binding dependencies\n     * @param {BindingPart} part Binding part metadata\n     * @param {string} path Property/path that triggered this effect\n     * @param {Object} props Bag of current property changes\n     * @param {Object} oldProps Bag of previous values for changed properties\n     * @param {boolean} hasPaths True with `props` contains one or more paths\n     * @return {*} Value the binding part evaluated to\n     * @protected\n     * @nocollapse\n     */\n    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {\n      let value;\n      if (part.signature) {\n        value = runMethodEffect(inst, path, props, oldProps, part.signature);\n      } else if (path != part.source) {\n        value = get(inst, part.source);\n      } else {\n        if (hasPaths && isPath(path)) {\n          value = get(inst, path);\n        } else {\n          value = inst.__data[path];\n        }\n      }\n      if (part.negate) {\n        value = !value;\n      }\n      return value;\n    }\n\n  }\n\n  return PropertyEffects;\n});\n\n/**\n * Stack for enqueuing client dom created by a host element.\n *\n * By default elements are flushed via `_flushProperties` when\n * `connectedCallback` is called. Elements attach their client dom to\n * themselves at `ready` time which results from this first flush.\n * This provides an ordering guarantee that the client dom an element\n * creates is flushed before the element itself (i.e. client `ready`\n * fires before host `ready`).\n *\n * However, if `_flushProperties` is called *before* an element is connected,\n * as for example `Templatize` does, this ordering guarantee cannot be\n * satisfied because no elements are connected. (Note: Bound elements that\n * receive data do become enqueued clients and are properly ordered but\n * unbound elements are not.)\n *\n * To maintain the desired \"client before host\" ordering guarantee for this\n * case we rely on the \"host stack. Client nodes registers themselves with\n * the creating host element when created. This ensures that all client dom\n * is readied in the proper order, maintaining the desired guarantee.\n *\n * @private\n */\nconst hostStack = [];\n"],"mappings":"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AAE1M,KAAK,EAAEgU,OAAO,GAAG/S,IAAI,GAAGE,IAAI,CAAC;cACjEqB,KAAK,GAAG;gBACNvB,IAAI,EAAE+S,OAAO,GAAG/S,IAAI,GAAGE,IAAI;gBAC3BqB,KAAK,EAAEyR,SAAS;gBAChBC,IAAI,EAAEF,OAAO,GAAG3W,KAAG,CAACqP,IAAI,EAAEvL,IAAI,CAAC,GAAG8S;cACpC,CAAC;YACH,CAAC,MAAM;cACLzR,KAAK,GAAGpB,UAAU,GAAGqL,WAAW,CAACC,IAAI,EAAE1M,KAAK,EAAEmB,IAAI,CAAC,GAAGuL,IAAI,CAACvL,IAAI,CAAC;YAClE;UACF;UACA;UACA;UACA,IAAIpD,eAAe,IAAI,CAAC,IAAI,CAACiP,wBAAwB,IAAIxK,KAAK,KAAKM,SAAS,IAAIsD,IAAI,CAACxG,MAAM,GAAG,CAAC,EAAE;YAC/F,OAAOxB,IAAI;UACb;UACA0V,MAAM,CAACjU,CAAC,CAAC,GAAG2C,KAAK;QACnB;QACA,OAAOsR,MAAM;MACf;;MAEA;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IApCI;MAAA/E,GAAA;MAAAvM,KAAA;MA6JA;;MAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;MAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACI,SAAA2R,cAAcC,QAAQ,EAAEC,eAAe,EAAE;QACvC,IAAInN,YAAY,GAAG,IAAI,CAACjC,WAAW,CAACqP,cAAc,CAACF,QAAQ,CAAC;QAC5D,IAAIG,WAAW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"},"metadata":{},"sourceType":"module","externalDependencies":[]}