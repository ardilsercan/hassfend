{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { nextRender } from \"../common/util/render-status\";\nimport \"./ha-alert\";\nlet HaHLSPlayer = _decorate([customElement(\"ha-hls-player\")], function (_initialize, _LitElement) {\n  class HaHLSPlayer extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaHLSPlayer,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"url\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"posterUrl\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"controls\"\n      })],\n      key: \"controls\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"muted\"\n      })],\n      key: \"muted\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"autoplay\"\n      })],\n      key: \"autoPlay\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"playsinline\"\n      })],\n      key: \"playsInline\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"allow-exoplayer\"\n      })],\n      key: \"allowExoPlayer\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [query(\"video\")],\n      key: \"_videoEl\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_error\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_errorIsFatal\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_hlsPolyfillInstance\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_exoPlayer\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      static: true,\n      key: \"streamCount\",\n      value() {\n        return 0;\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value:\n      // don't cache this, as we remove it on disconnects\n\n      function connectedCallback() {\n        _get(_getPrototypeOf(HaHLSPlayer.prototype), \"connectedCallback\", this).call(this);\n        HaHLSPlayer.streamCount += 1;\n        if (this.hasUpdated) {\n          this._resetError();\n          this._startHls();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaHLSPlayer.prototype), \"disconnectedCallback\", this).call(this);\n        HaHLSPlayer.streamCount -= 1;\n        this._cleanUp();\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return html`\n      ${this._error ? html`<ha-alert\n            alert-type=\"error\"\n            class=${this._errorIsFatal ? \"fatal\" : \"retry\"}\n          >\n            ${this._error}\n          </ha-alert>` : \"\"}\n      ${!this._errorIsFatal ? html`<video\n            .poster=${this.posterUrl}\n            ?autoplay=${this.autoPlay}\n            .muted=${this.muted}\n            ?playsinline=${this.playsInline}\n            ?controls=${this.controls}\n            @loadeddata=${this._loadedData}\n          ></video>` : \"\"}\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value: function updated(changedProps) {\n        _get(_getPrototypeOf(HaHLSPlayer.prototype), \"updated\", this).call(this, changedProps);\n        const urlChanged = changedProps.has(\"url\");\n        if (!urlChanged) {\n          return;\n        }\n        this._cleanUp();\n        this._resetError();\n        this._startHls();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_startHls\",\n      value: async function _startHls() {\n        var _this$hass$auth$exter;\n        const masterPlaylistPromise = fetch(this.url);\n        const Hls = (await import(\"hls.js/dist/hls.light.mjs\")).default;\n        if (!this.isConnected) {\n          return;\n        }\n        let hlsSupported = Hls.isSupported();\n        if (!hlsSupported) {\n          hlsSupported = this._videoEl.canPlayType(\"application/vnd.apple.mpegurl\") !== \"\";\n        }\n        if (!hlsSupported) {\n          this._setFatalError(this.hass.localize(\"ui.components.media-browser.video_not_supported\"));\n          return;\n        }\n        const useExoPlayer = this.allowExoPlayer && ((_this$hass$auth$exter = this.hass.auth.external) === null || _this$hass$auth$exter === void 0 ? void 0 : _this$hass$auth$exter.config.hasExoPlayer);\n        const masterPlaylist = await (await masterPlaylistPromise).text();\n        if (!this.isConnected) {\n          return;\n        }\n\n        // Parse playlist assuming it is a master playlist. Match group 1 is whether hevc, match group 2 is regular playlist url\n        // See https://tools.ietf.org/html/rfc8216 for HLS spec details\n        const playlistRegexp = /#EXT-X-STREAM-INF:.*?(?:CODECS=\".*?(hev1|hvc1)?\\..*?\".*?)?(?:\\n|\\r\\n)(.+)/g;\n        const match = playlistRegexp.exec(masterPlaylist);\n        const matchTwice = playlistRegexp.exec(masterPlaylist);\n\n        // Get the regular playlist url from the input (master) playlist, falling back to the input playlist if necessary\n        // This avoids the player having to load and parse the master playlist again before loading the regular playlist\n        let playlist_url;\n        if (match !== null && matchTwice === null) {\n          // Only send the regular playlist url if we match exactly once\n          playlist_url = new URL(match[2], this.url).href;\n        } else {\n          playlist_url = this.url;\n        }\n\n        // If codec is HEVC and ExoPlayer is supported, use ExoPlayer.\n        if (useExoPlayer && match !== null && match[1] !== undefined) {\n          this._renderHLSExoPlayer(playlist_url);\n        } else if (Hls.isSupported()) {\n          this._renderHLSPolyfill(this._videoEl, Hls, playlist_url);\n        } else {\n          this._renderHLSNative(this._videoEl, playlist_url);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_renderHLSExoPlayer\",\n      value: async function _renderHLSExoPlayer(url) {\n        this._exoPlayer = true;\n        window.addEventListener(\"resize\", this._resizeExoPlayer);\n        this.updateComplete.then(() => nextRender()).then(this._resizeExoPlayer);\n        this._videoEl.style.visibility = \"hidden\";\n        await this.hass.auth.external.fireMessage({\n          type: \"exoplayer/play_hls\",\n          payload: {\n            url: new URL(url, window.location.href).toString(),\n            muted: this.muted\n          }\n        });\n      }\n    }, {\n      kind: \"field\",\n      key: \"_resizeExoPlayer\",\n      value() {\n        return () => {\n          if (!this._videoEl) {\n            return;\n          }\n          const rect = this._videoEl.getBoundingClientRect();\n          this.hass.auth.external.fireMessage({\n            type: \"exoplayer/resize\",\n            payload: {\n              left: rect.left,\n              top: rect.top,\n              right: rect.right,\n              bottom: rect.bottom\n            }\n          });\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_isLLHLSSupported\",\n      value: function _isLLHLSSupported() {\n        // LL-HLS keeps multiple requests in flight, which can run into browser limitations without\n        // an http/2 proxy to pipeline requests. However, a small number of streams active at\n        // once should be OK.\n        // The stream count may be incremented multiple times before this function is called to check\n        // the count e.g. when loading a page with many streams on it. The race can work in our favor\n        // so we now have a better idea on if we'll use too many browser connections later.\n        if (HaHLSPlayer.streamCount <= 2) {\n          return true;\n        }\n        if (!(\"performance\" in window) || performance.getEntriesByType(\"resource\").length === 0) {\n          return false;\n        }\n        const perfEntry = performance.getEntriesByType(\"resource\")[0];\n        return \"nextHopProtocol\" in perfEntry && perfEntry.nextHopProtocol === \"h2\";\n      }\n    }, {\n      kind: \"method\",\n      key: \"_renderHLSPolyfill\",\n      value: async function _renderHLSPolyfill(videoEl, Hls, url) {\n        const hls = new Hls({\n          backBufferLength: 60,\n          fragLoadingTimeOut: 30000,\n          manifestLoadingTimeOut: 30000,\n          levelLoadingTimeOut: 30000,\n          maxLiveSyncPlaybackRate: 2,\n          lowLatencyMode: this._isLLHLSSupported()\n        });\n        this._hlsPolyfillInstance = hls;\n        hls.attachMedia(videoEl);\n        hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n          this._resetError();\n          hls.loadSource(url);\n        });\n        hls.on(Hls.Events.FRAG_LOADED, (_event, _data) => {\n          this._resetError();\n        });\n        hls.on(Hls.Events.ERROR, (_event, data) => {\n          // Some errors are recovered automatically by the hls player itself, and the others handled\n          // in this function require special actions to recover. Errors retried in this function\n          // are done with backoff to not cause unecessary failures.\n          if (!data.fatal) {\n            return;\n          }\n          if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {\n            switch (data.details) {\n              case Hls.ErrorDetails.MANIFEST_LOAD_ERROR:\n                {\n                  let error = \"Error starting stream, see logs for details\";\n                  if (data.response !== undefined && data.response.code !== undefined) {\n                    if (data.response.code >= 500) {\n                      error += \" (Server failure)\";\n                    } else if (data.response.code >= 400) {\n                      error += \" (Stream never started)\";\n                    } else {\n                      error += \" (\" + data.response.code + \")\";\n                    }\n                  }\n                  this._setRetryableError(error);\n                  break;\n                }\n              case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n                this._setRetryableError(\"Timeout while starting stream\");\n                break;\n              default:\n                this._setRetryableError(\"Stream network error\");\n                break;\n            }\n            hls.startLoad();\n          } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {\n            this._setRetryableError(\"Error with media stream contents\");\n            hls.recoverMediaError();\n          } else {\n            this._setFatalError(\"Error playing stream\");\n          }\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_renderHLSNative\",\n      value: async function _renderHLSNative(videoEl, url) {\n        videoEl.src = url;\n        videoEl.addEventListener(\"loadedmetadata\", () => {\n          videoEl.play();\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_cleanUp\",\n      value: function _cleanUp() {\n        if (this._hlsPolyfillInstance) {\n          this._hlsPolyfillInstance.destroy();\n          this._hlsPolyfillInstance = undefined;\n        }\n        if (this._exoPlayer) {\n          window.removeEventListener(\"resize\", this._resizeExoPlayer);\n          this.hass.auth.external.fireMessage({\n            type: \"exoplayer/stop\"\n          });\n          this._exoPlayer = false;\n        }\n        if (this._videoEl) {\n          this._videoEl.removeAttribute(\"src\");\n          this._videoEl.load();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_resetError\",\n      value: function _resetError() {\n        this._error = undefined;\n        this._errorIsFatal = false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_setFatalError\",\n      value: function _setFatalError(errorMessage) {\n        this._error = errorMessage;\n        this._errorIsFatal = true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_setRetryableError\",\n      value: function _setRetryableError(errorMessage) {\n        this._error = errorMessage;\n        this._errorIsFatal = false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_loadedData\",\n      value: function _loadedData() {\n        // @ts-ignore\n        fireEvent(this, \"load\");\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n\n      .fatal {\n        display: block;\n        padding: 100px 16px;\n      }\n\n      .retry {\n        display: block;\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","customElement","property","query","state","fireEvent","nextRender","HaHLSPlayer","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","static","connectedCallback","_get","_getPrototypeOf","prototype","call","streamCount","hasUpdated","_resetError","_startHls","disconnectedCallback","_cleanUp","render","_error","_errorIsFatal","posterUrl","autoPlay","muted","playsInline","controls","_loadedData","updated","changedProps","urlChanged","has","_this$hass$auth$exter","masterPlaylistPromise","fetch","url","Hls","default","isConnected","hlsSupported","isSupported","_videoEl","canPlayType","_setFatalError","hass","localize","useExoPlayer","allowExoPlayer","auth","external","config","hasExoPlayer","masterPlaylist","text","playlistRegexp","match","exec","matchTwice","playlist_url","URL","href","undefined","_renderHLSExoPlayer","_renderHLSPolyfill","_renderHLSNative","_exoPlayer","window","addEventListener","_resizeExoPlayer","updateComplete","then","style","visibility","fireMessage","payload","location","toString","rect","getBoundingClientRect","left","top","right","bottom","_isLLHLSSupported","performance","getEntriesByType","length","perfEntry","nextHopProtocol","videoEl","hls","backBufferLength","fragLoadingTimeOut","manifestLoadingTimeOut","levelLoadingTimeOut","maxLiveSyncPlaybackRate","lowLatencyMode","_hlsPolyfillInstance","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","FRAG_LOADED","_event","_data","ERROR","data","fatal","ErrorTypes","NETWORK_ERROR","details","ErrorDetails","MANIFEST_LOAD_ERROR","error","response","code","_setRetryableError","MANIFEST_LOAD_TIMEOUT","startLoad","MEDIA_ERROR","recoverMediaError","src","play","destroy","removeEventListener","removeAttribute","load","errorMessage","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/ha-hls-player.ts"],"sourcesContent":["import type HlsType from \"hls.js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { nextRender } from \"../common/util/render-status\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\ntype HlsLite = Omit<\n  HlsType,\n  \"subtitleTrackController\" | \"audioTrackController\" | \"emeController\"\n>;\n\n@customElement(\"ha-hls-player\")\nclass HaHLSPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public url!: string;\n\n  @property() public posterUrl!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"video\") private _videoEl!: HTMLVideoElement;\n\n  @state() private _error?: string;\n\n  @state() private _errorIsFatal = false;\n\n  private _hlsPolyfillInstance?: HlsLite;\n\n  private _exoPlayer = false;\n\n  private static streamCount = 0;\n\n  public connectedCallback() {\n    super.connectedCallback();\n    HaHLSPlayer.streamCount += 1;\n    if (this.hasUpdated) {\n      this._resetError();\n      this._startHls();\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    HaHLSPlayer.streamCount -= 1;\n    this._cleanUp();\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      ${this._error\n        ? html`<ha-alert\n            alert-type=\"error\"\n            class=${this._errorIsFatal ? \"fatal\" : \"retry\"}\n          >\n            ${this._error}\n          </ha-alert>`\n        : \"\"}\n      ${!this._errorIsFatal\n        ? html`<video\n            .poster=${this.posterUrl}\n            ?autoplay=${this.autoPlay}\n            .muted=${this.muted}\n            ?playsinline=${this.playsInline}\n            ?controls=${this.controls}\n            @loadeddata=${this._loadedData}\n          ></video>`\n        : \"\"}\n    `;\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    super.updated(changedProps);\n\n    const urlChanged = changedProps.has(\"url\");\n\n    if (!urlChanged) {\n      return;\n    }\n\n    this._cleanUp();\n    this._resetError();\n    this._startHls();\n  }\n\n  private async _startHls(): Promise<void> {\n    const masterPlaylistPromise = fetch(this.url);\n\n    const Hls: typeof HlsType = (await import(\"hls.js/dist/hls.light.mjs\"))\n      .default;\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    let hlsSupported = Hls.isSupported();\n\n    if (!hlsSupported) {\n      hlsSupported =\n        this._videoEl.canPlayType(\"application/vnd.apple.mpegurl\") !== \"\";\n    }\n\n    if (!hlsSupported) {\n      this._setFatalError(\n        this.hass.localize(\"ui.components.media-browser.video_not_supported\")\n      );\n      return;\n    }\n\n    const useExoPlayer =\n      this.allowExoPlayer && this.hass.auth.external?.config.hasExoPlayer;\n    const masterPlaylist = await (await masterPlaylistPromise).text();\n\n    if (!this.isConnected) {\n      return;\n    }\n\n    // Parse playlist assuming it is a master playlist. Match group 1 is whether hevc, match group 2 is regular playlist url\n    // See https://tools.ietf.org/html/rfc8216 for HLS spec details\n    const playlistRegexp =\n      /#EXT-X-STREAM-INF:.*?(?:CODECS=\".*?(hev1|hvc1)?\\..*?\".*?)?(?:\\n|\\r\\n)(.+)/g;\n    const match = playlistRegexp.exec(masterPlaylist);\n    const matchTwice = playlistRegexp.exec(masterPlaylist);\n\n    // Get the regular playlist url from the input (master) playlist, falling back to the input playlist if necessary\n    // This avoids the player having to load and parse the master playlist again before loading the regular playlist\n    let playlist_url: string;\n    if (match !== null && matchTwice === null) {\n      // Only send the regular playlist url if we match exactly once\n      playlist_url = new URL(match[2], this.url).href;\n    } else {\n      playlist_url = this.url;\n    }\n\n    // If codec is HEVC and ExoPlayer is supported, use ExoPlayer.\n    if (useExoPlayer && match !== null && match[1] !== undefined) {\n      this._renderHLSExoPlayer(playlist_url);\n    } else if (Hls.isSupported()) {\n      this._renderHLSPolyfill(this._videoEl, Hls, playlist_url);\n    } else {\n      this._renderHLSNative(this._videoEl, playlist_url);\n    }\n  }\n\n  private async _renderHLSExoPlayer(url: string) {\n    this._exoPlayer = true;\n    window.addEventListener(\"resize\", this._resizeExoPlayer);\n    this.updateComplete.then(() => nextRender()).then(this._resizeExoPlayer);\n    this._videoEl.style.visibility = \"hidden\";\n    await this.hass!.auth.external!.fireMessage({\n      type: \"exoplayer/play_hls\",\n      payload: {\n        url: new URL(url, window.location.href).toString(),\n        muted: this.muted,\n      },\n    });\n  }\n\n  private _resizeExoPlayer = () => {\n    if (!this._videoEl) {\n      return;\n    }\n    const rect = this._videoEl.getBoundingClientRect();\n    this.hass!.auth.external!.fireMessage({\n      type: \"exoplayer/resize\",\n      payload: {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n      },\n    });\n  };\n\n  private _isLLHLSSupported(): boolean {\n    // LL-HLS keeps multiple requests in flight, which can run into browser limitations without\n    // an http/2 proxy to pipeline requests. However, a small number of streams active at\n    // once should be OK.\n    // The stream count may be incremented multiple times before this function is called to check\n    // the count e.g. when loading a page with many streams on it. The race can work in our favor\n    // so we now have a better idea on if we'll use too many browser connections later.\n    if (HaHLSPlayer.streamCount <= 2) {\n      return true;\n    }\n    if (\n      !(\"performance\" in window) ||\n      performance.getEntriesByType(\"resource\").length === 0\n    ) {\n      return false;\n    }\n    const perfEntry = performance.getEntriesByType(\n      \"resource\"\n    )[0] as PerformanceResourceTiming;\n    return \"nextHopProtocol\" in perfEntry && perfEntry.nextHopProtocol === \"h2\";\n  }\n\n  private async _renderHLSPolyfill(\n    videoEl: HTMLVideoElement,\n    Hls: typeof HlsType,\n    url: string\n  ) {\n    const hls = new Hls({\n      backBufferLength: 60,\n      fragLoadingTimeOut: 30000,\n      manifestLoadingTimeOut: 30000,\n      levelLoadingTimeOut: 30000,\n      maxLiveSyncPlaybackRate: 2,\n      lowLatencyMode: this._isLLHLSSupported(),\n    });\n    this._hlsPolyfillInstance = hls;\n    hls.attachMedia(videoEl);\n    hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n      this._resetError();\n      hls.loadSource(url);\n    });\n    hls.on(Hls.Events.FRAG_LOADED, (_event, _data: any) => {\n      this._resetError();\n    });\n    hls.on(Hls.Events.ERROR, (_event, data: any) => {\n      // Some errors are recovered automatically by the hls player itself, and the others handled\n      // in this function require special actions to recover. Errors retried in this function\n      // are done with backoff to not cause unecessary failures.\n      if (!data.fatal) {\n        return;\n      }\n      if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {\n        switch (data.details) {\n          case Hls.ErrorDetails.MANIFEST_LOAD_ERROR: {\n            let error = \"Error starting stream, see logs for details\";\n            if (\n              data.response !== undefined &&\n              data.response.code !== undefined\n            ) {\n              if (data.response.code >= 500) {\n                error += \" (Server failure)\";\n              } else if (data.response.code >= 400) {\n                error += \" (Stream never started)\";\n              } else {\n                error += \" (\" + data.response.code + \")\";\n              }\n            }\n            this._setRetryableError(error);\n            break;\n          }\n          case Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            this._setRetryableError(\"Timeout while starting stream\");\n            break;\n          default:\n            this._setRetryableError(\"Stream network error\");\n            break;\n        }\n        hls.startLoad();\n      } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {\n        this._setRetryableError(\"Error with media stream contents\");\n        hls.recoverMediaError();\n      } else {\n        this._setFatalError(\"Error playing stream\");\n      }\n    });\n  }\n\n  private async _renderHLSNative(videoEl: HTMLVideoElement, url: string) {\n    videoEl.src = url;\n    videoEl.addEventListener(\"loadedmetadata\", () => {\n      videoEl.play();\n    });\n  }\n\n  private _cleanUp() {\n    if (this._hlsPolyfillInstance) {\n      this._hlsPolyfillInstance.destroy();\n      this._hlsPolyfillInstance = undefined;\n    }\n    if (this._exoPlayer) {\n      window.removeEventListener(\"resize\", this._resizeExoPlayer);\n      this.hass!.auth.external!.fireMessage({ type: \"exoplayer/stop\" });\n      this._exoPlayer = false;\n    }\n    if (this._videoEl) {\n      this._videoEl.removeAttribute(\"src\");\n      this._videoEl.load();\n    }\n  }\n\n  private _resetError() {\n    this._error = undefined;\n    this._errorIsFatal = false;\n  }\n\n  private _setFatalError(errorMessage: string) {\n    this._error = errorMessage;\n    this._errorIsFatal = true;\n  }\n\n  private _setRetryableError(errorMessage: string) {\n    this._error = errorMessage;\n    this._errorIsFatal = false;\n  }\n\n  private _loadedData() {\n    // @ts-ignore\n    fireEvent(this, \"load\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n\n      .fatal {\n        display: block;\n        padding: 100px 16px;\n      }\n\n      .retry {\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-hls-player\": HaHLSPlayer;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}