{"ast":null,"code":"import { ensureArray } from \"../common/array/ensure-array\";\nimport { formatDuration } from \"../common/datetime/format_duration\";\nimport { formatTime, formatTimeWithSeconds } from \"../common/datetime/format_time\";\nimport secondsToDuration from \"../common/datetime/seconds_to_duration\";\nimport { computeAttributeNameDisplay } from \"../common/entity/compute_attribute_display\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport \"../resources/intl-polyfill\";\nimport { localizeDeviceAutomationCondition, localizeDeviceAutomationTrigger } from \"./device_automation\";\nimport { formatListWithAnds, formatListWithOrs } from \"../common/string/format-list\";\nconst triggerTranslationBaseKey = \"ui.panel.config.automation.editor.triggers.type\";\nconst conditionsTranslationBaseKey = \"ui.panel.config.automation.editor.conditions.type\";\nconst describeDuration = (locale, forTime) => {\n  let duration;\n  if (typeof forTime === \"number\") {\n    duration = secondsToDuration(forTime);\n  } else if (typeof forTime === \"string\") {\n    duration = forTime;\n  } else {\n    duration = formatDuration(locale, forTime);\n  }\n  return duration;\n};\nconst localizeTimeString = (time, locale, config) => {\n  const chunks = time.split(\":\");\n  if (chunks.length < 2 || chunks.length > 3) {\n    return time;\n  }\n  try {\n    const dt = new Date(\"1970-01-01T\" + time);\n    if (chunks.length === 2 || Number(chunks[2]) === 0) {\n      return formatTime(dt, locale, config);\n    }\n    return formatTimeWithSeconds(dt, locale, config);\n  } catch (_unused) {\n    return time;\n  }\n};\nexport const describeTrigger = (trigger, hass, entityRegistry, ignoreAlias = false) => {\n  try {\n    return tryDescribeTrigger(trigger, hass, entityRegistry, ignoreAlias);\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n    let msg = \"Error in describing trigger\";\n    if (error.message) {\n      msg += \": \" + error.message;\n    }\n    return msg;\n  }\n};\nconst tryDescribeTrigger = (trigger, hass, entityRegistry, ignoreAlias = false) => {\n  if (trigger.alias && !ignoreAlias) {\n    return trigger.alias;\n  }\n\n  // Event Trigger\n  if (trigger.platform === \"event\" && trigger.event_type) {\n    const eventTypes = [];\n    if (Array.isArray(trigger.event_type)) {\n      for (const state of trigger.event_type.values()) {\n        eventTypes.push(state);\n      }\n    } else {\n      eventTypes.push(trigger.event_type);\n    }\n    const eventTypesString = formatListWithOrs(hass.locale, eventTypes);\n    return hass.localize(`${triggerTranslationBaseKey}.event.description.full`, {\n      eventTypes: eventTypesString\n    });\n  }\n\n  // Indexline Technology Trigger\n  if (trigger.platform === \"homeassistant\" && trigger.event) {\n    return hass.localize(trigger.event === \"start\" ? `${triggerTranslationBaseKey}.homeassistant.description.started` : `${triggerTranslationBaseKey}.homeassistant.description.shutdown`);\n  }\n\n  // Numeric State Trigger\n  if (trigger.platform === \"numeric_state\" && trigger.entity_id) {\n    const entities = [];\n    const states = hass.states;\n    const stateObj = Array.isArray(trigger.entity_id) ? hass.states[trigger.entity_id[0]] : hass.states[trigger.entity_id];\n    if (Array.isArray(trigger.entity_id)) {\n      for (const entity of trigger.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else if (trigger.entity_id) {\n      entities.push(states[trigger.entity_id] ? computeStateName(states[trigger.entity_id]) : trigger.entity_id);\n    }\n    const attribute = trigger.attribute ? computeAttributeNameDisplay(hass.localize, stateObj, hass.entities, trigger.attribute) : undefined;\n    const duration = trigger.for ? describeDuration(hass.locale, trigger.for) : undefined;\n    if (trigger.above !== undefined && trigger.below !== undefined) {\n      return hass.localize(`${triggerTranslationBaseKey}.numeric_state.description.above-below`, {\n        attribute: attribute,\n        entity: formatListWithOrs(hass.locale, entities),\n        numberOfEntities: entities.length,\n        above: trigger.above,\n        below: trigger.below,\n        duration: duration\n      });\n    }\n    if (trigger.above !== undefined) {\n      return hass.localize(`${triggerTranslationBaseKey}.numeric_state.description.above`, {\n        attribute: attribute,\n        entity: formatListWithOrs(hass.locale, entities),\n        numberOfEntities: entities.length,\n        above: trigger.above,\n        duration: duration\n      });\n    }\n    if (trigger.below !== undefined) {\n      return hass.localize(`${triggerTranslationBaseKey}.numeric_state.description.below`, {\n        attribute: attribute,\n        entity: formatListWithOrs(hass.locale, entities),\n        numberOfEntities: entities.length,\n        below: trigger.below,\n        duration: duration\n      });\n    }\n  }\n\n  // State Trigger\n  if (trigger.platform === \"state\") {\n    const entities = [];\n    const states = hass.states;\n    let attribute = \"\";\n    if (trigger.attribute) {\n      const stateObj = Array.isArray(trigger.entity_id) ? hass.states[trigger.entity_id[0]] : hass.states[trigger.entity_id];\n      attribute = computeAttributeNameDisplay(hass.localize, stateObj, hass.entities, trigger.attribute);\n    }\n    const entityArray = ensureArray(trigger.entity_id);\n    if (entityArray) {\n      for (const entity of entityArray) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    }\n    const stateObj = hass.states[entityArray[0]];\n    let fromChoice = \"other\";\n    let fromString = \"\";\n    if (trigger.from !== undefined) {\n      let fromArray = [];\n      if (trigger.from === null) {\n        if (!trigger.attribute) {\n          fromChoice = \"null\";\n        }\n      } else {\n        fromArray = ensureArray(trigger.from);\n        const from = [];\n        for (const state of fromArray) {\n          from.push(trigger.attribute ? hass.formatEntityAttributeValue(stateObj, trigger.attribute, state).toString() : hass.formatEntityState(stateObj, state));\n        }\n        if (from.length !== 0) {\n          fromString = formatListWithOrs(hass.locale, from);\n          fromChoice = \"fromUsed\";\n        }\n      }\n    }\n    let toChoice = \"other\";\n    let toString = \"\";\n    if (trigger.to !== undefined) {\n      let toArray = [];\n      if (trigger.to === null) {\n        if (!trigger.attribute) {\n          toChoice = \"null\";\n        }\n      } else {\n        toArray = ensureArray(trigger.to);\n        const to = [];\n        for (const state of toArray) {\n          to.push(trigger.attribute ? hass.formatEntityAttributeValue(stateObj, trigger.attribute, state).toString() : hass.formatEntityState(stateObj, state).toString());\n        }\n        if (to.length !== 0) {\n          toString = formatListWithOrs(hass.locale, to);\n          toChoice = \"toUsed\";\n        }\n      }\n    }\n    if (!trigger.attribute && trigger.from === undefined && trigger.to === undefined) {\n      toChoice = \"special\";\n    }\n    let duration = \"\";\n    if (trigger.for) {\n      var _describeDuration;\n      duration = (_describeDuration = describeDuration(hass.locale, trigger.for)) !== null && _describeDuration !== void 0 ? _describeDuration : \"\";\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.state.description.full`, {\n      hasAttribute: attribute !== \"\" ? \"true\" : \"false\",\n      attribute: attribute,\n      hasEntity: entities.length !== 0 ? \"true\" : \"false\",\n      entity: formatListWithOrs(hass.locale, entities),\n      fromChoice: fromChoice,\n      fromString: fromString,\n      toChoice: toChoice,\n      toString: toString,\n      hasDuration: duration !== \"\" ? \"true\" : \"false\",\n      duration: duration\n    });\n  }\n\n  // Sun Trigger\n  if (trigger.platform === \"sun\" && trigger.event) {\n    let duration = \"\";\n    if (trigger.offset) {\n      if (typeof trigger.offset === \"number\") {\n        duration = secondsToDuration(trigger.offset);\n      } else if (typeof trigger.offset === \"string\") {\n        duration = trigger.offset;\n      } else {\n        duration = JSON.stringify(trigger.offset);\n      }\n    }\n    return hass.localize(trigger.event === \"sunset\" ? `${triggerTranslationBaseKey}.sun.description.sets` : `${triggerTranslationBaseKey}.sun.description.rises`, {\n      hasDuration: duration !== \"\" ? \"true\" : \"false\",\n      duration: duration\n    });\n  }\n\n  // Tag Trigger\n  if (trigger.platform === \"tag\") {\n    return hass.localize(`${triggerTranslationBaseKey}.tag.description.full`);\n  }\n\n  // Time Trigger\n  if (trigger.platform === \"time\" && trigger.at) {\n    const result = ensureArray(trigger.at).map(at => typeof at !== \"string\" ? at : at.includes(\".\") ? `entity ${hass.states[at] ? computeStateName(hass.states[at]) : at}` : localizeTimeString(at, hass.locale, hass.config));\n    return hass.localize(`${triggerTranslationBaseKey}.time.description.full`, {\n      time: formatListWithOrs(hass.locale, result)\n    });\n  }\n\n  // Time Pattern Trigger\n  if (trigger.platform === \"time_pattern\") {\n    if (!trigger.seconds && !trigger.minutes && !trigger.hours) {\n      return hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.initial`);\n    }\n    const invalidParts = [];\n    let secondsChoice = \"other\";\n    let minutesChoice = \"other\";\n    let hoursChoice = \"other\";\n    let seconds = 0;\n    let minutes = 0;\n    let hours = 0;\n    if (trigger.seconds !== undefined) {\n      const seconds_all = trigger.seconds === \"*\";\n      const seconds_interval = typeof trigger.seconds === \"string\" && trigger.seconds.startsWith(\"/\");\n      seconds = seconds_all ? 0 : typeof trigger.seconds === \"number\" ? trigger.seconds : seconds_interval ? parseInt(trigger.seconds.substring(1)) : parseInt(trigger.seconds);\n      if (isNaN(seconds) || seconds > 59 || seconds < 0 || seconds_interval && seconds === 0) {\n        invalidParts.push(\"seconds\");\n      }\n      if (seconds_all || seconds_interval && seconds === 1) {\n        secondsChoice = \"every\";\n      } else if (seconds_interval) {\n        secondsChoice = \"every_interval\";\n      } else {\n        secondsChoice = \"on_the_xth\";\n      }\n    }\n    if (trigger.minutes !== undefined) {\n      const minutes_all = trigger.minutes === \"*\";\n      const minutes_interval = typeof trigger.minutes === \"string\" && trigger.minutes.startsWith(\"/\");\n      minutes = minutes_all ? 0 : typeof trigger.minutes === \"number\" ? trigger.minutes : minutes_interval ? parseInt(trigger.minutes.substring(1)) : parseInt(trigger.minutes);\n      if (isNaN(minutes) || minutes > 59 || minutes < 0 || minutes_interval && minutes === 0) {\n        invalidParts.push(\"minutes\");\n      }\n      if (minutes_all || minutes_interval && minutes === 1) {\n        minutesChoice = \"every\";\n      } else if (minutes_interval) {\n        minutesChoice = \"every_interval\";\n      } else {\n        minutesChoice = trigger.seconds !== undefined ? \"has_seconds\" : \"on_the_xth\";\n      }\n    } else if (trigger.seconds !== undefined) {\n      if (trigger.hours !== undefined) {\n        minutes = 0;\n        minutesChoice = \"has_seconds\";\n      } else {\n        minutesChoice = \"every\";\n      }\n    }\n    if (trigger.hours !== undefined) {\n      const hours_all = trigger.hours === \"*\";\n      const hours_interval = typeof trigger.hours === \"string\" && trigger.hours.startsWith(\"/\");\n      hours = hours_all ? 0 : typeof trigger.hours === \"number\" ? trigger.hours : hours_interval ? parseInt(trigger.hours.substring(1)) : parseInt(trigger.hours);\n      if (isNaN(hours) || hours > 23 || hours < 0 || hours_interval && hours === 0) {\n        invalidParts.push(\"hours\");\n      }\n      if (hours_all || hours_interval && hours === 1) {\n        hoursChoice = \"every\";\n      } else if (hours_interval) {\n        hoursChoice = \"every_interval\";\n      } else {\n        hoursChoice = trigger.seconds !== undefined || trigger.minutes !== undefined ? \"has_seconds_or_minutes\" : \"on_the_xth\";\n      }\n    } else {\n      hoursChoice = \"every\";\n    }\n    if (invalidParts.length !== 0) {\n      return hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.invalid`, {\n        parts: formatListWithAnds(hass.locale, invalidParts.map(invalidPart => hass.localize(`${triggerTranslationBaseKey}.time_pattern.${invalidPart}`)))\n      });\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.full`, {\n      secondsChoice: secondsChoice,\n      minutesChoice: minutesChoice,\n      hoursChoice: hoursChoice,\n      seconds: seconds,\n      minutes: minutes,\n      hours: hours,\n      secondsWithOrdinal: hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.ordinal`, {\n        part: seconds\n      }),\n      minutesWithOrdinal: hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.ordinal`, {\n        part: minutes\n      }),\n      hoursWithOrdinal: hass.localize(`${triggerTranslationBaseKey}.time_pattern.description.ordinal`, {\n        part: hours\n      })\n    });\n  }\n\n  // Zone Trigger\n  if (trigger.platform === \"zone\" && trigger.entity_id && trigger.zone) {\n    const entities = [];\n    const zones = [];\n    const states = hass.states;\n    if (Array.isArray(trigger.entity_id)) {\n      for (const entity of trigger.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else {\n      entities.push(states[trigger.entity_id] ? computeStateName(states[trigger.entity_id]) : trigger.entity_id);\n    }\n    if (Array.isArray(trigger.zone)) {\n      for (const zone of trigger.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(states[trigger.zone] ? computeStateName(states[trigger.zone]) : trigger.zone);\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.zone.description.full`, {\n      entity: formatListWithOrs(hass.locale, entities),\n      event: trigger.event.toString(),\n      zone: formatListWithOrs(hass.locale, zones),\n      numberOfZones: zones.length\n    });\n  }\n\n  // Geo Location Trigger\n  if (trigger.platform === \"geo_location\" && trigger.source && trigger.zone) {\n    const sources = [];\n    const zones = [];\n    const states = hass.states;\n    if (Array.isArray(trigger.source)) {\n      for (const source of trigger.source.values()) {\n        sources.push(source);\n      }\n    } else {\n      sources.push(trigger.source);\n    }\n    if (Array.isArray(trigger.zone)) {\n      for (const zone of trigger.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(states[trigger.zone] ? computeStateName(states[trigger.zone]) : trigger.zone);\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.geo_location.description.full`, {\n      source: formatListWithOrs(hass.locale, sources),\n      event: trigger.event.toString(),\n      zone: formatListWithOrs(hass.locale, zones),\n      numberOfZones: zones.length\n    });\n  }\n\n  // MQTT Trigger\n  if (trigger.platform === \"mqtt\") {\n    return hass.localize(`${triggerTranslationBaseKey}.mqtt.description.full`);\n  }\n\n  // Template Trigger\n  if (trigger.platform === \"template\") {\n    let duration = \"\";\n    if (trigger.for) {\n      var _describeDuration2;\n      duration = (_describeDuration2 = describeDuration(hass.locale, trigger.for)) !== null && _describeDuration2 !== void 0 ? _describeDuration2 : \"\";\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.template.description.full`, {\n      hasDuration: duration !== \"\" ? \"true\" : \"false\",\n      duration: duration\n    });\n  }\n\n  // Webhook Trigger\n  if (trigger.platform === \"webhook\") {\n    return hass.localize(`${triggerTranslationBaseKey}.webhook.description.full`);\n  }\n\n  // Conversation Trigger\n  if (trigger.platform === \"conversation\") {\n    if (!trigger.command) {\n      return hass.localize(`${triggerTranslationBaseKey}.conversation.description.empty`);\n    }\n    return hass.localize(`${triggerTranslationBaseKey}.conversation.description.full`, {\n      sentence: formatListWithOrs(hass.locale, ensureArray(trigger.command).map(cmd => `'${cmd}'`))\n    });\n  }\n\n  // Persistent Notification Trigger\n  if (trigger.platform === \"persistent_notification\") {\n    return hass.localize(`${triggerTranslationBaseKey}.persistent_notification.description.full`);\n  }\n\n  // Device Trigger\n  if (trigger.platform === \"device\" && trigger.device_id) {\n    const config = trigger;\n    const localized = localizeDeviceAutomationTrigger(hass, entityRegistry, config);\n    if (localized) {\n      return localized;\n    }\n    const stateObj = hass.states[config.entity_id];\n    return `${stateObj ? computeStateName(stateObj) : config.entity_id} ${config.type}`;\n  }\n  return hass.localize(`ui.panel.config.automation.editor.triggers.type.${trigger.platform}.label`) || hass.localize(`ui.panel.config.automation.editor.triggers.unknown_trigger`);\n};\nexport const describeCondition = (condition, hass, entityRegistry, ignoreAlias = false) => {\n  try {\n    return tryDescribeCondition(condition, hass, entityRegistry, ignoreAlias);\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n    let msg = \"Error in describing condition\";\n    if (error.message) {\n      msg += \": \" + error.message;\n    }\n    return msg;\n  }\n};\nconst tryDescribeCondition = (condition, hass, entityRegistry, ignoreAlias = false) => {\n  if (condition.alias && !ignoreAlias) {\n    return condition.alias;\n  }\n  if (!condition.condition) {\n    const shorthands = [\"and\", \"or\", \"not\"];\n    for (const key of shorthands) {\n      if (!(key in condition)) {\n        continue;\n      }\n      if (ensureArray(condition[key])) {\n        condition = {\n          condition: key,\n          conditions: condition[key]\n        };\n      }\n    }\n  }\n  if (condition.condition === \"or\") {\n    const conditions = ensureArray(condition.conditions);\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(`${conditionsTranslationBaseKey}.or.description.no_conditions`);\n    }\n    const count = conditions.length;\n    return hass.localize(`${conditionsTranslationBaseKey}.or.description.full`, {\n      count: count\n    });\n  }\n  if (condition.condition === \"and\") {\n    const conditions = ensureArray(condition.conditions);\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(`${conditionsTranslationBaseKey}.and.description.no_conditions`);\n    }\n    const count = conditions.length;\n    return hass.localize(`${conditionsTranslationBaseKey}.and.description.full`, {\n      count: count\n    });\n  }\n  if (condition.condition === \"not\") {\n    const conditions = ensureArray(condition.conditions);\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(`${conditionsTranslationBaseKey}.not.description.no_conditions`);\n    }\n    if (conditions.length === 1) {\n      return hass.localize(`${conditionsTranslationBaseKey}.not.description.one_condition`);\n    }\n    return hass.localize(`${conditionsTranslationBaseKey}.not.description.full`, {\n      count: conditions.length\n    });\n  }\n\n  // State Condition\n  if (condition.condition === \"state\") {\n    if (!condition.entity_id) {\n      return hass.localize(`${conditionsTranslationBaseKey}.state.description.no_entity`);\n    }\n    let attribute = \"\";\n    if (condition.attribute) {\n      const stateObj = Array.isArray(condition.entity_id) ? hass.states[condition.entity_id[0]] : hass.states[condition.entity_id];\n      attribute = computeAttributeNameDisplay(hass.localize, stateObj, hass.entities, condition.attribute);\n    }\n    const entities = [];\n    if (Array.isArray(condition.entity_id)) {\n      for (const entity of condition.entity_id.values()) {\n        if (hass.states[entity]) {\n          entities.push(computeStateName(hass.states[entity]) || entity);\n        }\n      }\n    } else if (condition.entity_id) {\n      entities.push(hass.states[condition.entity_id] ? computeStateName(hass.states[condition.entity_id]) : condition.entity_id);\n    }\n    const states = [];\n    const stateObj = hass.states[Array.isArray(condition.entity_id) ? condition.entity_id[0] : condition.entity_id];\n    if (Array.isArray(condition.state)) {\n      for (const state of condition.state.values()) {\n        states.push(condition.attribute ? hass.formatEntityAttributeValue(stateObj, condition.attribute, state).toString() : hass.formatEntityState(stateObj, state));\n      }\n    } else if (condition.state !== \"\") {\n      states.push(condition.attribute ? hass.formatEntityAttributeValue(stateObj, condition.attribute, condition.state).toString() : hass.formatEntityState(stateObj, condition.state.toString()));\n    }\n    let duration = \"\";\n    if (condition.for) {\n      duration = describeDuration(hass.locale, condition.for) || \"\";\n    }\n    return hass.localize(`${conditionsTranslationBaseKey}.state.description.full`, {\n      hasAttribute: attribute !== \"\" ? \"true\" : \"false\",\n      attribute: attribute,\n      numberOfEntities: entities.length,\n      entities: condition.match === \"any\" ? formatListWithOrs(hass.locale, entities) : formatListWithAnds(hass.locale, entities),\n      numberOfStates: states.length,\n      states: formatListWithOrs(hass.locale, states),\n      hasDuration: duration !== \"\" ? \"true\" : \"false\",\n      duration: duration\n    });\n  }\n\n  // Numeric State Condition\n  if (condition.condition === \"numeric_state\" && condition.entity_id) {\n    const stateObj = hass.states[condition.entity_id];\n    const entity = stateObj ? computeStateName(stateObj) : condition.entity_id;\n    const attribute = condition.attribute ? computeAttributeNameDisplay(hass.localize, stateObj, hass.entities, condition.attribute) : undefined;\n    if (condition.above && condition.below) {\n      return hass.localize(`${conditionsTranslationBaseKey}.numeric_state.description.above-below`, {\n        attribute: attribute,\n        entity: entity,\n        above: condition.above,\n        below: condition.below\n      });\n    }\n    if (condition.above) {\n      return hass.localize(`${conditionsTranslationBaseKey}.numeric_state.description.above`, {\n        attribute: attribute,\n        entity: entity,\n        above: condition.above\n      });\n    }\n    if (condition.below) {\n      return hass.localize(`${conditionsTranslationBaseKey}.numeric_state.description.below`, {\n        attribute: attribute,\n        entity: entity,\n        below: condition.below\n      });\n    }\n  }\n\n  // Time condition\n  if (condition.condition === \"time\") {\n    const weekdaysArray = ensureArray(condition.weekday);\n    const validWeekdays = weekdaysArray && weekdaysArray.length > 0 && weekdaysArray.length < 7;\n    if (condition.before || condition.after || validWeekdays) {\n      const before = typeof condition.before !== \"string\" ? condition.before : condition.before.includes(\".\") ? `entity ${hass.states[condition.before] ? computeStateName(hass.states[condition.before]) : condition.before}` : localizeTimeString(condition.before, hass.locale, hass.config);\n      const after = typeof condition.after !== \"string\" ? condition.after : condition.after.includes(\".\") ? `entity ${hass.states[condition.after] ? computeStateName(hass.states[condition.after]) : condition.after}` : localizeTimeString(condition.after, hass.locale, hass.config);\n      let localizedDays = [];\n      if (validWeekdays) {\n        localizedDays = weekdaysArray.map(d => hass.localize(`ui.panel.config.automation.editor.conditions.type.time.weekdays.${d}`));\n      }\n      let hasTime = \"\";\n      if (after !== undefined && before !== undefined) {\n        hasTime = \"after_before\";\n      } else if (after !== undefined) {\n        hasTime = \"after\";\n      } else if (before !== undefined) {\n        hasTime = \"before\";\n      }\n      return hass.localize(`${conditionsTranslationBaseKey}.time.description.full`, {\n        hasTime: hasTime,\n        hasTimeAndDay: (after || before) && validWeekdays ? \"true\" : \"false\",\n        hasDay: validWeekdays ? \"true\" : \"false\",\n        time_before: before,\n        time_after: after,\n        day: formatListWithOrs(hass.locale, localizedDays)\n      });\n    }\n  }\n\n  // Sun condition\n  if (condition.condition === \"sun\" && (condition.before || condition.after)) {\n    var _condition$after, _condition$before;\n    let afterDuration = \"\";\n    if (condition.after && condition.after_offset) {\n      if (typeof condition.after_offset === \"number\") {\n        afterDuration = secondsToDuration(condition.after_offset);\n      } else if (typeof condition.after_offset === \"string\") {\n        afterDuration = condition.after_offset;\n      } else {\n        afterDuration = JSON.stringify(condition.after_offset);\n      }\n    }\n    let beforeDuration = \"\";\n    if (condition.before && condition.before_offset) {\n      if (typeof condition.before_offset === \"number\") {\n        beforeDuration = secondsToDuration(condition.before_offset);\n      } else if (typeof condition.before_offset === \"string\") {\n        beforeDuration = condition.before_offset;\n      } else {\n        beforeDuration = JSON.stringify(condition.before_offset);\n      }\n    }\n    return hass.localize(`${conditionsTranslationBaseKey}.sun.description.full`, {\n      afterChoice: (_condition$after = condition.after) !== null && _condition$after !== void 0 ? _condition$after : \"other\",\n      afterOffsetChoice: afterDuration !== \"\" ? \"offset\" : \"other\",\n      afterOffset: afterDuration,\n      beforeChoice: (_condition$before = condition.before) !== null && _condition$before !== void 0 ? _condition$before : \"other\",\n      beforeOffsetChoice: beforeDuration !== \"\" ? \"offset\" : \"other\",\n      beforeOffset: beforeDuration\n    });\n  }\n\n  // Zone condition\n  if (condition.condition === \"zone\" && condition.entity_id && condition.zone) {\n    const entities = [];\n    const zones = [];\n    const states = hass.states;\n    if (Array.isArray(condition.entity_id)) {\n      for (const entity of condition.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else {\n      entities.push(states[condition.entity_id] ? computeStateName(states[condition.entity_id]) : condition.entity_id);\n    }\n    if (Array.isArray(condition.zone)) {\n      for (const zone of condition.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(states[condition.zone] ? computeStateName(states[condition.zone]) : condition.zone);\n    }\n    const entitiesString = formatListWithOrs(hass.locale, entities);\n    const zonesString = formatListWithOrs(hass.locale, zones);\n    return hass.localize(`${conditionsTranslationBaseKey}.zone.description.full`, {\n      entity: entitiesString,\n      numberOfEntities: entities.length,\n      zone: zonesString,\n      numberOfZones: zones.length\n    });\n  }\n  if (condition.condition === \"device\" && condition.device_id) {\n    const config = condition;\n    const localized = localizeDeviceAutomationCondition(hass, entityRegistry, config);\n    if (localized) {\n      return localized;\n    }\n    const stateObj = hass.states[config.entity_id];\n    return `${stateObj ? computeStateName(stateObj) : config.entity_id} ${config.type}`;\n  }\n  if (condition.condition === \"template\") {\n    return hass.localize(`${conditionsTranslationBaseKey}.template.description.full`);\n  }\n  if (condition.condition === \"trigger\" && condition.id != null) {\n    return hass.localize(`${conditionsTranslationBaseKey}.trigger.description.full`, {\n      id: formatListWithOrs(hass.locale, ensureArray(condition.id).map(id => id.toString()))\n    });\n  }\n  return hass.localize(`ui.panel.config.automation.editor.conditions.type.${condition.condition}.label`) || hass.localize(`ui.panel.config.automation.editor.conditions.unknown_condition`);\n};","map":{"version":3,"names":["ensureArray","formatDuration","formatTime","formatTimeWithSeconds","secondsToDuration","computeAttributeNameDisplay","computeStateName","localizeDeviceAutomationCondition","localizeDeviceAutomationTrigger","formatListWithAnds","formatListWithOrs","triggerTranslationBaseKey","conditionsTranslationBaseKey","describeDuration","locale","forTime","duration","localizeTimeString","time","config","chunks","split","length","dt","Date","Number","_unused","describeTrigger","trigger","hass","entityRegistry","ignoreAlias","tryDescribeTrigger","error","console","msg","message","alias","platform","event_type","eventTypes","Array","isArray","state","values","push","eventTypesString","localize","event","entity_id","entities","states","stateObj","entity","attribute","undefined","for","above","below","numberOfEntities","entityArray","fromChoice","fromString","from","fromArray","formatEntityAttributeValue","toString","formatEntityState","toChoice","to","toArray","_describeDuration","hasAttribute","hasEntity","hasDuration","offset","JSON","stringify","at","result","map","includes","seconds","minutes","hours","invalidParts","secondsChoice","minutesChoice","hoursChoice","seconds_all","seconds_interval","startsWith","parseInt","substring","isNaN","minutes_all","minutes_interval","hours_all","hours_interval","parts","invalidPart","secondsWithOrdinal","part","minutesWithOrdinal","hoursWithOrdinal","zone","zones","numberOfZones","source","sources","_describeDuration2","command","sentence","cmd","device_id","localized","type","describeCondition","condition","tryDescribeCondition","shorthands","key","conditions","count","match","numberOfStates","weekdaysArray","weekday","validWeekdays","before","after","localizedDays","d","hasTime","hasTimeAndDay","hasDay","time_before","time_after","day","_condition$after","_condition$before","afterDuration","after_offset","beforeDuration","before_offset","afterChoice","afterOffsetChoice","afterOffset","beforeChoice","beforeOffsetChoice","beforeOffset","entitiesString","zonesString","id"],"sources":["/workspaces/frontend/src/data/automation_i18n.ts"],"sourcesContent":["import { HassConfig } from \"home-assistant-js-websocket\";\nimport { ensureArray } from \"../common/array/ensure-array\";\nimport { formatDuration } from \"../common/datetime/format_duration\";\nimport {\n  formatTime,\n  formatTimeWithSeconds,\n} from \"../common/datetime/format_time\";\nimport secondsToDuration from \"../common/datetime/seconds_to_duration\";\nimport { computeAttributeNameDisplay } from \"../common/entity/compute_attribute_display\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport \"../resources/intl-polyfill\";\nimport type { HomeAssistant } from \"../types\";\nimport { Condition, ForDict, Trigger } from \"./automation\";\nimport {\n  DeviceCondition,\n  DeviceTrigger,\n  localizeDeviceAutomationCondition,\n  localizeDeviceAutomationTrigger,\n} from \"./device_automation\";\nimport { EntityRegistryEntry } from \"./entity_registry\";\nimport { FrontendLocaleData } from \"./translation\";\nimport {\n  formatListWithAnds,\n  formatListWithOrs,\n} from \"../common/string/format-list\";\n\nconst triggerTranslationBaseKey =\n  \"ui.panel.config.automation.editor.triggers.type\";\nconst conditionsTranslationBaseKey =\n  \"ui.panel.config.automation.editor.conditions.type\";\n\nconst describeDuration = (\n  locale: FrontendLocaleData,\n  forTime: number | string | ForDict\n) => {\n  let duration: string | null;\n  if (typeof forTime === \"number\") {\n    duration = secondsToDuration(forTime);\n  } else if (typeof forTime === \"string\") {\n    duration = forTime;\n  } else {\n    duration = formatDuration(locale, forTime);\n  }\n  return duration;\n};\n\nconst localizeTimeString = (\n  time: string,\n  locale: FrontendLocaleData,\n  config: HassConfig\n) => {\n  const chunks = time.split(\":\");\n  if (chunks.length < 2 || chunks.length > 3) {\n    return time;\n  }\n  try {\n    const dt = new Date(\"1970-01-01T\" + time);\n    if (chunks.length === 2 || Number(chunks[2]) === 0) {\n      return formatTime(dt, locale, config);\n    }\n    return formatTimeWithSeconds(dt, locale, config);\n  } catch {\n    return time;\n  }\n};\n\nexport const describeTrigger = (\n  trigger: Trigger,\n  hass: HomeAssistant,\n  entityRegistry: EntityRegistryEntry[],\n  ignoreAlias = false\n) => {\n  try {\n    return tryDescribeTrigger(trigger, hass, entityRegistry, ignoreAlias);\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n\n    let msg = \"Error in describing trigger\";\n    if (error.message) {\n      msg += \": \" + error.message;\n    }\n    return msg;\n  }\n};\n\nconst tryDescribeTrigger = (\n  trigger: Trigger,\n  hass: HomeAssistant,\n  entityRegistry: EntityRegistryEntry[],\n  ignoreAlias = false\n) => {\n  if (trigger.alias && !ignoreAlias) {\n    return trigger.alias;\n  }\n\n  // Event Trigger\n  if (trigger.platform === \"event\" && trigger.event_type) {\n    const eventTypes: string[] = [];\n\n    if (Array.isArray(trigger.event_type)) {\n      for (const state of trigger.event_type.values()) {\n        eventTypes.push(state);\n      }\n    } else {\n      eventTypes.push(trigger.event_type);\n    }\n\n    const eventTypesString = formatListWithOrs(hass.locale, eventTypes);\n    return hass.localize(\n      `${triggerTranslationBaseKey}.event.description.full`,\n      { eventTypes: eventTypesString }\n    );\n  }\n\n  // Indexline Technology Trigger\n  if (trigger.platform === \"homeassistant\" && trigger.event) {\n    return hass.localize(\n      trigger.event === \"start\"\n        ? `${triggerTranslationBaseKey}.homeassistant.description.started`\n        : `${triggerTranslationBaseKey}.homeassistant.description.shutdown`\n    );\n  }\n\n  // Numeric State Trigger\n  if (trigger.platform === \"numeric_state\" && trigger.entity_id) {\n    const entities: string[] = [];\n    const states = hass.states;\n\n    const stateObj = Array.isArray(trigger.entity_id)\n      ? hass.states[trigger.entity_id[0]]\n      : hass.states[trigger.entity_id];\n\n    if (Array.isArray(trigger.entity_id)) {\n      for (const entity of trigger.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else if (trigger.entity_id) {\n      entities.push(\n        states[trigger.entity_id]\n          ? computeStateName(states[trigger.entity_id])\n          : trigger.entity_id\n      );\n    }\n\n    const attribute = trigger.attribute\n      ? computeAttributeNameDisplay(\n          hass.localize,\n          stateObj,\n          hass.entities,\n          trigger.attribute\n        )\n      : undefined;\n\n    const duration = trigger.for\n      ? describeDuration(hass.locale, trigger.for)\n      : undefined;\n\n    if (trigger.above !== undefined && trigger.below !== undefined) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.numeric_state.description.above-below`,\n        {\n          attribute: attribute,\n          entity: formatListWithOrs(hass.locale, entities),\n          numberOfEntities: entities.length,\n          above: trigger.above,\n          below: trigger.below,\n          duration: duration,\n        }\n      );\n    }\n    if (trigger.above !== undefined) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.numeric_state.description.above`,\n        {\n          attribute: attribute,\n          entity: formatListWithOrs(hass.locale, entities),\n          numberOfEntities: entities.length,\n          above: trigger.above,\n          duration: duration,\n        }\n      );\n    }\n    if (trigger.below !== undefined) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.numeric_state.description.below`,\n        {\n          attribute: attribute,\n          entity: formatListWithOrs(hass.locale, entities),\n          numberOfEntities: entities.length,\n          below: trigger.below,\n          duration: duration,\n        }\n      );\n    }\n  }\n\n  // State Trigger\n  if (trigger.platform === \"state\") {\n    const entities: string[] = [];\n    const states = hass.states;\n\n    let attribute = \"\";\n    if (trigger.attribute) {\n      const stateObj = Array.isArray(trigger.entity_id)\n        ? hass.states[trigger.entity_id[0]]\n        : hass.states[trigger.entity_id];\n      attribute = computeAttributeNameDisplay(\n        hass.localize,\n        stateObj,\n        hass.entities,\n        trigger.attribute\n      );\n    }\n\n    const entityArray: string[] = ensureArray(trigger.entity_id);\n    if (entityArray) {\n      for (const entity of entityArray) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    }\n\n    const stateObj = hass.states[entityArray[0]];\n\n    let fromChoice = \"other\";\n    let fromString = \"\";\n    if (trigger.from !== undefined) {\n      let fromArray: string[] = [];\n      if (trigger.from === null) {\n        if (!trigger.attribute) {\n          fromChoice = \"null\";\n        }\n      } else {\n        fromArray = ensureArray(trigger.from);\n\n        const from: string[] = [];\n        for (const state of fromArray) {\n          from.push(\n            trigger.attribute\n              ? hass\n                  .formatEntityAttributeValue(\n                    stateObj,\n                    trigger.attribute,\n                    state\n                  )\n                  .toString()\n              : hass.formatEntityState(stateObj, state)\n          );\n        }\n        if (from.length !== 0) {\n          fromString = formatListWithOrs(hass.locale, from);\n          fromChoice = \"fromUsed\";\n        }\n      }\n    }\n\n    let toChoice = \"other\";\n    let toString = \"\";\n    if (trigger.to !== undefined) {\n      let toArray: string[] = [];\n      if (trigger.to === null) {\n        if (!trigger.attribute) {\n          toChoice = \"null\";\n        }\n      } else {\n        toArray = ensureArray(trigger.to);\n\n        const to: string[] = [];\n        for (const state of toArray) {\n          to.push(\n            trigger.attribute\n              ? hass\n                  .formatEntityAttributeValue(\n                    stateObj,\n                    trigger.attribute,\n                    state\n                  )\n                  .toString()\n              : hass.formatEntityState(stateObj, state).toString()\n          );\n        }\n        if (to.length !== 0) {\n          toString = formatListWithOrs(hass.locale, to);\n          toChoice = \"toUsed\";\n        }\n      }\n    }\n\n    if (\n      !trigger.attribute &&\n      trigger.from === undefined &&\n      trigger.to === undefined\n    ) {\n      toChoice = \"special\";\n    }\n\n    let duration = \"\";\n    if (trigger.for) {\n      duration = describeDuration(hass.locale, trigger.for) ?? \"\";\n    }\n\n    return hass.localize(\n      `${triggerTranslationBaseKey}.state.description.full`,\n      {\n        hasAttribute: attribute !== \"\" ? \"true\" : \"false\",\n        attribute: attribute,\n        hasEntity: entities.length !== 0 ? \"true\" : \"false\",\n        entity: formatListWithOrs(hass.locale, entities),\n        fromChoice: fromChoice,\n        fromString: fromString,\n        toChoice: toChoice,\n        toString: toString,\n        hasDuration: duration !== \"\" ? \"true\" : \"false\",\n        duration: duration,\n      }\n    );\n  }\n\n  // Sun Trigger\n  if (trigger.platform === \"sun\" && trigger.event) {\n    let duration = \"\";\n    if (trigger.offset) {\n      if (typeof trigger.offset === \"number\") {\n        duration = secondsToDuration(trigger.offset)!;\n      } else if (typeof trigger.offset === \"string\") {\n        duration = trigger.offset;\n      } else {\n        duration = JSON.stringify(trigger.offset);\n      }\n    }\n\n    return hass.localize(\n      trigger.event === \"sunset\"\n        ? `${triggerTranslationBaseKey}.sun.description.sets`\n        : `${triggerTranslationBaseKey}.sun.description.rises`,\n      { hasDuration: duration !== \"\" ? \"true\" : \"false\", duration: duration }\n    );\n  }\n\n  // Tag Trigger\n  if (trigger.platform === \"tag\") {\n    return hass.localize(`${triggerTranslationBaseKey}.tag.description.full`);\n  }\n\n  // Time Trigger\n  if (trigger.platform === \"time\" && trigger.at) {\n    const result = ensureArray(trigger.at).map((at) =>\n      typeof at !== \"string\"\n        ? at\n        : at.includes(\".\")\n          ? `entity ${hass.states[at] ? computeStateName(hass.states[at]) : at}`\n          : localizeTimeString(at, hass.locale, hass.config)\n    );\n\n    return hass.localize(`${triggerTranslationBaseKey}.time.description.full`, {\n      time: formatListWithOrs(hass.locale, result),\n    });\n  }\n\n  // Time Pattern Trigger\n  if (trigger.platform === \"time_pattern\") {\n    if (!trigger.seconds && !trigger.minutes && !trigger.hours) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.time_pattern.description.initial`\n      );\n    }\n\n    const invalidParts: Array<\"seconds\" | \"minutes\" | \"hours\"> = [];\n\n    let secondsChoice: \"every\" | \"every_interval\" | \"on_the_xth\" | \"other\" =\n      \"other\";\n    let minutesChoice:\n      | \"every\"\n      | \"every_interval\"\n      | \"on_the_xth\"\n      | \"other\"\n      | \"has_seconds\" = \"other\";\n    let hoursChoice:\n      | \"every\"\n      | \"every_interval\"\n      | \"on_the_xth\"\n      | \"other\"\n      | \"has_seconds_or_minutes\" = \"other\";\n\n    let seconds = 0;\n    let minutes = 0;\n    let hours = 0;\n\n    if (trigger.seconds !== undefined) {\n      const seconds_all = trigger.seconds === \"*\";\n      const seconds_interval =\n        typeof trigger.seconds === \"string\" && trigger.seconds.startsWith(\"/\");\n      seconds = seconds_all\n        ? 0\n        : typeof trigger.seconds === \"number\"\n          ? trigger.seconds\n          : seconds_interval\n            ? parseInt(trigger.seconds.substring(1))\n            : parseInt(trigger.seconds);\n\n      if (\n        isNaN(seconds) ||\n        seconds > 59 ||\n        seconds < 0 ||\n        (seconds_interval && seconds === 0)\n      ) {\n        invalidParts.push(\"seconds\");\n      }\n\n      if (seconds_all || (seconds_interval && seconds === 1)) {\n        secondsChoice = \"every\";\n      } else if (seconds_interval) {\n        secondsChoice = \"every_interval\";\n      } else {\n        secondsChoice = \"on_the_xth\";\n      }\n    }\n    if (trigger.minutes !== undefined) {\n      const minutes_all = trigger.minutes === \"*\";\n      const minutes_interval =\n        typeof trigger.minutes === \"string\" && trigger.minutes.startsWith(\"/\");\n      minutes = minutes_all\n        ? 0\n        : typeof trigger.minutes === \"number\"\n          ? trigger.minutes\n          : minutes_interval\n            ? parseInt(trigger.minutes.substring(1))\n            : parseInt(trigger.minutes);\n\n      if (\n        isNaN(minutes) ||\n        minutes > 59 ||\n        minutes < 0 ||\n        (minutes_interval && minutes === 0)\n      ) {\n        invalidParts.push(\"minutes\");\n      }\n\n      if (minutes_all || (minutes_interval && minutes === 1)) {\n        minutesChoice = \"every\";\n      } else if (minutes_interval) {\n        minutesChoice = \"every_interval\";\n      } else {\n        minutesChoice =\n          trigger.seconds !== undefined ? \"has_seconds\" : \"on_the_xth\";\n      }\n    } else if (trigger.seconds !== undefined) {\n      if (trigger.hours !== undefined) {\n        minutes = 0;\n        minutesChoice = \"has_seconds\";\n      } else {\n        minutesChoice = \"every\";\n      }\n    }\n    if (trigger.hours !== undefined) {\n      const hours_all = trigger.hours === \"*\";\n      const hours_interval =\n        typeof trigger.hours === \"string\" && trigger.hours.startsWith(\"/\");\n      hours = hours_all\n        ? 0\n        : typeof trigger.hours === \"number\"\n          ? trigger.hours\n          : hours_interval\n            ? parseInt(trigger.hours.substring(1))\n            : parseInt(trigger.hours);\n\n      if (\n        isNaN(hours) ||\n        hours > 23 ||\n        hours < 0 ||\n        (hours_interval && hours === 0)\n      ) {\n        invalidParts.push(\"hours\");\n      }\n\n      if (hours_all || (hours_interval && hours === 1)) {\n        hoursChoice = \"every\";\n      } else if (hours_interval) {\n        hoursChoice = \"every_interval\";\n      } else {\n        hoursChoice =\n          trigger.seconds !== undefined || trigger.minutes !== undefined\n            ? \"has_seconds_or_minutes\"\n            : \"on_the_xth\";\n      }\n    } else {\n      hoursChoice = \"every\";\n    }\n\n    if (invalidParts.length !== 0) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.time_pattern.description.invalid`,\n        {\n          parts: formatListWithAnds(\n            hass.locale,\n            invalidParts.map((invalidPart) =>\n              hass.localize(\n                `${triggerTranslationBaseKey}.time_pattern.${invalidPart}`\n              )\n            )\n          ),\n        }\n      );\n    }\n\n    return hass.localize(\n      `${triggerTranslationBaseKey}.time_pattern.description.full`,\n      {\n        secondsChoice: secondsChoice,\n        minutesChoice: minutesChoice,\n        hoursChoice: hoursChoice,\n        seconds: seconds,\n        minutes: minutes,\n        hours: hours,\n        secondsWithOrdinal: hass.localize(\n          `${triggerTranslationBaseKey}.time_pattern.description.ordinal`,\n          {\n            part: seconds,\n          }\n        ),\n        minutesWithOrdinal: hass.localize(\n          `${triggerTranslationBaseKey}.time_pattern.description.ordinal`,\n          {\n            part: minutes,\n          }\n        ),\n        hoursWithOrdinal: hass.localize(\n          `${triggerTranslationBaseKey}.time_pattern.description.ordinal`,\n          {\n            part: hours,\n          }\n        ),\n      }\n    );\n  }\n\n  // Zone Trigger\n  if (trigger.platform === \"zone\" && trigger.entity_id && trigger.zone) {\n    const entities: string[] = [];\n    const zones: string[] = [];\n\n    const states = hass.states;\n\n    if (Array.isArray(trigger.entity_id)) {\n      for (const entity of trigger.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else {\n      entities.push(\n        states[trigger.entity_id]\n          ? computeStateName(states[trigger.entity_id])\n          : trigger.entity_id\n      );\n    }\n\n    if (Array.isArray(trigger.zone)) {\n      for (const zone of trigger.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(\n        states[trigger.zone]\n          ? computeStateName(states[trigger.zone])\n          : trigger.zone\n      );\n    }\n\n    return hass.localize(`${triggerTranslationBaseKey}.zone.description.full`, {\n      entity: formatListWithOrs(hass.locale, entities),\n      event: trigger.event.toString(),\n      zone: formatListWithOrs(hass.locale, zones),\n      numberOfZones: zones.length,\n    });\n  }\n\n  // Geo Location Trigger\n  if (trigger.platform === \"geo_location\" && trigger.source && trigger.zone) {\n    const sources: string[] = [];\n    const zones: string[] = [];\n    const states = hass.states;\n\n    if (Array.isArray(trigger.source)) {\n      for (const source of trigger.source.values()) {\n        sources.push(source);\n      }\n    } else {\n      sources.push(trigger.source);\n    }\n\n    if (Array.isArray(trigger.zone)) {\n      for (const zone of trigger.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(\n        states[trigger.zone]\n          ? computeStateName(states[trigger.zone])\n          : trigger.zone\n      );\n    }\n\n    return hass.localize(\n      `${triggerTranslationBaseKey}.geo_location.description.full`,\n      {\n        source: formatListWithOrs(hass.locale, sources),\n        event: trigger.event.toString(),\n        zone: formatListWithOrs(hass.locale, zones),\n        numberOfZones: zones.length,\n      }\n    );\n  }\n\n  // MQTT Trigger\n  if (trigger.platform === \"mqtt\") {\n    return hass.localize(`${triggerTranslationBaseKey}.mqtt.description.full`);\n  }\n\n  // Template Trigger\n  if (trigger.platform === \"template\") {\n    let duration = \"\";\n    if (trigger.for) {\n      duration = describeDuration(hass.locale, trigger.for) ?? \"\";\n    }\n\n    return hass.localize(\n      `${triggerTranslationBaseKey}.template.description.full`,\n      { hasDuration: duration !== \"\" ? \"true\" : \"false\", duration: duration }\n    );\n  }\n\n  // Webhook Trigger\n  if (trigger.platform === \"webhook\") {\n    return hass.localize(\n      `${triggerTranslationBaseKey}.webhook.description.full`\n    );\n  }\n\n  // Conversation Trigger\n  if (trigger.platform === \"conversation\") {\n    if (!trigger.command) {\n      return hass.localize(\n        `${triggerTranslationBaseKey}.conversation.description.empty`\n      );\n    }\n\n    return hass.localize(\n      `${triggerTranslationBaseKey}.conversation.description.full`,\n      {\n        sentence: formatListWithOrs(\n          hass.locale,\n          ensureArray(trigger.command).map((cmd) => `'${cmd}'`)\n        ),\n      }\n    );\n  }\n\n  // Persistent Notification Trigger\n  if (trigger.platform === \"persistent_notification\") {\n    return hass.localize(\n      `${triggerTranslationBaseKey}.persistent_notification.description.full`\n    );\n  }\n\n  // Device Trigger\n  if (trigger.platform === \"device\" && trigger.device_id) {\n    const config = trigger as DeviceTrigger;\n    const localized = localizeDeviceAutomationTrigger(\n      hass,\n      entityRegistry,\n      config\n    );\n    if (localized) {\n      return localized;\n    }\n    const stateObj = hass.states[config.entity_id as string];\n    return `${stateObj ? computeStateName(stateObj) : config.entity_id} ${\n      config.type\n    }`;\n  }\n\n  return (\n    hass.localize(\n      `ui.panel.config.automation.editor.triggers.type.${trigger.platform}.label`\n    ) ||\n    hass.localize(`ui.panel.config.automation.editor.triggers.unknown_trigger`)\n  );\n};\n\nexport const describeCondition = (\n  condition: Condition,\n  hass: HomeAssistant,\n  entityRegistry: EntityRegistryEntry[],\n  ignoreAlias = false\n) => {\n  try {\n    return tryDescribeCondition(condition, hass, entityRegistry, ignoreAlias);\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(error);\n\n    let msg = \"Error in describing condition\";\n    if (error.message) {\n      msg += \": \" + error.message;\n    }\n    return msg;\n  }\n};\n\nconst tryDescribeCondition = (\n  condition: Condition,\n  hass: HomeAssistant,\n  entityRegistry: EntityRegistryEntry[],\n  ignoreAlias = false\n) => {\n  if (condition.alias && !ignoreAlias) {\n    return condition.alias;\n  }\n\n  if (!condition.condition) {\n    const shorthands: Array<\"and\" | \"or\" | \"not\"> = [\"and\", \"or\", \"not\"];\n    for (const key of shorthands) {\n      if (!(key in condition)) {\n        continue;\n      }\n      if (ensureArray(condition[key])) {\n        condition = {\n          condition: key,\n          conditions: condition[key],\n        };\n      }\n    }\n  }\n\n  if (condition.condition === \"or\") {\n    const conditions = ensureArray(condition.conditions);\n\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.or.description.no_conditions`\n      );\n    }\n    const count = conditions.length;\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.or.description.full`,\n      {\n        count: count,\n      }\n    );\n  }\n\n  if (condition.condition === \"and\") {\n    const conditions = ensureArray(condition.conditions);\n\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.and.description.no_conditions`\n      );\n    }\n    const count = conditions.length;\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.and.description.full`,\n      {\n        count: count,\n      }\n    );\n  }\n\n  if (condition.condition === \"not\") {\n    const conditions = ensureArray(condition.conditions);\n\n    if (!conditions || conditions.length === 0) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.not.description.no_conditions`\n      );\n    }\n    if (conditions.length === 1) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.not.description.one_condition`\n      );\n    }\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.not.description.full`,\n      { count: conditions.length }\n    );\n  }\n\n  // State Condition\n  if (condition.condition === \"state\") {\n    if (!condition.entity_id) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.state.description.no_entity`\n      );\n    }\n\n    let attribute = \"\";\n    if (condition.attribute) {\n      const stateObj = Array.isArray(condition.entity_id)\n        ? hass.states[condition.entity_id[0]]\n        : hass.states[condition.entity_id];\n      attribute = computeAttributeNameDisplay(\n        hass.localize,\n        stateObj,\n        hass.entities,\n        condition.attribute\n      );\n    }\n\n    const entities: string[] = [];\n    if (Array.isArray(condition.entity_id)) {\n      for (const entity of condition.entity_id.values()) {\n        if (hass.states[entity]) {\n          entities.push(computeStateName(hass.states[entity]) || entity);\n        }\n      }\n    } else if (condition.entity_id) {\n      entities.push(\n        hass.states[condition.entity_id]\n          ? computeStateName(hass.states[condition.entity_id])\n          : condition.entity_id\n      );\n    }\n\n    const states: string[] = [];\n    const stateObj =\n      hass.states[\n        Array.isArray(condition.entity_id)\n          ? condition.entity_id[0]\n          : condition.entity_id\n      ];\n    if (Array.isArray(condition.state)) {\n      for (const state of condition.state.values()) {\n        states.push(\n          condition.attribute\n            ? hass\n                .formatEntityAttributeValue(\n                  stateObj,\n                  condition.attribute,\n                  state\n                )\n                .toString()\n            : hass.formatEntityState(stateObj, state)\n        );\n      }\n    } else if (condition.state !== \"\") {\n      states.push(\n        condition.attribute\n          ? hass\n              .formatEntityAttributeValue(\n                stateObj,\n                condition.attribute,\n                condition.state\n              )\n              .toString()\n          : hass.formatEntityState(stateObj, condition.state.toString())\n      );\n    }\n\n    let duration = \"\";\n    if (condition.for) {\n      duration = describeDuration(hass.locale, condition.for) || \"\";\n    }\n\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.state.description.full`,\n      {\n        hasAttribute: attribute !== \"\" ? \"true\" : \"false\",\n        attribute: attribute,\n        numberOfEntities: entities.length,\n        entities:\n          condition.match === \"any\"\n            ? formatListWithOrs(hass.locale, entities)\n            : formatListWithAnds(hass.locale, entities),\n        numberOfStates: states.length,\n        states: formatListWithOrs(hass.locale, states),\n        hasDuration: duration !== \"\" ? \"true\" : \"false\",\n        duration: duration,\n      }\n    );\n  }\n\n  // Numeric State Condition\n  if (condition.condition === \"numeric_state\" && condition.entity_id) {\n    const stateObj = hass.states[condition.entity_id];\n    const entity = stateObj ? computeStateName(stateObj) : condition.entity_id;\n\n    const attribute = condition.attribute\n      ? computeAttributeNameDisplay(\n          hass.localize,\n          stateObj,\n          hass.entities,\n          condition.attribute\n        )\n      : undefined;\n\n    if (condition.above && condition.below) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.numeric_state.description.above-below`,\n        {\n          attribute: attribute,\n          entity: entity,\n          above: condition.above,\n          below: condition.below,\n        }\n      );\n    }\n    if (condition.above) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.numeric_state.description.above`,\n        {\n          attribute: attribute,\n          entity: entity,\n          above: condition.above,\n        }\n      );\n    }\n    if (condition.below) {\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.numeric_state.description.below`,\n        {\n          attribute: attribute,\n          entity: entity,\n          below: condition.below,\n        }\n      );\n    }\n  }\n\n  // Time condition\n  if (condition.condition === \"time\") {\n    const weekdaysArray = ensureArray(condition.weekday);\n    const validWeekdays =\n      weekdaysArray && weekdaysArray.length > 0 && weekdaysArray.length < 7;\n    if (condition.before || condition.after || validWeekdays) {\n      const before =\n        typeof condition.before !== \"string\"\n          ? condition.before\n          : condition.before.includes(\".\")\n            ? `entity ${\n                hass.states[condition.before]\n                  ? computeStateName(hass.states[condition.before])\n                  : condition.before\n              }`\n            : localizeTimeString(condition.before, hass.locale, hass.config);\n\n      const after =\n        typeof condition.after !== \"string\"\n          ? condition.after\n          : condition.after.includes(\".\")\n            ? `entity ${\n                hass.states[condition.after]\n                  ? computeStateName(hass.states[condition.after])\n                  : condition.after\n              }`\n            : localizeTimeString(condition.after, hass.locale, hass.config);\n\n      let localizedDays: string[] = [];\n      if (validWeekdays) {\n        localizedDays = weekdaysArray.map((d) =>\n          hass.localize(\n            `ui.panel.config.automation.editor.conditions.type.time.weekdays.${d}`\n          )\n        );\n      }\n\n      let hasTime = \"\";\n      if (after !== undefined && before !== undefined) {\n        hasTime = \"after_before\";\n      } else if (after !== undefined) {\n        hasTime = \"after\";\n      } else if (before !== undefined) {\n        hasTime = \"before\";\n      }\n\n      return hass.localize(\n        `${conditionsTranslationBaseKey}.time.description.full`,\n        {\n          hasTime: hasTime,\n          hasTimeAndDay: (after || before) && validWeekdays ? \"true\" : \"false\",\n          hasDay: validWeekdays ? \"true\" : \"false\",\n          time_before: before,\n          time_after: after,\n          day: formatListWithOrs(hass.locale, localizedDays),\n        }\n      );\n    }\n  }\n\n  // Sun condition\n  if (condition.condition === \"sun\" && (condition.before || condition.after)) {\n    let afterDuration = \"\";\n    if (condition.after && condition.after_offset) {\n      if (typeof condition.after_offset === \"number\") {\n        afterDuration = secondsToDuration(condition.after_offset)!;\n      } else if (typeof condition.after_offset === \"string\") {\n        afterDuration = condition.after_offset;\n      } else {\n        afterDuration = JSON.stringify(condition.after_offset);\n      }\n    }\n\n    let beforeDuration = \"\";\n    if (condition.before && condition.before_offset) {\n      if (typeof condition.before_offset === \"number\") {\n        beforeDuration = secondsToDuration(condition.before_offset)!;\n      } else if (typeof condition.before_offset === \"string\") {\n        beforeDuration = condition.before_offset;\n      } else {\n        beforeDuration = JSON.stringify(condition.before_offset);\n      }\n    }\n\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.sun.description.full`,\n      {\n        afterChoice: condition.after ?? \"other\",\n        afterOffsetChoice: afterDuration !== \"\" ? \"offset\" : \"other\",\n        afterOffset: afterDuration,\n        beforeChoice: condition.before ?? \"other\",\n        beforeOffsetChoice: beforeDuration !== \"\" ? \"offset\" : \"other\",\n        beforeOffset: beforeDuration,\n      }\n    );\n  }\n\n  // Zone condition\n  if (condition.condition === \"zone\" && condition.entity_id && condition.zone) {\n    const entities: string[] = [];\n    const zones: string[] = [];\n\n    const states = hass.states;\n\n    if (Array.isArray(condition.entity_id)) {\n      for (const entity of condition.entity_id.values()) {\n        if (states[entity]) {\n          entities.push(computeStateName(states[entity]) || entity);\n        }\n      }\n    } else {\n      entities.push(\n        states[condition.entity_id]\n          ? computeStateName(states[condition.entity_id])\n          : condition.entity_id\n      );\n    }\n\n    if (Array.isArray(condition.zone)) {\n      for (const zone of condition.zone.values()) {\n        if (states[zone]) {\n          zones.push(computeStateName(states[zone]) || zone);\n        }\n      }\n    } else {\n      zones.push(\n        states[condition.zone]\n          ? computeStateName(states[condition.zone])\n          : condition.zone\n      );\n    }\n\n    const entitiesString = formatListWithOrs(hass.locale, entities);\n    const zonesString = formatListWithOrs(hass.locale, zones);\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.zone.description.full`,\n      {\n        entity: entitiesString,\n        numberOfEntities: entities.length,\n        zone: zonesString,\n        numberOfZones: zones.length,\n      }\n    );\n  }\n\n  if (condition.condition === \"device\" && condition.device_id) {\n    const config = condition as DeviceCondition;\n    const localized = localizeDeviceAutomationCondition(\n      hass,\n      entityRegistry,\n      config\n    );\n    if (localized) {\n      return localized;\n    }\n    const stateObj = hass.states[config.entity_id as string];\n    return `${stateObj ? computeStateName(stateObj) : config.entity_id} ${\n      config.type\n    }`;\n  }\n\n  if (condition.condition === \"template\") {\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.template.description.full`\n    );\n  }\n\n  if (condition.condition === \"trigger\" && condition.id != null) {\n    return hass.localize(\n      `${conditionsTranslationBaseKey}.trigger.description.full`,\n      {\n        id: formatListWithOrs(\n          hass.locale,\n          ensureArray(condition.id).map((id) => id.toString())\n        ),\n      }\n    );\n  }\n\n  return (\n    hass.localize(\n      `ui.panel.config.automation.editor.conditions.type.${condition.condition}.label`\n    ) ||\n    hass.localize(\n      `ui.panel.config.automation.editor.conditions.unknown_condition`\n    )\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}