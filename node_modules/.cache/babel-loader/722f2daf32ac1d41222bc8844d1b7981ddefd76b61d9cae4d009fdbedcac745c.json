{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.string.trim.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nvar templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\nvar placeholderBugDetect = false;\nvar placeholderBug = false;\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    var t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nvar copyAttributeWithTemplateEventPolicy = function () {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  var polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy('polymer-template-event-attribute-policy', {\n    createScript: function createScript(x) {\n      return x;\n    }\n  });\n  return function (dest, src, name) {\n    var value = src.getAttribute(name);\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n    dest.setAttribute(name, value);\n  };\n}();\nfunction wrapTemplateExtension(node) {\n  var is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    var t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while (t.attributes.length) {\n      var name = t.attributes[0].name;\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  var parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (var j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  var handler = function handler(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport var TemplateStamp = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nfunction (superClass) {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  var TemplateStamp = /*#__PURE__*/function (_superClass) {\n    _inherits(TemplateStamp, _superClass);\n    function TemplateStamp() {\n      _classCallCheck(this, TemplateStamp);\n      return _callSuper(this, TemplateStamp, arguments);\n    }\n    _createClass(TemplateStamp, [{\n      key: \"_stampTemplate\",\n      value:\n      /**\n       * Clones the provided template content and returns a document fragment\n       * containing the cloned dom.\n       *\n       * The template is parsed (once and memoized) using this library's\n       * template parsing features, and provides the following value-added\n       * features:\n       * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n       * * Generates an \"id map\" for all nodes with id's under `$` on returned\n       *   document fragment\n       * * Passes template info including `content` back to templates as\n       *   `_templateInfo` (a performance optimization to avoid deep template\n       *   cloning)\n       *\n       * Note that the memoized template parsing process is destructive to the\n       * template: attributes for bindings and declarative event listeners are\n       * removed after being noted in notes, and any nested `<template>.content`\n       * is removed and stored in notes as well.\n       *\n       * @param {!HTMLTemplateElement} template Template to stamp\n       * @param {TemplateInfo=} templateInfo Optional template info associated\n       *   with the template to be stamped; if omitted the template will be\n       *   automatically parsed.\n       * @return {!StampedTemplate} Cloned template content\n       * @override\n       */\n      function _stampTemplate(template, templateInfo) {\n        // Polyfill support: bootstrap the template if it has not already been\n        if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n          HTMLTemplateElement.decorate(template);\n        }\n        // Accepting the `templateInfo` via an argument allows for creating\n        // instances of the `templateInfo` by the caller, useful for adding\n        // instance-time information to the prototypical data\n        templateInfo = templateInfo || this.constructor._parseTemplate(template);\n        var nodeInfo = templateInfo.nodeInfoList;\n        var content = templateInfo.content || template.content;\n        var dom = /** @type {DocumentFragment} */document.importNode(content, true);\n        // NOTE: ShadyDom optimization indicating there is an insertion point\n        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n        var nodes = dom.nodeList = new Array(nodeInfo.length);\n        dom.$ = {};\n        for (var i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {\n          var node = nodes[i] = findTemplateNode(dom, info);\n          applyIdToMap(this, dom.$, node, info);\n          applyTemplateInfo(this, node, info, templateInfo);\n          applyEventListener(this, node, info);\n        }\n        dom = /** @type {!StampedTemplate} */dom; // eslint-disable-line no-self-assign\n        return dom;\n      }\n\n      /**\n       * Adds an event listener by method name for the event provided.\n       *\n       * This method generates a handler function that looks up the method\n       * name at handling time.\n       *\n       * @param {!EventTarget} node Node to add listener on\n       * @param {string} eventName Name of event\n       * @param {string} methodName Name of method\n       * @param {*=} context Context the method will be called on (defaults\n       *   to `node`)\n       * @return {Function} Generated handler function\n       * @override\n       */\n    }, {\n      key: \"_addMethodEventListenerToNode\",\n      value: function _addMethodEventListenerToNode(node, eventName, methodName, context) {\n        context = context || node;\n        var handler = createNodeEventHandler(context, eventName, methodName);\n        this._addEventListenerToNode(node, eventName, handler);\n        return handler;\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {!EventTarget} node Node to add event listener to\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to add\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_addEventListenerToNode\",\n      value: function _addEventListenerToNode(node, eventName, handler) {\n        node.addEventListener(eventName, handler);\n      }\n\n      /**\n       * Override point for adding custom or simulated event handling.\n       *\n       * @param {!EventTarget} node Node to remove event listener from\n       * @param {string} eventName Name of event\n       * @param {function(!Event):void} handler Listener function to remove\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_removeEventListenerFromNode\",\n      value: function _removeEventListenerFromNode(node, eventName, handler) {\n        node.removeEventListener(eventName, handler);\n      }\n    }], [{\n      key: \"_parseTemplate\",\n      value:\n      /**\n       * Scans a template to produce template metadata.\n       *\n       * Template-specific metadata are stored in the object returned, and node-\n       * specific metadata are stored in objects in its flattened `nodeInfoList`\n       * array.  Only nodes in the template that were parsed as nodes of\n       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n       * contains an `index` (`childNodes` index in parent) and optionally\n       * `parent`, which points to node info of its parent (including its index).\n       *\n       * The template metadata object returned from this method has the following\n       * structure (many fields optional):\n       *\n       * ```js\n       *   {\n       *     // Flattened list of node metadata (for nodes that generated metadata)\n       *     nodeInfoList: [\n       *       {\n       *         // `id` attribute for any nodes with id's for generating `$` map\n       *         id: {string},\n       *         // `on-event=\"handler\"` metadata\n       *         events: [\n       *           {\n       *             name: {string},   // event name\n       *             value: {string},  // handler method name\n       *           }, ...\n       *         ],\n       *         // Notes when the template contained a `<slot>` for shady DOM\n       *         // optimization purposes\n       *         hasInsertionPoint: {boolean},\n       *         // For nested `<template>`` nodes, nested template metadata\n       *         templateInfo: {object}, // nested template metadata\n       *         // Metadata to allow efficient retrieval of instanced node\n       *         // corresponding to this metadata\n       *         parentInfo: {number},   // reference to parent nodeInfo>\n       *         parentIndex: {number},  // index in parent's `childNodes` collection\n       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n       *       },\n       *       ...\n       *     ],\n       *     // When true, the template had the `strip-whitespace` attribute\n       *     // or was nested in a template with that setting\n       *     stripWhitespace: {boolean},\n       *     // For nested templates, nested template content is moved into\n       *     // a document fragment stored here; this is an optimization to\n       *     // avoid the cost of nested template cloning\n       *     content: {DocumentFragment}\n       *   }\n       * ```\n       *\n       * This method kicks off a recursive treewalk as follows:\n       *\n       * ```\n       *    _parseTemplate <---------------------+\n       *      _parseTemplateContent              |\n       *        _parseTemplateNode  <------------|--+\n       *          _parseTemplateNestedTemplate --+  |\n       *          _parseTemplateChildNodes ---------+\n       *          _parseTemplateNodeAttributes\n       *            _parseTemplateNodeAttribute\n       *\n       * ```\n       *\n       * These methods may be overridden to add custom metadata about templates\n       * to either `templateInfo` or `nodeInfo`.\n       *\n       * Note that this method may be destructive to the template, in that\n       * e.g. event annotations may be removed after being noted in the\n       * template metadata.\n       *\n       * @param {!HTMLTemplateElement} template Template to parse\n       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n       *   template, for parsing nested templates\n       * @return {!TemplateInfo} Parsed template metadata\n       * @nocollapse\n       */\n      function _parseTemplate(template, outerTemplateInfo) {\n        // since a template may be re-used, memo-ize metadata\n        if (!template._templateInfo) {\n          // TODO(rictic): fix typing\n          var /** ? */templateInfo = template._templateInfo = {};\n          templateInfo.nodeInfoList = [];\n          templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute && template.hasAttribute('strip-whitespace');\n          // TODO(rictic): fix typing\n          this._parseTemplateContent(template, templateInfo, /** @type {?} */{\n            parent: null\n          });\n        }\n        return template._templateInfo;\n      }\n\n      /**\n       * See docs for _parseTemplateNode.\n       *\n       * @param {!HTMLTemplateElement} template .\n       * @param {!TemplateInfo} templateInfo .\n       * @param {!NodeInfo} nodeInfo .\n       * @return {boolean} .\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateContent\",\n      value: function _parseTemplateContent(template, templateInfo, nodeInfo) {\n        return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n      }\n\n      /**\n       * Parses template node and adds template and node metadata based on\n       * the current node, and its `childNodes` and `attributes`.\n       *\n       * This method may be overridden to add custom node or template specific\n       * metadata based on this node.\n       *\n       * @param {Node} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNode\",\n      value: function _parseTemplateNode(node, templateInfo, nodeInfo) {\n        var noted = false;\n        var element = /** @type {!HTMLTemplateElement} */node;\n        if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n        } else if (element.localName === 'slot') {\n          // For ShadyDom optimization, indicating there is an insertion point\n          templateInfo.hasInsertionPoint = true;\n        }\n        fixPlaceholder(element);\n        if (element.firstChild) {\n          this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n        }\n        if (element.hasAttributes && element.hasAttributes()) {\n          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n        }\n        // Checking `nodeInfo.noted` allows a child node of this node (who gets\n        // access to `parentInfo`) to cause the parent to be noted, which\n        // otherwise has no return path via `_parseTemplateChildNodes` (used by\n        // some optimizations)\n        return noted || nodeInfo.noted;\n      }\n\n      /**\n       * Parses template child nodes for the given root node.\n       *\n       * This method also wraps whitelisted legacy template extensions\n       * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n       * wrappers, collapses text nodes, and strips whitespace from the template\n       * if the `templateInfo.stripWhitespace` setting was provided.\n       *\n       * @param {Node} root Root node whose `childNodes` will be parsed\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {void}\n       */\n    }, {\n      key: \"_parseTemplateChildNodes\",\n      value: function _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n        if (root.localName === 'script' || root.localName === 'style') {\n          return;\n        }\n        for (var node = root.firstChild, parentIndex = 0, next; node; node = next) {\n          // Wrap templates\n          if (node.localName == 'template') {\n            node = wrapTemplateExtension(node);\n          }\n          // collapse adjacent textNodes: fixes an IE issue that can cause\n          // text nodes to be inexplicably split =(\n          // note that root.normalize() should work but does not so we do this\n          // manually.\n          next = node.nextSibling;\n          if (node.nodeType === Node.TEXT_NODE) {\n            var /** Node */n = next;\n            while (n && n.nodeType === Node.TEXT_NODE) {\n              node.textContent += n.textContent;\n              next = n.nextSibling;\n              root.removeChild(n);\n              n = next;\n            }\n            // optionally strip whitespace\n            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n              root.removeChild(node);\n              continue;\n            }\n          }\n          var childInfo = /** @type {!NodeInfo} */{\n            parentIndex: parentIndex,\n            parentInfo: nodeInfo\n          };\n          if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n            childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n          }\n          // Increment if not removed\n          if (node.parentNode) {\n            parentIndex++;\n          }\n        }\n      }\n\n      /**\n       * Parses template content for the given nested `<template>`.\n       *\n       * Nested template info is stored as `templateInfo` in the current node's\n       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n       * It will then be the responsibility of the host to set it back to the\n       * template and for users stamping nested templates to use the\n       * `_contentForTemplate` method to retrieve the content for this template\n       * (an optimization to avoid the cost of cloning nested template content).\n       *\n       * @param {HTMLTemplateElement} node Node to parse (a <template>)\n       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n       *   that includes the template `node`\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNestedTemplate\",\n      value: function _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n        // TODO(rictic): the type of node should be non-null\n        var element = /** @type {!HTMLTemplateElement} */node;\n        var templateInfo = this._parseTemplate(element, outerTemplateInfo);\n        var content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();\n        content.appendChild(element.content);\n        nodeInfo.templateInfo = templateInfo;\n        return true;\n      }\n\n      /**\n       * Parses template node attributes and adds node metadata to `nodeInfo`\n       * for nodes of interest.\n       *\n       * @param {Element} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current\n       *     template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNodeAttributes\",\n      value: function _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n        // Make copy of original attribute list, since the order may change\n        // as attributes are added and removed\n        var noted = false;\n        var attrs = Array.from(node.attributes);\n        for (var i = attrs.length - 1, a; a = attrs[i]; i--) {\n          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n        }\n        return noted;\n      }\n\n      /**\n       * Parses a single template node attribute and adds node metadata to\n       * `nodeInfo` for attributes of interest.\n       *\n       * This implementation adds metadata for `on-event=\"handler\"` attributes\n       * and `id` attributes.\n       *\n       * @param {Element} node Node to parse\n       * @param {!TemplateInfo} templateInfo Template metadata for current template\n       * @param {!NodeInfo} nodeInfo Node metadata for current template.\n       * @param {string} name Attribute name\n       * @param {string} value Attribute value\n       * @return {boolean} `true` if the visited node added node-specific\n       *   metadata to `nodeInfo`\n       * @nocollapse\n       */\n    }, {\n      key: \"_parseTemplateNodeAttribute\",\n      value: function _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n        // events (on-*)\n        if (name.slice(0, 3) === 'on-') {\n          node.removeAttribute(name);\n          nodeInfo.events = nodeInfo.events || [];\n          nodeInfo.events.push({\n            name: name.slice(3),\n            value: value\n          });\n          return true;\n        }\n        // static id\n        else if (name === 'id') {\n          nodeInfo.id = value;\n          return true;\n        }\n        return false;\n      }\n\n      /**\n       * Returns the `content` document fragment for a given template.\n       *\n       * For nested templates, Polymer performs an optimization to cache nested\n       * template content to avoid the cost of cloning deeply nested templates.\n       * This method retrieves the cached content for a given template.\n       *\n       * @param {HTMLTemplateElement} template Template to retrieve `content` for\n       * @return {DocumentFragment} Content fragment\n       * @nocollapse\n       */\n    }, {\n      key: \"_contentForTemplate\",\n      value: function _contentForTemplate(template) {\n        var templateInfo = /** @type {HTMLTemplateElementWithInfo} */template._templateInfo;\n        return templateInfo && templateInfo.content || template.content;\n      }\n    }]);\n    return TemplateStamp;\n  }(superClass);\n  return TemplateStamp;\n});","map":{"version":3,"names":["dedupingMixin","templateExtensions","placeholderBugDetect","placeholderBug","hasPlaceholderBug","t","document","createElement","placeholder","textContent","fixPlaceholder","node","localName","copyAttributeWithTemplateEventPolicy","polymerTemplateEventAttributePolicy","window","trustedTypes","createPolicy","createScript","x","dest","src","name","value","getAttribute","startsWith","setAttribute","wrapTemplateExtension","is","removeAttribute","ownerDocument","parentNode","replaceChild","appendChild","attributes","length","findTemplateNode","root","nodeInfo","parent","parentInfo","n","firstChild","i","nextSibling","parentIndex","applyIdToMap","inst","map","id","applyEventListener","events","j","e$","e","_addMethodEventListenerToNode","applyTemplateInfo","parentTemplateInfo","templateInfo","_templateInfo","_parentTemplateInfo","createNodeEventHandler","context","eventName","methodName","_methodHost","handler","detail","console","warn","TemplateStamp","superClass","_superClass","_inherits","_classCallCheck","_callSuper","arguments","_createClass","key","_stampTemplate","template","content","HTMLTemplateElement","decorate","constructor","_parseTemplate","nodeInfoList","dom","importNode","__noInsertionPoint","hasInsertionPoint","nodes","nodeList","Array","$","l","info","_addEventListenerToNode","addEventListener","_removeEventListenerFromNode","removeEventListener","outerTemplateInfo","nestedTemplate","Boolean","stripWhiteSpace","hasAttribute","_parseTemplateContent","_parseTemplateNode","noted","element","_parseTemplateNestedTemplate","_parseTemplateChildNodes","hasAttributes","_parseTemplateNodeAttributes","next","nodeType","Node","TEXT_NODE","removeChild","trim","childInfo","infoIndex","push","createDocumentFragment","attrs","from","a","_parseTemplateNodeAttribute","slice","_contentForTemplate"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/mixins/template-stamp.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\n\n// 1.x backwards-compatible auto-wrapper for template type extensions\n// This is a clear layering violation and gives favored-nation status to\n// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep\n// a.) to ease 1.x backwards-compatibility due to loss of `is`, and\n// b.) to maintain if/repeat capability in parser-constrained elements\n//     (e.g. table, select) in lieu of native CE type extensions without\n//     massive new invention in this space (e.g. directive system)\nconst templateExtensions = {\n  'dom-if': true,\n  'dom-repeat': true\n};\n\nlet placeholderBugDetect = false;\nlet placeholderBug = false;\n\nfunction hasPlaceholderBug() {\n  if (!placeholderBugDetect) {\n    placeholderBugDetect = true;\n    const t = document.createElement('textarea');\n    t.placeholder = 'a';\n    placeholderBug = t.placeholder === t.textContent;\n  }\n  return placeholderBug;\n}\n\n/**\n * Some browsers have a bug with textarea, where placeholder text is copied as\n * a textnode child of the textarea.\n *\n * If the placeholder is a binding, this can break template stamping in two\n * ways.\n *\n * One issue is that when the `placeholder` attribute is removed when the\n * binding is processed, the textnode child of the textarea is deleted, and the\n * template info tries to bind into that node.\n *\n * With `legacyOptimizations` in use, when the template is stamped and the\n * `textarea.textContent` binding is processed, no corresponding node is found\n * because it was removed during parsing. An exception is generated when this\n * binding is updated.\n *\n * With `legacyOptimizations` not in use, the template is cloned before\n * processing and this changes the above behavior. The cloned template also has\n * a value property set to the placeholder and textContent. This prevents the\n * removal of the textContent when the placeholder attribute is removed.\n * Therefore the exception does not occur. However, there is an extra\n * unnecessary binding.\n *\n * @param {!Node} node Check node for placeholder bug\n * @return {void}\n */\nfunction fixPlaceholder(node) {\n  if (hasPlaceholderBug() && node.localName === 'textarea' && node.placeholder\n        && node.placeholder === node.textContent) {\n    node.textContent = null;\n  }\n}\n\n/**\n * Copies an attribute from one element to another, converting the value to a\n * `TrustedScript` if it is named like a Polymer template event listener.\n *\n * @param {!Element} dest The element to set the attribute on\n * @param {!Element} src The element to read the attribute from\n * @param {string} name The name of the attribute\n */\nconst copyAttributeWithTemplateEventPolicy = (() => {\n  /**\n   * This `TrustedTypePolicy` is used to work around a Chrome bug in the Trusted\n   * Types API where any attribute that starts with `on` may only be set to a\n   * `TrustedScript` value, even if that attribute would not cause an event\n   * listener to be created. (See https://crbug.com/993268 for details.)\n   *\n   * Polymer's template system allows `<dom-if>` and `<dom-repeat>` to be\n   * written using the `<template is=\"...\">` syntax, even if there is no UA\n   * support for custom element extensions of built-in elements. In doing so, it\n   * copies attributes from the original `<template>` to a newly created\n   * `<dom-if>` or `<dom-repeat>`, which can trigger the bug mentioned above if\n   * any of those attributes uses Polymer's `on-` syntax for event listeners.\n   * (Note, the value of these `on-` listeners is not evaluated as script: it is\n   * the name of a member function of a component that will be used as the event\n   * listener.)\n   *\n   * @type {!TrustedTypePolicy|undefined}\n   */\n  const polymerTemplateEventAttributePolicy = window.trustedTypes &&\n      window.trustedTypes.createPolicy(\n          'polymer-template-event-attribute-policy', {\n            createScript: x => x,\n          });\n\n  return (dest, src, name) => {\n    const value = src.getAttribute(name);\n\n    if (polymerTemplateEventAttributePolicy && name.startsWith('on-')) {\n      dest.setAttribute(\n          name, polymerTemplateEventAttributePolicy.createScript(value, name));\n      return;\n    }\n\n    dest.setAttribute(name, value);\n  };\n})();\n\nfunction wrapTemplateExtension(node) {\n  let is = node.getAttribute('is');\n  if (is && templateExtensions[is]) {\n    let t = node;\n    t.removeAttribute('is');\n    node = t.ownerDocument.createElement(is);\n    t.parentNode.replaceChild(node, t);\n    node.appendChild(t);\n    while(t.attributes.length) {\n      const {name} = t.attributes[0];\n      copyAttributeWithTemplateEventPolicy(node, t, name);\n      t.removeAttribute(name);\n    }\n  }\n  return node;\n}\n\nfunction findTemplateNode(root, nodeInfo) {\n  // recursively ascend tree until we hit root\n  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);\n  // unwind the stack, returning the indexed node at each level\n  if (parent) {\n    // note: marginally faster than indexing via childNodes\n    // (http://jsperf.com/childnodes-lookup)\n    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {\n      if (nodeInfo.parentIndex === i++) {\n        return n;\n      }\n    }\n  } else {\n    return root;\n  }\n}\n\n// construct `$` map (from id annotations)\nfunction applyIdToMap(inst, map, node, nodeInfo) {\n  if (nodeInfo.id) {\n    map[nodeInfo.id] = node;\n  }\n}\n\n// install event listeners (from event annotations)\nfunction applyEventListener(inst, node, nodeInfo) {\n  if (nodeInfo.events && nodeInfo.events.length) {\n    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {\n      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);\n    }\n  }\n}\n\n// push configuration references at configure time\nfunction applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {\n  if (nodeInfo.templateInfo) {\n    // Give the node an instance of this templateInfo and set its parent\n    node._templateInfo = nodeInfo.templateInfo;\n    node._parentTemplateInfo = parentTemplateInfo;\n  }\n}\n\nfunction createNodeEventHandler(context, eventName, methodName) {\n  // Instances can optionally have a _methodHost which allows redirecting where\n  // to find methods. Currently used by `templatize`.\n  context = context._methodHost || context;\n  let handler = function(e) {\n    if (context[methodName]) {\n      context[methodName](e, e.detail);\n    } else {\n      console.warn('listener method `' + methodName + '` not defined');\n    }\n  };\n  return handler;\n}\n\n/**\n * Element mixin that provides basic template parsing and stamping, including\n * the following template-related features for stamped templates:\n *\n * - Declarative event listeners (`on-eventname=\"listener\"`)\n * - Map of node id's to stamped node instances (`this.$.id`)\n * - Nested template content caching/removal and re-installation (performance\n *   optimization)\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin that provides basic template parsing and stamping\n */\nexport const TemplateStamp = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_TemplateStamp}\n   */\n  class TemplateStamp extends superClass {\n\n    /**\n     * Scans a template to produce template metadata.\n     *\n     * Template-specific metadata are stored in the object returned, and node-\n     * specific metadata are stored in objects in its flattened `nodeInfoList`\n     * array.  Only nodes in the template that were parsed as nodes of\n     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object\n     * contains an `index` (`childNodes` index in parent) and optionally\n     * `parent`, which points to node info of its parent (including its index).\n     *\n     * The template metadata object returned from this method has the following\n     * structure (many fields optional):\n     *\n     * ```js\n     *   {\n     *     // Flattened list of node metadata (for nodes that generated metadata)\n     *     nodeInfoList: [\n     *       {\n     *         // `id` attribute for any nodes with id's for generating `$` map\n     *         id: {string},\n     *         // `on-event=\"handler\"` metadata\n     *         events: [\n     *           {\n     *             name: {string},   // event name\n     *             value: {string},  // handler method name\n     *           }, ...\n     *         ],\n     *         // Notes when the template contained a `<slot>` for shady DOM\n     *         // optimization purposes\n     *         hasInsertionPoint: {boolean},\n     *         // For nested `<template>`` nodes, nested template metadata\n     *         templateInfo: {object}, // nested template metadata\n     *         // Metadata to allow efficient retrieval of instanced node\n     *         // corresponding to this metadata\n     *         parentInfo: {number},   // reference to parent nodeInfo>\n     *         parentIndex: {number},  // index in parent's `childNodes` collection\n     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`\n     *       },\n     *       ...\n     *     ],\n     *     // When true, the template had the `strip-whitespace` attribute\n     *     // or was nested in a template with that setting\n     *     stripWhitespace: {boolean},\n     *     // For nested templates, nested template content is moved into\n     *     // a document fragment stored here; this is an optimization to\n     *     // avoid the cost of nested template cloning\n     *     content: {DocumentFragment}\n     *   }\n     * ```\n     *\n     * This method kicks off a recursive treewalk as follows:\n     *\n     * ```\n     *    _parseTemplate <---------------------+\n     *      _parseTemplateContent              |\n     *        _parseTemplateNode  <------------|--+\n     *          _parseTemplateNestedTemplate --+  |\n     *          _parseTemplateChildNodes ---------+\n     *          _parseTemplateNodeAttributes\n     *            _parseTemplateNodeAttribute\n     *\n     * ```\n     *\n     * These methods may be overridden to add custom metadata about templates\n     * to either `templateInfo` or `nodeInfo`.\n     *\n     * Note that this method may be destructive to the template, in that\n     * e.g. event annotations may be removed after being noted in the\n     * template metadata.\n     *\n     * @param {!HTMLTemplateElement} template Template to parse\n     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer\n     *   template, for parsing nested templates\n     * @return {!TemplateInfo} Parsed template metadata\n     * @nocollapse\n     */\n    static _parseTemplate(template, outerTemplateInfo) {\n      // since a template may be re-used, memo-ize metadata\n      if (!template._templateInfo) {\n        // TODO(rictic): fix typing\n        let /** ? */ templateInfo = template._templateInfo = {};\n        templateInfo.nodeInfoList = [];\n        templateInfo.nestedTemplate = Boolean(outerTemplateInfo);\n        templateInfo.stripWhiteSpace =\n          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||\n          (template.hasAttribute && template.hasAttribute('strip-whitespace'));\n         // TODO(rictic): fix typing\n         this._parseTemplateContent(\n             template, templateInfo, /** @type {?} */ ({parent: null}));\n      }\n      return template._templateInfo;\n    }\n\n    /**\n     * See docs for _parseTemplateNode.\n     *\n     * @param {!HTMLTemplateElement} template .\n     * @param {!TemplateInfo} templateInfo .\n     * @param {!NodeInfo} nodeInfo .\n     * @return {boolean} .\n     * @nocollapse\n     */\n    static _parseTemplateContent(template, templateInfo, nodeInfo) {\n      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);\n    }\n\n    /**\n     * Parses template node and adds template and node metadata based on\n     * the current node, and its `childNodes` and `attributes`.\n     *\n     * This method may be overridden to add custom node or template specific\n     * metadata based on this node.\n     *\n     * @param {Node} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNode(node, templateInfo, nodeInfo) {\n      let noted = false;\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {\n        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;\n      } else if (element.localName === 'slot') {\n        // For ShadyDom optimization, indicating there is an insertion point\n        templateInfo.hasInsertionPoint = true;\n      }\n      fixPlaceholder(element);\n      if (element.firstChild) {\n        this._parseTemplateChildNodes(element, templateInfo, nodeInfo);\n      }\n      if (element.hasAttributes && element.hasAttributes()) {\n        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;\n      }\n      // Checking `nodeInfo.noted` allows a child node of this node (who gets\n      // access to `parentInfo`) to cause the parent to be noted, which\n      // otherwise has no return path via `_parseTemplateChildNodes` (used by\n      // some optimizations)\n      return noted || nodeInfo.noted;\n    }\n\n    /**\n     * Parses template child nodes for the given root node.\n     *\n     * This method also wraps whitelisted legacy template extensions\n     * (`is=\"dom-if\"` and `is=\"dom-repeat\"`) with their equivalent element\n     * wrappers, collapses text nodes, and strips whitespace from the template\n     * if the `templateInfo.stripWhitespace` setting was provided.\n     *\n     * @param {Node} root Root node whose `childNodes` will be parsed\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {void}\n     */\n    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {\n      if (root.localName === 'script' || root.localName === 'style') {\n        return;\n      }\n      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {\n        // Wrap templates\n        if (node.localName == 'template') {\n          node = wrapTemplateExtension(node);\n        }\n        // collapse adjacent textNodes: fixes an IE issue that can cause\n        // text nodes to be inexplicably split =(\n        // note that root.normalize() should work but does not so we do this\n        // manually.\n        next = node.nextSibling;\n        if (node.nodeType === Node.TEXT_NODE) {\n          let /** Node */ n = next;\n          while (n && (n.nodeType === Node.TEXT_NODE)) {\n            node.textContent += n.textContent;\n            next = n.nextSibling;\n            root.removeChild(n);\n            n = next;\n          }\n          // optionally strip whitespace\n          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {\n            root.removeChild(node);\n            continue;\n          }\n        }\n        let childInfo =\n            /** @type {!NodeInfo} */ ({parentIndex, parentInfo: nodeInfo});\n        if (this._parseTemplateNode(node, templateInfo, childInfo)) {\n          childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;\n        }\n        // Increment if not removed\n        if (node.parentNode) {\n          parentIndex++;\n        }\n      }\n    }\n\n    /**\n     * Parses template content for the given nested `<template>`.\n     *\n     * Nested template info is stored as `templateInfo` in the current node's\n     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.\n     * It will then be the responsibility of the host to set it back to the\n     * template and for users stamping nested templates to use the\n     * `_contentForTemplate` method to retrieve the content for this template\n     * (an optimization to avoid the cost of cloning nested template content).\n     *\n     * @param {HTMLTemplateElement} node Node to parse (a <template>)\n     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template\n     *   that includes the template `node`\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {\n      // TODO(rictic): the type of node should be non-null\n      let element = /** @type {!HTMLTemplateElement} */ (node);\n      let templateInfo = this._parseTemplate(element, outerTemplateInfo);\n      let content = templateInfo.content =\n          element.content.ownerDocument.createDocumentFragment();\n      content.appendChild(element.content);\n      nodeInfo.templateInfo = templateInfo;\n      return true;\n    }\n\n    /**\n     * Parses template node attributes and adds node metadata to `nodeInfo`\n     * for nodes of interest.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current\n     *     template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {\n      // Make copy of original attribute list, since the order may change\n      // as attributes are added and removed\n      let noted = false;\n      let attrs = Array.from(node.attributes);\n      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {\n        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;\n      }\n      return noted;\n    }\n\n    /**\n     * Parses a single template node attribute and adds node metadata to\n     * `nodeInfo` for attributes of interest.\n     *\n     * This implementation adds metadata for `on-event=\"handler\"` attributes\n     * and `id` attributes.\n     *\n     * @param {Element} node Node to parse\n     * @param {!TemplateInfo} templateInfo Template metadata for current template\n     * @param {!NodeInfo} nodeInfo Node metadata for current template.\n     * @param {string} name Attribute name\n     * @param {string} value Attribute value\n     * @return {boolean} `true` if the visited node added node-specific\n     *   metadata to `nodeInfo`\n     * @nocollapse\n     */\n    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {\n      // events (on-*)\n      if (name.slice(0, 3) === 'on-') {\n        node.removeAttribute(name);\n        nodeInfo.events = nodeInfo.events || [];\n        nodeInfo.events.push({\n          name: name.slice(3),\n          value\n        });\n        return true;\n      }\n      // static id\n      else if (name === 'id') {\n        nodeInfo.id = value;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Returns the `content` document fragment for a given template.\n     *\n     * For nested templates, Polymer performs an optimization to cache nested\n     * template content to avoid the cost of cloning deeply nested templates.\n     * This method retrieves the cached content for a given template.\n     *\n     * @param {HTMLTemplateElement} template Template to retrieve `content` for\n     * @return {DocumentFragment} Content fragment\n     * @nocollapse\n     */\n    static _contentForTemplate(template) {\n      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;\n      return (templateInfo && templateInfo.content) || template.content;\n    }\n\n    /**\n     * Clones the provided template content and returns a document fragment\n     * containing the cloned dom.\n     *\n     * The template is parsed (once and memoized) using this library's\n     * template parsing features, and provides the following value-added\n     * features:\n     * * Adds declarative event listeners for `on-event=\"handler\"` attributes\n     * * Generates an \"id map\" for all nodes with id's under `$` on returned\n     *   document fragment\n     * * Passes template info including `content` back to templates as\n     *   `_templateInfo` (a performance optimization to avoid deep template\n     *   cloning)\n     *\n     * Note that the memoized template parsing process is destructive to the\n     * template: attributes for bindings and declarative event listeners are\n     * removed after being noted in notes, and any nested `<template>.content`\n     * is removed and stored in notes as well.\n     *\n     * @param {!HTMLTemplateElement} template Template to stamp\n     * @param {TemplateInfo=} templateInfo Optional template info associated\n     *   with the template to be stamped; if omitted the template will be\n     *   automatically parsed.\n     * @return {!StampedTemplate} Cloned template content\n     * @override\n     */\n    _stampTemplate(template, templateInfo) {\n      // Polyfill support: bootstrap the template if it has not already been\n      if (template && !template.content &&\n          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\n        HTMLTemplateElement.decorate(template);\n      }\n      // Accepting the `templateInfo` via an argument allows for creating\n      // instances of the `templateInfo` by the caller, useful for adding\n      // instance-time information to the prototypical data\n      templateInfo = templateInfo || this.constructor._parseTemplate(template);\n      let nodeInfo = templateInfo.nodeInfoList;\n      let content = templateInfo.content || template.content;\n      let dom = /** @type {DocumentFragment} */ (document.importNode(content, true));\n      // NOTE: ShadyDom optimization indicating there is an insertion point\n      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;\n      let nodes = dom.nodeList = new Array(nodeInfo.length);\n      dom.$ = {};\n      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {\n        let node = nodes[i] = findTemplateNode(dom, info);\n        applyIdToMap(this, dom.$, node, info);\n        applyTemplateInfo(this, node, info, templateInfo);\n        applyEventListener(this, node, info);\n      }\n      dom = /** @type {!StampedTemplate} */(dom); // eslint-disable-line no-self-assign\n      return dom;\n    }\n\n    /**\n     * Adds an event listener by method name for the event provided.\n     *\n     * This method generates a handler function that looks up the method\n     * name at handling time.\n     *\n     * @param {!EventTarget} node Node to add listener on\n     * @param {string} eventName Name of event\n     * @param {string} methodName Name of method\n     * @param {*=} context Context the method will be called on (defaults\n     *   to `node`)\n     * @return {Function} Generated handler function\n     * @override\n     */\n    _addMethodEventListenerToNode(node, eventName, methodName, context) {\n      context = context || node;\n      let handler = createNodeEventHandler(context, eventName, methodName);\n      this._addEventListenerToNode(node, eventName, handler);\n      return handler;\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to add event listener to\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to add\n     * @return {void}\n     * @override\n     */\n    _addEventListenerToNode(node, eventName, handler) {\n      node.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Override point for adding custom or simulated event handling.\n     *\n     * @param {!EventTarget} node Node to remove event listener from\n     * @param {string} eventName Name of event\n     * @param {function(!Event):void} handler Listener function to remove\n     * @return {void}\n     * @override\n     */\n    _removeEventListenerFromNode(node, eventName, handler) {\n      node.removeEventListener(eventName, handler);\n    }\n\n  }\n\n  return TemplateStamp;\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}