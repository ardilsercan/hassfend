{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier {\n  constructor(defaultValue) {\n    this.subscriptions = new Map();\n    this.updateObservers = () => {\n      for (const [callback, {\n        disposer\n      }] of this.subscriptions) {\n        callback(this._value, disposer);\n      }\n    };\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  set value(v) {\n    this.setValue(v);\n  }\n  setValue(v, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n  addCallback(callback, consumerHost, subscribe) {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost\n      });\n    }\n    const {\n      disposer\n    } = this.subscriptions.get(callback);\n    callback(this.value, disposer);\n  }\n  clearCallbacks() {\n    this.subscriptions.clear();\n  }\n}","map":{"version":3,"names":["ValueNotifier","constructor","defaultValue","subscriptions","Map","updateObservers","callback","disposer","_value","undefined","value","v","setValue","force","update","Object","is","addCallback","consumerHost","subscribe","has","set","delete","get","clearCallbacks","clear"],"sources":["../../src/lib/value-notifier.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\ninterface CallbackInfo {\n  disposer: Disposer;\n  consumerHost: Element;\n}\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when\n * the value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to\n * get behavior like this. But this is a pretty minimal approach that will\n * likely work for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  protected readonly subscriptions: Map<ContextCallback<T>, CallbackInfo> =\n    new Map();\n  private _value!: T;\n  get value(): T {\n    return this._value;\n  }\n  set value(v: T) {\n    this.setValue(v);\n  }\n\n  setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, {disposer}] of this.subscriptions) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(\n    callback: ContextCallback<T>,\n    consumerHost: Element,\n    subscribe?: boolean\n  ): void {\n    if (!subscribe) {\n      // just call the callback once and we're done\n      callback(this.value);\n      return;\n    }\n    if (!this.subscriptions.has(callback)) {\n      this.subscriptions.set(callback, {\n        disposer: () => {\n          this.subscriptions.delete(callback);\n        },\n        consumerHost,\n      });\n    }\n    const {disposer} = this.subscriptions.get(callback)!;\n    callback(this.value, disposer);\n  }\n\n  clearCallbacks(): void {\n    this.subscriptions.clear();\n  }\n}\n"],"mappings":"AAAA;;;;;AAkBA;;;;;;;;AAQA,OAAM,MAAOA,aAAa;EAmBxBC,YAAYC,YAAgB;IAlBT,KAAAC,aAAa,GAC9B,IAAIC,GAAG,EAAE;IAuBX,KAAAC,eAAe,GAAG,MAAW;MAC3B,KAAK,MAAM,CAACC,QAAQ,EAAE;QAACC;MAAQ,CAAC,CAAC,IAAI,IAAI,CAACJ,aAAa,EAAE;QACvDG,QAAQ,CAAC,IAAI,CAACE,MAAM,EAAED,QAAQ,CAAC;;IAEnC,CAAC;IATC,IAAIL,YAAY,KAAKO,SAAS,EAAE;MAC9B,IAAI,CAACC,KAAK,GAAGR,YAAY;;EAE7B;EAnBA,IAAIQ,KAAKA,CAAA;IACP,OAAO,IAAI,CAACF,MAAM;EACpB;EACA,IAAIE,KAAKA,CAACC,CAAI;IACZ,IAAI,CAACC,QAAQ,CAACD,CAAC,CAAC;EAClB;EAEAC,QAAQA,CAACD,CAAI,EAAEE,KAAK,GAAG,KAAK;IAC1B,MAAMC,MAAM,GAAGD,KAAK,IAAI,CAACE,MAAM,CAACC,EAAE,CAACL,CAAC,EAAE,IAAI,CAACH,MAAM,CAAC;IAClD,IAAI,CAACA,MAAM,GAAGG,CAAC;IACf,IAAIG,MAAM,EAAE;MACV,IAAI,CAACT,eAAe,EAAE;;EAE1B;EAcAY,WAAWA,CACTX,QAA4B,EAC5BY,YAAqB,EACrBC,SAAmB;IAEnB,IAAI,CAACA,SAAS,EAAE;MACd;MACAb,QAAQ,CAAC,IAAI,CAACI,KAAK,CAAC;MACpB;;IAEF,IAAI,CAAC,IAAI,CAACP,aAAa,CAACiB,GAAG,CAACd,QAAQ,CAAC,EAAE;MACrC,IAAI,CAACH,aAAa,CAACkB,GAAG,CAACf,QAAQ,EAAE;QAC/BC,QAAQ,EAAEA,CAAA,KAAK;UACb,IAAI,CAACJ,aAAa,CAACmB,MAAM,CAAChB,QAAQ,CAAC;QACrC,CAAC;QACDY;OACD,CAAC;;IAEJ,MAAM;MAACX;IAAQ,CAAC,GAAG,IAAI,CAACJ,aAAa,CAACoB,GAAG,CAACjB,QAAQ,CAAE;IACpDA,QAAQ,CAAC,IAAI,CAACI,KAAK,EAAEH,QAAQ,CAAC;EAChC;EAEAiB,cAAcA,CAAA;IACZ,IAAI,CAACrB,aAAa,CAACsB,KAAK,EAAE;EAC5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}