{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\n/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getFocusableElements, isElementFocused } from './focus-utils.js';\nvar instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nexport var FocusTrapController = /*#__PURE__*/function () {\n  /**\n   * @param {HTMLElement} host\n   */\n  function FocusTrapController(host) {\n    _classCallCheck(this, FocusTrapController);\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  _createClass(FocusTrapController, [{\n    key: \"__focusableElements\",\n    get: function get() {\n      return getFocusableElements(this.__trapNode);\n    }\n\n    /**\n     * The index of the element inside the trap node that currently has focus.\n     *\n     * @return {HTMLElement | undefined}\n     * @private\n     */\n  }, {\n    key: \"__focusedElementIndex\",\n    get: function get() {\n      var focusableElements = this.__focusableElements;\n      return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());\n    }\n  }, {\n    key: \"hostConnected\",\n    value: function hostConnected() {\n      document.addEventListener('keydown', this.__onKeyDown);\n    }\n  }, {\n    key: \"hostDisconnected\",\n    value: function hostDisconnected() {\n      document.removeEventListener('keydown', this.__onKeyDown);\n    }\n\n    /**\n     * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n     * The trap can be deactivated with the `.releaseFocus()` method.\n     *\n     * If focus is initially outside the trap, the method will move focus inside,\n     * on the first focusable element of the trap in the tab order.\n     * The first focusable element can be the trap node itself if it is focusable\n     * and comes first in the tab order.\n     *\n     * If there are no focusable elements, the method will throw an exception\n     * and the trap will not be set.\n     *\n     * @param {HTMLElement} trapNode\n     */\n  }, {\n    key: \"trapFocus\",\n    value: function trapFocus(trapNode) {\n      this.__trapNode = trapNode;\n      if (this.__focusableElements.length === 0) {\n        this.__trapNode = null;\n        throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n      }\n      instances.push(this);\n      if (this.__focusedElementIndex === -1) {\n        this.__focusableElements[0].focus();\n      }\n    }\n\n    /**\n     * Deactivates the focus trap set with the `.trapFocus()` method\n     * so that it becomes possible to tab outside the trap node.\n     */\n  }, {\n    key: \"releaseFocus\",\n    value: function releaseFocus() {\n      this.__trapNode = null;\n      instances.pop();\n    }\n\n    /**\n     * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n     *\n     * - Moves focus to the next focusable element of the trap on `Tab` press.\n     * When no next element to focus, the method moves focus to the first focusable element.\n     * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n     * When no prev element to focus, the method moves focus to the last focusable element.\n     *\n     * @param {KeyboardEvent} event\n     * @private\n     */\n  }, {\n    key: \"__onKeyDown\",\n    value: function __onKeyDown(event) {\n      if (!this.__trapNode) {\n        return;\n      }\n\n      // Only handle events for the last instance\n      if (this !== Array.from(instances).pop()) {\n        return;\n      }\n      if (event.key === 'Tab') {\n        event.preventDefault();\n        var backward = event.shiftKey;\n        this.__focusNextElement(backward);\n      }\n    }\n\n    /**\n     * - Moves focus to the next focusable element if `backward === false`.\n     * When no next element to focus, the method moves focus to the first focusable element.\n     * - Moves focus to the prev focusable element if `backward === true`.\n     * When no prev element to focus the method moves focus to the last focusable element.\n     *\n     * If no focusable elements, the method returns immediately.\n     *\n     * @param {boolean} backward\n     * @private\n     */\n  }, {\n    key: \"__focusNextElement\",\n    value: function __focusNextElement() {\n      var backward = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var focusableElements = this.__focusableElements;\n      var step = backward ? -1 : 1;\n      var currentIndex = this.__focusedElementIndex;\n      var nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n      var element = focusableElements[nextIndex];\n      element.focus();\n      if (element.localName === 'input') {\n        element.select();\n      }\n    }\n  }]);\n  return FocusTrapController;\n}();","map":{"version":3,"names":["getFocusableElements","isElementFocused","instances","FocusTrapController","host","_classCallCheck","__trapNode","__onKeyDown","bind","_createClass","key","get","focusableElements","__focusableElements","indexOf","filter","pop","value","hostConnected","document","addEventListener","hostDisconnected","removeEventListener","trapFocus","trapNode","length","Error","push","__focusedElementIndex","focus","releaseFocus","event","Array","from","preventDefault","backward","shiftKey","__focusNextElement","arguments","undefined","step","currentIndex","nextIndex","element","localName","select"],"sources":["/workspaces/frontend/node_modules/@vaadin/a11y-base/src/focus-trap-controller.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getFocusableElements, isElementFocused } from './focus-utils.js';\n\nconst instances = [];\n\n/**\n * A controller for trapping focus within a DOM node.\n */\nexport class FocusTrapController {\n  /**\n   * @param {HTMLElement} host\n   */\n  constructor(host) {\n    /**\n     * The controller host element.\n     *\n     * @type {HTMLElement}\n     */\n    this.host = host;\n\n    /**\n     * A node for trapping focus in.\n     *\n     * @type {HTMLElement | null}\n     * @private\n     */\n    this.__trapNode = null;\n\n    this.__onKeyDown = this.__onKeyDown.bind(this);\n  }\n\n  /**\n   * An array of tab-ordered focusable elements inside the trap node.\n   *\n   * @return {HTMLElement[]}\n   * @private\n   */\n  get __focusableElements() {\n    return getFocusableElements(this.__trapNode);\n  }\n\n  /**\n   * The index of the element inside the trap node that currently has focus.\n   *\n   * @return {HTMLElement | undefined}\n   * @private\n   */\n  get __focusedElementIndex() {\n    const focusableElements = this.__focusableElements;\n    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());\n  }\n\n  hostConnected() {\n    document.addEventListener('keydown', this.__onKeyDown);\n  }\n\n  hostDisconnected() {\n    document.removeEventListener('keydown', this.__onKeyDown);\n  }\n\n  /**\n   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.\n   * The trap can be deactivated with the `.releaseFocus()` method.\n   *\n   * If focus is initially outside the trap, the method will move focus inside,\n   * on the first focusable element of the trap in the tab order.\n   * The first focusable element can be the trap node itself if it is focusable\n   * and comes first in the tab order.\n   *\n   * If there are no focusable elements, the method will throw an exception\n   * and the trap will not be set.\n   *\n   * @param {HTMLElement} trapNode\n   */\n  trapFocus(trapNode) {\n    this.__trapNode = trapNode;\n\n    if (this.__focusableElements.length === 0) {\n      this.__trapNode = null;\n      throw new Error('The trap node should have at least one focusable descendant or be focusable itself.');\n    }\n\n    instances.push(this);\n\n    if (this.__focusedElementIndex === -1) {\n      this.__focusableElements[0].focus();\n    }\n  }\n\n  /**\n   * Deactivates the focus trap set with the `.trapFocus()` method\n   * so that it becomes possible to tab outside the trap node.\n   */\n  releaseFocus() {\n    this.__trapNode = null;\n\n    instances.pop();\n  }\n\n  /**\n   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.\n   *\n   * - Moves focus to the next focusable element of the trap on `Tab` press.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.\n   * When no prev element to focus, the method moves focus to the last focusable element.\n   *\n   * @param {KeyboardEvent} event\n   * @private\n   */\n  __onKeyDown(event) {\n    if (!this.__trapNode) {\n      return;\n    }\n\n    // Only handle events for the last instance\n    if (this !== Array.from(instances).pop()) {\n      return;\n    }\n\n    if (event.key === 'Tab') {\n      event.preventDefault();\n\n      const backward = event.shiftKey;\n      this.__focusNextElement(backward);\n    }\n  }\n\n  /**\n   * - Moves focus to the next focusable element if `backward === false`.\n   * When no next element to focus, the method moves focus to the first focusable element.\n   * - Moves focus to the prev focusable element if `backward === true`.\n   * When no prev element to focus the method moves focus to the last focusable element.\n   *\n   * If no focusable elements, the method returns immediately.\n   *\n   * @param {boolean} backward\n   * @private\n   */\n  __focusNextElement(backward = false) {\n    const focusableElements = this.__focusableElements;\n    const step = backward ? -1 : 1;\n    const currentIndex = this.__focusedElementIndex;\n    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;\n    const element = focusableElements[nextIndex];\n    element.focus();\n    if (element.localName === 'input') {\n      element.select();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}