{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\n/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Home Assistant object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport var timeCachePromiseFunc = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cacheKey, cacheTime, func, generateCacheKey, hass) {\n    var _len,\n      args,\n      _key,\n      anyHass,\n      lastResult,\n      checkCachedResult,\n      resultPromise,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, args = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n            args[_key - 5] = _args[_key];\n          }\n          anyHass = hass;\n          lastResult = anyHass[cacheKey];\n          checkCachedResult = function checkCachedResult(result) {\n            if (!generateCacheKey || generateCacheKey(hass, result.result) === result.cacheKey) {\n              return result.result;\n            }\n            anyHass[cacheKey] = undefined;\n            return timeCachePromiseFunc.apply(void 0, [cacheKey, cacheTime, func, generateCacheKey, hass].concat(args));\n          }; // If we have a cached result, return it if it's still valid\n          if (!lastResult) {\n            _context.next = 6;\n            break;\n          }\n          return _context.abrupt(\"return\", lastResult instanceof Promise ? lastResult.then(checkCachedResult) : checkCachedResult(lastResult));\n        case 6:\n          resultPromise = func.apply(void 0, [hass].concat(args));\n          anyHass[cacheKey] = resultPromise;\n          resultPromise.then(\n          // When successful, set timer to clear cache\n          function (result) {\n            anyHass[cacheKey] = {\n              result: result,\n              cacheKey: generateCacheKey === null || generateCacheKey === void 0 ? void 0 : generateCacheKey(hass, result)\n            };\n            setTimeout(function () {\n              anyHass[cacheKey] = undefined;\n            }, cacheTime);\n          },\n          // On failure, clear cache right away\n          function () {\n            anyHass[cacheKey] = undefined;\n          });\n          return _context.abrupt(\"return\", resultPromise);\n        case 10:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function timeCachePromiseFunc(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["timeCachePromiseFunc","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","cacheKey","cacheTime","func","generateCacheKey","hass","_len","args","_key","anyHass","lastResult","checkCachedResult","resultPromise","_args","arguments","wrap","_callee$","_context","prev","next","length","Array","result","undefined","apply","concat","abrupt","Promise","then","setTimeout","stop","_x","_x2","_x3","_x4","_x5"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/util/time-cache-function-promise.ts"],"sourcesContent":["import { HomeAssistant } from \"../../types\";\n\ninterface CacheResult<T> {\n  result: T;\n  cacheKey: any;\n}\n\n/**\n * Caches a result of a promise for X time. Allows optional extra validation\n * check to invalidate the cache.\n * @param cacheKey the key to store the cache\n * @param cacheTime the time to cache the result\n * @param func the function to fetch the data\n * @param generateCacheKey optional function to generate a cache key based on current hass + cached result. Cache is invalid if generates a different cache key.\n * @param hass Home Assistant object\n * @param args extra arguments to pass to the function to fetch the data\n * @returns\n */\nexport const timeCachePromiseFunc = async <T>(\n  cacheKey: string,\n  cacheTime: number,\n  func: (hass: HomeAssistant, ...args: any[]) => Promise<T>,\n  generateCacheKey:\n    | ((hass: HomeAssistant, lastResult: T) => unknown)\n    | undefined,\n  hass: HomeAssistant,\n  ...args: any[]\n): Promise<T> => {\n  const anyHass = hass as any;\n  const lastResult: Promise<CacheResult<T>> | CacheResult<T> | undefined =\n    anyHass[cacheKey];\n\n  const checkCachedResult = (result: CacheResult<T>): T | Promise<T> => {\n    if (\n      !generateCacheKey ||\n      generateCacheKey(hass, result.result) === result.cacheKey\n    ) {\n      return result.result;\n    }\n\n    anyHass[cacheKey] = undefined;\n    return timeCachePromiseFunc(\n      cacheKey,\n      cacheTime,\n      func,\n      generateCacheKey,\n      hass,\n      ...args\n    );\n  };\n\n  // If we have a cached result, return it if it's still valid\n  if (lastResult) {\n    return lastResult instanceof Promise\n      ? lastResult.then(checkCachedResult)\n      : checkCachedResult(lastResult);\n  }\n\n  const resultPromise = func(hass, ...args);\n  anyHass[cacheKey] = resultPromise;\n\n  resultPromise.then(\n    // When successful, set timer to clear cache\n    (result) => {\n      anyHass[cacheKey] = {\n        result,\n        cacheKey: generateCacheKey?.(hass, result),\n      };\n      setTimeout(() => {\n        anyHass[cacheKey] = undefined;\n      }, cacheTime);\n    },\n    // On failure, clear cache right away\n    () => {\n      anyHass[cacheKey] = undefined;\n    }\n  );\n\n  return resultPromise;\n};\n"],"mappings":";;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMA,oBAAoB;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAClCC,QAAgB,EAChBC,SAAiB,EACjBC,IAAyD,EACzDC,gBAEa,EACbC,IAAmB;IAAA,IAAAC,IAAA;MAAAC,IAAA;MAAAC,IAAA;MAAAC,OAAA;MAAAC,UAAA;MAAAC,iBAAA;MAAAC,aAAA;MAAAC,KAAA,GAAAC,SAAA;IAAA,OAAAhB,mBAAA,GAAAiB,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,KAAAb,IAAA,GAAAO,KAAA,CAAAO,MAAA,EAChBb,IAAI,OAAAc,KAAA,CAAAf,IAAA,OAAAA,IAAA,WAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;YAAJD,IAAI,CAAAC,IAAA,QAAAK,KAAA,CAAAL,IAAA;UAAA;UAEDC,OAAO,GAAGJ,IAAI;UACdK,UAAgE,GACpED,OAAO,CAACR,QAAQ,CAAC;UAEbU,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIW,MAAsB,EAAqB;YACpE,IACE,CAAClB,gBAAgB,IACjBA,gBAAgB,CAACC,IAAI,EAAEiB,MAAM,CAACA,MAAM,CAAC,KAAKA,MAAM,CAACrB,QAAQ,EACzD;cACA,OAAOqB,MAAM,CAACA,MAAM;YACtB;YAEAb,OAAO,CAACR,QAAQ,CAAC,GAAGsB,SAAS;YAC7B,OAAO5B,oBAAoB,CAAA6B,KAAA,UACzBvB,QAAQ,EACRC,SAAS,EACTC,IAAI,EACJC,gBAAgB,EAChBC,IAAI,EAAAoB,MAAA,CACDlB,IAAI,CACT,CAAC;UACH,CAAC,EAED;UAAA,KACIG,UAAU;YAAAO,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAS,MAAA,WACLhB,UAAU,YAAYiB,OAAO,GAChCjB,UAAU,CAACkB,IAAI,CAACjB,iBAAiB,CAAC,GAClCA,iBAAiB,CAACD,UAAU,CAAC;QAAA;UAG7BE,aAAa,GAAGT,IAAI,CAAAqB,KAAA,UAACnB,IAAI,EAAAoB,MAAA,CAAKlB,IAAI,EAAC;UACzCE,OAAO,CAACR,QAAQ,CAAC,GAAGW,aAAa;UAEjCA,aAAa,CAACgB,IAAI;UAChB;UACA,UAACN,MAAM,EAAK;YACVb,OAAO,CAACR,QAAQ,CAAC,GAAG;cAClBqB,MAAM,EAANA,MAAM;cACNrB,QAAQ,EAAEG,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAGC,IAAI,EAAEiB,MAAM;YAC3C,CAAC;YACDO,UAAU,CAAC,YAAM;cACfpB,OAAO,CAACR,QAAQ,CAAC,GAAGsB,SAAS;YAC/B,CAAC,EAAErB,SAAS,CAAC;UACf,CAAC;UACD;UACA,YAAM;YACJO,OAAO,CAACR,QAAQ,CAAC,GAAGsB,SAAS;UAC/B,CACF,CAAC;UAAC,OAAAN,QAAA,CAAAS,MAAA,WAEKd,aAAa;QAAA;QAAA;UAAA,OAAAK,QAAA,CAAAa,IAAA;MAAA;IAAA,GAAA9B,OAAA;EAAA,CACrB;EAAA,gBA7DYL,oBAAoBA,CAAAoC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;IAAA,OAAAvC,IAAA,CAAA4B,KAAA,OAAAV,SAAA;EAAA;AAAA,GA6DhC"},"metadata":{},"sourceType":"module","externalDependencies":[]}