{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nconst mdiFlash = \"M7,2V13H10V22L17,10H13L17,2H7Z\";\nconst mdiFlashOff = \"M17,10H13L17,2H7V4.18L15.46,12.64M3.27,3L2,4.27L7,9.27V13H10V22L13.58,15.86L17.73,20L19,18.73L3.27,3Z\";\nimport { LitElement, css, html } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { STATES_OFF } from \"../../common/const\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { UNAVAILABLE, UNKNOWN, isUnavailableState } from \"../../data/entity\";\nimport { forwardHaptic } from \"../../data/haptics\";\nimport \"../ha-formfield\";\nimport \"../ha-icon-button\";\nimport \"../ha-switch\";\nconst isOn = stateObj => stateObj !== undefined && !STATES_OFF.includes(stateObj.state) && !isUnavailableState(stateObj.state);\nexport let HaEntityToggle = _decorate([customElement(\"ha-entity-toggle\")], function (_initialize, _LitElement) {\n  class HaEntityToggle extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaEntityToggle,\n    d: [{\n      kind: \"field\",\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"stateObj\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"label\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_isOn\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value:\n      // hass is not a property so that we only re-render on stateObj changes\n\n      function render() {\n        if (!this.stateObj) {\n          return html` <ha-switch disabled></ha-switch> `;\n        }\n        if (this.stateObj.attributes.assumed_state || this.stateObj.state === UNKNOWN) {\n          return html`\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} off`}\n          .path=${mdiFlashOff}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOff}\n          class=${!this._isOn && this.stateObj.state !== UNKNOWN ? \"state-active\" : \"\"}\n        ></ha-icon-button>\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} on`}\n          .path=${mdiFlash}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOn}\n          class=${this._isOn ? \"state-active\" : \"\"}\n        ></ha-icon-button>\n      `;\n        }\n        const switchTemplate = html`<ha-switch\n      aria-label=${`Toggle ${computeStateName(this.stateObj)} ${this._isOn ? \"off\" : \"on\"}`}\n      .checked=${this._isOn}\n      .disabled=${this.stateObj.state === UNAVAILABLE}\n      @change=${this._toggleChanged}\n    ></ha-switch>`;\n        if (!this.label) {\n          return switchTemplate;\n        }\n        return html`\n      <ha-formfield .label=${this.label}>${switchTemplate}</ha-formfield>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated(changedProps) {\n        _get(_getPrototypeOf(HaEntityToggle.prototype), \"firstUpdated\", this).call(this, changedProps);\n        this.addEventListener(\"click\", ev => ev.stopPropagation());\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        _get(_getPrototypeOf(HaEntityToggle.prototype), \"willUpdate\", this).call(this, changedProps);\n        if (changedProps.has(\"stateObj\")) {\n          this._isOn = isOn(this.stateObj);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_toggleChanged\",\n      value: function _toggleChanged(ev) {\n        const newVal = ev.target.checked;\n        if (newVal !== this._isOn) {\n          this._callService(newVal);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_turnOn\",\n      value: function _turnOn() {\n        this._callService(true);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_turnOff\",\n      value: function _turnOff() {\n        this._callService(false);\n      }\n\n      // We will force a re-render after a successful call to re-sync the toggle\n      // with the state. It will be out of sync if our service call did not\n      // result in the entity to be turned on. Since the state is not changing,\n      // the resync is not called automatic.\n    }, {\n      kind: \"method\",\n      key: \"_callService\",\n      value: async function _callService(turnOn) {\n        if (!this.hass || !this.stateObj) {\n          return;\n        }\n        forwardHaptic(\"light\");\n        const stateDomain = computeStateDomain(this.stateObj);\n        let serviceDomain;\n        let service;\n        if (stateDomain === \"lock\") {\n          serviceDomain = \"lock\";\n          service = turnOn ? \"unlock\" : \"lock\";\n        } else if (stateDomain === \"cover\") {\n          serviceDomain = \"cover\";\n          service = turnOn ? \"open_cover\" : \"close_cover\";\n        } else if (stateDomain === \"valve\") {\n          serviceDomain = \"valve\";\n          service = turnOn ? \"open_valve\" : \"close_valve\";\n        } else if (stateDomain === \"group\") {\n          serviceDomain = \"homeassistant\";\n          service = turnOn ? \"turn_on\" : \"turn_off\";\n        } else {\n          serviceDomain = stateDomain;\n          service = turnOn ? \"turn_on\" : \"turn_off\";\n        }\n        const currentState = this.stateObj;\n\n        // Optimistic update.\n        this._isOn = turnOn;\n        await this.hass.callService(serviceDomain, service, {\n          entity_id: this.stateObj.entity_id\n        });\n        setTimeout(async () => {\n          // If after 2 seconds we have not received a state update\n          // reset the switch to it's original state.\n          if (this.stateObj === currentState) {\n            this._isOn = isOn(this.stateObj);\n          }\n        }, 2000);\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host {\n        white-space: nowrap;\n        min-width: 38px;\n      }\n      ha-icon-button {\n        --mdc-icon-button-size: 40px;\n        color: var(--ha-icon-button-inactive-color, var(--primary-text-color));\n        transition: color 0.5s;\n      }\n      ha-icon-button.state-active {\n        color: var(--ha-icon-button-active-color, var(--primary-color));\n      }\n      ha-switch {\n        padding: 13px 5px;\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["LitElement","css","html","customElement","property","state","STATES_OFF","computeStateDomain","computeStateName","UNAVAILABLE","UNKNOWN","isUnavailableState","forwardHaptic","isOn","stateObj","undefined","includes","HaEntityToggle","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","key","value","decorators","attribute","render","attributes","assumed_state","mdiFlashOff","_turnOff","_isOn","mdiFlash","_turnOn","switchTemplate","_toggleChanged","label","firstUpdated","changedProps","_get","_getPrototypeOf","prototype","call","addEventListener","ev","stopPropagation","willUpdate","has","newVal","target","checked","_callService","turnOn","hass","stateDomain","serviceDomain","service","currentState","callService","entity_id","setTimeout","static","styles"],"sources":["/workspaces/frontend/src/components/entity/ha-entity-toggle.ts"],"sourcesContent":["import { mdiFlash, mdiFlashOff } from \"@mdi/js\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport {\n  CSSResultGroup,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n  css,\n  html,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { STATES_OFF } from \"../../common/const\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { UNAVAILABLE, UNKNOWN, isUnavailableState } from \"../../data/entity\";\nimport { forwardHaptic } from \"../../data/haptics\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-formfield\";\nimport \"../ha-icon-button\";\nimport \"../ha-switch\";\n\nconst isOn = (stateObj?: HassEntity) =>\n  stateObj !== undefined &&\n  !STATES_OFF.includes(stateObj.state) &&\n  !isUnavailableState(stateObj.state);\n\n@customElement(\"ha-entity-toggle\")\nexport class HaEntityToggle extends LitElement {\n  // hass is not a property so that we only re-render on stateObj changes\n  public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: HassEntity;\n\n  @property() public label?: string;\n\n  @state() private _isOn = false;\n\n  protected render(): TemplateResult {\n    if (!this.stateObj) {\n      return html` <ha-switch disabled></ha-switch> `;\n    }\n\n    if (\n      this.stateObj.attributes.assumed_state ||\n      this.stateObj.state === UNKNOWN\n    ) {\n      return html`\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} off`}\n          .path=${mdiFlashOff}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOff}\n          class=${!this._isOn && this.stateObj.state !== UNKNOWN\n            ? \"state-active\"\n            : \"\"}\n        ></ha-icon-button>\n        <ha-icon-button\n          .label=${`Turn ${computeStateName(this.stateObj)} on`}\n          .path=${mdiFlash}\n          .disabled=${this.stateObj.state === UNAVAILABLE}\n          @click=${this._turnOn}\n          class=${this._isOn ? \"state-active\" : \"\"}\n        ></ha-icon-button>\n      `;\n    }\n\n    const switchTemplate = html`<ha-switch\n      aria-label=${`Toggle ${computeStateName(this.stateObj)} ${\n        this._isOn ? \"off\" : \"on\"\n      }`}\n      .checked=${this._isOn}\n      .disabled=${this.stateObj.state === UNAVAILABLE}\n      @change=${this._toggleChanged}\n    ></ha-switch>`;\n\n    if (!this.label) {\n      return switchTemplate;\n    }\n\n    return html`\n      <ha-formfield .label=${this.label}>${switchTemplate}</ha-formfield>\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    this.addEventListener(\"click\", (ev) => ev.stopPropagation());\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"stateObj\")) {\n      this._isOn = isOn(this.stateObj);\n    }\n  }\n\n  private _toggleChanged(ev) {\n    const newVal = ev.target.checked;\n\n    if (newVal !== this._isOn) {\n      this._callService(newVal);\n    }\n  }\n\n  private _turnOn() {\n    this._callService(true);\n  }\n\n  private _turnOff() {\n    this._callService(false);\n  }\n\n  // We will force a re-render after a successful call to re-sync the toggle\n  // with the state. It will be out of sync if our service call did not\n  // result in the entity to be turned on. Since the state is not changing,\n  // the resync is not called automatic.\n  private async _callService(turnOn): Promise<void> {\n    if (!this.hass || !this.stateObj) {\n      return;\n    }\n    forwardHaptic(\"light\");\n    const stateDomain = computeStateDomain(this.stateObj);\n    let serviceDomain;\n    let service;\n\n    if (stateDomain === \"lock\") {\n      serviceDomain = \"lock\";\n      service = turnOn ? \"unlock\" : \"lock\";\n    } else if (stateDomain === \"cover\") {\n      serviceDomain = \"cover\";\n      service = turnOn ? \"open_cover\" : \"close_cover\";\n    } else if (stateDomain === \"valve\") {\n      serviceDomain = \"valve\";\n      service = turnOn ? \"open_valve\" : \"close_valve\";\n    } else if (stateDomain === \"group\") {\n      serviceDomain = \"homeassistant\";\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    } else {\n      serviceDomain = stateDomain;\n      service = turnOn ? \"turn_on\" : \"turn_off\";\n    }\n\n    const currentState = this.stateObj;\n\n    // Optimistic update.\n    this._isOn = turnOn;\n\n    await this.hass.callService(serviceDomain, service, {\n      entity_id: this.stateObj.entity_id,\n    });\n\n    setTimeout(async () => {\n      // If after 2 seconds we have not received a state update\n      // reset the switch to it's original state.\n      if (this.stateObj === currentState) {\n        this._isOn = isOn(this.stateObj);\n      }\n    }, 2000);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        white-space: nowrap;\n        min-width: 38px;\n      }\n      ha-icon-button {\n        --mdc-icon-button-size: 40px;\n        color: var(--ha-icon-button-inactive-color, var(--primary-text-color));\n        transition: color 0.5s;\n      }\n      ha-icon-button.state-active {\n        color: var(--ha-icon-button-active-color, var(--primary-color));\n      }\n      ha-switch {\n        padding: 13px 5px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-toggle\": HaEntityToggle;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}