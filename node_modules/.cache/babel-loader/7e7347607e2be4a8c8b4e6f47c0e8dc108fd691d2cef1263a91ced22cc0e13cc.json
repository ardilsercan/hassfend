{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.last-index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.trim.js\";\nvar StyleNode = /*#__PURE__*/_createClass(function StyleNode() {\n  _classCallCheck(this, StyleNode);\n  /** @type {number} */\n  this['start'] = 0;\n  /** @type {number} */\n  this['end'] = 0;\n  /** @type {StyleNode} */\n  this['previous'] = null;\n  /** @type {StyleNode} */\n  this['parent'] = null;\n  /** @type {Array<StyleNode>} */\n  this['rules'] = null;\n  /** @type {string} */\n  this['parsedCssText'] = '';\n  /** @type {string} */\n  this['cssText'] = '';\n  /** @type {boolean} */\n  this['atRule'] = false;\n  /** @type {number} */\n  this['type'] = 0;\n  /** @type {string} */\n  this['keyframesName'] = '';\n  /** @type {string} */\n  this['selector'] = '';\n  /** @type {string} */\n  this['parsedSelector'] = '';\n});\nexport { StyleNode };\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction lex(text) {\n  var root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  var n = root;\n  for (var i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      var p = n;\n      var previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction parseCss(node, text) {\n  var t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    var ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    var s = node['parsedSelector'] = node['selector'] = t.trim();\n    node['atRule'] = s.indexOf(AT_START) === 0;\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  var r$ = node['rules'];\n  if (r$) {\n    for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    var code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties) {\n  var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  // calc rule cssText\n  var cssText = '';\n  if (node['cssText'] || node['rules']) {\n    var r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  var r = rules[0];\n  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport var types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000\n};\nvar OPEN_BRACE = '{';\nvar CLOSE_BRACE = '}';\n\n// helper regexp's\nvar RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g\n};\nvar VAR_START = '--';\nvar MEDIA_START = '@media';\nvar AT_START = '@';","map":{"version":3,"names":["_createClass","_classCallCheck","StyleNode","parse","text","clean","parseCss","lex","cssText","replace","RX","comments","port","root","length","n","i","l","OPEN_BRACE","p","previous","push","CLOSE_BRACE","node","t","substring","trim","ss","_expandUnicodeEscapes","multipleSpaces","lastIndexOf","s","indexOf","AT_START","MEDIA_START","types","MEDIA_RULE","match","keyframesRule","KEYFRAMES_RULE","split","pop","VAR_START","MIXIN_RULE","STYLE_RULE","r$","r","code","arguments","repeat","stringify","preserveProperties","undefined","_hasMixinRules","removeCustomProps","rules","Boolean","removeCustomPropAssignment","removeCustomPropApply","customProp","mixinProp","mixinApply","varApply"],"sources":["/workspaces/frontend/node_modules/@webcomponents/shadycss/src/css-parse.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\nexport {StyleNode};\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous']\n      ? node['previous']['end']\n      : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = (node['parsedSelector'] = node['selector'] = t.trim());\n    node['atRule'] = s.indexOf(AT_START) === 0;\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties\n        ? node['cssText']\n        : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return (\n    Boolean(r) &&\n    Boolean(r['selector']) &&\n    r['selector'].indexOf(VAR_START) === 0\n  );\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000,\n};\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g,\n};\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}