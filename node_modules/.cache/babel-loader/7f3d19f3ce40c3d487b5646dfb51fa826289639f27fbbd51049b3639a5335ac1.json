{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxDataProviderMixin = superClass => class DataProviderMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Number of items fetched at a time from the dataprovider.\n       * @attr {number} page-size\n       * @type {number}\n       */\n      pageSize: {\n        type: Number,\n        value: 50,\n        observer: '_pageSizeChanged'\n      },\n      /**\n       * Total number of items.\n       * @type {number | undefined}\n       */\n      size: {\n        type: Number,\n        observer: '_sizeChanged'\n      },\n      /**\n       * Function that provides items lazily. Receives arguments `params`, `callback`\n       *\n       * `params.page` Requested page index\n       *\n       * `params.pageSize` Current page size\n       *\n       * `params.filter` Currently applied filter\n       *\n       * `callback(items, size)` Callback function with arguments:\n       *   - `items` Current page of items\n       *   - `size` Total number of items.\n       * @type {ComboBoxDataProvider | undefined}\n       */\n      dataProvider: {\n        type: Object,\n        observer: '_dataProviderChanged'\n      },\n      /** @private */\n      _pendingRequests: {\n        value: () => {\n          return {};\n        }\n      },\n      /** @private */\n      __placeHolder: {\n        value: new ComboBoxPlaceholder()\n      },\n      /** @private */\n      __previousDataProviderFilter: {\n        type: String\n      }\n    };\n  }\n  static get observers() {\n    return ['_dataProviderFilterChanged(filter)', '_warnDataProviderValue(dataProvider, value)', '_ensureFirstPage(opened)'];\n  }\n\n  /** @protected */\n  ready() {\n    super.ready();\n    this._scroller.addEventListener('index-requested', e => {\n      const index = e.detail.index;\n      const currentScrollerPos = e.detail.currentScrollerPos;\n      const allowedIndexRange = Math.floor(this.pageSize * 1.5);\n\n      // Ignores the indexes, which are being re-sent during scrolling reset,\n      // if the corresponding page is around the current scroller position.\n      // Otherwise, there might be a last pages duplicates, which cause the\n      // loading indicator hanging and blank items\n      if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {\n        return;\n      }\n      if (index !== undefined) {\n        const page = this._getPageForIndex(index);\n        if (this._shouldLoadPage(page)) {\n          this._loadPage(page);\n        }\n      }\n    });\n  }\n\n  /** @private */\n  _dataProviderFilterChanged(filter) {\n    if (this.__previousDataProviderFilter === undefined && filter === '') {\n      this.__previousDataProviderFilter = filter;\n      return;\n    }\n    if (this.__previousDataProviderFilter !== filter) {\n      this.__previousDataProviderFilter = filter;\n      this._pendingRequests = {};\n      // Immediately mark as loading if this refresh leads to re-fetching pages\n      // This prevents some issues with the properties below triggering\n      // observers that also rely on the loading state\n      this.loading = this._shouldFetchData();\n      // Reset size and internal loading state\n      this.size = undefined;\n      this.clearCache();\n    }\n  }\n\n  /** @private */\n  _shouldFetchData() {\n    if (!this.dataProvider) {\n      return false;\n    }\n    return this.opened || this.filter && this.filter.length;\n  }\n\n  /** @private */\n  _ensureFirstPage(opened) {\n    if (opened && this._shouldLoadPage(0)) {\n      this._loadPage(0);\n    }\n  }\n\n  /** @private */\n  _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {\n    return currentScrollerPos !== 0 && index >= currentScrollerPos - allowedIndexRange && index <= currentScrollerPos + allowedIndexRange;\n  }\n\n  /** @private */\n  _shouldLoadPage(page) {\n    if (!this.filteredItems || this._forceNextRequest) {\n      this._forceNextRequest = false;\n      return true;\n    }\n    const loadedItem = this.filteredItems[page * this.pageSize];\n    if (loadedItem !== undefined) {\n      return loadedItem instanceof ComboBoxPlaceholder;\n    }\n    return this.size === undefined;\n  }\n\n  /** @private */\n  _loadPage(page) {\n    // Make sure same page isn't requested multiple times.\n    if (this._pendingRequests[page] || !this.dataProvider) {\n      return;\n    }\n    const params = {\n      page,\n      pageSize: this.pageSize,\n      filter: this.filter\n    };\n    const callback = (items, size) => {\n      if (this._pendingRequests[page] !== callback) {\n        return;\n      }\n      const filteredItems = this.filteredItems ? [...this.filteredItems] : [];\n      filteredItems.splice(params.page * params.pageSize, items.length, ...items);\n      this.filteredItems = filteredItems;\n      if (!this.opened && !this._isInputFocused()) {\n        this._commitValue();\n      }\n      if (size !== undefined) {\n        this.size = size;\n      }\n      delete this._pendingRequests[page];\n      if (Object.keys(this._pendingRequests).length === 0) {\n        this.loading = false;\n      }\n    };\n    this._pendingRequests[page] = callback;\n    // Set the `loading` flag only after marking the request as pending\n    // to prevent the same page from getting requested multiple times\n    // as a result of `__loadingChanged` in the scroller which requests\n    // a virtualizer update which in turn may trigger a data provider page request.\n    this.loading = true;\n    this.dataProvider(params, callback);\n  }\n\n  /** @private */\n  _getPageForIndex(index) {\n    return Math.floor(index / this.pageSize);\n  }\n\n  /**\n   * Clears the cached pages and reloads data from dataprovider when needed.\n   */\n  clearCache() {\n    if (!this.dataProvider) {\n      return;\n    }\n    this._pendingRequests = {};\n    const filteredItems = [];\n    for (let i = 0; i < (this.size || 0); i++) {\n      filteredItems.push(this.__placeHolder);\n    }\n    this.filteredItems = filteredItems;\n    if (this._shouldFetchData()) {\n      this._forceNextRequest = false;\n      this._loadPage(0);\n    } else {\n      this._forceNextRequest = true;\n    }\n  }\n\n  /** @private */\n  _sizeChanged(size = 0) {\n    const filteredItems = (this.filteredItems || []).slice(0, size);\n    for (let i = 0; i < size; i++) {\n      filteredItems[i] = filteredItems[i] !== undefined ? filteredItems[i] : this.__placeHolder;\n    }\n    this.filteredItems = filteredItems;\n\n    // Cleans up the redundant pending requests for pages > size\n    // Refers to https://github.com/vaadin/vaadin-flow-components/issues/229\n    this._flushPendingRequests(size);\n  }\n\n  /** @private */\n  _pageSizeChanged(pageSize, oldPageSize) {\n    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {\n      this.pageSize = oldPageSize;\n      throw new Error('`pageSize` value must be an integer > 0');\n    }\n    this.clearCache();\n  }\n\n  /** @private */\n  _dataProviderChanged(dataProvider, oldDataProvider) {\n    this._ensureItemsOrDataProvider(() => {\n      this.dataProvider = oldDataProvider;\n    });\n    this.clearCache();\n  }\n\n  /** @private */\n  _ensureItemsOrDataProvider(restoreOldValueCallback) {\n    if (this.items !== undefined && this.dataProvider !== undefined) {\n      restoreOldValueCallback();\n      throw new Error('Using `items` and `dataProvider` together is not supported');\n    } else if (this.dataProvider && !this.filteredItems) {\n      this.filteredItems = [];\n    }\n  }\n\n  /** @private */\n  _warnDataProviderValue(dataProvider, value) {\n    if (dataProvider && value !== '' && (this.selectedItem === undefined || this.selectedItem === null)) {\n      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);\n      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {\n        console.warn('Warning: unable to determine the label for the provided `value`. ' + 'Nothing to display in the text field. This usually happens when ' + 'setting an initial `value` before any items are returned from ' + 'the `dataProvider` callback. Consider setting `selectedItem` ' + 'instead of `value`');\n      }\n    }\n  }\n\n  /**\n   * This method cleans up the page callbacks which refers to the\n   * non-existing pages, i.e. which item indexes are greater than the\n   * changed size.\n   * This case is basically happens when:\n   * 1. Users scroll fast to the bottom and combo box generates the\n   * redundant page request/callback\n   * 2. Server side uses undefined size lazy loading and suddenly reaches\n   * the exact size which is on the range edge\n   * (for default page size = 50, it will be 100, 200, 300, ...).\n   * @param size the new size of items\n   * @private\n   */\n  _flushPendingRequests(size) {\n    if (this._pendingRequests) {\n      const lastPage = Math.ceil(size / this.pageSize);\n      Object.entries(this._pendingRequests).forEach(([page, callback]) => {\n        if (parseInt(page) >= lastPage) {\n          callback([], size);\n        }\n      });\n    }\n  }\n};","map":{"version":3,"names":["ComboBoxPlaceholder","ComboBoxDataProviderMixin","superClass","DataProviderMixin","properties","pageSize","type","Number","value","observer","size","dataProvider","Object","_pendingRequests","__placeHolder","__previousDataProviderFilter","String","observers","ready","_scroller","addEventListener","e","index","detail","currentScrollerPos","allowedIndexRange","Math","floor","_shouldSkipIndex","undefined","page","_getPageForIndex","_shouldLoadPage","_loadPage","_dataProviderFilterChanged","filter","loading","_shouldFetchData","clearCache","opened","length","_ensureFirstPage","filteredItems","_forceNextRequest","loadedItem","params","callback","items","splice","_isInputFocused","_commitValue","keys","i","push","_sizeChanged","slice","_flushPendingRequests","_pageSizeChanged","oldPageSize","Error","_dataProviderChanged","oldDataProvider","_ensureItemsOrDataProvider","restoreOldValueCallback","_warnDataProviderValue","selectedItem","valueIndex","__getItemIndexByValue","_getItemLabel","console","warn","lastPage","ceil","entries","forEach","parseInt"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@vaadin/combo-box/src/vaadin-combo-box-data-provider-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { ComboBoxPlaceholder } from './vaadin-combo-box-placeholder.js';\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxDataProviderMixin = (superClass) =>\n  class DataProviderMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * Number of items fetched at a time from the dataprovider.\n         * @attr {number} page-size\n         * @type {number}\n         */\n        pageSize: {\n          type: Number,\n          value: 50,\n          observer: '_pageSizeChanged',\n        },\n\n        /**\n         * Total number of items.\n         * @type {number | undefined}\n         */\n        size: {\n          type: Number,\n          observer: '_sizeChanged',\n        },\n\n        /**\n         * Function that provides items lazily. Receives arguments `params`, `callback`\n         *\n         * `params.page` Requested page index\n         *\n         * `params.pageSize` Current page size\n         *\n         * `params.filter` Currently applied filter\n         *\n         * `callback(items, size)` Callback function with arguments:\n         *   - `items` Current page of items\n         *   - `size` Total number of items.\n         * @type {ComboBoxDataProvider | undefined}\n         */\n        dataProvider: {\n          type: Object,\n          observer: '_dataProviderChanged',\n        },\n\n        /** @private */\n        _pendingRequests: {\n          value: () => {\n            return {};\n          },\n        },\n\n        /** @private */\n        __placeHolder: {\n          value: new ComboBoxPlaceholder(),\n        },\n\n        /** @private */\n        __previousDataProviderFilter: {\n          type: String,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '_dataProviderFilterChanged(filter)',\n        '_warnDataProviderValue(dataProvider, value)',\n        '_ensureFirstPage(opened)',\n      ];\n    }\n\n    /** @protected */\n    ready() {\n      super.ready();\n      this._scroller.addEventListener('index-requested', (e) => {\n        const index = e.detail.index;\n        const currentScrollerPos = e.detail.currentScrollerPos;\n        const allowedIndexRange = Math.floor(this.pageSize * 1.5);\n\n        // Ignores the indexes, which are being re-sent during scrolling reset,\n        // if the corresponding page is around the current scroller position.\n        // Otherwise, there might be a last pages duplicates, which cause the\n        // loading indicator hanging and blank items\n        if (this._shouldSkipIndex(index, allowedIndexRange, currentScrollerPos)) {\n          return;\n        }\n\n        if (index !== undefined) {\n          const page = this._getPageForIndex(index);\n          if (this._shouldLoadPage(page)) {\n            this._loadPage(page);\n          }\n        }\n      });\n    }\n\n    /** @private */\n    _dataProviderFilterChanged(filter) {\n      if (this.__previousDataProviderFilter === undefined && filter === '') {\n        this.__previousDataProviderFilter = filter;\n        return;\n      }\n\n      if (this.__previousDataProviderFilter !== filter) {\n        this.__previousDataProviderFilter = filter;\n\n        this._pendingRequests = {};\n        // Immediately mark as loading if this refresh leads to re-fetching pages\n        // This prevents some issues with the properties below triggering\n        // observers that also rely on the loading state\n        this.loading = this._shouldFetchData();\n        // Reset size and internal loading state\n        this.size = undefined;\n\n        this.clearCache();\n      }\n    }\n\n    /** @private */\n    _shouldFetchData() {\n      if (!this.dataProvider) {\n        return false;\n      }\n\n      return this.opened || (this.filter && this.filter.length);\n    }\n\n    /** @private */\n    _ensureFirstPage(opened) {\n      if (opened && this._shouldLoadPage(0)) {\n        this._loadPage(0);\n      }\n    }\n\n    /** @private */\n    _shouldSkipIndex(index, allowedIndexRange, currentScrollerPos) {\n      return (\n        currentScrollerPos !== 0 &&\n        index >= currentScrollerPos - allowedIndexRange &&\n        index <= currentScrollerPos + allowedIndexRange\n      );\n    }\n\n    /** @private */\n    _shouldLoadPage(page) {\n      if (!this.filteredItems || this._forceNextRequest) {\n        this._forceNextRequest = false;\n        return true;\n      }\n\n      const loadedItem = this.filteredItems[page * this.pageSize];\n      if (loadedItem !== undefined) {\n        return loadedItem instanceof ComboBoxPlaceholder;\n      }\n      return this.size === undefined;\n    }\n\n    /** @private */\n    _loadPage(page) {\n      // Make sure same page isn't requested multiple times.\n      if (this._pendingRequests[page] || !this.dataProvider) {\n        return;\n      }\n\n      const params = {\n        page,\n        pageSize: this.pageSize,\n        filter: this.filter,\n      };\n\n      const callback = (items, size) => {\n        if (this._pendingRequests[page] !== callback) {\n          return;\n        }\n\n        const filteredItems = this.filteredItems ? [...this.filteredItems] : [];\n        filteredItems.splice(params.page * params.pageSize, items.length, ...items);\n        this.filteredItems = filteredItems;\n\n        if (!this.opened && !this._isInputFocused()) {\n          this._commitValue();\n        }\n\n        if (size !== undefined) {\n          this.size = size;\n        }\n\n        delete this._pendingRequests[page];\n\n        if (Object.keys(this._pendingRequests).length === 0) {\n          this.loading = false;\n        }\n      };\n\n      this._pendingRequests[page] = callback;\n      // Set the `loading` flag only after marking the request as pending\n      // to prevent the same page from getting requested multiple times\n      // as a result of `__loadingChanged` in the scroller which requests\n      // a virtualizer update which in turn may trigger a data provider page request.\n      this.loading = true;\n      this.dataProvider(params, callback);\n    }\n\n    /** @private */\n    _getPageForIndex(index) {\n      return Math.floor(index / this.pageSize);\n    }\n\n    /**\n     * Clears the cached pages and reloads data from dataprovider when needed.\n     */\n    clearCache() {\n      if (!this.dataProvider) {\n        return;\n      }\n\n      this._pendingRequests = {};\n      const filteredItems = [];\n      for (let i = 0; i < (this.size || 0); i++) {\n        filteredItems.push(this.__placeHolder);\n      }\n      this.filteredItems = filteredItems;\n\n      if (this._shouldFetchData()) {\n        this._forceNextRequest = false;\n        this._loadPage(0);\n      } else {\n        this._forceNextRequest = true;\n      }\n    }\n\n    /** @private */\n    _sizeChanged(size = 0) {\n      const filteredItems = (this.filteredItems || []).slice(0, size);\n      for (let i = 0; i < size; i++) {\n        filteredItems[i] = filteredItems[i] !== undefined ? filteredItems[i] : this.__placeHolder;\n      }\n      this.filteredItems = filteredItems;\n\n      // Cleans up the redundant pending requests for pages > size\n      // Refers to https://github.com/vaadin/vaadin-flow-components/issues/229\n      this._flushPendingRequests(size);\n    }\n\n    /** @private */\n    _pageSizeChanged(pageSize, oldPageSize) {\n      if (Math.floor(pageSize) !== pageSize || pageSize < 1) {\n        this.pageSize = oldPageSize;\n        throw new Error('`pageSize` value must be an integer > 0');\n      }\n      this.clearCache();\n    }\n\n    /** @private */\n    _dataProviderChanged(dataProvider, oldDataProvider) {\n      this._ensureItemsOrDataProvider(() => {\n        this.dataProvider = oldDataProvider;\n      });\n\n      this.clearCache();\n    }\n\n    /** @private */\n    _ensureItemsOrDataProvider(restoreOldValueCallback) {\n      if (this.items !== undefined && this.dataProvider !== undefined) {\n        restoreOldValueCallback();\n        throw new Error('Using `items` and `dataProvider` together is not supported');\n      } else if (this.dataProvider && !this.filteredItems) {\n        this.filteredItems = [];\n      }\n    }\n\n    /** @private */\n    _warnDataProviderValue(dataProvider, value) {\n      if (dataProvider && value !== '' && (this.selectedItem === undefined || this.selectedItem === null)) {\n        const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);\n        if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {\n          console.warn(\n            'Warning: unable to determine the label for the provided `value`. ' +\n              'Nothing to display in the text field. This usually happens when ' +\n              'setting an initial `value` before any items are returned from ' +\n              'the `dataProvider` callback. Consider setting `selectedItem` ' +\n              'instead of `value`',\n          );\n        }\n      }\n    }\n\n    /**\n     * This method cleans up the page callbacks which refers to the\n     * non-existing pages, i.e. which item indexes are greater than the\n     * changed size.\n     * This case is basically happens when:\n     * 1. Users scroll fast to the bottom and combo box generates the\n     * redundant page request/callback\n     * 2. Server side uses undefined size lazy loading and suddenly reaches\n     * the exact size which is on the range edge\n     * (for default page size = 50, it will be 100, 200, 300, ...).\n     * @param size the new size of items\n     * @private\n     */\n    _flushPendingRequests(size) {\n      if (this._pendingRequests) {\n        const lastPage = Math.ceil(size / this.pageSize);\n        Object.entries(this._pendingRequests).forEach(([page, callback]) => {\n          if (parseInt(page) >= lastPage) {\n            callback([], size);\n          }\n        });\n      }\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}