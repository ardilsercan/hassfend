{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, LitElement } from 'lit';\nimport { property, queryAll } from 'lit/decorators.js';\n/**\n * An item layout component.\n */\nexport class Item extends LitElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * Only needed for SSR.\n     *\n     * Add this attribute when an item has two lines to avoid a Flash Of Unstyled\n     * Content. This attribute is not needed for single line items or items with\n     * three or more lines.\n     */\n    this.multiline = false;\n  }\n  render() {\n    return html`\n      <slot name=\"container\"></slot>\n      <slot class=\"non-text\" name=\"start\"></slot>\n      <div class=\"text\">\n        <slot name=\"overline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          class=\"default-slot\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n        <slot name=\"headline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          name=\"supporting-text\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n      </div>\n      <slot class=\"non-text\" name=\"trailing-supporting-text\"></slot>\n      <slot class=\"non-text\" name=\"end\"></slot>\n    `;\n  }\n  handleTextSlotChange() {\n    // Check if there's more than one text slot with content. If so, the item is\n    // multiline, which has a different min-height than single line items.\n    let isMultiline = false;\n    let slotsWithContent = 0;\n    for (const slot of this.textSlots) {\n      if (slotHasContent(slot)) {\n        slotsWithContent += 1;\n      }\n      if (slotsWithContent > 1) {\n        isMultiline = true;\n        break;\n      }\n    }\n    this.multiline = isMultiline;\n  }\n}\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], Item.prototype, \"multiline\", void 0);\n__decorate([queryAll('.text slot')], Item.prototype, \"textSlots\", void 0);\nfunction slotHasContent(slot) {\n  for (const node of slot.assignedNodes({\n    flatten: true\n  })) {\n    var _node$textContent;\n    // Assume there's content if there's an element slotted in\n    const isElement = node.nodeType === Node.ELEMENT_NODE;\n    // If there's only text nodes for the default slot, check if there's\n    // non-whitespace.\n    const isTextWithContent = node.nodeType === Node.TEXT_NODE && ((_node$textContent = node.textContent) === null || _node$textContent === void 0 ? void 0 : _node$textContent.match(/\\S/));\n    if (isElement || isTextWithContent) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["html","LitElement","property","queryAll","Item","constructor","multiline","render","handleTextSlotChange","isMultiline","slotsWithContent","slot","textSlots","slotHasContent","__decorate","type","Boolean","reflect","node","assignedNodes","flatten","_node$textContent","isElement","nodeType","Node","ELEMENT_NODE","isTextWithContent","TEXT_NODE","textContent","match"],"sources":["item.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, LitElement} from 'lit';\nimport {property, queryAll} from 'lit/decorators.js';\n\n/**\n * An item layout component.\n */\nexport class Item extends LitElement {\n  /**\n   * Only needed for SSR.\n   *\n   * Add this attribute when an item has two lines to avoid a Flash Of Unstyled\n   * Content. This attribute is not needed for single line items or items with\n   * three or more lines.\n   */\n  @property({type: Boolean, reflect: true}) multiline = false;\n\n  @queryAll('.text slot') private readonly textSlots!: HTMLSlotElement[];\n\n  override render() {\n    return html`\n      <slot name=\"container\"></slot>\n      <slot class=\"non-text\" name=\"start\"></slot>\n      <div class=\"text\">\n        <slot name=\"overline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          class=\"default-slot\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n        <slot name=\"headline\" @slotchange=${this.handleTextSlotChange}></slot>\n        <slot\n          name=\"supporting-text\"\n          @slotchange=${this.handleTextSlotChange}></slot>\n      </div>\n      <slot class=\"non-text\" name=\"trailing-supporting-text\"></slot>\n      <slot class=\"non-text\" name=\"end\"></slot>\n    `;\n  }\n\n  private handleTextSlotChange() {\n    // Check if there's more than one text slot with content. If so, the item is\n    // multiline, which has a different min-height than single line items.\n    let isMultiline = false;\n    let slotsWithContent = 0;\n    for (const slot of this.textSlots) {\n      if (slotHasContent(slot)) {\n        slotsWithContent += 1;\n      }\n\n      if (slotsWithContent > 1) {\n        isMultiline = true;\n        break;\n      }\n    }\n\n    this.multiline = isMultiline;\n  }\n}\n\nfunction slotHasContent(slot: HTMLSlotElement) {\n  for (const node of slot.assignedNodes({flatten: true})) {\n    // Assume there's content if there's an element slotted in\n    const isElement = node.nodeType === Node.ELEMENT_NODE;\n    // If there's only text nodes for the default slot, check if there's\n    // non-whitespace.\n    const isTextWithContent =\n      node.nodeType === Node.TEXT_NODE && node.textContent?.match(/\\S/);\n    if (isElement || isTextWithContent) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"mappings":"AAAA;;;;;;AAMA,SAAQA,IAAI,EAAEC,UAAU,QAAO,KAAK;AACpC,SAAQC,QAAQ,EAAEC,QAAQ,QAAO,mBAAmB;AAEpD;;;AAGA,OAAM,MAAOC,IAAK,SAAQH,UAAU;EAApCI,YAAA;;IACE;;;;;;;IAO0C,KAAAC,SAAS,GAAG,KAAK;EAyC7D;EArCWC,MAAMA,CAAA;IACb,OAAOP,IAAI;;;;4CAI6B,IAAI,CAACQ,oBAAoB;;;wBAG7C,IAAI,CAACA,oBAAoB;4CACL,IAAI,CAACA,oBAAoB;;;wBAG7C,IAAI,CAACA,oBAAoB;;;;KAI5C;EACH;EAEQA,oBAAoBA,CAAA;IAC1B;IACA;IACA,IAAIC,WAAW,GAAG,KAAK;IACvB,IAAIC,gBAAgB,GAAG,CAAC;IACxB,KAAK,MAAMC,IAAI,IAAI,IAAI,CAACC,SAAS,EAAE;MACjC,IAAIC,cAAc,CAACF,IAAI,CAAC,EAAE;QACxBD,gBAAgB,IAAI,CAAC;;MAGvB,IAAIA,gBAAgB,GAAG,CAAC,EAAE;QACxBD,WAAW,GAAG,IAAI;QAClB;;;IAIJ,IAAI,CAACH,SAAS,GAAGG,WAAW;EAC9B;;AAxC0CK,UAAA,EAAzCZ,QAAQ,CAAC;EAACa,IAAI,EAAEC,OAAO;EAAEC,OAAO,EAAE;AAAI,CAAC,CAAC,C,sCAAmB;AAEnBH,UAAA,EAAxCX,QAAQ,CAAC,YAAY,CAAC,C,sCAAgD;AAyCzE,SAASU,cAAcA,CAACF,IAAqB;EAC3C,KAAK,MAAMO,IAAI,IAAIP,IAAI,CAACQ,aAAa,CAAC;IAACC,OAAO,EAAE;EAAI,CAAC,CAAC,EAAE;IAAA,IAAAC,iBAAA;IACtD;IACA,MAAMC,SAAS,GAAGJ,IAAI,CAACK,QAAQ,KAAKC,IAAI,CAACC,YAAY;IACrD;IACA;IACA,MAAMC,iBAAiB,GACrBR,IAAI,CAACK,QAAQ,KAAKC,IAAI,CAACG,SAAS,MAAAN,iBAAA,GAAIH,IAAI,CAACU,WAAW,cAAAP,iBAAA,uBAAhBA,iBAAA,CAAkBQ,KAAK,CAAC,IAAI,CAAC;IACnE,IAAIP,SAAS,IAAII,iBAAiB,EAAE;MAClC,OAAO,IAAI;;;EAIf,OAAO,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}