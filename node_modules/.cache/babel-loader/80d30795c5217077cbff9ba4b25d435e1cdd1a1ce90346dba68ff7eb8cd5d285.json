{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { throttle } from \"../../common/util/throttle\";\nimport \"../../components/ha-circular-progress\";\nimport { subscribeLogbook } from \"../../data/logbook\";\nimport { loadTraceContexts } from \"../../data/trace\";\nimport { fetchUsers } from \"../../data/user\";\nimport \"./ha-logbook-renderer\";\nconst findStartOfRecentTime = (now, recentTime) => new Date(now.getTime() - recentTime * 1000).getTime() / 1000;\nconst idsChanged = (oldIds, newIds) => {\n  if (oldIds === undefined && newIds === undefined) {\n    return false;\n  }\n  return !oldIds || !newIds || oldIds.length !== newIds.length || oldIds.some(val => !newIds.includes(val)) || newIds.some(val => !oldIds.includes(val));\n};\nexport let HaLogbook = _decorate([customElement(\"ha-logbook\")], function (_initialize, _LitElement) {\n  class HaLogbook extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaLogbook,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"time\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"entityIds\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"deviceIds\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"narrow\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        reflect: true\n      })],\n      key: \"virtualize\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"no-icon\"\n      })],\n      key: \"noIcon\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"no-name\"\n      })],\n      key: \"noName\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"show-indicator\"\n      })],\n      key: \"showIndicator\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"relative-time\"\n      })],\n      key: \"relativeTime\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"showMoreLink\",\n      value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_logbookEntries\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_traceContexts\",\n      value() {\n        return {};\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_userIdToName\",\n      value() {\n        return {};\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_error\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_subscribed\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_liveUpdatesEnabled\",\n      value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_pendingStreamMessages\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_throttleGetLogbookEntries\",\n      value() {\n        return throttle(() => this._getLogBookData(), 1000);\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!isComponentLoaded(this.hass, \"logbook\")) {\n          return nothing;\n        }\n        if (this._error) {\n          return html`<div class=\"no-entries\">\n        ${`${this.hass.localize(\"ui.components.logbook.retrieval_error\")}: ${this._error}`}\n      </div>`;\n        }\n        if (this._logbookEntries === undefined) {\n          return html`\n        <div class=\"progress-wrapper\">\n          <ha-circular-progress indeterminate></ha-circular-progress>\n        </div>\n      `;\n        }\n        if (this._logbookEntries.length === 0) {\n          return html`<div class=\"no-entries\">\n        ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n      </div>`;\n        }\n        return html`\n      <ha-logbook-renderer\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .virtualize=${this.virtualize}\n        .noIcon=${this.noIcon}\n        .noName=${this.noName}\n        .showIndicator=${this.showIndicator}\n        .relativeTime=${this.relativeTime}\n        .entries=${this._logbookEntries}\n        .traceContexts=${this._traceContexts}\n        .userIdToName=${this._userIdToName}\n        @hass-logbook-live=${this._handleLogbookLive}\n      ></ha-logbook-renderer>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"refresh\",\n      value: async function refresh(force = false) {\n        if (!force && (this._subscribed || this._logbookEntries === undefined)) {\n          return;\n        }\n        this._throttleGetLogbookEntries.cancel();\n        this._updateTraceContexts.cancel();\n        this._updateUsers.cancel();\n        await this._unsubscribeSetLoading();\n        if (force) {\n          this._getLogBookData();\n        } else {\n          this._throttleGetLogbookEntries();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        if (changedProps.size !== 1 || !changedProps.has(\"hass\")) {\n          return true;\n        }\n        // We only respond to hass changes if the translations changed\n        const oldHass = changedProps.get(\"hass\");\n        return !oldHass || oldHass.localize !== this.hass.localize;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        let changed = changedProps.has(\"time\");\n        for (const key of [\"entityIds\", \"deviceIds\"]) {\n          if (!changedProps.has(key)) {\n            continue;\n          }\n          const oldValue = changedProps.get(key);\n          const curValue = this[key];\n\n          // If they make the filter more specific we want\n          // to change the subscription since it will reduce\n          // the overhead on the backend as the event stream\n          // can be a firehose for all state events.\n          if (idsChanged(oldValue, curValue)) {\n            changed = true;\n            break;\n          }\n        }\n        if (changed) {\n          this.refresh(true);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_handleLogbookLive\",\n      value: function _handleLogbookLive(ev) {\n        if (ev.detail.enable && !this._liveUpdatesEnabled) {\n          // Process everything we queued up while we were scrolled down\n          this._pendingStreamMessages.forEach(msg => this._processStreamMessage(msg));\n          this._pendingStreamMessages = [];\n        }\n        this._liveUpdatesEnabled = ev.detail.enable;\n      }\n    }, {\n      kind: \"get\",\n      key: \"_filterAlwaysEmptyResults\",\n      value: function _filterAlwaysEmptyResults() {\n        const entityIds = this.entityIds;\n        const deviceIds = this.deviceIds;\n\n        // If all specified filters are empty lists, we can return an empty list.\n        return Boolean(entityIds || deviceIds) && (!entityIds || entityIds.length === 0) && (!deviceIds || deviceIds.length === 0);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_unsubscribe\",\n      value: async function _unsubscribe() {\n        if (this._subscribed) {\n          const unsub = await this._subscribed;\n          if (unsub) {\n            try {\n              await unsub();\n            } catch (e) {\n              // The backend will cancel the subscription if\n              // we subscribe to entities that will all be\n              // filtered away\n            }\n          }\n          this._subscribed = undefined;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HaLogbook.prototype), \"connectedCallback\", this).call(this);\n        if (this.hasUpdated) {\n          this._subscribeLogbookPeriod(this._calculateLogbookPeriod());\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaLogbook.prototype), \"disconnectedCallback\", this).call(this);\n        this._unsubscribeSetLoading();\n      }\n\n      /** Unsubscribe because we are unloading\n       * or about to resubscribe.\n       * Setting this._logbookEntries to undefined\n       * will put the page in a loading state.\n       */\n    }, {\n      kind: \"method\",\n      key: \"_unsubscribeSetLoading\",\n      value: async function _unsubscribeSetLoading() {\n        await this._unsubscribe();\n        this._logbookEntries = undefined;\n        this._pendingStreamMessages = [];\n      }\n\n      /** Unsubscribe because there are no results.\n       * Setting this._logbookEntries to an empty\n       * list will show a no results message.\n       */\n    }, {\n      kind: \"method\",\n      key: \"_unsubscribeNoResults\",\n      value: async function _unsubscribeNoResults() {\n        await this._unsubscribe();\n        this._logbookEntries = [];\n        this._pendingStreamMessages = [];\n      }\n    }, {\n      kind: \"method\",\n      key: \"_calculateLogbookPeriod\",\n      value: function _calculateLogbookPeriod() {\n        const now = new Date();\n        if (\"range\" in this.time) {\n          return {\n            now: now,\n            startTime: this.time.range[0],\n            endTime: this.time.range[1],\n            purgeBeforePythonTime: undefined\n          };\n        }\n        if (\"recent\" in this.time) {\n          const purgeBeforePythonTime = findStartOfRecentTime(now, this.time.recent);\n          return {\n            now: now,\n            startTime: new Date(purgeBeforePythonTime * 1000),\n            // end streaming one year from now\n            endTime: new Date(now.getTime() + 86400 * 365 * 1000),\n            purgeBeforePythonTime: findStartOfRecentTime(now, this.time.recent)\n          };\n        }\n        throw new Error(\"Unexpected time specified\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"_subscribeLogbookPeriod\",\n      value: function _subscribeLogbookPeriod(logbookPeriod) {\n        if (this._subscribed) {\n          return true;\n        }\n        this._subscribed = subscribeLogbook(this.hass, streamMessage => {\n          // \"recent\" means start time is a sliding window\n          // so we need to calculate an expireTime to\n          // purge old events\n          if (!this._subscribed) {\n            // Message came in before we had a chance to unload\n            return;\n          }\n          this._processOrQueueStreamMessage(streamMessage);\n        }, logbookPeriod.startTime.toISOString(), logbookPeriod.endTime.toISOString(), this.entityIds, this.deviceIds).catch(err => {\n          this._subscribed = undefined;\n          this._error = err;\n        });\n        return true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getLogBookData\",\n      value: async function _getLogBookData() {\n        var _this$hass$user;\n        this._error = undefined;\n        if (this._filterAlwaysEmptyResults) {\n          this._unsubscribeNoResults();\n          return;\n        }\n        const logbookPeriod = this._calculateLogbookPeriod();\n        if (logbookPeriod.startTime > logbookPeriod.now) {\n          // Time Travel not yet invented\n          this._unsubscribeNoResults();\n          return;\n        }\n        this._updateUsers();\n        if ((_this$hass$user = this.hass.user) !== null && _this$hass$user !== void 0 && _this$hass$user.is_admin) {\n          this._updateTraceContexts();\n        }\n        this._subscribeLogbookPeriod(logbookPeriod);\n      }\n    }, {\n      kind: \"field\",\n      key: \"_nonExpiredRecords\",\n      value() {\n        return purgeBeforePythonTime => !this._logbookEntries ? [] : purgeBeforePythonTime ? this._logbookEntries.filter(entry => entry.when > purgeBeforePythonTime) : this._logbookEntries;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_processOrQueueStreamMessage\",\n      value() {\n        return streamMessage => {\n          if (this._liveUpdatesEnabled) {\n            this._processStreamMessage(streamMessage);\n            return;\n          }\n          this._pendingStreamMessages.push(streamMessage);\n        };\n      }\n    }, {\n      kind: \"field\",\n      key: \"_processStreamMessage\",\n      value() {\n        return streamMessage => {\n          const purgeBeforePythonTime = \"recent\" in this.time ? findStartOfRecentTime(new Date(), this.time.recent) : undefined;\n          // Put newest ones on top. Reverse works in-place so\n          // make a copy first.\n          const newEntries = [...streamMessage.events].reverse();\n          if (!this._logbookEntries || !this._logbookEntries.length) {\n            this._logbookEntries = newEntries;\n            return;\n          }\n          if (!newEntries.length) {\n            // Empty messages are still sent to\n            // indicate no more historical events\n            return;\n          }\n          const nonExpiredRecords = this._nonExpiredRecords(purgeBeforePythonTime);\n\n          // Entries are sorted in descending order with newest first.\n          if (!nonExpiredRecords.length) {\n            // We have no records left, so we can just replace the list\n            this._logbookEntries = newEntries;\n          } else if (newEntries[newEntries.length - 1].when >\n          // oldest new entry\n          nonExpiredRecords[0].when // newest old entry\n          ) {\n            // The new records are newer than the old records\n            // append the old records to the end of the new records\n            this._logbookEntries = newEntries.concat(nonExpiredRecords);\n          } else if (nonExpiredRecords[nonExpiredRecords.length - 1].when >\n          // oldest old entry\n          newEntries[0].when // newest new entry\n          ) {\n            // The new records are older than the old records\n            // append the new records to the end of the old records\n            this._logbookEntries = nonExpiredRecords.concat(newEntries);\n          } else {\n            // The new records are in the middle of the old records\n            // so we need to re-sort them\n            this._logbookEntries = nonExpiredRecords.concat(newEntries).sort((a, b) => b.when - a.when);\n          }\n        };\n      }\n    }, {\n      kind: \"field\",\n      key: \"_updateTraceContexts\",\n      value() {\n        return throttle(async () => {\n          this._traceContexts = await loadTraceContexts(this.hass);\n        }, 60000);\n      }\n    }, {\n      kind: \"field\",\n      key: \"_updateUsers\",\n      value() {\n        return throttle(async () => {\n          var _this$hass$user2;\n          const userIdToName = {};\n\n          // Start loading users\n          const userProm = ((_this$hass$user2 = this.hass.user) === null || _this$hass$user2 === void 0 ? void 0 : _this$hass$user2.is_admin) && fetchUsers(this.hass);\n\n          // Process persons\n          for (const entity of Object.values(this.hass.states)) {\n            if (entity.attributes.user_id && computeStateDomain(entity) === \"person\") {\n              userIdToName[entity.attributes.user_id] = entity.attributes.friendly_name;\n            }\n          }\n\n          // Process users\n          if (userProm) {\n            const users = await userProm;\n            for (const user of users) {\n              if (!(user.id in userIdToName)) {\n                userIdToName[user.id] = user.name;\n              }\n            }\n          }\n          this._userIdToName = userIdToName;\n        }, 60000);\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return [css`\n        :host {\n          display: block;\n        }\n\n        :host([virtualize]) {\n          height: 100%;\n        }\n\n        .no-entries {\n          text-align: center;\n          padding: 16px;\n          color: var(--secondary-text-color);\n        }\n\n        .progress-wrapper {\n          display: flex;\n          justify-content: center;\n          height: 100%;\n          align-items: center;\n        }\n      `];\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","nothing","customElement","property","state","isComponentLoaded","computeStateDomain","throttle","subscribeLogbook","loadTraceContexts","fetchUsers","findStartOfRecentTime","now","recentTime","Date","getTime","idsChanged","oldIds","newIds","undefined","length","some","val","includes","HaLogbook","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","reflect","_getLogBookData","render","hass","_error","localize","_logbookEntries","narrow","virtualize","noIcon","noName","showIndicator","relativeTime","_traceContexts","_userIdToName","_handleLogbookLive","refresh","force","_subscribed","_throttleGetLogbookEntries","cancel","_updateTraceContexts","_updateUsers","_unsubscribeSetLoading","shouldUpdate","changedProps","size","has","oldHass","get","willUpdate","changed","oldValue","curValue","ev","detail","enable","_liveUpdatesEnabled","_pendingStreamMessages","forEach","msg","_processStreamMessage","_filterAlwaysEmptyResults","entityIds","deviceIds","_unsubscribe","unsub","e","connectedCallback","_get","_getPrototypeOf","prototype","call","hasUpdated","_subscribeLogbookPeriod","_calculateLogbookPeriod","disconnectedCallback","_unsubscribeNoResults","time","startTime","range","endTime","purgeBeforePythonTime","recent","Error","logbookPeriod","streamMessage","_processOrQueueStreamMessage","toISOString","catch","err","_this$hass$user","user","is_admin","filter","entry","when","push","newEntries","events","reverse","nonExpiredRecords","_nonExpiredRecords","concat","sort","a","b","_this$hass$user2","userIdToName","userProm","entity","Object","values","states","attributes","user_id","friendly_name","users","id","name","static","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/panels/logbook/ha-logbook.ts"],"sourcesContent":["import { css, html, LitElement, PropertyValues, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../../common/config/is_component_loaded\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { throttle } from \"../../common/util/throttle\";\nimport \"../../components/ha-circular-progress\";\nimport {\n  LogbookEntry,\n  LogbookStreamMessage,\n  subscribeLogbook,\n} from \"../../data/logbook\";\nimport { loadTraceContexts, TraceContexts } from \"../../data/trace\";\nimport { fetchUsers } from \"../../data/user\";\nimport { HomeAssistant } from \"../../types\";\nimport \"./ha-logbook-renderer\";\n\ninterface LogbookTimePeriod {\n  now: Date;\n  startTime: Date;\n  endTime: Date;\n  purgeBeforePythonTime: number | undefined;\n}\n\nconst findStartOfRecentTime = (now: Date, recentTime: number) =>\n  new Date(now.getTime() - recentTime * 1000).getTime() / 1000;\n\nconst idsChanged = (oldIds?: string[], newIds?: string[]) => {\n  if (oldIds === undefined && newIds === undefined) {\n    return false;\n  }\n  return (\n    !oldIds ||\n    !newIds ||\n    oldIds.length !== newIds.length ||\n    oldIds.some((val) => !newIds.includes(val)) ||\n    newIds.some((val) => !oldIds.includes(val))\n  );\n};\n\n@customElement(\"ha-logbook\")\nexport class HaLogbook extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public time!:\n    | { range: [Date, Date] }\n    | {\n        // Seconds\n        recent: number;\n      };\n\n  @property({ attribute: false }) public entityIds?: string[];\n\n  @property({ attribute: false }) public deviceIds?: string[];\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @property({ type: Boolean, reflect: true }) public virtualize = false;\n\n  @property({ type: Boolean, attribute: \"no-icon\" }) public noIcon = false;\n\n  @property({ type: Boolean, attribute: \"no-name\" }) public noName = false;\n\n  @property({ type: Boolean, attribute: \"show-indicator\" })\n  public showIndicator = false;\n\n  @property({ type: Boolean, attribute: \"relative-time\" })\n  public relativeTime = false;\n\n  @property({ type: Boolean }) public showMoreLink = true;\n\n  @state() private _logbookEntries?: LogbookEntry[];\n\n  @state() private _traceContexts: TraceContexts = {};\n\n  @state() private _userIdToName = {};\n\n  @state() private _error?: string;\n\n  private _subscribed?: Promise<(() => Promise<void>) | void>;\n\n  private _liveUpdatesEnabled = true;\n\n  private _pendingStreamMessages: LogbookStreamMessage[] = [];\n\n  private _throttleGetLogbookEntries = throttle(\n    () => this._getLogBookData(),\n    1000\n  );\n\n  protected render() {\n    if (!isComponentLoaded(this.hass, \"logbook\")) {\n      return nothing;\n    }\n\n    if (this._error) {\n      return html`<div class=\"no-entries\">\n        ${`${this.hass.localize(\"ui.components.logbook.retrieval_error\")}: ${\n          this._error\n        }`}\n      </div>`;\n    }\n\n    if (this._logbookEntries === undefined) {\n      return html`\n        <div class=\"progress-wrapper\">\n          <ha-circular-progress indeterminate></ha-circular-progress>\n        </div>\n      `;\n    }\n\n    if (this._logbookEntries.length === 0) {\n      return html`<div class=\"no-entries\">\n        ${this.hass.localize(\"ui.components.logbook.entries_not_found\")}\n      </div>`;\n    }\n\n    return html`\n      <ha-logbook-renderer\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n        .virtualize=${this.virtualize}\n        .noIcon=${this.noIcon}\n        .noName=${this.noName}\n        .showIndicator=${this.showIndicator}\n        .relativeTime=${this.relativeTime}\n        .entries=${this._logbookEntries}\n        .traceContexts=${this._traceContexts}\n        .userIdToName=${this._userIdToName}\n        @hass-logbook-live=${this._handleLogbookLive}\n      ></ha-logbook-renderer>\n    `;\n  }\n\n  public async refresh(force = false) {\n    if (!force && (this._subscribed || this._logbookEntries === undefined)) {\n      return;\n    }\n\n    this._throttleGetLogbookEntries.cancel();\n    this._updateTraceContexts.cancel();\n    this._updateUsers.cancel();\n    await this._unsubscribeSetLoading();\n\n    if (force) {\n      this._getLogBookData();\n    } else {\n      this._throttleGetLogbookEntries();\n    }\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    if (changedProps.size !== 1 || !changedProps.has(\"hass\")) {\n      return true;\n    }\n    // We only respond to hass changes if the translations changed\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n    return !oldHass || oldHass.localize !== this.hass.localize;\n  }\n\n  protected willUpdate(changedProps: PropertyValues): void {\n    let changed = changedProps.has(\"time\");\n\n    for (const key of [\"entityIds\", \"deviceIds\"]) {\n      if (!changedProps.has(key)) {\n        continue;\n      }\n\n      const oldValue = changedProps.get(key) as string[] | undefined;\n      const curValue = this[key] as string[] | undefined;\n\n      // If they make the filter more specific we want\n      // to change the subscription since it will reduce\n      // the overhead on the backend as the event stream\n      // can be a firehose for all state events.\n      if (idsChanged(oldValue, curValue)) {\n        changed = true;\n        break;\n      }\n    }\n\n    if (changed) {\n      this.refresh(true);\n    }\n  }\n\n  private _handleLogbookLive(ev: CustomEvent) {\n    if (ev.detail.enable && !this._liveUpdatesEnabled) {\n      // Process everything we queued up while we were scrolled down\n      this._pendingStreamMessages.forEach((msg) =>\n        this._processStreamMessage(msg)\n      );\n      this._pendingStreamMessages = [];\n    }\n    this._liveUpdatesEnabled = ev.detail.enable;\n  }\n\n  private get _filterAlwaysEmptyResults(): boolean {\n    const entityIds = this.entityIds;\n    const deviceIds = this.deviceIds;\n\n    // If all specified filters are empty lists, we can return an empty list.\n    return (\n      Boolean(entityIds || deviceIds) &&\n      (!entityIds || entityIds.length === 0) &&\n      (!deviceIds || deviceIds.length === 0)\n    );\n  }\n\n  private async _unsubscribe(): Promise<void> {\n    if (this._subscribed) {\n      const unsub = await this._subscribed;\n      if (unsub) {\n        try {\n          await unsub();\n        } catch (e) {\n          // The backend will cancel the subscription if\n          // we subscribe to entities that will all be\n          // filtered away\n        }\n      }\n      this._subscribed = undefined;\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._subscribeLogbookPeriod(this._calculateLogbookPeriod());\n    }\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._unsubscribeSetLoading();\n  }\n\n  /** Unsubscribe because we are unloading\n   * or about to resubscribe.\n   * Setting this._logbookEntries to undefined\n   * will put the page in a loading state.\n   */\n  private async _unsubscribeSetLoading() {\n    await this._unsubscribe();\n    this._logbookEntries = undefined;\n    this._pendingStreamMessages = [];\n  }\n\n  /** Unsubscribe because there are no results.\n   * Setting this._logbookEntries to an empty\n   * list will show a no results message.\n   */\n  private async _unsubscribeNoResults() {\n    await this._unsubscribe();\n    this._logbookEntries = [];\n    this._pendingStreamMessages = [];\n  }\n\n  private _calculateLogbookPeriod() {\n    const now = new Date();\n    if (\"range\" in this.time) {\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: this.time.range[0],\n        endTime: this.time.range[1],\n        purgeBeforePythonTime: undefined,\n      };\n    }\n    if (\"recent\" in this.time) {\n      const purgeBeforePythonTime = findStartOfRecentTime(\n        now,\n        this.time.recent\n      );\n      return <LogbookTimePeriod>{\n        now: now,\n        startTime: new Date(purgeBeforePythonTime * 1000),\n        // end streaming one year from now\n        endTime: new Date(now.getTime() + 86400 * 365 * 1000),\n        purgeBeforePythonTime: findStartOfRecentTime(now, this.time.recent),\n      };\n    }\n    throw new Error(\"Unexpected time specified\");\n  }\n\n  private _subscribeLogbookPeriod(logbookPeriod: LogbookTimePeriod) {\n    if (this._subscribed) {\n      return true;\n    }\n    this._subscribed = subscribeLogbook(\n      this.hass,\n      (streamMessage) => {\n        // \"recent\" means start time is a sliding window\n        // so we need to calculate an expireTime to\n        // purge old events\n        if (!this._subscribed) {\n          // Message came in before we had a chance to unload\n          return;\n        }\n        this._processOrQueueStreamMessage(streamMessage);\n      },\n      logbookPeriod.startTime.toISOString(),\n      logbookPeriod.endTime.toISOString(),\n      this.entityIds,\n      this.deviceIds\n    ).catch((err) => {\n      this._subscribed = undefined;\n      this._error = err;\n    });\n    return true;\n  }\n\n  private async _getLogBookData() {\n    this._error = undefined;\n\n    if (this._filterAlwaysEmptyResults) {\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    const logbookPeriod = this._calculateLogbookPeriod();\n\n    if (logbookPeriod.startTime > logbookPeriod.now) {\n      // Time Travel not yet invented\n      this._unsubscribeNoResults();\n      return;\n    }\n\n    this._updateUsers();\n    if (this.hass.user?.is_admin) {\n      this._updateTraceContexts();\n    }\n\n    this._subscribeLogbookPeriod(logbookPeriod);\n  }\n\n  private _nonExpiredRecords = (purgeBeforePythonTime: number | undefined) =>\n    !this._logbookEntries\n      ? []\n      : purgeBeforePythonTime\n        ? this._logbookEntries.filter(\n            (entry) => entry.when > purgeBeforePythonTime!\n          )\n        : this._logbookEntries;\n\n  private _processOrQueueStreamMessage = (\n    streamMessage: LogbookStreamMessage\n  ) => {\n    if (this._liveUpdatesEnabled) {\n      this._processStreamMessage(streamMessage);\n      return;\n    }\n    this._pendingStreamMessages.push(streamMessage);\n  };\n\n  private _processStreamMessage = (streamMessage: LogbookStreamMessage) => {\n    const purgeBeforePythonTime =\n      \"recent\" in this.time\n        ? findStartOfRecentTime(new Date(), this.time.recent)\n        : undefined;\n    // Put newest ones on top. Reverse works in-place so\n    // make a copy first.\n    const newEntries = [...streamMessage.events].reverse();\n    if (!this._logbookEntries || !this._logbookEntries.length) {\n      this._logbookEntries = newEntries;\n      return;\n    }\n    if (!newEntries.length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return;\n    }\n    const nonExpiredRecords = this._nonExpiredRecords(purgeBeforePythonTime);\n\n    // Entries are sorted in descending order with newest first.\n    if (!nonExpiredRecords.length) {\n      // We have no records left, so we can just replace the list\n      this._logbookEntries = newEntries;\n    } else if (\n      newEntries[newEntries.length - 1].when > // oldest new entry\n      nonExpiredRecords[0].when // newest old entry\n    ) {\n      // The new records are newer than the old records\n      // append the old records to the end of the new records\n      this._logbookEntries = newEntries.concat(nonExpiredRecords);\n    } else if (\n      nonExpiredRecords[nonExpiredRecords.length - 1].when > // oldest old entry\n      newEntries[0].when // newest new entry\n    ) {\n      // The new records are older than the old records\n      // append the new records to the end of the old records\n      this._logbookEntries = nonExpiredRecords.concat(newEntries);\n    } else {\n      // The new records are in the middle of the old records\n      // so we need to re-sort them\n      this._logbookEntries = nonExpiredRecords\n        .concat(newEntries)\n        .sort((a, b) => b.when - a.when);\n    }\n  };\n\n  private _updateTraceContexts = throttle(async () => {\n    this._traceContexts = await loadTraceContexts(this.hass);\n  }, 60000);\n\n  private _updateUsers = throttle(async () => {\n    const userIdToName = {};\n\n    // Start loading users\n    const userProm = this.hass.user?.is_admin && fetchUsers(this.hass);\n\n    // Process persons\n    for (const entity of Object.values(this.hass.states)) {\n      if (\n        entity.attributes.user_id &&\n        computeStateDomain(entity) === \"person\"\n      ) {\n        userIdToName[entity.attributes.user_id] =\n          entity.attributes.friendly_name;\n      }\n    }\n\n    // Process users\n    if (userProm) {\n      const users = await userProm;\n      for (const user of users) {\n        if (!(user.id in userIdToName)) {\n          userIdToName[user.id] = user.name;\n        }\n      }\n    }\n\n    this._userIdToName = userIdToName;\n  }, 60000);\n\n  static get styles() {\n    return [\n      css`\n        :host {\n          display: block;\n        }\n\n        :host([virtualize]) {\n          height: 100%;\n        }\n\n        .no-entries {\n          text-align: center;\n          padding: 16px;\n          color: var(--secondary-text-color);\n        }\n\n        .progress-wrapper {\n          display: flex;\n          justify-content: center;\n          height: 100%;\n          align-items: center;\n        }\n      `,\n    ];\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-logbook\": HaLogbook;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}