{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"unfetch/polyfill\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\nimport \"core-js/modules/web.atob.js\";\nimport \"core-js/modules/web.btoa.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-exception.constructor.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/web.dom-exception.to-string-tag.js\";\nimport { parseQuery } from \"./util.js\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH, ERR_INVALID_AUTH_CALLBACK, ERR_INVALID_HTTPS_TO_HTTP } from \"./errors.js\";\nexport var genClientId = function genClientId() {\n  return \"\".concat(location.protocol, \"//\").concat(location.host, \"/\");\n};\nexport var genExpires = function genExpires(expires_in) {\n  return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n  // Get current url but without # part.\n  var _location = location,\n    protocol = _location.protocol,\n    host = _location.host,\n    pathname = _location.pathname,\n    search = _location.search;\n  return \"\".concat(protocol, \"//\").concat(host).concat(pathname).concat(search);\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n  var authorizeUrl = \"\".concat(hassUrl, \"/auth/authorize?response_type=code&redirect_uri=\").concat(encodeURIComponent(redirectUrl));\n  if (clientId !== null) {\n    authorizeUrl += \"&client_id=\".concat(encodeURIComponent(clientId));\n  }\n  if (state) {\n    authorizeUrl += \"&state=\".concat(encodeURIComponent(state));\n  }\n  return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n  // Add either ?auth_callback=1 or &auth_callback=1\n  redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n  document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nfunction tokenRequest(_x, _x2, _x3) {\n  return _tokenRequest.apply(this, arguments);\n}\nfunction _tokenRequest() {\n  _tokenRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(hassUrl, clientId, data) {\n    var l, a, formData, resp, tokens;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          // Browsers don't allow fetching tokens from https -> http.\n          // Throw an error because it's a pain to debug this.\n          // Guard against not working in node.\n          l = typeof location !== \"undefined\" && location;\n          if (!(l && l.protocol === \"https:\")) {\n            _context3.next = 6;\n            break;\n          }\n          // Ensure that the hassUrl is hosted on https.\n          a = document.createElement(\"a\");\n          a.href = hassUrl;\n          if (!(a.protocol === \"http:\" && a.hostname !== \"localhost\")) {\n            _context3.next = 6;\n            break;\n          }\n          throw ERR_INVALID_HTTPS_TO_HTTP;\n        case 6:\n          formData = new FormData();\n          if (clientId !== null) {\n            formData.append(\"client_id\", clientId);\n          }\n          Object.keys(data).forEach(function (key) {\n            formData.append(key, data[key]);\n          });\n          _context3.next = 11;\n          return fetch(\"\".concat(hassUrl, \"/auth/token\"), {\n            method: \"POST\",\n            credentials: \"same-origin\",\n            body: formData\n          });\n        case 11:\n          resp = _context3.sent;\n          if (resp.ok) {\n            _context3.next = 14;\n            break;\n          }\n          throw resp.status === 400 /* auth invalid */ || resp.status === 403 /* user not active */ ? ERR_INVALID_AUTH : new Error(\"Unable to fetch tokens\");\n        case 14:\n          _context3.next = 16;\n          return resp.json();\n        case 16:\n          tokens = _context3.sent;\n          tokens.hassUrl = hassUrl;\n          tokens.clientId = clientId;\n          tokens.expires = genExpires(tokens.expires_in);\n          return _context3.abrupt(\"return\", tokens);\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _tokenRequest.apply(this, arguments);\n}\nfunction fetchToken(hassUrl, clientId, code) {\n  return tokenRequest(hassUrl, clientId, {\n    code: code,\n    grant_type: \"authorization_code\"\n  });\n}\nfunction encodeOAuthState(state) {\n  return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n  return JSON.parse(atob(encoded));\n}\nexport var Auth = /*#__PURE__*/function () {\n  function Auth(data, saveTokens) {\n    _classCallCheck(this, Auth);\n    this.data = data;\n    this._saveTokens = saveTokens;\n  }\n  _createClass(Auth, [{\n    key: \"wsUrl\",\n    get: function get() {\n      // Convert from http:// -> ws://, https:// -> wss://\n      return \"ws\".concat(this.data.hassUrl.substr(4), \"/api/websocket\");\n    }\n  }, {\n    key: \"accessToken\",\n    get: function get() {\n      return this.data.access_token;\n    }\n  }, {\n    key: \"expired\",\n    get: function get() {\n      return Date.now() > this.data.expires;\n    }\n    /**\n     * Refresh the access token.\n     */\n  }, {\n    key: \"refreshAccessToken\",\n    value: (function () {\n      var _refreshAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.data.refresh_token) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error(\"No refresh_token\");\n            case 2:\n              _context.next = 4;\n              return tokenRequest(this.data.hassUrl, this.data.clientId, {\n                grant_type: \"refresh_token\",\n                refresh_token: this.data.refresh_token\n              });\n            case 4:\n              data = _context.sent;\n              // Access token response does not contain refresh token.\n              data.refresh_token = this.data.refresh_token;\n              this.data = data;\n              if (this._saveTokens) this._saveTokens(data);\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function refreshAccessToken() {\n        return _refreshAccessToken.apply(this, arguments);\n      }\n      return refreshAccessToken;\n    }()\n    /**\n     * Revoke the refresh & access tokens.\n     */\n    )\n  }, {\n    key: \"revoke\",\n    value: (function () {\n      var _revoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var formData;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.data.refresh_token) {\n                _context2.next = 2;\n                break;\n              }\n              throw new Error(\"No refresh_token to revoke\");\n            case 2:\n              formData = new FormData();\n              formData.append(\"token\", this.data.refresh_token);\n              // There is no error checking, as revoke will always return 200\n              _context2.next = 6;\n              return fetch(\"\".concat(this.data.hassUrl, \"/auth/revoke\"), {\n                method: \"POST\",\n                credentials: \"same-origin\",\n                body: formData\n              });\n            case 6:\n              if (this._saveTokens) {\n                this._saveTokens(null);\n              }\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function revoke() {\n        return _revoke.apply(this, arguments);\n      }\n      return revoke;\n    }())\n  }]);\n  return Auth;\n}();\nexport function createLongLivedTokenAuth(hassUrl, access_token) {\n  return new Auth({\n    hassUrl: hassUrl,\n    clientId: null,\n    expires: Date.now() + 1e11,\n    refresh_token: \"\",\n    access_token: access_token,\n    expires_in: 1e11\n  });\n}\nexport function getAuth() {\n  return _getAuth.apply(this, arguments);\n}\nfunction _getAuth() {\n  _getAuth = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var options,\n      data,\n      hassUrl,\n      clientId,\n      limitHassInstance,\n      query,\n      state,\n      _args4 = arguments;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n          hassUrl = options.hassUrl; // Strip trailing slash.\n          if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n            hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n          }\n          clientId = options.clientId !== undefined ? options.clientId : genClientId();\n          limitHassInstance = options.limitHassInstance === true; // Use auth code if it was passed in\n          if (!(options.authCode && hassUrl)) {\n            _context4.next = 10;\n            break;\n          }\n          _context4.next = 8;\n          return fetchToken(hassUrl, clientId, options.authCode);\n        case 8:\n          data = _context4.sent;\n          if (options.saveTokens) {\n            options.saveTokens(data);\n          }\n        case 10:\n          if (data) {\n            _context4.next = 20;\n            break;\n          }\n          query = parseQuery(location.search.substr(1)); // Check if we got redirected here from authorize page\n          if (!(\"auth_callback\" in query)) {\n            _context4.next = 20;\n            break;\n          }\n          // Restore state\n          state = decodeOAuthState(query.state);\n          if (!(limitHassInstance && (state.hassUrl !== hassUrl || state.clientId !== clientId))) {\n            _context4.next = 16;\n            break;\n          }\n          throw ERR_INVALID_AUTH_CALLBACK;\n        case 16:\n          _context4.next = 18;\n          return fetchToken(state.hassUrl, state.clientId, query.code);\n        case 18:\n          data = _context4.sent;\n          if (options.saveTokens) {\n            options.saveTokens(data);\n          }\n        case 20:\n          if (!(!data && options.loadTokens)) {\n            _context4.next = 24;\n            break;\n          }\n          _context4.next = 23;\n          return options.loadTokens();\n        case 23:\n          data = _context4.sent;\n        case 24:\n          if (!data) {\n            _context4.next = 26;\n            break;\n          }\n          return _context4.abrupt(\"return\", new Auth(data, options.saveTokens));\n        case 26:\n          if (!(hassUrl === undefined)) {\n            _context4.next = 28;\n            break;\n          }\n          throw ERR_HASS_HOST_REQUIRED;\n        case 28:\n          // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n          redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n            hassUrl: hassUrl,\n            clientId: clientId\n          }));\n          // Just don't resolve while we navigate to next page\n          return _context4.abrupt(\"return\", new Promise(function () {}));\n        case 30:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _getAuth.apply(this, arguments);\n}","map":{"version":3,"names":["parseQuery","ERR_HASS_HOST_REQUIRED","ERR_INVALID_AUTH","ERR_INVALID_AUTH_CALLBACK","ERR_INVALID_HTTPS_TO_HTTP","genClientId","concat","location","protocol","host","genExpires","expires_in","Date","now","genRedirectUrl","_location","pathname","search","genAuthorizeUrl","hassUrl","clientId","redirectUrl","state","authorizeUrl","encodeURIComponent","redirectAuthorize","includes","document","href","tokenRequest","_x","_x2","_x3","_tokenRequest","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee3","data","l","a","formData","resp","tokens","wrap","_callee3$","_context3","prev","next","createElement","hostname","FormData","append","Object","keys","forEach","key","fetch","method","credentials","body","sent","ok","status","Error","json","expires","abrupt","stop","fetchToken","code","grant_type","encodeOAuthState","btoa","JSON","stringify","decodeOAuthState","encoded","parse","atob","Auth","saveTokens","_classCallCheck","_saveTokens","_createClass","get","substr","access_token","value","_refreshAccessToken","_callee","_callee$","_context","refresh_token","refreshAccessToken","_revoke","_callee2","_callee2$","_context2","revoke","createLongLivedTokenAuth","getAuth","_getAuth","_callee4","options","limitHassInstance","query","_args4","_callee4$","_context4","length","undefined","authCode","loadTokens","Promise"],"sources":["/workspaces/frontend/node_modules/home-assistant-js-websocket/dist/auth.js"],"sourcesContent":["import { parseQuery } from \"./util.js\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH, ERR_INVALID_AUTH_CALLBACK, ERR_INVALID_HTTPS_TO_HTTP, } from \"./errors.js\";\nexport const genClientId = () => `${location.protocol}//${location.host}/`;\nexport const genExpires = (expires_in) => {\n    return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n    // Get current url but without # part.\n    const { protocol, host, pathname, search } = location;\n    return `${protocol}//${host}${pathname}${search}`;\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n    let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n    if (clientId !== null) {\n        authorizeUrl += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n    if (state) {\n        authorizeUrl += `&state=${encodeURIComponent(state)}`;\n    }\n    return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n    // Add either ?auth_callback=1 or &auth_callback=1\n    redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n    document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nasync function tokenRequest(hassUrl, clientId, data) {\n    // Browsers don't allow fetching tokens from https -> http.\n    // Throw an error because it's a pain to debug this.\n    // Guard against not working in node.\n    const l = typeof location !== \"undefined\" && location;\n    if (l && l.protocol === \"https:\") {\n        // Ensure that the hassUrl is hosted on https.\n        const a = document.createElement(\"a\");\n        a.href = hassUrl;\n        if (a.protocol === \"http:\" && a.hostname !== \"localhost\") {\n            throw ERR_INVALID_HTTPS_TO_HTTP;\n        }\n    }\n    const formData = new FormData();\n    if (clientId !== null) {\n        formData.append(\"client_id\", clientId);\n    }\n    Object.keys(data).forEach((key) => {\n        formData.append(key, data[key]);\n    });\n    const resp = await fetch(`${hassUrl}/auth/token`, {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        body: formData,\n    });\n    if (!resp.ok) {\n        throw resp.status === 400 /* auth invalid */ ||\n            resp.status === 403 /* user not active */\n            ? ERR_INVALID_AUTH\n            : new Error(\"Unable to fetch tokens\");\n    }\n    const tokens = await resp.json();\n    tokens.hassUrl = hassUrl;\n    tokens.clientId = clientId;\n    tokens.expires = genExpires(tokens.expires_in);\n    return tokens;\n}\nfunction fetchToken(hassUrl, clientId, code) {\n    return tokenRequest(hassUrl, clientId, {\n        code,\n        grant_type: \"authorization_code\",\n    });\n}\nfunction encodeOAuthState(state) {\n    return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n    return JSON.parse(atob(encoded));\n}\nexport class Auth {\n    constructor(data, saveTokens) {\n        this.data = data;\n        this._saveTokens = saveTokens;\n    }\n    get wsUrl() {\n        // Convert from http:// -> ws://, https:// -> wss://\n        return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n    }\n    get accessToken() {\n        return this.data.access_token;\n    }\n    get expired() {\n        return Date.now() > this.data.expires;\n    }\n    /**\n     * Refresh the access token.\n     */\n    async refreshAccessToken() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token\");\n        const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n            grant_type: \"refresh_token\",\n            refresh_token: this.data.refresh_token,\n        });\n        // Access token response does not contain refresh token.\n        data.refresh_token = this.data.refresh_token;\n        this.data = data;\n        if (this._saveTokens)\n            this._saveTokens(data);\n    }\n    /**\n     * Revoke the refresh & access tokens.\n     */\n    async revoke() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token to revoke\");\n        const formData = new FormData();\n        formData.append(\"token\", this.data.refresh_token);\n        // There is no error checking, as revoke will always return 200\n        await fetch(`${this.data.hassUrl}/auth/revoke`, {\n            method: \"POST\",\n            credentials: \"same-origin\",\n            body: formData,\n        });\n        if (this._saveTokens) {\n            this._saveTokens(null);\n        }\n    }\n}\nexport function createLongLivedTokenAuth(hassUrl, access_token) {\n    return new Auth({\n        hassUrl,\n        clientId: null,\n        expires: Date.now() + 1e11,\n        refresh_token: \"\",\n        access_token,\n        expires_in: 1e11,\n    });\n}\nexport async function getAuth(options = {}) {\n    let data;\n    let hassUrl = options.hassUrl;\n    // Strip trailing slash.\n    if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n        hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n    }\n    const clientId = options.clientId !== undefined ? options.clientId : genClientId();\n    const limitHassInstance = options.limitHassInstance === true;\n    // Use auth code if it was passed in\n    if (options.authCode && hassUrl) {\n        data = await fetchToken(hassUrl, clientId, options.authCode);\n        if (options.saveTokens) {\n            options.saveTokens(data);\n        }\n    }\n    // Check if we came back from an authorize redirect\n    if (!data) {\n        const query = parseQuery(location.search.substr(1));\n        // Check if we got redirected here from authorize page\n        if (\"auth_callback\" in query) {\n            // Restore state\n            const state = decodeOAuthState(query.state);\n            if (limitHassInstance &&\n                (state.hassUrl !== hassUrl || state.clientId !== clientId)) {\n                throw ERR_INVALID_AUTH_CALLBACK;\n            }\n            data = await fetchToken(state.hassUrl, state.clientId, query.code);\n            if (options.saveTokens) {\n                options.saveTokens(data);\n            }\n        }\n    }\n    // Check for stored tokens\n    if (!data && options.loadTokens) {\n        data = await options.loadTokens();\n    }\n    if (data) {\n        return new Auth(data, options.saveTokens);\n    }\n    if (hassUrl === undefined) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n    redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n        hassUrl,\n        clientId,\n    }));\n    // Just don't resolve while we navigate to next page\n    return new Promise(() => { });\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,UAAU,QAAQ,WAAW;AACtC,SAASC,sBAAsB,EAAEC,gBAAgB,EAAEC,yBAAyB,EAAEC,yBAAyB,QAAS,aAAa;AAC7H,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAA;EAAA,UAAAC,MAAA,CAAYC,QAAQ,CAACC,QAAQ,QAAAF,MAAA,CAAKC,QAAQ,CAACE,IAAI;AAAA,CAAG;AAC1E,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAUA,CAAIC,UAAU,EAAK;EACtC,OAAOA,UAAU,GAAG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;AACzC,CAAC;AACD,SAASC,cAAcA,CAAA,EAAG;EACtB;EACA,IAAAC,SAAA,GAA6CR,QAAQ;IAA7CC,QAAQ,GAAAO,SAAA,CAARP,QAAQ;IAAEC,IAAI,GAAAM,SAAA,CAAJN,IAAI;IAAEO,QAAQ,GAAAD,SAAA,CAARC,QAAQ;IAAEC,MAAM,GAAAF,SAAA,CAANE,MAAM;EACxC,UAAAX,MAAA,CAAUE,QAAQ,QAAAF,MAAA,CAAKG,IAAI,EAAAH,MAAA,CAAGU,QAAQ,EAAAV,MAAA,CAAGW,MAAM;AACnD;AACA,SAASC,eAAeA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,KAAK,EAAE;EAC5D,IAAIC,YAAY,MAAAjB,MAAA,CAAMa,OAAO,sDAAAb,MAAA,CAAmDkB,kBAAkB,CAACH,WAAW,CAAC,CAAE;EACjH,IAAID,QAAQ,KAAK,IAAI,EAAE;IACnBG,YAAY,kBAAAjB,MAAA,CAAkBkB,kBAAkB,CAACJ,QAAQ,CAAC,CAAE;EAChE;EACA,IAAIE,KAAK,EAAE;IACPC,YAAY,cAAAjB,MAAA,CAAckB,kBAAkB,CAACF,KAAK,CAAC,CAAE;EACzD;EACA,OAAOC,YAAY;AACvB;AACA,SAASE,iBAAiBA,CAACN,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,KAAK,EAAE;EAC9D;EACAD,WAAW,IAAI,CAACA,WAAW,CAACK,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,iBAAiB;EAC1EC,QAAQ,CAACpB,QAAQ,CAACqB,IAAI,GAAGV,eAAe,CAACC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,KAAK,CAAC;AACnF;AAAC,SACcO,YAAYA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,cAAA;EAAAA,aAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAA3B,SAAAC,SAA4BpB,OAAO,EAAEC,QAAQ,EAAEoB,IAAI;IAAA,IAAAC,CAAA,EAAAC,CAAA,EAAAC,QAAA,EAAAC,IAAA,EAAAC,MAAA;IAAA,OAAAR,mBAAA,GAAAS,IAAA,UAAAC,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;QAAA;UAC/C;UACA;UACA;UACMT,CAAC,GAAG,OAAOlC,QAAQ,KAAK,WAAW,IAAIA,QAAQ;UAAA,MACjDkC,CAAC,IAAIA,CAAC,CAACjC,QAAQ,KAAK,QAAQ;YAAAwC,SAAA,CAAAE,IAAA;YAAA;UAAA;UAC5B;UACMR,CAAC,GAAGf,QAAQ,CAACwB,aAAa,CAAC,GAAG,CAAC;UACrCT,CAAC,CAACd,IAAI,GAAGT,OAAO;UAAC,MACbuB,CAAC,CAAClC,QAAQ,KAAK,OAAO,IAAIkC,CAAC,CAACU,QAAQ,KAAK,WAAW;YAAAJ,SAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MAC9C9C,yBAAyB;QAAA;UAGjCuC,QAAQ,GAAG,IAAIU,QAAQ,CAAC,CAAC;UAC/B,IAAIjC,QAAQ,KAAK,IAAI,EAAE;YACnBuB,QAAQ,CAACW,MAAM,CAAC,WAAW,EAAElC,QAAQ,CAAC;UAC1C;UACAmC,MAAM,CAACC,IAAI,CAAChB,IAAI,CAAC,CAACiB,OAAO,CAAC,UAACC,GAAG,EAAK;YAC/Bf,QAAQ,CAACW,MAAM,CAACI,GAAG,EAAElB,IAAI,CAACkB,GAAG,CAAC,CAAC;UACnC,CAAC,CAAC;UAACV,SAAA,CAAAE,IAAA;UAAA,OACgBS,KAAK,IAAArD,MAAA,CAAIa,OAAO,kBAAe;YAC9CyC,MAAM,EAAE,MAAM;YACdC,WAAW,EAAE,aAAa;YAC1BC,IAAI,EAAEnB;UACV,CAAC,CAAC;QAAA;UAJIC,IAAI,GAAAI,SAAA,CAAAe,IAAA;UAAA,IAKLnB,IAAI,CAACoB,EAAE;YAAAhB,SAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,MACFN,IAAI,CAACqB,MAAM,KAAK,GAAG,CAAC,sBACtBrB,IAAI,CAACqB,MAAM,KAAK,GAAG,CAAC,wBAClB/D,gBAAgB,GAChB,IAAIgE,KAAK,CAAC,wBAAwB,CAAC;QAAA;UAAAlB,SAAA,CAAAE,IAAA;UAAA,OAExBN,IAAI,CAACuB,IAAI,CAAC,CAAC;QAAA;UAA1BtB,MAAM,GAAAG,SAAA,CAAAe,IAAA;UACZlB,MAAM,CAAC1B,OAAO,GAAGA,OAAO;UACxB0B,MAAM,CAACzB,QAAQ,GAAGA,QAAQ;UAC1ByB,MAAM,CAACuB,OAAO,GAAG1D,UAAU,CAACmC,MAAM,CAAClC,UAAU,CAAC;UAAC,OAAAqC,SAAA,CAAAqB,MAAA,WACxCxB,MAAM;QAAA;QAAA;UAAA,OAAAG,SAAA,CAAAsB,IAAA;MAAA;IAAA,GAAA/B,QAAA;EAAA,CAChB;EAAA,OAAAN,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AACD,SAASoC,UAAUA,CAACpD,OAAO,EAAEC,QAAQ,EAAEoD,IAAI,EAAE;EACzC,OAAO3C,YAAY,CAACV,OAAO,EAAEC,QAAQ,EAAE;IACnCoD,IAAI,EAAJA,IAAI;IACJC,UAAU,EAAE;EAChB,CAAC,CAAC;AACN;AACA,SAASC,gBAAgBA,CAACpD,KAAK,EAAE;EAC7B,OAAOqD,IAAI,CAACC,IAAI,CAACC,SAAS,CAACvD,KAAK,CAAC,CAAC;AACtC;AACA,SAASwD,gBAAgBA,CAACC,OAAO,EAAE;EAC/B,OAAOH,IAAI,CAACI,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC,CAAC;AACpC;AACA,WAAaG,IAAI;EACb,SAAAA,KAAY1C,IAAI,EAAE2C,UAAU,EAAE;IAAAC,eAAA,OAAAF,IAAA;IAC1B,IAAI,CAAC1C,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC6C,WAAW,GAAGF,UAAU;EACjC;EAACG,YAAA,CAAAJ,IAAA;IAAAxB,GAAA;IAAA6B,GAAA,EACD,SAAAA,IAAA,EAAY;MACR;MACA,YAAAjF,MAAA,CAAY,IAAI,CAACkC,IAAI,CAACrB,OAAO,CAACqE,MAAM,CAAC,CAAC,CAAC;IAC3C;EAAC;IAAA9B,GAAA;IAAA6B,GAAA,EACD,SAAAA,IAAA,EAAkB;MACd,OAAO,IAAI,CAAC/C,IAAI,CAACiD,YAAY;IACjC;EAAC;IAAA/B,GAAA;IAAA6B,GAAA,EACD,SAAAA,IAAA,EAAc;MACV,OAAO3E,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC2B,IAAI,CAAC4B,OAAO;IACzC;IACA;AACJ;AACA;EAFI;IAAAV,GAAA;IAAAgC,KAAA;MAAA,IAAAC,mBAAA,GAAAvD,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGA,SAAAsD,QAAA;QAAA,IAAApD,IAAA;QAAA,OAAAH,mBAAA,GAAAS,IAAA,UAAA+C,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAA7C,IAAA,GAAA6C,QAAA,CAAA5C,IAAA;YAAA;cAAA,IACS,IAAI,CAACV,IAAI,CAACuD,aAAa;gBAAAD,QAAA,CAAA5C,IAAA;gBAAA;cAAA;cAAA,MAClB,IAAIgB,KAAK,CAAC,kBAAkB,CAAC;YAAA;cAAA4B,QAAA,CAAA5C,IAAA;cAAA,OACpBrB,YAAY,CAAC,IAAI,CAACW,IAAI,CAACrB,OAAO,EAAE,IAAI,CAACqB,IAAI,CAACpB,QAAQ,EAAE;gBACnEqD,UAAU,EAAE,eAAe;gBAC3BsB,aAAa,EAAE,IAAI,CAACvD,IAAI,CAACuD;cAC7B,CAAC,CAAC;YAAA;cAHIvD,IAAI,GAAAsD,QAAA,CAAA/B,IAAA;cAIV;cACAvB,IAAI,CAACuD,aAAa,GAAG,IAAI,CAACvD,IAAI,CAACuD,aAAa;cAC5C,IAAI,CAACvD,IAAI,GAAGA,IAAI;cAChB,IAAI,IAAI,CAAC6C,WAAW,EAChB,IAAI,CAACA,WAAW,CAAC7C,IAAI,CAAC;YAAC;YAAA;cAAA,OAAAsD,QAAA,CAAAxB,IAAA;UAAA;QAAA,GAAAsB,OAAA;MAAA,CAC9B;MAAA,SAAAI,mBAAA;QAAA,OAAAL,mBAAA,CAAAzD,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAA6D,kBAAA;IAAA;IACD;AACJ;AACA;IAFI;EAAA;IAAAtC,GAAA;IAAAgC,KAAA;MAAA,IAAAO,OAAA,GAAA7D,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGA,SAAA4D,SAAA;QAAA,IAAAvD,QAAA;QAAA,OAAAN,mBAAA,GAAAS,IAAA,UAAAqD,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAnD,IAAA,GAAAmD,SAAA,CAAAlD,IAAA;YAAA;cAAA,IACS,IAAI,CAACV,IAAI,CAACuD,aAAa;gBAAAK,SAAA,CAAAlD,IAAA;gBAAA;cAAA;cAAA,MAClB,IAAIgB,KAAK,CAAC,4BAA4B,CAAC;YAAA;cAC3CvB,QAAQ,GAAG,IAAIU,QAAQ,CAAC,CAAC;cAC/BV,QAAQ,CAACW,MAAM,CAAC,OAAO,EAAE,IAAI,CAACd,IAAI,CAACuD,aAAa,CAAC;cACjD;cAAAK,SAAA,CAAAlD,IAAA;cAAA,OACMS,KAAK,IAAArD,MAAA,CAAI,IAAI,CAACkC,IAAI,CAACrB,OAAO,mBAAgB;gBAC5CyC,MAAM,EAAE,MAAM;gBACdC,WAAW,EAAE,aAAa;gBAC1BC,IAAI,EAAEnB;cACV,CAAC,CAAC;YAAA;cACF,IAAI,IAAI,CAAC0C,WAAW,EAAE;gBAClB,IAAI,CAACA,WAAW,CAAC,IAAI,CAAC;cAC1B;YAAC;YAAA;cAAA,OAAAe,SAAA,CAAA9B,IAAA;UAAA;QAAA,GAAA4B,QAAA;MAAA,CACJ;MAAA,SAAAG,OAAA;QAAA,OAAAJ,OAAA,CAAA/D,KAAA,OAAAC,SAAA;MAAA;MAAA,OAAAkE,MAAA;IAAA;EAAA;EAAA,OAAAnB,IAAA;AAAA;AAEL,OAAO,SAASoB,wBAAwBA,CAACnF,OAAO,EAAEsE,YAAY,EAAE;EAC5D,OAAO,IAAIP,IAAI,CAAC;IACZ/D,OAAO,EAAPA,OAAO;IACPC,QAAQ,EAAE,IAAI;IACdgD,OAAO,EAAExD,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI;IAC1BkF,aAAa,EAAE,EAAE;IACjBN,YAAY,EAAZA,YAAY;IACZ9E,UAAU,EAAE;EAChB,CAAC,CAAC;AACN;AACA,gBAAsB4F,OAAOA,CAAA;EAAA,OAAAC,QAAA,CAAAtE,KAAA,OAAAC,SAAA;AAAA;AAkD5B,SAAAqE,SAAA;EAAAA,QAAA,GAAApE,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAlDM,SAAAmE,SAAA;IAAA,IAAAC,OAAA;MAAAlE,IAAA;MAAArB,OAAA;MAAAC,QAAA;MAAAuF,iBAAA;MAAAC,KAAA;MAAAtF,KAAA;MAAAuF,MAAA,GAAA1E,SAAA;IAAA,OAAAE,mBAAA,GAAAS,IAAA,UAAAgE,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA9D,IAAA,GAAA8D,SAAA,CAAA7D,IAAA;QAAA;UAAuBwD,OAAO,GAAAG,MAAA,CAAAG,MAAA,QAAAH,MAAA,QAAAI,SAAA,GAAAJ,MAAA,MAAG,CAAC,CAAC;UAElC1F,OAAO,GAAGuF,OAAO,CAACvF,OAAO,EAC7B;UACA,IAAIA,OAAO,IAAIA,OAAO,CAACA,OAAO,CAAC6F,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;YAChD7F,OAAO,GAAGA,OAAO,CAACqE,MAAM,CAAC,CAAC,EAAErE,OAAO,CAAC6F,MAAM,GAAG,CAAC,CAAC;UACnD;UACM5F,QAAQ,GAAGsF,OAAO,CAACtF,QAAQ,KAAK6F,SAAS,GAAGP,OAAO,CAACtF,QAAQ,GAAGf,WAAW,CAAC,CAAC;UAC5EsG,iBAAiB,GAAGD,OAAO,CAACC,iBAAiB,KAAK,IAAI,EAC5D;UAAA,MACID,OAAO,CAACQ,QAAQ,IAAI/F,OAAO;YAAA4F,SAAA,CAAA7D,IAAA;YAAA;UAAA;UAAA6D,SAAA,CAAA7D,IAAA;UAAA,OACdqB,UAAU,CAACpD,OAAO,EAAEC,QAAQ,EAAEsF,OAAO,CAACQ,QAAQ,CAAC;QAAA;UAA5D1E,IAAI,GAAAuE,SAAA,CAAAhD,IAAA;UACJ,IAAI2C,OAAO,CAACvB,UAAU,EAAE;YACpBuB,OAAO,CAACvB,UAAU,CAAC3C,IAAI,CAAC;UAC5B;QAAC;UAAA,IAGAA,IAAI;YAAAuE,SAAA,CAAA7D,IAAA;YAAA;UAAA;UACC0D,KAAK,GAAG5G,UAAU,CAACO,QAAQ,CAACU,MAAM,CAACuE,MAAM,CAAC,CAAC,CAAC,CAAC,EACnD;UAAA,MACI,eAAe,IAAIoB,KAAK;YAAAG,SAAA,CAAA7D,IAAA;YAAA;UAAA;UACxB;UACM5B,KAAK,GAAGwD,gBAAgB,CAAC8B,KAAK,CAACtF,KAAK,CAAC;UAAA,MACvCqF,iBAAiB,KAChBrF,KAAK,CAACH,OAAO,KAAKA,OAAO,IAAIG,KAAK,CAACF,QAAQ,KAAKA,QAAQ,CAAC;YAAA2F,SAAA,CAAA7D,IAAA;YAAA;UAAA;UAAA,MACpD/C,yBAAyB;QAAA;UAAA4G,SAAA,CAAA7D,IAAA;UAAA,OAEtBqB,UAAU,CAACjD,KAAK,CAACH,OAAO,EAAEG,KAAK,CAACF,QAAQ,EAAEwF,KAAK,CAACpC,IAAI,CAAC;QAAA;UAAlEhC,IAAI,GAAAuE,SAAA,CAAAhD,IAAA;UACJ,IAAI2C,OAAO,CAACvB,UAAU,EAAE;YACpBuB,OAAO,CAACvB,UAAU,CAAC3C,IAAI,CAAC;UAC5B;QAAC;UAAA,MAIL,CAACA,IAAI,IAAIkE,OAAO,CAACS,UAAU;YAAAJ,SAAA,CAAA7D,IAAA;YAAA;UAAA;UAAA6D,SAAA,CAAA7D,IAAA;UAAA,OACdwD,OAAO,CAACS,UAAU,CAAC,CAAC;QAAA;UAAjC3E,IAAI,GAAAuE,SAAA,CAAAhD,IAAA;QAAA;UAAA,KAEJvB,IAAI;YAAAuE,SAAA,CAAA7D,IAAA;YAAA;UAAA;UAAA,OAAA6D,SAAA,CAAA1C,MAAA,WACG,IAAIa,IAAI,CAAC1C,IAAI,EAAEkE,OAAO,CAACvB,UAAU,CAAC;QAAA;UAAA,MAEzChE,OAAO,KAAK8F,SAAS;YAAAF,SAAA,CAAA7D,IAAA;YAAA;UAAA;UAAA,MACfjD,sBAAsB;QAAA;UAEhC;UACAwB,iBAAiB,CAACN,OAAO,EAAEC,QAAQ,EAAEsF,OAAO,CAACrF,WAAW,IAAIP,cAAc,CAAC,CAAC,EAAE4D,gBAAgB,CAAC;YAC3FvD,OAAO,EAAPA,OAAO;YACPC,QAAQ,EAARA;UACJ,CAAC,CAAC,CAAC;UACH;UAAA,OAAA2F,SAAA,CAAA1C,MAAA,WACO,IAAI+C,OAAO,CAAC,YAAM,CAAE,CAAC,CAAC;QAAA;QAAA;UAAA,OAAAL,SAAA,CAAAzC,IAAA;MAAA;IAAA,GAAAmC,QAAA;EAAA,CAChC;EAAA,OAAAD,QAAA,CAAAtE,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}