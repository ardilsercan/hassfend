{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\nimport './boot.js';\n\n// Microtask implemented using Mutation Observer\nvar microtaskCurrHandle = 0;\nvar microtaskLastHandle = 0;\nvar microtaskCallbacks = [];\nvar microtaskNodeContent = 0;\nvar microtaskScheduled = false;\nvar microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {\n  characterData: true\n});\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  var len = microtaskCallbacks.length;\n  var _loop = function _loop() {\n    var cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        });\n      }\n    }\n  };\n  for (var i = 0; i < len; i++) {\n    _loop();\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nvar timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after: function after(delay) {\n    return {\n      run: function run(fn) {\n        return window.setTimeout(fn, delay);\n      },\n      cancel: function cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\nexport { timeOut };\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nvar animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\nexport { animationFrame };\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nvar idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(fn) {\n    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);\n  }\n};\nexport { idlePeriod };\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nvar microTask = {\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run: function run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel: function cancel(handle) {\n    var idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n};\nexport { microTask };","map":{"version":3,"names":["microtaskCurrHandle","microtaskLastHandle","microtaskCallbacks","microtaskNodeContent","microtaskScheduled","microtaskNode","document","createTextNode","window","MutationObserver","microtaskFlush","observe","characterData","len","length","_loop","cb","i","e","setTimeout","splice","timeOut","after","delay","run","fn","cancel","handle","clearTimeout","animationFrame","requestAnimationFrame","cancelAnimationFrame","idlePeriod","requestIdleCallback","cancelIdleCallback","microTask","callback","textContent","push","idx","Error"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/utils/async.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * @fileoverview\n *\n * This module provides a number of strategies for enqueuing asynchronous\n * tasks. Each sub-module provides a standard `run(fn)` interface that returns a\n * handle, and a `cancel(handle)` interface for canceling async tasks before\n * they run.\n *\n * @summary Module that provides a number of strategies for enqueuing\n * asynchronous tasks.\n */\n\nimport './boot.js';\n\n// Microtask implemented using Mutation Observer\nlet microtaskCurrHandle = 0;\nlet microtaskLastHandle = 0;\nlet microtaskCallbacks = [];\nlet microtaskNodeContent = 0;\nlet microtaskScheduled = false;\nlet microtaskNode = document.createTextNode('');\nnew window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});\n\nfunction microtaskFlush() {\n  microtaskScheduled = false;\n  const len = microtaskCallbacks.length;\n  for (let i = 0; i < len; i++) {\n    let cb = microtaskCallbacks[i];\n    if (cb) {\n      try {\n        cb();\n      } catch (e) {\n        setTimeout(() => { throw e; });\n      }\n    }\n  }\n  microtaskCallbacks.splice(0, len);\n  microtaskLastHandle += len;\n}\n\n/**\n * Async interface wrapper around `setTimeout`.\n *\n * @namespace\n * @summary Async interface wrapper around `setTimeout`.\n */\nconst timeOut = {\n  /**\n   * Returns a sub-module with the async interface providing the provided\n   * delay.\n   *\n   * @memberof timeOut\n   * @param {number=} delay Time to wait before calling callbacks in ms\n   * @return {!AsyncInterface} An async timeout interface\n   */\n  after(delay) {\n    return {\n      run(fn) { return window.setTimeout(fn, delay); },\n      cancel(handle) {\n        window.clearTimeout(handle);\n      }\n    };\n  },\n  /**\n   * Enqueues a function called in the next task.\n   *\n   * @memberof timeOut\n   * @param {!Function} fn Callback to run\n   * @param {number=} delay Delay in milliseconds\n   * @return {number} Handle used for canceling task\n   */\n  run(fn, delay) {\n    return window.setTimeout(fn, delay);\n  },\n  /**\n   * Cancels a previously enqueued `timeOut` callback.\n   *\n   * @memberof timeOut\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.clearTimeout(handle);\n  }\n};\nexport {timeOut};\n\n/**\n * Async interface wrapper around `requestAnimationFrame`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestAnimationFrame`.\n */\nconst animationFrame = {\n  /**\n   * Enqueues a function called at `requestAnimationFrame` timing.\n   *\n   * @memberof animationFrame\n   * @param {function(number):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestAnimationFrame(fn);\n  },\n  /**\n   * Cancels a previously enqueued `animationFrame` callback.\n   *\n   * @memberof animationFrame\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelAnimationFrame(handle);\n  }\n};\nexport {animationFrame};\n\n/**\n * Async interface wrapper around `requestIdleCallback`.  Falls back to\n * `setTimeout` on browsers that do not support `requestIdleCallback`.\n *\n * @namespace\n * @summary Async interface wrapper around `requestIdleCallback`.\n */\nconst idlePeriod = {\n  /**\n   * Enqueues a function called at `requestIdleCallback` timing.\n   *\n   * @memberof idlePeriod\n   * @param {function(!IdleDeadline):void} fn Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(fn) {\n    return window.requestIdleCallback ?\n      window.requestIdleCallback(fn) :\n      window.setTimeout(fn, 16);\n  },\n  /**\n   * Cancels a previously enqueued `idlePeriod` callback.\n   *\n   * @memberof idlePeriod\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    window.cancelIdleCallback ?\n      window.cancelIdleCallback(handle) :\n      window.clearTimeout(handle);\n  }\n};\nexport {idlePeriod};\n\n/**\n * Async interface for enqueuing callbacks that run at microtask timing.\n *\n * Note that microtask timing is achieved via a single `MutationObserver`,\n * and thus callbacks enqueued with this API will all run in a single\n * batch, and not interleaved with other microtasks such as promises.\n * Promises are avoided as an implementation choice for the time being\n * due to Safari bugs that cause Promises to lack microtask guarantees.\n *\n * @namespace\n * @summary Async interface for enqueuing callbacks that run at microtask\n *   timing.\n */\nconst microTask = {\n\n  /**\n   * Enqueues a function called at microtask timing.\n   *\n   * @memberof microTask\n   * @param {!Function=} callback Callback to run\n   * @return {number} Handle used for canceling task\n   */\n  run(callback) {\n    if (!microtaskScheduled) {\n      microtaskScheduled = true;\n      microtaskNode.textContent = microtaskNodeContent++;\n    }\n    microtaskCallbacks.push(callback);\n    return microtaskCurrHandle++;\n  },\n\n  /**\n   * Cancels a previously enqueued `microTask` callback.\n   *\n   * @memberof microTask\n   * @param {number} handle Handle returned from `run` of callback to cancel\n   * @return {void}\n   */\n  cancel(handle) {\n    const idx = handle - microtaskLastHandle;\n    if (idx >= 0) {\n      if (!microtaskCallbacks[idx]) {\n        throw new Error('invalid async handle: ' + handle);\n      }\n      microtaskCallbacks[idx] = null;\n    }\n  }\n\n};\nexport {microTask};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}