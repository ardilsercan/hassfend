{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport { clamp } from \"../number/clamp\";\nexport var DEFAULT_MIN_KELVIN = 2700;\nexport var DEFAULT_MAX_KELVIN = 6500;\nexport var temperature2rgb = function temperature2rgb(temperature) {\n  var value = temperature / 100;\n  return [temperatureRed(value), temperatureGreen(value), temperatureBlue(value)];\n};\nvar temperatureRed = function temperatureRed(temperature) {\n  if (temperature <= 66) {\n    return 255;\n  }\n  var red = 329.698727446 * Math.pow(temperature - 60, -0.1332047592);\n  return clamp(red, 0, 255);\n};\nvar temperatureGreen = function temperatureGreen(temperature) {\n  var green;\n  if (temperature <= 66) {\n    green = 99.4708025861 * Math.log(temperature) - 161.1195681661;\n  } else {\n    green = 288.1221695283 * Math.pow(temperature - 60, -0.0755148492);\n  }\n  return clamp(green, 0, 255);\n};\nvar temperatureBlue = function temperatureBlue(temperature) {\n  if (temperature >= 66) {\n    return 255;\n  }\n  if (temperature <= 19) {\n    return 0;\n  }\n  var blue = 138.5177312231 * Math.log(temperature - 10) - 305.0447927307;\n  return clamp(blue, 0, 255);\n};\nvar matchMaxScale = function matchMaxScale(inputColors, outputColors) {\n  var maxIn = Math.max.apply(Math, _toConsumableArray(inputColors));\n  var maxOut = Math.max.apply(Math, _toConsumableArray(outputColors));\n  var factor;\n  if (maxOut === 0) {\n    factor = 0.0;\n  } else {\n    factor = maxIn / maxOut;\n  }\n  return outputColors.map(function (value) {\n    return Math.round(value * factor);\n  });\n};\nexport var mired2kelvin = function mired2kelvin(miredTemperature) {\n  return Math.floor(1000000 / miredTemperature);\n};\nexport var kelvin2mired = function kelvin2mired(kelvintTemperature) {\n  return Math.floor(1000000 / kelvintTemperature);\n};\nexport var rgbww2rgb = function rgbww2rgb(rgbww, minKelvin, maxKelvin) {\n  var _rgbww = _slicedToArray(rgbww, 5),\n    r = _rgbww[0],\n    g = _rgbww[1],\n    b = _rgbww[2],\n    cw = _rgbww[3],\n    ww = _rgbww[4];\n  // Calculate color temperature of the white channels\n  var maxMireds = kelvin2mired(minKelvin !== null && minKelvin !== void 0 ? minKelvin : DEFAULT_MIN_KELVIN);\n  var minMireds = kelvin2mired(maxKelvin !== null && maxKelvin !== void 0 ? maxKelvin : DEFAULT_MAX_KELVIN);\n  var miredRange = maxMireds - minMireds;\n  var ctRatio;\n  try {\n    ctRatio = ww / (cw + ww);\n  } catch (_error) {\n    ctRatio = 0.5;\n  }\n  var colorTempMired = minMireds + ctRatio * miredRange;\n  var colorTempKelvin = colorTempMired ? mired2kelvin(colorTempMired) : 0;\n  var _temperature2rgb = temperature2rgb(colorTempKelvin),\n    _temperature2rgb2 = _slicedToArray(_temperature2rgb, 3),\n    wR = _temperature2rgb2[0],\n    wG = _temperature2rgb2[1],\n    wB = _temperature2rgb2[2];\n  var whiteLevel = Math.max(cw, ww) / 255;\n\n  // Add the white channels to the rgb channels.\n  var rgb = [r + wR * whiteLevel, g + wG * whiteLevel, b + wB * whiteLevel];\n\n  // Match the output maximum value to the input. This ensures the\n  // output doesn't overflow.\n  return matchMaxScale([r, g, b, cw, ww], rgb);\n};\nexport var rgbw2rgb = function rgbw2rgb(rgbw) {\n  var _rgbw = _slicedToArray(rgbw, 4),\n    r = _rgbw[0],\n    g = _rgbw[1],\n    b = _rgbw[2],\n    w = _rgbw[3];\n  var rgb = [r + w, g + w, b + w];\n  return matchMaxScale([r, g, b, w], rgb);\n};","map":{"version":3,"names":["clamp","DEFAULT_MIN_KELVIN","DEFAULT_MAX_KELVIN","temperature2rgb","temperature","value","temperatureRed","temperatureGreen","temperatureBlue","red","Math","pow","green","log","blue","matchMaxScale","inputColors","outputColors","maxIn","max","apply","_toConsumableArray","maxOut","factor","map","round","mired2kelvin","miredTemperature","floor","kelvin2mired","kelvintTemperature","rgbww2rgb","rgbww","minKelvin","maxKelvin","_rgbww","_slicedToArray","r","g","b","cw","ww","maxMireds","minMireds","miredRange","ctRatio","_error","colorTempMired","colorTempKelvin","_temperature2rgb","_temperature2rgb2","wR","wG","wB","whiteLevel","rgb","rgbw2rgb","rgbw","_rgbw","w"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/color/convert-light-color.ts"],"sourcesContent":["import { clamp } from \"../number/clamp\";\n\nexport const DEFAULT_MIN_KELVIN = 2700;\nexport const DEFAULT_MAX_KELVIN = 6500;\n\nexport const temperature2rgb = (\n  temperature: number\n): [number, number, number] => {\n  const value = temperature / 100;\n  return [\n    temperatureRed(value),\n    temperatureGreen(value),\n    temperatureBlue(value),\n  ];\n};\n\nconst temperatureRed = (temperature: number): number => {\n  if (temperature <= 66) {\n    return 255;\n  }\n  const red = 329.698727446 * (temperature - 60) ** -0.1332047592;\n  return clamp(red, 0, 255);\n};\n\nconst temperatureGreen = (temperature: number): number => {\n  let green: number;\n  if (temperature <= 66) {\n    green = 99.4708025861 * Math.log(temperature) - 161.1195681661;\n  } else {\n    green = 288.1221695283 * (temperature - 60) ** -0.0755148492;\n  }\n  return clamp(green, 0, 255);\n};\n\nconst temperatureBlue = (temperature: number): number => {\n  if (temperature >= 66) {\n    return 255;\n  }\n  if (temperature <= 19) {\n    return 0;\n  }\n  const blue = 138.5177312231 * Math.log(temperature - 10) - 305.0447927307;\n  return clamp(blue, 0, 255);\n};\n\nconst matchMaxScale = (\n  inputColors: number[],\n  outputColors: number[]\n): number[] => {\n  const maxIn: number = Math.max(...inputColors);\n  const maxOut: number = Math.max(...outputColors);\n  let factor: number;\n  if (maxOut === 0) {\n    factor = 0.0;\n  } else {\n    factor = maxIn / maxOut;\n  }\n  return outputColors.map((value) => Math.round(value * factor));\n};\n\nexport const mired2kelvin = (miredTemperature: number) =>\n  Math.floor(1000000 / miredTemperature);\n\nexport const kelvin2mired = (kelvintTemperature: number) =>\n  Math.floor(1000000 / kelvintTemperature);\n\nexport const rgbww2rgb = (\n  rgbww: [number, number, number, number, number],\n  minKelvin?: number,\n  maxKelvin?: number\n): [number, number, number] => {\n  const [r, g, b, cw, ww] = rgbww;\n  // Calculate color temperature of the white channels\n  const maxMireds: number = kelvin2mired(minKelvin ?? DEFAULT_MIN_KELVIN);\n  const minMireds: number = kelvin2mired(maxKelvin ?? DEFAULT_MAX_KELVIN);\n  const miredRange: number = maxMireds - minMireds;\n  let ctRatio: number;\n  try {\n    ctRatio = ww / (cw + ww);\n  } catch (_error) {\n    ctRatio = 0.5;\n  }\n  const colorTempMired = minMireds + ctRatio * miredRange;\n  const colorTempKelvin = colorTempMired ? mired2kelvin(colorTempMired) : 0;\n  const [wR, wG, wB] = temperature2rgb(colorTempKelvin);\n  const whiteLevel = Math.max(cw, ww) / 255;\n\n  // Add the white channels to the rgb channels.\n  const rgb = [\n    r + wR * whiteLevel,\n    g + wG * whiteLevel,\n    b + wB * whiteLevel,\n  ] as [number, number, number];\n\n  // Match the output maximum value to the input. This ensures the\n  // output doesn't overflow.\n  return matchMaxScale([r, g, b, cw, ww], rgb) as [number, number, number];\n};\n\nexport const rgbw2rgb = (\n  rgbw: [number, number, number, number]\n): [number, number, number] => {\n  const [r, g, b, w] = rgbw;\n  const rgb = [r + w, g + w, b + w] as [number, number, number];\n  return matchMaxScale([r, g, b, w], rgb) as [number, number, number];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}