{"ast":null,"code":"import \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.string.iterator.js\";\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport './boot.js';\nimport { wrap } from './wrap.js';\nvar ShadyDOM = window.ShadyDOM;\nvar ShadyCSS = window.ShadyCSS;\n\n/**\n * Return true if node scope is correct.\n *\n * @param {!Element} node Node to check scope\n * @param {!Node} scope Scope reference\n * @return {boolean} True if node is in scope\n */\nfunction sameScope(node, scope) {\n  return wrap(node).getRootNode() === scope;\n}\n\n/**\n * Ensure that elements in a ShadowDOM container are scoped correctly.\n * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.\n * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.\n *\n * @param  {!Element} container Container element to scope\n * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n */\nexport function scopeSubtree(container) {\n  var shouldObserve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  // If using native ShadowDOM, abort\n  if (!ShadyDOM || !ShadyCSS) {\n    return null;\n  }\n  // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself\n  if (!ShadyDOM['handlesDynamicScoping']) {\n    return null;\n  }\n  var ScopingShim = ShadyCSS['ScopingShim'];\n  // if ScopingShim is not available, abort\n  if (!ScopingShim) {\n    return null;\n  }\n  // capture correct scope for container\n  var containerScope = ScopingShim['scopeForNode'](container);\n  var root = wrap(container).getRootNode();\n  var scopify = function scopify(node) {\n    if (!sameScope(node, root)) {\n      return;\n    }\n    // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1\n    var elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));\n    elements.push(node);\n    for (var i = 0; i < elements.length; i++) {\n      var el = elements[i];\n      if (!sameScope(el, root)) {\n        continue;\n      }\n      var currentScope = ScopingShim['currentScopeForNode'](el);\n      if (currentScope !== containerScope) {\n        if (currentScope !== '') {\n          ScopingShim['unscopeNode'](el, currentScope);\n        }\n        ScopingShim['scopeNode'](el, containerScope);\n      }\n    }\n  };\n\n  // scope everything in container\n  scopify(container);\n  if (shouldObserve) {\n    var mo = new MutationObserver(function (mxns) {\n      for (var i = 0; i < mxns.length; i++) {\n        var mxn = mxns[i];\n        for (var j = 0; j < mxn.addedNodes.length; j++) {\n          var addedNode = mxn.addedNodes[j];\n          if (addedNode.nodeType === Node.ELEMENT_NODE) {\n            scopify(addedNode);\n          }\n        }\n      }\n    });\n    mo.observe(container, {\n      childList: true,\n      subtree: true\n    });\n    return mo;\n  } else {\n    return null;\n  }\n}","map":{"version":3,"names":["wrap","ShadyDOM","window","ShadyCSS","sameScope","node","scope","getRootNode","scopeSubtree","container","shouldObserve","arguments","length","undefined","ScopingShim","containerScope","root","scopify","elements","Array","from","call","push","i","el","currentScope","mo","MutationObserver","mxns","mxn","j","addedNodes","addedNode","nodeType","Node","ELEMENT_NODE","observe","childList","subtree"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/utils/scope-subtree.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nimport './boot.js';\nimport {wrap} from './wrap.js';\n\nconst ShadyDOM = window.ShadyDOM;\nconst ShadyCSS = window.ShadyCSS;\n\n/**\n * Return true if node scope is correct.\n *\n * @param {!Element} node Node to check scope\n * @param {!Node} scope Scope reference\n * @return {boolean} True if node is in scope\n */\nfunction sameScope(node, scope) {\n  return wrap(node).getRootNode() === scope;\n}\n\n/**\n * Ensure that elements in a ShadowDOM container are scoped correctly.\n * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.\n * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.\n *\n * @param  {!Element} container Container element to scope\n * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n */\nexport function scopeSubtree(container, shouldObserve = false) {\n  // If using native ShadowDOM, abort\n  if (!ShadyDOM || !ShadyCSS) {\n    return null;\n  }\n  // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself\n  if (!ShadyDOM['handlesDynamicScoping']) {\n    return null;\n  }\n  const ScopingShim = ShadyCSS['ScopingShim'];\n  // if ScopingShim is not available, abort\n  if (!ScopingShim) {\n    return null;\n  }\n  // capture correct scope for container\n  const containerScope = ScopingShim['scopeForNode'](container);\n  const root = wrap(container).getRootNode();\n\n  const scopify = (node) => {\n    if (!sameScope(node, root)) {\n      return;\n    }\n    // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1\n    const elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));\n    elements.push(node);\n    for (let i = 0; i < elements.length; i++) {\n      const el = elements[i];\n      if (!sameScope(el, root)) {\n        continue;\n      }\n      const currentScope = ScopingShim['currentScopeForNode'](el);\n      if (currentScope !== containerScope) {\n        if (currentScope !== '') {\n          ScopingShim['unscopeNode'](el, currentScope);\n        }\n        ScopingShim['scopeNode'](el, containerScope);\n      }\n    }\n  };\n\n  // scope everything in container\n  scopify(container);\n\n  if (shouldObserve) {\n    const mo = new MutationObserver((mxns) => {\n      for (let i = 0; i < mxns.length; i++) {\n        const mxn = mxns[i];\n        for (let j = 0; j < mxn.addedNodes.length; j++) {\n          const addedNode = mxn.addedNodes[j];\n          if (addedNode.nodeType === Node.ELEMENT_NODE) {\n            scopify(addedNode);\n          }\n        }\n      }\n    });\n    mo.observe(container, {childList: true, subtree: true});\n    return mo;\n  } else {\n    return null;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}