{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, isServer, LitElement } from 'lit';\nimport { queryAssignedElements } from 'lit/decorators.js';\nimport { Chip } from './chip.js';\n/**\n * A chip set component.\n */\nexport class ChipSet extends LitElement {\n  get chips() {\n    return this.childElements.filter(child => child instanceof Chip);\n  }\n  constructor() {\n    super();\n    this.internals =\n    // Cast needed for closure\n    this.attachInternals();\n    if (!isServer) {\n      this.addEventListener('focusin', this.updateTabIndices.bind(this));\n      this.addEventListener('update-focus', this.updateTabIndices.bind(this));\n      this.addEventListener('keydown', this.handleKeyDown.bind(this));\n      this.internals.role = 'toolbar';\n    }\n  }\n  render() {\n    return html`<slot @slotchange=${this.updateTabIndices}></slot>`;\n  }\n  handleKeyDown(event) {\n    const isLeft = event.key === 'ArrowLeft';\n    const isRight = event.key === 'ArrowRight';\n    const isHome = event.key === 'Home';\n    const isEnd = event.key === 'End';\n    // Ignore non-navigation keys\n    if (!isLeft && !isRight && !isHome && !isEnd) {\n      return;\n    }\n    const {\n      chips\n    } = this;\n    // Don't try to select another chip if there aren't any.\n    if (chips.length < 2) {\n      return;\n    }\n    // Prevent default interactions, such as scrolling.\n    event.preventDefault();\n    if (isHome || isEnd) {\n      const index = isHome ? 0 : chips.length - 1;\n      chips[index].focus({\n        trailing: isEnd\n      });\n      this.updateTabIndices();\n      return;\n    }\n    // Check if moving forwards or backwards\n    const isRtl = getComputedStyle(this).direction === 'rtl';\n    const forwards = isRtl ? isLeft : isRight;\n    const focusedChip = chips.find(chip => chip.matches(':focus-within'));\n    if (!focusedChip) {\n      // If there is not already a chip focused, select the first or last chip\n      // based on the direction we're traveling.\n      const nextChip = forwards ? chips[0] : chips[chips.length - 1];\n      nextChip.focus({\n        trailing: !forwards\n      });\n      this.updateTabIndices();\n      return;\n    }\n    const currentIndex = chips.indexOf(focusedChip);\n    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;\n    // Search for the next sibling that is not disabled to select.\n    // If we return to the host index, there is nothing to select.\n    while (nextIndex !== currentIndex) {\n      if (nextIndex >= chips.length) {\n        // Return to start if moving past the last item.\n        nextIndex = 0;\n      } else if (nextIndex < 0) {\n        // Go to end if moving before the first item.\n        nextIndex = chips.length - 1;\n      }\n      // Check if the next sibling is disabled. If so,\n      // move the index and continue searching.\n      //\n      // Some toolbar items may be focusable when disabled for increased\n      // visibility.\n      const nextChip = chips[nextIndex];\n      if (nextChip.disabled && !nextChip.alwaysFocusable) {\n        if (forwards) {\n          nextIndex++;\n        } else {\n          nextIndex--;\n        }\n        continue;\n      }\n      nextChip.focus({\n        trailing: !forwards\n      });\n      this.updateTabIndices();\n      break;\n    }\n  }\n  updateTabIndices() {\n    // The chip that should be focusable is either the chip that currently has\n    // focus or the first chip that can be focused.\n    const {\n      chips\n    } = this;\n    let chipToFocus;\n    for (const chip of chips) {\n      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;\n      const chipIsFocused = chip.matches(':focus-within');\n      if (chipIsFocused && isChipFocusable) {\n        // Found the first chip that is actively focused. This overrides the\n        // first focusable chip found.\n        chipToFocus = chip;\n        continue;\n      }\n      if (isChipFocusable && !chipToFocus) {\n        chipToFocus = chip;\n      }\n      // Disable non-focused chips. If we disable all of them, we'll grant focus\n      // to the first focusable child that was found.\n      chip.tabIndex = -1;\n    }\n    if (chipToFocus) {\n      chipToFocus.tabIndex = 0;\n    }\n  }\n}\n__decorate([queryAssignedElements()], ChipSet.prototype, \"childElements\", void 0);","map":{"version":3,"names":["html","isServer","LitElement","queryAssignedElements","Chip","ChipSet","chips","childElements","filter","child","constructor","internals","attachInternals","addEventListener","updateTabIndices","bind","handleKeyDown","role","render","event","isLeft","key","isRight","isHome","isEnd","length","preventDefault","index","focus","trailing","isRtl","getComputedStyle","direction","forwards","focusedChip","find","chip","matches","nextChip","currentIndex","indexOf","nextIndex","disabled","alwaysFocusable","chipToFocus","isChipFocusable","chipIsFocused","tabIndex","__decorate"],"sources":["chip-set.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, isServer, LitElement} from 'lit';\nimport {queryAssignedElements} from 'lit/decorators.js';\n\nimport {Chip} from './chip.js';\n\n/**\n * A chip set component.\n */\nexport class ChipSet extends LitElement {\n  get chips() {\n    return this.childElements.filter(\n      (child): child is Chip => child instanceof Chip,\n    );\n  }\n\n  @queryAssignedElements() private readonly childElements!: HTMLElement[];\n  private readonly internals =\n    // Cast needed for closure\n    (this as HTMLElement).attachInternals();\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('focusin', this.updateTabIndices.bind(this));\n      this.addEventListener('update-focus', this.updateTabIndices.bind(this));\n      this.addEventListener('keydown', this.handleKeyDown.bind(this));\n      this.internals.role = 'toolbar';\n    }\n  }\n\n  protected override render() {\n    return html`<slot @slotchange=${this.updateTabIndices}></slot>`;\n  }\n\n  private handleKeyDown(event: KeyboardEvent) {\n    const isLeft = event.key === 'ArrowLeft';\n    const isRight = event.key === 'ArrowRight';\n    const isHome = event.key === 'Home';\n    const isEnd = event.key === 'End';\n    // Ignore non-navigation keys\n    if (!isLeft && !isRight && !isHome && !isEnd) {\n      return;\n    }\n\n    const {chips} = this as {chips: MaybeMultiActionChip[]};\n    // Don't try to select another chip if there aren't any.\n    if (chips.length < 2) {\n      return;\n    }\n\n    // Prevent default interactions, such as scrolling.\n    event.preventDefault();\n\n    if (isHome || isEnd) {\n      const index = isHome ? 0 : chips.length - 1;\n      chips[index].focus({trailing: isEnd});\n      this.updateTabIndices();\n      return;\n    }\n\n    // Check if moving forwards or backwards\n    const isRtl = getComputedStyle(this).direction === 'rtl';\n    const forwards = isRtl ? isLeft : isRight;\n    const focusedChip = chips.find((chip) => chip.matches(':focus-within'));\n    if (!focusedChip) {\n      // If there is not already a chip focused, select the first or last chip\n      // based on the direction we're traveling.\n      const nextChip = forwards ? chips[0] : chips[chips.length - 1];\n      nextChip.focus({trailing: !forwards});\n      this.updateTabIndices();\n      return;\n    }\n\n    const currentIndex = chips.indexOf(focusedChip);\n    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;\n    // Search for the next sibling that is not disabled to select.\n    // If we return to the host index, there is nothing to select.\n    while (nextIndex !== currentIndex) {\n      if (nextIndex >= chips.length) {\n        // Return to start if moving past the last item.\n        nextIndex = 0;\n      } else if (nextIndex < 0) {\n        // Go to end if moving before the first item.\n        nextIndex = chips.length - 1;\n      }\n\n      // Check if the next sibling is disabled. If so,\n      // move the index and continue searching.\n      //\n      // Some toolbar items may be focusable when disabled for increased\n      // visibility.\n      const nextChip = chips[nextIndex];\n      if (nextChip.disabled && !nextChip.alwaysFocusable) {\n        if (forwards) {\n          nextIndex++;\n        } else {\n          nextIndex--;\n        }\n\n        continue;\n      }\n\n      nextChip.focus({trailing: !forwards});\n      this.updateTabIndices();\n      break;\n    }\n  }\n\n  private updateTabIndices() {\n    // The chip that should be focusable is either the chip that currently has\n    // focus or the first chip that can be focused.\n    const {chips} = this;\n    let chipToFocus: Chip | undefined;\n    for (const chip of chips) {\n      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;\n      const chipIsFocused = chip.matches(':focus-within');\n      if (chipIsFocused && isChipFocusable) {\n        // Found the first chip that is actively focused. This overrides the\n        // first focusable chip found.\n        chipToFocus = chip;\n        continue;\n      }\n\n      if (isChipFocusable && !chipToFocus) {\n        chipToFocus = chip;\n      }\n\n      // Disable non-focused chips. If we disable all of them, we'll grant focus\n      // to the first focusable child that was found.\n      chip.tabIndex = -1;\n    }\n\n    if (chipToFocus) {\n      chipToFocus.tabIndex = 0;\n    }\n  }\n}\n\ninterface MaybeMultiActionChip extends Chip {\n  focus(options?: FocusOptions & {trailing?: boolean}): void;\n}\n"],"mappings":"AAAA;;;;;;AAMA,SAAQA,IAAI,EAAEC,QAAQ,EAAEC,UAAU,QAAO,KAAK;AAC9C,SAAQC,qBAAqB,QAAO,mBAAmB;AAEvD,SAAQC,IAAI,QAAO,WAAW;AAE9B;;;AAGA,OAAM,MAAOC,OAAQ,SAAQH,UAAU;EACrC,IAAII,KAAKA,CAAA;IACP,OAAO,IAAI,CAACC,aAAa,CAACC,MAAM,CAC7BC,KAAK,IAAoBA,KAAK,YAAYL,IAAI,CAChD;EACH;EAOAM,YAAA;IACE,KAAK,EAAE;IALQ,KAAAC,SAAS;IACxB;IACC,IAAoB,CAACC,eAAe,EAAE;IAIvC,IAAI,CAACX,QAAQ,EAAE;MACb,IAAI,CAACY,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;MAClE,IAAI,CAACF,gBAAgB,CAAC,cAAc,EAAE,IAAI,CAACC,gBAAgB,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;MACvE,IAAI,CAACF,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACG,aAAa,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC;MAC/D,IAAI,CAACJ,SAAS,CAACM,IAAI,GAAG,SAAS;;EAEnC;EAEmBC,MAAMA,CAAA;IACvB,OAAOlB,IAAI,qBAAqB,IAAI,CAACc,gBAAgB,UAAU;EACjE;EAEQE,aAAaA,CAACG,KAAoB;IACxC,MAAMC,MAAM,GAAGD,KAAK,CAACE,GAAG,KAAK,WAAW;IACxC,MAAMC,OAAO,GAAGH,KAAK,CAACE,GAAG,KAAK,YAAY;IAC1C,MAAME,MAAM,GAAGJ,KAAK,CAACE,GAAG,KAAK,MAAM;IACnC,MAAMG,KAAK,GAAGL,KAAK,CAACE,GAAG,KAAK,KAAK;IACjC;IACA,IAAI,CAACD,MAAM,IAAI,CAACE,OAAO,IAAI,CAACC,MAAM,IAAI,CAACC,KAAK,EAAE;MAC5C;;IAGF,MAAM;MAAClB;IAAK,CAAC,GAAG,IAAuC;IACvD;IACA,IAAIA,KAAK,CAACmB,MAAM,GAAG,CAAC,EAAE;MACpB;;IAGF;IACAN,KAAK,CAACO,cAAc,EAAE;IAEtB,IAAIH,MAAM,IAAIC,KAAK,EAAE;MACnB,MAAMG,KAAK,GAAGJ,MAAM,GAAG,CAAC,GAAGjB,KAAK,CAACmB,MAAM,GAAG,CAAC;MAC3CnB,KAAK,CAACqB,KAAK,CAAC,CAACC,KAAK,CAAC;QAACC,QAAQ,EAAEL;MAAK,CAAC,CAAC;MACrC,IAAI,CAACV,gBAAgB,EAAE;MACvB;;IAGF;IACA,MAAMgB,KAAK,GAAGC,gBAAgB,CAAC,IAAI,CAAC,CAACC,SAAS,KAAK,KAAK;IACxD,MAAMC,QAAQ,GAAGH,KAAK,GAAGV,MAAM,GAAGE,OAAO;IACzC,MAAMY,WAAW,GAAG5B,KAAK,CAAC6B,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAACC,OAAO,CAAC,eAAe,CAAC,CAAC;IACvE,IAAI,CAACH,WAAW,EAAE;MAChB;MACA;MACA,MAAMI,QAAQ,GAAGL,QAAQ,GAAG3B,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAACA,KAAK,CAACmB,MAAM,GAAG,CAAC,CAAC;MAC9Da,QAAQ,CAACV,KAAK,CAAC;QAACC,QAAQ,EAAE,CAACI;MAAQ,CAAC,CAAC;MACrC,IAAI,CAACnB,gBAAgB,EAAE;MACvB;;IAGF,MAAMyB,YAAY,GAAGjC,KAAK,CAACkC,OAAO,CAACN,WAAW,CAAC;IAC/C,IAAIO,SAAS,GAAGR,QAAQ,GAAGM,YAAY,GAAG,CAAC,GAAGA,YAAY,GAAG,CAAC;IAC9D;IACA;IACA,OAAOE,SAAS,KAAKF,YAAY,EAAE;MACjC,IAAIE,SAAS,IAAInC,KAAK,CAACmB,MAAM,EAAE;QAC7B;QACAgB,SAAS,GAAG,CAAC;OACd,MAAM,IAAIA,SAAS,GAAG,CAAC,EAAE;QACxB;QACAA,SAAS,GAAGnC,KAAK,CAACmB,MAAM,GAAG,CAAC;;MAG9B;MACA;MACA;MACA;MACA;MACA,MAAMa,QAAQ,GAAGhC,KAAK,CAACmC,SAAS,CAAC;MACjC,IAAIH,QAAQ,CAACI,QAAQ,IAAI,CAACJ,QAAQ,CAACK,eAAe,EAAE;QAClD,IAAIV,QAAQ,EAAE;UACZQ,SAAS,EAAE;SACZ,MAAM;UACLA,SAAS,EAAE;;QAGb;;MAGFH,QAAQ,CAACV,KAAK,CAAC;QAACC,QAAQ,EAAE,CAACI;MAAQ,CAAC,CAAC;MACrC,IAAI,CAACnB,gBAAgB,EAAE;MACvB;;EAEJ;EAEQA,gBAAgBA,CAAA;IACtB;IACA;IACA,MAAM;MAACR;IAAK,CAAC,GAAG,IAAI;IACpB,IAAIsC,WAA6B;IACjC,KAAK,MAAMR,IAAI,IAAI9B,KAAK,EAAE;MACxB,MAAMuC,eAAe,GAAGT,IAAI,CAACO,eAAe,IAAI,CAACP,IAAI,CAACM,QAAQ;MAC9D,MAAMI,aAAa,GAAGV,IAAI,CAACC,OAAO,CAAC,eAAe,CAAC;MACnD,IAAIS,aAAa,IAAID,eAAe,EAAE;QACpC;QACA;QACAD,WAAW,GAAGR,IAAI;QAClB;;MAGF,IAAIS,eAAe,IAAI,CAACD,WAAW,EAAE;QACnCA,WAAW,GAAGR,IAAI;;MAGpB;MACA;MACAA,IAAI,CAACW,QAAQ,GAAG,CAAC,CAAC;;IAGpB,IAAIH,WAAW,EAAE;MACfA,WAAW,CAACG,QAAQ,GAAG,CAAC;;EAE5B;;AAxH0CC,UAAA,EAAzC7C,qBAAqB,EAAE,C,6CAAgD"},"metadata":{},"sourceType":"module","externalDependencies":[]}