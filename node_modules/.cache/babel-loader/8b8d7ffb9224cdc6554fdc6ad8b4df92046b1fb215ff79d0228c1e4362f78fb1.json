{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport var PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6\n};\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport var directive = function directive(c) {\n  return function () {\n    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n      values[_key] = arguments[_key];\n    }\n    return _defineProperty(_defineProperty({}, '_$litDirective$', c), \"values\", values);\n  };\n};\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport var Directive = /*#__PURE__*/function () {\n  function Directive(_partInfo) {\n    _classCallCheck(this, Directive);\n  }\n  // See comment in Disconnectable interface for why this is a getter\n  _createClass(Directive, [{\n    key: \"_$isConnected\",\n    get: function get() {\n      return this._$parent._$isConnected;\n    }\n    /** @internal */\n  }, {\n    key: \"_$initialize\",\n    value: function _$initialize(part, parent, attributeIndex) {\n      this.__part = part;\n      this._$parent = parent;\n      this.__attributeIndex = attributeIndex;\n    }\n    /** @internal */\n  }, {\n    key: \"_$resolve\",\n    value: function _$resolve(part, props) {\n      return this.update(part, props);\n    }\n  }, {\n    key: \"update\",\n    value: function update(_part, props) {\n      return this.render.apply(this, _toConsumableArray(props));\n    }\n  }]);\n  return Directive;\n}();","map":{"version":3,"names":["PartType","ATTRIBUTE","CHILD","PROPERTY","BOOLEAN_ATTRIBUTE","EVENT","ELEMENT","directive","c","_len","arguments","length","values","Array","_key","_defineProperty","Directive","_partInfo","_classCallCheck","_createClass","key","get","_$parent","_$isConnected","value","_$initialize","part","parent","attributeIndex","__part","__attributeIndex","_$resolve","props","update","_part","render","apply","_toConsumableArray"],"sources":["../src/directive.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = (typeof PartType)[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n"],"mappings":";;;;AAAA;;;;;AAyCA,OAAO,IAAMA,QAAQ,GAAG;EACtBC,SAAS,EAAE,CAAC;EACZC,KAAK,EAAE,CAAC;EACRC,QAAQ,EAAE,CAAC;EACXC,iBAAiB,EAAE,CAAC;EACpBC,KAAK,EAAE,CAAC;EACRC,OAAO,EAAE;CACD;AA+BV;;;;AAIA,OAAO,IAAMC,SAAS,GACpB,SADWA,SAASA,CACOC,CAAI;EAAA,OAC/B;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAIC,MAA4C,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAA5CF,MAA4C,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IAAA,OAAAC,eAAA,CAAAA,eAAA,KAE7C,iBAAiB,EAAGP,CAAC,aACtBI,MAAM;EAAA,CACN;AAAA;AAEJ;;;;;AAKA,WAAsBI,SAAS;EAkB7B,SAAAA,UAAYC,SAAmB;IAAAC,eAAA,OAAAF,SAAA;EAAG;EAElC;EAAAG,YAAA,CAAAH,SAAA;IAAAI,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAAiB;MACf,OAAO,IAAI,CAACC,QAAQ,CAACC,aAAa;IACpC;IAEA;EAAA;IAAAH,GAAA;IAAAI,KAAA,EACA,SAAAC,aACEC,IAAU,EACVC,MAAsB,EACtBC,cAAkC;MAElC,IAAI,CAACC,MAAM,GAAGH,IAAI;MAClB,IAAI,CAACJ,QAAQ,GAAGK,MAAM;MACtB,IAAI,CAACG,gBAAgB,GAAGF,cAAc;IACxC;IACA;EAAA;IAAAR,GAAA;IAAAI,KAAA,EACA,SAAAO,UAAUL,IAAU,EAAEM,KAAqB;MACzC,OAAO,IAAI,CAACC,MAAM,CAACP,IAAI,EAAEM,KAAK,CAAC;IACjC;EAAC;IAAAZ,GAAA;IAAAI,KAAA,EAID,SAAAS,OAAOC,KAAW,EAAEF,KAAqB;MACvC,OAAO,IAAI,CAACG,MAAM,CAAAC,KAAA,CAAX,IAAI,EAAAC,kBAAA,CAAWL,KAAK,EAAC;IAC9B;EAAC;EAAA,OAAAhB,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}