{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { STATES_OFF } from \"../../../common/const\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-camera-stream\";\nimport \"../../../components/ha-circular-progress\";\nimport { fetchThumbnailUrlWithCache } from \"../../../data/camera\";\nimport { UNAVAILABLE } from \"../../../data/entity\";\nimport { computeImageUrl } from \"../../../data/image\";\nconst UPDATE_INTERVAL = 10000;\nconst DEFAULT_FILTER = \"grayscale(100%)\";\nconst MAX_IMAGE_WIDTH = 640;\nconst ASPECT_RATIO_DEFAULT = 9 / 16;\nvar LoadState = /*#__PURE__*/function (LoadState) {\n  LoadState[LoadState[\"Loading\"] = 1] = \"Loading\";\n  LoadState[LoadState[\"Loaded\"] = 2] = \"Loaded\";\n  LoadState[LoadState[\"Error\"] = 3] = \"Error\";\n  return LoadState;\n}(LoadState || {});\nexport let HuiImage = _decorate([customElement(\"hui-image\")], function (_initialize, _LitElement) {\n  class HuiImage extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HuiImage,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"entity\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"image\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"stateImage\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"cameraImage\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"cameraView\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"aspectRatio\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"filter\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"stateFilter\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"darkModeImage\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"darkModeFilter\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"fitMode\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_imageVisible\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_loadState\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_cameraImageSrc\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_loadedImageSrc\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_lastImageHeight\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_intersectionObserver\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_cameraUpdater\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_ratio\",\n      value() {\n        return null;\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HuiImage.prototype), \"connectedCallback\", this).call(this);\n        if (this._loadState === undefined) {\n          this._loadState = LoadState.Loading;\n        }\n        if (this.cameraImage && this.cameraView !== \"live\") {\n          this._startIntersectionObserverOrUpdates();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HuiImage.prototype), \"disconnectedCallback\", this).call(this);\n        this._stopUpdateCameraInterval();\n        this._stopIntersectionObserver();\n        this._imageVisible = undefined;\n      }\n    }, {\n      kind: \"method\",\n      key: \"handleIntersectionCallback\",\n      value: function handleIntersectionCallback(entries) {\n        this._imageVisible = entries[0].isIntersecting;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (changedProps.has(\"hass\")) {\n          const oldHass = changedProps.get(\"hass\");\n          if (this._shouldStartCameraUpdates(oldHass)) {\n            this._startIntersectionObserverOrUpdates();\n          } else if (!this.hass.connected) {\n            this._stopUpdateCameraInterval();\n            this._stopIntersectionObserver();\n            this._loadState = LoadState.Loading;\n            this._cameraImageSrc = undefined;\n            this._loadedImageSrc = undefined;\n          }\n        }\n        if (changedProps.has(\"_imageVisible\")) {\n          if (this._imageVisible) {\n            if (this._shouldStartCameraUpdates()) {\n              this._startUpdateCameraInterval();\n            }\n          } else {\n            this._stopUpdateCameraInterval();\n          }\n        }\n        if (changedProps.has(\"aspectRatio\")) {\n          this._ratio = this.aspectRatio ? parseAspectRatio(this.aspectRatio) : null;\n        }\n        if (this._loadState === LoadState.Loading && !this.cameraImage) {\n          this._loadState = LoadState.Loaded;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!this.hass) {\n          return nothing;\n        }\n        const useRatio = Boolean(this._ratio && this._ratio.w > 0 && this._ratio.h > 0);\n        const stateObj = this.entity ? this.hass.states[this.entity] : undefined;\n        const entityState = stateObj ? stateObj.state : UNAVAILABLE;\n\n        // Figure out image source to use\n        let imageSrc;\n        let cameraObj;\n        // Track if we are we using a fallback image, used for filter.\n        let imageFallback = !this.stateImage;\n        if (this.cameraImage) {\n          if (this.cameraView === \"live\") {\n            cameraObj = this.hass.states[this.cameraImage];\n          } else {\n            imageSrc = this._cameraImageSrc;\n          }\n        } else if (this.stateImage) {\n          const stateImage = this.stateImage[entityState];\n          if (stateImage) {\n            imageSrc = stateImage;\n          } else {\n            imageSrc = this.image;\n            imageFallback = true;\n          }\n        } else if (this.darkModeImage && this.hass.themes.darkMode) {\n          imageSrc = this.darkModeImage;\n        } else if (stateObj && computeDomain(stateObj.entity_id) === \"image\") {\n          imageSrc = computeImageUrl(stateObj);\n        } else {\n          imageSrc = this.image;\n        }\n        if (imageSrc) {\n          imageSrc = this.hass.hassUrl(imageSrc);\n        }\n\n        // Figure out filter to use\n        let filter = this.filter || \"\";\n        if (this.hass.themes.darkMode && this.darkModeFilter) {\n          filter += this.darkModeFilter;\n        }\n        if (this.stateFilter && this.stateFilter[entityState]) {\n          filter += this.stateFilter[entityState];\n        }\n        if (!filter && this.entity) {\n          const isOff = !stateObj || STATES_OFF.includes(entityState);\n          filter = isOff && imageFallback ? DEFAULT_FILTER : \"\";\n        }\n        return html`\n      <div\n        style=${styleMap({\n          paddingBottom: useRatio ? `${(100 * this._ratio.h / this._ratio.w).toFixed(2)}%` : this._lastImageHeight === undefined ? \"56.25%\" : undefined,\n          backgroundImage: useRatio && this._loadedImageSrc ? `url(\"${this._loadedImageSrc}\")` : undefined,\n          filter: this._loadState === LoadState.Loaded || this.cameraView === \"live\" ? filter : undefined\n        })}\n        class=\"container ${classMap({\n          ratio: useRatio || this._lastImageHeight === undefined,\n          contain: this.fitMode === \"contain\",\n          fill: this.fitMode === \"fill\"\n        })}\"\n      >\n        ${this.cameraImage && this.cameraView === \"live\" ? html`\n              <ha-camera-stream\n                muted\n                .hass=${this.hass}\n                .stateObj=${cameraObj}\n                @load=${this._onVideoLoad}\n              ></ha-camera-stream>\n            ` : imageSrc === undefined ? nothing : html`\n                <img\n                  id=\"image\"\n                  src=${imageSrc}\n                  @error=${this._onImageError}\n                  @load=${this._onImageLoad}\n                  style=${styleMap({\n          display: useRatio || this._loadState === LoadState.Loaded ? \"block\" : \"none\"\n        })}\n                />\n              `}\n        ${this._loadState === LoadState.Error ? html`<div\n              id=\"brokenImage\"\n              style=${styleMap({\n          height: !useRatio ? `${this._lastImageHeight}px` || \"100%\" : undefined\n        })}\n            ></div>` : this.cameraView !== \"live\" && (imageSrc === undefined || this._loadState === LoadState.Loading) ? html`<div\n                class=\"progress-container\"\n                style=${styleMap({\n          height: !useRatio ? `${this._lastImageHeight}px` || \"100%\" : undefined\n        })}\n              >\n                <ha-circular-progress\n                  class=\"render-spinner\"\n                  indeterminate\n                  size=\"small\"\n                ></ha-circular-progress>\n              </div>` : \"\"}\n      </div>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_shouldStartCameraUpdates\",\n      value: function _shouldStartCameraUpdates(oldHass) {\n        return !!((!oldHass || oldHass.connected !== this.hass.connected) && this.hass.connected && this.cameraView !== \"live\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"_startIntersectionObserverOrUpdates\",\n      value: function _startIntersectionObserverOrUpdates() {\n        if (\"IntersectionObserver\" in window) {\n          if (!this._intersectionObserver) {\n            this._intersectionObserver = new IntersectionObserver(this.handleIntersectionCallback.bind(this));\n          }\n          this._intersectionObserver.observe(this);\n        } else {\n          // No support for IntersectionObserver\n          // assume all images are visible\n          this._imageVisible = true;\n          this._startUpdateCameraInterval();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_stopIntersectionObserver\",\n      value: function _stopIntersectionObserver() {\n        if (this._intersectionObserver) {\n          this._intersectionObserver.disconnect();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_startUpdateCameraInterval\",\n      value: function _startUpdateCameraInterval() {\n        this._stopUpdateCameraInterval();\n        this._updateCameraImageSrc();\n        if (this.cameraImage && this.isConnected) {\n          this._cameraUpdater = window.setInterval(() => this._updateCameraImageSrcAtInterval(), UPDATE_INTERVAL);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_stopUpdateCameraInterval\",\n      value: function _stopUpdateCameraInterval() {\n        if (this._cameraUpdater) {\n          clearInterval(this._cameraUpdater);\n          this._cameraUpdater = undefined;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onImageError\",\n      value: function _onImageError() {\n        this._loadState = LoadState.Error;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onImageLoad\",\n      value: async function _onImageLoad(ev) {\n        this._loadState = LoadState.Loaded;\n        const imgEl = ev.target;\n        if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n          this._loadedImageSrc = imgEl.src;\n        }\n        await this.updateComplete;\n        this._lastImageHeight = imgEl.offsetHeight;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_onVideoLoad\",\n      value: async function _onVideoLoad(ev) {\n        this._loadState = LoadState.Loaded;\n        const videoEl = ev.currentTarget;\n        await this.updateComplete;\n        this._lastImageHeight = videoEl.offsetHeight;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_updateCameraImageSrcAtInterval\",\n      value: async function _updateCameraImageSrcAtInterval() {\n        // If we hit the interval and it was still loading\n        // it means we timed out so we should show the error.\n        if (this._loadState === LoadState.Loading) {\n          this._onImageError();\n        }\n        return this._updateCameraImageSrc();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_updateCameraImageSrc\",\n      value: async function _updateCameraImageSrc() {\n        if (!this.hass || !this.cameraImage) {\n          return;\n        }\n        const cameraState = this.hass.states[this.cameraImage];\n        if (!cameraState) {\n          this._onImageError();\n          return;\n        }\n        const element_width = this.clientWidth || MAX_IMAGE_WIDTH;\n        let width = Math.ceil(element_width * devicePixelRatio);\n        let height;\n        // If the image has not rendered yet we have no height\n        if (!this._lastImageHeight) {\n          if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n            height = Math.ceil(width * (this._ratio.h / this._ratio.w));\n          } else {\n            // If we don't have a ratio and we don't have a height\n            // we ask for 200% of what we need because the aspect\n            // ratio might result in a smaller image\n            width *= 2;\n            height = Math.ceil(width * ASPECT_RATIO_DEFAULT);\n          }\n        } else {\n          height = Math.ceil(this._lastImageHeight * devicePixelRatio);\n        }\n        this._cameraImageSrc = await fetchThumbnailUrlWithCache(this.hass, this.cameraImage, width, height);\n        if (this._cameraImageSrc === undefined) {\n          this._onImageError();\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host {\n        display: block;\n      }\n\n      .container {\n        transition: filter 0.2s linear;\n        height: 100%;\n      }\n\n      img {\n        display: block;\n        height: 100%;\n        width: 100%;\n        object-fit: cover;\n      }\n\n      .progress-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .ratio {\n        position: relative;\n        width: 100%;\n        height: 0;\n        background-position: center;\n        background-size: cover;\n      }\n      .ratio.fill {\n        background-size: 100% 100%;\n      }\n      .ratio.contain {\n        background-size: contain;\n        background-repeat: no-repeat;\n      }\n      .fill img {\n        object-fit: fill;\n      }\n      .contain img {\n        object-fit: contain;\n      }\n\n      .ratio img,\n      .ratio div {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      .ratio img {\n        visibility: hidden;\n      }\n\n      #brokenImage {\n        background: grey url(\"/static/images/image-broken.svg\") center/36px\n          no-repeat;\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","nothing","customElement","property","state","classMap","styleMap","STATES_OFF","computeDomain","parseAspectRatio","fetchThumbnailUrlWithCache","UNAVAILABLE","computeImageUrl","UPDATE_INTERVAL","DEFAULT_FILTER","MAX_IMAGE_WIDTH","ASPECT_RATIO_DEFAULT","LoadState","HuiImage","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","connectedCallback","_get","_getPrototypeOf","prototype","call","_loadState","undefined","Loading","cameraImage","cameraView","_startIntersectionObserverOrUpdates","disconnectedCallback","_stopUpdateCameraInterval","_stopIntersectionObserver","_imageVisible","handleIntersectionCallback","entries","isIntersecting","willUpdate","changedProps","has","oldHass","get","_shouldStartCameraUpdates","hass","connected","_cameraImageSrc","_loadedImageSrc","_startUpdateCameraInterval","_ratio","aspectRatio","Loaded","render","useRatio","Boolean","w","h","stateObj","entity","states","entityState","imageSrc","cameraObj","imageFallback","stateImage","image","darkModeImage","themes","darkMode","entity_id","hassUrl","filter","darkModeFilter","stateFilter","isOff","includes","paddingBottom","toFixed","_lastImageHeight","backgroundImage","ratio","contain","fitMode","fill","_onVideoLoad","_onImageError","_onImageLoad","display","Error","height","window","_intersectionObserver","IntersectionObserver","bind","observe","disconnect","_updateCameraImageSrc","isConnected","_cameraUpdater","setInterval","_updateCameraImageSrcAtInterval","clearInterval","ev","imgEl","target","src","updateComplete","offsetHeight","videoEl","currentTarget","cameraState","element_width","clientWidth","width","Math","ceil","devicePixelRatio","static","styles"],"sources":["/workspaces/frontend/src/panels/lovelace/components/hui-image.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  nothing,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { STATES_OFF } from \"../../../common/const\";\nimport { computeDomain } from \"../../../common/entity/compute_domain\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-camera-stream\";\nimport type { HaCameraStream } from \"../../../components/ha-camera-stream\";\nimport \"../../../components/ha-circular-progress\";\nimport { CameraEntity, fetchThumbnailUrlWithCache } from \"../../../data/camera\";\nimport { UNAVAILABLE } from \"../../../data/entity\";\nimport { computeImageUrl, ImageEntity } from \"../../../data/image\";\nimport { HomeAssistant } from \"../../../types\";\n\nconst UPDATE_INTERVAL = 10000;\nconst DEFAULT_FILTER = \"grayscale(100%)\";\n\nconst MAX_IMAGE_WIDTH = 640;\nconst ASPECT_RATIO_DEFAULT = 9 / 16;\n\nconst enum LoadState {\n  Loading = 1,\n  Loaded = 2,\n  Error = 3,\n}\n\nexport interface StateSpecificConfig {\n  [state: string]: string;\n}\n\n@customElement(\"hui-image\")\nexport class HuiImage extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public entity?: string;\n\n  @property() public image?: string;\n\n  @property({ attribute: false }) public stateImage?: StateSpecificConfig;\n\n  @property() public cameraImage?: string;\n\n  @property() public cameraView?: \"live\" | \"auto\";\n\n  @property() public aspectRatio?: string;\n\n  @property() public filter?: string;\n\n  @property({ attribute: false }) public stateFilter?: StateSpecificConfig;\n\n  @property() public darkModeImage?: string;\n\n  @property() public darkModeFilter?: string;\n\n  @property() public fitMode?: \"cover\" | \"contain\" | \"fill\";\n\n  @state() private _imageVisible? = false;\n\n  @state() private _loadState?: LoadState;\n\n  @state() private _cameraImageSrc?: string;\n\n  @state() private _loadedImageSrc?: string;\n\n  @state() private _lastImageHeight?: number;\n\n  private _intersectionObserver?: IntersectionObserver;\n\n  private _cameraUpdater?: number;\n\n  private _ratio: {\n    w: number;\n    h: number;\n  } | null = null;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    if (this._loadState === undefined) {\n      this._loadState = LoadState.Loading;\n    }\n    if (this.cameraImage && this.cameraView !== \"live\") {\n      this._startIntersectionObserverOrUpdates();\n    }\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._stopUpdateCameraInterval();\n    this._stopIntersectionObserver();\n    this._imageVisible = undefined;\n  }\n\n  protected handleIntersectionCallback(entries: IntersectionObserverEntry[]) {\n    this._imageVisible = entries[0].isIntersecting;\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (changedProps.has(\"hass\")) {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n      if (this._shouldStartCameraUpdates(oldHass)) {\n        this._startIntersectionObserverOrUpdates();\n      } else if (!this.hass!.connected) {\n        this._stopUpdateCameraInterval();\n        this._stopIntersectionObserver();\n        this._loadState = LoadState.Loading;\n        this._cameraImageSrc = undefined;\n        this._loadedImageSrc = undefined;\n      }\n    }\n    if (changedProps.has(\"_imageVisible\")) {\n      if (this._imageVisible) {\n        if (this._shouldStartCameraUpdates()) {\n          this._startUpdateCameraInterval();\n        }\n      } else {\n        this._stopUpdateCameraInterval();\n      }\n    }\n    if (changedProps.has(\"aspectRatio\")) {\n      this._ratio = this.aspectRatio\n        ? parseAspectRatio(this.aspectRatio)\n        : null;\n    }\n    if (this._loadState === LoadState.Loading && !this.cameraImage) {\n      this._loadState = LoadState.Loaded;\n    }\n  }\n\n  protected render() {\n    if (!this.hass) {\n      return nothing;\n    }\n    const useRatio = Boolean(\n      this._ratio && this._ratio.w > 0 && this._ratio.h > 0\n    );\n    const stateObj = this.entity ? this.hass.states[this.entity] : undefined;\n    const entityState = stateObj ? stateObj.state : UNAVAILABLE;\n\n    // Figure out image source to use\n    let imageSrc: string | undefined;\n    let cameraObj: CameraEntity | undefined;\n    // Track if we are we using a fallback image, used for filter.\n    let imageFallback = !this.stateImage;\n\n    if (this.cameraImage) {\n      if (this.cameraView === \"live\") {\n        cameraObj = this.hass.states[this.cameraImage] as CameraEntity;\n      } else {\n        imageSrc = this._cameraImageSrc;\n      }\n    } else if (this.stateImage) {\n      const stateImage = this.stateImage[entityState];\n\n      if (stateImage) {\n        imageSrc = stateImage;\n      } else {\n        imageSrc = this.image;\n        imageFallback = true;\n      }\n    } else if (this.darkModeImage && this.hass.themes.darkMode) {\n      imageSrc = this.darkModeImage;\n    } else if (stateObj && computeDomain(stateObj.entity_id) === \"image\") {\n      imageSrc = computeImageUrl(stateObj as ImageEntity);\n    } else {\n      imageSrc = this.image;\n    }\n\n    if (imageSrc) {\n      imageSrc = this.hass.hassUrl(imageSrc);\n    }\n\n    // Figure out filter to use\n    let filter = this.filter || \"\";\n\n    if (this.hass.themes.darkMode && this.darkModeFilter) {\n      filter += this.darkModeFilter;\n    }\n\n    if (this.stateFilter && this.stateFilter[entityState]) {\n      filter += this.stateFilter[entityState];\n    }\n\n    if (!filter && this.entity) {\n      const isOff = !stateObj || STATES_OFF.includes(entityState);\n      filter = isOff && imageFallback ? DEFAULT_FILTER : \"\";\n    }\n\n    return html`\n      <div\n        style=${styleMap({\n          paddingBottom: useRatio\n            ? `${((100 * this._ratio!.h) / this._ratio!.w).toFixed(2)}%`\n            : this._lastImageHeight === undefined\n              ? \"56.25%\"\n              : undefined,\n          backgroundImage:\n            useRatio && this._loadedImageSrc\n              ? `url(\"${this._loadedImageSrc}\")`\n              : undefined,\n          filter:\n            this._loadState === LoadState.Loaded || this.cameraView === \"live\"\n              ? filter\n              : undefined,\n        })}\n        class=\"container ${classMap({\n          ratio: useRatio || this._lastImageHeight === undefined,\n          contain: this.fitMode === \"contain\",\n          fill: this.fitMode === \"fill\",\n        })}\"\n      >\n        ${this.cameraImage && this.cameraView === \"live\"\n          ? html`\n              <ha-camera-stream\n                muted\n                .hass=${this.hass}\n                .stateObj=${cameraObj}\n                @load=${this._onVideoLoad}\n              ></ha-camera-stream>\n            `\n          : imageSrc === undefined\n            ? nothing\n            : html`\n                <img\n                  id=\"image\"\n                  src=${imageSrc}\n                  @error=${this._onImageError}\n                  @load=${this._onImageLoad}\n                  style=${styleMap({\n                    display:\n                      useRatio || this._loadState === LoadState.Loaded\n                        ? \"block\"\n                        : \"none\",\n                  })}\n                />\n              `}\n        ${this._loadState === LoadState.Error\n          ? html`<div\n              id=\"brokenImage\"\n              style=${styleMap({\n                height: !useRatio\n                  ? `${this._lastImageHeight}px` || \"100%\"\n                  : undefined,\n              })}\n            ></div>`\n          : this.cameraView !== \"live\" &&\n              (imageSrc === undefined || this._loadState === LoadState.Loading)\n            ? html`<div\n                class=\"progress-container\"\n                style=${styleMap({\n                  height: !useRatio\n                    ? `${this._lastImageHeight}px` || \"100%\"\n                    : undefined,\n                })}\n              >\n                <ha-circular-progress\n                  class=\"render-spinner\"\n                  indeterminate\n                  size=\"small\"\n                ></ha-circular-progress>\n              </div>`\n            : \"\"}\n      </div>\n    `;\n  }\n\n  protected _shouldStartCameraUpdates(oldHass?: HomeAssistant): boolean {\n    return !!(\n      (!oldHass || oldHass.connected !== this.hass!.connected) &&\n      this.hass!.connected &&\n      this.cameraView !== \"live\"\n    );\n  }\n\n  private _startIntersectionObserverOrUpdates(): void {\n    if (\"IntersectionObserver\" in window) {\n      if (!this._intersectionObserver) {\n        this._intersectionObserver = new IntersectionObserver(\n          this.handleIntersectionCallback.bind(this)\n        );\n      }\n      this._intersectionObserver.observe(this);\n    } else {\n      // No support for IntersectionObserver\n      // assume all images are visible\n      this._imageVisible = true;\n      this._startUpdateCameraInterval();\n    }\n  }\n\n  private _stopIntersectionObserver(): void {\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n    }\n  }\n\n  private _startUpdateCameraInterval(): void {\n    this._stopUpdateCameraInterval();\n    this._updateCameraImageSrc();\n    if (this.cameraImage && this.isConnected) {\n      this._cameraUpdater = window.setInterval(\n        () => this._updateCameraImageSrcAtInterval(),\n        UPDATE_INTERVAL\n      );\n    }\n  }\n\n  private _stopUpdateCameraInterval(): void {\n    if (this._cameraUpdater) {\n      clearInterval(this._cameraUpdater);\n      this._cameraUpdater = undefined;\n    }\n  }\n\n  private _onImageError(): void {\n    this._loadState = LoadState.Error;\n  }\n\n  private async _onImageLoad(ev: Event): Promise<void> {\n    this._loadState = LoadState.Loaded;\n    const imgEl = ev.target as HTMLImageElement;\n    if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n      this._loadedImageSrc = imgEl.src;\n    }\n    await this.updateComplete;\n    this._lastImageHeight = imgEl.offsetHeight;\n  }\n\n  private async _onVideoLoad(ev: Event): Promise<void> {\n    this._loadState = LoadState.Loaded;\n    const videoEl = ev.currentTarget as HaCameraStream;\n    await this.updateComplete;\n    this._lastImageHeight = videoEl.offsetHeight;\n  }\n\n  private async _updateCameraImageSrcAtInterval(): Promise<void> {\n    // If we hit the interval and it was still loading\n    // it means we timed out so we should show the error.\n    if (this._loadState === LoadState.Loading) {\n      this._onImageError();\n    }\n    return this._updateCameraImageSrc();\n  }\n\n  private async _updateCameraImageSrc(): Promise<void> {\n    if (!this.hass || !this.cameraImage) {\n      return;\n    }\n\n    const cameraState = this.hass.states[this.cameraImage] as\n      | CameraEntity\n      | undefined;\n\n    if (!cameraState) {\n      this._onImageError();\n      return;\n    }\n\n    const element_width = this.clientWidth || MAX_IMAGE_WIDTH;\n    let width = Math.ceil(element_width * devicePixelRatio);\n    let height: number;\n    // If the image has not rendered yet we have no height\n    if (!this._lastImageHeight) {\n      if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n        height = Math.ceil(width * (this._ratio.h / this._ratio.w));\n      } else {\n        // If we don't have a ratio and we don't have a height\n        // we ask for 200% of what we need because the aspect\n        // ratio might result in a smaller image\n        width *= 2;\n        height = Math.ceil(width * ASPECT_RATIO_DEFAULT);\n      }\n    } else {\n      height = Math.ceil(this._lastImageHeight * devicePixelRatio);\n    }\n    this._cameraImageSrc = await fetchThumbnailUrlWithCache(\n      this.hass,\n      this.cameraImage,\n      width,\n      height\n    );\n    if (this._cameraImageSrc === undefined) {\n      this._onImageError();\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n\n      .container {\n        transition: filter 0.2s linear;\n        height: 100%;\n      }\n\n      img {\n        display: block;\n        height: 100%;\n        width: 100%;\n        object-fit: cover;\n      }\n\n      .progress-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .ratio {\n        position: relative;\n        width: 100%;\n        height: 0;\n        background-position: center;\n        background-size: cover;\n      }\n      .ratio.fill {\n        background-size: 100% 100%;\n      }\n      .ratio.contain {\n        background-size: contain;\n        background-repeat: no-repeat;\n      }\n      .fill img {\n        object-fit: fill;\n      }\n      .contain img {\n        object-fit: contain;\n      }\n\n      .ratio img,\n      .ratio div {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      .ratio img {\n        visibility: hidden;\n      }\n\n      #brokenImage {\n        background: grey url(\"/static/images/image-broken.svg\") center/36px\n          no-repeat;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-image\": HuiImage;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}