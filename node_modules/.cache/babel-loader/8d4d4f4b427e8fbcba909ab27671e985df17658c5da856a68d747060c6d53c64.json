{"ast":null,"code":"// Loads the static locale data for a given language from FormatJS\n// Parents need to load polyfills first; they are not imported here to avoid a circular reference\n\nconst INTL_POLYFILLS = [\"DateTimeFormat\", \"DisplayNames\", \"ListFormat\", \"NumberFormat\", \"RelativeTimeFormat\"];\nconst loadedLocales = new Set();\nconst addData = async (obj, language, addFunc = \"__addLocaleData\") => {\n  var _Intl$obj;\n  // Add function will only exist if constructor is polyfilled\n  if (typeof ((_Intl$obj = Intl[obj]) === null || _Intl$obj === void 0 ? void 0 : _Intl$obj[addFunc]) === \"function\") {\n    const result = await fetch(`${__STATIC_PATH__}locale-data/intl-${obj.toLowerCase()}/${language}.json`);\n    // Ignore if polyfill data does not exist for language\n    if (result.ok) {\n      Intl[obj][addFunc](await result.json());\n    }\n  }\n};\nexport const polyfillLocaleData = async language => {\n  if (loadedLocales.has(language)) {\n    return;\n  }\n  loadedLocales.add(language);\n  await Promise.all(INTL_POLYFILLS.map(obj => addData(obj, language)));\n};\nexport const polyfillTimeZoneData = () => addData(\"DateTimeFormat\", \"add-all-tz\", \"__addTZData\");","map":{"version":3,"names":["INTL_POLYFILLS","loadedLocales","Set","addData","obj","language","addFunc","_Intl$obj","Intl","result","fetch","__STATIC_PATH__","toLowerCase","ok","json","polyfillLocaleData","has","add","Promise","all","map","polyfillTimeZoneData"],"sources":["/workspaces/frontend/src/resources/locale-data-polyfill.ts"],"sourcesContent":["// Loads the static locale data for a given language from FormatJS\n// Parents need to load polyfills first; they are not imported here to avoid a circular reference\n\nconst INTL_POLYFILLS = [\n  \"DateTimeFormat\",\n  \"DisplayNames\",\n  \"ListFormat\",\n  \"NumberFormat\",\n  \"RelativeTimeFormat\",\n] as const satisfies readonly (keyof typeof Intl)[];\n\nconst loadedLocales: Set<string> = new Set();\n\nconst addData = async (\n  obj: (typeof INTL_POLYFILLS)[number],\n  language: string,\n  addFunc = \"__addLocaleData\"\n) => {\n  // Add function will only exist if constructor is polyfilled\n  if (typeof (Intl[obj] as any)?.[addFunc] === \"function\") {\n    const result = await fetch(\n      `${__STATIC_PATH__}locale-data/intl-${obj.toLowerCase()}/${language}.json`\n    );\n    // Ignore if polyfill data does not exist for language\n    if (result.ok) {\n      (Intl[obj] as any)[addFunc](await result.json());\n    }\n  }\n};\n\nexport const polyfillLocaleData = async (language: string) => {\n  if (loadedLocales.has(language)) {\n    return;\n  }\n  loadedLocales.add(language);\n  await Promise.all(INTL_POLYFILLS.map((obj) => addData(obj, language)));\n};\n\nexport const polyfillTimeZoneData = () =>\n  addData(\"DateTimeFormat\", \"add-all-tz\", \"__addTZData\");\n"],"mappings":"AAAA;AACA;;AAEA,MAAMA,cAAc,GAAG,CACrB,gBAAgB,EAChB,cAAc,EACd,YAAY,EACZ,cAAc,EACd,oBAAoB,CAC6B;AAEnD,MAAMC,aAA0B,GAAG,IAAIC,GAAG,CAAC,CAAC;AAE5C,MAAMC,OAAO,GAAG,MAAAA,CACdC,GAAoC,EACpCC,QAAgB,EAChBC,OAAO,GAAG,iBAAiB,KACxB;EAAA,IAAAC,SAAA;EACH;EACA,IAAI,SAAAA,SAAA,GAAQC,IAAI,CAACJ,GAAG,CAAC,cAAAG,SAAA,uBAAVA,SAAA,CAAqBD,OAAO,CAAC,MAAK,UAAU,EAAE;IACvD,MAAMG,MAAM,GAAG,MAAMC,KAAK,CACvB,GAAEC,eAAgB,oBAAmBP,GAAG,CAACQ,WAAW,CAAC,CAAE,IAAGP,QAAS,OACtE,CAAC;IACD;IACA,IAAII,MAAM,CAACI,EAAE,EAAE;MACZL,IAAI,CAACJ,GAAG,CAAC,CAASE,OAAO,CAAC,CAAC,MAAMG,MAAM,CAACK,IAAI,CAAC,CAAC,CAAC;IAClD;EACF;AACF,CAAC;AAED,OAAO,MAAMC,kBAAkB,GAAG,MAAOV,QAAgB,IAAK;EAC5D,IAAIJ,aAAa,CAACe,GAAG,CAACX,QAAQ,CAAC,EAAE;IAC/B;EACF;EACAJ,aAAa,CAACgB,GAAG,CAACZ,QAAQ,CAAC;EAC3B,MAAMa,OAAO,CAACC,GAAG,CAACnB,cAAc,CAACoB,GAAG,CAAEhB,GAAG,IAAKD,OAAO,CAACC,GAAG,EAAEC,QAAQ,CAAC,CAAC,CAAC;AACxE,CAAC;AAED,OAAO,MAAMgB,oBAAoB,GAAGA,CAAA,KAClClB,OAAO,CAAC,gBAAgB,EAAE,YAAY,EAAE,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}