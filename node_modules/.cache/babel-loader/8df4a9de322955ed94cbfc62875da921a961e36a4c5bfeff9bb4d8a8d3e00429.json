{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\nrequire(\"core-js/modules/es.array.join.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\nrequire(\"core-js/modules/es.function.name.js\");\nrequire(\"core-js/modules/es.object.keys.js\");\nrequire(\"core-js/modules/es.object.to-string.js\");\nrequire(\"core-js/modules/es.regexp.exec.js\");\nrequire(\"core-js/modules/es.regexp.to-string.js\");\nrequire(\"core-js/modules/es.string.replace.js\");\nrequire(\"core-js/modules/es.string.split.js\");\nrequire(\"core-js/modules/esnext.iterator.constructor.js\");\nrequire(\"core-js/modules/esnext.iterator.for-each.js\");\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n  // The SourceNode we want to fill with the generated code\n  // and the SourceMap\n  var node = new SourceNode();\n\n  // All even indices of this array are one line of the generated code,\n  // while all odd indices are the newlines between two adjacent lines\n  // (since `REGEX_NEWLINE` captures its match).\n  // Processed fragments are removed from this array, by calling `shiftNextLine`.\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n  var shiftNextLine = function shiftNextLine() {\n    var lineContents = remainingLines.shift();\n    // The last line of a file might not have a newline.\n    var newLine = remainingLines.shift() || \"\";\n    return lineContents + newLine;\n  };\n\n  // We need to remember the position of \"remainingLines\"\n  var lastGeneratedLine = 1,\n    lastGeneratedColumn = 0;\n\n  // The generate SourceNodes we need a code range.\n  // To extract it current and last mapping is used.\n  // Here we store the last mapping.\n  var lastMapping = null;\n  aSourceMapConsumer.eachMapping(function (mapping) {\n    if (lastMapping !== null) {\n      // We add the code from \"lastMapping\" to \"mapping\":\n      // First check if there is a new line in between.\n      if (lastGeneratedLine < mapping.generatedLine) {\n        // Associate first line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n        lastGeneratedLine++;\n        lastGeneratedColumn = 0;\n        // The remaining code is added without mapping\n      } else {\n        // There is no new line in between.\n        // Associate the code between \"lastGeneratedColumn\" and\n        // \"mapping.generatedColumn\" with \"lastMapping\"\n        var nextLine = remainingLines[0];\n        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n        addMappingWithCode(lastMapping, code);\n        // No more remaining code, continue\n        lastMapping = mapping;\n        return;\n      }\n    }\n    // We add the generated code until the first mapping\n    // to the SourceNode without any mapping.\n    // Each line is added as separate string.\n    while (lastGeneratedLine < mapping.generatedLine) {\n      node.add(shiftNextLine());\n      lastGeneratedLine++;\n    }\n    if (lastGeneratedColumn < mapping.generatedColumn) {\n      var nextLine = remainingLines[0];\n      node.add(nextLine.substr(0, mapping.generatedColumn));\n      remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n      lastGeneratedColumn = mapping.generatedColumn;\n    }\n    lastMapping = mapping;\n  }, this);\n  // We have processed all mappings.\n  if (remainingLines.length > 0) {\n    if (lastMapping) {\n      // Associate the remaining code in the current line with \"lastMapping\"\n      addMappingWithCode(lastMapping, shiftNextLine());\n    }\n    // and add the remaining lines without any mapping\n    node.add(remainingLines.join(\"\"));\n  }\n\n  // Copy sourcesContent into SourceNode\n  aSourceMapConsumer.sources.forEach(function (sourceFile) {\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n    if (content != null) {\n      if (aRelativePath != null) {\n        sourceFile = util.join(aRelativePath, sourceFile);\n      }\n      node.setSourceContent(sourceFile, content);\n    }\n  });\n  return node;\n  function addMappingWithCode(mapping, code) {\n    if (mapping === null || mapping.source === undefined) {\n      node.add(code);\n    } else {\n      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n    }\n  }\n};\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length - 1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    } else {\n      if (chunk !== '') {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len - 1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  } else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  } else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    if (this.children[i][isSourceNode]) {\n      this.children[i].walkSourceContents(aFn);\n    }\n  }\n  var sources = Object.keys(this.sourceContents);\n  for (var i = 0, len = sources.length; i < len; i++) {\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n  }\n};\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null && original.line !== null && original.column !== null) {\n      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n  return {\n    code: generated.code,\n    map: map\n  };\n};\nexports.SourceNode = SourceNode;","map":{"version":3,"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","shiftNextLine","lineContents","shift","newLine","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","length","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","undefined","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"sources":["/workspaces/frontend/node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}