{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport { MDCFoundation } from '@material/base/foundation.js';\nimport { normalizeKey } from '@material/dom/keyboard.js';\nimport { numbers, strings } from '@material/list/constants.js';\nconst integerSort = (a, b) => {\n  return a - b;\n};\nconst findIndexDiff = (oldSet, newSet) => {\n  const oldArr = Array.from(oldSet);\n  const newArr = Array.from(newSet);\n  const diff = {\n    added: [],\n    removed: []\n  };\n  const oldSorted = oldArr.sort(integerSort);\n  const newSorted = newArr.sort(integerSort);\n  let i = 0;\n  let j = 0;\n  while (i < oldSorted.length || j < newSorted.length) {\n    const oldVal = oldSorted[i];\n    const newVal = newSorted[j];\n    if (oldVal === newVal) {\n      i++;\n      j++;\n      continue;\n    }\n    if (oldVal !== undefined && (newVal === undefined || oldVal < newVal)) {\n      diff.removed.push(oldVal);\n      i++;\n      continue;\n    }\n    if (newVal !== undefined && (oldVal === undefined || newVal < oldVal)) {\n      diff.added.push(newVal);\n      j++;\n      continue;\n    }\n  }\n  return diff;\n};\nconst ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];\nexport function isIndexSet(selectedIndex) {\n  return selectedIndex instanceof Set;\n}\nexport function isEventMulti(evt) {\n  return isIndexSet(evt.detail.index);\n}\nexport const createSetFromIndex = index => {\n  const entry = index === numbers.UNSET_INDEX ? new Set() : index;\n  return isIndexSet(entry) ? new Set(entry) : new Set([entry]);\n};\nexport class MDCListFoundation extends MDCFoundation {\n  constructor(adapter) {\n    super(Object.assign(Object.assign({}, MDCListFoundation.defaultAdapter), adapter));\n    this.isMulti_ = false;\n    this.wrapFocus_ = false;\n    this.isVertical_ = true;\n    this.selectedIndex_ = numbers.UNSET_INDEX;\n    this.focusedItemIndex_ = numbers.UNSET_INDEX;\n    this.useActivatedClass_ = false;\n    this.ariaCurrentAttrValue_ = null;\n  }\n  static get strings() {\n    return strings;\n  }\n  static get numbers() {\n    return numbers;\n  }\n  static get defaultAdapter() {\n    return {\n      focusItemAtIndex: () => undefined,\n      getFocusedElementIndex: () => 0,\n      getListItemCount: () => 0,\n      isFocusInsideList: () => false,\n      isRootFocused: () => false,\n      notifyAction: () => undefined,\n      notifySelected: () => undefined,\n      getSelectedStateForElementIndex: () => false,\n      setDisabledStateForElementIndex: () => undefined,\n      getDisabledStateForElementIndex: () => false,\n      setSelectedStateForElementIndex: () => undefined,\n      setActivatedStateForElementIndex: () => undefined,\n      setTabIndexForElementIndex: () => undefined,\n      setAttributeForElementIndex: () => undefined,\n      getAttributeForElementIndex: () => null\n    };\n  }\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setWrapFocus(value) {\n    this.wrapFocus_ = value;\n  }\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setMulti(value) {\n    this.isMulti_ = value;\n    const currentIndex = this.selectedIndex_;\n    if (value) {\n      // number to set\n      if (!isIndexSet(currentIndex)) {\n        const isUnset = currentIndex === numbers.UNSET_INDEX;\n        this.selectedIndex_ = isUnset ? new Set() : new Set([currentIndex]);\n      }\n    } else {\n      // set to first sorted number in set\n      if (isIndexSet(currentIndex)) {\n        if (currentIndex.size) {\n          const vals = Array.from(currentIndex).sort(integerSort);\n          this.selectedIndex_ = vals[0];\n        } else {\n          this.selectedIndex_ = numbers.UNSET_INDEX;\n        }\n      }\n    }\n  }\n  /**\n   * Sets the isVertical_ private variable.\n   */\n  setVerticalOrientation(value) {\n    this.isVertical_ = value;\n  }\n  /**\n   * Sets the useActivatedClass_ private variable.\n   */\n  setUseActivatedClass(useActivated) {\n    this.useActivatedClass_ = useActivated;\n  }\n  getSelectedIndex() {\n    return this.selectedIndex_;\n  }\n  setSelectedIndex(index) {\n    if (!this.isIndexValid_(index)) {\n      return;\n    }\n    if (this.isMulti_) {\n      this.setMultiSelectionAtIndex_(createSetFromIndex(index));\n    } else {\n      this.setSingleSelectionAtIndex_(index);\n    }\n  }\n  /**\n   * Focus in handler for the list items.\n   */\n  handleFocusIn(_, listItemIndex) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, 0);\n    }\n  }\n  /**\n   * Focus out handler for the list items.\n   */\n  handleFocusOut(_, listItemIndex) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, -1);\n    }\n    /**\n     * Between Focusout & Focusin some browsers do not have focus on any\n     * element. Setting a delay to wait till the focus is moved to next element.\n     */\n    setTimeout(() => {\n      if (!this.adapter.isFocusInsideList()) {\n        this.setTabindexToFirstSelectedItem_();\n      }\n    }, 0);\n  }\n  /**\n   * Key handler for the list.\n   */\n  handleKeydown(event, isRootListItem, listItemIndex) {\n    const isArrowLeft = normalizeKey(event) === 'ArrowLeft';\n    const isArrowUp = normalizeKey(event) === 'ArrowUp';\n    const isArrowRight = normalizeKey(event) === 'ArrowRight';\n    const isArrowDown = normalizeKey(event) === 'ArrowDown';\n    const isHome = normalizeKey(event) === 'Home';\n    const isEnd = normalizeKey(event) === 'End';\n    const isEnter = normalizeKey(event) === 'Enter';\n    const isSpace = normalizeKey(event) === 'Spacebar';\n    if (this.adapter.isRootFocused()) {\n      if (isArrowUp || isEnd) {\n        event.preventDefault();\n        this.focusLastElement();\n      } else if (isArrowDown || isHome) {\n        event.preventDefault();\n        this.focusFirstElement();\n      }\n      return;\n    }\n    let currentIndex = this.adapter.getFocusedElementIndex();\n    if (currentIndex === -1) {\n      currentIndex = listItemIndex;\n      if (currentIndex < 0) {\n        // If this event doesn't have a mdc-deprecated-list-item ancestor from\n        // the current list (not from a sublist), return early.\n        return;\n      }\n    }\n    let nextIndex;\n    if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusNextElement(currentIndex);\n    } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusPrevElement(currentIndex);\n    } else if (isHome) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusFirstElement();\n    } else if (isEnd) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusLastElement();\n    } else if (isEnter || isSpace) {\n      if (isRootListItem) {\n        // Return early if enter key is pressed on anchor element which triggers\n        // synthetic MouseEvent event.\n        const target = event.target;\n        if (target && target.tagName === 'A' && isEnter) {\n          return;\n        }\n        this.preventDefaultEvent(event);\n        this.setSelectedIndexOnAction_(currentIndex, true);\n      }\n    }\n    this.focusedItemIndex_ = currentIndex;\n    if (nextIndex !== undefined) {\n      this.setTabindexAtIndex_(nextIndex);\n      this.focusedItemIndex_ = nextIndex;\n    }\n  }\n  /**\n   * Click handler for the list.\n   */\n  handleSingleSelection(index, isInteraction, force) {\n    if (index === numbers.UNSET_INDEX) {\n      return;\n    }\n    this.setSelectedIndexOnAction_(index, isInteraction, force);\n    this.setTabindexAtIndex_(index);\n    this.focusedItemIndex_ = index;\n  }\n  /**\n   * Focuses the next element on the list.\n   */\n  focusNextElement(index) {\n    const count = this.adapter.getListItemCount();\n    let nextIndex = index + 1;\n    if (nextIndex >= count) {\n      if (this.wrapFocus_) {\n        nextIndex = 0;\n      } else {\n        // Return early because last item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(nextIndex);\n    return nextIndex;\n  }\n  /**\n   * Focuses the previous element on the list.\n   */\n  focusPrevElement(index) {\n    let prevIndex = index - 1;\n    if (prevIndex < 0) {\n      if (this.wrapFocus_) {\n        prevIndex = this.adapter.getListItemCount() - 1;\n      } else {\n        // Return early because first item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(prevIndex);\n    return prevIndex;\n  }\n  focusFirstElement() {\n    this.adapter.focusItemAtIndex(0);\n    return 0;\n  }\n  focusLastElement() {\n    const lastIndex = this.adapter.getListItemCount() - 1;\n    this.adapter.focusItemAtIndex(lastIndex);\n    return lastIndex;\n  }\n  /**\n   * @param itemIndex Index of the list item\n   * @param isEnabled Sets the list item to enabled or disabled.\n   */\n  setEnabled(itemIndex, isEnabled) {\n    if (!this.isIndexValid_(itemIndex)) {\n      return;\n    }\n    this.adapter.setDisabledStateForElementIndex(itemIndex, !isEnabled);\n  }\n  /**\n   * Ensures that preventDefault is only called if the containing element\n   * doesn't consume the event, and it will cause an unintended scroll.\n   */\n  preventDefaultEvent(evt) {\n    const target = evt.target;\n    const tagName = `${target.tagName}`.toLowerCase();\n    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {\n      evt.preventDefault();\n    }\n  }\n  setSingleSelectionAtIndex_(index, isInteraction = true) {\n    if (this.selectedIndex_ === index) {\n      return;\n    }\n    // unset previous\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setSelectedStateForElementIndex(this.selectedIndex_, false);\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(this.selectedIndex_, false);\n      }\n    }\n    // set new\n    if (isInteraction) {\n      this.adapter.setSelectedStateForElementIndex(index, true);\n    }\n    if (this.useActivatedClass_) {\n      this.adapter.setActivatedStateForElementIndex(index, true);\n    }\n    this.setAriaForSingleSelectionAtIndex_(index);\n    this.selectedIndex_ = index;\n    this.adapter.notifySelected(index);\n  }\n  setMultiSelectionAtIndex_(newIndex, isInteraction = true) {\n    const oldIndex = createSetFromIndex(this.selectedIndex_);\n    const diff = findIndexDiff(oldIndex, newIndex);\n    if (!diff.removed.length && !diff.added.length) {\n      return;\n    }\n    for (const removed of diff.removed) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(removed, false);\n      }\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(removed, false);\n      }\n    }\n    for (const added of diff.added) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(added, true);\n      }\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(added, true);\n      }\n    }\n    this.selectedIndex_ = newIndex;\n    this.adapter.notifySelected(newIndex, diff);\n  }\n  /**\n   * Sets aria attribute for single selection at given index.\n   */\n  setAriaForSingleSelectionAtIndex_(index) {\n    // Detect the presence of aria-current and get the value only during list\n    // initialization when it is in unset state.\n    if (this.selectedIndex_ === numbers.UNSET_INDEX) {\n      this.ariaCurrentAttrValue_ = this.adapter.getAttributeForElementIndex(index, strings.ARIA_CURRENT);\n    }\n    const isAriaCurrent = this.ariaCurrentAttrValue_ !== null;\n    const ariaAttribute = isAriaCurrent ? strings.ARIA_CURRENT : strings.ARIA_SELECTED;\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');\n    }\n    const ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';\n    this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);\n  }\n  setTabindexAtIndex_(index) {\n    if (this.focusedItemIndex_ === numbers.UNSET_INDEX && index !== 0) {\n      // If no list item was selected set first list item's tabindex to -1.\n      // Generally, tabindex is set to 0 on first list item of list that has no\n      // preselected items.\n      this.adapter.setTabIndexForElementIndex(0, -1);\n    } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {\n      this.adapter.setTabIndexForElementIndex(this.focusedItemIndex_, -1);\n    }\n    this.adapter.setTabIndexForElementIndex(index, 0);\n  }\n  setTabindexToFirstSelectedItem_() {\n    let targetIndex = 0;\n    if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      targetIndex = this.selectedIndex_;\n    } else if (isIndexSet(this.selectedIndex_) && this.selectedIndex_.size > 0) {\n      targetIndex = Math.min(...this.selectedIndex_);\n    }\n    this.setTabindexAtIndex_(targetIndex);\n  }\n  isIndexValid_(index) {\n    if (index instanceof Set) {\n      if (!this.isMulti_) {\n        throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');\n      }\n      if (index.size === 0) {\n        return true;\n      } else {\n        let isOneInRange = false;\n        for (const entry of index) {\n          isOneInRange = this.isIndexInRange_(entry);\n          if (isOneInRange) {\n            break;\n          }\n        }\n        return isOneInRange;\n      }\n    } else if (typeof index === 'number') {\n      if (this.isMulti_) {\n        throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);\n      }\n      return index === numbers.UNSET_INDEX || this.isIndexInRange_(index);\n    } else {\n      return false;\n    }\n  }\n  isIndexInRange_(index) {\n    const listSize = this.adapter.getListItemCount();\n    return index >= 0 && index < listSize;\n  }\n  /**\n   * Sets selected index on user action, toggles checkbox / radio based on\n   * toggleCheckbox value. User interaction should not toggle list item(s) when\n   * disabled.\n   */\n  setSelectedIndexOnAction_(index, isInteraction, force) {\n    if (this.adapter.getDisabledStateForElementIndex(index)) {\n      return;\n    }\n    let checkedIndex = index;\n    if (this.isMulti_) {\n      checkedIndex = new Set([index]);\n    }\n    if (!this.isIndexValid_(checkedIndex)) {\n      return;\n    }\n    if (this.isMulti_) {\n      this.toggleMultiAtIndex(index, force, isInteraction);\n    } else {\n      if (isInteraction || force) {\n        this.setSingleSelectionAtIndex_(index, isInteraction);\n      } else {\n        const isDeselection = this.selectedIndex_ === index;\n        if (isDeselection) {\n          this.setSingleSelectionAtIndex_(numbers.UNSET_INDEX);\n        }\n      }\n    }\n    if (isInteraction) {\n      this.adapter.notifyAction(index);\n    }\n  }\n  toggleMultiAtIndex(index, force, isInteraction = true) {\n    let newSelectionValue = false;\n    if (force === undefined) {\n      newSelectionValue = !this.adapter.getSelectedStateForElementIndex(index);\n    } else {\n      newSelectionValue = force;\n    }\n    const newSet = createSetFromIndex(this.selectedIndex_);\n    if (newSelectionValue) {\n      newSet.add(index);\n    } else {\n      newSet.delete(index);\n    }\n    this.setMultiSelectionAtIndex_(newSet, isInteraction);\n  }\n}\n// tslint:disable-next-line:no-default-export Needed for backward compatibility\n// with MDC Web v0.44.0 and earlier.\nexport default MDCListFoundation;","map":{"version":3,"names":["MDCFoundation","normalizeKey","numbers","strings","integerSort","a","b","findIndexDiff","oldSet","newSet","oldArr","Array","from","newArr","diff","added","removed","oldSorted","sort","newSorted","i","j","length","oldVal","newVal","undefined","push","ELEMENTS_KEY_ALLOWED_IN","isIndexSet","selectedIndex","Set","isEventMulti","evt","detail","index","createSetFromIndex","entry","UNSET_INDEX","MDCListFoundation","constructor","adapter","Object","assign","defaultAdapter","isMulti_","wrapFocus_","isVertical_","selectedIndex_","focusedItemIndex_","useActivatedClass_","ariaCurrentAttrValue_","focusItemAtIndex","getFocusedElementIndex","getListItemCount","isFocusInsideList","isRootFocused","notifyAction","notifySelected","getSelectedStateForElementIndex","setDisabledStateForElementIndex","getDisabledStateForElementIndex","setSelectedStateForElementIndex","setActivatedStateForElementIndex","setTabIndexForElementIndex","setAttributeForElementIndex","getAttributeForElementIndex","setWrapFocus","value","setMulti","currentIndex","isUnset","size","vals","setVerticalOrientation","setUseActivatedClass","useActivated","getSelectedIndex","setSelectedIndex","isIndexValid_","setMultiSelectionAtIndex_","setSingleSelectionAtIndex_","handleFocusIn","_","listItemIndex","handleFocusOut","setTimeout","setTabindexToFirstSelectedItem_","handleKeydown","event","isRootListItem","isArrowLeft","isArrowUp","isArrowRight","isArrowDown","isHome","isEnd","isEnter","isSpace","preventDefault","focusLastElement","focusFirstElement","nextIndex","preventDefaultEvent","focusNextElement","focusPrevElement","target","tagName","setSelectedIndexOnAction_","setTabindexAtIndex_","handleSingleSelection","isInteraction","force","count","prevIndex","lastIndex","setEnabled","itemIndex","isEnabled","toLowerCase","indexOf","setAriaForSingleSelectionAtIndex_","newIndex","oldIndex","ARIA_CURRENT","isAriaCurrent","ariaAttribute","ARIA_SELECTED","ariaAttributeValue","targetIndex","Math","min","Error","isOneInRange","isIndexInRange_","listSize","checkedIndex","toggleMultiAtIndex","isDeselection","newSelectionValue","add","delete"],"sources":["mwc-list-foundation.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n\nimport {MDCFoundation} from '@material/base/foundation.js';\nimport {normalizeKey} from '@material/dom/keyboard.js';\nimport {numbers, strings} from '@material/list/constants.js';\n\nimport {MDCListAdapter} from './mwc-list-adapter.js';\n\nexport type MWCListIndex = number|Set<number>;\n\nexport interface IndexDiff {\n  added: number[];\n  removed: number[];\n}\n\nexport interface SelectedDetail<T extends MWCListIndex = MWCListIndex> {\n  index: T;\n  diff: T extends Set<number>? IndexDiff: undefined;\n}\n\nexport interface ActionDetail {\n  index: number;\n}\n\nconst integerSort = (a: number, b: number) => {\n  return a - b;\n};\n\nexport type SingleSelectedEvent = CustomEvent<SelectedDetail<number>>;\nexport type MultiSelectedEvent = CustomEvent<SelectedDetail<Set<number>>>;\nexport type SelectedEvent = SingleSelectedEvent|MultiSelectedEvent;\n\nconst findIndexDiff = (oldSet: Set<number>, newSet: Set<number>): IndexDiff => {\n  const oldArr = Array.from(oldSet);\n  const newArr = Array.from(newSet);\n  const diff: IndexDiff = {added: [], removed: []};\n  const oldSorted = oldArr.sort(integerSort);\n  const newSorted = newArr.sort(integerSort);\n\n  let i = 0;\n  let j = 0;\n  while (i < oldSorted.length || j < newSorted.length) {\n    const oldVal = oldSorted[i];\n    const newVal = newSorted[j];\n\n    if (oldVal === newVal) {\n      i++;\n      j++;\n      continue;\n    }\n\n    if (oldVal !== undefined && (newVal === undefined || oldVal < newVal)) {\n      diff.removed.push(oldVal);\n      i++;\n      continue;\n    }\n\n    if (newVal !== undefined && (oldVal === undefined || newVal < oldVal)) {\n      diff.added.push(newVal);\n      j++;\n      continue;\n    }\n  }\n\n  return diff;\n};\n\nconst ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];\n\nexport function isIndexSet(selectedIndex: MWCListIndex):\n    selectedIndex is Set<number> {\n  return selectedIndex instanceof Set;\n}\n\nexport function isEventMulti(evt: SelectedEvent): evt is MultiSelectedEvent {\n  return isIndexSet(evt.detail.index);\n}\n\nexport const createSetFromIndex = (index: MWCListIndex) => {\n  const entry = index === numbers.UNSET_INDEX ? new Set<number>() : index;\n  return isIndexSet(entry) ? new Set(entry) : new Set([entry]);\n};\n\nexport class MDCListFoundation extends MDCFoundation<MDCListAdapter> {\n  static override get strings() {\n    return strings;\n  }\n\n  static override get numbers() {\n    return numbers;\n  }\n\n\n  static override get defaultAdapter(): MDCListAdapter {\n    return {\n      focusItemAtIndex: () => undefined,\n      getFocusedElementIndex: () => 0,\n      getListItemCount: () => 0,\n      isFocusInsideList: () => false,\n      isRootFocused: () => false,\n      notifyAction: () => undefined,\n      notifySelected: () => undefined,\n      getSelectedStateForElementIndex: () => false,\n      setDisabledStateForElementIndex: () => undefined,\n      getDisabledStateForElementIndex: () => false,\n      setSelectedStateForElementIndex: () => undefined,\n      setActivatedStateForElementIndex: () => undefined,\n      setTabIndexForElementIndex: () => undefined,\n      setAttributeForElementIndex: () => undefined,\n      getAttributeForElementIndex: () => null,\n    };\n  }\n\n  protected isMulti_ = false;\n  private wrapFocus_ = false;\n  private isVertical_ = true;\n  private selectedIndex_: MWCListIndex = numbers.UNSET_INDEX;\n  private focusedItemIndex_ = numbers.UNSET_INDEX;\n  private useActivatedClass_ = false;\n  private ariaCurrentAttrValue_: string|null = null;\n\n  constructor(adapter?: Partial<MDCListAdapter>) {\n    super({...MDCListFoundation.defaultAdapter, ...adapter});\n  }\n\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setWrapFocus(value: boolean) {\n    this.wrapFocus_ = value;\n  }\n\n  /**\n   * Sets the private wrapFocus_ variable.\n   */\n  setMulti(value: boolean) {\n    this.isMulti_ = value;\n\n    const currentIndex = this.selectedIndex_;\n\n    if (value) {\n      // number to set\n      if (!isIndexSet(currentIndex)) {\n        const isUnset = currentIndex === numbers.UNSET_INDEX;\n        this.selectedIndex_ = isUnset ? new Set() : new Set([currentIndex]);\n      }\n    } else {\n      // set to first sorted number in set\n      if (isIndexSet(currentIndex)) {\n        if (currentIndex.size) {\n          const vals = Array.from(currentIndex).sort(integerSort);\n          this.selectedIndex_ = vals[0];\n        } else {\n          this.selectedIndex_ = numbers.UNSET_INDEX;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the isVertical_ private variable.\n   */\n  setVerticalOrientation(value: boolean) {\n    this.isVertical_ = value;\n  }\n\n  /**\n   * Sets the useActivatedClass_ private variable.\n   */\n  setUseActivatedClass(useActivated: boolean) {\n    this.useActivatedClass_ = useActivated;\n  }\n\n  getSelectedIndex(): MWCListIndex {\n    return this.selectedIndex_;\n  }\n\n  setSelectedIndex(index: MWCListIndex) {\n    if (!this.isIndexValid_(index)) {\n      return;\n    }\n\n    if (this.isMulti_) {\n      this.setMultiSelectionAtIndex_(createSetFromIndex(index));\n    } else {\n      this.setSingleSelectionAtIndex_(index as number);\n    }\n  }\n\n  /**\n   * Focus in handler for the list items.\n   */\n  handleFocusIn(_: FocusEvent, listItemIndex: number) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, 0);\n    }\n  }\n\n  /**\n   * Focus out handler for the list items.\n   */\n  handleFocusOut(_: FocusEvent, listItemIndex: number) {\n    if (listItemIndex >= 0) {\n      this.adapter.setTabIndexForElementIndex(listItemIndex, -1);\n    }\n\n    /**\n     * Between Focusout & Focusin some browsers do not have focus on any\n     * element. Setting a delay to wait till the focus is moved to next element.\n     */\n    setTimeout(() => {\n      if (!this.adapter.isFocusInsideList()) {\n        this.setTabindexToFirstSelectedItem_();\n      }\n    }, 0);\n  }\n\n  /**\n   * Key handler for the list.\n   */\n  handleKeydown(\n      event: KeyboardEvent, isRootListItem: boolean, listItemIndex: number) {\n    const isArrowLeft = normalizeKey(event) === 'ArrowLeft';\n    const isArrowUp = normalizeKey(event) === 'ArrowUp';\n    const isArrowRight = normalizeKey(event) === 'ArrowRight';\n    const isArrowDown = normalizeKey(event) === 'ArrowDown';\n    const isHome = normalizeKey(event) === 'Home';\n    const isEnd = normalizeKey(event) === 'End';\n    const isEnter = normalizeKey(event) === 'Enter';\n    const isSpace = normalizeKey(event) === 'Spacebar';\n\n    if (this.adapter.isRootFocused()) {\n      if (isArrowUp || isEnd) {\n        event.preventDefault();\n        this.focusLastElement();\n      } else if (isArrowDown || isHome) {\n        event.preventDefault();\n        this.focusFirstElement();\n      }\n\n      return;\n    }\n\n    let currentIndex = this.adapter.getFocusedElementIndex();\n    if (currentIndex === -1) {\n      currentIndex = listItemIndex;\n      if (currentIndex < 0) {\n        // If this event doesn't have a mdc-deprecated-list-item ancestor from\n        // the current list (not from a sublist), return early.\n        return;\n      }\n    }\n\n    let nextIndex;\n    if ((this.isVertical_ && isArrowDown) ||\n        (!this.isVertical_ && isArrowRight)) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusNextElement(currentIndex);\n    } else if (\n        (this.isVertical_ && isArrowUp) || (!this.isVertical_ && isArrowLeft)) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusPrevElement(currentIndex);\n    } else if (isHome) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusFirstElement();\n    } else if (isEnd) {\n      this.preventDefaultEvent(event);\n      nextIndex = this.focusLastElement();\n    } else if (isEnter || isSpace) {\n      if (isRootListItem) {\n        // Return early if enter key is pressed on anchor element which triggers\n        // synthetic MouseEvent event.\n        const target = event.target as Element | null;\n        if (target && target.tagName === 'A' && isEnter) {\n          return;\n        }\n        this.preventDefaultEvent(event);\n        this.setSelectedIndexOnAction_(currentIndex, true);\n      }\n    }\n\n    this.focusedItemIndex_ = currentIndex;\n\n    if (nextIndex !== undefined) {\n      this.setTabindexAtIndex_(nextIndex);\n      this.focusedItemIndex_ = nextIndex;\n    }\n  }\n\n  /**\n   * Click handler for the list.\n   */\n  handleSingleSelection(\n      index: number, isInteraction: boolean, force?: boolean) {\n    if (index === numbers.UNSET_INDEX) {\n      return;\n    }\n\n    this.setSelectedIndexOnAction_(index, isInteraction, force);\n    this.setTabindexAtIndex_(index);\n    this.focusedItemIndex_ = index;\n  }\n\n  /**\n   * Focuses the next element on the list.\n   */\n  focusNextElement(index: number) {\n    const count = this.adapter.getListItemCount();\n    let nextIndex = index + 1;\n    if (nextIndex >= count) {\n      if (this.wrapFocus_) {\n        nextIndex = 0;\n      } else {\n        // Return early because last item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(nextIndex);\n\n    return nextIndex;\n  }\n\n  /**\n   * Focuses the previous element on the list.\n   */\n  focusPrevElement(index: number) {\n    let prevIndex = index - 1;\n    if (prevIndex < 0) {\n      if (this.wrapFocus_) {\n        prevIndex = this.adapter.getListItemCount() - 1;\n      } else {\n        // Return early because first item is already focused.\n        return index;\n      }\n    }\n    this.adapter.focusItemAtIndex(prevIndex);\n\n    return prevIndex;\n  }\n\n  focusFirstElement() {\n    this.adapter.focusItemAtIndex(0);\n    return 0;\n  }\n\n  focusLastElement() {\n    const lastIndex = this.adapter.getListItemCount() - 1;\n    this.adapter.focusItemAtIndex(lastIndex);\n    return lastIndex;\n  }\n\n  /**\n   * @param itemIndex Index of the list item\n   * @param isEnabled Sets the list item to enabled or disabled.\n   */\n  setEnabled(itemIndex: number, isEnabled: boolean): void {\n    if (!this.isIndexValid_(itemIndex)) {\n      return;\n    }\n\n    this.adapter.setDisabledStateForElementIndex(itemIndex, !isEnabled);\n  }\n\n  /**\n   * Ensures that preventDefault is only called if the containing element\n   * doesn't consume the event, and it will cause an unintended scroll.\n   */\n  private preventDefaultEvent(evt: KeyboardEvent) {\n    const target = evt.target as Element;\n    const tagName = `${target.tagName}`.toLowerCase();\n    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {\n      evt.preventDefault();\n    }\n  }\n\n  private setSingleSelectionAtIndex_(index: number, isInteraction = true) {\n    if (this.selectedIndex_ === index) {\n      return;\n    }\n\n    // unset previous\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setSelectedStateForElementIndex(\n          this.selectedIndex_ as number, false);\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(\n            this.selectedIndex_ as number, false);\n      }\n    }\n\n    // set new\n    if (isInteraction) {\n      this.adapter.setSelectedStateForElementIndex(index, true);\n    }\n    if (this.useActivatedClass_) {\n      this.adapter.setActivatedStateForElementIndex(index, true);\n    }\n    this.setAriaForSingleSelectionAtIndex_(index);\n\n    this.selectedIndex_ = index;\n\n    this.adapter.notifySelected(index);\n  }\n\n  private setMultiSelectionAtIndex_(\n      newIndex: Set<number>, isInteraction = true) {\n    const oldIndex = createSetFromIndex(this.selectedIndex_);\n    const diff = findIndexDiff(oldIndex, newIndex);\n\n    if (!diff.removed.length && !diff.added.length) {\n      return;\n    }\n\n    for (const removed of diff.removed) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(removed, false);\n      }\n\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(removed, false);\n      }\n    }\n\n    for (const added of diff.added) {\n      if (isInteraction) {\n        this.adapter.setSelectedStateForElementIndex(added, true);\n      }\n\n      if (this.useActivatedClass_) {\n        this.adapter.setActivatedStateForElementIndex(added, true);\n      }\n    }\n\n    this.selectedIndex_ = newIndex;\n\n    this.adapter.notifySelected(newIndex, diff);\n  }\n\n  /**\n   * Sets aria attribute for single selection at given index.\n   */\n  private setAriaForSingleSelectionAtIndex_(index: number) {\n    // Detect the presence of aria-current and get the value only during list\n    // initialization when it is in unset state.\n    if (this.selectedIndex_ === numbers.UNSET_INDEX) {\n      this.ariaCurrentAttrValue_ =\n          this.adapter.getAttributeForElementIndex(index, strings.ARIA_CURRENT);\n    }\n\n    const isAriaCurrent = this.ariaCurrentAttrValue_ !== null;\n    const ariaAttribute =\n        isAriaCurrent ? strings.ARIA_CURRENT : strings.ARIA_SELECTED;\n\n    if (this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      this.adapter.setAttributeForElementIndex(\n          this.selectedIndex_ as number, ariaAttribute, 'false');\n    }\n\n    const ariaAttributeValue =\n        isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';\n    this.adapter.setAttributeForElementIndex(\n        index, ariaAttribute, ariaAttributeValue as string);\n  }\n\n  private setTabindexAtIndex_(index: number) {\n    if (this.focusedItemIndex_ === numbers.UNSET_INDEX && index !== 0) {\n      // If no list item was selected set first list item's tabindex to -1.\n      // Generally, tabindex is set to 0 on first list item of list that has no\n      // preselected items.\n      this.adapter.setTabIndexForElementIndex(0, -1);\n    } else if (\n        this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {\n      this.adapter.setTabIndexForElementIndex(this.focusedItemIndex_, -1);\n    }\n\n    this.adapter.setTabIndexForElementIndex(index, 0);\n  }\n\n  private setTabindexToFirstSelectedItem_() {\n    let targetIndex = 0;\n\n    if (typeof this.selectedIndex_ === 'number' &&\n        this.selectedIndex_ !== numbers.UNSET_INDEX) {\n      targetIndex = this.selectedIndex_;\n    } else if (\n        isIndexSet(this.selectedIndex_) && this.selectedIndex_.size > 0) {\n      targetIndex = Math.min(...this.selectedIndex_);\n    }\n\n    this.setTabindexAtIndex_(targetIndex);\n  }\n\n  private isIndexValid_(index: MWCListIndex) {\n    if (index instanceof Set) {\n      if (!this.isMulti_) {\n        throw new Error(\n            'MDCListFoundation: Array of index is only supported for checkbox based list');\n      }\n\n      if (index.size === 0) {\n        return true;\n      } else {\n        let isOneInRange = false;\n\n        for (const entry of index) {\n          isOneInRange = this.isIndexInRange_(entry);\n\n          if (isOneInRange) {\n            break;\n          }\n        }\n\n        return isOneInRange;\n      }\n    } else if (typeof index === 'number') {\n      if (this.isMulti_) {\n        throw new Error(\n            'MDCListFoundation: Expected array of index for checkbox based list but got number: ' +\n            index);\n      }\n      return index === numbers.UNSET_INDEX || this.isIndexInRange_(index);\n    } else {\n      return false;\n    }\n  }\n\n  private isIndexInRange_(index: number) {\n    const listSize = this.adapter.getListItemCount();\n    return index >= 0 && index < listSize;\n  }\n\n  /**\n   * Sets selected index on user action, toggles checkbox / radio based on\n   * toggleCheckbox value. User interaction should not toggle list item(s) when\n   * disabled.\n   */\n  private setSelectedIndexOnAction_(\n      index: number, isInteraction: boolean, force?: boolean) {\n    if (this.adapter.getDisabledStateForElementIndex(index)) {\n      return;\n    }\n\n    let checkedIndex: MWCListIndex = index;\n\n    if (this.isMulti_) {\n      checkedIndex = new Set([index]);\n    }\n\n    if (!this.isIndexValid_(checkedIndex)) {\n      return;\n    }\n\n    if (this.isMulti_) {\n      this.toggleMultiAtIndex(index, force, isInteraction);\n    } else {\n      if (isInteraction || force) {\n        this.setSingleSelectionAtIndex_(index, isInteraction);\n      } else {\n        const isDeselection = this.selectedIndex_ === index;\n        if (isDeselection) {\n          this.setSingleSelectionAtIndex_(numbers.UNSET_INDEX);\n        }\n      }\n    }\n\n    if (isInteraction) {\n      this.adapter.notifyAction(index);\n    }\n  }\n\n  toggleMultiAtIndex(index: number, force?: boolean, isInteraction = true) {\n    let newSelectionValue = false;\n\n    if (force === undefined) {\n      newSelectionValue = !this.adapter.getSelectedStateForElementIndex(index);\n    } else {\n      newSelectionValue = force;\n    }\n\n    const newSet = createSetFromIndex(this.selectedIndex_);\n\n    if (newSelectionValue) {\n      newSet.add(index);\n    } else {\n      newSet.delete(index);\n    }\n\n    this.setMultiSelectionAtIndex_(newSet, isInteraction);\n  }\n}\n\n// tslint:disable-next-line:no-default-export Needed for backward compatibility\n// with MDC Web v0.44.0 and earlier.\nexport default MDCListFoundation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}