{"ast":null,"code":"const generateStateHistory = (state, deltas, start_date, end_date) => {\n  const changes = typeof deltas[0] === \"object\" ? deltas : deltas.map(st => ({\n    state: st\n  }));\n  const timeDiff = (end_date.getTime() - start_date.getTime()) / changes.length;\n  return changes.map((change, index) => {\n    let attributes;\n    if (!change.attributes && !state.attributes) {\n      attributes = {};\n    } else if (!change.attributes) {\n      attributes = state.attributes;\n    } else if (!state.attributes) {\n      attributes = change.attributes;\n    } else {\n      attributes = {\n        ...state.attributes,\n        ...change.attributes\n      };\n    }\n    const time = start_date.getTime() + timeDiff * index;\n    return {\n      a: attributes,\n      s: change.state || state.state,\n      lc: time / 1000,\n      lu: time / 1000\n    };\n  });\n};\nconst incrementalUnits = [\"clients\", \"queries\", \"ads\"];\nexport const mockHistory = mockHass => {\n  mockHass.mockWS(\"history/stream\", ({\n    entity_ids,\n    start_time,\n    end_time\n  }, hass, onChange) => {\n    const states = {};\n    const start = new Date(start_time);\n    const end = end_time ? new Date(end_time) : new Date();\n    for (const entityId of entity_ids) {\n      states[entityId] = [];\n      const state = hass.states[entityId];\n      if (!state) {\n        continue;\n      }\n      if (!state.attributes.unit_of_measurement) {\n        states[entityId] = generateStateHistory(state, [state.state], start, end);\n        continue;\n      }\n      const numberState = Number(state.state);\n      if (isNaN(numberState)) {\n        // eslint-disable-next-line no-console\n        console.log(\"Ignoring state with unparsable state but with a unit\", entityId, state);\n        continue;\n      }\n      const statesToGenerate = 15;\n      let genFunc;\n      if (incrementalUnits.includes(state.attributes.unit_of_measurement)) {\n        let initial = Math.floor(numberState * 0.4 + numberState * Math.random() * 0.2);\n        const diff = Math.max(1, Math.floor((numberState - initial) / statesToGenerate));\n        genFunc = () => {\n          initial += diff;\n          return Math.min(numberState, initial);\n        };\n      } else {\n        const diff = Math.floor(numberState * (numberState > 80 ? 0.05 : 0.5));\n        genFunc = () => numberState - diff + Math.floor(Math.random() * 2 * diff);\n      }\n      states[entityId] = generateStateHistory(state, Array.from({\n        length: statesToGenerate\n      }, genFunc), start, end);\n    }\n    setTimeout(() => {\n      onChange === null || onChange === void 0 || onChange({\n        states,\n        start_time: start,\n        end_time: end\n      });\n    }, 1);\n    return () => {};\n  });\n};","map":{"version":3,"names":["generateStateHistory","state","deltas","start_date","end_date","changes","map","st","timeDiff","getTime","length","change","index","attributes","time","a","s","lc","lu","incrementalUnits","mockHistory","mockHass","mockWS","entity_ids","start_time","end_time","hass","onChange","states","start","Date","end","entityId","unit_of_measurement","numberState","Number","isNaN","console","log","statesToGenerate","genFunc","includes","initial","Math","floor","random","diff","max","min","Array","from","setTimeout"],"sources":["/workspaces/frontend/demo/src/stubs/history.ts"],"sourcesContent":["import { HassEntity } from \"home-assistant-js-websocket\";\nimport { HistoryStates } from \"../../../src/data/history\";\nimport { MockHomeAssistant } from \"../../../src/fake_data/provide_hass\";\n\nconst generateStateHistory = (\n  state: HassEntity,\n  deltas,\n  start_date: Date,\n  end_date: Date\n) => {\n  const changes =\n    typeof deltas[0] === \"object\"\n      ? deltas\n      : deltas.map((st) => ({ state: st }));\n\n  const timeDiff = (end_date.getTime() - start_date.getTime()) / changes.length;\n\n  return changes.map((change, index) => {\n    let attributes;\n    if (!change.attributes && !state.attributes) {\n      attributes = {};\n    } else if (!change.attributes) {\n      attributes = state.attributes;\n    } else if (!state.attributes) {\n      attributes = change.attributes;\n    } else {\n      attributes = { ...state.attributes, ...change.attributes };\n    }\n\n    const time = start_date.getTime() + timeDiff * index;\n\n    return {\n      a: attributes,\n      s: change.state || state.state,\n      lc: time / 1000,\n      lu: time / 1000,\n    };\n  });\n};\n\nconst incrementalUnits = [\"clients\", \"queries\", \"ads\"];\n\nexport const mockHistory = (mockHass: MockHomeAssistant) => {\n  mockHass.mockWS(\n    \"history/stream\",\n    (\n      {\n        entity_ids,\n        start_time,\n        end_time,\n      }: {\n        entity_ids: string[];\n        start_time: string;\n        end_time?: string;\n      },\n      hass,\n      onChange\n    ) => {\n      const states: HistoryStates = {};\n\n      const start = new Date(start_time);\n      const end = end_time ? new Date(end_time) : new Date();\n\n      for (const entityId of entity_ids) {\n        states[entityId] = [];\n\n        const state = hass.states[entityId];\n\n        if (!state) {\n          continue;\n        }\n\n        if (!state.attributes.unit_of_measurement) {\n          states[entityId] = generateStateHistory(\n            state,\n            [state.state],\n            start,\n            end\n          );\n          continue;\n        }\n\n        const numberState = Number(state.state);\n\n        if (isNaN(numberState)) {\n          // eslint-disable-next-line no-console\n          console.log(\n            \"Ignoring state with unparsable state but with a unit\",\n            entityId,\n            state\n          );\n          continue;\n        }\n\n        const statesToGenerate = 15;\n        let genFunc;\n\n        if (incrementalUnits.includes(state.attributes.unit_of_measurement)) {\n          let initial = Math.floor(\n            numberState * 0.4 + numberState * Math.random() * 0.2\n          );\n          const diff = Math.max(\n            1,\n            Math.floor((numberState - initial) / statesToGenerate)\n          );\n          genFunc = () => {\n            initial += diff;\n            return Math.min(numberState, initial);\n          };\n        } else {\n          const diff = Math.floor(\n            numberState * (numberState > 80 ? 0.05 : 0.5)\n          );\n          genFunc = () =>\n            numberState - diff + Math.floor(Math.random() * 2 * diff);\n        }\n\n        states[entityId] = generateStateHistory(\n          state,\n          Array.from({ length: statesToGenerate }, genFunc),\n          start,\n          end\n        );\n      }\n\n      setTimeout(() => {\n        onChange?.({\n          states,\n          start_time: start,\n          end_time: end,\n        });\n      }, 1);\n\n      return () => {};\n    }\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}