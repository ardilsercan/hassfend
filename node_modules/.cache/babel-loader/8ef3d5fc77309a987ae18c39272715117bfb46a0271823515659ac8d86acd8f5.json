{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport { fuzzyScore } from \"./filter\";\n\n/**\n * Determine whether a sequence of letters exists in another string,\n *   in that order, allowing for skipping. Ex: \"chdr\" exists in \"chandelier\")\n *\n * @param {string} filter - Sequence of letters to check for\n * @param {ScorableTextItem} item - Item against whose strings will be checked\n *\n * @return {number} Score representing how well the word matches the filter. Return of 0 means no match.\n */\n\nexport var fuzzySequentialMatch = function fuzzySequentialMatch(filter, item) {\n  var topScore = Number.NEGATIVE_INFINITY;\n  var _iterator = _createForOfIteratorHelper(item.strings),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var word = _step.value;\n      var scores = fuzzyScore(filter, filter.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n      if (!scores) {\n        continue;\n      }\n\n      // The VS Code implementation of filter returns a 0 for a weak match.\n      // But if .filter() sees a \"0\", it considers that a failed match and will remove it.\n      // So, we set score to 1 in these cases so the match will be included, and mostly respect correct ordering.\n      var score = scores[0] === 0 ? 1 : scores[0];\n      if (score > topScore) {\n        topScore = score;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (topScore === Number.NEGATIVE_INFINITY) {\n    return undefined;\n  }\n  return topScore;\n};\n\n/**\n * An interface that objects must extend in order to use the fuzzy sequence matcher\n *\n * @param {number} score - A number representing the existence and strength of a match.\n *    - `< 0` means a good match that starts in the middle of the string\n *    - `> 0` means a good match that starts at the beginning of the string\n *    - `0` means just barely a match\n *    - `undefined` means not a match\n *\n * @param {string} strings - Array of strings (aliases) representing the item. The filter string will be compared against each of these for a match.\n *\n */\n\nexport var fuzzyFilterSort = function fuzzyFilterSort(filter, items) {\n  return items.map(function (item) {\n    item.score = fuzzySequentialMatch(filter, item);\n    return item;\n  }).filter(function (item) {\n    return item.score !== undefined;\n  }).sort(function (_ref, _ref2) {\n    var _ref$score = _ref.score,\n      scoreA = _ref$score === void 0 ? 0 : _ref$score;\n    var _ref2$score = _ref2.score,\n      scoreB = _ref2$score === void 0 ? 0 : _ref2$score;\n    return scoreA > scoreB ? -1 : scoreA < scoreB ? 1 : 0;\n  });\n};","map":{"version":3,"names":["fuzzyScore","fuzzySequentialMatch","filter","item","topScore","Number","NEGATIVE_INFINITY","_iterator","_createForOfIteratorHelper","strings","_step","s","n","done","word","value","scores","toLowerCase","score","err","e","f","undefined","fuzzyFilterSort","items","map","sort","_ref","_ref2","_ref$score","scoreA","_ref2$score","scoreB"],"sources":["/Users/sercanardil/Desktop/frontend/src/common/string/filter/sequence-matching.ts"],"sourcesContent":["import { fuzzyScore } from \"./filter\";\n\n/**\n * Determine whether a sequence of letters exists in another string,\n *   in that order, allowing for skipping. Ex: \"chdr\" exists in \"chandelier\")\n *\n * @param {string} filter - Sequence of letters to check for\n * @param {ScorableTextItem} item - Item against whose strings will be checked\n *\n * @return {number} Score representing how well the word matches the filter. Return of 0 means no match.\n */\n\nexport const fuzzySequentialMatch = (\n  filter: string,\n  item: ScorableTextItem\n) => {\n  let topScore = Number.NEGATIVE_INFINITY;\n\n  for (const word of item.strings) {\n    const scores = fuzzyScore(\n      filter,\n      filter.toLowerCase(),\n      0,\n      word,\n      word.toLowerCase(),\n      0,\n      true\n    );\n\n    if (!scores) {\n      continue;\n    }\n\n    // The VS Code implementation of filter returns a 0 for a weak match.\n    // But if .filter() sees a \"0\", it considers that a failed match and will remove it.\n    // So, we set score to 1 in these cases so the match will be included, and mostly respect correct ordering.\n    const score = scores[0] === 0 ? 1 : scores[0];\n\n    if (score > topScore) {\n      topScore = score;\n    }\n  }\n\n  if (topScore === Number.NEGATIVE_INFINITY) {\n    return undefined;\n  }\n\n  return topScore;\n};\n\n/**\n * An interface that objects must extend in order to use the fuzzy sequence matcher\n *\n * @param {number} score - A number representing the existence and strength of a match.\n *    - `< 0` means a good match that starts in the middle of the string\n *    - `> 0` means a good match that starts at the beginning of the string\n *    - `0` means just barely a match\n *    - `undefined` means not a match\n *\n * @param {string} strings - Array of strings (aliases) representing the item. The filter string will be compared against each of these for a match.\n *\n */\n\nexport interface ScorableTextItem {\n  score?: number;\n  strings: string[];\n}\n\ntype FuzzyFilterSort = <T extends ScorableTextItem>(\n  filter: string,\n  items: T[]\n) => T[];\n\nexport const fuzzyFilterSort: FuzzyFilterSort = (filter, items) =>\n  items\n    .map((item) => {\n      item.score = fuzzySequentialMatch(filter, item);\n      return item;\n    })\n    .filter((item) => item.score !== undefined)\n    .sort(({ score: scoreA = 0 }, { score: scoreB = 0 }) =>\n      scoreA > scoreB ? -1 : scoreA < scoreB ? 1 : 0\n    );\n"],"mappings":";;;;;;;;;AAAA,SAASA,UAAU,QAAQ,UAAU;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAC/BC,MAAc,EACdC,IAAsB,EACnB;EACH,IAAIC,QAAQ,GAAGC,MAAM,CAACC,iBAAiB;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CAErBL,IAAI,CAACM,OAAO;IAAAC,KAAA;EAAA;IAA/B,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAAiC;MAAA,IAAtBC,IAAI,GAAAJ,KAAA,CAAAK,KAAA;MACb,IAAMC,MAAM,GAAGhB,UAAU,CACvBE,MAAM,EACNA,MAAM,CAACe,WAAW,CAAC,CAAC,EACpB,CAAC,EACDH,IAAI,EACJA,IAAI,CAACG,WAAW,CAAC,CAAC,EAClB,CAAC,EACD,IACF,CAAC;MAED,IAAI,CAACD,MAAM,EAAE;QACX;MACF;;MAEA;MACA;MACA;MACA,IAAME,KAAK,GAAGF,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;MAE7C,IAAIE,KAAK,GAAGd,QAAQ,EAAE;QACpBA,QAAQ,GAAGc,KAAK;MAClB;IACF;EAAC,SAAAC,GAAA;IAAAZ,SAAA,CAAAa,CAAA,CAAAD,GAAA;EAAA;IAAAZ,SAAA,CAAAc,CAAA;EAAA;EAED,IAAIjB,QAAQ,KAAKC,MAAM,CAACC,iBAAiB,EAAE;IACzC,OAAOgB,SAAS;EAClB;EAEA,OAAOlB,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAYA,OAAO,IAAMmB,eAAgC,GAAG,SAAnCA,eAAgCA,CAAIrB,MAAM,EAAEsB,KAAK;EAAA,OAC5DA,KAAK,CACFC,GAAG,CAAC,UAACtB,IAAI,EAAK;IACbA,IAAI,CAACe,KAAK,GAAGjB,oBAAoB,CAACC,MAAM,EAAEC,IAAI,CAAC;IAC/C,OAAOA,IAAI;EACb,CAAC,CAAC,CACDD,MAAM,CAAC,UAACC,IAAI;IAAA,OAAKA,IAAI,CAACe,KAAK,KAAKI,SAAS;EAAA,EAAC,CAC1CI,IAAI,CAAC,UAAAC,IAAA,EAAAC,KAAA;IAAA,IAAAC,UAAA,GAAAF,IAAA,CAAGT,KAAK;MAAEY,MAAM,GAAAD,UAAA,cAAG,CAAC,GAAAA,UAAA;IAAA,IAAAE,WAAA,GAAAH,KAAA,CAAMV,KAAK;MAAEc,MAAM,GAAAD,WAAA,cAAG,CAAC,GAAAA,WAAA;IAAA,OAC/CD,MAAM,GAAGE,MAAM,GAAG,CAAC,CAAC,GAAGF,MAAM,GAAGE,MAAM,GAAG,CAAC,GAAG,CAAC;EAAA,CAChD,CAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}