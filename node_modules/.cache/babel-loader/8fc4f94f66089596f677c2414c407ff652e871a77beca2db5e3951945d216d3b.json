{"ast":null,"code":"import { clear, get, set, createStore, promisifyRequest } from \"idb-keyval\";\nimport { promiseTimeout } from \"../common/util/promise-timeout\";\nimport { iconMetadata } from \"../resources/icon-metadata\";\nexport const iconStore = createStore(\"hass-icon-db\", \"mdi-icon-store\");\nexport const MDI_PREFIXES = [\"mdi\", \"hass\", \"hassio\", \"hademo\"];\nlet toRead = [];\n\n// Queue up as many icon fetches in 1 transaction\nexport const getIcon = iconName => new Promise((resolve, reject) => {\n  toRead.push([iconName, resolve, reject]);\n  if (toRead.length > 1) {\n    return;\n  }\n  const readIcons = () => iconStore(\"readonly\", store => {\n    for (const [iconName_, resolve_, reject_] of toRead) {\n      promisifyRequest(store.get(iconName_)).then(icon => resolve_(icon)).catch(e => reject_(e));\n    }\n    toRead = [];\n  });\n  promiseTimeout(1000, readIcons()).catch(e => {\n    // Firefox in private mode doesn't support IDB\n    // Safari sometime doesn't open the DB so we time out\n    for (const [,, reject_] of toRead) {\n      reject_(e);\n    }\n    toRead = [];\n  });\n});\nexport const findIconChunk = icon => {\n  let lastChunk;\n  for (const chunk of iconMetadata.parts) {\n    if (chunk.start !== undefined && icon < chunk.start) {\n      break;\n    }\n    lastChunk = chunk;\n  }\n  return lastChunk.file;\n};\nexport const writeCache = async chunks => {\n  const keys = Object.keys(chunks);\n  const iconsSets = await Promise.all(Object.values(chunks));\n  // We do a batch opening the store just once, for (considerable) performance\n  iconStore(\"readwrite\", store => {\n    iconsSets.forEach((icons, idx) => {\n      Object.entries(icons).forEach(([name, path]) => {\n        store.put(path, name);\n      });\n      delete chunks[keys[idx]];\n    });\n  });\n};\nexport const checkCacheVersion = async () => {\n  const version = await get(\"_version\", iconStore);\n  if (!version) {\n    set(\"_version\", iconMetadata.version, iconStore);\n  } else if (version !== iconMetadata.version) {\n    await clear(iconStore);\n    set(\"_version\", iconMetadata.version, iconStore);\n  }\n};","map":{"version":3,"names":["clear","get","set","createStore","promisifyRequest","promiseTimeout","iconMetadata","iconStore","MDI_PREFIXES","toRead","getIcon","iconName","Promise","resolve","reject","push","length","readIcons","store","iconName_","resolve_","reject_","then","icon","catch","e","findIconChunk","lastChunk","chunk","parts","start","undefined","file","writeCache","chunks","keys","Object","iconsSets","all","values","forEach","icons","idx","entries","name","path","put","checkCacheVersion","version"],"sources":["/workspaces/frontend/src/data/iconsets.ts"],"sourcesContent":["import { clear, get, set, createStore, promisifyRequest } from \"idb-keyval\";\nimport { promiseTimeout } from \"../common/util/promise-timeout\";\nimport { iconMetadata } from \"../resources/icon-metadata\";\nimport { IconMeta } from \"../types\";\n\nexport interface Icons {\n  [key: string]: string;\n}\n\nexport interface Chunks {\n  [key: string]: Promise<Icons>;\n}\n\nexport const iconStore = createStore(\"hass-icon-db\", \"mdi-icon-store\");\n\nexport const MDI_PREFIXES = [\"mdi\", \"hass\", \"hassio\", \"hademo\"];\n\nlet toRead: Array<\n  [string, (iconPath: string | undefined) => void, (e: any) => void]\n> = [];\n\n// Queue up as many icon fetches in 1 transaction\nexport const getIcon = (iconName: string) =>\n  new Promise<string | undefined>((resolve, reject) => {\n    toRead.push([iconName, resolve, reject]);\n\n    if (toRead.length > 1) {\n      return;\n    }\n\n    const readIcons = () =>\n      iconStore(\"readonly\", (store) => {\n        for (const [iconName_, resolve_, reject_] of toRead) {\n          promisifyRequest<string | undefined>(store.get(iconName_))\n            .then((icon) => resolve_(icon))\n            .catch((e) => reject_(e));\n        }\n        toRead = [];\n      });\n\n    promiseTimeout(1000, readIcons()).catch((e) => {\n      // Firefox in private mode doesn't support IDB\n      // Safari sometime doesn't open the DB so we time out\n      for (const [, , reject_] of toRead) {\n        reject_(e);\n      }\n      toRead = [];\n    });\n  });\n\nexport const findIconChunk = (icon: string): string => {\n  let lastChunk: IconMeta;\n  for (const chunk of iconMetadata.parts) {\n    if (chunk.start !== undefined && icon < chunk.start) {\n      break;\n    }\n    lastChunk = chunk;\n  }\n  return lastChunk!.file;\n};\n\nexport const writeCache = async (chunks: Chunks) => {\n  const keys = Object.keys(chunks);\n  const iconsSets: Icons[] = await Promise.all(Object.values(chunks));\n  // We do a batch opening the store just once, for (considerable) performance\n  iconStore(\"readwrite\", (store) => {\n    iconsSets.forEach((icons, idx) => {\n      Object.entries(icons).forEach(([name, path]) => {\n        store.put(path, name);\n      });\n      delete chunks[keys[idx]];\n    });\n  });\n};\n\nexport const checkCacheVersion = async () => {\n  const version = await get(\"_version\", iconStore);\n\n  if (!version) {\n    set(\"_version\", iconMetadata.version, iconStore);\n  } else if (version !== iconMetadata.version) {\n    await clear(iconStore);\n    set(\"_version\", iconMetadata.version, iconStore);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}