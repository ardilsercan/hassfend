{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js';\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nvar nativeProperties = {};\nvar proto = HTMLElement.prototype;\nwhile (proto) {\n  var props = Object.getOwnPropertyNames(proto);\n  for (var i = 0; i < props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\nvar isTrustedType = function () {\n  if (!window.trustedTypes) {\n    return function () {\n      return false;\n    };\n  }\n  return function (val) {\n    return trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\n  };\n}();\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    var value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport var PropertyAccessors = dedupingMixin(function (superClass) {\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n  var base = PropertiesChanged(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  var PropertyAccessors = /*#__PURE__*/function (_base) {\n    _inherits(PropertyAccessors, _base);\n    function PropertyAccessors() {\n      _classCallCheck(this, PropertyAccessors);\n      return _callSuper(this, PropertyAccessors, arguments);\n    }\n    _createClass(PropertyAccessors, [{\n      key: \"_initializeProperties\",\n      value:\n      /**\n       * Overrides PropertiesChanged implementation to initialize values for\n       * accessors created for values that already existed on the element\n       * prototype.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n      function _initializeProperties() {\n        if (this.__dataProto) {\n          this._initializeProtoProperties(this.__dataProto);\n          this.__dataProto = null;\n        }\n        _get(_getPrototypeOf(PropertyAccessors.prototype), \"_initializeProperties\", this).call(this);\n      }\n\n      /**\n       * Called at instance time with bag of properties that were overwritten\n       * by accessors on the prototype when accessors were created.\n       *\n       * The default implementation sets these properties back into the\n       * setter at instance time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_initializeProtoProperties\",\n      value: function _initializeProtoProperties(props) {\n        for (var p in props) {\n          this._setProperty(p, props[p]);\n        }\n      }\n\n      /**\n       * Ensures the element has the given attribute. If it does not,\n       * assigns the given value to the attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n       *     element\n       *\n       * @param {string} attribute Name of attribute to ensure is set.\n       * @param {string} value of the attribute.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_ensureAttribute\",\n      value: function _ensureAttribute(attribute, value) {\n        var el = /** @type {!HTMLElement} */this;\n        if (!el.hasAttribute(attribute)) {\n          this._valueToNodeAttribute(el, value, attribute);\n        }\n      }\n\n      /**\n       * Overrides PropertiesChanged implemention to serialize objects as JSON.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided property\n       *     value.\n       * @override\n       */\n    }, {\n      key: \"_serializeValue\",\n      value: function _serializeValue(value) {\n        /* eslint-disable no-fallthrough */\n        switch (_typeof(value)) {\n          case 'object':\n            if (value instanceof Date) {\n              return value.toString();\n            } else if (value) {\n              if (isTrustedType(value)) {\n                /**\n                 * Here `value` isn't actually a string, but it should be\n                 * passed into APIs that normally expect a string, like\n                 * elem.setAttribute.\n                 */\n                return /** @type {?} */value;\n              }\n              try {\n                return JSON.stringify(value);\n              } catch (x) {\n                return '';\n              }\n            }\n          default:\n            return _get(_getPrototypeOf(PropertyAccessors.prototype), \"_serializeValue\", this).call(this, value);\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called by Polymer when reading HTML attribute values to\n       * JS properties.  Users may override this method on Polymer element\n       * prototypes to provide deserialization for custom `type`s.  Note,\n       * the `type` argument is the value of the `type` field provided in the\n       * `properties` configuration object for a given property, and is\n       * by convention the constructor for the type to deserialize.\n       *\n       *\n       * @param {?string} value Attribute value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       * @override\n       */\n    }, {\n      key: \"_deserializeValue\",\n      value: function _deserializeValue(value, type) {\n        /**\n         * @type {*}\n         */\n        var outValue;\n        switch (type) {\n          case Object:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              // allow non-JSON literals like Strings and Numbers\n              outValue = value;\n            }\n            break;\n          case Array:\n            try {\n              outValue = JSON.parse( /** @type {string} */value);\n            } catch (x) {\n              outValue = null;\n              console.warn(\"Polymer::Attributes: couldn't decode Array as JSON: \".concat(value));\n            }\n            break;\n          case Date:\n            outValue = isNaN(value) ? String(value) : Number(value);\n            outValue = new Date(outValue);\n            break;\n          default:\n            outValue = _get(_getPrototypeOf(PropertyAccessors.prototype), \"_deserializeValue\", this).call(this, value, type);\n            break;\n        }\n        return outValue;\n      }\n      /* eslint-enable no-fallthrough */\n\n      /**\n       * Overrides PropertiesChanged implementation to save existing prototype\n       * property value so that it can be reset.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       *\n       * When calling on a prototype, any overwritten values are saved in\n       * `__dataProto`, and it is up to the subclasser to decide how/when\n       * to set those properties back into the accessor.  When calling on an\n       * instance, the overwritten value is set via `_setPendingProperty`,\n       * and the user should call `_invalidateProperties` or `_flushProperties`\n       * for the values to take effect.\n       * @protected\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_definePropertyAccessor\",\n      value: function _definePropertyAccessor(property, readOnly) {\n        saveAccessorValue(this, property);\n        _get(_getPrototypeOf(PropertyAccessors.prototype), \"_definePropertyAccessor\", this).call(this, property, readOnly);\n      }\n\n      /**\n       * Returns true if this library created an accessor for the given property.\n       *\n       * @param {string} property Property name\n       * @return {boolean} True if an accessor was created\n       * @override\n       */\n    }, {\n      key: \"_hasAccessor\",\n      value: function _hasAccessor(property) {\n        return this.__dataHasAccessor && this.__dataHasAccessor[property];\n      }\n\n      /**\n       * Returns true if the specified property has a pending change.\n       *\n       * @param {string} prop Property name\n       * @return {boolean} True if property has a pending change\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_isPropertyPending\",\n      value: function _isPropertyPending(prop) {\n        return Boolean(this.__dataPending && prop in this.__dataPending);\n      }\n    }], [{\n      key: \"createPropertiesForAttributes\",\n      value:\n      /**\n       * Generates property accessors for all attributes in the standard\n       * static `observedAttributes` array.\n       *\n       * Attribute names are mapped to property names using the `dash-case` to\n       * `camelCase` convention\n       *\n       * @return {void}\n       * @nocollapse\n       */\n      function createPropertiesForAttributes() {\n        var a$ = /** @type {?} */this.observedAttributes;\n        for (var _i = 0; _i < a$.length; _i++) {\n          this.prototype._createPropertyAccessor(dashToCamelCase(a$[_i]));\n        }\n      }\n\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"attributeNameForProperty\",\n      value: function attributeNameForProperty(property) {\n        return camelToDashCase(property);\n      }\n    }]);\n    return PropertyAccessors;\n  }(base);\n  return PropertyAccessors;\n});","map":{"version":3,"names":["dedupingMixin","camelToDashCase","dashToCamelCase","PropertiesChanged","nativeProperties","proto","HTMLElement","prototype","props","Object","getOwnPropertyNames","i","length","getPrototypeOf","isTrustedType","window","trustedTypes","val","isHTML","isScript","isScriptURL","saveAccessorValue","model","property","value","undefined","__data","_setPendingProperty","__dataProto","hasOwnProperty","JSCompiler_renameProperty","create","PropertyAccessors","superClass","base","_base","_inherits","_classCallCheck","_callSuper","arguments","_createClass","key","_initializeProperties","_initializeProtoProperties","_get","_getPrototypeOf","call","p","_setProperty","_ensureAttribute","attribute","el","hasAttribute","_valueToNodeAttribute","_serializeValue","_typeof","Date","toString","JSON","stringify","x","_deserializeValue","type","outValue","parse","Array","console","warn","concat","isNaN","String","Number","_definePropertyAccessor","readOnly","_hasAccessor","__dataHasAccessor","_isPropertyPending","prop","Boolean","__dataPending","createPropertiesForAttributes","a$","observedAttributes","_createPropertyAccessor","attributeNameForProperty"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/mixins/property-accessors.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { camelToDashCase, dashToCamelCase } from '../utils/case-map.js';\nimport { PropertiesChanged } from './properties-changed.js';\n\n// Save map of native properties; this forms a blacklist or properties\n// that won't have their values \"saved\" by `saveAccessorValue`, since\n// reading from an HTMLElement accessor from the context of a prototype throws\nconst nativeProperties = {};\nlet proto = HTMLElement.prototype;\nwhile (proto) {\n  let props = Object.getOwnPropertyNames(proto);\n  for (let i=0; i<props.length; i++) {\n    nativeProperties[props[i]] = true;\n  }\n  proto = Object.getPrototypeOf(proto);\n}\n\nconst isTrustedType = (() => {\n  if (!window.trustedTypes) {\n    return () => false;\n  }\n  return (val) => trustedTypes.isHTML(val) ||\n        trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);\n})();\n\n/**\n * Used to save the value of a property that will be overridden with\n * an accessor. If the `model` is a prototype, the values will be saved\n * in `__dataProto`, and it's up to the user (or downstream mixin) to\n * decide how/when to set these values back into the accessors.\n * If `model` is already an instance (it has a `__data` property), then\n * the value will be set as a pending property, meaning the user should\n * call `_invalidateProperties` or `_flushProperties` to take effect\n *\n * @param {Object} model Prototype or instance\n * @param {string} property Name of property\n * @return {void}\n * @private\n */\nfunction saveAccessorValue(model, property) {\n  // Don't read/store value for any native properties since they could throw\n  if (!nativeProperties[property]) {\n    let value = model[property];\n    if (value !== undefined) {\n      if (model.__data) {\n        // Adding accessor to instance; update the property\n        // It is the user's responsibility to call _flushProperties\n        model._setPendingProperty(property, value);\n      } else {\n        // Adding accessor to proto; save proto's value for instance-time use\n        if (!model.__dataProto) {\n          model.__dataProto = {};\n        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {\n          model.__dataProto = Object.create(model.__dataProto);\n        }\n        model.__dataProto[property] = value;\n      }\n    }\n  }\n}\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin:\n *\n * -   Declare attributes to observe via the standard `static get\n *     observedAttributes()`. Use `dash-case` attribute names to represent\n *     `camelCase` property names.\n * -   Implement the `_propertiesChanged` callback on the class.\n * -   Call `MyClass.createPropertiesForAttributes()` **once** on the class to\n *     generate property accessors for each observed attribute. This must be\n *     called before the first instance is created, for example, by calling it\n *     before calling `customElements.define`. It can also be called lazily from\n *     the element's `constructor`, as long as it's guarded so that the call is\n *     only made once, when the first instance is created.\n * -   Call `this._enableProperties()` in the element's `connectedCallback` to\n *     enable the accessors.\n *\n * Any `observedAttributes` will automatically be\n * deserialized via `attributeChangedCallback` and set to the associated\n * property using `dash-case`-to-`camelCase` convention.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertiesChanged\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const PropertyAccessors = dedupingMixin(superClass => {\n\n  /**\n   * @constructor\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   * @private\n   */\n   const base = PropertiesChanged(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertyAccessors}\n   * @extends {base}\n   * @unrestricted\n   */\n  class PropertyAccessors extends base {\n\n    /**\n     * Generates property accessors for all attributes in the standard\n     * static `observedAttributes` array.\n     *\n     * Attribute names are mapped to property names using the `dash-case` to\n     * `camelCase` convention\n     *\n     * @return {void}\n     * @nocollapse\n     */\n    static createPropertiesForAttributes() {\n      let a$ =  /** @type {?} */ (this).observedAttributes;\n      for (let i=0; i < a$.length; i++) {\n        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i]));\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return camelToDashCase(property);\n    }\n\n    /**\n     * Overrides PropertiesChanged implementation to initialize values for\n     * accessors created for values that already existed on the element\n     * prototype.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      if (this.__dataProto) {\n        this._initializeProtoProperties(this.__dataProto);\n        this.__dataProto = null;\n      }\n      super._initializeProperties();\n    }\n\n    /**\n     * Called at instance time with bag of properties that were overwritten\n     * by accessors on the prototype when accessors were created.\n     *\n     * The default implementation sets these properties back into the\n     * setter at instance time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProtoProperties(props) {\n      for (let p in props) {\n        this._setProperty(p, props[p]);\n      }\n    }\n\n    /**\n     * Ensures the element has the given attribute. If it does not,\n     * assigns the given value to the attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is infact an\n     *     element\n     *\n     * @param {string} attribute Name of attribute to ensure is set.\n     * @param {string} value of the attribute.\n     * @return {void}\n     * @override\n     */\n    _ensureAttribute(attribute, value) {\n      const el = /** @type {!HTMLElement} */(this);\n      if (!el.hasAttribute(attribute)) {\n        this._valueToNodeAttribute(el, value, attribute);\n      }\n    }\n\n    /**\n     * Overrides PropertiesChanged implemention to serialize objects as JSON.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided property\n     *     value.\n     * @override\n     */\n    _serializeValue(value) {\n      /* eslint-disable no-fallthrough */\n      switch (typeof value) {\n        case 'object':\n          if (value instanceof Date) {\n            return value.toString();\n          } else if (value) {\n            if (isTrustedType(value)) {\n              /**\n               * Here `value` isn't actually a string, but it should be\n               * passed into APIs that normally expect a string, like\n               * elem.setAttribute.\n               */\n              return /** @type {?} */ (value);\n            }\n            try {\n              return JSON.stringify(value);\n            } catch(x) {\n              return '';\n            }\n          }\n\n        default:\n          return super._serializeValue(value);\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called by Polymer when reading HTML attribute values to\n     * JS properties.  Users may override this method on Polymer element\n     * prototypes to provide deserialization for custom `type`s.  Note,\n     * the `type` argument is the value of the `type` field provided in the\n     * `properties` configuration object for a given property, and is\n     * by convention the constructor for the type to deserialize.\n     *\n     *\n     * @param {?string} value Attribute value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      /**\n       * @type {*}\n       */\n      let outValue;\n      switch (type) {\n        case Object:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            // allow non-JSON literals like Strings and Numbers\n            outValue = value;\n          }\n          break;\n        case Array:\n          try {\n            outValue = JSON.parse(/** @type {string} */(value));\n          } catch(x) {\n            outValue = null;\n            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);\n          }\n          break;\n        case Date:\n          outValue = isNaN(value) ? String(value) : Number(value);\n          outValue = new Date(outValue);\n          break;\n        default:\n          outValue = super._deserializeValue(value, type);\n          break;\n      }\n      return outValue;\n    }\n    /* eslint-enable no-fallthrough */\n\n    /**\n     * Overrides PropertiesChanged implementation to save existing prototype\n     * property value so that it can be reset.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     *\n     * When calling on a prototype, any overwritten values are saved in\n     * `__dataProto`, and it is up to the subclasser to decide how/when\n     * to set those properties back into the accessor.  When calling on an\n     * instance, the overwritten value is set via `_setPendingProperty`,\n     * and the user should call `_invalidateProperties` or `_flushProperties`\n     * for the values to take effect.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _definePropertyAccessor(property, readOnly) {\n      saveAccessorValue(this, property);\n      super._definePropertyAccessor(property, readOnly);\n    }\n\n    /**\n     * Returns true if this library created an accessor for the given property.\n     *\n     * @param {string} property Property name\n     * @return {boolean} True if an accessor was created\n     * @override\n     */\n    _hasAccessor(property) {\n      return this.__dataHasAccessor && this.__dataHasAccessor[property];\n    }\n\n    /**\n     * Returns true if the specified property has a pending change.\n     *\n     * @param {string} prop Property name\n     * @return {boolean} True if property has a pending change\n     * @protected\n     * @override\n     */\n    _isPropertyPending(prop) {\n      return Boolean(this.__dataPending && (prop in this.__dataPending));\n    }\n\n  }\n\n  return PropertyAccessors;\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}