{"ast":null,"code":"import _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport var ScrollerShim = /*#__PURE__*/function () {\n  function ScrollerShim(element) {\n    _classCallCheck(this, ScrollerShim);\n    this._element = null;\n    var node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  _createClass(ScrollerShim, [{\n    key: \"element\",\n    get: function get() {\n      return this._element || document.scrollingElement || document.documentElement;\n    }\n  }, {\n    key: \"scrollTop\",\n    get: function get() {\n      return this.element.scrollTop || window.scrollY;\n    }\n  }, {\n    key: \"scrollLeft\",\n    get: function get() {\n      return this.element.scrollLeft || window.scrollX;\n    }\n  }, {\n    key: \"scrollHeight\",\n    get: function get() {\n      return this.element.scrollHeight;\n    }\n  }, {\n    key: \"scrollWidth\",\n    get: function get() {\n      return this.element.scrollWidth;\n    }\n  }, {\n    key: \"viewportHeight\",\n    get: function get() {\n      return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n    }\n  }, {\n    key: \"viewportWidth\",\n    get: function get() {\n      return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n    }\n  }, {\n    key: \"maxScrollTop\",\n    get: function get() {\n      return this.scrollHeight - this.viewportHeight;\n    }\n  }, {\n    key: \"maxScrollLeft\",\n    get: function get() {\n      return this.scrollWidth - this.viewportWidth;\n    }\n  }]);\n  return ScrollerShim;\n}();\nexport var ScrollerController = /*#__PURE__*/function (_ScrollerShim) {\n  _inherits(ScrollerController, _ScrollerShim);\n  function ScrollerController(client, element) {\n    var _this;\n    _classCallCheck(this, ScrollerController);\n    _this = _callSuper(this, ScrollerController, [element]);\n    _this._clients = new Set();\n    _this._retarget = null;\n    _this._end = null;\n    _this.__destination = null;\n    _this.correctingScrollError = false;\n    _this._checkForArrival = _this._checkForArrival.bind(_assertThisInitialized(_this));\n    _this._updateManagedScrollTo = _this._updateManagedScrollTo.bind(_assertThisInitialized(_this));\n    _this.scrollTo = _this.scrollTo.bind(_assertThisInitialized(_this));\n    _this.scrollBy = _this.scrollBy.bind(_assertThisInitialized(_this));\n    var node = _this._node;\n    _this._originalScrollTo = node.scrollTo;\n    _this._originalScrollBy = node.scrollBy;\n    _this._originalScroll = node.scroll;\n    _this._attach(client);\n    return _this;\n  }\n  _createClass(ScrollerController, [{\n    key: \"_destination\",\n    get: function get() {\n      return this.__destination;\n    }\n  }, {\n    key: \"scrolling\",\n    get: function get() {\n      return this._destination !== null;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(p1, p2) {\n      var options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n        left: p1,\n        top: p2\n      } : p1;\n      this._scrollTo(options);\n    }\n  }, {\n    key: \"scrollBy\",\n    value: function scrollBy(p1, p2) {\n      var options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n        left: p1,\n        top: p2\n      } : p1;\n      if (options.top !== undefined) {\n        options.top += this.scrollTop;\n      }\n      if (options.left !== undefined) {\n        options.left += this.scrollLeft;\n      }\n      this._scrollTo(options);\n    }\n  }, {\n    key: \"_nativeScrollTo\",\n    value: function _nativeScrollTo(options) {\n      this._originalScrollTo.bind(this._element || window)(options);\n    }\n  }, {\n    key: \"_scrollTo\",\n    value: function _scrollTo(options) {\n      var retarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (this._end !== null) {\n        this._end();\n      }\n      if (options.behavior === 'smooth') {\n        this._setDestination(options);\n        this._retarget = retarget;\n        this._end = end;\n      } else {\n        this._resetScrollState();\n      }\n      this._nativeScrollTo(options);\n    }\n  }, {\n    key: \"_setDestination\",\n    value: function _setDestination(options) {\n      var top = options.top,\n        left = options.left;\n      top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n      left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n      if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n        return false;\n      }\n      this.__destination = {\n        top: top,\n        left: left,\n        behavior: 'smooth'\n      };\n      return true;\n    }\n  }, {\n    key: \"_resetScrollState\",\n    value: function _resetScrollState() {\n      this.__destination = null;\n      this._retarget = null;\n      this._end = null;\n    }\n  }, {\n    key: \"_updateManagedScrollTo\",\n    value: function _updateManagedScrollTo(coordinates) {\n      if (this._destination) {\n        if (this._setDestination(coordinates)) {\n          this._nativeScrollTo(this._destination);\n        }\n      }\n    }\n  }, {\n    key: \"managedScrollTo\",\n    value: function managedScrollTo(options, retarget, end) {\n      this._scrollTo(options, retarget, end);\n      return this._updateManagedScrollTo;\n    }\n  }, {\n    key: \"correctScrollError\",\n    value: function correctScrollError(coordinates) {\n      var _this2 = this;\n      this.correctingScrollError = true;\n      requestAnimationFrame(function () {\n        return requestAnimationFrame(function () {\n          return _this2.correctingScrollError = false;\n        });\n      });\n      // Correct the error\n      this._nativeScrollTo(coordinates);\n      // Then, if we were headed for a specific destination, we continue scrolling:\n      // First, we update our target destination, if applicable...\n      if (this._retarget) {\n        this._setDestination(this._retarget());\n      }\n      // Then we go ahead and resume scrolling\n      if (this._destination) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }, {\n    key: \"_checkForArrival\",\n    value: function _checkForArrival() {\n      if (this._destination !== null) {\n        var scrollTop = this.scrollTop,\n          scrollLeft = this.scrollLeft;\n        var _this$_destination = this._destination,\n          top = _this$_destination.top,\n          left = _this$_destination.left;\n        top = Math.min(top || 0, this.maxScrollTop);\n        left = Math.min(left || 0, this.maxScrollLeft);\n        var topDiff = Math.abs(top - scrollTop);\n        var leftDiff = Math.abs(left - scrollLeft);\n        // We check to see if we've arrived at our destination.\n        if (topDiff < 1 && leftDiff < 1) {\n          if (this._end) {\n            this._end();\n          }\n          this._resetScrollState();\n        }\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(client) {\n      this._clients.delete(client);\n      /**\n       * If there aren't any more clients, then return the node's default\n       * scrolling methods\n       */\n      if (this._clients.size === 0) {\n        this._node.scrollTo = this._originalScrollTo;\n        this._node.scrollBy = this._originalScrollBy;\n        this._node.scroll = this._originalScroll;\n        this._node.removeEventListener('scroll', this._checkForArrival);\n      }\n      return null;\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach(client) {\n      this._clients.add(client);\n      /**\n       * The node should only have the methods shimmed when adding the first\n       * client â€“ otherwise it's redundant\n       */\n      if (this._clients.size === 1) {\n        this._node.scrollTo = this.scrollTo;\n        this._node.scrollBy = this.scrollBy;\n        this._node.scroll = this.scrollTo;\n        this._node.addEventListener('scroll', this._checkForArrival);\n      }\n    }\n  }]);\n  return ScrollerController;\n}(ScrollerShim);","map":{"version":3,"names":["ScrollerShim","element","_classCallCheck","_element","node","window","_node","_createClass","key","get","document","scrollingElement","documentElement","scrollTop","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","getBoundingClientRect","height","innerHeight","width","innerWidth","viewportHeight","viewportWidth","ScrollerController","_ScrollerShim","_inherits","client","_this","_callSuper","_clients","Set","_retarget","_end","__destination","correctingScrollError","_checkForArrival","bind","_assertThisInitialized","_updateManagedScrollTo","scrollTo","scrollBy","_originalScrollTo","_originalScrollBy","_originalScroll","scroll","_attach","_destination","value","p1","p2","options","left","top","_scrollTo","undefined","_nativeScrollTo","retarget","arguments","length","end","behavior","_setDestination","_resetScrollState","Math","max","min","maxScrollTop","maxScrollLeft","coordinates","managedScrollTo","correctScrollError","_this2","requestAnimationFrame","_this$_destination","topDiff","abs","leftDiff","detach","delete","size","removeEventListener","add","addEventListener"],"sources":["src/ScrollerController.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ScrollToCoordinates} from './layouts/shared/Layout.js';\n\ntype retargetScrollCallback = () => ScrollToCoordinates;\ntype endScrollCallback = () => void;\ntype Nullable<T> = T | null;\n\nexport class ScrollerShim {\n  protected _node: Element | Window;\n  protected _element: Nullable<Element> = null;\n\n  constructor(element?: Element) {\n    const node = element ?? window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n\n  public get element() {\n    return (\n      this._element || document.scrollingElement || document.documentElement\n    );\n  }\n\n  public get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n\n  public get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n\n  public get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n\n  public get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n\n  public get viewportHeight() {\n    return this._element\n      ? this._element.getBoundingClientRect().height\n      : window.innerHeight;\n  }\n\n  public get viewportWidth() {\n    return this._element\n      ? this._element.getBoundingClientRect().width\n      : window.innerWidth;\n  }\n\n  public get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n\n  public get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\n\nexport class ScrollerController extends ScrollerShim {\n  private _originalScrollTo:\n    | typeof Element.prototype.scrollTo\n    | typeof window.scrollTo;\n  private _originalScrollBy:\n    | typeof Element.prototype.scrollBy\n    | typeof window.scrollBy;\n  private _originalScroll:\n    | typeof Element.prototype.scroll\n    | typeof window.scroll;\n  private _clients = new Set<unknown>();\n  private _retarget: Nullable<retargetScrollCallback> = null;\n  private _end: Nullable<endScrollCallback> = null;\n  private __destination: Nullable<ScrollToOptions> = null;\n\n  constructor(client: unknown, element?: Element) {\n    super(element);\n\n    this._checkForArrival = this._checkForArrival.bind(this);\n    this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n    this.scrollTo = this.scrollTo.bind(this);\n    this.scrollBy = this.scrollBy.bind(this);\n\n    const node = this._node;\n\n    this._originalScrollTo = node.scrollTo;\n    this._originalScrollBy = node.scrollBy;\n    this._originalScroll = node.scroll;\n    this._attach(client);\n  }\n\n  public correctingScrollError = false;\n\n  private get _destination() {\n    return this.__destination;\n  }\n\n  public get scrolling() {\n    return this._destination !== null;\n  }\n\n  public scrollTo(options: ScrollToOptions): void;\n  public scrollTo(x: number, y: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollTo(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    this._scrollTo(options);\n  }\n\n  public scrollBy(options: ScrollToOptions): void;\n  public scrollBy(x: number, y: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number): void;\n  public scrollBy(p1: ScrollToOptions | number, p2?: number) {\n    const options: ScrollToOptions =\n      typeof p1 === 'number' && typeof p2 === 'number'\n        ? {left: p1, top: p2}\n        : (p1 as ScrollToOptions);\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n\n  private _nativeScrollTo(options: ScrollToOptions) {\n    this._originalScrollTo!.bind(this._element || window)(options);\n  }\n\n  private _scrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback | null = null,\n    end: endScrollCallback | null = null\n  ) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n\n  private _setDestination(options: ScrollToOptions) {\n    let {top, left} = options;\n    top =\n      top === undefined\n        ? undefined\n        : Math.max(0, Math.min(top, this.maxScrollTop));\n    left =\n      left === undefined\n        ? undefined\n        : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (\n      this._destination !== null &&\n      left === this._destination.left &&\n      top === this._destination.top\n    ) {\n      return false;\n    }\n    this.__destination = {top, left, behavior: 'smooth'};\n    return true;\n  }\n\n  private _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n\n  private _updateManagedScrollTo(coordinates: ScrollToCoordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n\n  public managedScrollTo(\n    options: ScrollToOptions,\n    retarget: retargetScrollCallback,\n    end: endScrollCallback\n  ) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n\n  public correctScrollError(coordinates: ScrollToCoordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => (this.correctingScrollError = false))\n    );\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n\n  private _checkForArrival() {\n    if (this._destination !== null) {\n      const {scrollTop, scrollLeft} = this;\n      let {top, left} = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n\n  public detach(client: unknown) {\n    this._clients.delete(client);\n\n    /**\n     * If there aren't any more clients, then return the node's default\n     * scrolling methods\n     */\n    if (this._clients.size === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n\n  private _attach(client: unknown) {\n    this._clients.add(client);\n\n    /**\n     * The node should only have the methods shimmed when adding the first\n     * client â€“ otherwise it's redundant\n     */\n    if (this._clients.size === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}