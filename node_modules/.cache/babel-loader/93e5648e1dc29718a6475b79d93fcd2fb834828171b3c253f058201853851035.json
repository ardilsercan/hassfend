{"ast":null,"code":"import { atLeastVersion } from \"../common/config/version\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeLocalize } from \"../common/translations/localize\";\nimport { computeRTLDirection, setDirectionStyles } from \"../common/util/compute_rtl\";\nimport { debounce } from \"../common/util/debounce\";\nimport { getHassTranslations, getHassTranslationsPre109, saveTranslationPreferences } from \"../data/translation\";\nimport { translationMetadata } from \"../resources/translations-metadata\";\nimport { getLocalLanguage, getTranslation, getUserLocale } from \"../util/common-translation\";\nimport { storeState } from \"../util/ha-pref-storage\";\nlet updateResourcesIteration = 0;\n\n/*\n * superClass needs to contain `this.hass` and `this._updateHass`.\n */\n\nexport default (superClass => class extends superClass {\n  constructor(...args) {\n    super(...args);\n    // eslint-disable-next-line: variable-name\n    this.__coreProgress = void 0;\n    this.__loadedFragmetTranslations = new Set();\n    this.__loadedTranslations = {};\n  }\n  firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    this.addEventListener(\"hass-language-select\", e => {\n      this._selectLanguage(e.detail, true);\n    });\n    this.addEventListener(\"hass-number-format-select\", e => {\n      this._selectNumberFormat(e.detail, true);\n    });\n    this.addEventListener(\"hass-time-format-select\", e => {\n      this._selectTimeFormat(e.detail, true);\n    });\n    this.addEventListener(\"hass-date-format-select\", e => {\n      this._selectDateFormat(e.detail, true);\n    });\n    this.addEventListener(\"hass-time-zone-select\", e => {\n      this._selectTimeZone(e.detail, true);\n    });\n    this.addEventListener(\"hass-first-weekday-select\", e => {\n      this._selectFirstWeekday(e.detail, true);\n    });\n    this._loadCoreTranslations(getLocalLanguage());\n  }\n  updated(changedProps) {\n    var _this$hass;\n    super.updated(changedProps);\n    if (!changedProps.has(\"hass\")) {\n      return;\n    }\n    const oldHass = changedProps.get(\"hass\");\n    if ((_this$hass = this.hass) !== null && _this$hass !== void 0 && _this$hass.panels && (!oldHass || oldHass.panels !== this.hass.panels)) {\n      this._loadFragmentTranslations(this.hass.language, this.hass.panelUrl);\n    }\n  }\n  hassConnected() {\n    super.hassConnected();\n    getUserLocale(this.hass).then(locale => {\n      if (locale !== null && locale !== void 0 && locale.language && this.hass.language !== locale.language) {\n        // We just got language from backend, no need to save back\n        this._selectLanguage(locale.language, false);\n      }\n      if (locale !== null && locale !== void 0 && locale.number_format && this.hass.locale.number_format !== locale.number_format) {\n        // We just got number_format from backend, no need to save back\n        this._selectNumberFormat(locale.number_format, false);\n      }\n      if (locale !== null && locale !== void 0 && locale.time_format && this.hass.locale.time_format !== locale.time_format) {\n        // We just got time_format from backend, no need to save back\n        this._selectTimeFormat(locale.time_format, false);\n      }\n      if (locale !== null && locale !== void 0 && locale.date_format && this.hass.locale.date_format !== locale.date_format) {\n        // We just got date_format from backend, no need to save back\n        this._selectDateFormat(locale.date_format, false);\n      }\n      if (locale !== null && locale !== void 0 && locale.time_zone && this.hass.locale.time_zone !== locale.time_zone) {\n        // We just got time_zone from backend, no need to save back\n        this._selectTimeZone(locale.time_zone, false);\n      }\n      if (locale !== null && locale !== void 0 && locale.first_weekday && this.hass.locale.first_weekday !== locale.first_weekday) {\n        // We just got first_weekday from backend, no need to save back\n        this._selectFirstWeekday(locale.first_weekday, false);\n      }\n    });\n    this.hass.connection.subscribeEvents(debounce(() => {\n      this._refetchCachedHassTranslations(false, false);\n    }, 500), \"component_loaded\");\n    this._applyTranslations(this.hass);\n  }\n  hassReconnected() {\n    super.hassReconnected();\n    this._refetchCachedHassTranslations(true, false);\n    this._applyTranslations(this.hass);\n  }\n  panelUrlChanged(newPanelUrl) {\n    super.panelUrlChanged(newPanelUrl);\n    // this may be triggered before hassConnected\n    this._loadFragmentTranslations(this.hass ? this.hass.language : getLocalLanguage(), newPanelUrl);\n  }\n  _selectNumberFormat(number_format, saveToBackend) {\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        number_format: number_format\n      }\n    });\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n  }\n  _selectTimeFormat(time_format, saveToBackend) {\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        time_format: time_format\n      }\n    });\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n  }\n  _selectDateFormat(date_format, saveToBackend) {\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        date_format: date_format\n      }\n    });\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n  }\n  _selectTimeZone(time_zone, saveToBackend) {\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        time_zone\n      }\n    });\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n  }\n  _selectFirstWeekday(first_weekday, saveToBackend) {\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        first_weekday: first_weekday\n      }\n    });\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n  }\n  _selectLanguage(language, saveToBackend) {\n    if (!this.hass) {\n      // should not happen, do it to avoid use this.hass!\n      return;\n    }\n\n    // update selectedLanguage so that it can be saved to local storage\n    this._updateHass({\n      locale: {\n        ...this.hass.locale,\n        language: language\n      },\n      language: language,\n      selectedLanguage: language\n    });\n    storeState(this.hass);\n    if (saveToBackend) {\n      saveTranslationPreferences(this.hass, this.hass.locale);\n    }\n    this._applyTranslations(this.hass);\n    this._refetchCachedHassTranslations(true, true);\n  }\n  _applyTranslations(hass) {\n    document.querySelector(\"html\").setAttribute(\"lang\", hass.language);\n    this._applyDirection(hass);\n    this._loadCoreTranslations(hass.language);\n    this.__loadedFragmetTranslations = new Set();\n    this._loadFragmentTranslations(hass.language, hass.panelUrl);\n  }\n  _applyDirection(hass) {\n    const direction = computeRTLDirection(hass);\n    setDirectionStyles(direction, this);\n  }\n\n  /**\n   * Load translations from the backend\n   * @param language language to fetch\n   * @param category category to fetch\n   * @param integration optional, if having to fetch for specific integration\n   * @param configFlow optional, if having to fetch for all integrations with a config flow\n   * @param force optional, load even if already cached\n   */\n  async _loadHassTranslations(language, category, integration, configFlow, force = false) {\n    if (__BACKWARDS_COMPAT__ && !atLeastVersion(this.hass.connection.haVersion, 0, 109)) {\n      if (category !== \"state\") {\n        return this.hass.localize;\n      }\n      const resources = await getHassTranslationsPre109(this.hass, language);\n\n      // Ignore the repsonse if user switched languages before we got response\n      if (this.hass.language !== language) {\n        return this.hass.localize;\n      }\n      return this._updateResources(language, resources);\n    }\n    let alreadyLoaded;\n    if (category in this.__loadedTranslations) {\n      alreadyLoaded = this.__loadedTranslations[category];\n    } else {\n      alreadyLoaded = this.__loadedTranslations[category] = {\n        integrations: [],\n        setup: false,\n        configFlow: false\n      };\n    }\n    let integrationsToLoad = [];\n\n    // Check if already loaded\n    if (!force) {\n      if (integration && Array.isArray(integration)) {\n        integrationsToLoad = integration.filter(i => !alreadyLoaded.integrations.includes(i));\n        if (!integrationsToLoad.length) {\n          return this.hass.localize;\n        }\n      } else if (integration) {\n        if (alreadyLoaded.integrations.includes(integration)) {\n          return this.hass.localize;\n        }\n        integrationsToLoad = [integration];\n      } else if (configFlow ? alreadyLoaded.configFlow : alreadyLoaded.setup) {\n        return this.hass.localize;\n      }\n    }\n\n    // Add to cache\n    if (integrationsToLoad.length) {\n      alreadyLoaded.integrations.push(...integrationsToLoad);\n    } else {\n      alreadyLoaded.setup = true;\n      if (configFlow) {\n        alreadyLoaded.configFlow = true;\n      }\n    }\n    const resources = await getHassTranslations(this.hass, language, category, integrationsToLoad.length ? integrationsToLoad : undefined, configFlow);\n\n    // Ignore the repsonse if user switched languages before we got response\n    if (this.hass.language !== language) {\n      return this.hass.localize;\n    }\n    return this._updateResources(language, resources);\n  }\n  async _loadFragmentTranslations(language, panelUrl) {\n    var _this$hass2;\n    if (!panelUrl) {\n      return undefined;\n    }\n    const panelComponent = (_this$hass2 = this.hass) === null || _this$hass2 === void 0 || (_this$hass2 = _this$hass2.panels) === null || _this$hass2 === void 0 || (_this$hass2 = _this$hass2[panelUrl]) === null || _this$hass2 === void 0 ? void 0 : _this$hass2.component_name;\n\n    // If it's the first call we don't have panel info yet to check the component.\n    const fragment = translationMetadata.fragments.includes(panelComponent || panelUrl) ? panelComponent || panelUrl : undefined;\n    if (!fragment) {\n      return undefined;\n    }\n    if (this.__loadedFragmetTranslations.has(fragment)) {\n      return this.hass.localize;\n    }\n    this.__loadedFragmetTranslations.add(fragment);\n    const result = await getTranslation(fragment, language);\n    return this._updateResources(result.language, result.data);\n  }\n  async _loadCoreTranslations(language) {\n    // Check if already in progress\n    // Necessary as we call this in firstUpdated and hassConnected\n    if (this.__coreProgress === language) {\n      return;\n    }\n    this.__coreProgress = language;\n    try {\n      const result = await getTranslation(null, language);\n      await this._updateResources(result.language, result.data);\n    } finally {\n      this.__coreProgress = undefined;\n    }\n  }\n  async _updateResources(language, data) {\n    var _this$hass3, _ref, _this$hass5, _this$hass6;\n    updateResourcesIteration++;\n    const i = updateResourcesIteration;\n\n    // Update the language in hass, and update the resources with the newly\n    // loaded resources. This merges the new data on top of the old data for\n    // this language, so that the full translation set can be loaded across\n    // multiple fragments.\n    //\n    // Beware of a subtle race condition: it is possible to get here twice\n    // before this.hass is even created. In this case our base state comes\n    // from this._pendingHass instead. Otherwise the first set of strings is\n    // overwritten when we call _updateHass the second time!\n\n    // Allow hass to be updated\n    await new Promise(resolve => {\n      setTimeout(resolve, 0);\n    });\n    if (language !== ((_this$hass3 = this.hass) !== null && _this$hass3 !== void 0 ? _this$hass3 : this._pendingHass).language) {\n      var _this$hass4;\n      // the language was changed, abort\n      return ((_this$hass4 = this.hass) !== null && _this$hass4 !== void 0 ? _this$hass4 : this._pendingHass).localize;\n    }\n    const resources = {\n      [language]: {\n        ...((_ref = (_this$hass5 = this.hass) !== null && _this$hass5 !== void 0 ? _this$hass5 : this._pendingHass) === null || _ref === void 0 || (_ref = _ref.resources) === null || _ref === void 0 ? void 0 : _ref[language]),\n        ...data\n      }\n    };\n\n    // Update resources immediately, so when a new update comes in we don't miss values\n    this._updateHass({\n      resources\n    });\n    const localize = await computeLocalize(this, language, resources);\n    if (updateResourcesIteration !== i || language !== ((_this$hass6 = this.hass) !== null && _this$hass6 !== void 0 ? _this$hass6 : this._pendingHass).language) {\n      // if a new iteration has started or the language changed, abort\n      return localize;\n    }\n    this._updateHass({\n      localize\n    });\n    fireEvent(this, \"translations-updated\");\n    return localize;\n  }\n  _refetchCachedHassTranslations(includeConfigFlow, clearIntegrations) {\n    for (const [category, cache] of Object.entries(this.__loadedTranslations)) {\n      if (clearIntegrations) {\n        cache.integrations = [];\n      }\n      if (cache.setup) {\n        this._loadHassTranslations(this.hass.language, category, undefined, includeConfigFlow && cache.configFlow, true);\n      }\n    }\n  }\n});\n\n// Load selected translation into memory immediately so it is ready when Polymer\n// initializes.\ngetTranslation(null, getLocalLanguage());","map":{"version":3,"names":["atLeastVersion","fireEvent","computeLocalize","computeRTLDirection","setDirectionStyles","debounce","getHassTranslations","getHassTranslationsPre109","saveTranslationPreferences","translationMetadata","getLocalLanguage","getTranslation","getUserLocale","storeState","updateResourcesIteration","superClass","constructor","args","__coreProgress","__loadedFragmetTranslations","Set","__loadedTranslations","firstUpdated","changedProps","addEventListener","e","_selectLanguage","detail","_selectNumberFormat","_selectTimeFormat","_selectDateFormat","_selectTimeZone","_selectFirstWeekday","_loadCoreTranslations","updated","_this$hass","has","oldHass","get","hass","panels","_loadFragmentTranslations","language","panelUrl","hassConnected","then","locale","number_format","time_format","date_format","time_zone","first_weekday","connection","subscribeEvents","_refetchCachedHassTranslations","_applyTranslations","hassReconnected","panelUrlChanged","newPanelUrl","saveToBackend","_updateHass","selectedLanguage","document","querySelector","setAttribute","_applyDirection","direction","_loadHassTranslations","category","integration","configFlow","force","__BACKWARDS_COMPAT__","haVersion","localize","resources","_updateResources","alreadyLoaded","integrations","setup","integrationsToLoad","Array","isArray","filter","i","includes","length","push","undefined","_this$hass2","panelComponent","component_name","fragment","fragments","add","result","data","_this$hass3","_ref","_this$hass5","_this$hass6","Promise","resolve","setTimeout","_pendingHass","_this$hass4","includeConfigFlow","clearIntegrations","cache","Object","entries"],"sources":["/Users/sercanardil/Desktop/frontend/src/state/translations-mixin.ts"],"sourcesContent":["import { atLeastVersion } from \"../common/config/version\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeLocalize, LocalizeFunc } from \"../common/translations/localize\";\nimport {\n  computeRTLDirection,\n  setDirectionStyles,\n} from \"../common/util/compute_rtl\";\nimport { debounce } from \"../common/util/debounce\";\nimport {\n  FirstWeekday,\n  getHassTranslations,\n  getHassTranslationsPre109,\n  NumberFormat,\n  saveTranslationPreferences,\n  TimeFormat,\n  DateFormat,\n  TranslationCategory,\n  TimeZone,\n} from \"../data/translation\";\nimport { translationMetadata } from \"../resources/translations-metadata\";\nimport { Constructor, HomeAssistant } from \"../types\";\nimport {\n  getLocalLanguage,\n  getTranslation,\n  getUserLocale,\n} from \"../util/common-translation\";\nimport { storeState } from \"../util/ha-pref-storage\";\nimport { HassBaseEl } from \"./hass-base-mixin\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"hass-language-select\": {\n      language: string;\n    };\n    \"hass-number-format-select\": {\n      number_format: NumberFormat;\n    };\n    \"hass-time-format-select\": {\n      time_format: TimeFormat;\n    };\n    \"hass-date-format-select\": {\n      date_format: DateFormat;\n    };\n    \"hass-time-zone-select\": {\n      time_zone: TimeZone;\n    };\n    \"hass-first-weekday-select\": {\n      first_weekday: FirstWeekday;\n    };\n    \"translations-updated\": undefined;\n  }\n}\n\ninterface LoadedTranslationCategory {\n  // individual integrations loaded for this category\n  integrations: string[];\n  // if integrations that have been set up for this category are loaded\n  setup: boolean;\n  // if\n  configFlow: boolean;\n}\n\nlet updateResourcesIteration = 0;\n\n/*\n * superClass needs to contain `this.hass` and `this._updateHass`.\n */\n\nexport default <T extends Constructor<HassBaseEl>>(superClass: T) =>\n  class extends superClass {\n    // eslint-disable-next-line: variable-name\n    private __coreProgress?: string;\n\n    private __loadedFragmetTranslations: Set<string> = new Set();\n\n    private __loadedTranslations: {\n      // track what things have been loaded\n      [category: string]: LoadedTranslationCategory;\n    } = {};\n\n    protected firstUpdated(changedProps) {\n      super.firstUpdated(changedProps);\n      this.addEventListener(\"hass-language-select\", (e) => {\n        this._selectLanguage((e as CustomEvent).detail, true);\n      });\n      this.addEventListener(\"hass-number-format-select\", (e) => {\n        this._selectNumberFormat((e as CustomEvent).detail, true);\n      });\n      this.addEventListener(\"hass-time-format-select\", (e) => {\n        this._selectTimeFormat((e as CustomEvent).detail, true);\n      });\n      this.addEventListener(\"hass-date-format-select\", (e) => {\n        this._selectDateFormat((e as CustomEvent).detail, true);\n      });\n      this.addEventListener(\"hass-time-zone-select\", (e) => {\n        this._selectTimeZone((e as CustomEvent).detail, true);\n      });\n      this.addEventListener(\"hass-first-weekday-select\", (e) => {\n        this._selectFirstWeekday((e as CustomEvent).detail, true);\n      });\n      this._loadCoreTranslations(getLocalLanguage());\n    }\n\n    protected updated(changedProps) {\n      super.updated(changedProps);\n      if (!changedProps.has(\"hass\")) {\n        return;\n      }\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n      if (\n        this.hass?.panels &&\n        (!oldHass || oldHass.panels !== this.hass.panels)\n      ) {\n        this._loadFragmentTranslations(this.hass.language, this.hass.panelUrl);\n      }\n    }\n\n    protected hassConnected() {\n      super.hassConnected();\n      getUserLocale(this.hass!).then((locale) => {\n        if (locale?.language && this.hass!.language !== locale.language) {\n          // We just got language from backend, no need to save back\n          this._selectLanguage(locale.language, false);\n        }\n        if (\n          locale?.number_format &&\n          this.hass!.locale.number_format !== locale.number_format\n        ) {\n          // We just got number_format from backend, no need to save back\n          this._selectNumberFormat(locale.number_format, false);\n        }\n        if (\n          locale?.time_format &&\n          this.hass!.locale.time_format !== locale.time_format\n        ) {\n          // We just got time_format from backend, no need to save back\n          this._selectTimeFormat(locale.time_format, false);\n        }\n        if (\n          locale?.date_format &&\n          this.hass!.locale.date_format !== locale.date_format\n        ) {\n          // We just got date_format from backend, no need to save back\n          this._selectDateFormat(locale.date_format, false);\n        }\n        if (\n          locale?.time_zone &&\n          this.hass!.locale.time_zone !== locale.time_zone\n        ) {\n          // We just got time_zone from backend, no need to save back\n          this._selectTimeZone(locale.time_zone, false);\n        }\n        if (\n          locale?.first_weekday &&\n          this.hass!.locale.first_weekday !== locale.first_weekday\n        ) {\n          // We just got first_weekday from backend, no need to save back\n          this._selectFirstWeekday(locale.first_weekday, false);\n        }\n      });\n\n      this.hass!.connection.subscribeEvents(\n        debounce(() => {\n          this._refetchCachedHassTranslations(false, false);\n        }, 500),\n        \"component_loaded\"\n      );\n      this._applyTranslations(this.hass!);\n    }\n\n    protected hassReconnected() {\n      super.hassReconnected();\n      this._refetchCachedHassTranslations(true, false);\n      this._applyTranslations(this.hass!);\n    }\n\n    protected panelUrlChanged(newPanelUrl: string) {\n      super.panelUrlChanged(newPanelUrl);\n      // this may be triggered before hassConnected\n      this._loadFragmentTranslations(\n        this.hass ? this.hass.language : getLocalLanguage(),\n        newPanelUrl\n      );\n    }\n\n    private _selectNumberFormat(\n      number_format: NumberFormat,\n      saveToBackend: boolean\n    ) {\n      this._updateHass({\n        locale: { ...this.hass!.locale, number_format: number_format },\n      });\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass!, this.hass!.locale);\n      }\n    }\n\n    private _selectTimeFormat(time_format: TimeFormat, saveToBackend: boolean) {\n      this._updateHass({\n        locale: { ...this.hass!.locale, time_format: time_format },\n      });\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass!, this.hass!.locale);\n      }\n    }\n\n    private _selectDateFormat(date_format: DateFormat, saveToBackend: boolean) {\n      this._updateHass({\n        locale: {\n          ...this.hass!.locale,\n          date_format: date_format,\n        },\n      });\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass!, this.hass!.locale);\n      }\n    }\n\n    private _selectTimeZone(time_zone: TimeZone, saveToBackend: boolean) {\n      this._updateHass({\n        locale: { ...this.hass!.locale, time_zone },\n      });\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass!, this.hass!.locale);\n      }\n    }\n\n    private _selectFirstWeekday(\n      first_weekday: FirstWeekday,\n      saveToBackend: boolean\n    ) {\n      this._updateHass({\n        locale: { ...this.hass!.locale, first_weekday: first_weekday },\n      });\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass!, this.hass!.locale);\n      }\n    }\n\n    private _selectLanguage(language: string, saveToBackend: boolean) {\n      if (!this.hass) {\n        // should not happen, do it to avoid use this.hass!\n        return;\n      }\n\n      // update selectedLanguage so that it can be saved to local storage\n      this._updateHass({\n        locale: { ...this.hass!.locale, language: language },\n        language: language,\n        selectedLanguage: language,\n      });\n      storeState(this.hass);\n      if (saveToBackend) {\n        saveTranslationPreferences(this.hass, this.hass.locale);\n      }\n      this._applyTranslations(this.hass);\n      this._refetchCachedHassTranslations(true, true);\n    }\n\n    private _applyTranslations(hass: HomeAssistant) {\n      document.querySelector(\"html\")!.setAttribute(\"lang\", hass.language);\n      this._applyDirection(hass);\n      this._loadCoreTranslations(hass.language);\n      this.__loadedFragmetTranslations = new Set();\n      this._loadFragmentTranslations(hass.language, hass.panelUrl);\n    }\n\n    private _applyDirection(hass: HomeAssistant) {\n      const direction = computeRTLDirection(hass);\n      setDirectionStyles(direction, this);\n    }\n\n    /**\n     * Load translations from the backend\n     * @param language language to fetch\n     * @param category category to fetch\n     * @param integration optional, if having to fetch for specific integration\n     * @param configFlow optional, if having to fetch for all integrations with a config flow\n     * @param force optional, load even if already cached\n     */\n    private async _loadHassTranslations(\n      language: string,\n      category: Parameters<typeof getHassTranslations>[2],\n      integration?: Parameters<typeof getHassTranslations>[3],\n      configFlow?: Parameters<typeof getHassTranslations>[4],\n      force = false\n    ): Promise<LocalizeFunc> {\n      if (\n        __BACKWARDS_COMPAT__ &&\n        !atLeastVersion(this.hass!.connection.haVersion, 0, 109)\n      ) {\n        if (category !== \"state\") {\n          return this.hass!.localize;\n        }\n        const resources = await getHassTranslationsPre109(this.hass!, language);\n\n        // Ignore the repsonse if user switched languages before we got response\n        if (this.hass!.language !== language) {\n          return this.hass!.localize;\n        }\n\n        return this._updateResources(language, resources);\n      }\n\n      let alreadyLoaded: LoadedTranslationCategory;\n\n      if (category in this.__loadedTranslations) {\n        alreadyLoaded = this.__loadedTranslations[category];\n      } else {\n        alreadyLoaded = this.__loadedTranslations[category] = {\n          integrations: [],\n          setup: false,\n          configFlow: false,\n        };\n      }\n\n      let integrationsToLoad: string[] = [];\n\n      // Check if already loaded\n      if (!force) {\n        if (integration && Array.isArray(integration)) {\n          integrationsToLoad = integration.filter(\n            (i) => !alreadyLoaded.integrations.includes(i)\n          );\n          if (!integrationsToLoad.length) {\n            return this.hass!.localize;\n          }\n        } else if (integration) {\n          if (alreadyLoaded.integrations.includes(integration)) {\n            return this.hass!.localize;\n          }\n          integrationsToLoad = [integration];\n        } else if (\n          configFlow ? alreadyLoaded.configFlow : alreadyLoaded.setup\n        ) {\n          return this.hass!.localize;\n        }\n      }\n\n      // Add to cache\n      if (integrationsToLoad.length) {\n        alreadyLoaded.integrations.push(...integrationsToLoad);\n      } else {\n        alreadyLoaded.setup = true;\n        if (configFlow) {\n          alreadyLoaded.configFlow = true;\n        }\n      }\n\n      const resources = await getHassTranslations(\n        this.hass!,\n        language,\n        category,\n        integrationsToLoad.length ? integrationsToLoad : undefined,\n        configFlow\n      );\n\n      // Ignore the repsonse if user switched languages before we got response\n      if (this.hass!.language !== language) {\n        return this.hass!.localize;\n      }\n\n      return this._updateResources(language, resources);\n    }\n\n    private async _loadFragmentTranslations(\n      language: string,\n      panelUrl: string\n    ) {\n      if (!panelUrl) {\n        return undefined;\n      }\n\n      const panelComponent = this.hass?.panels?.[panelUrl]?.component_name;\n\n      // If it's the first call we don't have panel info yet to check the component.\n      const fragment = translationMetadata.fragments.includes(\n        panelComponent || panelUrl\n      )\n        ? panelComponent || panelUrl\n        : undefined;\n\n      if (!fragment) {\n        return undefined;\n      }\n\n      if (this.__loadedFragmetTranslations.has(fragment)) {\n        return this.hass!.localize;\n      }\n      this.__loadedFragmetTranslations.add(fragment);\n      const result = await getTranslation(fragment, language);\n      return this._updateResources(result.language, result.data);\n    }\n\n    private async _loadCoreTranslations(language: string) {\n      // Check if already in progress\n      // Necessary as we call this in firstUpdated and hassConnected\n      if (this.__coreProgress === language) {\n        return;\n      }\n      this.__coreProgress = language;\n      try {\n        const result = await getTranslation(null, language);\n        await this._updateResources(result.language, result.data);\n      } finally {\n        this.__coreProgress = undefined;\n      }\n    }\n\n    private async _updateResources(\n      language: string,\n      data: any\n    ): Promise<LocalizeFunc> {\n      updateResourcesIteration++;\n      const i = updateResourcesIteration;\n\n      // Update the language in hass, and update the resources with the newly\n      // loaded resources. This merges the new data on top of the old data for\n      // this language, so that the full translation set can be loaded across\n      // multiple fragments.\n      //\n      // Beware of a subtle race condition: it is possible to get here twice\n      // before this.hass is even created. In this case our base state comes\n      // from this._pendingHass instead. Otherwise the first set of strings is\n      // overwritten when we call _updateHass the second time!\n\n      // Allow hass to be updated\n      await new Promise((resolve) => {\n        setTimeout(resolve, 0);\n      });\n\n      if (language !== (this.hass ?? this._pendingHass).language) {\n        // the language was changed, abort\n        return (this.hass ?? this._pendingHass).localize!;\n      }\n\n      const resources = {\n        [language]: {\n          ...(this.hass ?? this._pendingHass)?.resources?.[language],\n          ...data,\n        },\n      };\n\n      // Update resources immediately, so when a new update comes in we don't miss values\n      this._updateHass({ resources });\n\n      const localize = await computeLocalize(this, language, resources);\n\n      if (\n        updateResourcesIteration !== i ||\n        language !== (this.hass ?? this._pendingHass).language\n      ) {\n        // if a new iteration has started or the language changed, abort\n        return localize;\n      }\n\n      this._updateHass({\n        localize,\n      });\n      fireEvent(this, \"translations-updated\");\n\n      return localize;\n    }\n\n    private _refetchCachedHassTranslations(\n      includeConfigFlow: boolean,\n      clearIntegrations: boolean\n    ) {\n      for (const [category, cache] of Object.entries(\n        this.__loadedTranslations\n      )) {\n        if (clearIntegrations) {\n          cache.integrations = [];\n        }\n        if (cache.setup) {\n          this._loadHassTranslations(\n            this.hass!.language,\n            category as TranslationCategory,\n            undefined,\n            includeConfigFlow && cache.configFlow,\n            true\n          );\n        }\n      }\n    }\n  };\n\n// Load selected translation into memory immediately so it is ready when Polymer\n// initializes.\ngetTranslation(null, getLocalLanguage());\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}