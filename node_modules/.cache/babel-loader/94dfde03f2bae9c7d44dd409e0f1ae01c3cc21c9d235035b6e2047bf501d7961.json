{"ast":null,"code":"import { BarController } from \"chart.js\";\nfunction borderProps(properties) {\n  let reverse;\n  let start;\n  let end;\n  let top;\n  let bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = \"left\";\n    end = \"right\";\n  } else {\n    reverse = properties.base < properties.y;\n    start = \"bottom\";\n    end = \"top\";\n  }\n  if (reverse) {\n    top = \"end\";\n    bottom = \"start\";\n  } else {\n    top = \"start\";\n    bottom = \"end\";\n  }\n  return {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true\n    };\n    return;\n  }\n  const {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  } = borderProps(properties);\n  if (edge === \"middle\" && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, {\n  inflateAmount\n}, ratio) {\n  properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nfunction parseValue(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry.start, i);\n  const endValue = vScale.parse(entry.end, i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n  return item;\n}\nexport class TimelineController extends BarController {\n  parseObjectData(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i;\n    let ilen;\n    let item;\n    let entry;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      entry = data[i];\n      item = {};\n      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n      parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n  }\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {\n      vScale\n    } = meta;\n    const data = this.getDataset().data[index];\n    return {\n      label: vScale.getLabelForValue(this.index) || \"\",\n      value: data.label || \"\"\n    };\n  }\n  updateElements(bars, start, count, mode) {\n    const vScale = this._cachedMeta.vScale;\n    const iScale = this._cachedMeta.iScale;\n    const dataset = this.getDataset();\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const horizontal = vScale.isHorizontal();\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    for (let index = start; index < start + count; index++) {\n      const data = dataset.data[index];\n      const y = vScale.getPixelForValue(this.index);\n      const xStart = iScale.getPixelForValue(data.start.getTime());\n      const xEnd = iScale.getPixelForValue(data.end.getTime());\n      const width = xEnd - xStart;\n      const parsed = this.getParsed(index);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const height = 10;\n      const properties = {\n        horizontal,\n        x: xStart + width / 2,\n        // Center of the bar\n        y: y - height,\n        // Top of bar\n        width,\n        height: 0,\n        base: y + height,\n        // Bottom of bar,\n        // Text\n        text: data.label\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(index, mode);\n        properties.options = {\n          ...properties.options,\n          backgroundColor: data.color\n        };\n      }\n      const options = properties.options || bars[index].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, 1);\n      this.updateElement(bars[index], index, properties, mode);\n    }\n  }\n  removeHoverStyle(_element, _datasetIndex, _index) {\n    // this._setStyle(element, index, 'active', false);\n  }\n  setHoverStyle(_element, _datasetIndex, _index) {\n    // this._setStyle(element, index, 'active', true);\n  }\n}\nTimelineController.id = \"timeline\";\nTimelineController.defaults = {\n  dataElementType: \"textbar\",\n  dataElementOptions: [\"text\", \"textColor\", \"textPadding\"],\n  elements: {\n    showText: true,\n    textPadding: 4,\n    minBarWidth: 1\n  },\n  layout: {\n    padding: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }\n  }\n};\nTimelineController.overrides = {\n  maintainAspectRatio: false,\n  plugins: {\n    legend: {\n      display: false\n    }\n  }\n};","map":{"version":3,"names":["BarController","borderProps","properties","reverse","start","end","top","bottom","horizontal","base","x","y","setBorderSkipped","options","stack","index","edge","borderSkipped","res","right","left","enableBorderRadius","_top","_bottom","parseEdge","a","b","swap","startEnd","orig","v1","v2","v","setInflateAmount","inflateAmount","ratio","parseValue","entry","item","vScale","i","startValue","parse","endValue","min","Math","max","barStart","barEnd","abs","axis","_custom","TimelineController","parseObjectData","meta","data","count","iScale","labels","getLabels","singleScale","parsed","ilen","push","getLabelAndValue","_cachedMeta","getDataset","label","getLabelForValue","value","updateElements","bars","mode","dataset","firstOpts","resolveDataElementOptions","sharedOptions","getSharedOptions","includeOptions","isHorizontal","updateSharedOptions","getPixelForValue","xStart","getTime","xEnd","width","getParsed","_stacks","height","text","backgroundColor","color","updateElement","removeHoverStyle","_element","_datasetIndex","_index","setHoverStyle","id","defaults","dataElementType","dataElementOptions","elements","showText","textPadding","minBarWidth","layout","padding","overrides","maintainAspectRatio","plugins","legend","display"],"sources":["/workspaces/frontend/src/components/chart/timeline-chart/timeline-controller.ts"],"sourcesContent":["import { BarController, BarElement } from \"chart.js\";\nimport { TimeLineData } from \"./const\";\nimport { TextBarProps } from \"./textbar-element\";\n\nfunction borderProps(properties) {\n  let reverse;\n  let start;\n  let end;\n  let top;\n  let bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = \"left\";\n    end = \"right\";\n  } else {\n    reverse = properties.base < properties.y;\n    start = \"bottom\";\n    end = \"top\";\n  }\n  if (reverse) {\n    top = \"end\";\n    bottom = \"start\";\n  } else {\n    top = \"start\";\n    bottom = \"end\";\n  }\n  return { start, end, reverse, top, bottom };\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true,\n    };\n    return;\n  }\n\n  const { start, end, reverse, top, bottom } = borderProps(properties);\n\n  if (edge === \"middle\" && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === \"start\" ? start : v === \"end\" ? end : v;\n}\n\nfunction setInflateAmount(\n  properties,\n  { inflateAmount }: { inflateAmount?: string | number },\n  ratio\n) {\n  properties.inflateAmount =\n    inflateAmount === \"auto\" ? (ratio === 1 ? 0.33 : 0) : inflateAmount;\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry.start, i);\n  const endValue = vScale.parse(entry.end, i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max,\n  };\n\n  return item;\n}\n\nexport class TimelineController extends BarController {\n  static id = \"timeline\";\n\n  static defaults = {\n    dataElementType: \"textbar\",\n    dataElementOptions: [\"text\", \"textColor\", \"textPadding\"],\n    elements: {\n      showText: true,\n      textPadding: 4,\n      minBarWidth: 1,\n    },\n\n    layout: {\n      padding: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n      },\n    },\n  };\n\n  static overrides = {\n    maintainAspectRatio: false,\n    plugins: {\n      legend: {\n        display: false,\n      },\n    },\n  };\n\n  parseObjectData(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed: any[] = [];\n    let i;\n    let ilen;\n    let item;\n    let entry;\n\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      entry = data[i];\n      item = {};\n      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n      parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const { vScale } = meta;\n    const data = this.getDataset().data[index] as TimeLineData;\n\n    return {\n      label: vScale!.getLabelForValue(this.index) || \"\",\n      value: data.label || \"\",\n    };\n  }\n\n  updateElements(\n    bars: BarElement[],\n    start: number,\n    count: number,\n    mode: \"reset\" | \"resize\" | \"none\" | \"hide\" | \"show\" | \"default\" | \"active\"\n  ) {\n    const vScale = this._cachedMeta.vScale!;\n    const iScale = this._cachedMeta.iScale!;\n    const dataset = this.getDataset();\n\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions!);\n\n    const horizontal = vScale.isHorizontal();\n\n    this.updateSharedOptions(sharedOptions!, mode, firstOpts);\n\n    for (let index = start; index < start + count; index++) {\n      const data = dataset.data[index] as TimeLineData;\n\n      const y = vScale.getPixelForValue(this.index);\n\n      const xStart = iScale.getPixelForValue(data.start.getTime());\n      const xEnd = iScale.getPixelForValue(data.end.getTime());\n      const width = xEnd - xStart;\n\n      const parsed = this.getParsed(index);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const height = 10;\n\n      const properties: TextBarProps = {\n        horizontal,\n        x: xStart + width / 2, // Center of the bar\n        y: y - height, // Top of bar\n        width,\n        height: 0,\n        base: y + height, // Bottom of bar,\n        // Text\n        text: data.label,\n      };\n\n      if (includeOptions) {\n        properties.options =\n          sharedOptions || this.resolveDataElementOptions(index, mode);\n\n        properties.options = {\n          ...properties.options,\n          backgroundColor: data.color,\n        };\n      }\n      const options = properties.options || bars[index].options;\n\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, 1);\n      this.updateElement(bars[index], index, properties as any, mode);\n    }\n  }\n\n  removeHoverStyle(_element, _datasetIndex, _index) {\n    // this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(_element, _datasetIndex, _index) {\n    // this._setStyle(element, index, 'active', true);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}