{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxItemMixin = superClass => class ComboBoxItemMixinClass extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The index of the item.\n       */\n      index: {\n        type: Number\n      },\n      /**\n       * The item to render.\n       */\n      item: {\n        type: Object\n      },\n      /**\n       * The text to render in the item.\n       */\n      label: {\n        type: String\n      },\n      /**\n       * True when item is selected.\n       */\n      selected: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * True when item is focused.\n       */\n      focused: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Custom function for rendering the item content.\n       */\n      renderer: {\n        type: Function\n      }\n    };\n  }\n  static get observers() {\n    return ['__rendererOrItemChanged(renderer, index, item.*, selected, focused)', '__updateLabel(label, renderer)'];\n  }\n  static get observedAttributes() {\n    return [...super.observedAttributes, 'hidden'];\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'hidden' && newValue !== null) {\n      // The element is being hidden (by virtualizer). Mark one of the __rendererOrItemChanged\n      // dependencies as undefined to make sure it's called when the element is shown again\n      // and assigned properties with possibly identical values as before hiding.\n      this.index = undefined;\n    } else {\n      super.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    this._owner = this.parentNode.owner;\n    const hostDir = this._owner.getAttribute('dir');\n    if (hostDir) {\n      this.setAttribute('dir', hostDir);\n    }\n  }\n\n  /**\n   * Requests an update for the content of the item.\n   * While performing the update, it invokes the renderer passed in the `renderer` property.\n   *\n   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n   */\n  requestContentUpdate() {\n    if (!this.renderer) {\n      return;\n    }\n    const model = {\n      index: this.index,\n      item: this.item,\n      focused: this.focused,\n      selected: this.selected\n    };\n    this.renderer(this, this._owner, model);\n  }\n\n  /** @private */\n  __rendererOrItemChanged(renderer, index, item) {\n    if (item === undefined || index === undefined) {\n      return;\n    }\n    if (this._oldRenderer !== renderer) {\n      this.innerHTML = '';\n      // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n      // When clearing the rendered content, this part needs to be manually disposed of.\n      // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n      delete this._$litPart$;\n    }\n    if (renderer) {\n      this._oldRenderer = renderer;\n      this.requestContentUpdate();\n    }\n  }\n\n  /** @private */\n  __updateLabel(label, renderer) {\n    if (renderer) {\n      return;\n    }\n    this.textContent = label;\n  }\n};","map":{"version":3,"names":["ComboBoxItemMixin","superClass","ComboBoxItemMixinClass","properties","index","type","Number","item","Object","label","String","selected","Boolean","value","reflectToAttribute","focused","renderer","Function","observers","observedAttributes","attributeChangedCallback","name","oldValue","newValue","undefined","connectedCallback","_owner","parentNode","owner","hostDir","getAttribute","setAttribute","requestContentUpdate","model","__rendererOrItemChanged","_oldRenderer","innerHTML","_$litPart$","__updateLabel","textContent"],"sources":["/workspaces/frontend/node_modules/@vaadin/combo-box/src/vaadin-combo-box-item-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2015 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n\n/**\n * @polymerMixin\n */\nexport const ComboBoxItemMixin = (superClass) =>\n  class ComboBoxItemMixinClass extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The index of the item.\n         */\n        index: {\n          type: Number,\n        },\n\n        /**\n         * The item to render.\n         */\n        item: {\n          type: Object,\n        },\n\n        /**\n         * The text to render in the item.\n         */\n        label: {\n          type: String,\n        },\n\n        /**\n         * True when item is selected.\n         */\n        selected: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n        },\n\n        /**\n         * True when item is focused.\n         */\n        focused: {\n          type: Boolean,\n          value: false,\n          reflectToAttribute: true,\n        },\n\n        /**\n         * Custom function for rendering the item content.\n         */\n        renderer: {\n          type: Function,\n        },\n      };\n    }\n\n    static get observers() {\n      return ['__rendererOrItemChanged(renderer, index, item.*, selected, focused)', '__updateLabel(label, renderer)'];\n    }\n\n    static get observedAttributes() {\n      return [...super.observedAttributes, 'hidden'];\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === 'hidden' && newValue !== null) {\n        // The element is being hidden (by virtualizer). Mark one of the __rendererOrItemChanged\n        // dependencies as undefined to make sure it's called when the element is shown again\n        // and assigned properties with possibly identical values as before hiding.\n        this.index = undefined;\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      this._owner = this.parentNode.owner;\n\n      const hostDir = this._owner.getAttribute('dir');\n      if (hostDir) {\n        this.setAttribute('dir', hostDir);\n      }\n    }\n\n    /**\n     * Requests an update for the content of the item.\n     * While performing the update, it invokes the renderer passed in the `renderer` property.\n     *\n     * It is not guaranteed that the update happens immediately (synchronously) after it is requested.\n     */\n    requestContentUpdate() {\n      if (!this.renderer) {\n        return;\n      }\n\n      const model = {\n        index: this.index,\n        item: this.item,\n        focused: this.focused,\n        selected: this.selected,\n      };\n\n      this.renderer(this, this._owner, model);\n    }\n\n    /** @private */\n    __rendererOrItemChanged(renderer, index, item) {\n      if (item === undefined || index === undefined) {\n        return;\n      }\n\n      if (this._oldRenderer !== renderer) {\n        this.innerHTML = '';\n        // Whenever a Lit-based renderer is used, it assigns a Lit part to the node it was rendered into.\n        // When clearing the rendered content, this part needs to be manually disposed of.\n        // Otherwise, using a Lit-based renderer on the same node will throw an exception or render nothing afterward.\n        delete this._$litPart$;\n      }\n\n      if (renderer) {\n        this._oldRenderer = renderer;\n        this.requestContentUpdate();\n      }\n    }\n\n    /** @private */\n    __updateLabel(label, renderer) {\n      if (renderer) {\n        return;\n      }\n\n      this.textContent = label;\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}