{"ast":null,"code":"/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport { ERR_INVALID_AUTH, ERR_CANNOT_CONNECT, ERR_HASS_HOST_REQUIRED } from \"./errors.js\";\nimport * as messages from \"./messages.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nconst DEBUG = false;\nexport const MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nexport const MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nexport const MSG_TYPE_AUTH_OK = \"auth_ok\";\nexport function createSocket(options) {\n  if (!options.auth) {\n    throw ERR_HASS_HOST_REQUIRED;\n  }\n  const auth = options.auth;\n  // Start refreshing expired tokens even before the WS connection is open.\n  // We know that we will need auth anyway.\n  let authRefreshTask = auth.expired ? auth.refreshAccessToken().then(() => {\n    authRefreshTask = undefined;\n  }, () => {\n    authRefreshTask = undefined;\n  }) : undefined;\n  // Convert from http:// -> ws://, https:// -> wss://\n  const url = auth.wsUrl;\n  if (DEBUG) {\n    console.log(\"[Auth phase] Initializing\", url);\n  }\n  function connect(triesLeft, promResolve, promReject) {\n    if (DEBUG) {\n      console.log(\"[Auth Phase] New connection\", url);\n    }\n    const socket = new WebSocket(url);\n    // If invalid auth, we will not try to reconnect.\n    let invalidAuth = false;\n    const closeMessage = () => {\n      // If we are in error handler make sure close handler doesn't also fire.\n      socket.removeEventListener(\"close\", closeMessage);\n      if (invalidAuth) {\n        promReject(ERR_INVALID_AUTH);\n        return;\n      }\n      // Reject if we no longer have to retry\n      if (triesLeft === 0) {\n        // We never were connected and will not retry\n        promReject(ERR_CANNOT_CONNECT);\n        return;\n      }\n      const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n      // Try again in a second\n      setTimeout(() => connect(newTries, promResolve, promReject), 1000);\n    };\n    // Auth is mandatory, so we can send the auth message right away.\n    const handleOpen = async event => {\n      try {\n        if (auth.expired) {\n          await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n        }\n        socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n      } catch (err) {\n        // Refresh token failed\n        invalidAuth = err === ERR_INVALID_AUTH;\n        socket.close();\n      }\n    };\n    const handleMessage = async event => {\n      const message = JSON.parse(event.data);\n      if (DEBUG) {\n        console.log(\"[Auth phase] Received\", message);\n      }\n      switch (message.type) {\n        case MSG_TYPE_AUTH_INVALID:\n          invalidAuth = true;\n          socket.close();\n          break;\n        case MSG_TYPE_AUTH_OK:\n          socket.removeEventListener(\"open\", handleOpen);\n          socket.removeEventListener(\"message\", handleMessage);\n          socket.removeEventListener(\"close\", closeMessage);\n          socket.removeEventListener(\"error\", closeMessage);\n          socket.haVersion = message.ha_version;\n          if (atLeastHaVersion(socket.haVersion, 2022, 9)) {\n            socket.send(JSON.stringify(messages.supportedFeatures()));\n          }\n          promResolve(socket);\n          break;\n        default:\n          if (DEBUG) {\n            // We already send response to this message when socket opens\n            if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n              console.warn(\"[Auth phase] Unhandled message\", message);\n            }\n          }\n      }\n    };\n    socket.addEventListener(\"open\", handleOpen);\n    socket.addEventListener(\"message\", handleMessage);\n    socket.addEventListener(\"close\", closeMessage);\n    socket.addEventListener(\"error\", closeMessage);\n  }\n  return new Promise((resolve, reject) => connect(options.setupRetry, resolve, reject));\n}","map":{"version":3,"names":["ERR_INVALID_AUTH","ERR_CANNOT_CONNECT","ERR_HASS_HOST_REQUIRED","messages","atLeastHaVersion","DEBUG","MSG_TYPE_AUTH_REQUIRED","MSG_TYPE_AUTH_INVALID","MSG_TYPE_AUTH_OK","createSocket","options","auth","authRefreshTask","expired","refreshAccessToken","then","undefined","url","wsUrl","console","log","connect","triesLeft","promResolve","promReject","socket","WebSocket","invalidAuth","closeMessage","removeEventListener","newTries","setTimeout","handleOpen","event","send","JSON","stringify","accessToken","err","close","handleMessage","message","parse","data","type","haVersion","ha_version","supportedFeatures","warn","addEventListener","Promise","resolve","reject","setupRetry"],"sources":["/workspaces/frontend/node_modules/home-assistant-js-websocket/dist/socket.js"],"sourcesContent":["/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport { ERR_INVALID_AUTH, ERR_CANNOT_CONNECT, ERR_HASS_HOST_REQUIRED, } from \"./errors.js\";\nimport * as messages from \"./messages.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nconst DEBUG = false;\nexport const MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nexport const MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nexport const MSG_TYPE_AUTH_OK = \"auth_ok\";\nexport function createSocket(options) {\n    if (!options.auth) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    const auth = options.auth;\n    // Start refreshing expired tokens even before the WS connection is open.\n    // We know that we will need auth anyway.\n    let authRefreshTask = auth.expired\n        ? auth.refreshAccessToken().then(() => {\n            authRefreshTask = undefined;\n        }, () => {\n            authRefreshTask = undefined;\n        })\n        : undefined;\n    // Convert from http:// -> ws://, https:// -> wss://\n    const url = auth.wsUrl;\n    if (DEBUG) {\n        console.log(\"[Auth phase] Initializing\", url);\n    }\n    function connect(triesLeft, promResolve, promReject) {\n        if (DEBUG) {\n            console.log(\"[Auth Phase] New connection\", url);\n        }\n        const socket = new WebSocket(url);\n        // If invalid auth, we will not try to reconnect.\n        let invalidAuth = false;\n        const closeMessage = () => {\n            // If we are in error handler make sure close handler doesn't also fire.\n            socket.removeEventListener(\"close\", closeMessage);\n            if (invalidAuth) {\n                promReject(ERR_INVALID_AUTH);\n                return;\n            }\n            // Reject if we no longer have to retry\n            if (triesLeft === 0) {\n                // We never were connected and will not retry\n                promReject(ERR_CANNOT_CONNECT);\n                return;\n            }\n            const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n            // Try again in a second\n            setTimeout(() => connect(newTries, promResolve, promReject), 1000);\n        };\n        // Auth is mandatory, so we can send the auth message right away.\n        const handleOpen = async (event) => {\n            try {\n                if (auth.expired) {\n                    await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n                }\n                socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n            }\n            catch (err) {\n                // Refresh token failed\n                invalidAuth = err === ERR_INVALID_AUTH;\n                socket.close();\n            }\n        };\n        const handleMessage = async (event) => {\n            const message = JSON.parse(event.data);\n            if (DEBUG) {\n                console.log(\"[Auth phase] Received\", message);\n            }\n            switch (message.type) {\n                case MSG_TYPE_AUTH_INVALID:\n                    invalidAuth = true;\n                    socket.close();\n                    break;\n                case MSG_TYPE_AUTH_OK:\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"message\", handleMessage);\n                    socket.removeEventListener(\"close\", closeMessage);\n                    socket.removeEventListener(\"error\", closeMessage);\n                    socket.haVersion = message.ha_version;\n                    if (atLeastHaVersion(socket.haVersion, 2022, 9)) {\n                        socket.send(JSON.stringify(messages.supportedFeatures()));\n                    }\n                    promResolve(socket);\n                    break;\n                default:\n                    if (DEBUG) {\n                        // We already send response to this message when socket opens\n                        if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n                            console.warn(\"[Auth phase] Unhandled message\", message);\n                        }\n                    }\n            }\n        };\n        socket.addEventListener(\"open\", handleOpen);\n        socket.addEventListener(\"message\", handleMessage);\n        socket.addEventListener(\"close\", closeMessage);\n        socket.addEventListener(\"error\", closeMessage);\n    }\n    return new Promise((resolve, reject) => connect(options.setupRetry, resolve, reject));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,gBAAgB,EAAEC,kBAAkB,EAAEC,sBAAsB,QAAS,aAAa;AAC3F,OAAO,KAAKC,QAAQ,MAAM,eAAe;AACzC,SAASC,gBAAgB,QAAQ,WAAW;AAC5C,MAAMC,KAAK,GAAG,KAAK;AACnB,OAAO,MAAMC,sBAAsB,GAAG,eAAe;AACrD,OAAO,MAAMC,qBAAqB,GAAG,cAAc;AACnD,OAAO,MAAMC,gBAAgB,GAAG,SAAS;AACzC,OAAO,SAASC,YAAYA,CAACC,OAAO,EAAE;EAClC,IAAI,CAACA,OAAO,CAACC,IAAI,EAAE;IACf,MAAMT,sBAAsB;EAChC;EACA,MAAMS,IAAI,GAAGD,OAAO,CAACC,IAAI;EACzB;EACA;EACA,IAAIC,eAAe,GAAGD,IAAI,CAACE,OAAO,GAC5BF,IAAI,CAACG,kBAAkB,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;IACnCH,eAAe,GAAGI,SAAS;EAC/B,CAAC,EAAE,MAAM;IACLJ,eAAe,GAAGI,SAAS;EAC/B,CAAC,CAAC,GACAA,SAAS;EACf;EACA,MAAMC,GAAG,GAAGN,IAAI,CAACO,KAAK;EACtB,IAAIb,KAAK,EAAE;IACPc,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEH,GAAG,CAAC;EACjD;EACA,SAASI,OAAOA,CAACC,SAAS,EAAEC,WAAW,EAAEC,UAAU,EAAE;IACjD,IAAInB,KAAK,EAAE;MACPc,OAAO,CAACC,GAAG,CAAC,6BAA6B,EAAEH,GAAG,CAAC;IACnD;IACA,MAAMQ,MAAM,GAAG,IAAIC,SAAS,CAACT,GAAG,CAAC;IACjC;IACA,IAAIU,WAAW,GAAG,KAAK;IACvB,MAAMC,YAAY,GAAGA,CAAA,KAAM;MACvB;MACAH,MAAM,CAACI,mBAAmB,CAAC,OAAO,EAAED,YAAY,CAAC;MACjD,IAAID,WAAW,EAAE;QACbH,UAAU,CAACxB,gBAAgB,CAAC;QAC5B;MACJ;MACA;MACA,IAAIsB,SAAS,KAAK,CAAC,EAAE;QACjB;QACAE,UAAU,CAACvB,kBAAkB,CAAC;QAC9B;MACJ;MACA,MAAM6B,QAAQ,GAAGR,SAAS,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGA,SAAS,GAAG,CAAC;MACtD;MACAS,UAAU,CAAC,MAAMV,OAAO,CAACS,QAAQ,EAAEP,WAAW,EAAEC,UAAU,CAAC,EAAE,IAAI,CAAC;IACtE,CAAC;IACD;IACA,MAAMQ,UAAU,GAAG,MAAOC,KAAK,IAAK;MAChC,IAAI;QACA,IAAItB,IAAI,CAACE,OAAO,EAAE;UACd,OAAOD,eAAe,GAAGA,eAAe,GAAGD,IAAI,CAACG,kBAAkB,CAAC,CAAC,CAAC;QACzE;QACAW,MAAM,CAACS,IAAI,CAACC,IAAI,CAACC,SAAS,CAACjC,QAAQ,CAACQ,IAAI,CAACA,IAAI,CAAC0B,WAAW,CAAC,CAAC,CAAC;MAChE,CAAC,CACD,OAAOC,GAAG,EAAE;QACR;QACAX,WAAW,GAAGW,GAAG,KAAKtC,gBAAgB;QACtCyB,MAAM,CAACc,KAAK,CAAC,CAAC;MAClB;IACJ,CAAC;IACD,MAAMC,aAAa,GAAG,MAAOP,KAAK,IAAK;MACnC,MAAMQ,OAAO,GAAGN,IAAI,CAACO,KAAK,CAACT,KAAK,CAACU,IAAI,CAAC;MACtC,IAAItC,KAAK,EAAE;QACPc,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEqB,OAAO,CAAC;MACjD;MACA,QAAQA,OAAO,CAACG,IAAI;QAChB,KAAKrC,qBAAqB;UACtBoB,WAAW,GAAG,IAAI;UAClBF,MAAM,CAACc,KAAK,CAAC,CAAC;UACd;QACJ,KAAK/B,gBAAgB;UACjBiB,MAAM,CAACI,mBAAmB,CAAC,MAAM,EAAEG,UAAU,CAAC;UAC9CP,MAAM,CAACI,mBAAmB,CAAC,SAAS,EAAEW,aAAa,CAAC;UACpDf,MAAM,CAACI,mBAAmB,CAAC,OAAO,EAAED,YAAY,CAAC;UACjDH,MAAM,CAACI,mBAAmB,CAAC,OAAO,EAAED,YAAY,CAAC;UACjDH,MAAM,CAACoB,SAAS,GAAGJ,OAAO,CAACK,UAAU;UACrC,IAAI1C,gBAAgB,CAACqB,MAAM,CAACoB,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE;YAC7CpB,MAAM,CAACS,IAAI,CAACC,IAAI,CAACC,SAAS,CAACjC,QAAQ,CAAC4C,iBAAiB,CAAC,CAAC,CAAC,CAAC;UAC7D;UACAxB,WAAW,CAACE,MAAM,CAAC;UACnB;QACJ;UACI,IAAIpB,KAAK,EAAE;YACP;YACA,IAAIoC,OAAO,CAACG,IAAI,KAAKtC,sBAAsB,EAAE;cACzCa,OAAO,CAAC6B,IAAI,CAAC,gCAAgC,EAAEP,OAAO,CAAC;YAC3D;UACJ;MACR;IACJ,CAAC;IACDhB,MAAM,CAACwB,gBAAgB,CAAC,MAAM,EAAEjB,UAAU,CAAC;IAC3CP,MAAM,CAACwB,gBAAgB,CAAC,SAAS,EAAET,aAAa,CAAC;IACjDf,MAAM,CAACwB,gBAAgB,CAAC,OAAO,EAAErB,YAAY,CAAC;IAC9CH,MAAM,CAACwB,gBAAgB,CAAC,OAAO,EAAErB,YAAY,CAAC;EAClD;EACA,OAAO,IAAIsB,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK/B,OAAO,CAACX,OAAO,CAAC2C,UAAU,EAAEF,OAAO,EAAEC,MAAM,CAAC,CAAC;AACzF"},"metadata":{},"sourceType":"module","externalDependencies":[]}