{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.fixed.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport '../../elevation/elevation.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../ripple/ripple.js';\nimport { html, isServer, LitElement, nothing } from 'lit';\nimport { property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { when } from 'lit/directives/when.js';\nimport { requestUpdateOnAriaChange } from '../../internal/aria/delegate.js';\nimport { dispatchActivationClick, isActivationClick } from '../../internal/events/form-label-activation.js';\nimport { redispatchEvent } from '../../internal/events/redispatch-event.js';\nimport { mixinElementInternals } from '../../labs/behaviors/element-internals.js';\nimport { getFormValue, mixinFormAssociated } from '../../labs/behaviors/form-associated.js';\n// Disable warning for classMap with destructuring\n// tslint:disable:no-implicit-dictionary-conversion\n// Separate variable needed for closure.\nvar sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));\n/**\n * Slider component.\n *\n *\n * @fires change {Event} The native `change` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)\n * --bubbles\n * @fires input {InputEvent} The native `input` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)\n * --bubbles --composed\n */\nexport var Slider = /*#__PURE__*/function (_sliderBaseClass) {\n  _inherits(Slider, _sliderBaseClass);\n  function Slider() {\n    var _this;\n    _classCallCheck(this, Slider);\n    _this = _callSuper(this, Slider);\n    /**\n     * The slider minimum value\n     */\n    _this.min = 0;\n    /**\n     * The slider maximum value\n     */\n    _this.max = 100;\n    /**\n     * An optional label for the slider's value displayed when range is\n     * false; if not set, the label is the value itself.\n     */\n    _this.valueLabel = '';\n    /**\n     * An optional label for the slider's start value displayed when\n     * range is true; if not set, the label is the valueStart itself.\n     */\n    _this.valueLabelStart = '';\n    /**\n     * An optional label for the slider's end value displayed when\n     * range is true; if not set, the label is the valueEnd itself.\n     */\n    _this.valueLabelEnd = '';\n    /**\n     * Aria label for the slider's start handle displayed when\n     * range is true.\n     */\n    _this.ariaLabelStart = '';\n    /**\n     * Aria value text for the slider's start value displayed when\n     * range is true.\n     */\n    _this.ariaValueTextStart = '';\n    /**\n     * Aria label for the slider's end handle displayed when\n     * range is true.\n     */\n    _this.ariaLabelEnd = '';\n    /**\n     * Aria value text for the slider's end value displayed when\n     * range is true.\n     */\n    _this.ariaValueTextEnd = '';\n    /**\n     * The step between values.\n     */\n    _this.step = 1;\n    /**\n     * Whether or not to show tick marks.\n     */\n    _this.ticks = false;\n    /**\n     * Whether or not to show a value label when activated.\n     */\n    _this.labeled = false;\n    /**\n     * Whether or not to show a value range. When false, the slider displays\n     * a slideable handle for the value property; when true, it displays\n     * slideable handles for the valueStart and valueEnd properties.\n     */\n    _this.range = false;\n    // handle hover/pressed states are set manually since the handle\n    // does not receive pointer events so that the native inputs are\n    // interaction targets.\n    _this.handleStartHover = false;\n    _this.handleEndHover = false;\n    _this.startOnTop = false;\n    _this.handlesOverlapping = false;\n    // used in synthetic events generated to control ripple hover state.\n    _this.ripplePointerId = 1;\n    // flag to prevent processing of re-dispatched input event.\n    _this.isRedispatchingEvent = false;\n    if (!isServer) {\n      _this.addEventListener('click', function (event) {\n        if (!isActivationClick(event) || !_this.inputEnd) {\n          return;\n        }\n        _this.focus();\n        dispatchActivationClick(_this.inputEnd);\n      });\n    }\n    return _this;\n  }\n  _createClass(Slider, [{\n    key: \"nameStart\",\n    get:\n    /**\n     * The HTML name to use in form submission for a range slider's starting\n     * value. Use `name` instead if both the start and end values should use the\n     * same name.\n     */\n    function get() {\n      var _this$getAttribute;\n      return (_this$getAttribute = this.getAttribute('name-start')) !== null && _this$getAttribute !== void 0 ? _this$getAttribute : this.name;\n    },\n    set: function set(name) {\n      this.setAttribute('name-start', name);\n    }\n    /**\n     * The HTML name to use in form submission for a range slider's ending value.\n     * Use `name` instead if both the start and end values should use the same\n     * name.\n     */\n  }, {\n    key: \"nameEnd\",\n    get: function get() {\n      var _this$getAttribute2;\n      return (_this$getAttribute2 = this.getAttribute('name-end')) !== null && _this$getAttribute2 !== void 0 ? _this$getAttribute2 : this.nameStart;\n    },\n    set: function set(name) {\n      this.setAttribute('name-end', name);\n    }\n    // Note: start aria-* properties are only applied when range=true, which is\n    // why they do not need to handle both cases.\n  }, {\n    key: \"renderAriaLabelStart\",\n    get: function get() {\n      // Needed for closure conformance\n      var ariaLabel = this.ariaLabel;\n      return this.ariaLabelStart || ariaLabel && \"\".concat(ariaLabel, \" start\") || this.valueLabelStart || String(this.valueStart);\n    }\n  }, {\n    key: \"renderAriaValueTextStart\",\n    get: function get() {\n      return this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart);\n    }\n    // Note: end aria-* properties are applied for single and range sliders, which\n    // is why it needs to handle `this.range` (while start aria-* properties do\n    // not).\n  }, {\n    key: \"renderAriaLabelEnd\",\n    get: function get() {\n      // Needed for closure conformance\n      var ariaLabel = this.ariaLabel;\n      if (this.range) {\n        return this.ariaLabelEnd || ariaLabel && \"\".concat(ariaLabel, \" end\") || this.valueLabelEnd || String(this.valueEnd);\n      }\n      return ariaLabel || this.valueLabel || String(this.value);\n    }\n  }, {\n    key: \"renderAriaValueTextEnd\",\n    get: function get() {\n      if (this.range) {\n        return this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd);\n      }\n      // Needed for conformance\n      var ariaValueText = this.ariaValueText;\n      return ariaValueText || this.valueLabel || String(this.value);\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var _this$inputEnd;\n      (_this$inputEnd = this.inputEnd) === null || _this$inputEnd === void 0 || _this$inputEnd.focus();\n    }\n  }, {\n    key: \"willUpdate\",\n    value: function willUpdate(changed) {\n      var _this$inputStart, _this$inputEnd2;\n      this.renderValueStart = changed.has('valueStart') ? this.valueStart : (_this$inputStart = this.inputStart) === null || _this$inputStart === void 0 ? void 0 : _this$inputStart.valueAsNumber;\n      var endValueChanged = changed.has('valueEnd') && this.range || changed.has('value');\n      this.renderValueEnd = endValueChanged ? this.range ? this.valueEnd : this.value : (_this$inputEnd2 = this.inputEnd) === null || _this$inputEnd2 === void 0 ? void 0 : _this$inputEnd2.valueAsNumber;\n      // manually handle ripple hover state since the handle is pointer events\n      // none.\n      if (changed.get('handleStartHover') !== undefined) {\n        this.toggleRippleHover(this.rippleStart, this.handleStartHover);\n      } else if (changed.get('handleEndHover') !== undefined) {\n        this.toggleRippleHover(this.rippleEnd, this.handleEndHover);\n      }\n    }\n  }, {\n    key: \"updated\",\n    value: function updated(changed) {\n      // Validate input rendered value and re-render if necessary. This ensures\n      // the rendred handle stays in sync with the input thumb which is used for\n      // interaction. These can get out of sync if a supplied value does not\n      // map to an exactly stepped value between min and max.\n      if (this.range) {\n        this.renderValueStart = this.inputStart.valueAsNumber;\n      }\n      this.renderValueEnd = this.inputEnd.valueAsNumber;\n      // update values if they are unset\n      // when using a range, default to equi-distant between\n      // min - valueStart - valueEnd - max\n      if (this.range) {\n        var segment = (this.max - this.min) / 3;\n        if (this.valueStart === undefined) {\n          this.inputStart.valueAsNumber = this.min + segment;\n          // read actual value from input\n          var v = this.inputStart.valueAsNumber;\n          this.valueStart = this.renderValueStart = v;\n        }\n        if (this.valueEnd === undefined) {\n          this.inputEnd.valueAsNumber = this.min + 2 * segment;\n          // read actual value from input\n          var _v = this.inputEnd.valueAsNumber;\n          this.valueEnd = this.renderValueEnd = _v;\n        }\n      } else {\n        var _this$value;\n        (_this$value = this.value) !== null && _this$value !== void 0 ? _this$value : this.value = this.renderValueEnd;\n      }\n      if (changed.has('range') || changed.has('renderValueStart') || changed.has('renderValueEnd') || this.isUpdatePending) {\n        var _this$handleStart, _this$handleEnd;\n        // Only check if the handle nubs are overlapping, as the ripple touch\n        // target extends subtantially beyond the boundary of the handle nub.\n        var startNub = (_this$handleStart = this.handleStart) === null || _this$handleStart === void 0 ? void 0 : _this$handleStart.querySelector('.handleNub');\n        var endNub = (_this$handleEnd = this.handleEnd) === null || _this$handleEnd === void 0 ? void 0 : _this$handleEnd.querySelector('.handleNub');\n        this.handlesOverlapping = isOverlapping(startNub, endNub);\n      }\n      // called to finish the update imediately;\n      // note, this is a no-op unless an update is scheduled\n      this.performUpdate();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$renderValueStar,\n        _this$renderValueEnd,\n        _this$valueEnd,\n        _this$valueStart,\n        _this2 = this;\n      var step = this.step === 0 ? 1 : this.step;\n      var range = Math.max(this.max - this.min, step);\n      var startFraction = this.range ? (((_this$renderValueStar = this.renderValueStart) !== null && _this$renderValueStar !== void 0 ? _this$renderValueStar : this.min) - this.min) / range : 0;\n      var endFraction = (((_this$renderValueEnd = this.renderValueEnd) !== null && _this$renderValueEnd !== void 0 ? _this$renderValueEnd : this.min) - this.min) / range;\n      var containerStyles = {\n        // for clipping inputs and active track.\n        '--_start-fraction': String(startFraction),\n        '--_end-fraction': String(endFraction),\n        // for generating tick marks\n        '--_tick-count': String(range / step)\n      };\n      var containerClasses = {\n        ranged: this.range\n      };\n      // optional label values to show in place of the value.\n      var labelStart = this.valueLabelStart || String(this.renderValueStart);\n      var labelEnd = (this.range ? this.valueLabelEnd : this.valueLabel) || String(this.renderValueEnd);\n      var inputStartProps = {\n        start: true,\n        value: this.renderValueStart,\n        ariaLabel: this.renderAriaLabelStart,\n        ariaValueText: this.renderAriaValueTextStart,\n        ariaMin: this.min,\n        ariaMax: (_this$valueEnd = this.valueEnd) !== null && _this$valueEnd !== void 0 ? _this$valueEnd : this.max\n      };\n      var inputEndProps = {\n        start: false,\n        value: this.renderValueEnd,\n        ariaLabel: this.renderAriaLabelEnd,\n        ariaValueText: this.renderAriaValueTextEnd,\n        ariaMin: this.range ? (_this$valueStart = this.valueStart) !== null && _this$valueStart !== void 0 ? _this$valueStart : this.min : this.min,\n        ariaMax: this.max\n      };\n      var handleStartProps = {\n        start: true,\n        hover: this.handleStartHover,\n        label: labelStart\n      };\n      var handleEndProps = {\n        start: false,\n        hover: this.handleEndHover,\n        label: labelEnd\n      };\n      var handleContainerClasses = {\n        hover: this.handleStartHover || this.handleEndHover\n      };\n      return html(_templateObject || (_templateObject = _taggedTemplateLiteral([\" <div\\n      class=\\\"container \", \"\\\"\\n      style=\", \">\\n      \", \"\\n      \", \" \", \"\\n      <div class=\\\"handleContainerPadded\\\">\\n        <div class=\\\"handleContainerBlock\\\">\\n          <div class=\\\"handleContainer \", \"\\\">\\n            \", \"\\n            \", \"\\n          </div>\\n        </div>\\n      </div>\\n    </div>\"])), classMap(containerClasses), styleMap(containerStyles), when(this.range, function () {\n        return _this2.renderInput(inputStartProps);\n      }), this.renderInput(inputEndProps), this.renderTrack(), classMap(handleContainerClasses), when(this.range, function () {\n        return _this2.renderHandle(handleStartProps);\n      }), this.renderHandle(handleEndProps));\n    }\n  }, {\n    key: \"renderTrack\",\n    value: function renderTrack() {\n      return html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n      <div class=\\\"track\\\"></div>\\n      \", \"\\n    \"])), this.ticks ? html(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"<div class=\\\"tickmarks\\\"></div>\"]))) : nothing);\n    }\n  }, {\n    key: \"renderLabel\",\n    value: function renderLabel(value) {\n      return html(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"<div class=\\\"label\\\" aria-hidden=\\\"true\\\">\\n      <span class=\\\"labelContent\\\" part=\\\"label\\\">\", \"</span>\\n    </div>\"])), value);\n    }\n  }, {\n    key: \"renderHandle\",\n    value: function renderHandle(_ref) {\n      var _this3 = this;\n      var start = _ref.start,\n        hover = _ref.hover,\n        label = _ref.label;\n      var onTop = !this.disabled && start === this.startOnTop;\n      var isOverlapping = !this.disabled && this.handlesOverlapping;\n      var name = start ? 'start' : 'end';\n      return html(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"<div\\n      class=\\\"handle \", \"\\\">\\n      <md-focus-ring part=\\\"focus-ring\\\" for=\", \"></md-focus-ring>\\n      <md-ripple\\n        for=\", \"\\n        class=\", \"\\n        ?disabled=\", \"></md-ripple>\\n      <div class=\\\"handleNub\\\"><md-elevation></md-elevation></div>\\n      \", \"\\n    </div>\"])), classMap(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, name, true), \"hover\", hover), \"onTop\", onTop), \"isOverlapping\", isOverlapping)), name, name, name, this.disabled, when(this.labeled, function () {\n        return _this3.renderLabel(label);\n      }));\n    }\n  }, {\n    key: \"renderInput\",\n    value: function renderInput(_ref2) {\n      var start = _ref2.start,\n        value = _ref2.value,\n        ariaLabel = _ref2.ariaLabel,\n        ariaValueText = _ref2.ariaValueText,\n        ariaMin = _ref2.ariaMin,\n        ariaMax = _ref2.ariaMax;\n      // Slider requires min/max set to the overall min/max for both inputs.\n      // This is reported to screen readers, which is why we need aria-valuemin\n      // and aria-valuemax.\n      var name = start ? \"start\" : \"end\";\n      return html(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"<input\\n      type=\\\"range\\\"\\n      class=\\\"\", \"\\\"\\n      @focus=\", \"\\n      @pointerdown=\", \"\\n      @pointerup=\", \"\\n      @pointerenter=\", \"\\n      @pointermove=\", \"\\n      @pointerleave=\", \"\\n      @keydown=\", \"\\n      @keyup=\", \"\\n      @input=\", \"\\n      @change=\", \"\\n      id=\", \"\\n      .disabled=\", \"\\n      .min=\", \"\\n      aria-valuemin=\", \"\\n      .max=\", \"\\n      aria-valuemax=\", \"\\n      .step=\", \"\\n      .value=\", \"\\n      .tabIndex=\", \"\\n      aria-label=\", \"\\n      aria-valuetext=\", \" />\"])), classMap({\n        start: start,\n        end: !start\n      }), this.handleFocus, this.handleDown, this.handleUp, this.handleEnter, this.handleMove, this.handleLeave, this.handleKeydown, this.handleKeyup, this.handleInput, this.handleChange, name, this.disabled, String(this.min), ariaMin, String(this.max), ariaMax, String(this.step), String(value), start ? 1 : 0, ariaLabel || nothing, ariaValueText);\n    }\n  }, {\n    key: \"toggleRippleHover\",\n    value: function () {\n      var _toggleRippleHover = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ripple, hovering) {\n        var rippleEl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return ripple;\n            case 2:\n              rippleEl = _context.sent;\n              if (rippleEl) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 5:\n              // TODO(b/269799771): improve slider ripple connection\n              if (hovering) {\n                rippleEl.handlePointerenter(new PointerEvent('pointerenter', {\n                  isPrimary: true,\n                  pointerId: this.ripplePointerId\n                }));\n              } else {\n                rippleEl.handlePointerleave(new PointerEvent('pointerleave', {\n                  isPrimary: true,\n                  pointerId: this.ripplePointerId\n                }));\n              }\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function toggleRippleHover(_x, _x2) {\n        return _toggleRippleHover.apply(this, arguments);\n      }\n      return toggleRippleHover;\n    }()\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus(event) {\n      this.updateOnTop(event.target);\n    }\n  }, {\n    key: \"startAction\",\n    value: function startAction(event) {\n      var target = event.target;\n      var fixed = target === this.inputStart ? this.inputEnd : this.inputStart;\n      this.action = {\n        canFlip: event.type === 'pointerdown',\n        flipped: false,\n        target: target,\n        fixed: fixed,\n        values: new Map([[target, target.valueAsNumber], [fixed, fixed === null || fixed === void 0 ? void 0 : fixed.valueAsNumber]])\n      };\n    }\n  }, {\n    key: \"finishAction\",\n    value: function finishAction(event) {\n      this.action = undefined;\n    }\n  }, {\n    key: \"handleKeydown\",\n    value: function handleKeydown(event) {\n      this.startAction(event);\n    }\n  }, {\n    key: \"handleKeyup\",\n    value: function handleKeyup(event) {\n      this.finishAction(event);\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(event) {\n      this.startAction(event);\n      this.ripplePointerId = event.pointerId;\n      var isStart = event.target === this.inputStart;\n      // Since handle moves to pointer on down and there may not be a move,\n      // it needs to be considered hovered..\n      this.handleStartHover = !this.disabled && isStart && Boolean(this.handleStart);\n      this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);\n    }\n  }, {\n    key: \"handleUp\",\n    value: function () {\n      var _handleUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event) {\n        var _this$action, target, values, flipped;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.action) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              _this$action = this.action, target = _this$action.target, values = _this$action.values, flipped = _this$action.flipped; //  Async here for Firefox because input can be after pointerup\n              //  when value is calmped.\n              _context2.next = 5;\n              return new Promise(requestAnimationFrame);\n            case 5:\n              if (target !== undefined) {\n                // Ensure Safari focuses input so label renders.\n                // Ensure any flipped input is focused so the tab order is right.\n                target.focus();\n                // When action is flipped, change must be fired manually since the\n                // real event target did not change.\n                if (flipped && target.valueAsNumber !== values.get(target)) {\n                  target.dispatchEvent(new Event('change', {\n                    bubbles: true\n                  }));\n                }\n              }\n              this.finishAction(event);\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function handleUp(_x3) {\n        return _handleUp.apply(this, arguments);\n      }\n      return handleUp;\n    }()\n    /**\n     * The move handler tracks handle hovering to facilitate proper ripple\n     * behavior on the slider handle. This is needed because user interaction with\n     * the native input is leveraged to position the handle. Because the separate\n     * displayed handle element has pointer events disabled (to allow interaction\n     * with the input) and the input's handle is a pseudo-element, neither can be\n     * the ripple's interactive element. Therefore the input is the ripple's\n     * interactive element and has a `ripple` directive; however the ripple\n     * is gated on the handle being hovered. In addition, because the ripple\n     * hover state is being specially handled, it must be triggered independent\n     * of the directive. This is done based on the hover state when the\n     * slider is updated.\n     */\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(event) {\n      this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);\n      this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(event) {\n      this.handleMove(event);\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave() {\n      this.handleStartHover = false;\n      this.handleEndHover = false;\n    }\n  }, {\n    key: \"updateOnTop\",\n    value: function updateOnTop(input) {\n      this.startOnTop = input.classList.contains('start');\n    }\n  }, {\n    key: \"needsClamping\",\n    value: function needsClamping() {\n      if (!this.action) {\n        return false;\n      }\n      var _this$action2 = this.action,\n        target = _this$action2.target,\n        fixed = _this$action2.fixed;\n      var isStart = target === this.inputStart;\n      return isStart ? target.valueAsNumber > fixed.valueAsNumber : target.valueAsNumber < fixed.valueAsNumber;\n    }\n    // if start/end start coincident and the first drag input would e.g. move\n    // start > end, avoid clamping and \"flip\" to use the other input\n    // as the action target.\n  }, {\n    key: \"isActionFlipped\",\n    value: function isActionFlipped() {\n      var action = this.action;\n      if (!action) {\n        return false;\n      }\n      var target = action.target,\n        fixed = action.fixed,\n        values = action.values;\n      if (action.canFlip) {\n        var coincident = values.get(target) === values.get(fixed);\n        if (coincident && this.needsClamping()) {\n          action.canFlip = false;\n          action.flipped = true;\n          action.target = fixed;\n          action.fixed = target;\n        }\n      }\n      return action.flipped;\n    }\n    // when flipped, apply the drag input to the flipped target and reset\n    // the actual target.\n  }, {\n    key: \"flipAction\",\n    value: function flipAction() {\n      if (!this.action) {\n        return false;\n      }\n      var _this$action3 = this.action,\n        target = _this$action3.target,\n        fixed = _this$action3.fixed,\n        values = _this$action3.values;\n      var changed = target.valueAsNumber !== fixed.valueAsNumber;\n      target.valueAsNumber = fixed.valueAsNumber;\n      fixed.valueAsNumber = values.get(fixed);\n      return changed;\n    }\n    // clamp such that start does not move beyond end and visa versa.\n  }, {\n    key: \"clampAction\",\n    value: function clampAction() {\n      if (!this.needsClamping() || !this.action) {\n        return false;\n      }\n      var _this$action4 = this.action,\n        target = _this$action4.target,\n        fixed = _this$action4.fixed;\n      target.valueAsNumber = fixed.valueAsNumber;\n      return true;\n    }\n  }, {\n    key: \"handleInput\",\n    value: function handleInput(event) {\n      // avoid processing a re-dispatched event\n      if (this.isRedispatchingEvent) {\n        return;\n      }\n      var stopPropagation = false;\n      var redispatch = false;\n      if (this.range) {\n        if (this.isActionFlipped()) {\n          stopPropagation = true;\n          redispatch = this.flipAction();\n        }\n        if (this.clampAction()) {\n          stopPropagation = true;\n          redispatch = false;\n        }\n      }\n      var target = event.target;\n      this.updateOnTop(target);\n      // update value only on interaction\n      if (this.range) {\n        this.valueStart = this.inputStart.valueAsNumber;\n        this.valueEnd = this.inputEnd.valueAsNumber;\n      } else {\n        this.value = this.inputEnd.valueAsNumber;\n      }\n      // control external visibility of input event\n      if (stopPropagation) {\n        event.stopPropagation();\n      }\n      // ensure event path is correct when flipped.\n      if (redispatch) {\n        this.isRedispatchingEvent = true;\n        redispatchEvent(target, event);\n        this.isRedispatchingEvent = false;\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(event) {\n      var _this$action5;\n      // prevent keyboard triggered changes from dispatching for\n      // clamped values; note, this only occurs for keyboard\n      var changeTarget = event.target;\n      var _ref3 = (_this$action5 = this.action) !== null && _this$action5 !== void 0 ? _this$action5 : {},\n        target = _ref3.target,\n        values = _ref3.values;\n      var squelch = target && target.valueAsNumber === values.get(changeTarget);\n      if (!squelch) {\n        redispatchEvent(this, event);\n      }\n      // ensure keyboard triggered change clears action.\n      this.finishAction(event);\n    }\n  }, {\n    key: getFormValue,\n    value: function value() {\n      if (this.range) {\n        var data = new FormData();\n        data.append(this.nameStart, String(this.valueStart));\n        data.append(this.nameEnd, String(this.valueEnd));\n        return data;\n      }\n      return String(this.value);\n    }\n  }, {\n    key: \"formResetCallback\",\n    value: function formResetCallback() {\n      if (this.range) {\n        var valueStart = this.getAttribute('value-start');\n        this.valueStart = valueStart !== null ? Number(valueStart) : undefined;\n        var valueEnd = this.getAttribute('value-end');\n        this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;\n        return;\n      }\n      var value = this.getAttribute('value');\n      this.value = value !== null ? Number(value) : undefined;\n    }\n  }, {\n    key: \"formStateRestoreCallback\",\n    value: function formStateRestoreCallback(state) {\n      if (Array.isArray(state)) {\n        var _state = _slicedToArray(state, 2),\n          _state$ = _slicedToArray(_state[0], 2),\n          valueStart = _state$[1],\n          _state$2 = _slicedToArray(_state[1], 2),\n          valueEnd = _state$2[1];\n        this.valueStart = Number(valueStart);\n        this.valueEnd = Number(valueEnd);\n        this.range = true;\n        return;\n      }\n      this.value = Number(state);\n      this.range = false;\n    }\n  }]);\n  return Slider;\n}(sliderBaseClass);\n(function () {\n  requestUpdateOnAriaChange(Slider);\n})();\n/** @nocollapse */\nSlider.shadowRootOptions = Object.assign(Object.assign({}, LitElement.shadowRootOptions), {}, {\n  delegatesFocus: true\n});\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"min\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"max\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"value\", void 0);\n__decorate([property({\n  type: Number,\n  attribute: 'value-start'\n})], Slider.prototype, \"valueStart\", void 0);\n__decorate([property({\n  type: Number,\n  attribute: 'value-end'\n})], Slider.prototype, \"valueEnd\", void 0);\n__decorate([property({\n  attribute: 'value-label'\n})], Slider.prototype, \"valueLabel\", void 0);\n__decorate([property({\n  attribute: 'value-label-start'\n})], Slider.prototype, \"valueLabelStart\", void 0);\n__decorate([property({\n  attribute: 'value-label-end'\n})], Slider.prototype, \"valueLabelEnd\", void 0);\n__decorate([property({\n  attribute: 'aria-label-start'\n})], Slider.prototype, \"ariaLabelStart\", void 0);\n__decorate([property({\n  attribute: 'aria-valuetext-start'\n})], Slider.prototype, \"ariaValueTextStart\", void 0);\n__decorate([property({\n  attribute: 'aria-label-end'\n})], Slider.prototype, \"ariaLabelEnd\", void 0);\n__decorate([property({\n  attribute: 'aria-valuetext-end'\n})], Slider.prototype, \"ariaValueTextEnd\", void 0);\n__decorate([property({\n  type: Number\n})], Slider.prototype, \"step\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"ticks\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"labeled\", void 0);\n__decorate([property({\n  type: Boolean\n})], Slider.prototype, \"range\", void 0);\n__decorate([query('input.start')], Slider.prototype, \"inputStart\", void 0);\n__decorate([query('.handle.start')], Slider.prototype, \"handleStart\", void 0);\n__decorate([queryAsync('md-ripple.start')], Slider.prototype, \"rippleStart\", void 0);\n__decorate([query('input.end')], Slider.prototype, \"inputEnd\", void 0);\n__decorate([query('.handle.end')], Slider.prototype, \"handleEnd\", void 0);\n__decorate([queryAsync('md-ripple.end')], Slider.prototype, \"rippleEnd\", void 0);\n__decorate([state()], Slider.prototype, \"handleStartHover\", void 0);\n__decorate([state()], Slider.prototype, \"handleEndHover\", void 0);\n__decorate([state()], Slider.prototype, \"startOnTop\", void 0);\n__decorate([state()], Slider.prototype, \"handlesOverlapping\", void 0);\n__decorate([state()], Slider.prototype, \"renderValueStart\", void 0);\n__decorate([state()], Slider.prototype, \"renderValueEnd\", void 0);\nfunction inBounds(_ref4, element) {\n  var x = _ref4.x,\n    y = _ref4.y;\n  if (!element) {\n    return false;\n  }\n  var _element$getBoundingC = element.getBoundingClientRect(),\n    top = _element$getBoundingC.top,\n    left = _element$getBoundingC.left,\n    bottom = _element$getBoundingC.bottom,\n    right = _element$getBoundingC.right;\n  return x >= left && x <= right && y >= top && y <= bottom;\n}\nfunction isOverlapping(elA, elB) {\n  if (!(elA && elB)) {\n    return false;\n  }\n  var a = elA.getBoundingClientRect();\n  var b = elB.getBoundingClientRect();\n  return !(a.top > b.bottom || a.right < b.left || a.bottom < b.top || a.left > b.right);\n}","map":{"version":3,"names":["html","isServer","LitElement","nothing","property","query","queryAsync","state","classMap","styleMap","when","requestUpdateOnAriaChange","dispatchActivationClick","isActivationClick","redispatchEvent","mixinElementInternals","getFormValue","mixinFormAssociated","sliderBaseClass","Slider","_sliderBaseClass","_inherits","_this","_classCallCheck","_callSuper","min","max","valueLabel","valueLabelStart","valueLabelEnd","ariaLabelStart","ariaValueTextStart","ariaLabelEnd","ariaValueTextEnd","step","ticks","labeled","range","handleStartHover","handleEndHover","startOnTop","handlesOverlapping","ripplePointerId","isRedispatchingEvent","addEventListener","event","inputEnd","focus","_createClass","key","get","_this$getAttribute","getAttribute","name","set","setAttribute","_this$getAttribute2","nameStart","ariaLabel","concat","String","valueStart","valueEnd","value","ariaValueText","_this$inputEnd","willUpdate","changed","_this$inputStart","_this$inputEnd2","renderValueStart","has","inputStart","valueAsNumber","endValueChanged","renderValueEnd","undefined","toggleRippleHover","rippleStart","rippleEnd","updated","segment","v","_this$value","isUpdatePending","_this$handleStart","_this$handleEnd","startNub","handleStart","querySelector","endNub","handleEnd","isOverlapping","performUpdate","render","_this$renderValueStar","_this$renderValueEnd","_this$valueEnd","_this$valueStart","_this2","Math","startFraction","endFraction","containerStyles","containerClasses","ranged","labelStart","labelEnd","inputStartProps","start","renderAriaLabelStart","renderAriaValueTextStart","ariaMin","ariaMax","inputEndProps","renderAriaLabelEnd","renderAriaValueTextEnd","handleStartProps","hover","label","handleEndProps","handleContainerClasses","_templateObject","_taggedTemplateLiteral","renderInput","renderTrack","renderHandle","_templateObject2","_templateObject3","renderLabel","_templateObject4","_ref","_this3","onTop","disabled","_templateObject5","_defineProperty","_ref2","_templateObject6","end","handleFocus","handleDown","handleUp","handleEnter","handleMove","handleLeave","handleKeydown","handleKeyup","handleInput","handleChange","_toggleRippleHover","_asyncToGenerator","_regeneratorRuntime","mark","_callee","ripple","hovering","rippleEl","wrap","_callee$","_context","prev","next","sent","abrupt","handlePointerenter","PointerEvent","isPrimary","pointerId","handlePointerleave","stop","_x","_x2","apply","arguments","updateOnTop","target","startAction","fixed","action","canFlip","type","flipped","values","Map","finishAction","isStart","Boolean","_handleUp","_callee2","_this$action","_callee2$","_context2","Promise","requestAnimationFrame","dispatchEvent","Event","bubbles","_x3","inBounds","input","classList","contains","needsClamping","_this$action2","isActionFlipped","coincident","flipAction","_this$action3","clampAction","_this$action4","stopPropagation","redispatch","_this$action5","changeTarget","_ref3","squelch","data","FormData","append","nameEnd","formResetCallback","Number","formStateRestoreCallback","Array","isArray","_state","_slicedToArray","_state$","_state$2","shadowRootOptions","Object","assign","delegatesFocus","__decorate","attribute","_ref4","element","x","y","_element$getBoundingC","getBoundingClientRect","top","left","bottom","right","elA","elB","a","b"],"sources":["slider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport '../../elevation/elevation.js';\nimport '../../focus/md-focus-ring.js';\nimport '../../ripple/ripple.js';\n\nimport {html, isServer, LitElement, nothing, PropertyValues} from 'lit';\nimport {property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {styleMap} from 'lit/directives/style-map.js';\nimport {when} from 'lit/directives/when.js';\n\nimport {ARIAMixinStrict} from '../../internal/aria/aria.js';\nimport {requestUpdateOnAriaChange} from '../../internal/aria/delegate.js';\nimport {\n  dispatchActivationClick,\n  isActivationClick,\n} from '../../internal/events/form-label-activation.js';\nimport {redispatchEvent} from '../../internal/events/redispatch-event.js';\nimport {mixinElementInternals} from '../../labs/behaviors/element-internals.js';\nimport {\n  getFormValue,\n  mixinFormAssociated,\n} from '../../labs/behaviors/form-associated.js';\nimport {MdRipple} from '../../ripple/ripple.js';\n\n// Disable warning for classMap with destructuring\n// tslint:disable:no-implicit-dictionary-conversion\n\n// Separate variable needed for closure.\nconst sliderBaseClass = mixinFormAssociated(mixinElementInternals(LitElement));\n\n/**\n * Slider component.\n *\n *\n * @fires change {Event} The native `change` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)\n * --bubbles\n * @fires input {InputEvent} The native `input` event on\n * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)\n * --bubbles --composed\n */\nexport class Slider extends sliderBaseClass {\n  static {\n    requestUpdateOnAriaChange(Slider);\n  }\n\n  /** @nocollapse */\n  static override shadowRootOptions: ShadowRootInit = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  /**\n   * The slider minimum value\n   */\n  @property({type: Number}) min = 0;\n\n  /**\n   * The slider maximum value\n   */\n  @property({type: Number}) max = 100;\n\n  /**\n   * The slider value displayed when range is false.\n   */\n  @property({type: Number}) value?: number;\n\n  /**\n   * The slider start value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-start'}) valueStart?: number;\n\n  /**\n   * The slider end value displayed when range is true.\n   */\n  @property({type: Number, attribute: 'value-end'}) valueEnd?: number;\n\n  /**\n   * An optional label for the slider's value displayed when range is\n   * false; if not set, the label is the value itself.\n   */\n  @property({attribute: 'value-label'}) valueLabel = '';\n\n  /**\n   * An optional label for the slider's start value displayed when\n   * range is true; if not set, the label is the valueStart itself.\n   */\n  @property({attribute: 'value-label-start'}) valueLabelStart = '';\n\n  /**\n   * An optional label for the slider's end value displayed when\n   * range is true; if not set, the label is the valueEnd itself.\n   */\n  @property({attribute: 'value-label-end'}) valueLabelEnd = '';\n\n  /**\n   * Aria label for the slider's start handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-start'}) ariaLabelStart = '';\n\n  /**\n   * Aria value text for the slider's start value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-start'}) ariaValueTextStart = '';\n\n  /**\n   * Aria label for the slider's end handle displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-label-end'}) ariaLabelEnd = '';\n\n  /**\n   * Aria value text for the slider's end value displayed when\n   * range is true.\n   */\n  @property({attribute: 'aria-valuetext-end'}) ariaValueTextEnd = '';\n\n  /**\n   * The step between values.\n   */\n  @property({type: Number}) step = 1;\n\n  /**\n   * Whether or not to show tick marks.\n   */\n  @property({type: Boolean}) ticks = false;\n\n  /**\n   * Whether or not to show a value label when activated.\n   */\n  @property({type: Boolean}) labeled = false;\n\n  /**\n   * Whether or not to show a value range. When false, the slider displays\n   * a slideable handle for the value property; when true, it displays\n   * slideable handles for the valueStart and valueEnd properties.\n   */\n  @property({type: Boolean}) range = false;\n\n  /**\n   * The HTML name to use in form submission for a range slider's starting\n   * value. Use `name` instead if both the start and end values should use the\n   * same name.\n   */\n  get nameStart() {\n    return this.getAttribute('name-start') ?? this.name;\n  }\n  set nameStart(name: string) {\n    this.setAttribute('name-start', name);\n  }\n\n  /**\n   * The HTML name to use in form submission for a range slider's ending value.\n   * Use `name` instead if both the start and end values should use the same\n   * name.\n   */\n  get nameEnd() {\n    return this.getAttribute('name-end') ?? this.nameStart;\n  }\n  set nameEnd(name: string) {\n    this.setAttribute('name-end', name);\n  }\n\n  @query('input.start') private readonly inputStart!: HTMLInputElement | null;\n  @query('.handle.start') private readonly handleStart!: HTMLDivElement | null;\n  @queryAsync('md-ripple.start')\n  private readonly rippleStart!: Promise<MdRipple | null>;\n\n  @query('input.end') private readonly inputEnd!: HTMLInputElement | null;\n  @query('.handle.end') private readonly handleEnd!: HTMLDivElement | null;\n  @queryAsync('md-ripple.end')\n  private readonly rippleEnd!: Promise<MdRipple | null>;\n\n  // handle hover/pressed states are set manually since the handle\n  // does not receive pointer events so that the native inputs are\n  // interaction targets.\n  @state() private handleStartHover = false;\n  @state() private handleEndHover = false;\n\n  @state() private startOnTop = false;\n  @state() private handlesOverlapping = false;\n\n  @state() private renderValueStart?: number;\n  @state() private renderValueEnd?: number;\n\n  // Note: start aria-* properties are only applied when range=true, which is\n  // why they do not need to handle both cases.\n  private get renderAriaLabelStart() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    return (\n      this.ariaLabelStart ||\n      (ariaLabel && `${ariaLabel} start`) ||\n      this.valueLabelStart ||\n      String(this.valueStart)\n    );\n  }\n\n  private get renderAriaValueTextStart() {\n    return (\n      this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart)\n    );\n  }\n\n  // Note: end aria-* properties are applied for single and range sliders, which\n  // is why it needs to handle `this.range` (while start aria-* properties do\n  // not).\n  private get renderAriaLabelEnd() {\n    // Needed for closure conformance\n    const {ariaLabel} = this as ARIAMixinStrict;\n    if (this.range) {\n      return (\n        this.ariaLabelEnd ||\n        (ariaLabel && `${ariaLabel} end`) ||\n        this.valueLabelEnd ||\n        String(this.valueEnd)\n      );\n    }\n\n    return ariaLabel || this.valueLabel || String(this.value);\n  }\n\n  private get renderAriaValueTextEnd() {\n    if (this.range) {\n      return (\n        this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd)\n      );\n    }\n\n    // Needed for conformance\n    const {ariaValueText} = this as ARIAMixinStrict;\n    return ariaValueText || this.valueLabel || String(this.value);\n  }\n\n  // used in synthetic events generated to control ripple hover state.\n  private ripplePointerId = 1;\n\n  // flag to prevent processing of re-dispatched input event.\n  private isRedispatchingEvent = false;\n\n  private action?: Action;\n\n  constructor() {\n    super();\n    if (!isServer) {\n      this.addEventListener('click', (event: MouseEvent) => {\n        if (!isActivationClick(event) || !this.inputEnd) {\n          return;\n        }\n        this.focus();\n        dispatchActivationClick(this.inputEnd);\n      });\n    }\n  }\n\n  override focus() {\n    this.inputEnd?.focus();\n  }\n\n  protected override willUpdate(changed: PropertyValues) {\n    this.renderValueStart = changed.has('valueStart')\n      ? this.valueStart\n      : this.inputStart?.valueAsNumber;\n    const endValueChanged =\n      (changed.has('valueEnd') && this.range) || changed.has('value');\n    this.renderValueEnd = endValueChanged\n      ? this.range\n        ? this.valueEnd\n        : this.value\n      : this.inputEnd?.valueAsNumber;\n    // manually handle ripple hover state since the handle is pointer events\n    // none.\n    if (changed.get('handleStartHover') !== undefined) {\n      this.toggleRippleHover(this.rippleStart, this.handleStartHover);\n    } else if (changed.get('handleEndHover') !== undefined) {\n      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);\n    }\n  }\n\n  protected override updated(changed: PropertyValues) {\n    // Validate input rendered value and re-render if necessary. This ensures\n    // the rendred handle stays in sync with the input thumb which is used for\n    // interaction. These can get out of sync if a supplied value does not\n    // map to an exactly stepped value between min and max.\n    if (this.range) {\n      this.renderValueStart = this.inputStart!.valueAsNumber;\n    }\n    this.renderValueEnd = this.inputEnd!.valueAsNumber;\n    // update values if they are unset\n    // when using a range, default to equi-distant between\n    // min - valueStart - valueEnd - max\n    if (this.range) {\n      const segment = (this.max - this.min) / 3;\n      if (this.valueStart === undefined) {\n        this.inputStart!.valueAsNumber = this.min + segment;\n        // read actual value from input\n        const v = this.inputStart!.valueAsNumber;\n        this.valueStart = this.renderValueStart = v;\n      }\n      if (this.valueEnd === undefined) {\n        this.inputEnd!.valueAsNumber = this.min + 2 * segment;\n        // read actual value from input\n        const v = this.inputEnd!.valueAsNumber;\n        this.valueEnd = this.renderValueEnd = v;\n      }\n    } else {\n      this.value ??= this.renderValueEnd;\n    }\n    if (\n      changed.has('range') ||\n      changed.has('renderValueStart') ||\n      changed.has('renderValueEnd') ||\n      this.isUpdatePending\n    ) {\n      // Only check if the handle nubs are overlapping, as the ripple touch\n      // target extends subtantially beyond the boundary of the handle nub.\n      const startNub = this.handleStart?.querySelector('.handleNub');\n      const endNub = this.handleEnd?.querySelector('.handleNub');\n      this.handlesOverlapping = isOverlapping(startNub, endNub);\n    }\n    // called to finish the update imediately;\n    // note, this is a no-op unless an update is scheduled\n    this.performUpdate();\n  }\n\n  protected override render() {\n    const step = this.step === 0 ? 1 : this.step;\n    const range = Math.max(this.max - this.min, step);\n    const startFraction = this.range\n      ? ((this.renderValueStart ?? this.min) - this.min) / range\n      : 0;\n    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;\n    const containerStyles = {\n      // for clipping inputs and active track.\n      '--_start-fraction': String(startFraction),\n      '--_end-fraction': String(endFraction),\n      // for generating tick marks\n      '--_tick-count': String(range / step),\n    };\n    const containerClasses = {ranged: this.range};\n\n    // optional label values to show in place of the value.\n    const labelStart = this.valueLabelStart || String(this.renderValueStart);\n    const labelEnd =\n      (this.range ? this.valueLabelEnd : this.valueLabel) ||\n      String(this.renderValueEnd);\n\n    const inputStartProps = {\n      start: true,\n      value: this.renderValueStart,\n      ariaLabel: this.renderAriaLabelStart,\n      ariaValueText: this.renderAriaValueTextStart,\n      ariaMin: this.min,\n      ariaMax: this.valueEnd ?? this.max,\n    };\n\n    const inputEndProps = {\n      start: false,\n      value: this.renderValueEnd,\n      ariaLabel: this.renderAriaLabelEnd,\n      ariaValueText: this.renderAriaValueTextEnd,\n      ariaMin: this.range ? this.valueStart ?? this.min : this.min,\n      ariaMax: this.max,\n    };\n\n    const handleStartProps = {\n      start: true,\n      hover: this.handleStartHover,\n      label: labelStart,\n    };\n\n    const handleEndProps = {\n      start: false,\n      hover: this.handleEndHover,\n      label: labelEnd,\n    };\n\n    const handleContainerClasses = {\n      hover: this.handleStartHover || this.handleEndHover,\n    };\n\n    return html` <div\n      class=\"container ${classMap(containerClasses)}\"\n      style=${styleMap(containerStyles)}>\n      ${when(this.range, () => this.renderInput(inputStartProps))}\n      ${this.renderInput(inputEndProps)} ${this.renderTrack()}\n      <div class=\"handleContainerPadded\">\n        <div class=\"handleContainerBlock\">\n          <div class=\"handleContainer ${classMap(handleContainerClasses)}\">\n            ${when(this.range, () => this.renderHandle(handleStartProps))}\n            ${this.renderHandle(handleEndProps)}\n          </div>\n        </div>\n      </div>\n    </div>`;\n  }\n\n  private renderTrack() {\n    return html`\n      <div class=\"track\"></div>\n      ${this.ticks ? html`<div class=\"tickmarks\"></div>` : nothing}\n    `;\n  }\n\n  private renderLabel(value: string) {\n    return html`<div class=\"label\" aria-hidden=\"true\">\n      <span class=\"labelContent\" part=\"label\">${value}</span>\n    </div>`;\n  }\n\n  private renderHandle({\n    start,\n    hover,\n    label,\n  }: {\n    start: boolean;\n    hover: boolean;\n    label: string;\n  }) {\n    const onTop = !this.disabled && start === this.startOnTop;\n    const isOverlapping = !this.disabled && this.handlesOverlapping;\n    const name = start ? 'start' : 'end';\n    return html`<div\n      class=\"handle ${classMap({\n        [name]: true,\n        hover,\n        onTop,\n        isOverlapping,\n      })}\">\n      <md-focus-ring part=\"focus-ring\" for=${name}></md-focus-ring>\n      <md-ripple\n        for=${name}\n        class=${name}\n        ?disabled=${this.disabled}></md-ripple>\n      <div class=\"handleNub\"><md-elevation></md-elevation></div>\n      ${when(this.labeled, () => this.renderLabel(label))}\n    </div>`;\n  }\n\n  private renderInput({\n    start,\n    value,\n    ariaLabel,\n    ariaValueText,\n    ariaMin,\n    ariaMax,\n  }: {\n    start: boolean;\n    value?: number;\n    ariaLabel: string;\n    ariaValueText: string;\n    ariaMin: number;\n    ariaMax: number;\n  }) {\n    // Slider requires min/max set to the overall min/max for both inputs.\n    // This is reported to screen readers, which is why we need aria-valuemin\n    // and aria-valuemax.\n    const name = start ? `start` : `end`;\n    return html`<input\n      type=\"range\"\n      class=\"${classMap({\n        start,\n        end: !start,\n      })}\"\n      @focus=${this.handleFocus}\n      @pointerdown=${this.handleDown}\n      @pointerup=${this.handleUp}\n      @pointerenter=${this.handleEnter}\n      @pointermove=${this.handleMove}\n      @pointerleave=${this.handleLeave}\n      @keydown=${this.handleKeydown}\n      @keyup=${this.handleKeyup}\n      @input=${this.handleInput}\n      @change=${this.handleChange}\n      id=${name}\n      .disabled=${this.disabled}\n      .min=${String(this.min)}\n      aria-valuemin=${ariaMin}\n      .max=${String(this.max)}\n      aria-valuemax=${ariaMax}\n      .step=${String(this.step)}\n      .value=${String(value)}\n      .tabIndex=${start ? 1 : 0}\n      aria-label=${ariaLabel || nothing}\n      aria-valuetext=${ariaValueText} />`;\n  }\n\n  private async toggleRippleHover(\n    ripple: Promise<MdRipple | null>,\n    hovering: boolean,\n  ) {\n    const rippleEl = await ripple;\n    if (!rippleEl) {\n      return;\n    }\n    // TODO(b/269799771): improve slider ripple connection\n    if (hovering) {\n      rippleEl.handlePointerenter(\n        new PointerEvent('pointerenter', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    } else {\n      rippleEl.handlePointerleave(\n        new PointerEvent('pointerleave', {\n          isPrimary: true,\n          pointerId: this.ripplePointerId,\n        }),\n      );\n    }\n  }\n\n  private handleFocus(event: Event) {\n    this.updateOnTop(event.target as HTMLInputElement);\n  }\n\n  private startAction(event: Event) {\n    const target = event.target as HTMLInputElement;\n    const fixed =\n      target === this.inputStart ? this.inputEnd! : this.inputStart!;\n    this.action = {\n      canFlip: event.type === 'pointerdown',\n      flipped: false,\n      target,\n      fixed,\n      values: new Map([\n        [target, target.valueAsNumber],\n        [fixed, fixed?.valueAsNumber],\n      ]),\n    };\n  }\n\n  private finishAction(event: Event) {\n    this.action = undefined;\n  }\n\n  private handleKeydown(event: KeyboardEvent) {\n    this.startAction(event);\n  }\n\n  private handleKeyup(event: KeyboardEvent) {\n    this.finishAction(event);\n  }\n\n  private handleDown(event: PointerEvent) {\n    this.startAction(event);\n    this.ripplePointerId = event.pointerId;\n    const isStart = (event.target as HTMLInputElement) === this.inputStart;\n    // Since handle moves to pointer on down and there may not be a move,\n    // it needs to be considered hovered..\n    this.handleStartHover =\n      !this.disabled && isStart && Boolean(this.handleStart);\n    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);\n  }\n\n  private async handleUp(event: PointerEvent) {\n    if (!this.action) {\n      return;\n    }\n\n    const {target, values, flipped} = this.action;\n    //  Async here for Firefox because input can be after pointerup\n    //  when value is calmped.\n    await new Promise(requestAnimationFrame);\n    if (target !== undefined) {\n      // Ensure Safari focuses input so label renders.\n      // Ensure any flipped input is focused so the tab order is right.\n      target.focus();\n      // When action is flipped, change must be fired manually since the\n      // real event target did not change.\n      if (flipped && target.valueAsNumber !== values.get(target)!) {\n        target.dispatchEvent(new Event('change', {bubbles: true}));\n      }\n    }\n    this.finishAction(event);\n  }\n\n  /**\n   * The move handler tracks handle hovering to facilitate proper ripple\n   * behavior on the slider handle. This is needed because user interaction with\n   * the native input is leveraged to position the handle. Because the separate\n   * displayed handle element has pointer events disabled (to allow interaction\n   * with the input) and the input's handle is a pseudo-element, neither can be\n   * the ripple's interactive element. Therefore the input is the ripple's\n   * interactive element and has a `ripple` directive; however the ripple\n   * is gated on the handle being hovered. In addition, because the ripple\n   * hover state is being specially handled, it must be triggered independent\n   * of the directive. This is done based on the hover state when the\n   * slider is updated.\n   */\n  private handleMove(event: PointerEvent) {\n    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);\n    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);\n  }\n\n  private handleEnter(event: PointerEvent) {\n    this.handleMove(event);\n  }\n\n  private handleLeave() {\n    this.handleStartHover = false;\n    this.handleEndHover = false;\n  }\n\n  private updateOnTop(input: HTMLInputElement) {\n    this.startOnTop = input.classList.contains('start');\n  }\n\n  private needsClamping() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed} = this.action;\n    const isStart = target === this.inputStart;\n    return isStart\n      ? target.valueAsNumber > fixed.valueAsNumber\n      : target.valueAsNumber < fixed.valueAsNumber;\n  }\n\n  // if start/end start coincident and the first drag input would e.g. move\n  // start > end, avoid clamping and \"flip\" to use the other input\n  // as the action target.\n  private isActionFlipped() {\n    const {action} = this;\n    if (!action) {\n      return false;\n    }\n\n    const {target, fixed, values} = action;\n    if (action.canFlip) {\n      const coincident = values.get(target) === values.get(fixed);\n      if (coincident && this.needsClamping()) {\n        action.canFlip = false;\n        action.flipped = true;\n        action.target = fixed;\n        action.fixed = target;\n      }\n    }\n    return action.flipped;\n  }\n\n  // when flipped, apply the drag input to the flipped target and reset\n  // the actual target.\n  private flipAction() {\n    if (!this.action) {\n      return false;\n    }\n\n    const {target, fixed, values} = this.action;\n    const changed = target.valueAsNumber !== fixed.valueAsNumber;\n    target.valueAsNumber = fixed.valueAsNumber;\n    fixed.valueAsNumber = values.get(fixed)!;\n    return changed;\n  }\n\n  // clamp such that start does not move beyond end and visa versa.\n  private clampAction() {\n    if (!this.needsClamping() || !this.action) {\n      return false;\n    }\n    const {target, fixed} = this.action;\n    target.valueAsNumber = fixed.valueAsNumber;\n    return true;\n  }\n\n  private handleInput(event: InputEvent) {\n    // avoid processing a re-dispatched event\n    if (this.isRedispatchingEvent) {\n      return;\n    }\n    let stopPropagation = false;\n    let redispatch = false;\n    if (this.range) {\n      if (this.isActionFlipped()) {\n        stopPropagation = true;\n        redispatch = this.flipAction();\n      }\n      if (this.clampAction()) {\n        stopPropagation = true;\n        redispatch = false;\n      }\n    }\n    const target = event.target as HTMLInputElement;\n    this.updateOnTop(target);\n    // update value only on interaction\n    if (this.range) {\n      this.valueStart = this.inputStart!.valueAsNumber;\n      this.valueEnd = this.inputEnd!.valueAsNumber;\n    } else {\n      this.value = this.inputEnd!.valueAsNumber;\n    }\n    // control external visibility of input event\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n    // ensure event path is correct when flipped.\n    if (redispatch) {\n      this.isRedispatchingEvent = true;\n      redispatchEvent(target, event);\n      this.isRedispatchingEvent = false;\n    }\n  }\n\n  private handleChange(event: Event) {\n    // prevent keyboard triggered changes from dispatching for\n    // clamped values; note, this only occurs for keyboard\n    const changeTarget = event.target as HTMLInputElement;\n    const {target, values} = this.action ?? {};\n    const squelch =\n      target && target.valueAsNumber === values!.get(changeTarget)!;\n    if (!squelch) {\n      redispatchEvent(this, event);\n    }\n    // ensure keyboard triggered change clears action.\n    this.finishAction(event);\n  }\n\n  // Writable mixin properties for lit-html binding, needed for lit-analyzer\n  declare disabled: boolean;\n  declare name: string;\n\n  override [getFormValue]() {\n    if (this.range) {\n      const data = new FormData();\n      data.append(this.nameStart, String(this.valueStart));\n      data.append(this.nameEnd, String(this.valueEnd));\n      return data;\n    }\n\n    return String(this.value);\n  }\n\n  override formResetCallback() {\n    if (this.range) {\n      const valueStart = this.getAttribute('value-start');\n      this.valueStart = valueStart !== null ? Number(valueStart) : undefined;\n      const valueEnd = this.getAttribute('value-end');\n      this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;\n      return;\n    }\n    const value = this.getAttribute('value');\n    this.value = value !== null ? Number(value) : undefined;\n  }\n\n  override formStateRestoreCallback(\n    state: string | Array<[string, string]> | null,\n  ) {\n    if (Array.isArray(state)) {\n      const [[, valueStart], [, valueEnd]] = state;\n      this.valueStart = Number(valueStart);\n      this.valueEnd = Number(valueEnd);\n      this.range = true;\n      return;\n    }\n\n    this.value = Number(state);\n    this.range = false;\n  }\n}\n\nfunction inBounds({x, y}: PointerEvent, element?: HTMLElement | null) {\n  if (!element) {\n    return false;\n  }\n  const {top, left, bottom, right} = element.getBoundingClientRect();\n  return x >= left && x <= right && y >= top && y <= bottom;\n}\n\nfunction isOverlapping(\n  elA: Element | null | undefined,\n  elB: Element | null | undefined,\n) {\n  if (!(elA && elB)) {\n    return false;\n  }\n  const a = elA.getBoundingClientRect();\n  const b = elB.getBoundingClientRect();\n  return !(\n    a.top > b.bottom ||\n    a.right < b.left ||\n    a.bottom < b.top ||\n    a.left > b.right\n  );\n}\n\ninterface Action {\n  canFlip: boolean;\n  flipped: boolean;\n  target: HTMLInputElement;\n  fixed: HTMLInputElement;\n  values: Map<HTMLInputElement | undefined, number | undefined>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}