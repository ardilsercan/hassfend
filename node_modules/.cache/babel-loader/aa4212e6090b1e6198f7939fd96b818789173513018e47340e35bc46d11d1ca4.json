{"ast":null,"code":"/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages.js\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors.js\";\nconst DEBUG = false;\nexport class Connection {\n  constructor(socket, options) {\n    this._handleMessage = event => {\n      let messageGroup = JSON.parse(event.data);\n      if (!Array.isArray(messageGroup)) {\n        messageGroup = [messageGroup];\n      }\n      messageGroup.forEach(message => {\n        if (DEBUG) {\n          console.log(\"Received\", message);\n        }\n        const info = this.commands.get(message.id);\n        switch (message.type) {\n          case \"event\":\n            if (info) {\n              info.callback(message.event);\n            } else {\n              console.warn(`Received event for unknown subscription ${message.id}. Unsubscribing.`);\n              this.sendMessagePromise(messages.unsubscribeEvents(message.id)).catch(err => {\n                if (DEBUG) {\n                  console.warn(` Error unsubsribing from unknown subscription ${message.id}`, err);\n                }\n              });\n            }\n            break;\n          case \"result\":\n            // No info is fine. If just sendMessage is used, we did not store promise for result\n            if (info) {\n              if (message.success) {\n                info.resolve(message.result);\n                // Don't remove subscriptions.\n                if (!(\"subscribe\" in info)) {\n                  this.commands.delete(message.id);\n                }\n              } else {\n                info.reject(message.error);\n                this.commands.delete(message.id);\n              }\n            }\n            break;\n          case \"pong\":\n            if (info) {\n              info.resolve();\n              this.commands.delete(message.id);\n            } else {\n              console.warn(`Received unknown pong response ${message.id}`);\n            }\n            break;\n          default:\n            if (DEBUG) {\n              console.warn(\"Unhandled message\", message);\n            }\n        }\n      });\n    };\n    this._handleClose = async () => {\n      const oldCommands = this.commands;\n      // reset to original state except haVersion\n      this.commandId = 1;\n      this.oldSubscriptions = this.commands;\n      this.commands = new Map();\n      this.socket = undefined;\n      // Reject in-flight sendMessagePromise requests\n      oldCommands.forEach(info => {\n        // We don't cancel subscribeEvents commands in flight\n        // as we will be able to recover them.\n        if (!(\"subscribe\" in info)) {\n          info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n        }\n      });\n      if (this.closeRequested) {\n        return;\n      }\n      this.fireEvent(\"disconnected\");\n      // Disable setupRetry, we control it here with auto-backoff\n      const options = Object.assign(Object.assign({}, this.options), {\n        setupRetry: 0\n      });\n      const reconnect = tries => {\n        setTimeout(async () => {\n          if (this.closeRequested) {\n            return;\n          }\n          if (DEBUG) {\n            console.log(\"Trying to reconnect\");\n          }\n          try {\n            const socket = await options.createSocket(options);\n            this._setSocket(socket);\n          } catch (err) {\n            if (this._queuedMessages) {\n              const queuedMessages = this._queuedMessages;\n              this._queuedMessages = undefined;\n              for (const msg of queuedMessages) {\n                if (msg.reject) {\n                  msg.reject(ERR_CONNECTION_LOST);\n                }\n              }\n            }\n            if (err === ERR_INVALID_AUTH) {\n              this.fireEvent(\"reconnect-error\", err);\n            } else {\n              reconnect(tries + 1);\n            }\n          }\n        }, Math.min(tries, 5) * 1000);\n      };\n      if (this.suspendReconnectPromise) {\n        await this.suspendReconnectPromise;\n        this.suspendReconnectPromise = undefined;\n        // For the first retry after suspend, we will queue up\n        // all messages.\n        this._queuedMessages = [];\n      }\n      reconnect(0);\n    };\n    // connection options\n    //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n    //  - createSocket: create a new Socket connection\n    this.options = options;\n    // id if next command to send\n    this.commandId = 2; // socket may send 1 at the start to enable features\n    // info about active subscriptions and commands in flight\n    this.commands = new Map();\n    // map of event listeners\n    this.eventListeners = new Map();\n    // true if a close is requested by the user\n    this.closeRequested = false;\n    this._setSocket(socket);\n  }\n  get connected() {\n    // Using conn.socket.OPEN instead of WebSocket for better node support\n    return this.socket !== undefined && this.socket.readyState == this.socket.OPEN;\n  }\n  _setSocket(socket) {\n    this.socket = socket;\n    this.haVersion = socket.haVersion;\n    socket.addEventListener(\"message\", this._handleMessage);\n    socket.addEventListener(\"close\", this._handleClose);\n    const oldSubscriptions = this.oldSubscriptions;\n    if (oldSubscriptions) {\n      this.oldSubscriptions = undefined;\n      oldSubscriptions.forEach(info => {\n        if (\"subscribe\" in info && info.subscribe) {\n          info.subscribe().then(unsub => {\n            info.unsubscribe = unsub;\n            // We need to resolve this in case it wasn't resolved yet.\n            // This allows us to subscribe while we're disconnected\n            // and recover properly.\n            info.resolve();\n          });\n        }\n      });\n    }\n    const queuedMessages = this._queuedMessages;\n    if (queuedMessages) {\n      this._queuedMessages = undefined;\n      for (const queuedMsg of queuedMessages) {\n        queuedMsg.resolve();\n      }\n    }\n    this.fireEvent(\"ready\");\n  }\n  addEventListener(eventType, callback) {\n    let listeners = this.eventListeners.get(eventType);\n    if (!listeners) {\n      listeners = [];\n      this.eventListeners.set(eventType, listeners);\n    }\n    listeners.push(callback);\n  }\n  removeEventListener(eventType, callback) {\n    const listeners = this.eventListeners.get(eventType);\n    if (!listeners) {\n      return;\n    }\n    const index = listeners.indexOf(callback);\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n  }\n  fireEvent(eventType, eventData) {\n    (this.eventListeners.get(eventType) || []).forEach(callback => callback(this, eventData));\n  }\n  suspendReconnectUntil(suspendPromise) {\n    this.suspendReconnectPromise = suspendPromise;\n  }\n  suspend() {\n    if (!this.suspendReconnectPromise) {\n      throw new Error(\"Suspend promise not set\");\n    }\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n  /**\n   * Reconnect the websocket connection.\n   * @param force discard old socket instead of gracefully closing it.\n   */\n  reconnect(force = false) {\n    if (!this.socket) {\n      return;\n    }\n    if (!force) {\n      this.socket.close();\n      return;\n    }\n    this.socket.removeEventListener(\"message\", this._handleMessage);\n    this.socket.removeEventListener(\"close\", this._handleClose);\n    this.socket.close();\n    this._handleClose();\n  }\n  close() {\n    this.closeRequested = true;\n    if (this.socket) {\n      this.socket.close();\n    }\n  }\n  /**\n   * Subscribe to a specific or all events.\n   *\n   * @param callback Callback  to be called when a new event fires\n   * @param eventType\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeEvents(callback, eventType) {\n    return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n  }\n  ping() {\n    return this.sendMessagePromise(messages.ping());\n  }\n  sendMessage(message, commandId) {\n    if (!this.connected) {\n      throw ERR_CONNECTION_LOST;\n    }\n    if (DEBUG) {\n      console.log(\"Sending\", message);\n    }\n    if (this._queuedMessages) {\n      if (commandId) {\n        throw new Error(\"Cannot queue with commandId\");\n      }\n      this._queuedMessages.push({\n        resolve: () => this.sendMessage(message)\n      });\n      return;\n    }\n    if (!commandId) {\n      commandId = this._genCmdId();\n    }\n    message.id = commandId;\n    this.socket.send(JSON.stringify(message));\n  }\n  sendMessagePromise(message) {\n    return new Promise((resolve, reject) => {\n      if (this._queuedMessages) {\n        this._queuedMessages.push({\n          reject,\n          resolve: async () => {\n            try {\n              resolve(await this.sendMessagePromise(message));\n            } catch (err) {\n              reject(err);\n            }\n          }\n        });\n        return;\n      }\n      const commandId = this._genCmdId();\n      this.commands.set(commandId, {\n        resolve,\n        reject\n      });\n      this.sendMessage(message, commandId);\n    });\n  }\n  /**\n   * Call a websocket command that starts a subscription on the backend.\n   *\n   * @param message the message to start the subscription\n   * @param callback the callback to be called when a new item arrives\n   * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n   * @returns promise that resolves to an unsubscribe function\n   */\n  async subscribeMessage(callback, subscribeMessage, options) {\n    if (this._queuedMessages) {\n      await new Promise((resolve, reject) => {\n        this._queuedMessages.push({\n          resolve,\n          reject\n        });\n      });\n    }\n    let info;\n    await new Promise((resolve, reject) => {\n      // Command ID that will be used\n      const commandId = this._genCmdId();\n      // We store unsubscribe on info object. That way we can overwrite it in case\n      // we get disconnected and we have to subscribe again.\n      info = {\n        resolve,\n        reject,\n        callback,\n        subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false ? () => this.subscribeMessage(callback, subscribeMessage) : undefined,\n        unsubscribe: async () => {\n          // No need to unsubscribe if we're disconnected\n          if (this.connected) {\n            await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n          }\n          this.commands.delete(commandId);\n        }\n      };\n      this.commands.set(commandId, info);\n      try {\n        this.sendMessage(subscribeMessage, commandId);\n      } catch (err) {\n        // Happens when the websocket is already closing.\n        // Don't have to handle the error, reconnect logic will pick it up.\n      }\n    });\n    return () => info.unsubscribe();\n  }\n  _genCmdId() {\n    return ++this.commandId;\n  }\n}","map":{"version":3,"names":["messages","ERR_INVALID_AUTH","ERR_CONNECTION_LOST","DEBUG","Connection","constructor","socket","options","_handleMessage","event","messageGroup","JSON","parse","data","Array","isArray","forEach","message","console","log","info","commands","get","id","type","callback","warn","sendMessagePromise","unsubscribeEvents","catch","err","success","resolve","result","delete","reject","error","_handleClose","oldCommands","commandId","oldSubscriptions","Map","undefined","closeRequested","fireEvent","Object","assign","setupRetry","reconnect","tries","setTimeout","createSocket","_setSocket","_queuedMessages","queuedMessages","msg","Math","min","suspendReconnectPromise","eventListeners","connected","readyState","OPEN","haVersion","addEventListener","subscribe","then","unsub","unsubscribe","queuedMsg","eventType","listeners","set","push","removeEventListener","index","indexOf","splice","eventData","suspendReconnectUntil","suspendPromise","suspend","Error","close","force","subscribeEvents","subscribeMessage","ping","sendMessage","_genCmdId","send","stringify","Promise","resubscribe"],"sources":["/workspaces/frontend/node_modules/home-assistant-js-websocket/dist/connection.js"],"sourcesContent":["/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages.js\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors.js\";\nconst DEBUG = false;\nexport class Connection {\n    constructor(socket, options) {\n        this._handleMessage = (event) => {\n            let messageGroup = JSON.parse(event.data);\n            if (!Array.isArray(messageGroup)) {\n                messageGroup = [messageGroup];\n            }\n            messageGroup.forEach((message) => {\n                if (DEBUG) {\n                    console.log(\"Received\", message);\n                }\n                const info = this.commands.get(message.id);\n                switch (message.type) {\n                    case \"event\":\n                        if (info) {\n                            info.callback(message.event);\n                        }\n                        else {\n                            console.warn(`Received event for unknown subscription ${message.id}. Unsubscribing.`);\n                            this.sendMessagePromise(messages.unsubscribeEvents(message.id)).catch((err) => {\n                                if (DEBUG) {\n                                    console.warn(` Error unsubsribing from unknown subscription ${message.id}`, err);\n                                }\n                            });\n                        }\n                        break;\n                    case \"result\":\n                        // No info is fine. If just sendMessage is used, we did not store promise for result\n                        if (info) {\n                            if (message.success) {\n                                info.resolve(message.result);\n                                // Don't remove subscriptions.\n                                if (!(\"subscribe\" in info)) {\n                                    this.commands.delete(message.id);\n                                }\n                            }\n                            else {\n                                info.reject(message.error);\n                                this.commands.delete(message.id);\n                            }\n                        }\n                        break;\n                    case \"pong\":\n                        if (info) {\n                            info.resolve();\n                            this.commands.delete(message.id);\n                        }\n                        else {\n                            console.warn(`Received unknown pong response ${message.id}`);\n                        }\n                        break;\n                    default:\n                        if (DEBUG) {\n                            console.warn(\"Unhandled message\", message);\n                        }\n                }\n            });\n        };\n        this._handleClose = async () => {\n            const oldCommands = this.commands;\n            // reset to original state except haVersion\n            this.commandId = 1;\n            this.oldSubscriptions = this.commands;\n            this.commands = new Map();\n            this.socket = undefined;\n            // Reject in-flight sendMessagePromise requests\n            oldCommands.forEach((info) => {\n                // We don't cancel subscribeEvents commands in flight\n                // as we will be able to recover them.\n                if (!(\"subscribe\" in info)) {\n                    info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n                }\n            });\n            if (this.closeRequested) {\n                return;\n            }\n            this.fireEvent(\"disconnected\");\n            // Disable setupRetry, we control it here with auto-backoff\n            const options = Object.assign(Object.assign({}, this.options), { setupRetry: 0 });\n            const reconnect = (tries) => {\n                setTimeout(async () => {\n                    if (this.closeRequested) {\n                        return;\n                    }\n                    if (DEBUG) {\n                        console.log(\"Trying to reconnect\");\n                    }\n                    try {\n                        const socket = await options.createSocket(options);\n                        this._setSocket(socket);\n                    }\n                    catch (err) {\n                        if (this._queuedMessages) {\n                            const queuedMessages = this._queuedMessages;\n                            this._queuedMessages = undefined;\n                            for (const msg of queuedMessages) {\n                                if (msg.reject) {\n                                    msg.reject(ERR_CONNECTION_LOST);\n                                }\n                            }\n                        }\n                        if (err === ERR_INVALID_AUTH) {\n                            this.fireEvent(\"reconnect-error\", err);\n                        }\n                        else {\n                            reconnect(tries + 1);\n                        }\n                    }\n                }, Math.min(tries, 5) * 1000);\n            };\n            if (this.suspendReconnectPromise) {\n                await this.suspendReconnectPromise;\n                this.suspendReconnectPromise = undefined;\n                // For the first retry after suspend, we will queue up\n                // all messages.\n                this._queuedMessages = [];\n            }\n            reconnect(0);\n        };\n        // connection options\n        //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n        //  - createSocket: create a new Socket connection\n        this.options = options;\n        // id if next command to send\n        this.commandId = 2; // socket may send 1 at the start to enable features\n        // info about active subscriptions and commands in flight\n        this.commands = new Map();\n        // map of event listeners\n        this.eventListeners = new Map();\n        // true if a close is requested by the user\n        this.closeRequested = false;\n        this._setSocket(socket);\n    }\n    get connected() {\n        // Using conn.socket.OPEN instead of WebSocket for better node support\n        return (this.socket !== undefined && this.socket.readyState == this.socket.OPEN);\n    }\n    _setSocket(socket) {\n        this.socket = socket;\n        this.haVersion = socket.haVersion;\n        socket.addEventListener(\"message\", this._handleMessage);\n        socket.addEventListener(\"close\", this._handleClose);\n        const oldSubscriptions = this.oldSubscriptions;\n        if (oldSubscriptions) {\n            this.oldSubscriptions = undefined;\n            oldSubscriptions.forEach((info) => {\n                if (\"subscribe\" in info && info.subscribe) {\n                    info.subscribe().then((unsub) => {\n                        info.unsubscribe = unsub;\n                        // We need to resolve this in case it wasn't resolved yet.\n                        // This allows us to subscribe while we're disconnected\n                        // and recover properly.\n                        info.resolve();\n                    });\n                }\n            });\n        }\n        const queuedMessages = this._queuedMessages;\n        if (queuedMessages) {\n            this._queuedMessages = undefined;\n            for (const queuedMsg of queuedMessages) {\n                queuedMsg.resolve();\n            }\n        }\n        this.fireEvent(\"ready\");\n    }\n    addEventListener(eventType, callback) {\n        let listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            listeners = [];\n            this.eventListeners.set(eventType, listeners);\n        }\n        listeners.push(callback);\n    }\n    removeEventListener(eventType, callback) {\n        const listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(callback);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    }\n    fireEvent(eventType, eventData) {\n        (this.eventListeners.get(eventType) || []).forEach((callback) => callback(this, eventData));\n    }\n    suspendReconnectUntil(suspendPromise) {\n        this.suspendReconnectPromise = suspendPromise;\n    }\n    suspend() {\n        if (!this.suspendReconnectPromise) {\n            throw new Error(\"Suspend promise not set\");\n        }\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Reconnect the websocket connection.\n     * @param force discard old socket instead of gracefully closing it.\n     */\n    reconnect(force = false) {\n        if (!this.socket) {\n            return;\n        }\n        if (!force) {\n            this.socket.close();\n            return;\n        }\n        this.socket.removeEventListener(\"message\", this._handleMessage);\n        this.socket.removeEventListener(\"close\", this._handleClose);\n        this.socket.close();\n        this._handleClose();\n    }\n    close() {\n        this.closeRequested = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Subscribe to a specific or all events.\n     *\n     * @param callback Callback  to be called when a new event fires\n     * @param eventType\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeEvents(callback, eventType) {\n        return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n    }\n    ping() {\n        return this.sendMessagePromise(messages.ping());\n    }\n    sendMessage(message, commandId) {\n        if (!this.connected) {\n            throw ERR_CONNECTION_LOST;\n        }\n        if (DEBUG) {\n            console.log(\"Sending\", message);\n        }\n        if (this._queuedMessages) {\n            if (commandId) {\n                throw new Error(\"Cannot queue with commandId\");\n            }\n            this._queuedMessages.push({ resolve: () => this.sendMessage(message) });\n            return;\n        }\n        if (!commandId) {\n            commandId = this._genCmdId();\n        }\n        message.id = commandId;\n        this.socket.send(JSON.stringify(message));\n    }\n    sendMessagePromise(message) {\n        return new Promise((resolve, reject) => {\n            if (this._queuedMessages) {\n                this._queuedMessages.push({\n                    reject,\n                    resolve: async () => {\n                        try {\n                            resolve(await this.sendMessagePromise(message));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    },\n                });\n                return;\n            }\n            const commandId = this._genCmdId();\n            this.commands.set(commandId, { resolve, reject });\n            this.sendMessage(message, commandId);\n        });\n    }\n    /**\n     * Call a websocket command that starts a subscription on the backend.\n     *\n     * @param message the message to start the subscription\n     * @param callback the callback to be called when a new item arrives\n     * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeMessage(callback, subscribeMessage, options) {\n        if (this._queuedMessages) {\n            await new Promise((resolve, reject) => {\n                this._queuedMessages.push({ resolve, reject });\n            });\n        }\n        let info;\n        await new Promise((resolve, reject) => {\n            // Command ID that will be used\n            const commandId = this._genCmdId();\n            // We store unsubscribe on info object. That way we can overwrite it in case\n            // we get disconnected and we have to subscribe again.\n            info = {\n                resolve,\n                reject,\n                callback,\n                subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false\n                    ? () => this.subscribeMessage(callback, subscribeMessage)\n                    : undefined,\n                unsubscribe: async () => {\n                    // No need to unsubscribe if we're disconnected\n                    if (this.connected) {\n                        await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n                    }\n                    this.commands.delete(commandId);\n                },\n            };\n            this.commands.set(commandId, info);\n            try {\n                this.sendMessage(subscribeMessage, commandId);\n            }\n            catch (err) {\n                // Happens when the websocket is already closing.\n                // Don't have to handle the error, reconnect logic will pick it up.\n            }\n        });\n        return () => info.unsubscribe();\n    }\n    _genCmdId() {\n        return ++this.commandId;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}