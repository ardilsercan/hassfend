{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nexport var createStore = function createStore(state) {\n  var listeners = [];\n  function unsubscribe(listener) {\n    var out = [];\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener) {\n        listener = null;\n      } else {\n        out.push(listeners[i]);\n      }\n    }\n    listeners = out;\n  }\n  function setState(update, overwrite) {\n    state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n    var currentListeners = listeners;\n    for (var i = 0; i < currentListeners.length; i++) {\n      currentListeners[i](state);\n    }\n  }\n  /**\n   * An observable state container, returned from {@link createStore}\n   * @name store\n   */\n  return {\n    get state() {\n      return state;\n    },\n    /**\n     * Create a bound copy of the given action function.\n     * The bound returned function invokes action() and persists the result back to the store.\n     * If the return value of `action` is a Promise, the resolved value will be used as state.\n     * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n     * @returns {Function} boundAction()\n     */\n    action: function action(_action) {\n      function apply(result) {\n        setState(result, false);\n      }\n      // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n      return function () {\n        var args = [state];\n        for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n        // @ts-ignore\n        var ret = _action.apply(this, args);\n        if (ret != null) {\n          return ret instanceof Promise ? ret.then(apply) : apply(ret);\n        }\n      };\n    },\n    /**\n     * Apply a partial state object to the current state, invoking registered listeners.\n     * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n     * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n     */\n    setState: setState,\n    clearState: function clearState() {\n      state = undefined;\n    },\n    /**\n     * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n     * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n     * @returns {Function} unsubscribe()\n     */\n    subscribe: function subscribe(listener) {\n      listeners.push(listener);\n      return function () {\n        unsubscribe(listener);\n      };\n    } // /**\n    //  * Remove a previously-registered listener function.\n    //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n    //  * @function\n    //  */\n    // unsubscribe,\n  };\n};","map":{"version":3,"names":["createStore","state","listeners","unsubscribe","listener","out","i","length","push","setState","update","overwrite","Object","assign","currentListeners","action","apply","result","args","arguments","ret","Promise","then","clearState","undefined","subscribe"],"sources":["/workspaces/frontend/node_modules/home-assistant-js-websocket/dist/store.js"],"sourcesContent":["export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n"],"mappings":";;;;AAAA,OAAO,IAAMA,WAAW,GAAG,SAAdA,WAAWA,CAAIC,KAAK,EAAK;EAClC,IAAIC,SAAS,GAAG,EAAE;EAClB,SAASC,WAAWA,CAACC,QAAQ,EAAE;IAC3B,IAAIC,GAAG,GAAG,EAAE;IACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAACK,MAAM,EAAED,CAAC,EAAE,EAAE;MACvC,IAAIJ,SAAS,CAACI,CAAC,CAAC,KAAKF,QAAQ,EAAE;QAC3BA,QAAQ,GAAG,IAAI;MACnB,CAAC,MACI;QACDC,GAAG,CAACG,IAAI,CAACN,SAAS,CAACI,CAAC,CAAC,CAAC;MAC1B;IACJ;IACAJ,SAAS,GAAGG,GAAG;EACnB;EACA,SAASI,QAAQA,CAACC,MAAM,EAAEC,SAAS,EAAE;IACjCV,KAAK,GAAGU,SAAS,GAAGD,MAAM,GAAGE,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEZ,KAAK,CAAC,EAAES,MAAM,CAAC;IAC5E,IAAII,gBAAgB,GAAGZ,SAAS;IAChC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,gBAAgB,CAACP,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9CQ,gBAAgB,CAACR,CAAC,CAAC,CAACL,KAAK,CAAC;IAC9B;EACJ;EACA;AACJ;AACA;AACA;EACI,OAAO;IACH,IAAIA,KAAKA,CAAA,EAAG;MACR,OAAOA,KAAK;IAChB,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQc,MAAM,WAAAA,OAACA,OAAM,EAAE;MACX,SAASC,KAAKA,CAACC,MAAM,EAAE;QACnBR,QAAQ,CAACQ,MAAM,EAAE,KAAK,CAAC;MAC3B;MACA;MACA,OAAO,YAAY;QACf,IAAIC,IAAI,GAAG,CAACjB,KAAK,CAAC;QAClB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGa,SAAS,CAACZ,MAAM,EAAED,CAAC,EAAE,EACrCY,IAAI,CAACV,IAAI,CAACW,SAAS,CAACb,CAAC,CAAC,CAAC;QAC3B;QACA,IAAIc,GAAG,GAAGL,OAAM,CAACC,KAAK,CAAC,IAAI,EAAEE,IAAI,CAAC;QAClC,IAAIE,GAAG,IAAI,IAAI,EAAE;UACb,OAAOA,GAAG,YAAYC,OAAO,GAAGD,GAAG,CAACE,IAAI,CAACN,KAAK,CAAC,GAAGA,KAAK,CAACI,GAAG,CAAC;QAChE;MACJ,CAAC;IACL,CAAC;IACD;AACR;AACA;AACA;AACA;IACQX,QAAQ,EAARA,QAAQ;IACRc,UAAU,WAAAA,WAAA,EAAG;MACTtB,KAAK,GAAGuB,SAAS;IACrB,CAAC;IACD;AACR;AACA;AACA;AACA;IACQC,SAAS,WAAAA,UAACrB,QAAQ,EAAE;MAChBF,SAAS,CAACM,IAAI,CAACJ,QAAQ,CAAC;MACxB,OAAO,YAAM;QACTD,WAAW,CAACC,QAAQ,CAAC;MACzB,CAAC;IACL,CAAC,CACD;IACA;IACA;IACA;IACA;IACA;EACJ,CAAC;AACL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}