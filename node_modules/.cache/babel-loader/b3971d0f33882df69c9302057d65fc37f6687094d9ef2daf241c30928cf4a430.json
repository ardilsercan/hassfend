{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Any new exports need to be added to the export statement in\n// `packages/lit/src/index.all.ts`.\nimport { html as coreHtml, svg as coreSvg } from './lit-html.js';\n/**\n * Prevents JSON injection attacks.\n *\n * The goals of this brand:\n *   1) fast to check\n *   2) code is small on the wire\n *   3) multiple versions of Lit in a single page will all produce mutually\n *      interoperable StaticValues\n *   4) normal JSON.parse (without an unusual reviver) can not produce a\n *      StaticValue\n *\n * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\n * we don't care about the key, so we break ties via (2) and use the empty\n * string.\n */\nvar brand = Symbol.for('');\n/** Safely extracts the string part of a StaticValue. */\nvar unwrapStaticValue = function unwrapStaticValue(value) {\n  if ((value === null || value === void 0 ? void 0 : value.r) !== brand) {\n    return undefined;\n  }\n  return value === null || value === void 0 ? void 0 : value['_$litStatic$'];\n};\n/**\n * Wraps a string so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Note that this function is unsafe to use on untrusted content, as it will be\n * directly parsed into HTML. Do not pass user input to this function\n * without sanitizing it.\n *\n * Static values can be changed, but they will cause a complete re-render\n * since they effectively create a new template.\n */\nexport var unsafeStatic = function unsafeStatic(value) {\n  return _defineProperty(_defineProperty({}, '_$litStatic$', value), \"r\", brand);\n};\nvar textFromStatic = function textFromStatic(value) {\n  if (value['_$litStatic$'] !== undefined) {\n    return value['_$litStatic$'];\n  } else {\n    throw new Error(\"Value passed to 'literal' function must be a 'literal' result: \".concat(value, \". Use 'unsafeStatic' to pass non-literal values, but\\n            take care to ensure page security.\"));\n  }\n};\n/**\n * Tags a string literal so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * The only values that may be used in template expressions are other tagged\n * `literal` results or `unsafeStatic` values (note that untrusted content\n * should never be passed to `unsafeStatic`).\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Static values can be changed, but they will cause a complete re-render since\n * they effectively create a new template.\n */\nexport var literal = function literal(strings) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  return _defineProperty(_defineProperty({}, '_$litStatic$', values.reduce(function (acc, v, idx) {\n    return acc + textFromStatic(v) + strings[idx + 1];\n  }, strings[0])), \"r\", brand);\n};\nvar stringsCache = new Map();\n/**\n * Wraps a lit-html template tag (`html` or `svg`) to add static value support.\n */\nexport var withStatic = function withStatic(coreTag) {\n  return function (strings) {\n    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n    var l = values.length;\n    var staticValue;\n    var dynamicValue;\n    var staticStrings = [];\n    var dynamicValues = [];\n    var i = 0;\n    var hasStatics = false;\n    var s;\n    while (i < l) {\n      s = strings[i];\n      // Collect any unsafeStatic values, and their following template strings\n      // so that we treat a run of template strings and unsafe static values as\n      // a single template string.\n      while (i < l && (dynamicValue = values[i], staticValue = unwrapStaticValue(dynamicValue)) !== undefined) {\n        s += staticValue + strings[++i];\n        hasStatics = true;\n      }\n      // If the last value is static, we don't need to push it.\n      if (i !== l) {\n        dynamicValues.push(dynamicValue);\n      }\n      staticStrings.push(s);\n      i++;\n    }\n    // If the last value isn't static (which would have consumed the last\n    // string), then we need to add the last string.\n    if (i === l) {\n      staticStrings.push(strings[l]);\n    }\n    if (hasStatics) {\n      var key = staticStrings.join('$$lit$$');\n      strings = stringsCache.get(key);\n      if (strings === undefined) {\n        // Beware: in general this pattern is unsafe, and doing so may bypass\n        // lit's security checks and allow an attacker to execute arbitrary\n        // code and inject arbitrary content.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        staticStrings.raw = staticStrings;\n        stringsCache.set(key, strings = staticStrings);\n      }\n      values = dynamicValues;\n    }\n    return coreTag.apply(void 0, [strings].concat(_toConsumableArray(values)));\n  };\n};\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport var html = withStatic(coreHtml);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport var svg = withStatic(coreSvg);","map":{"version":3,"names":["html","coreHtml","svg","coreSvg","brand","Symbol","for","unwrapStaticValue","value","r","undefined","unsafeStatic","_defineProperty","textFromStatic","Error","concat","literal","strings","_len","arguments","length","values","Array","_key","reduce","acc","v","idx","stringsCache","Map","withStatic","coreTag","_len2","_key2","l","staticValue","dynamicValue","staticStrings","dynamicValues","i","hasStatics","s","push","key","join","get","raw","set","apply","_toConsumableArray"],"sources":["../src/static.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Any new exports need to be added to the export statement in\n// `packages/lit/src/index.all.ts`.\n\nimport {html as coreHtml, svg as coreSvg, TemplateResult} from './lit-html.js';\n\nexport interface StaticValue {\n  /** The value to interpolate as-is into the template. */\n  _$litStatic$: string;\n\n  /**\n   * A value that can't be decoded from ordinary JSON, make it harder for\n   * a attacker-controlled data that goes through JSON.parse to produce a valid\n   * StaticValue.\n   */\n  r: typeof brand;\n}\n\n/**\n * Prevents JSON injection attacks.\n *\n * The goals of this brand:\n *   1) fast to check\n *   2) code is small on the wire\n *   3) multiple versions of Lit in a single page will all produce mutually\n *      interoperable StaticValues\n *   4) normal JSON.parse (without an unusual reviver) can not produce a\n *      StaticValue\n *\n * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\n * we don't care about the key, so we break ties via (2) and use the empty\n * string.\n */\nconst brand = Symbol.for('');\n\n/** Safely extracts the string part of a StaticValue. */\nconst unwrapStaticValue = (value: unknown): string | undefined => {\n  if ((value as Partial<StaticValue>)?.r !== brand) {\n    return undefined;\n  }\n  return (value as Partial<StaticValue>)?.['_$litStatic$'];\n};\n\n/**\n * Wraps a string so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Note that this function is unsafe to use on untrusted content, as it will be\n * directly parsed into HTML. Do not pass user input to this function\n * without sanitizing it.\n *\n * Static values can be changed, but they will cause a complete re-render\n * since they effectively create a new template.\n */\nexport const unsafeStatic = (value: string): StaticValue => ({\n  ['_$litStatic$']: value,\n  r: brand,\n});\n\nconst textFromStatic = (value: StaticValue) => {\n  if (value['_$litStatic$'] !== undefined) {\n    return value['_$litStatic$'];\n  } else {\n    throw new Error(\n      `Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`\n    );\n  }\n};\n\n/**\n * Tags a string literal so that it behaves like part of the static template\n * strings instead of a dynamic value.\n *\n * The only values that may be used in template expressions are other tagged\n * `literal` results or `unsafeStatic` values (note that untrusted content\n * should never be passed to `unsafeStatic`).\n *\n * Users must take care to ensure that adding the static string to the template\n * results in well-formed HTML, or else templates may break unexpectedly.\n *\n * Static values can be changed, but they will cause a complete re-render since\n * they effectively create a new template.\n */\nexport const literal = (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): StaticValue => ({\n  ['_$litStatic$']: values.reduce(\n    (acc, v, idx) => acc + textFromStatic(v as StaticValue) + strings[idx + 1],\n    strings[0]\n  ) as string,\n  r: brand,\n});\n\nconst stringsCache = new Map<string, TemplateStringsArray>();\n\n/**\n * Wraps a lit-html template tag (`html` or `svg`) to add static value support.\n */\nexport const withStatic =\n  (coreTag: typeof coreHtml | typeof coreSvg) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult => {\n    const l = values.length;\n    let staticValue: string | undefined;\n    let dynamicValue: unknown;\n    const staticStrings: Array<string> = [];\n    const dynamicValues: Array<unknown> = [];\n    let i = 0;\n    let hasStatics = false;\n    let s: string;\n\n    while (i < l) {\n      s = strings[i];\n      // Collect any unsafeStatic values, and their following template strings\n      // so that we treat a run of template strings and unsafe static values as\n      // a single template string.\n      while (\n        i < l &&\n        ((dynamicValue = values[i]),\n        (staticValue = unwrapStaticValue(dynamicValue))) !== undefined\n      ) {\n        s += staticValue + strings[++i];\n        hasStatics = true;\n      }\n      // If the last value is static, we don't need to push it.\n      if (i !== l) {\n        dynamicValues.push(dynamicValue);\n      }\n      staticStrings.push(s);\n      i++;\n    }\n    // If the last value isn't static (which would have consumed the last\n    // string), then we need to add the last string.\n    if (i === l) {\n      staticStrings.push(strings[l]);\n    }\n\n    if (hasStatics) {\n      const key = staticStrings.join('$$lit$$');\n      strings = stringsCache.get(key)!;\n      if (strings === undefined) {\n        // Beware: in general this pattern is unsafe, and doing so may bypass\n        // lit's security checks and allow an attacker to execute arbitrary\n        // code and inject arbitrary content.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (staticStrings as any).raw = staticStrings;\n        stringsCache.set(\n          key,\n          (strings = staticStrings as unknown as TemplateStringsArray)\n        );\n      }\n      values = dynamicValues;\n    }\n    return coreTag(strings, ...values);\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const html = withStatic(coreHtml);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n *\n * Includes static value support from `lit-html/static.js`.\n */\nexport const svg = withStatic(coreSvg);\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;AAMA;AACA;AAEA,SAAQA,IAAI,IAAIC,QAAQ,EAAEC,GAAG,IAAIC,OAAO,QAAuB,eAAe;AAc9E;;;;;;;;;;;;;;;AAeA,IAAMC,KAAK,GAAGC,MAAM,CAACC,GAAG,CAAC,EAAE,CAAC;AAE5B;AACA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIC,KAAc,EAAwB;EAC/D,IAAI,CAACA,KAA8B,aAA9BA,KAAK,uBAALA,KAAK,CAA2BC,CAAC,MAAKL,KAAK,EAAE;IAChD,OAAOM,SAAS;;EAElB,OAAQF,KAA8B,aAA9BA,KAAK,uBAALA,KAAK,CAA4B,cAAc,CAAC;AAC1D,CAAC;AAED;;;;;;;;;;;;;;AAcA,OAAO,IAAMG,YAAY,GAAG,SAAfA,YAAYA,CAAIH,KAAa;EAAA,OAAAI,eAAA,CAAAA,eAAA,KACvC,cAAc,EAAGJ,KAAK,QACpBJ,KAAK;AAAA,CACR;AAEF,IAAMS,cAAc,GAAG,SAAjBA,cAAcA,CAAIL,KAAkB,EAAI;EAC5C,IAAIA,KAAK,CAAC,cAAc,CAAC,KAAKE,SAAS,EAAE;IACvC,OAAOF,KAAK,CAAC,cAAc,CAAC;GAC7B,MAAM;IACL,MAAM,IAAIM,KAAK,mEAAAC,MAAA,CACqDP,KAAK,yGAC9B,CAC1C;;AAEL,CAAC;AAED;;;;;;;;;;;;;;AAcA,OAAO,IAAMQ,OAAO,GAAG,SAAVA,OAAOA,CAClBC,OAA6B;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAC1BC,MAAiB,OAAAC,KAAA,CAAAJ,IAAA,OAAAA,IAAA,WAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAjBF,MAAiB,CAAAE,IAAA,QAAAJ,SAAA,CAAAI,IAAA;EAAA;EAAA,OAAAX,eAAA,CAAAA,eAAA,KAEnB,cAAc,EAAGS,MAAM,CAACG,MAAM,CAC7B,UAACC,GAAG,EAAEC,CAAC,EAAEC,GAAG;IAAA,OAAKF,GAAG,GAAGZ,cAAc,CAACa,CAAgB,CAAC,GAAGT,OAAO,CAACU,GAAG,GAAG,CAAC,CAAC;EAAA,GAC1EV,OAAO,CAAC,CAAC,CAAC,CACD,QACRb,KAAK;AAAA,CACR;AAEF,IAAMwB,YAAY,GAAG,IAAIC,GAAG,EAAgC;AAE5D;;;AAGA,OAAO,IAAMC,UAAU,GACrB,SADWA,UAAUA,CACpBC,OAAyC;EAAA,OAC1C,UAACd,OAA6B,EAA0C;IAAA,SAAAe,KAAA,GAAAb,SAAA,CAAAC,MAAA,EAArCC,MAAiB,OAAAC,KAAA,CAAAU,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAjBZ,MAAiB,CAAAY,KAAA,QAAAd,SAAA,CAAAc,KAAA;IAAA;IAClD,IAAMC,CAAC,GAAGb,MAAM,CAACD,MAAM;IACvB,IAAIe,WAA+B;IACnC,IAAIC,YAAqB;IACzB,IAAMC,aAAa,GAAkB,EAAE;IACvC,IAAMC,aAAa,GAAmB,EAAE;IACxC,IAAIC,CAAC,GAAG,CAAC;IACT,IAAIC,UAAU,GAAG,KAAK;IACtB,IAAIC,CAAS;IAEb,OAAOF,CAAC,GAAGL,CAAC,EAAE;MACZO,CAAC,GAAGxB,OAAO,CAACsB,CAAC,CAAC;MACd;MACA;MACA;MACA,OACEA,CAAC,GAAGL,CAAC,IACL,CAAEE,YAAY,GAAGf,MAAM,CAACkB,CAAC,CAAC,EACzBJ,WAAW,GAAG5B,iBAAiB,CAAC6B,YAAY,CAAE,MAAM1B,SAAS,EAC9D;QACA+B,CAAC,IAAIN,WAAW,GAAGlB,OAAO,CAAC,EAAEsB,CAAC,CAAC;QAC/BC,UAAU,GAAG,IAAI;;MAEnB;MACA,IAAID,CAAC,KAAKL,CAAC,EAAE;QACXI,aAAa,CAACI,IAAI,CAACN,YAAY,CAAC;;MAElCC,aAAa,CAACK,IAAI,CAACD,CAAC,CAAC;MACrBF,CAAC,EAAE;;IAEL;IACA;IACA,IAAIA,CAAC,KAAKL,CAAC,EAAE;MACXG,aAAa,CAACK,IAAI,CAACzB,OAAO,CAACiB,CAAC,CAAC,CAAC;;IAGhC,IAAIM,UAAU,EAAE;MACd,IAAMG,GAAG,GAAGN,aAAa,CAACO,IAAI,CAAC,SAAS,CAAC;MACzC3B,OAAO,GAAGW,YAAY,CAACiB,GAAG,CAACF,GAAG,CAAE;MAChC,IAAI1B,OAAO,KAAKP,SAAS,EAAE;QACzB;QACA;QACA;QACA;QACC2B,aAAqB,CAACS,GAAG,GAAGT,aAAa;QAC1CT,YAAY,CAACmB,GAAG,CACdJ,GAAG,EACF1B,OAAO,GAAGoB,aAAiD,CAC7D;;MAEHhB,MAAM,GAAGiB,aAAa;;IAExB,OAAOP,OAAO,CAAAiB,KAAA,UAAC/B,OAAO,EAAAF,MAAA,CAAAkC,kBAAA,CAAK5B,MAAM,GAAC;EACpC,CAAC;AAAA;AAEH;;;;;;AAMA,OAAO,IAAMrB,IAAI,GAAG8B,UAAU,CAAC7B,QAAQ,CAAC;AAExC;;;;;;AAMA,OAAO,IAAMC,GAAG,GAAG4B,UAAU,CAAC3B,OAAO,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}