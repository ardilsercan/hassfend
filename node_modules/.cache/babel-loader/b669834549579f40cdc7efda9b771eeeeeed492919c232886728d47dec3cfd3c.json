{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { extractSearchParam } from \"../../../../common/url/search-params\";\nimport \"../../../../components/ha-assist-pipeline-picker\";\nimport \"../../../../components/ha-button\";\nimport \"../../../../components/ha-checkbox\";\nimport \"../../../../components/ha-formfield\";\nimport \"../../../../components/ha-textfield\";\nimport { runDebugAssistPipeline } from \"../../../../data/assist_pipeline\";\nimport { showAlertDialog, showPromptDialog } from \"../../../../dialogs/generic/show-dialog-box\";\nimport \"../../../../layouts/hass-subpage\";\nimport { haStyle } from \"../../../../resources/styles\";\nimport { AudioRecorder } from \"../../../../util/audio-recorder\";\nimport { fileDownload } from \"../../../../util/file_download\";\nimport \"./assist-render-pipeline-run\";\nexport let AssistPipelineRunDebug = _decorate([customElement(\"assist-pipeline-run-debug\")], function (_initialize, _LitElement) {\n  class AssistPipelineRunDebug extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: AssistPipelineRunDebug,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"narrow\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_pipelineRuns\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [query(\"#continue-conversation\")],\n      key: \"_continueConversationCheckbox\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [query(\"#continue-conversation-text\")],\n      key: \"_continueConversationTextField\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_audioBuffer\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_finished\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_pipelineId\",\n      value() {\n        return extractSearchParam(\"pipeline\") || undefined;\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return html`\n      <hass-subpage\n        .narrow=${this.narrow}\n        .hass=${this.hass}\n        header=\"Assist Pipeline\"\n      >\n        ${this._pipelineRuns.length > 0 ? html`\n              <ha-button\n                slot=\"toolbar-icon\"\n                @click=${this._clearConversation}\n                .disabled=${!this._finished}\n              >\n                Clear\n              </ha-button>\n              <ha-button\n                slot=\"toolbar-icon\"\n                @click=${this._downloadConversation}\n              >\n                Download\n              </ha-button>\n            ` : \"\"}\n\n        <div class=\"content\">\n          <div class=\"start-row\">\n            ${this._pipelineRuns.length === 0 ? html`\n                  <ha-assist-pipeline-picker\n                    .hass=${this.hass}\n                    .value=${this._pipelineId}\n                    @value-changed=${this._pipelinePicked}\n                  ></ha-assist-pipeline-picker>\n                  <div class=\"start-buttons\">\n                    <ha-button raised @click=${this._runTextPipeline}>\n                      Run Text Pipeline\n                    </ha-button>\n                    <ha-button\n                      raised\n                      @click=${this._runAudioPipeline}\n                      .disabled=${!window.isSecureContext ||\n        // @ts-ignore-next-line\n        !(window.AudioContext || window.webkitAudioContext)}\n                    >\n                      Run Audio Pipeline\n                    </ha-button>\n                    <ha-button\n                      raised\n                      @click=${this._runAudioWakeWordPipeline}\n                      .disabled=${!window.isSecureContext ||\n        // @ts-ignore-next-line\n        !(window.AudioContext || window.webkitAudioContext)}\n                    >\n                      Run Audio Pipeline with Wake Word detection\n                    </ha-button>\n                  </div>\n                ` : this._pipelineRuns[0].init_options.start_stage === \"intent\" ? html`\n                    <ha-textfield\n                      id=\"continue-conversation-text\"\n                      label=\"Response\"\n                      .disabled=${!this._finished}\n                      @keydown=${this._handleContinueKeyDown}\n                    ></ha-textfield>\n                    <ha-button\n                      @click=${this._runTextPipeline}\n                      .disabled=${!this._finished}\n                    >\n                      Send\n                    </ha-button>\n                  ` : this._finished ? this._pipelineRuns[0].init_options.start_stage === \"wake_word\" ? html`\n                        <ha-button @click=${this._runAudioWakeWordPipeline}>\n                          Continue listening for wake word\n                        </ha-button>\n                      ` : html`<ha-button @click=${this._runAudioPipeline}>\n                        Continue talking\n                      </ha-button>` : html`\n                      <ha-formfield label=\"Continue conversation\">\n                        <ha-checkbox\n                          id=\"continue-conversation\"\n                          checked\n                        ></ha-checkbox>\n                      </ha-formfield>\n                    `}\n          </div>\n\n          ${this._pipelineRuns.map(run => run === null ? \"\" : html`\n                  <assist-render-pipeline-run\n                    .hass=${this.hass}\n                    .pipelineRun=${run}\n                  ></assist-render-pipeline-run>\n                `)}\n        </div>\n      </hass-subpage>\n    `;\n      }\n    }, {\n      kind: \"get\",\n      key: \"conversationId\",\n      value: function conversationId() {\n        var _this$_pipelineRuns$;\n        return this._pipelineRuns.length === 0 ? null : ((_this$_pipelineRuns$ = this._pipelineRuns[0].intent) === null || _this$_pipelineRuns$ === void 0 || (_this$_pipelineRuns$ = _this$_pipelineRuns$.intent_output) === null || _this$_pipelineRuns$ === void 0 ? void 0 : _this$_pipelineRuns$.conversation_id) || null;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_runTextPipeline\",\n      value: async function _runTextPipeline() {\n        const textfield = this._continueConversationTextField;\n        let text;\n        if (textfield) {\n          text = textfield.value;\n        } else {\n          text = await showPromptDialog(this, {\n            title: \"Input text\",\n            confirmText: \"Run\"\n          });\n        }\n        if (!text) {\n          return;\n        }\n        await this._doRunPipeline(run => {\n          if ([\"done\", \"error\"].includes(run.stage)) {\n            this._finished = true;\n            if (textfield) {\n              textfield.value = \"\";\n            }\n          }\n        }, {\n          start_stage: \"intent\",\n          end_stage: \"intent\",\n          input: {\n            text\n          }\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_runAudioWakeWordPipeline\",\n      value: async function _runAudioWakeWordPipeline() {\n        const audioRecorder = new AudioRecorder(data => {\n          if (this._audioBuffer) {\n            this._audioBuffer.push(data);\n          } else {\n            this._sendAudioChunk(data);\n          }\n        });\n        this._audioBuffer = [];\n        await audioRecorder.start();\n        let run;\n        let stopRecording = () => {\n          var _run;\n          stopRecording = undefined;\n          audioRecorder.close();\n          // We're currently STTing, so finish audio\n          if (((_run = run) === null || _run === void 0 ? void 0 : _run.stage) === \"stt\" && run.stt.done === false) {\n            if (this._audioBuffer) {\n              for (const chunk of this._audioBuffer) {\n                this._sendAudioChunk(chunk);\n              }\n            }\n            // Send empty message to indicate we're done streaming.\n            this._sendAudioChunk(new Int16Array());\n          }\n          this._audioBuffer = undefined;\n        };\n        await this._doRunPipeline(updatedRun => {\n          run = updatedRun;\n\n          // When we start wake work stage, the WS has a binary handler\n          if (updatedRun.stage === \"wake_word\" && this._audioBuffer) {\n            // Send the buffer over the WS to the Wake Word / STT engine.\n            for (const buffer of this._audioBuffer) {\n              this._sendAudioChunk(buffer);\n            }\n            this._audioBuffer = undefined;\n          }\n\n          // Stop recording if the server is done with STT stage\n          if (![\"ready\", \"wake_word\", \"stt\"].includes(updatedRun.stage) && stopRecording) {\n            stopRecording();\n          }\n\n          // Play audio when we're done.\n          if (updatedRun.stage === \"done\" && !updatedRun.error) {\n            const url = updatedRun.tts.tts_output.url;\n            const audio = new Audio(url);\n            audio.addEventListener(\"ended\", () => {\n              if (this.isConnected && this._continueConversationCheckbox.checked) {\n                this._runAudioWakeWordPipeline();\n              } else {\n                this._finished = true;\n              }\n            });\n            audio.play();\n          } else if (updatedRun.stage === \"done\" && updatedRun.error || updatedRun.stage === \"error\") {\n            this._finished = true;\n          }\n        }, {\n          start_stage: \"wake_word\",\n          end_stage: \"tts\",\n          input: {\n            sample_rate: audioRecorder.sampleRate\n          }\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_runAudioPipeline\",\n      value: async function _runAudioPipeline() {\n        const audioRecorder = new AudioRecorder(data => {\n          if (this._audioBuffer) {\n            this._audioBuffer.push(data);\n          } else {\n            this._sendAudioChunk(data);\n          }\n        });\n        this._audioBuffer = [];\n        await audioRecorder.start();\n        let run;\n        let stopRecording = () => {\n          var _run2;\n          stopRecording = undefined;\n          audioRecorder.close();\n          // We're currently STTing, so finish audio\n          if (((_run2 = run) === null || _run2 === void 0 ? void 0 : _run2.stage) === \"stt\" && run.stt.done === false) {\n            if (this._audioBuffer) {\n              for (const chunk of this._audioBuffer) {\n                this._sendAudioChunk(chunk);\n              }\n            }\n            // Send empty message to indicate we're done streaming.\n            this._sendAudioChunk(new Int16Array());\n          }\n          this._audioBuffer = undefined;\n        };\n        await this._doRunPipeline(updatedRun => {\n          run = updatedRun;\n\n          // When we start STT stage, the WS has a binary handler\n          if (updatedRun.stage === \"stt\" && this._audioBuffer) {\n            // Send the buffer over the WS to the STT engine.\n            for (const buffer of this._audioBuffer) {\n              this._sendAudioChunk(buffer);\n            }\n            this._audioBuffer = undefined;\n          }\n\n          // Stop recording if the server is done with STT stage\n          if (![\"ready\", \"stt\"].includes(updatedRun.stage) && stopRecording) {\n            stopRecording();\n          }\n\n          // Play audio when we're done.\n          if (updatedRun.stage === \"done\") {\n            const url = updatedRun.tts.tts_output.url;\n            const audio = new Audio(url);\n            audio.addEventListener(\"ended\", () => {\n              if (this.isConnected && this._continueConversationCheckbox.checked) {\n                this._runAudioPipeline();\n              } else {\n                this._finished = true;\n              }\n            });\n            audio.play();\n          } else if (updatedRun.stage === \"error\") {\n            this._finished = true;\n          }\n        }, {\n          start_stage: \"stt\",\n          end_stage: \"tts\",\n          input: {\n            sample_rate: audioRecorder.sampleRate\n          }\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_doRunPipeline\",\n      value: async function _doRunPipeline(callback, options) {\n        this._finished = false;\n        let added = false;\n        try {\n          await runDebugAssistPipeline(this.hass, updatedRun => {\n            if (added) {\n              this._pipelineRuns = [updatedRun, ...this._pipelineRuns.slice(1)];\n            } else {\n              this._pipelineRuns = [updatedRun, ...this._pipelineRuns];\n              added = true;\n            }\n            callback(updatedRun);\n          }, {\n            ...options,\n            pipeline: this._pipelineId,\n            conversation_id: this.conversationId\n          });\n        } catch (err) {\n          await showAlertDialog(this, {\n            title: \"Error starting pipeline\",\n            text: err.message || err\n          });\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_sendAudioChunk\",\n      value: function _sendAudioChunk(chunk) {\n        this.hass.connection.socket.binaryType = \"arraybuffer\";\n        // Turn into 8 bit so we can prefix our handler ID.\n        const data = new Uint8Array(1 + chunk.length * 2);\n        data[0] = this._pipelineRuns[0].run.runner_data.stt_binary_handler_id;\n        data.set(new Uint8Array(chunk.buffer), 1);\n        this.hass.connection.socket.send(data);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_handleContinueKeyDown\",\n      value: function _handleContinueKeyDown(ev) {\n        if (ev.key === \"Enter\") {\n          this._runTextPipeline();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_clearConversation\",\n      value: function _clearConversation() {\n        this._pipelineRuns = [];\n      }\n    }, {\n      kind: \"method\",\n      key: \"_downloadConversation\",\n      value: function _downloadConversation() {\n        fileDownload(`data:text/plain;charset=utf-8,${encodeURIComponent(JSON.stringify(this._pipelineRuns, null, 2))}`, `conversation.json`);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_pipelinePicked\",\n      value: function _pipelinePicked(ev) {\n        this._pipelineId = ev.detail.value;\n      }\n    }, {\n      kind: \"field\",\n      static: true,\n      key: \"styles\",\n      value() {\n        return [haStyle, css`\n      .content {\n        padding: 24px 0 32px;\n        max-width: 600px;\n        margin: 0 auto;\n        direction: ltr;\n      }\n      .start-buttons {\n        display: flex;\n        flex-wrap: wrap;\n        gap: 8px;\n        align-items: center;\n        justify-content: center;\n      }\n      .start-row {\n        display: flex;\n        justify-content: space-around;\n        align-items: center;\n        flex-wrap: wrap;\n        margin: 0 16px 16px;\n        direction: var(--direction);\n      }\n      ha-assist-pipeline-picker {\n        display: block;\n        width: 100%;\n        margin-bottom: 16px;\n      }\n      .start-row ha-textfield {\n        flex: 1;\n      }\n      assist-render-pipeline-run {\n        padding-top: 16px;\n      }\n      assist-render-pipeline-run + assist-render-pipeline-run {\n        border-top: 1px solid var(--divider-color);\n      }\n    `];\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","customElement","property","query","state","extractSearchParam","runDebugAssistPipeline","showAlertDialog","showPromptDialog","haStyle","AudioRecorder","fileDownload","AssistPipelineRunDebug","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","undefined","render","narrow","hass","_pipelineRuns","length","_clearConversation","_finished","_downloadConversation","_pipelineId","_pipelinePicked","_runTextPipeline","_runAudioPipeline","window","isSecureContext","AudioContext","webkitAudioContext","_runAudioWakeWordPipeline","init_options","start_stage","_handleContinueKeyDown","map","run","conversationId","_this$_pipelineRuns$","intent","intent_output","conversation_id","textfield","_continueConversationTextField","text","title","confirmText","_doRunPipeline","includes","stage","end_stage","input","audioRecorder","data","_audioBuffer","push","_sendAudioChunk","start","stopRecording","_run","close","stt","done","chunk","Int16Array","updatedRun","buffer","error","url","tts","tts_output","audio","Audio","addEventListener","isConnected","_continueConversationCheckbox","checked","play","sample_rate","sampleRate","_run2","callback","options","added","slice","pipeline","err","message","connection","socket","binaryType","Uint8Array","runner_data","stt_binary_handler_id","set","send","ev","encodeURIComponent","JSON","stringify","detail","static"],"sources":["/workspaces/frontend/src/panels/config/voice-assistants/debug/assist-pipeline-run-debug.ts"],"sourcesContent":["import { css, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { extractSearchParam } from \"../../../../common/url/search-params\";\nimport \"../../../../components/ha-assist-pipeline-picker\";\nimport \"../../../../components/ha-button\";\nimport \"../../../../components/ha-checkbox\";\nimport type { HaCheckbox } from \"../../../../components/ha-checkbox\";\nimport \"../../../../components/ha-formfield\";\nimport \"../../../../components/ha-textfield\";\nimport type { HaTextField } from \"../../../../components/ha-textfield\";\nimport {\n  PipelineRun,\n  PipelineRunOptions,\n  runDebugAssistPipeline,\n} from \"../../../../data/assist_pipeline\";\nimport {\n  showAlertDialog,\n  showPromptDialog,\n} from \"../../../../dialogs/generic/show-dialog-box\";\nimport \"../../../../layouts/hass-subpage\";\nimport { haStyle } from \"../../../../resources/styles\";\nimport type { HomeAssistant } from \"../../../../types\";\nimport { AudioRecorder } from \"../../../../util/audio-recorder\";\nimport { fileDownload } from \"../../../../util/file_download\";\nimport \"./assist-render-pipeline-run\";\n\n@customElement(\"assist-pipeline-run-debug\")\nexport class AssistPipelineRunDebug extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @state() private _pipelineRuns: PipelineRun[] = [];\n\n  @query(\"#continue-conversation\")\n  private _continueConversationCheckbox!: HaCheckbox;\n\n  @query(\"#continue-conversation-text\")\n  private _continueConversationTextField?: HaTextField;\n\n  private _audioBuffer?: Int16Array[];\n\n  @state() private _finished = false;\n\n  @state() private _pipelineId?: string =\n    extractSearchParam(\"pipeline\") || undefined;\n\n  protected render(): TemplateResult {\n    return html`\n      <hass-subpage\n        .narrow=${this.narrow}\n        .hass=${this.hass}\n        header=\"Assist Pipeline\"\n      >\n        ${this._pipelineRuns.length > 0\n          ? html`\n              <ha-button\n                slot=\"toolbar-icon\"\n                @click=${this._clearConversation}\n                .disabled=${!this._finished}\n              >\n                Clear\n              </ha-button>\n              <ha-button\n                slot=\"toolbar-icon\"\n                @click=${this._downloadConversation}\n              >\n                Download\n              </ha-button>\n            `\n          : \"\"}\n\n        <div class=\"content\">\n          <div class=\"start-row\">\n            ${this._pipelineRuns.length === 0\n              ? html`\n                  <ha-assist-pipeline-picker\n                    .hass=${this.hass}\n                    .value=${this._pipelineId}\n                    @value-changed=${this._pipelinePicked}\n                  ></ha-assist-pipeline-picker>\n                  <div class=\"start-buttons\">\n                    <ha-button raised @click=${this._runTextPipeline}>\n                      Run Text Pipeline\n                    </ha-button>\n                    <ha-button\n                      raised\n                      @click=${this._runAudioPipeline}\n                      .disabled=${!window.isSecureContext ||\n                      // @ts-ignore-next-line\n                      !(window.AudioContext || window.webkitAudioContext)}\n                    >\n                      Run Audio Pipeline\n                    </ha-button>\n                    <ha-button\n                      raised\n                      @click=${this._runAudioWakeWordPipeline}\n                      .disabled=${!window.isSecureContext ||\n                      // @ts-ignore-next-line\n                      !(window.AudioContext || window.webkitAudioContext)}\n                    >\n                      Run Audio Pipeline with Wake Word detection\n                    </ha-button>\n                  </div>\n                `\n              : this._pipelineRuns[0].init_options!.start_stage === \"intent\"\n                ? html`\n                    <ha-textfield\n                      id=\"continue-conversation-text\"\n                      label=\"Response\"\n                      .disabled=${!this._finished}\n                      @keydown=${this._handleContinueKeyDown}\n                    ></ha-textfield>\n                    <ha-button\n                      @click=${this._runTextPipeline}\n                      .disabled=${!this._finished}\n                    >\n                      Send\n                    </ha-button>\n                  `\n                : this._finished\n                  ? this._pipelineRuns[0].init_options!.start_stage ===\n                    \"wake_word\"\n                    ? html`\n                        <ha-button @click=${this._runAudioWakeWordPipeline}>\n                          Continue listening for wake word\n                        </ha-button>\n                      `\n                    : html`<ha-button @click=${this._runAudioPipeline}>\n                        Continue talking\n                      </ha-button>`\n                  : html`\n                      <ha-formfield label=\"Continue conversation\">\n                        <ha-checkbox\n                          id=\"continue-conversation\"\n                          checked\n                        ></ha-checkbox>\n                      </ha-formfield>\n                    `}\n          </div>\n\n          ${this._pipelineRuns.map((run) =>\n            run === null\n              ? \"\"\n              : html`\n                  <assist-render-pipeline-run\n                    .hass=${this.hass}\n                    .pipelineRun=${run}\n                  ></assist-render-pipeline-run>\n                `\n          )}\n        </div>\n      </hass-subpage>\n    `;\n  }\n\n  private get conversationId(): string | null {\n    return this._pipelineRuns.length === 0\n      ? null\n      : this._pipelineRuns[0].intent?.intent_output?.conversation_id || null;\n  }\n\n  private async _runTextPipeline() {\n    const textfield = this._continueConversationTextField;\n\n    let text: string | null;\n\n    if (textfield) {\n      text = textfield.value;\n    } else {\n      text = await showPromptDialog(this, {\n        title: \"Input text\",\n        confirmText: \"Run\",\n      });\n    }\n\n    if (!text) {\n      return;\n    }\n\n    await this._doRunPipeline(\n      (run) => {\n        if ([\"done\", \"error\"].includes(run.stage)) {\n          this._finished = true;\n          if (textfield) {\n            textfield.value = \"\";\n          }\n        }\n      },\n      {\n        start_stage: \"intent\",\n        end_stage: \"intent\",\n        input: { text },\n      }\n    );\n  }\n\n  private async _runAudioWakeWordPipeline() {\n    const audioRecorder = new AudioRecorder((data) => {\n      if (this._audioBuffer) {\n        this._audioBuffer.push(data);\n      } else {\n        this._sendAudioChunk(data);\n      }\n    });\n\n    this._audioBuffer = [];\n    await audioRecorder.start();\n\n    let run: PipelineRun | undefined;\n\n    let stopRecording: (() => void) | undefined = () => {\n      stopRecording = undefined;\n      audioRecorder.close();\n      // We're currently STTing, so finish audio\n      if (run?.stage === \"stt\" && run.stt!.done === false) {\n        if (this._audioBuffer) {\n          for (const chunk of this._audioBuffer) {\n            this._sendAudioChunk(chunk);\n          }\n        }\n        // Send empty message to indicate we're done streaming.\n        this._sendAudioChunk(new Int16Array());\n      }\n      this._audioBuffer = undefined;\n    };\n\n    await this._doRunPipeline(\n      (updatedRun) => {\n        run = updatedRun;\n\n        // When we start wake work stage, the WS has a binary handler\n        if (updatedRun.stage === \"wake_word\" && this._audioBuffer) {\n          // Send the buffer over the WS to the Wake Word / STT engine.\n          for (const buffer of this._audioBuffer) {\n            this._sendAudioChunk(buffer);\n          }\n          this._audioBuffer = undefined;\n        }\n\n        // Stop recording if the server is done with STT stage\n        if (\n          ![\"ready\", \"wake_word\", \"stt\"].includes(updatedRun.stage) &&\n          stopRecording\n        ) {\n          stopRecording();\n        }\n\n        // Play audio when we're done.\n        if (updatedRun.stage === \"done\" && !updatedRun.error) {\n          const url = updatedRun.tts!.tts_output!.url;\n          const audio = new Audio(url);\n          audio.addEventListener(\"ended\", () => {\n            if (\n              this.isConnected &&\n              this._continueConversationCheckbox.checked\n            ) {\n              this._runAudioWakeWordPipeline();\n            } else {\n              this._finished = true;\n            }\n          });\n          audio.play();\n        } else if (\n          (updatedRun.stage === \"done\" && updatedRun.error) ||\n          updatedRun.stage === \"error\"\n        ) {\n          this._finished = true;\n        }\n      },\n      {\n        start_stage: \"wake_word\",\n        end_stage: \"tts\",\n        input: {\n          sample_rate: audioRecorder.sampleRate!,\n        },\n      }\n    );\n  }\n\n  private async _runAudioPipeline() {\n    const audioRecorder = new AudioRecorder((data) => {\n      if (this._audioBuffer) {\n        this._audioBuffer.push(data);\n      } else {\n        this._sendAudioChunk(data);\n      }\n    });\n\n    this._audioBuffer = [];\n    await audioRecorder.start();\n\n    let run: PipelineRun | undefined;\n\n    let stopRecording: (() => void) | undefined = () => {\n      stopRecording = undefined;\n      audioRecorder.close();\n      // We're currently STTing, so finish audio\n      if (run?.stage === \"stt\" && run.stt!.done === false) {\n        if (this._audioBuffer) {\n          for (const chunk of this._audioBuffer) {\n            this._sendAudioChunk(chunk);\n          }\n        }\n        // Send empty message to indicate we're done streaming.\n        this._sendAudioChunk(new Int16Array());\n      }\n      this._audioBuffer = undefined;\n    };\n\n    await this._doRunPipeline(\n      (updatedRun) => {\n        run = updatedRun;\n\n        // When we start STT stage, the WS has a binary handler\n        if (updatedRun.stage === \"stt\" && this._audioBuffer) {\n          // Send the buffer over the WS to the STT engine.\n          for (const buffer of this._audioBuffer) {\n            this._sendAudioChunk(buffer);\n          }\n          this._audioBuffer = undefined;\n        }\n\n        // Stop recording if the server is done with STT stage\n        if (![\"ready\", \"stt\"].includes(updatedRun.stage) && stopRecording) {\n          stopRecording();\n        }\n\n        // Play audio when we're done.\n        if (updatedRun.stage === \"done\") {\n          const url = updatedRun.tts!.tts_output!.url;\n          const audio = new Audio(url);\n          audio.addEventListener(\"ended\", () => {\n            if (\n              this.isConnected &&\n              this._continueConversationCheckbox.checked\n            ) {\n              this._runAudioPipeline();\n            } else {\n              this._finished = true;\n            }\n          });\n          audio.play();\n        } else if (updatedRun.stage === \"error\") {\n          this._finished = true;\n        }\n      },\n      {\n        start_stage: \"stt\",\n        end_stage: \"tts\",\n        input: {\n          sample_rate: audioRecorder.sampleRate!,\n        },\n      }\n    );\n  }\n\n  private async _doRunPipeline(\n    callback: (event: PipelineRun) => void,\n    options: PipelineRunOptions\n  ) {\n    this._finished = false;\n    let added = false;\n    try {\n      await runDebugAssistPipeline(\n        this.hass,\n        (updatedRun) => {\n          if (added) {\n            this._pipelineRuns = [updatedRun, ...this._pipelineRuns.slice(1)];\n          } else {\n            this._pipelineRuns = [updatedRun, ...this._pipelineRuns];\n            added = true;\n          }\n          callback(updatedRun);\n        },\n        {\n          ...options,\n          pipeline: this._pipelineId,\n          conversation_id: this.conversationId,\n        }\n      );\n    } catch (err: any) {\n      await showAlertDialog(this, {\n        title: \"Error starting pipeline\",\n        text: err.message || err,\n      });\n    }\n  }\n\n  private _sendAudioChunk(chunk: Int16Array) {\n    this.hass.connection.socket!.binaryType = \"arraybuffer\";\n    // Turn into 8 bit so we can prefix our handler ID.\n    const data = new Uint8Array(1 + chunk.length * 2);\n    data[0] = this._pipelineRuns[0].run.runner_data.stt_binary_handler_id!;\n    data.set(new Uint8Array(chunk.buffer), 1);\n\n    this.hass.connection.socket!.send(data);\n  }\n\n  private _handleContinueKeyDown(ev) {\n    if (ev.key === \"Enter\") {\n      this._runTextPipeline();\n    }\n  }\n\n  private _clearConversation() {\n    this._pipelineRuns = [];\n  }\n\n  private _downloadConversation() {\n    fileDownload(\n      `data:text/plain;charset=utf-8,${encodeURIComponent(\n        JSON.stringify(this._pipelineRuns, null, 2)\n      )}`,\n      `conversation.json`\n    );\n  }\n\n  private _pipelinePicked(ev) {\n    this._pipelineId = ev.detail.value;\n  }\n\n  static styles = [\n    haStyle,\n    css`\n      .content {\n        padding: 24px 0 32px;\n        max-width: 600px;\n        margin: 0 auto;\n        direction: ltr;\n      }\n      .start-buttons {\n        display: flex;\n        flex-wrap: wrap;\n        gap: 8px;\n        align-items: center;\n        justify-content: center;\n      }\n      .start-row {\n        display: flex;\n        justify-content: space-around;\n        align-items: center;\n        flex-wrap: wrap;\n        margin: 0 16px 16px;\n        direction: var(--direction);\n      }\n      ha-assist-pipeline-picker {\n        display: block;\n        width: 100%;\n        margin-bottom: 16px;\n      }\n      .start-row ha-textfield {\n        flex: 1;\n      }\n      assist-render-pipeline-run {\n        padding-top: 16px;\n      }\n      assist-render-pipeline-run + assist-render-pipeline-run {\n        border-top: 1px solid var(--divider-color);\n      }\n    `,\n  ];\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"assist-pipeline-run-debug\": AssistPipelineRunDebug;\n  }\n}\n"],"mappings":";AAAA,SAASA,GAAG,EAAEC,IAAI,EAAEC,UAAU,QAAwB,KAAK;AAC3D,SAASC,aAAa,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,KAAK,QAAQ,gBAAgB;AACtE,SAASC,kBAAkB,QAAQ,sCAAsC;AACzE,OAAO,kDAAkD;AACzD,OAAO,kCAAkC;AACzC,OAAO,oCAAoC;AAE3C,OAAO,qCAAqC;AAC5C,OAAO,qCAAqC;AAE5C,SAGEC,sBAAsB,QACjB,kCAAkC;AACzC,SACEC,eAAe,EACfC,gBAAgB,QACX,6CAA6C;AACpD,OAAO,kCAAkC;AACzC,SAASC,OAAO,QAAQ,8BAA8B;AAEtD,SAASC,aAAa,QAAQ,iCAAiC;AAC/D,SAASC,YAAY,QAAQ,gCAAgC;AAC7D,OAAO,8BAA8B;AAErC,WACaC,sBAAsB,GAAAC,SAAA,EADlCZ,aAAa,CAAC,2BAA2B,CAAC,aAAAa,WAAA,EAAAC,WAAA;EAA3C,MACaH,sBAAsB,SAAAG,WAAA,CAAoB;IAAAC,YAAA,GAAAC,IAAA;MAAA,SAAAA,IAAA;MAAAH,WAAA;IAAA;EAmbvD;EAAC;IAAAI,CAAA,EAnbYN,sBAAsB;IAAAO,CAAA;MAAAC,IAAA;MAAAC,UAAA,GAChCnB,QAAQ,CAAC;QAAEoB,SAAS,EAAE;MAAM,CAAC,CAAC;MAAAC,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAE9BnB,QAAQ,CAAC;QAAEuB,IAAI,EAAEC;MAAQ,CAAC,CAAC;MAAAH,GAAA;MAAAC,MAAA;QAAA,OAAiB,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEjDjB,KAAK,CAAC,CAAC;MAAAmB,GAAA;MAAAC,MAAA;QAAA,OAAwC,EAAE;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEjDlB,KAAK,CAAC,wBAAwB,CAAC;MAAAoB,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAG/BlB,KAAK,CAAC,6BAA6B,CAAC;MAAAoB,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAG,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAKpCjB,KAAK,CAAC,CAAC;MAAAmB,GAAA;MAAAC,MAAA;QAAA,OAAqB,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEjCjB,KAAK,CAAC,CAAC;MAAAmB,GAAA;MAAAC,MAAA;QAAA,OACNnB,kBAAkB,CAAC,UAAU,CAAC,IAAIsB,SAAS;MAAA;IAAA;MAAAP,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAE7C,SAAAI,OAAA,EAAmC;QACjC,OAAO7B,IAAK;AAChB;AACA,kBAAkB,IAAI,CAAC8B,MAAO;AAC9B,gBAAgB,IAAI,CAACC,IAAK;AAC1B;AACA;AACA,UAAU,IAAI,CAACC,aAAa,CAACC,MAAM,GAAG,CAAC,GAC3BjC,IAAK;AACjB;AACA;AACA,yBAAyB,IAAI,CAACkC,kBAAmB;AACjD,4BAA4B,CAAC,IAAI,CAACC,SAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,CAACC,qBAAsB;AACpD;AACA;AACA;AACA,aAAa,GACD,EAAG;AACf;AACA;AACA;AACA,cAAc,IAAI,CAACJ,aAAa,CAACC,MAAM,KAAK,CAAC,GAC7BjC,IAAK;AACrB;AACA,4BAA4B,IAAI,CAAC+B,IAAK;AACtC,6BAA6B,IAAI,CAACM,WAAY;AAC9C,qCAAqC,IAAI,CAACC,eAAgB;AAC1D;AACA;AACA,+CAA+C,IAAI,CAACC,gBAAiB;AACrE;AACA;AACA;AACA;AACA,+BAA+B,IAAI,CAACC,iBAAkB;AACtD,kCAAkC,CAACC,MAAM,CAACC,eAAe;QACnC;QACA,EAAED,MAAM,CAACE,YAAY,IAAIF,MAAM,CAACG,kBAAkB,CAAE;AAC1E;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,CAACC,yBAA0B;AAC9D,kCAAkC,CAACJ,MAAM,CAACC,eAAe;QACnC;QACA,EAAED,MAAM,CAACE,YAAY,IAAIF,MAAM,CAACG,kBAAkB,CAAE;AAC1E;AACA;AACA;AACA;AACA,iBAAiB,GACD,IAAI,CAACZ,aAAa,CAAC,CAAC,CAAC,CAACc,YAAY,CAAEC,WAAW,KAAK,QAAQ,GAC1D/C,IAAK;AACvB;AACA;AACA;AACA,kCAAkC,CAAC,IAAI,CAACmC,SAAU;AAClD,iCAAiC,IAAI,CAACa,sBAAuB;AAC7D;AACA;AACA,+BAA+B,IAAI,CAACT,gBAAiB;AACrD,kCAAkC,CAAC,IAAI,CAACJ,SAAU;AAClD;AACA;AACA;AACA,mBAAmB,GACD,IAAI,CAACA,SAAS,GACZ,IAAI,CAACH,aAAa,CAAC,CAAC,CAAC,CAACc,YAAY,CAAEC,WAAW,KAC/C,WAAW,GACT/C,IAAK;AAC3B,4CAA4C,IAAI,CAAC6C,yBAA0B;AAC3E;AACA;AACA,uBAAuB,GACD7C,IAAK,qBAAoB,IAAI,CAACwC,iBAAkB;AACtE;AACA,mCAAmC,GACfxC,IAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAsB;AACtB;AACA;AACA,YAAY,IAAI,CAACgC,aAAa,CAACiB,GAAG,CAAEC,GAAG,IAC3BA,GAAG,KAAK,IAAI,GACR,EAAE,GACFlD,IAAK;AACrB;AACA,4BAA4B,IAAI,CAAC+B,IAAK;AACtC,mCAAmCmB,GAAI;AACvC;AACA,iBACU,CAAE;AACZ;AACA;AACA,KAAK;MACH;IAAC;MAAA7B,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAA0B,eAAA,EAA4C;QAAA,IAAAC,oBAAA;QAC1C,OAAO,IAAI,CAACpB,aAAa,CAACC,MAAM,KAAK,CAAC,GAClC,IAAI,GACJ,EAAAmB,oBAAA,OAAI,CAACpB,aAAa,CAAC,CAAC,CAAC,CAACqB,MAAM,cAAAD,oBAAA,gBAAAA,oBAAA,GAA5BA,oBAAA,CAA8BE,aAAa,cAAAF,oBAAA,uBAA3CA,oBAAA,CAA6CG,eAAe,KAAI,IAAI;MAC1E;IAAC;MAAAlC,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAc,iBAAA,EAAiC;QAC/B,MAAMiB,SAAS,GAAG,IAAI,CAACC,8BAA8B;QAErD,IAAIC,IAAmB;QAEvB,IAAIF,SAAS,EAAE;UACbE,IAAI,GAAGF,SAAS,CAAC/B,KAAK;QACxB,CAAC,MAAM;UACLiC,IAAI,GAAG,MAAMjD,gBAAgB,CAAC,IAAI,EAAE;YAClCkD,KAAK,EAAE,YAAY;YACnBC,WAAW,EAAE;UACf,CAAC,CAAC;QACJ;QAEA,IAAI,CAACF,IAAI,EAAE;UACT;QACF;QAEA,MAAM,IAAI,CAACG,cAAc,CACtBX,GAAG,IAAK;UACP,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACY,QAAQ,CAACZ,GAAG,CAACa,KAAK,CAAC,EAAE;YACzC,IAAI,CAAC5B,SAAS,GAAG,IAAI;YACrB,IAAIqB,SAAS,EAAE;cACbA,SAAS,CAAC/B,KAAK,GAAG,EAAE;YACtB;UACF;QACF,CAAC,EACD;UACEsB,WAAW,EAAE,QAAQ;UACrBiB,SAAS,EAAE,QAAQ;UACnBC,KAAK,EAAE;YAAEP;UAAK;QAChB,CACF,CAAC;MACH;IAAC;MAAArC,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAoB,0BAAA,EAA0C;QACxC,MAAMqB,aAAa,GAAG,IAAIvD,aAAa,CAAEwD,IAAI,IAAK;UAChD,IAAI,IAAI,CAACC,YAAY,EAAE;YACrB,IAAI,CAACA,YAAY,CAACC,IAAI,CAACF,IAAI,CAAC;UAC9B,CAAC,MAAM;YACL,IAAI,CAACG,eAAe,CAACH,IAAI,CAAC;UAC5B;QACF,CAAC,CAAC;QAEF,IAAI,CAACC,YAAY,GAAG,EAAE;QACtB,MAAMF,aAAa,CAACK,KAAK,CAAC,CAAC;QAE3B,IAAIrB,GAA4B;QAEhC,IAAIsB,aAAuC,GAAGA,CAAA,KAAM;UAAA,IAAAC,IAAA;UAClDD,aAAa,GAAG5C,SAAS;UACzBsC,aAAa,CAACQ,KAAK,CAAC,CAAC;UACrB;UACA,IAAI,EAAAD,IAAA,GAAAvB,GAAG,cAAAuB,IAAA,uBAAHA,IAAA,CAAKV,KAAK,MAAK,KAAK,IAAIb,GAAG,CAACyB,GAAG,CAAEC,IAAI,KAAK,KAAK,EAAE;YACnD,IAAI,IAAI,CAACR,YAAY,EAAE;cACrB,KAAK,MAAMS,KAAK,IAAI,IAAI,CAACT,YAAY,EAAE;gBACrC,IAAI,CAACE,eAAe,CAACO,KAAK,CAAC;cAC7B;YACF;YACA;YACA,IAAI,CAACP,eAAe,CAAC,IAAIQ,UAAU,CAAC,CAAC,CAAC;UACxC;UACA,IAAI,CAACV,YAAY,GAAGxC,SAAS;QAC/B,CAAC;QAED,MAAM,IAAI,CAACiC,cAAc,CACtBkB,UAAU,IAAK;UACd7B,GAAG,GAAG6B,UAAU;;UAEhB;UACA,IAAIA,UAAU,CAAChB,KAAK,KAAK,WAAW,IAAI,IAAI,CAACK,YAAY,EAAE;YACzD;YACA,KAAK,MAAMY,MAAM,IAAI,IAAI,CAACZ,YAAY,EAAE;cACtC,IAAI,CAACE,eAAe,CAACU,MAAM,CAAC;YAC9B;YACA,IAAI,CAACZ,YAAY,GAAGxC,SAAS;UAC/B;;UAEA;UACA,IACE,CAAC,CAAC,OAAO,EAAE,WAAW,EAAE,KAAK,CAAC,CAACkC,QAAQ,CAACiB,UAAU,CAAChB,KAAK,CAAC,IACzDS,aAAa,EACb;YACAA,aAAa,CAAC,CAAC;UACjB;;UAEA;UACA,IAAIO,UAAU,CAAChB,KAAK,KAAK,MAAM,IAAI,CAACgB,UAAU,CAACE,KAAK,EAAE;YACpD,MAAMC,GAAG,GAAGH,UAAU,CAACI,GAAG,CAAEC,UAAU,CAAEF,GAAG;YAC3C,MAAMG,KAAK,GAAG,IAAIC,KAAK,CAACJ,GAAG,CAAC;YAC5BG,KAAK,CAACE,gBAAgB,CAAC,OAAO,EAAE,MAAM;cACpC,IACE,IAAI,CAACC,WAAW,IAChB,IAAI,CAACC,6BAA6B,CAACC,OAAO,EAC1C;gBACA,IAAI,CAAC7C,yBAAyB,CAAC,CAAC;cAClC,CAAC,MAAM;gBACL,IAAI,CAACV,SAAS,GAAG,IAAI;cACvB;YACF,CAAC,CAAC;YACFkD,KAAK,CAACM,IAAI,CAAC,CAAC;UACd,CAAC,MAAM,IACJZ,UAAU,CAAChB,KAAK,KAAK,MAAM,IAAIgB,UAAU,CAACE,KAAK,IAChDF,UAAU,CAAChB,KAAK,KAAK,OAAO,EAC5B;YACA,IAAI,CAAC5B,SAAS,GAAG,IAAI;UACvB;QACF,CAAC,EACD;UACEY,WAAW,EAAE,WAAW;UACxBiB,SAAS,EAAE,KAAK;UAChBC,KAAK,EAAE;YACL2B,WAAW,EAAE1B,aAAa,CAAC2B;UAC7B;QACF,CACF,CAAC;MACH;IAAC;MAAAxE,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAe,kBAAA,EAAkC;QAChC,MAAM0B,aAAa,GAAG,IAAIvD,aAAa,CAAEwD,IAAI,IAAK;UAChD,IAAI,IAAI,CAACC,YAAY,EAAE;YACrB,IAAI,CAACA,YAAY,CAACC,IAAI,CAACF,IAAI,CAAC;UAC9B,CAAC,MAAM;YACL,IAAI,CAACG,eAAe,CAACH,IAAI,CAAC;UAC5B;QACF,CAAC,CAAC;QAEF,IAAI,CAACC,YAAY,GAAG,EAAE;QACtB,MAAMF,aAAa,CAACK,KAAK,CAAC,CAAC;QAE3B,IAAIrB,GAA4B;QAEhC,IAAIsB,aAAuC,GAAGA,CAAA,KAAM;UAAA,IAAAsB,KAAA;UAClDtB,aAAa,GAAG5C,SAAS;UACzBsC,aAAa,CAACQ,KAAK,CAAC,CAAC;UACrB;UACA,IAAI,EAAAoB,KAAA,GAAA5C,GAAG,cAAA4C,KAAA,uBAAHA,KAAA,CAAK/B,KAAK,MAAK,KAAK,IAAIb,GAAG,CAACyB,GAAG,CAAEC,IAAI,KAAK,KAAK,EAAE;YACnD,IAAI,IAAI,CAACR,YAAY,EAAE;cACrB,KAAK,MAAMS,KAAK,IAAI,IAAI,CAACT,YAAY,EAAE;gBACrC,IAAI,CAACE,eAAe,CAACO,KAAK,CAAC;cAC7B;YACF;YACA;YACA,IAAI,CAACP,eAAe,CAAC,IAAIQ,UAAU,CAAC,CAAC,CAAC;UACxC;UACA,IAAI,CAACV,YAAY,GAAGxC,SAAS;QAC/B,CAAC;QAED,MAAM,IAAI,CAACiC,cAAc,CACtBkB,UAAU,IAAK;UACd7B,GAAG,GAAG6B,UAAU;;UAEhB;UACA,IAAIA,UAAU,CAAChB,KAAK,KAAK,KAAK,IAAI,IAAI,CAACK,YAAY,EAAE;YACnD;YACA,KAAK,MAAMY,MAAM,IAAI,IAAI,CAACZ,YAAY,EAAE;cACtC,IAAI,CAACE,eAAe,CAACU,MAAM,CAAC;YAC9B;YACA,IAAI,CAACZ,YAAY,GAAGxC,SAAS;UAC/B;;UAEA;UACA,IAAI,CAAC,CAAC,OAAO,EAAE,KAAK,CAAC,CAACkC,QAAQ,CAACiB,UAAU,CAAChB,KAAK,CAAC,IAAIS,aAAa,EAAE;YACjEA,aAAa,CAAC,CAAC;UACjB;;UAEA;UACA,IAAIO,UAAU,CAAChB,KAAK,KAAK,MAAM,EAAE;YAC/B,MAAMmB,GAAG,GAAGH,UAAU,CAACI,GAAG,CAAEC,UAAU,CAAEF,GAAG;YAC3C,MAAMG,KAAK,GAAG,IAAIC,KAAK,CAACJ,GAAG,CAAC;YAC5BG,KAAK,CAACE,gBAAgB,CAAC,OAAO,EAAE,MAAM;cACpC,IACE,IAAI,CAACC,WAAW,IAChB,IAAI,CAACC,6BAA6B,CAACC,OAAO,EAC1C;gBACA,IAAI,CAAClD,iBAAiB,CAAC,CAAC;cAC1B,CAAC,MAAM;gBACL,IAAI,CAACL,SAAS,GAAG,IAAI;cACvB;YACF,CAAC,CAAC;YACFkD,KAAK,CAACM,IAAI,CAAC,CAAC;UACd,CAAC,MAAM,IAAIZ,UAAU,CAAChB,KAAK,KAAK,OAAO,EAAE;YACvC,IAAI,CAAC5B,SAAS,GAAG,IAAI;UACvB;QACF,CAAC,EACD;UACEY,WAAW,EAAE,KAAK;UAClBiB,SAAS,EAAE,KAAK;UAChBC,KAAK,EAAE;YACL2B,WAAW,EAAE1B,aAAa,CAAC2B;UAC7B;QACF,CACF,CAAC;MACH;IAAC;MAAAxE,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAoC,eACEkC,QAAsC,EACtCC,OAA2B,EAC3B;QACA,IAAI,CAAC7D,SAAS,GAAG,KAAK;QACtB,IAAI8D,KAAK,GAAG,KAAK;QACjB,IAAI;UACF,MAAM1F,sBAAsB,CAC1B,IAAI,CAACwB,IAAI,EACRgD,UAAU,IAAK;YACd,IAAIkB,KAAK,EAAE;cACT,IAAI,CAACjE,aAAa,GAAG,CAAC+C,UAAU,EAAE,GAAG,IAAI,CAAC/C,aAAa,CAACkE,KAAK,CAAC,CAAC,CAAC,CAAC;YACnE,CAAC,MAAM;cACL,IAAI,CAAClE,aAAa,GAAG,CAAC+C,UAAU,EAAE,GAAG,IAAI,CAAC/C,aAAa,CAAC;cACxDiE,KAAK,GAAG,IAAI;YACd;YACAF,QAAQ,CAAChB,UAAU,CAAC;UACtB,CAAC,EACD;YACE,GAAGiB,OAAO;YACVG,QAAQ,EAAE,IAAI,CAAC9D,WAAW;YAC1BkB,eAAe,EAAE,IAAI,CAACJ;UACxB,CACF,CAAC;QACH,CAAC,CAAC,OAAOiD,GAAQ,EAAE;UACjB,MAAM5F,eAAe,CAAC,IAAI,EAAE;YAC1BmD,KAAK,EAAE,yBAAyB;YAChCD,IAAI,EAAE0C,GAAG,CAACC,OAAO,IAAID;UACvB,CAAC,CAAC;QACJ;MACF;IAAC;MAAA/E,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAA6C,gBAAwBO,KAAiB,EAAE;QACzC,IAAI,CAAC9C,IAAI,CAACuE,UAAU,CAACC,MAAM,CAAEC,UAAU,GAAG,aAAa;QACvD;QACA,MAAMrC,IAAI,GAAG,IAAIsC,UAAU,CAAC,CAAC,GAAG5B,KAAK,CAAC5C,MAAM,GAAG,CAAC,CAAC;QACjDkC,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAACnC,aAAa,CAAC,CAAC,CAAC,CAACkB,GAAG,CAACwD,WAAW,CAACC,qBAAsB;QACtExC,IAAI,CAACyC,GAAG,CAAC,IAAIH,UAAU,CAAC5B,KAAK,CAACG,MAAM,CAAC,EAAE,CAAC,CAAC;QAEzC,IAAI,CAACjD,IAAI,CAACuE,UAAU,CAACC,MAAM,CAAEM,IAAI,CAAC1C,IAAI,CAAC;MACzC;IAAC;MAAA9C,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAuB,uBAA+B8D,EAAE,EAAE;QACjC,IAAIA,EAAE,CAACtF,GAAG,KAAK,OAAO,EAAE;UACtB,IAAI,CAACe,gBAAgB,CAAC,CAAC;QACzB;MACF;IAAC;MAAAlB,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAS,mBAAA,EAA6B;QAC3B,IAAI,CAACF,aAAa,GAAG,EAAE;MACzB;IAAC;MAAAX,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAW,sBAAA,EAAgC;QAC9BxB,YAAY,CACT,iCAAgCmG,kBAAkB,CACjDC,IAAI,CAACC,SAAS,CAAC,IAAI,CAACjF,aAAa,EAAE,IAAI,EAAE,CAAC,CAC5C,CAAE,EAAC,EACF,mBACH,CAAC;MACH;IAAC;MAAAX,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAa,gBAAwBwE,EAAE,EAAE;QAC1B,IAAI,CAACzE,WAAW,GAAGyE,EAAE,CAACI,MAAM,CAACzF,KAAK;MACpC;IAAC;MAAAJ,IAAA;MAAA8F,MAAA;MAAA3F,GAAA;MAAAC,MAAA;QAAA,OAEe,CACdf,OAAO,EACPX,GAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,CACF;MAAA;IAAA;EAAA;AAAA,GAlbyCE,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}