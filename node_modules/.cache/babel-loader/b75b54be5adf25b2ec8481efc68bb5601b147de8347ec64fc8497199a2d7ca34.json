{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\nvar IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS ([0-9]+)/);\nvar IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nvar DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nexport var ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    var virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    var _this = this;\n    var idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n      idx = this._iterateItems(function (pidx, vidx) {\n        physicalOffset += _this._getPhysicalSizeIncrement(pidx);\n        if (physicalOffset > _this._scrollPosition) {\n          return vidx;\n        }\n      }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    var _this2 = this;\n    var idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      var physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems(function (pidx, vidx) {\n        if (physicalOffset < _this2._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += _this2._getPhysicalSizeIncrement(pidx);\n      });\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler: function _scrollHandler() {\n    var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    var delta = scrollTop - this._scrollPosition;\n    var isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      var idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      var reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables: function _getReusables(fromTop) {\n    var ith, offsetContent, physicalItemHeight;\n    var idxs = [];\n    var protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    var virtualStart = this._virtualStart;\n    var virtualEnd = this._virtualEnd;\n    var physicalCount = this._physicalCount;\n    var top = this._physicalTop + this._scrollOffset;\n    var bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    var scrollTop = this._scrollPosition;\n    var scrollBottom = this._scrollBottom;\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return {\n      indexes: idxs,\n      physicalTop: top - this._scrollOffset\n    };\n  },\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update: function _update(itemSet, movingUp) {\n    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        var idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n  _isClientFull: function _isClientFull() {\n    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;\n  },\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded: function _increasePoolIfNeeded(count) {\n    var nextPhysicalCount = this._clamp(this._physicalCount + count, DEFAULT_PHYSICAL_COUNT, this._virtualCount - this._virtualStart);\n    var delta = nextPhysicalCount - this._physicalCount;\n    var nextIncrease = Math.round(this._physicalCount * 0.5);\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      var ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (var i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)), idlePeriod);\n    }\n  },\n  /**\n   * Renders the a new list.\n   */\n  _render: function _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      var reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged: function _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (!this._physicalItems) {\n        this._physicalItems = [];\n      }\n      if (!this._physicalSizes) {\n        this._physicalSizes = [];\n      }\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems: function _iterateItems(fn, itemSet) {\n    var pidx, vidx, rtn, i;\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx: function _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems: function _positionItems() {\n    var _this3 = this;\n    this._adjustScrollPosition();\n    var y = this._physicalTop;\n    this._iterateItems(function (pidx) {\n      _this3.translate3d(0, \"\".concat(y, \"px\"), 0, _this3._physicalItems[pidx]);\n      y += _this3._physicalSizes[pidx];\n    });\n  },\n  _getPhysicalSizeIncrement: function _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition: function _adjustScrollPosition() {\n    var deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      var scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition: function _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize: function _updateScrollerSize(forceUpdate) {\n    var estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n    this._estScrollHeight = estScrollHeight;\n\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (forceUpdate || this._scrollHeight === 0 || this._scrollPosition >= estScrollHeight - this._physicalSize || Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight) {\n      this.$.items.style.height = \"\".concat(estScrollHeight, \"px\");\n      this._scrollHeight = estScrollHeight;\n    }\n  },\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex: function scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n    var currentTopItem = this._physicalStart;\n    var currentVirtualItem = this._virtualStart;\n    var targetOffsetTop = 0;\n    var hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage: function _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler: function _resizeHandler() {\n    var _this4 = this;\n    this._debounce('_render', function () {\n      // Clear cached visible index.\n      _this4._firstVisibleIndexVal = null;\n      _this4._lastVisibleIndexVal = null;\n      if (_this4._isVisible) {\n        _this4.updateViewportBoundaries();\n        // Reinstall the scroll event listener.\n        _this4.toggleScrollListener(true);\n        _this4._resetAverage();\n        _this4._render();\n      } else {\n        // Uninstall the scroll event listener.\n        _this4.toggleScrollListener(false);\n      }\n    }, animationFrame);\n  },\n  _isIndexRendered: function _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n  _getPhysicalIndex: function _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n  _clamp: function _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n  _debounce: function _debounce(name, cb, asyncModule) {\n    if (!this._debouncers) {\n      this._debouncers = {};\n    }\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  }\n};","map":{"version":3,"names":["animationFrame","idlePeriod","microTask","Debouncer","enqueueDebouncer","flush","IOS","navigator","userAgent","match","IOS_TOUCH_SCROLLING","DEFAULT_PHYSICAL_COUNT","ironList","_ratio","_scrollerPaddingTop","_scrollPosition","_physicalSize","_physicalAverage","_physicalAverageCount","_physicalTop","_virtualCount","_estScrollHeight","_scrollHeight","_viewportHeight","_viewportWidth","_physicalItems","_physicalSizes","_firstVisibleIndexVal","_lastVisibleIndexVal","_maxPages","_templateCost","_physicalBottom","_scrollBottom","_virtualEnd","_virtualStart","_physicalCount","_hiddenContentSize","_maxScrollTop","_scrollOffset","_maxVirtualStart","virtualCount","Math","max","_virtualStartVal","val","_clamp","_physicalStart","_physicalStartVal","_physicalEnd","_physicalCountVal","_optPhysicalSize","Infinity","_isVisible","Boolean","offsetWidth","offsetHeight","firstVisibleIndex","_this","idx","physicalOffset","_iterateItems","pidx","vidx","_getPhysicalSizeIncrement","lastVisibleIndex","_this2","scrollOffset","_scrollHandler","scrollTop","min","_scrollTop","delta","isScrollingDown","abs","idxAdjustment","round","floor","_update","reusables","_getReusables","physicalTop","indexes","length","_debounce","_increasePoolIfNeeded","bind","fromTop","ith","offsetContent","physicalItemHeight","idxs","protectedOffsetContent","virtualStart","virtualEnd","physicalCount","top","bottom","scrollBottom","push","itemSet","movingUp","_assignModels","_updateMetrics","pop","_positionItems","_updateScrollerSize","_isClientFull","count","nextPhysicalCount","nextIncrease","ts","window","performance","now","apply","_createPool","i","_isIndexRendered","_focusedVirtualIndex","_getPhysicalIndex","_render","isAttached","updateViewportBoundaries","_itemsChanged","change","path","items","_physicalIndexForKey","_resetScrollPosition","fn","rtn","arguments","_computeVidx","call","_this3","_adjustScrollPosition","y","translate3d","concat","deltaHeight","pos","scrollTarget","forceUpdate","estScrollHeight","$","style","height","scrollToIndex","currentTopItem","currentVirtualItem","targetOffsetTop","hiddenContentSize","_resetAverage","_resizeHandler","_this4","toggleScrollListener","v","name","cb","asyncModule","_debouncers","debounce"],"sources":["/workspaces/frontend/node_modules/@vaadin/component-base/src/iron-list-core.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { animationFrame, idlePeriod, microTask } from './async.js';\nimport { Debouncer, enqueueDebouncer, flush } from './debounce.js';\n\nconst IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\\d+)/u);\nconst IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;\nconst DEFAULT_PHYSICAL_COUNT = 3;\n\n/**\n * DO NOT EDIT THIS FILE!\n *\n * This file includes the iron-list scrolling engine copied from\n * https://github.com/PolymerElements/iron-list/blob/master/iron-list.js\n *\n * If something in the scrolling engine needs to be changed\n * for the virtualizer's purposes, override a function\n * in virtualizer-iron-list-adapter.js instead of changing it here.\n * If a function on this file is no longer needed, the code can be safely deleted.\n *\n * This will allow us to keep the iron-list code here as close to\n * the original as possible.\n */\nexport const ironList = {\n  /**\n   * The ratio of hidden tiles that should remain in the scroll direction.\n   * Recommended value ~0.5, so it will distribute tiles evenly in both\n   * directions.\n   */\n  _ratio: 0.5,\n\n  /**\n   * The padding-top value for the list.\n   */\n  _scrollerPaddingTop: 0,\n\n  /**\n   * This value is a cached value of `scrollTop` from the last `scroll` event.\n   */\n  _scrollPosition: 0,\n\n  /**\n   * The sum of the heights of all the tiles in the DOM.\n   */\n  _physicalSize: 0,\n\n  /**\n   * The average `offsetHeight` of the tiles observed till now.\n   */\n  _physicalAverage: 0,\n\n  /**\n   * The number of tiles which `offsetHeight` > 0 observed until now.\n   */\n  _physicalAverageCount: 0,\n\n  /**\n   * The Y position of the item rendered in the `_physicalStart`\n   * tile relative to the scrolling list.\n   */\n  _physicalTop: 0,\n\n  /**\n   * The number of items in the list.\n   */\n  _virtualCount: 0,\n\n  /**\n   * The estimated scroll height based on `_physicalAverage`\n   */\n  _estScrollHeight: 0,\n\n  /**\n   * The scroll height of the dom node\n   */\n  _scrollHeight: 0,\n\n  /**\n   * The height of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportHeight: 0,\n\n  /**\n   * The width of the list. This is referred as the viewport in the context of\n   * list.\n   */\n  _viewportWidth: 0,\n\n  /**\n   * An array of DOM nodes that are currently in the tree\n   * @type {?Array<!HTMLElement>}\n   */\n  _physicalItems: null,\n\n  /**\n   * An array of heights for each item in `_physicalItems`\n   * @type {?Array<number>}\n   */\n  _physicalSizes: null,\n\n  /**\n   * A cached value for the first visible index.\n   * See `firstVisibleIndex`\n   * @type {?number}\n   */\n  _firstVisibleIndexVal: null,\n\n  /**\n   * A cached value for the last visible index.\n   * See `lastVisibleIndex`\n   * @type {?number}\n   */\n  _lastVisibleIndexVal: null,\n\n  /**\n   * The max number of pages to render. One page is equivalent to the height of\n   * the list.\n   */\n  _maxPages: 2,\n\n  /**\n   * The cost of stamping a template in ms.\n   */\n  _templateCost: 0,\n\n  /**\n   * The bottom of the physical content.\n   */\n  get _physicalBottom() {\n    return this._physicalTop + this._physicalSize;\n  },\n\n  /**\n   * The bottom of the scroll.\n   */\n  get _scrollBottom() {\n    return this._scrollPosition + this._viewportHeight;\n  },\n\n  /**\n   * The n-th item rendered in the last physical item.\n   */\n  get _virtualEnd() {\n    return this._virtualStart + this._physicalCount - 1;\n  },\n\n  /**\n   * The height of the physical content that isn't on the screen.\n   */\n  get _hiddenContentSize() {\n    return this._physicalSize - this._viewportHeight;\n  },\n\n  /**\n   * The maximum scroll top value.\n   */\n  get _maxScrollTop() {\n    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;\n  },\n\n  /**\n   * The largest n-th value for an item such that it can be rendered in\n   * `_physicalStart`.\n   */\n  get _maxVirtualStart() {\n    const virtualCount = this._virtualCount;\n    return Math.max(0, virtualCount - this._physicalCount);\n  },\n\n  get _virtualStart() {\n    return this._virtualStartVal || 0;\n  },\n\n  set _virtualStart(val) {\n    val = this._clamp(val, 0, this._maxVirtualStart);\n    this._virtualStartVal = val;\n  },\n\n  get _physicalStart() {\n    return this._physicalStartVal || 0;\n  },\n\n  /**\n   * The k-th tile that is at the top of the scrolling list.\n   */\n  set _physicalStart(val) {\n    val %= this._physicalCount;\n    if (val < 0) {\n      val = this._physicalCount + val;\n    }\n    this._physicalStartVal = val;\n  },\n\n  /**\n   * The k-th tile that is at the bottom of the scrolling list.\n   */\n  get _physicalEnd() {\n    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;\n  },\n\n  get _physicalCount() {\n    return this._physicalCountVal || 0;\n  },\n\n  set _physicalCount(val) {\n    this._physicalCountVal = val;\n  },\n\n  /**\n   * An optimal physical size such that we will have enough physical items\n   * to fill up the viewport and recycle when the user scrolls.\n   *\n   * This default value assumes that we will at least have the equivalent\n   * to a viewport of physical items above and below the user's viewport.\n   */\n  get _optPhysicalSize() {\n    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;\n  },\n\n  /**\n   * True if the current list is visible.\n   */\n  get _isVisible() {\n    return Boolean(this.offsetWidth || this.offsetHeight);\n  },\n\n  /**\n   * Gets the index of the first visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get firstVisibleIndex() {\n    let idx = this._firstVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n\n      idx =\n        this._iterateItems((pidx, vidx) => {\n          physicalOffset += this._getPhysicalSizeIncrement(pidx);\n\n          if (physicalOffset > this._scrollPosition) {\n            return vidx;\n          }\n        }) || 0;\n      this._firstVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  /**\n   * Gets the index of the last visible item in the viewport.\n   *\n   * @type {number}\n   */\n  get lastVisibleIndex() {\n    let idx = this._lastVisibleIndexVal;\n    if (idx == null) {\n      let physicalOffset = this._physicalTop + this._scrollOffset;\n      this._iterateItems((pidx, vidx) => {\n        if (physicalOffset < this._scrollBottom) {\n          idx = vidx;\n        }\n        physicalOffset += this._getPhysicalSizeIncrement(pidx);\n      });\n\n      this._lastVisibleIndexVal = idx;\n    }\n    return idx;\n  },\n\n  get _scrollOffset() {\n    return this._scrollerPaddingTop + this.scrollOffset;\n  },\n\n  /**\n   * Recycles the physical items when needed.\n   */\n  _scrollHandler() {\n    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));\n    let delta = scrollTop - this._scrollPosition;\n    const isScrollingDown = delta >= 0;\n    // Track the current scroll position.\n    this._scrollPosition = scrollTop;\n    // Clear indexes for first and last visible indexes.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n    // Random access.\n    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {\n      delta -= this._scrollOffset;\n      const idxAdjustment = Math.round(delta / this._physicalAverage);\n      this._virtualStart += idxAdjustment;\n      this._physicalStart += idxAdjustment;\n      // Estimate new physical offset based on the virtual start index.\n      // adjusts the physical start position to stay in sync with the clamped\n      // virtual start index. It's critical not to let this value be\n      // more than the scroll position however, since that would result in\n      // the physical items not covering the viewport, and leading to\n      // _increasePoolIfNeeded to run away creating items to try to fill it.\n      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);\n      this._update();\n    } else if (this._physicalCount > 0) {\n      const reusables = this._getReusables(isScrollingDown);\n      if (isScrollingDown) {\n        this._physicalTop = reusables.physicalTop;\n        this._virtualStart += reusables.indexes.length;\n        this._physicalStart += reusables.indexes.length;\n      } else {\n        this._virtualStart -= reusables.indexes.length;\n        this._physicalStart -= reusables.indexes.length;\n      }\n      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, 0), microTask);\n    }\n  },\n\n  /**\n   * Returns an object that contains the indexes of the physical items\n   * that might be reused and the physicalTop.\n   *\n   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.\n   */\n  _getReusables(fromTop) {\n    let ith, offsetContent, physicalItemHeight;\n    const idxs = [];\n    const protectedOffsetContent = this._hiddenContentSize * this._ratio;\n    const virtualStart = this._virtualStart;\n    const virtualEnd = this._virtualEnd;\n    const physicalCount = this._physicalCount;\n    let top = this._physicalTop + this._scrollOffset;\n    const bottom = this._physicalBottom + this._scrollOffset;\n    // This may be called outside of a scrollHandler, so use last cached position\n    const scrollTop = this._scrollPosition;\n    const scrollBottom = this._scrollBottom;\n\n    if (fromTop) {\n      ith = this._physicalStart;\n      offsetContent = scrollTop - top;\n    } else {\n      ith = this._physicalEnd;\n      offsetContent = bottom - scrollBottom;\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      physicalItemHeight = this._getPhysicalSizeIncrement(ith);\n      offsetContent -= physicalItemHeight;\n      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {\n        break;\n      }\n      if (fromTop) {\n        // Check that index is within the valid range.\n        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {\n          break;\n        }\n        idxs.push(ith);\n        top += physicalItemHeight;\n        ith = (ith + 1) % physicalCount;\n      } else {\n        // Check that index is within the valid range.\n        if (virtualStart - idxs.length <= 0) {\n          break;\n        }\n        // Check that the index is not visible.\n        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {\n          break;\n        }\n        idxs.push(ith);\n        top -= physicalItemHeight;\n        ith = ith === 0 ? physicalCount - 1 : ith - 1;\n      }\n    }\n    return { indexes: idxs, physicalTop: top - this._scrollOffset };\n  },\n\n  /**\n   * Update the list of items, starting from the `_virtualStart` item.\n   * @param {!Array<number>=} itemSet\n   * @param {!Array<number>=} movingUp\n   */\n  _update(itemSet, movingUp) {\n    if ((itemSet && itemSet.length === 0) || this._physicalCount === 0) {\n      return;\n    }\n    this._assignModels(itemSet);\n    this._updateMetrics(itemSet);\n    // Adjust offset after measuring.\n    if (movingUp) {\n      while (movingUp.length) {\n        const idx = movingUp.pop();\n        this._physicalTop -= this._getPhysicalSizeIncrement(idx);\n      }\n    }\n    this._positionItems();\n    this._updateScrollerSize();\n  },\n\n  _isClientFull() {\n    return (\n      this._scrollBottom !== 0 &&\n      this._physicalBottom - 1 >= this._scrollBottom &&\n      this._physicalTop <= this._scrollPosition\n    );\n  },\n\n  /**\n   * Increases the pool size.\n   */\n  _increasePoolIfNeeded(count) {\n    const nextPhysicalCount = this._clamp(\n      this._physicalCount + count,\n      DEFAULT_PHYSICAL_COUNT,\n      this._virtualCount - this._virtualStart,\n    );\n    const delta = nextPhysicalCount - this._physicalCount;\n    let nextIncrease = Math.round(this._physicalCount * 0.5);\n\n    if (delta < 0) {\n      return;\n    }\n    if (delta > 0) {\n      const ts = window.performance.now();\n      // Concat arrays in place.\n      [].push.apply(this._physicalItems, this._createPool(delta));\n      // Push 0s into physicalSizes. Can't use Array.fill because IE11 doesn't\n      // support it.\n      for (let i = 0; i < delta; i++) {\n        this._physicalSizes.push(0);\n      }\n      this._physicalCount += delta;\n      // Update the physical start if it needs to preserve the model of the\n      // focused item. In this situation, the focused item is currently rendered\n      // and its model would have changed after increasing the pool if the\n      // physical start remained unchanged.\n      if (\n        this._physicalStart > this._physicalEnd &&\n        this._isIndexRendered(this._focusedVirtualIndex) &&\n        this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd\n      ) {\n        this._physicalStart += delta;\n      }\n      this._update();\n      this._templateCost = (window.performance.now() - ts) / delta;\n      nextIncrease = Math.round(this._physicalCount * 0.5);\n    }\n    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) {\n      // Do nothing.\n    } else if (!this._isClientFull()) {\n      this._debounce('_increasePoolIfNeeded', this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);\n    } else if (this._physicalSize < this._optPhysicalSize) {\n      // Yield and increase the pool during idle time until the physical size is\n      // optimal.\n      this._debounce(\n        '_increasePoolIfNeeded',\n        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),\n        idlePeriod,\n      );\n    }\n  },\n\n  /**\n   * Renders the a new list.\n   */\n  _render() {\n    if (!this.isAttached || !this._isVisible) {\n      return;\n    }\n    if (this._physicalCount !== 0) {\n      const reusables = this._getReusables(true);\n      this._physicalTop = reusables.physicalTop;\n      this._virtualStart += reusables.indexes.length;\n      this._physicalStart += reusables.indexes.length;\n      this._update(reusables.indexes);\n      this._update();\n      this._increasePoolIfNeeded(0);\n    } else if (this._virtualCount > 0) {\n      // Initial render\n      this.updateViewportBoundaries();\n      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);\n    }\n  },\n\n  /**\n   * Called when the items have changed. That is, reassignments\n   * to `items`, splices or updates to a single item.\n   */\n  _itemsChanged(change) {\n    if (change.path === 'items') {\n      this._virtualStart = 0;\n      this._physicalTop = 0;\n      this._virtualCount = this.items ? this.items.length : 0;\n      this._physicalIndexForKey = {};\n      this._firstVisibleIndexVal = null;\n      this._lastVisibleIndexVal = null;\n      if (!this._physicalItems) {\n        this._physicalItems = [];\n      }\n      if (!this._physicalSizes) {\n        this._physicalSizes = [];\n      }\n      this._physicalStart = 0;\n      if (this._scrollTop > this._scrollOffset) {\n        this._resetScrollPosition(0);\n      }\n      this._debounce('_render', this._render, animationFrame);\n    }\n  },\n\n  /**\n   * Executes a provided function per every physical index in `itemSet`\n   * `itemSet` default value is equivalent to the entire set of physical\n   * indexes.\n   *\n   * @param {!function(number, number)} fn\n   * @param {!Array<number>=} itemSet\n   */\n  _iterateItems(fn, itemSet) {\n    let pidx, vidx, rtn, i;\n\n    if (arguments.length === 2 && itemSet) {\n      for (i = 0; i < itemSet.length; i++) {\n        pidx = itemSet[i];\n        vidx = this._computeVidx(pidx);\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    } else {\n      pidx = this._physicalStart;\n      vidx = this._virtualStart;\n      for (; pidx < this._physicalCount; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {\n        if ((rtn = fn.call(this, pidx, vidx)) != null) {\n          return rtn;\n        }\n      }\n    }\n  },\n\n  /**\n   * Returns the virtual index for a given physical index\n   *\n   * @param {number} pidx Physical index\n   * @return {number}\n   */\n  _computeVidx(pidx) {\n    if (pidx >= this._physicalStart) {\n      return this._virtualStart + (pidx - this._physicalStart);\n    }\n    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;\n  },\n\n  /**\n   * Updates the position of the physical items.\n   */\n  _positionItems() {\n    this._adjustScrollPosition();\n\n    let y = this._physicalTop;\n\n    this._iterateItems((pidx) => {\n      this.translate3d(0, `${y}px`, 0, this._physicalItems[pidx]);\n      y += this._physicalSizes[pidx];\n    });\n  },\n\n  _getPhysicalSizeIncrement(pidx) {\n    return this._physicalSizes[pidx];\n  },\n\n  /**\n   * Adjusts the scroll position when it was overestimated.\n   */\n  _adjustScrollPosition() {\n    const deltaHeight =\n      this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);\n    // Note: the delta can be positive or negative.\n    if (deltaHeight !== 0) {\n      this._physicalTop -= deltaHeight;\n      // This may be called outside of a scrollHandler, so use last cached position\n      const scrollTop = this._scrollPosition;\n      // Juking scroll position during interial scrolling on iOS is no bueno\n      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {\n        this._resetScrollPosition(scrollTop - deltaHeight);\n      }\n    }\n  },\n\n  /**\n   * Sets the position of the scroll.\n   */\n  _resetScrollPosition(pos) {\n    if (this.scrollTarget && pos >= 0) {\n      this._scrollTop = pos;\n      this._scrollPosition = this._scrollTop;\n    }\n  },\n\n  /**\n   * Sets the scroll height, that's the height of the content,\n   *\n   * @param {boolean=} forceUpdate If true, updates the height no matter what.\n   */\n  _updateScrollerSize(forceUpdate) {\n    const estScrollHeight =\n      this._physicalBottom +\n      Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;\n\n    this._estScrollHeight = estScrollHeight;\n\n    // Amortize height adjustment, so it won't trigger large repaints too often.\n    if (\n      forceUpdate ||\n      this._scrollHeight === 0 ||\n      this._scrollPosition >= estScrollHeight - this._physicalSize ||\n      Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight\n    ) {\n      this.$.items.style.height = `${estScrollHeight}px`;\n      this._scrollHeight = estScrollHeight;\n    }\n  },\n\n  /**\n   * Scroll to a specific index in the virtual list regardless\n   * of the physical items in the DOM tree.\n   *\n   * @method scrollToIndex\n   * @param {number} idx The index of the item\n   */\n  scrollToIndex(idx) {\n    if (typeof idx !== 'number' || idx < 0 || idx > this.items.length - 1) {\n      return;\n    }\n    flush();\n    // Items should have been rendered prior scrolling to an index.\n    if (this._physicalCount === 0) {\n      return;\n    }\n    idx = this._clamp(idx, 0, this._virtualCount - 1);\n    // Update the virtual start only when needed.\n    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {\n      this._virtualStart = idx - 1;\n    }\n    this._assignModels();\n    this._updateMetrics();\n    // Estimate new physical offset.\n    this._physicalTop = this._virtualStart * this._physicalAverage;\n\n    let currentTopItem = this._physicalStart;\n    let currentVirtualItem = this._virtualStart;\n    let targetOffsetTop = 0;\n    const hiddenContentSize = this._hiddenContentSize;\n    // Scroll to the item as much as we can.\n    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {\n      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);\n      currentTopItem = (currentTopItem + 1) % this._physicalCount;\n      currentVirtualItem += 1;\n    }\n    this._updateScrollerSize(true);\n    this._positionItems();\n    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);\n    this._increasePoolIfNeeded(0);\n    // Clear cached visible index.\n    this._firstVisibleIndexVal = null;\n    this._lastVisibleIndexVal = null;\n  },\n\n  /**\n   * Reset the physical average and the average count.\n   */\n  _resetAverage() {\n    this._physicalAverage = 0;\n    this._physicalAverageCount = 0;\n  },\n\n  /**\n   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`\n   * when the element is resized.\n   */\n  _resizeHandler() {\n    this._debounce(\n      '_render',\n      () => {\n        // Clear cached visible index.\n        this._firstVisibleIndexVal = null;\n        this._lastVisibleIndexVal = null;\n        if (this._isVisible) {\n          this.updateViewportBoundaries();\n          // Reinstall the scroll event listener.\n          this.toggleScrollListener(true);\n          this._resetAverage();\n          this._render();\n        } else {\n          // Uninstall the scroll event listener.\n          this.toggleScrollListener(false);\n        }\n      },\n      animationFrame,\n    );\n  },\n\n  _isIndexRendered(idx) {\n    return idx >= this._virtualStart && idx <= this._virtualEnd;\n  },\n\n  _getPhysicalIndex(vidx) {\n    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;\n  },\n\n  _clamp(v, min, max) {\n    return Math.min(max, Math.max(min, v));\n  },\n\n  _debounce(name, cb, asyncModule) {\n    if (!this._debouncers) {\n      this._debouncers = {};\n    }\n    this._debouncers[name] = Debouncer.debounce(this._debouncers[name], asyncModule, cb.bind(this));\n    enqueueDebouncer(this._debouncers[name]);\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}