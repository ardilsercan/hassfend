{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Specifies an observer callback that is run when the decorated property\n * changes. The observer receives the current and old value as arguments.\n */\nexport const observer = observer =>\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(proto, propName) => {\n  // if we haven't wrapped `updated` in this class, do so\n  if (!proto.constructor._observers) {\n    proto.constructor._observers = new Map();\n    const userUpdated = proto.updated;\n    proto.updated = function (changedProperties) {\n      userUpdated.call(this, changedProperties);\n      changedProperties.forEach((v, k) => {\n        const observers = this.constructor._observers;\n        const observer = observers.get(k);\n        if (observer !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          observer.call(this, this[k], v);\n        }\n      });\n    };\n    // clone any existing observers (superclasses)\n    // eslint-disable-next-line no-prototype-builtins\n  } else if (!proto.constructor.hasOwnProperty('_observers')) {\n    const observers = proto.constructor._observers;\n    proto.constructor._observers = new Map();\n    observers.forEach(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (v, k) => proto.constructor._observers.set(k, v));\n  }\n  // set this method\n  proto.constructor._observers.set(propName, observer);\n};","map":{"version":3,"names":["observer","proto","propName","constructor","_observers","Map","userUpdated","updated","changedProperties","call","forEach","v","k","observers","get","undefined","hasOwnProperty","set"],"sources":["observer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n// tslint:disable:no-any\n\nimport {PropertyValues, ReactiveElement} from '@lit/reactive-element';\n\n/**\n * Observer function type.\n */\nexport interface Observer {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (value: any, old: any): void;\n}\n\ntype ReactiveElementClass = typeof ReactiveElement;\ninterface ReactiveElementClassWithObservers extends ReactiveElementClass {\n  // tslint:disable-next-line:enforce-name-casing\n  _observers: Map<PropertyKey, Observer>;\n}\n\n/**\n * Specifies an observer callback that is run when the decorated property\n * changes. The observer receives the current and old value as arguments.\n */\nexport const observer = (observer: Observer) =>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (proto: any, propName: PropertyKey) => {\n      // if we haven't wrapped `updated` in this class, do so\n      if (!(proto.constructor as ReactiveElementClassWithObservers)\n               ._observers) {\n        proto.constructor._observers = new Map<PropertyKey, Observer>();\n        const userUpdated = proto.updated;\n        proto.updated = function(\n            this: ReactiveElement, changedProperties: PropertyValues) {\n          userUpdated.call(this, changedProperties);\n          changedProperties.forEach((v, k) => {\n            const observers =\n                (this.constructor as ReactiveElementClassWithObservers)\n                    ._observers;\n            const observer = observers.get(k);\n            if (observer !== undefined) {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              observer.call(this, (this as any)[k], v);\n            }\n          });\n        };\n        // clone any existing observers (superclasses)\n        // eslint-disable-next-line no-prototype-builtins\n      } else if (!proto.constructor.hasOwnProperty('_observers')) {\n        const observers = proto.constructor._observers;\n        proto.constructor._observers = new Map();\n        observers.forEach(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (v: any, k: PropertyKey) => proto.constructor._observers.set(k, v));\n      }\n      // set this method\n      proto.constructor._observers.set(propName, observer);\n    };\n"],"mappings":"AAAA;;;;;AA0BA;;;;AAIA,OAAO,MAAMA,QAAQ,GAAIA,QAAkB;AACvC;AACA,CAACC,KAAU,EAAEC,QAAqB,KAAI;EACpC;EACA,IAAI,CAAED,KAAK,CAACE,WAAiD,CACnDC,UAAU,EAAE;IACpBH,KAAK,CAACE,WAAW,CAACC,UAAU,GAAG,IAAIC,GAAG,EAAyB;IAC/D,MAAMC,WAAW,GAAGL,KAAK,CAACM,OAAO;IACjCN,KAAK,CAACM,OAAO,GAAG,UACWC,iBAAiC;MAC1DF,WAAW,CAACG,IAAI,CAAC,IAAI,EAAED,iBAAiB,CAAC;MACzCA,iBAAiB,CAACE,OAAO,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAI;QACjC,MAAMC,SAAS,GACV,IAAI,CAACV,WAAiD,CAClDC,UAAU;QACnB,MAAMJ,QAAQ,GAAGa,SAAS,CAACC,GAAG,CAACF,CAAC,CAAC;QACjC,IAAIZ,QAAQ,KAAKe,SAAS,EAAE;UAC1B;UACAf,QAAQ,CAACS,IAAI,CAAC,IAAI,EAAG,IAAY,CAACG,CAAC,CAAC,EAAED,CAAC,CAAC;;MAE5C,CAAC,CAAC;IACJ,CAAC;IACD;IACA;GACD,MAAM,IAAI,CAACV,KAAK,CAACE,WAAW,CAACa,cAAc,CAAC,YAAY,CAAC,EAAE;IAC1D,MAAMH,SAAS,GAAGZ,KAAK,CAACE,WAAW,CAACC,UAAU;IAC9CH,KAAK,CAACE,WAAW,CAACC,UAAU,GAAG,IAAIC,GAAG,EAAE;IACxCQ,SAAS,CAACH,OAAO;IACb;IACA,CAACC,CAAM,EAAEC,CAAc,KAAKX,KAAK,CAACE,WAAW,CAACC,UAAU,CAACa,GAAG,CAACL,CAAC,EAAED,CAAC,CAAC,CAAC;;EAEzE;EACAV,KAAK,CAACE,WAAW,CAACC,UAAU,CAACa,GAAG,CAACf,QAAQ,EAAEF,QAAQ,CAAC;AACtD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}