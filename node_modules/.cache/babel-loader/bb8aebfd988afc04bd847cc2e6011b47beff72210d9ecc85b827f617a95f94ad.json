{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\nimport { showHideChildren, templatize } from '../utils/templatize.js';\n\n/**\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Base class for dom-if element; subclassed into concrete\n *   implementation.\n */\nclass DomIfBase extends PolymerElement {\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() {\n    return 'dom-if';\n  }\n  static get template() {\n    return null;\n  }\n  static get properties() {\n    return {\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      }\n    };\n  }\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this._lastIf = false;\n    this.__hideTemplateChildren__ = false;\n    /** @type {!HTMLTemplateElement|undefined} */\n    this.__template;\n    /** @type {!TemplateInfo|undefined} */\n    this._templateInfo;\n  }\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap(parent).host) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Ensures a template has been assigned to `this.__template`.  If it has not\n   * yet been, it querySelectors for it in its children and if it does not yet\n   * exist (e.g. in parser-generated case), opens a mutation observer and\n   * waits for it to appear (returns false if it has not yet been found,\n   * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\n   * be the `dom-if` element itself.\n   *\n   * @return {boolean} True when a template has been found, false otherwise\n   */\n  __ensureTemplate() {\n    if (!this.__template) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */\n      /** @type {!HTMLElement} */this;\n      let template = thisAsTemplate._templateInfo ? thisAsTemplate : ( /** @type {!HTMLTemplateElement} */\n      wrap(thisAsTemplate).querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (wrap(this).querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-if requires a <template> child');\n          }\n        });\n        observer.observe(this, {\n          childList: true\n        });\n        return false;\n      }\n      this.__template = template;\n    }\n    return true;\n  }\n\n  /**\n   * Ensures a an instance of the template has been created and inserted. This\n   * method may return false if the template has not yet been found or if\n   * there is no `parentNode` to insert the template into (in either case,\n   * connection or the template-finding mutation observer firing will queue\n   * another render, causing this method to be called again at a more\n   * appropriate time).\n   *\n   * Subclasses should implement the following methods called here:\n   * - `__hasInstance`\n   * - `__createAndInsertInstance`\n   * - `__getInstanceNodes`\n   *\n   * @return {boolean} True if the instance was created, false otherwise.\n   */\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    if (!this.__hasInstance()) {\n      // Guard against element being detached while render was queued\n      if (!parentNode) {\n        return false;\n      }\n      // Find the template (when false, there was no template yet)\n      if (!this.__ensureTemplate()) {\n        return false;\n      }\n      this.__createAndInsertInstance(parentNode);\n    } else {\n      // Move instance children if necessary\n      let children = this.__getInstanceNodes();\n      if (children && children.length) {\n        // Detect case where dom-if was re-attached in new position\n        let lastChild = wrap(this).previousSibling;\n        if (lastChild !== children[children.length - 1]) {\n          for (let i = 0, n; i < children.length && (n = children[i]); i++) {\n            wrap(parentNode).insertBefore(n, this);\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   *\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  /**\n   * Performs the key rendering steps:\n   * 1. Ensure a template instance has been stamped (when true)\n   * 2. Remove the template instance (when false and restamp:true)\n   * 3. Sync the hidden state of the instance nodes with the if/restamp state\n   * 4. Fires the `dom-change` event when necessary\n   *\n   * @return {void}\n   */\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    this._showHideChildren();\n    if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  // Ideally these would be annotated as abstract methods in an abstract class,\n  // but closure compiler is finnicky\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Abstract API to be implemented by subclass: Returns true if a template\n   * instance has been created and inserted.\n   *\n   * @protected\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {}\n\n  /**\n   * Abstract API to be implemented by subclass: Returns the child nodes stamped\n   * from a template instance.\n   *\n   * @protected\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {}\n\n  /**\n   * Abstract API to be implemented by subclass: Creates an instance of the\n   * template and inserts it into the given parent node.\n   *\n   * @protected\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {} // eslint-disable-line no-unused-vars\n\n  /**\n   * Abstract API to be implemented by subclass: Removes nodes created by an\n   * instance of a template and any associated cleanup.\n   *\n   * @protected\n   * @return {void}\n   */\n  __teardownInstance() {}\n\n  /**\n   * Abstract API to be implemented by subclass: Shows or hides any template\n   * instance childNodes based on the `if` state of the element and its\n   * `__hideTemplateChildren__` property.\n   *\n   * @protected\n   * @return {void}\n   */\n  _showHideChildren() {}\n  /* eslint-enable valid-jsdoc */\n}\n\n/**\n * The version of DomIf used when `fastDomIf` setting is in use, which is\n * optimized for first-render (but adds a tax to all subsequent property updates\n * on the host, whether they were used in a given `dom-if` or not).\n *\n * This implementation avoids use of `Templatizer`, which introduces a new scope\n * (a non-element PropertyEffects instance), which is not strictly necessary\n * since `dom-if` never introduces new properties to its scope (unlike\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\n * `__dataHost` and stamps the template directly from the host using the host's\n * runtime `_stampTemplate` API, which binds the property effects of the\n * template directly to the host. This both avoids the intermediary\n * `Templatizer` instance, but also avoids the need to bind host properties to\n * the `<template>` element and forward those into the template instance.\n *\n * In this version of `dom-if`, the `this.__instance` method is the\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\n * handle for later removing it using the `_removeBoundDom` method.\n */\nclass DomIfFast extends DomIfBase {\n  constructor() {\n    super();\n    this.__instance = null;\n    this.__syncInfo = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.templateInfo.childNodes;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\n   * element and then inserts the resulting nodes into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    const host = this.__dataHost || this;\n    if (strictTemplatePolicy) {\n      if (!this.__dataHost) {\n        throw new Error('strictTemplatePolicy: template owner not trusted');\n      }\n    }\n    // Pre-bind and link the template into the effects system\n    const templateInfo = host._bindTemplate( /** @type {!HTMLTemplateElement} */this.__template, true);\n    // Install runEffects hook that prevents running property effects\n    // (and any nested template effects) when the `if` is false\n    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {\n      let syncInfo = this.__syncInfo;\n      if (this.if) {\n        // Mix any props that changed while the `if` was false into `changedProps`\n        if (syncInfo) {\n          // If there were properties received while the `if` was false, it is\n          // important to sync the hidden state with the element _first_, so that\n          // new bindings to e.g. `textContent` do not get stomped on by\n          // pre-hidden values if `_showHideChildren` were to be called later at\n          // the next render. Clearing `__invalidProps` here ensures\n          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\n          // that we don't call `runEffects` more often than necessary.\n          this.__syncInfo = null;\n          this._showHideChildren();\n          changedProps = Object.assign(syncInfo.changedProps, changedProps);\n        }\n        runEffects(changedProps, hasPaths);\n      } else {\n        // Accumulate any values changed while `if` was false, along with the\n        // runEffects method to sync them, so that we can replay them once `if`\n        // becomes true\n        if (this.__instance) {\n          if (!syncInfo) {\n            syncInfo = this.__syncInfo = {\n              runEffects,\n              changedProps: {}\n            };\n          }\n          if (hasPaths) {\n            // Store root object of any paths; this will ensure direct bindings\n            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\n            // note that path notifications like `set('obj.foo.bar', v)` will\n            // not propagate. Since batched path notifications are not\n            // supported, we cannot simply accumulate path notifications. This\n            // is equivalent to the non-fastDomIf case, which stores root(p) in\n            // __invalidProps.\n            for (const p in changedProps) {\n              const rootProp = root(p);\n              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];\n            }\n          } else {\n            Object.assign(syncInfo.changedProps, changedProps);\n          }\n        }\n      }\n    };\n    // Stamp the template, and set its DocumentFragment to the \"instance\"\n    this.__instance = host._stampTemplate( /** @type {!HTMLTemplateElement} */this.__template, templateInfo);\n    wrap(parentNode).insertBefore(this.__instance, this);\n  }\n\n  /**\n   * Run effects for any properties that changed while the `if` was false.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    const syncInfo = this.__syncInfo;\n    if (syncInfo) {\n      this.__syncInfo = null;\n      syncInfo.runEffects(syncInfo.changedProps, false);\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\n   * runtime `_removeBoundDom` method.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    const host = this.__dataHost || this;\n    if (this.__instance) {\n      host._removeBoundDom(this.__instance);\n      this.__instance = null;\n      this.__syncInfo = null;\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child nodes. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      showHideChildren(hidden, this.__instance.templateInfo.childNodes);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\n *\n * In this version, `this.__instance` is the `TemplateInstance` returned\n * from the templatized constructor.\n */\nclass DomIfLegacy extends DomIfBase {\n  constructor() {\n    super();\n    this.__ctor = null;\n    this.__instance = null;\n    this.__invalidProps = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.children;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by creating a new instance of the templatized\n   * constructor (which is created lazily if it does not yet exist), and then\n   * inserts its resulting `root` doc fragment into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    // Ensure we have an instance constructor\n    if (!this.__ctor) {\n      this.__ctor = templatize( /** @type {!HTMLTemplateElement} */this.__template, this, {\n        // dom-if templatizer instances require `mutable: true`, as\n        // `__syncHostProperties` relies on that behavior to sync objects\n        mutableData: true,\n        /**\n         * @param {string} prop Property to forward\n         * @param {*} value Value of property\n         * @this {DomIfLegacy}\n         */\n        forwardHostProp: function (prop, value) {\n          if (this.__instance) {\n            if (this.if) {\n              this.__instance.forwardHostProp(prop, value);\n            } else {\n              // If we have an instance but are squelching host property\n              // forwarding due to if being false, note the invalidated\n              // properties so `__syncHostProperties` can sync them the next\n              // time `if` becomes true\n              this.__invalidProps = this.__invalidProps || Object.create(null);\n              this.__invalidProps[root(prop)] = true;\n            }\n          }\n        }\n      });\n    }\n    // Create and insert the instance\n    this.__instance = new this.__ctor();\n    wrap(parentNode).insertBefore(this.__instance.root, this);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Removes the instance and any nodes it created.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i = 0, n; i < c$.length && (n = c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__invalidProps = null;\n      this.__instance = null;\n    }\n  }\n\n  /**\n   * Forwards any properties that changed while the `if` was false into the\n   * template instance and flushes it.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      this.__invalidProps = null;\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__instance._flushProperties();\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @protected\n   * @return {void}\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      this.__instance._showHideChildren(hidden);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends DomIfBase\n * @constructor\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\ncustomElements.define(DomIf.is, DomIf);","map":{"version":3,"names":["PolymerElement","Debouncer","enqueueDebouncer","flush","microTask","root","wrap","hideElementsGlobally","fastDomIf","strictTemplatePolicy","suppressTemplateNotifications","showHideChildren","templatize","DomIfBase","is","template","properties","if","type","Boolean","observer","restamp","notifyDomChange","constructor","__renderDebouncer","_lastIf","__hideTemplateChildren__","__template","_templateInfo","__debounceRender","debounce","__render","disconnectedCallback","parent","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","__teardownInstance","connectedCallback","style","display","__ensureTemplate","thisAsTemplate","querySelector","MutationObserver","disconnect","Error","observe","childList","__ensureInstance","__hasInstance","__createAndInsertInstance","children","__getInstanceNodes","length","lastChild","previousSibling","i","n","insertBefore","render","_showHideChildren","dispatchEvent","CustomEvent","bubbles","composed","DomIfFast","__instance","__syncInfo","templateInfo","childNodes","__dataHost","_bindTemplate","runEffects","changedProps","hasPaths","syncInfo","Object","assign","p","rootProp","_stampTemplate","__syncHostProperties","_removeBoundDom","hidden","__hidden","DomIfLegacy","__ctor","__invalidProps","mutableData","forwardHostProp","prop","value","create","c$","removeChild","props","_setPendingProperty","_flushProperties","DomIf","customElements","define"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/elements/dom-if.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\nimport { showHideChildren, templatize } from '../utils/templatize.js';\n\n/**\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Base class for dom-if element; subclassed into concrete\n *   implementation.\n */\nclass DomIfBase extends PolymerElement {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-if'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    return {\n\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      }\n    };\n\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this._lastIf = false;\n    this.__hideTemplateChildren__ = false;\n    /** @type {!HTMLTemplateElement|undefined} */\n    this.__template;\n    /** @type {!TemplateInfo|undefined} */\n    this._templateInfo;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , microTask\n        , () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\n        !wrap(parent).host)) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Ensures a template has been assigned to `this.__template`.  If it has not\n   * yet been, it querySelectors for it in its children and if it does not yet\n   * exist (e.g. in parser-generated case), opens a mutation observer and\n   * waits for it to appear (returns false if it has not yet been found,\n   * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\n   * be the `dom-if` element itself.\n   *\n   * @return {boolean} True when a template has been found, false otherwise\n   */\n  __ensureTemplate() {\n    if (!this.__template) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\n          /** @type {!HTMLElement} */ (this));\n      let template = thisAsTemplate._templateInfo ?\n          thisAsTemplate :\n          /** @type {!HTMLTemplateElement} */\n          (wrap(thisAsTemplate).querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (wrap(this).querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-if requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      this.__template = template;\n    }\n    return true;\n  }\n\n  /**\n   * Ensures a an instance of the template has been created and inserted. This\n   * method may return false if the template has not yet been found or if\n   * there is no `parentNode` to insert the template into (in either case,\n   * connection or the template-finding mutation observer firing will queue\n   * another render, causing this method to be called again at a more\n   * appropriate time).\n   *\n   * Subclasses should implement the following methods called here:\n   * - `__hasInstance`\n   * - `__createAndInsertInstance`\n   * - `__getInstanceNodes`\n   *\n   * @return {boolean} True if the instance was created, false otherwise.\n   */\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    if (!this.__hasInstance()) {\n      // Guard against element being detached while render was queued\n      if (!parentNode) {\n        return false;\n      }\n      // Find the template (when false, there was no template yet)\n      if (!this.__ensureTemplate()) {\n        return false;\n      }\n      this.__createAndInsertInstance(parentNode);\n    } else {\n      // Move instance children if necessary\n      let children = this.__getInstanceNodes();\n      if (children && children.length) {\n        // Detect case where dom-if was re-attached in new position\n        let lastChild = wrap(this).previousSibling;\n        if (lastChild !== children[children.length-1]) {\n          for (let i=0, n; (i<children.length) && (n=children[i]); i++) {\n            wrap(parentNode).insertBefore(n, this);\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   *\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  /**\n   * Performs the key rendering steps:\n   * 1. Ensure a template instance has been stamped (when true)\n   * 2. Remove the template instance (when false and restamp:true)\n   * 3. Sync the hidden state of the instance nodes with the if/restamp state\n   * 4. Fires the `dom-change` event when necessary\n   *\n   * @return {void}\n   */\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    this._showHideChildren();\n    if ((!suppressTemplateNotifications || this.notifyDomChange)\n        && this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  // Ideally these would be annotated as abstract methods in an abstract class,\n  // but closure compiler is finnicky\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Abstract API to be implemented by subclass: Returns true if a template\n   * instance has been created and inserted.\n   *\n   * @protected\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Returns the child nodes stamped\n   * from a template instance.\n   *\n   * @protected\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Creates an instance of the\n   * template and inserts it into the given parent node.\n   *\n   * @protected\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) { } // eslint-disable-line no-unused-vars\n\n  /**\n   * Abstract API to be implemented by subclass: Removes nodes created by an\n   * instance of a template and any associated cleanup.\n   *\n   * @protected\n   * @return {void}\n   */\n  __teardownInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Shows or hides any template\n   * instance childNodes based on the `if` state of the element and its\n   * `__hideTemplateChildren__` property.\n   *\n   * @protected\n   * @return {void}\n   */\n  _showHideChildren() { }\n  /* eslint-enable valid-jsdoc */\n}\n\n/**\n * The version of DomIf used when `fastDomIf` setting is in use, which is\n * optimized for first-render (but adds a tax to all subsequent property updates\n * on the host, whether they were used in a given `dom-if` or not).\n *\n * This implementation avoids use of `Templatizer`, which introduces a new scope\n * (a non-element PropertyEffects instance), which is not strictly necessary\n * since `dom-if` never introduces new properties to its scope (unlike\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\n * `__dataHost` and stamps the template directly from the host using the host's\n * runtime `_stampTemplate` API, which binds the property effects of the\n * template directly to the host. This both avoids the intermediary\n * `Templatizer` instance, but also avoids the need to bind host properties to\n * the `<template>` element and forward those into the template instance.\n *\n * In this version of `dom-if`, the `this.__instance` method is the\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\n * handle for later removing it using the `_removeBoundDom` method.\n */\nclass DomIfFast extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__instance = null;\n    this.__syncInfo = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.templateInfo.childNodes;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\n   * element and then inserts the resulting nodes into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    const host = this.__dataHost || this;\n    if (strictTemplatePolicy) {\n      if (!this.__dataHost) {\n        throw new Error('strictTemplatePolicy: template owner not trusted');\n      }\n    }\n    // Pre-bind and link the template into the effects system\n    const templateInfo = host._bindTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), true);\n    // Install runEffects hook that prevents running property effects\n    // (and any nested template effects) when the `if` is false\n    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {\n      let syncInfo = this.__syncInfo;\n      if (this.if) {\n        // Mix any props that changed while the `if` was false into `changedProps`\n        if (syncInfo) {\n          // If there were properties received while the `if` was false, it is\n          // important to sync the hidden state with the element _first_, so that\n          // new bindings to e.g. `textContent` do not get stomped on by\n          // pre-hidden values if `_showHideChildren` were to be called later at\n          // the next render. Clearing `__invalidProps` here ensures\n          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\n          // that we don't call `runEffects` more often than necessary.\n          this.__syncInfo = null;\n          this._showHideChildren();\n          changedProps = Object.assign(syncInfo.changedProps, changedProps);\n        }\n        runEffects(changedProps, hasPaths);\n      } else {\n        // Accumulate any values changed while `if` was false, along with the\n        // runEffects method to sync them, so that we can replay them once `if`\n        // becomes true\n        if (this.__instance) {\n          if (!syncInfo) {\n            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };\n          }\n          if (hasPaths) {\n            // Store root object of any paths; this will ensure direct bindings\n            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\n            // note that path notifications like `set('obj.foo.bar', v)` will\n            // not propagate. Since batched path notifications are not\n            // supported, we cannot simply accumulate path notifications. This\n            // is equivalent to the non-fastDomIf case, which stores root(p) in\n            // __invalidProps.\n            for (const p in changedProps) {\n              const rootProp = root(p);\n              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];\n            }\n          } else {\n            Object.assign(syncInfo.changedProps, changedProps);\n          }\n        }\n      }\n    };\n    // Stamp the template, and set its DocumentFragment to the \"instance\"\n    this.__instance = host._stampTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), templateInfo);\n    wrap(parentNode).insertBefore(this.__instance, this);\n  }\n\n  /**\n   * Run effects for any properties that changed while the `if` was false.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    const syncInfo = this.__syncInfo;\n    if (syncInfo) {\n      this.__syncInfo = null;\n      syncInfo.runEffects(syncInfo.changedProps, false);\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\n   * runtime `_removeBoundDom` method.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    const host = this.__dataHost || this;\n    if (this.__instance) {\n      host._removeBoundDom(this.__instance);\n      this.__instance = null;\n      this.__syncInfo = null;\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child nodes. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      showHideChildren(hidden, this.__instance.templateInfo.childNodes);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\n *\n * In this version, `this.__instance` is the `TemplateInstance` returned\n * from the templatized constructor.\n */\nclass DomIfLegacy extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__ctor = null;\n    this.__instance = null;\n    this.__invalidProps = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.children;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by creating a new instance of the templatized\n   * constructor (which is created lazily if it does not yet exist), and then\n   * inserts its resulting `root` doc fragment into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    // Ensure we have an instance constructor\n    if (!this.__ctor) {\n      this.__ctor = templatize(\n          /** @type {!HTMLTemplateElement} */ (this.__template), this, {\n            // dom-if templatizer instances require `mutable: true`, as\n            // `__syncHostProperties` relies on that behavior to sync objects\n            mutableData: true,\n            /**\n             * @param {string} prop Property to forward\n             * @param {*} value Value of property\n             * @this {DomIfLegacy}\n             */\n            forwardHostProp: function(prop, value) {\n              if (this.__instance) {\n                if (this.if) {\n                  this.__instance.forwardHostProp(prop, value);\n                } else {\n                  // If we have an instance but are squelching host property\n                  // forwarding due to if being false, note the invalidated\n                  // properties so `__syncHostProperties` can sync them the next\n                  // time `if` becomes true\n                  this.__invalidProps =\n                      this.__invalidProps || Object.create(null);\n                  this.__invalidProps[root(prop)] = true;\n                }\n              }\n            }\n          });\n    }\n    // Create and insert the instance\n    this.__instance = new this.__ctor();\n    wrap(parentNode).insertBefore(this.__instance.root, this);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Removes the instance and any nodes it created.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__invalidProps = null;\n      this.__instance = null;\n    }\n  }\n\n  /**\n   * Forwards any properties that changed while the `if` was false into the\n   * template instance and flushes it.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      this.__invalidProps = null;\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__instance._flushProperties();\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @protected\n   * @return {void}\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      this.__instance._showHideChildren(hidden);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends DomIfBase\n * @constructor\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\n\ncustomElements.define(DomIf.is, DomIf);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}