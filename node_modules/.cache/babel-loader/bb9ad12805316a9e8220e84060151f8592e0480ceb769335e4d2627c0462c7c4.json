{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\n/* eslint-disable no-console */\n\nimport { castApiAvailable } from \"./cast_framework\";\nimport { CAST_APP_ID, CAST_DEV, CAST_NS } from \"./const\";\nimport { CAST_DEV_HASS_URL } from \"./dev_const\";\nimport { castSendAuth } from \"./receiver_messages\";\nvar managerProm;\n\n/*\nGeneral flow of Chromecast:\n\nChromecast sessions are started via the Chromecast button. When clicked, session\nstate changes to started. We then send authentication, which will cause the\nreceiver app to send a status update.\n\nIf a session is already active, we query the status to see what it is up to. If\na user presses the cast button we send auth if not connected yet, then send\ncommand as usual.\n*/\n\nexport var CastManager = /*#__PURE__*/function () {\n  function CastManager(auth) {\n    var _this = this;\n    _classCallCheck(this, CastManager);\n    this.auth = void 0;\n    // If the cast connection is connected to our Hass.\n    this.status = void 0;\n    this._eventListeners = {};\n    this._sessionStateChanged = function (ev) {\n      if (__DEV__) {\n        console.log(\"Cast session state changed\", ev.sessionState);\n      }\n      // On Android, opening a new session always results in SESSION_RESUMED.\n      // So treat both as the same.\n      if (ev.sessionState === \"SESSION_STARTED\" || ev.sessionState === \"SESSION_RESUMED\") {\n        if (_this.auth) {\n          castSendAuth(_this, _this.auth);\n        } else {\n          // Only do if no auth, as this is done as part of sendAuth.\n          _this.sendMessage({\n            type: \"get_status\"\n          });\n        }\n        _this._attachMessageListener();\n      } else if (ev.sessionState === \"SESSION_ENDED\") {\n        _this.status = undefined;\n        _this._fireEvent(\"connection-changed\");\n      }\n    };\n    this._castStateChanged = function (ev) {\n      if (__DEV__) {\n        console.log(\"Cast state changed\", ev.castState);\n      }\n      _this._fireEvent(\"state-changed\");\n    };\n    this.auth = auth;\n    var context = this.castContext;\n    context.setOptions({\n      receiverApplicationId: CAST_APP_ID,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED\n    });\n    context.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, this._sessionStateChanged);\n    context.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, this._castStateChanged);\n  }\n  _createClass(CastManager, [{\n    key: \"addEventListener\",\n    value: function addEventListener(event, listener) {\n      var _this2 = this;\n      if (!(event in this._eventListeners)) {\n        this._eventListeners[event] = [];\n      }\n      this._eventListeners[event].push(listener);\n      return function () {\n        _this2._eventListeners[event].splice(_this2._eventListeners[event].indexOf(listener));\n      };\n    }\n  }, {\n    key: \"castConnectedToOurHass\",\n    get: function get() {\n      return this.status !== undefined && this.auth !== undefined && this.status.connected && (this.status.hassUrl === this.auth.data.hassUrl || CAST_DEV && this.status.hassUrl === CAST_DEV_HASS_URL);\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(msg) {\n      if (__DEV__) {\n        console.log(\"Sending cast message\", msg);\n      }\n      this.castSession.sendMessage(CAST_NS, msg);\n    }\n  }, {\n    key: \"castState\",\n    get: function get() {\n      return this.castContext.getCastState();\n    }\n  }, {\n    key: \"castContext\",\n    get: function get() {\n      // @ts-ignore\n      return cast.framework.CastContext.getInstance();\n    }\n  }, {\n    key: \"castSession\",\n    get: function get() {\n      return this.castContext.getCurrentSession();\n    }\n  }, {\n    key: \"requestSession\",\n    value: function requestSession() {\n      return this.castContext.requestSession();\n    }\n  }, {\n    key: \"_fireEvent\",\n    value: function _fireEvent(event) {\n      var _iterator = _createForOfIteratorHelper(this._eventListeners[event] || []),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_receiveMessage\",\n    value: function _receiveMessage(msg) {\n      if (__DEV__) {\n        console.log(\"Received cast message\", msg);\n      }\n      if (msg.type === \"receiver_status\") {\n        this.status = msg;\n        this._fireEvent(\"connection-changed\");\n      }\n    }\n  }, {\n    key: \"_attachMessageListener\",\n    value: function _attachMessageListener() {\n      var _this3 = this;\n      var session = this.castSession;\n      session.addMessageListener(CAST_NS, function (_ns, msg) {\n        return _this3._receiveMessage(JSON.parse(msg));\n      });\n    }\n  }]);\n  return CastManager;\n}();\nexport var getCastManager = function getCastManager(auth) {\n  if (!managerProm) {\n    managerProm = castApiAvailable().then(function (isAvailable) {\n      if (!isAvailable) {\n        throw new Error(\"No Cast API available\");\n      }\n      return new CastManager(auth);\n    });\n  }\n  return managerProm;\n};","map":{"version":3,"names":["castApiAvailable","CAST_APP_ID","CAST_DEV","CAST_NS","CAST_DEV_HASS_URL","castSendAuth","managerProm","CastManager","auth","_this","_classCallCheck","status","_eventListeners","_sessionStateChanged","ev","__DEV__","console","log","sessionState","sendMessage","type","_attachMessageListener","undefined","_fireEvent","_castStateChanged","castState","context","castContext","setOptions","receiverApplicationId","autoJoinPolicy","chrome","cast","AutoJoinPolicy","ORIGIN_SCOPED","addEventListener","framework","CastContextEventType","SESSION_STATE_CHANGED","CAST_STATE_CHANGED","_createClass","key","value","event","listener","_this2","push","splice","indexOf","get","connected","hassUrl","data","msg","castSession","getCastState","CastContext","getInstance","getCurrentSession","requestSession","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_receiveMessage","_this3","session","addMessageListener","_ns","JSON","parse","getCastManager","then","isAvailable","Error"],"sources":["/Users/sercanardil/Desktop/frontend/src/cast/cast_manager.ts"],"sourcesContent":["/* eslint-disable no-console */\n\nimport { Auth } from \"home-assistant-js-websocket\";\nimport { castApiAvailable } from \"./cast_framework\";\nimport { CAST_APP_ID, CAST_DEV, CAST_NS } from \"./const\";\nimport { CAST_DEV_HASS_URL } from \"./dev_const\";\nimport {\n  castSendAuth,\n  HassMessage as ReceiverMessage,\n} from \"./receiver_messages\";\nimport { ReceiverStatusMessage, SenderMessage } from \"./sender_messages\";\n\nlet managerProm: Promise<CastManager> | undefined;\n\ntype CastEventListener = () => void;\n\n/*\nGeneral flow of Chromecast:\n\nChromecast sessions are started via the Chromecast button. When clicked, session\nstate changes to started. We then send authentication, which will cause the\nreceiver app to send a status update.\n\nIf a session is already active, we query the status to see what it is up to. If\na user presses the cast button we send auth if not connected yet, then send\ncommand as usual.\n*/\n\ntype CastEvent = \"connection-changed\" | \"state-changed\";\n\nexport class CastManager {\n  public auth?: Auth;\n\n  // If the cast connection is connected to our Hass.\n  public status?: ReceiverStatusMessage;\n\n  private _eventListeners: { [event: string]: CastEventListener[] } = {};\n\n  constructor(auth?: Auth) {\n    this.auth = auth;\n    const context = this.castContext;\n    context.setOptions({\n      receiverApplicationId: CAST_APP_ID,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,\n    });\n    context.addEventListener(\n      cast.framework.CastContextEventType.SESSION_STATE_CHANGED,\n      this._sessionStateChanged\n    );\n    context.addEventListener(\n      cast.framework.CastContextEventType.CAST_STATE_CHANGED,\n      this._castStateChanged\n    );\n  }\n\n  public addEventListener(event: CastEvent, listener: CastEventListener) {\n    if (!(event in this._eventListeners)) {\n      this._eventListeners[event] = [];\n    }\n    this._eventListeners[event].push(listener);\n\n    return () => {\n      this._eventListeners[event].splice(\n        this._eventListeners[event].indexOf(listener)\n      );\n    };\n  }\n\n  public get castConnectedToOurHass(): boolean {\n    return (\n      this.status !== undefined &&\n      this.auth !== undefined &&\n      this.status.connected &&\n      (this.status.hassUrl === this.auth.data.hassUrl ||\n        (CAST_DEV && this.status.hassUrl === CAST_DEV_HASS_URL))\n    );\n  }\n\n  public sendMessage(msg: ReceiverMessage) {\n    if (__DEV__) {\n      console.log(\"Sending cast message\", msg);\n    }\n    this.castSession.sendMessage(CAST_NS, msg);\n  }\n\n  public get castState() {\n    return this.castContext.getCastState();\n  }\n\n  public get castContext() {\n    // @ts-ignore\n    return cast.framework.CastContext.getInstance();\n  }\n\n  public get castSession() {\n    return this.castContext.getCurrentSession()!;\n  }\n\n  public requestSession() {\n    return this.castContext.requestSession();\n  }\n\n  private _fireEvent(event: CastEvent) {\n    for (const listener of this._eventListeners[event] || []) {\n      listener();\n    }\n  }\n\n  private _receiveMessage(msg: SenderMessage) {\n    if (__DEV__) {\n      console.log(\"Received cast message\", msg);\n    }\n    if (msg.type === \"receiver_status\") {\n      this.status = msg;\n      this._fireEvent(\"connection-changed\");\n    }\n  }\n\n  private _sessionStateChanged = (ev: cast.framework.SessionStateEventData) => {\n    if (__DEV__) {\n      console.log(\"Cast session state changed\", ev.sessionState);\n    }\n    // On Android, opening a new session always results in SESSION_RESUMED.\n    // So treat both as the same.\n    if (\n      ev.sessionState === \"SESSION_STARTED\" ||\n      ev.sessionState === \"SESSION_RESUMED\"\n    ) {\n      if (this.auth) {\n        castSendAuth(this, this.auth);\n      } else {\n        // Only do if no auth, as this is done as part of sendAuth.\n        this.sendMessage({ type: \"get_status\" });\n      }\n      this._attachMessageListener();\n    } else if (ev.sessionState === \"SESSION_ENDED\") {\n      this.status = undefined;\n      this._fireEvent(\"connection-changed\");\n    }\n  };\n\n  private _castStateChanged = (ev: cast.framework.CastStateEventData) => {\n    if (__DEV__) {\n      console.log(\"Cast state changed\", ev.castState);\n    }\n    this._fireEvent(\"state-changed\");\n  };\n\n  private _attachMessageListener() {\n    const session = this.castSession;\n    session.addMessageListener(CAST_NS, (_ns, msg) =>\n      this._receiveMessage(JSON.parse(msg))\n    );\n  }\n}\n\nexport const getCastManager = (auth?: Auth) => {\n  if (!managerProm) {\n    managerProm = castApiAvailable().then((isAvailable) => {\n      if (!isAvailable) {\n        throw new Error(\"No Cast API available\");\n      }\n      return new CastManager(auth);\n    });\n  }\n  return managerProm;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}