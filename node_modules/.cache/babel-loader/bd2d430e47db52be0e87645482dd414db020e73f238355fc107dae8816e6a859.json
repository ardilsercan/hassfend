{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/** @const {!AsyncInterface} */\nvar microtask = microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport var PropertiesChanged = dedupingMixin(\n/**\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nfunction (superClass) {\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  var PropertiesChanged = /*#__PURE__*/function (_superClass) {\n    _inherits(PropertiesChanged, _superClass);\n    function PropertiesChanged() {\n      var _this;\n      _classCallCheck(this, PropertiesChanged);\n      _this = _callSuper(this, PropertiesChanged);\n      /** @type {boolean} */\n      _this.__dataEnabled = false;\n      _this.__dataReady = false;\n      _this.__dataInvalid = false;\n      _this.__data = {};\n      _this.__dataPending = null;\n      _this.__dataOld = null;\n      _this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      _this.__dataCounter = 0;\n      _this.__serializing = false;\n      _this._initializeProperties();\n      return _this;\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    _createClass(PropertiesChanged, [{\n      key: \"_createPropertyAccessor\",\n      value:\n      //eslint-disable-line no-unused-vars\n\n      /**\n       * Creates a setter/getter pair for the named property with its own\n       * local storage.  The getter returns the value in the local storage,\n       * and the setter calls `_setProperty`, which updates the local storage\n       * for the property and enqueues a `_propertiesChanged` callback.\n       *\n       * This method may be called on a prototype or an instance.  Calling\n       * this method may overwrite a property value that already exists on\n       * the prototype/instance by creating the accessor.\n       *\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created; the\n       *   protected `_setProperty` function must be used to set the property\n       * @return {void}\n       * @protected\n       * @override\n       */\n      function _createPropertyAccessor(property, readOnly) {\n        this._addPropertyToAttributeMap(property);\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n        }\n        if (!this.__dataHasAccessor[property]) {\n          this.__dataHasAccessor[property] = true;\n          this._definePropertyAccessor(property, readOnly);\n        }\n      }\n\n      /**\n       * Adds the given `property` to a map matching attribute names\n       * to property names, using `attributeNameForProperty`. This map is\n       * used when deserializing attribute values to properties.\n       *\n       * @param {string} property Name of the property\n       * @override\n       */\n    }, {\n      key: \"_addPropertyToAttributeMap\",\n      value: function _addPropertyToAttributeMap(property) {\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n          this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n        }\n        // This check is technically not correct; it's an optimization that\n        // assumes that if a _property_ name is already in the map (note this is\n        // an attr->property map), the property mapped directly to the attribute\n        // and it has already been mapped.  This would fail if\n        // `attributeNameForProperty` were overridden such that this was not the\n        // case.\n        var attr = this.__dataAttributes[property];\n        if (!attr) {\n          attr = this.constructor.attributeNameForProperty(property);\n          this.__dataAttributes[attr] = property;\n        }\n        return attr;\n      }\n\n      /**\n       * Defines a property accessor for the given property.\n       * @param {string} property Name of the property\n       * @param {boolean=} readOnly When true, no setter is created\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_definePropertyAccessor\",\n      value: function _definePropertyAccessor(property, readOnly) {\n        Object.defineProperty(this, property, {\n          /* eslint-disable valid-jsdoc */\n          /** @this {PropertiesChanged} */\n          get: function get() {\n            // Inline for perf instead of using `_getProperty`\n            return this.__data[property];\n          },\n          /** @this {PropertiesChanged} */\n          set: readOnly ? function () {} : function (value) {\n            // Inline for perf instead of using `_setProperty`\n            if (this._setPendingProperty(property, value, true)) {\n              this._invalidateProperties();\n            }\n          }\n          /* eslint-enable */\n        });\n      }\n    }, {\n      key: \"ready\",\n      value: function ready() {\n        this.__dataReady = true;\n        this._flushProperties();\n      }\n\n      /**\n       * Initializes the local storage for property accessors.\n       *\n       * Provided as an override point for performing any setup work prior\n       * to initializing the property accessor system.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_initializeProperties\",\n      value: function _initializeProperties() {\n        // Capture instance properties; these will be set into accessors\n        // during first flush. Don't set them here, since we want\n        // these to overwrite defaults/constructor assignments\n        for (var p in this.__dataHasAccessor) {\n          if (this.hasOwnProperty(p)) {\n            this.__dataInstanceProps = this.__dataInstanceProps || {};\n            this.__dataInstanceProps[p] = this[p];\n            delete this[p];\n          }\n        }\n      }\n\n      /**\n       * Called at ready time with bag of instance properties that overwrote\n       * accessors when the element upgraded.\n       *\n       * The default implementation sets these properties back into the\n       * setter at ready time.  This method is provided as an override\n       * point for customizing or providing more efficient initialization.\n       *\n       * @param {Object} props Bag of property values that were overwritten\n       *   when creating property accessors.\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_initializeInstanceProperties\",\n      value: function _initializeInstanceProperties(props) {\n        Object.assign(this, props);\n      }\n\n      /**\n       * Updates the local storage for a property (via `_setPendingProperty`)\n       * and enqueues a `_proeprtiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_setProperty\",\n      value: function _setProperty(property, value) {\n        if (this._setPendingProperty(property, value)) {\n          this._invalidateProperties();\n        }\n      }\n\n      /**\n       * Returns the value for the given property.\n       * @param {string} property Name of property\n       * @return {*} Value for the given property\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_getProperty\",\n      value: function _getProperty(property) {\n        return this.__data[property];\n      }\n\n      /* eslint-disable no-unused-vars */\n      /**\n       * Updates the local storage for a property, records the previous value,\n       * and adds it to the set of \"pending changes\" that will be passed to the\n       * `_propertiesChanged` callback.  This method does not enqueue the\n       * `_propertiesChanged` callback.\n       *\n       * @param {string} property Name of the property\n       * @param {*} value Value to set\n       * @param {boolean=} ext Not used here; affordance for closure\n       * @return {boolean} Returns true if the property changed\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_setPendingProperty\",\n      value: function _setPendingProperty(property, value, ext) {\n        var old = this.__data[property];\n        var changed = this._shouldPropertyChange(property, value, old);\n        if (changed) {\n          if (!this.__dataPending) {\n            this.__dataPending = {};\n            this.__dataOld = {};\n          }\n          // Ensure old is captured from the last turn\n          if (this.__dataOld && !(property in this.__dataOld)) {\n            this.__dataOld[property] = old;\n          }\n          this.__data[property] = value;\n          this.__dataPending[property] = value;\n        }\n        return changed;\n      }\n      /* eslint-enable */\n\n      /**\n       * @param {string} property Name of the property\n       * @return {boolean} Returns true if the property is pending.\n       */\n    }, {\n      key: \"_isPropertyPending\",\n      value: function _isPropertyPending(property) {\n        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n      }\n\n      /**\n       * Marks the properties as invalid, and enqueues an async\n       * `_propertiesChanged` callback.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_invalidateProperties\",\n      value: function _invalidateProperties() {\n        var _this2 = this;\n        if (!this.__dataInvalid && this.__dataReady) {\n          this.__dataInvalid = true;\n          microtask.run(function () {\n            if (_this2.__dataInvalid) {\n              _this2.__dataInvalid = false;\n              _this2._flushProperties();\n            }\n          });\n        }\n      }\n\n      /**\n       * Call to enable property accessor processing. Before this method is\n       * called accessor values will be set but side effects are\n       * queued. When called, any pending side effects occur immediately.\n       * For elements, generally `connectedCallback` is a normal spot to do so.\n       * It is safe to call this method multiple times as it only turns on\n       * property accessors once.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_enableProperties\",\n      value: function _enableProperties() {\n        if (!this.__dataEnabled) {\n          this.__dataEnabled = true;\n          if (this.__dataInstanceProps) {\n            this._initializeInstanceProperties(this.__dataInstanceProps);\n            this.__dataInstanceProps = null;\n          }\n          this.ready();\n        }\n      }\n\n      /**\n       * Calls the `_propertiesChanged` callback with the current set of\n       * pending changes (and old values recorded when pending changes were\n       * set), and resets the pending set of changes. Generally, this method\n       * should not be called in user code.\n       *\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_flushProperties\",\n      value: function _flushProperties() {\n        this.__dataCounter++;\n        var props = this.__data;\n        var changedProps = this.__dataPending;\n        var old = this.__dataOld;\n        if (this._shouldPropertiesChange(props, changedProps, old)) {\n          this.__dataPending = null;\n          this.__dataOld = null;\n          this._propertiesChanged(props, changedProps, old);\n        }\n        this.__dataCounter--;\n      }\n\n      /**\n       * Called in `_flushProperties` to determine if `_propertiesChanged`\n       * should be called. The default implementation returns true if\n       * properties are pending. Override to customize when\n       * `_propertiesChanged` is called.\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {boolean} true if changedProps is truthy\n       * @override\n       */\n    }, {\n      key: \"_shouldPropertiesChange\",\n      value: function _shouldPropertiesChange(currentProps, changedProps, oldProps) {\n        // eslint-disable-line no-unused-vars\n        return Boolean(changedProps);\n      }\n\n      /**\n       * Callback called when any properties with accessors created via\n       * `_createPropertyAccessor` have been set.\n       *\n       * @param {!Object} currentProps Bag of all current accessor values\n       * @param {?Object} changedProps Bag of properties changed since the last\n       *   call to `_propertiesChanged`\n       * @param {?Object} oldProps Bag of previous values for each property\n       *   in `changedProps`\n       * @return {void}\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_propertiesChanged\",\n      value: function _propertiesChanged(currentProps, changedProps, oldProps) {// eslint-disable-line no-unused-vars\n      }\n\n      /**\n       * Method called to determine whether a property value should be\n       * considered as a change and cause the `_propertiesChanged` callback\n       * to be enqueued.\n       *\n       * The default implementation returns `true` if a strict equality\n       * check fails. The method always returns false for `NaN`.\n       *\n       * Override this method to e.g. provide stricter checking for\n       * Objects/Arrays when using immutable patterns.\n       *\n       * @param {string} property Property name\n       * @param {*} value New property value\n       * @param {*} old Previous property value\n       * @return {boolean} Whether the property should be considered a change\n       *   and enqueue a `_proeprtiesChanged` callback\n       * @protected\n       * @override\n       */\n    }, {\n      key: \"_shouldPropertyChange\",\n      value: function _shouldPropertyChange(property, value, old) {\n        return (\n          // Strict equality check\n          old !== value && (\n          // This ensures (old==NaN, value==NaN) always returns false\n          old === old || value === value)\n        );\n      }\n\n      /**\n       * Implements native Custom Elements `attributeChangedCallback` to\n       * set an attribute value to a property via `_attributeToProperty`.\n       *\n       * @param {string} name Name of attribute that changed\n       * @param {?string} old Old attribute value\n       * @param {?string} value New attribute value\n       * @param {?string} namespace Attribute namespace.\n       * @return {void}\n       * @suppress {missingProperties} Super may or may not implement the callback\n       * @override\n       */\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(name, old, value, namespace) {\n        if (old !== value) {\n          this._attributeToProperty(name, value);\n        }\n        if (_get(_getPrototypeOf(PropertiesChanged.prototype), \"attributeChangedCallback\", this)) {\n          _get(_getPrototypeOf(PropertiesChanged.prototype), \"attributeChangedCallback\", this).call(this, name, old, value, namespace);\n        }\n      }\n\n      /**\n       * Deserializes an attribute to its associated property.\n       *\n       * This method calls the `_deserializeValue` method to convert the string to\n       * a typed value.\n       *\n       * @param {string} attribute Name of attribute to deserialize.\n       * @param {?string} value of the attribute.\n       * @param {*=} type type to deserialize to, defaults to the value\n       * returned from `typeForProperty`\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_attributeToProperty\",\n      value: function _attributeToProperty(attribute, value, type) {\n        if (!this.__serializing) {\n          var map = this.__dataAttributes;\n          var property = map && map[attribute] || attribute;\n          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));\n        }\n      }\n\n      /**\n       * Serializes a property to its associated attribute.\n       *\n       * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n       *\n       * @param {string} property Property name to reflect.\n       * @param {string=} attribute Attribute name to reflect to.\n       * @param {*=} value Property value to refect.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_propertyToAttribute\",\n      value: function _propertyToAttribute(property, attribute, value) {\n        this.__serializing = true;\n        value = arguments.length < 3 ? this[property] : value;\n        this._valueToNodeAttribute( /** @type {!HTMLElement} */this, value, attribute || this.constructor.attributeNameForProperty(property));\n        this.__serializing = false;\n      }\n\n      /**\n       * Sets a typed value to an HTML attribute on a node.\n       *\n       * This method calls the `_serializeValue` method to convert the typed\n       * value to a string.  If the `_serializeValue` method returns `undefined`,\n       * the attribute will be removed (this is the default for boolean\n       * type `false`).\n       *\n       * @param {Element} node Element to set attribute to.\n       * @param {*} value Value to serialize.\n       * @param {string} attribute Attribute name to serialize to.\n       * @return {void}\n       * @override\n       */\n    }, {\n      key: \"_valueToNodeAttribute\",\n      value: function _valueToNodeAttribute(node, value, attribute) {\n        var str = this._serializeValue(value);\n        if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n          node = /** @type {?Element} */wrap(node);\n        }\n        if (str === undefined) {\n          node.removeAttribute(attribute);\n        } else {\n          node.setAttribute(attribute,\n          // Closure's type for `setAttribute`'s second parameter incorrectly\n          // excludes `TrustedScript`.\n          str === '' && window.trustedTypes ? ( /** @type {?} */window.trustedTypes.emptyScript) : str);\n        }\n      }\n\n      /**\n       * Converts a typed JavaScript value to a string.\n       *\n       * This method is called when setting JS property values to\n       * HTML attributes.  Users may override this method to provide\n       * serialization for custom types.\n       *\n       * @param {*} value Property value to serialize.\n       * @return {string | undefined} String serialized from the provided\n       * property  value.\n       * @override\n       */\n    }, {\n      key: \"_serializeValue\",\n      value: function _serializeValue(value) {\n        switch (_typeof(value)) {\n          case 'boolean':\n            return value ? '' : undefined;\n          default:\n            return value != null ? value.toString() : undefined;\n        }\n      }\n\n      /**\n       * Converts a string to a typed JavaScript value.\n       *\n       * This method is called when reading HTML attribute values to\n       * JS properties.  Users may override this method to provide\n       * deserialization for custom `type`s. Types for `Boolean`, `String`,\n       * and `Number` convert attributes to the expected types.\n       *\n       * @param {?string} value Value to deserialize.\n       * @param {*=} type Type to deserialize the string to.\n       * @return {*} Typed value deserialized from the provided string.\n       * @override\n       */\n    }, {\n      key: \"_deserializeValue\",\n      value: function _deserializeValue(value, type) {\n        switch (type) {\n          case Boolean:\n            return value !== null;\n          case Number:\n            return Number(value);\n          default:\n            return value;\n        }\n      }\n    }], [{\n      key: \"createProperties\",\n      value:\n      /**\n       * Creates property accessors for the given property names.\n       * @param {!Object} props Object whose keys are names of accessors.\n       * @return {void}\n       * @protected\n       * @nocollapse\n       */\n      function createProperties(props) {\n        var proto = this.prototype;\n        for (var prop in props) {\n          // don't stomp an existing accessor\n          if (!(prop in proto)) {\n            proto._createPropertyAccessor(prop);\n          }\n        }\n      }\n\n      /**\n       * Returns an attribute name that corresponds to the given property.\n       * The attribute name is the lowercased property name. Override to\n       * customize this mapping.\n       * @param {string} property Property to convert\n       * @return {string} Attribute name corresponding to the given property.\n       *\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"attributeNameForProperty\",\n      value: function attributeNameForProperty(property) {\n        return property.toLowerCase();\n      }\n\n      /**\n       * Override point to provide a type to which to deserialize a value to\n       * a given property.\n       * @param {string} name Name of property\n       *\n       * @protected\n       * @nocollapse\n       */\n    }, {\n      key: \"typeForProperty\",\n      value: function typeForProperty(name) {}\n    }]);\n    return PropertiesChanged;\n  }(superClass);\n  return PropertiesChanged;\n});","map":{"version":3,"names":["dedupingMixin","microTask","wrap","microtask","PropertiesChanged","superClass","_superClass","_inherits","_this","_classCallCheck","_callSuper","__dataEnabled","__dataReady","__dataInvalid","__data","__dataPending","__dataOld","__dataInstanceProps","__dataCounter","__serializing","_initializeProperties","_createClass","key","value","_createPropertyAccessor","property","readOnly","_addPropertyToAttributeMap","hasOwnProperty","JSCompiler_renameProperty","__dataHasAccessor","Object","assign","_definePropertyAccessor","__dataAttributes","attr","constructor","attributeNameForProperty","defineProperty","get","set","_setPendingProperty","_invalidateProperties","ready","_flushProperties","p","_initializeInstanceProperties","props","_setProperty","_getProperty","ext","old","changed","_shouldPropertyChange","_isPropertyPending","_this2","run","_enableProperties","changedProps","_shouldPropertiesChange","_propertiesChanged","currentProps","oldProps","Boolean","attributeChangedCallback","name","namespace","_attributeToProperty","_get","_getPrototypeOf","prototype","call","attribute","type","map","_deserializeValue","typeForProperty","_propertyToAttribute","arguments","length","_valueToNodeAttribute","node","str","_serializeValue","undefined","removeAttribute","setAttribute","window","trustedTypes","emptyScript","_typeof","toString","Number","createProperties","proto","prop","toLowerCase"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/mixins/properties-changed.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '../utils/boot.js';\n\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { microTask } from '../utils/async.js';\nimport { wrap } from '../utils/wrap.js';\n\n/** @const {!AsyncInterface} */\nconst microtask = microTask;\n\n/**\n * Element class mixin that provides basic meta-programming for creating one\n * or more property accessors (getter/setter pair) that enqueue an async\n * (batched) `_propertiesChanged` callback.\n *\n * For basic usage of this mixin, call `MyClass.createProperties(props)`\n * once at class definition time to create property accessors for properties\n * named in props, implement `_propertiesChanged` to react as desired to\n * property changes, and implement `static get observedAttributes()` and\n * include lowercase versions of any property names that should be set from\n * attributes. Last, call `this._enableProperties()` in the element's\n * `connectedCallback` to enable the accessors.\n *\n * @mixinFunction\n * @polymer\n * @summary Element class mixin for reacting to property changes from\n *   generated property accessors.\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const PropertiesChanged = dedupingMixin(\n    /**\n     * @template T\n     * @param {function(new:T)} superClass Class to apply mixin to.\n     * @return {function(new:T)} superClass with mixin applied.\n     */\n    (superClass) => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_PropertiesChanged}\n   * @unrestricted\n   */\n  class PropertiesChanged extends superClass {\n\n    /**\n     * Creates property accessors for the given property names.\n     * @param {!Object} props Object whose keys are names of accessors.\n     * @return {void}\n     * @protected\n     * @nocollapse\n     */\n    static createProperties(props) {\n      const proto = this.prototype;\n      for (let prop in props) {\n        // don't stomp an existing accessor\n        if (!(prop in proto)) {\n          proto._createPropertyAccessor(prop);\n        }\n      }\n    }\n\n    /**\n     * Returns an attribute name that corresponds to the given property.\n     * The attribute name is the lowercased property name. Override to\n     * customize this mapping.\n     * @param {string} property Property to convert\n     * @return {string} Attribute name corresponding to the given property.\n     *\n     * @protected\n     * @nocollapse\n     */\n    static attributeNameForProperty(property) {\n      return property.toLowerCase();\n    }\n\n    /**\n     * Override point to provide a type to which to deserialize a value to\n     * a given property.\n     * @param {string} name Name of property\n     *\n     * @protected\n     * @nocollapse\n     */\n    static typeForProperty(name) { } //eslint-disable-line no-unused-vars\n\n    /**\n     * Creates a setter/getter pair for the named property with its own\n     * local storage.  The getter returns the value in the local storage,\n     * and the setter calls `_setProperty`, which updates the local storage\n     * for the property and enqueues a `_propertiesChanged` callback.\n     *\n     * This method may be called on a prototype or an instance.  Calling\n     * this method may overwrite a property value that already exists on\n     * the prototype/instance by creating the accessor.\n     *\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created; the\n     *   protected `_setProperty` function must be used to set the property\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _createPropertyAccessor(property, readOnly) {\n      this._addPropertyToAttributeMap(property);\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataHasAccessor', this))) {\n        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);\n      }\n      if (!this.__dataHasAccessor[property]) {\n        this.__dataHasAccessor[property] = true;\n        this._definePropertyAccessor(property, readOnly);\n      }\n    }\n\n    /**\n     * Adds the given `property` to a map matching attribute names\n     * to property names, using `attributeNameForProperty`. This map is\n     * used when deserializing attribute values to properties.\n     *\n     * @param {string} property Name of the property\n     * @override\n     */\n    _addPropertyToAttributeMap(property) {\n      if (!this.hasOwnProperty(JSCompiler_renameProperty('__dataAttributes', this))) {\n        this.__dataAttributes = Object.assign({}, this.__dataAttributes);\n      }\n      // This check is technically not correct; it's an optimization that\n      // assumes that if a _property_ name is already in the map (note this is\n      // an attr->property map), the property mapped directly to the attribute\n      // and it has already been mapped.  This would fail if\n      // `attributeNameForProperty` were overridden such that this was not the\n      // case.\n      let attr = this.__dataAttributes[property];\n      if (!attr) {\n        attr = this.constructor.attributeNameForProperty(property);\n        this.__dataAttributes[attr] = property;\n      }\n      return attr;\n    }\n\n    /**\n     * Defines a property accessor for the given property.\n     * @param {string} property Name of the property\n     * @param {boolean=} readOnly When true, no setter is created\n     * @return {void}\n     * @override\n     */\n     _definePropertyAccessor(property, readOnly) {\n      Object.defineProperty(this, property, {\n        /* eslint-disable valid-jsdoc */\n        /** @this {PropertiesChanged} */\n        get() {\n          // Inline for perf instead of using `_getProperty`\n          return this.__data[property];\n        },\n        /** @this {PropertiesChanged} */\n        set: readOnly ? function () {} : function (value) {\n          // Inline for perf instead of using `_setProperty`\n          if (this._setPendingProperty(property, value, true)) {\n            this._invalidateProperties();\n          }\n        }\n        /* eslint-enable */\n      });\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.__dataEnabled = false;\n      this.__dataReady = false;\n      this.__dataInvalid = false;\n      this.__data = {};\n      this.__dataPending = null;\n      this.__dataOld = null;\n      this.__dataInstanceProps = null;\n      /** @type {number} */\n      // NOTE: used to track re-entrant calls to `_flushProperties`\n      this.__dataCounter = 0;\n      this.__serializing = false;\n      this._initializeProperties();\n    }\n\n    /**\n     * Lifecycle callback called when properties are enabled via\n     * `_enableProperties`.\n     *\n     * Users may override this function to implement behavior that is\n     * dependent on the element having its property data initialized, e.g.\n     * from defaults (initialized from `constructor`, `_initializeProperties`),\n     * `attributeChangedCallback`, or values propagated from host e.g. via\n     * bindings.  `super.ready()` must be called to ensure the data system\n     * becomes enabled.\n     *\n     * @return {void}\n     * @public\n     * @override\n     */\n    ready() {\n      this.__dataReady = true;\n      this._flushProperties();\n    }\n\n    /**\n     * Initializes the local storage for property accessors.\n     *\n     * Provided as an override point for performing any setup work prior\n     * to initializing the property accessor system.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeProperties() {\n      // Capture instance properties; these will be set into accessors\n      // during first flush. Don't set them here, since we want\n      // these to overwrite defaults/constructor assignments\n      for (let p in this.__dataHasAccessor) {\n        if (this.hasOwnProperty(p)) {\n          this.__dataInstanceProps = this.__dataInstanceProps || {};\n          this.__dataInstanceProps[p] = this[p];\n          delete this[p];\n        }\n      }\n    }\n\n    /**\n     * Called at ready time with bag of instance properties that overwrote\n     * accessors when the element upgraded.\n     *\n     * The default implementation sets these properties back into the\n     * setter at ready time.  This method is provided as an override\n     * point for customizing or providing more efficient initialization.\n     *\n     * @param {Object} props Bag of property values that were overwritten\n     *   when creating property accessors.\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _initializeInstanceProperties(props) {\n      Object.assign(this, props);\n    }\n\n    /**\n     * Updates the local storage for a property (via `_setPendingProperty`)\n     * and enqueues a `_proeprtiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _setProperty(property, value) {\n      if (this._setPendingProperty(property, value)) {\n        this._invalidateProperties();\n      }\n    }\n\n    /**\n     * Returns the value for the given property.\n     * @param {string} property Name of property\n     * @return {*} Value for the given property\n     * @protected\n     * @override\n     */\n    _getProperty(property) {\n      return this.__data[property];\n    }\n\n    /* eslint-disable no-unused-vars */\n    /**\n     * Updates the local storage for a property, records the previous value,\n     * and adds it to the set of \"pending changes\" that will be passed to the\n     * `_propertiesChanged` callback.  This method does not enqueue the\n     * `_propertiesChanged` callback.\n     *\n     * @param {string} property Name of the property\n     * @param {*} value Value to set\n     * @param {boolean=} ext Not used here; affordance for closure\n     * @return {boolean} Returns true if the property changed\n     * @protected\n     * @override\n     */\n    _setPendingProperty(property, value, ext) {\n      let old = this.__data[property];\n      let changed = this._shouldPropertyChange(property, value, old);\n      if (changed) {\n        if (!this.__dataPending) {\n          this.__dataPending = {};\n          this.__dataOld = {};\n        }\n        // Ensure old is captured from the last turn\n        if (this.__dataOld && !(property in this.__dataOld)) {\n          this.__dataOld[property] = old;\n        }\n        this.__data[property] = value;\n        this.__dataPending[property] = value;\n      }\n      return changed;\n    }\n    /* eslint-enable */\n\n    /**\n     * @param {string} property Name of the property\n     * @return {boolean} Returns true if the property is pending.\n     */\n    _isPropertyPending(property) {\n      return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));\n    }\n\n    /**\n     * Marks the properties as invalid, and enqueues an async\n     * `_propertiesChanged` callback.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _invalidateProperties() {\n      if (!this.__dataInvalid && this.__dataReady) {\n        this.__dataInvalid = true;\n        microtask.run(() => {\n          if (this.__dataInvalid) {\n            this.__dataInvalid = false;\n            this._flushProperties();\n          }\n        });\n      }\n    }\n\n    /**\n     * Call to enable property accessor processing. Before this method is\n     * called accessor values will be set but side effects are\n     * queued. When called, any pending side effects occur immediately.\n     * For elements, generally `connectedCallback` is a normal spot to do so.\n     * It is safe to call this method multiple times as it only turns on\n     * property accessors once.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _enableProperties() {\n      if (!this.__dataEnabled) {\n        this.__dataEnabled = true;\n        if (this.__dataInstanceProps) {\n          this._initializeInstanceProperties(this.__dataInstanceProps);\n          this.__dataInstanceProps = null;\n        }\n        this.ready();\n      }\n    }\n\n    /**\n     * Calls the `_propertiesChanged` callback with the current set of\n     * pending changes (and old values recorded when pending changes were\n     * set), and resets the pending set of changes. Generally, this method\n     * should not be called in user code.\n     *\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _flushProperties() {\n      this.__dataCounter++;\n      const props = this.__data;\n      const changedProps = this.__dataPending;\n      const old = this.__dataOld;\n      if (this._shouldPropertiesChange(props, changedProps, old)) {\n        this.__dataPending = null;\n        this.__dataOld = null;\n        this._propertiesChanged(props, changedProps, old);\n      }\n      this.__dataCounter--;\n    }\n\n    /**\n     * Called in `_flushProperties` to determine if `_propertiesChanged`\n     * should be called. The default implementation returns true if\n     * properties are pending. Override to customize when\n     * `_propertiesChanged` is called.\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {boolean} true if changedProps is truthy\n     * @override\n     */\n    _shouldPropertiesChange(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n      return Boolean(changedProps);\n    }\n\n    /**\n     * Callback called when any properties with accessors created via\n     * `_createPropertyAccessor` have been set.\n     *\n     * @param {!Object} currentProps Bag of all current accessor values\n     * @param {?Object} changedProps Bag of properties changed since the last\n     *   call to `_propertiesChanged`\n     * @param {?Object} oldProps Bag of previous values for each property\n     *   in `changedProps`\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars\n    }\n\n    /**\n     * Method called to determine whether a property value should be\n     * considered as a change and cause the `_propertiesChanged` callback\n     * to be enqueued.\n     *\n     * The default implementation returns `true` if a strict equality\n     * check fails. The method always returns false for `NaN`.\n     *\n     * Override this method to e.g. provide stricter checking for\n     * Objects/Arrays when using immutable patterns.\n     *\n     * @param {string} property Property name\n     * @param {*} value New property value\n     * @param {*} old Previous property value\n     * @return {boolean} Whether the property should be considered a change\n     *   and enqueue a `_proeprtiesChanged` callback\n     * @protected\n     * @override\n     */\n    _shouldPropertyChange(property, value, old) {\n      return (\n        // Strict equality check\n        (old !== value &&\n          // This ensures (old==NaN, value==NaN) always returns false\n          (old === old || value === value))\n      );\n    }\n\n    /**\n     * Implements native Custom Elements `attributeChangedCallback` to\n     * set an attribute value to a property via `_attributeToProperty`.\n     *\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @suppress {missingProperties} Super may or may not implement the callback\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        this._attributeToProperty(name, value);\n      }\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(name, old, value, namespace);\n      }\n    }\n\n    /**\n     * Deserializes an attribute to its associated property.\n     *\n     * This method calls the `_deserializeValue` method to convert the string to\n     * a typed value.\n     *\n     * @param {string} attribute Name of attribute to deserialize.\n     * @param {?string} value of the attribute.\n     * @param {*=} type type to deserialize to, defaults to the value\n     * returned from `typeForProperty`\n     * @return {void}\n     * @override\n     */\n    _attributeToProperty(attribute, value, type) {\n      if (!this.__serializing) {\n        const map = this.__dataAttributes;\n        const property = map && map[attribute] || attribute;\n        this[property] = this._deserializeValue(value, type ||\n          this.constructor.typeForProperty(property));\n      }\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * @suppress {invalidCasts} Closure can't figure out `this` is an element.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect to.\n     * @param {*=} value Property value to refect.\n     * @return {void}\n     * @override\n     */\n    _propertyToAttribute(property, attribute, value) {\n      this.__serializing = true;\n      value = (arguments.length < 3) ? this[property] : value;\n      this._valueToNodeAttribute(/** @type {!HTMLElement} */(this), value,\n        attribute || this.constructor.attributeNameForProperty(property));\n      this.__serializing = false;\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * This method calls the `_serializeValue` method to convert the typed\n     * value to a string.  If the `_serializeValue` method returns `undefined`,\n     * the attribute will be removed (this is the default for boolean\n     * type `false`).\n     *\n     * @param {Element} node Element to set attribute to.\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @return {void}\n     * @override\n     */\n    _valueToNodeAttribute(node, value, attribute) {\n      const str = this._serializeValue(value);\n      if (attribute === 'class' || attribute === 'name' || attribute === 'slot') {\n        node = /** @type {?Element} */(wrap(node));\n      }\n      if (str === undefined) {\n        node.removeAttribute(attribute);\n      } else {\n        node.setAttribute(\n            attribute,\n            // Closure's type for `setAttribute`'s second parameter incorrectly\n            // excludes `TrustedScript`.\n            (str === '' && window.trustedTypes) ?\n                /** @type {?} */ (window.trustedTypes.emptyScript) :\n                str);\n      }\n    }\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * This method is called when setting JS property values to\n     * HTML attributes.  Users may override this method to provide\n     * serialization for custom types.\n     *\n     * @param {*} value Property value to serialize.\n     * @return {string | undefined} String serialized from the provided\n     * property  value.\n     * @override\n     */\n    _serializeValue(value) {\n      switch (typeof value) {\n        case 'boolean':\n          return value ? '' : undefined;\n        default:\n          return value != null ? value.toString() : undefined;\n      }\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * This method is called when reading HTML attribute values to\n     * JS properties.  Users may override this method to provide\n     * deserialization for custom `type`s. Types for `Boolean`, `String`,\n     * and `Number` convert attributes to the expected types.\n     *\n     * @param {?string} value Value to deserialize.\n     * @param {*=} type Type to deserialize the string to.\n     * @return {*} Typed value deserialized from the provided string.\n     * @override\n     */\n    _deserializeValue(value, type) {\n      switch (type) {\n        case Boolean:\n          return (value !== null);\n        case Number:\n          return Number(value);\n        default:\n          return value;\n      }\n    }\n\n  }\n\n  return PropertiesChanged;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}