{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.object.assign.js\";\nimport { getCollection } from \"home-assistant-js-websocket\";\n/**\n * Create an optimistic collection that includes a save function.\n * When the collection is saved, the collection is optimistically updated.\n * The update is reversed when the update failed.\n */\n\nexport var getOptimisticCollection = function getOptimisticCollection(saveCollection, conn, key, fetchCollection, subscribeUpdates) {\n  var updateKey = \"\".concat(key, \"-optimistic\");\n  var collection = getCollection(conn, key, fetchCollection, /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_conn, store) {\n      var subUpResult;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            // Subscribe to original updates\n            subUpResult = subscribeUpdates ? subscribeUpdates(conn, store) : undefined; // Store the store\n            conn[updateKey] = store;\n\n            // Unsub function to undo both\n            return _context.abrupt(\"return\", function () {\n              if (subUpResult) {\n                subUpResult.then(function (unsub) {\n                  return unsub();\n                });\n              }\n              conn[updateKey] = undefined;\n            });\n          case 3:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  return Object.assign(Object.assign({}, collection), {}, {\n    save: function save(data) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var store, current;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              store = conn[updateKey];\n              // Can be undefined if currently no subscribers\n              if (store) {\n                current = store.state;\n                store.setState(data, true);\n              }\n              _context2.prev = 2;\n              _context2.next = 5;\n              return saveCollection(conn, data);\n            case 5:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 8:\n              _context2.prev = 8;\n              _context2.t0 = _context2[\"catch\"](2);\n              if (store) {\n                store.setState(current, true);\n              }\n              throw _context2.t0;\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[2, 8]]);\n      }))();\n    }\n  });\n};","map":{"version":3,"names":["getCollection","getOptimisticCollection","saveCollection","conn","key","fetchCollection","subscribeUpdates","updateKey","concat","collection","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_conn","store","subUpResult","wrap","_callee$","_context","prev","next","undefined","abrupt","then","unsub","stop","_x","_x2","apply","arguments","Object","assign","save","data","_callee2","current","_callee2$","_context2","state","setState","sent","t0"],"sources":["/workspaces/frontend/src/data/collection.ts"],"sourcesContent":["import {\n  Collection,\n  Connection,\n  getCollection,\n  UnsubscribeFunc,\n} from \"home-assistant-js-websocket\";\nimport { Store } from \"home-assistant-js-websocket/dist/store\";\n\ninterface OptimisticCollection<T> extends Collection<T> {\n  save(data: T): Promise<unknown>;\n}\n\n/**\n * Create an optimistic collection that includes a save function.\n * When the collection is saved, the collection is optimistically updated.\n * The update is reversed when the update failed.\n */\n\nexport const getOptimisticCollection = <StateType>(\n  saveCollection: (conn2: Connection, data: StateType) => Promise<unknown>,\n  conn: Connection,\n  key: string,\n  fetchCollection: (conn2: Connection) => Promise<StateType>,\n  subscribeUpdates?: (\n    conn2: Connection,\n    store: Store<StateType>\n  ) => Promise<UnsubscribeFunc>\n): OptimisticCollection<StateType> => {\n  const updateKey = `${key}-optimistic`;\n\n  const collection = getCollection<StateType>(\n    conn,\n    key,\n    fetchCollection,\n    async (_conn, store) => {\n      // Subscribe to original updates\n      const subUpResult = subscribeUpdates\n        ? subscribeUpdates(conn, store)\n        : undefined;\n      // Store the store\n      conn[updateKey] = store;\n\n      // Unsub function to undo both\n      return () => {\n        if (subUpResult) {\n          subUpResult.then((unsub) => unsub());\n        }\n        conn[updateKey] = undefined;\n      };\n    }\n  );\n  return {\n    ...collection,\n    async save(data: StateType) {\n      const store: Store<StateType> | undefined = conn[updateKey];\n      let current;\n\n      // Can be undefined if currently no subscribers\n      if (store) {\n        current = store.state;\n        store.setState(data, true);\n      }\n\n      try {\n        return await saveCollection(conn, data);\n      } catch (err: any) {\n        if (store) {\n          store.setState(current as any, true);\n        }\n        throw err;\n      }\n    },\n  };\n};\n"],"mappings":";;;AAAA,SAGEA,aAAa,QAER,6BAA6B;AAOpC;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMC,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAClCC,cAAwE,EACxEC,IAAgB,EAChBC,GAAW,EACXC,eAA0D,EAC1DC,gBAG6B,EACO;EACpC,IAAMC,SAAS,MAAAC,MAAA,CAAMJ,GAAG,gBAAa;EAErC,IAAMK,UAAU,GAAGT,aAAa,CAC9BG,IAAI,EACJC,GAAG,EACHC,eAAe;IAAA,IAAAK,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CACf,SAAAC,QAAOC,KAAK,EAAEC,KAAK;MAAA,IAAAC,WAAA;MAAA,OAAAL,mBAAA,GAAAM,IAAA,UAAAC,SAAAC,QAAA;QAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YACjB;YACML,WAAW,GAAGX,gBAAgB,GAChCA,gBAAgB,CAACH,IAAI,EAAEa,KAAK,CAAC,GAC7BO,SAAS,EACb;YACApB,IAAI,CAACI,SAAS,CAAC,GAAGS,KAAK;;YAEvB;YAAA,OAAAI,QAAA,CAAAI,MAAA,WACO,YAAM;cACX,IAAIP,WAAW,EAAE;gBACfA,WAAW,CAACQ,IAAI,CAAC,UAACC,KAAK;kBAAA,OAAKA,KAAK,CAAC,CAAC;gBAAA,EAAC;cACtC;cACAvB,IAAI,CAACI,SAAS,CAAC,GAAGgB,SAAS;YAC7B,CAAC;UAAA;UAAA;YAAA,OAAAH,QAAA,CAAAO,IAAA;QAAA;MAAA,GAAAb,OAAA;IAAA,CACF;IAAA,iBAAAc,EAAA,EAAAC,GAAA;MAAA,OAAAnB,IAAA,CAAAoB,KAAA,OAAAC,SAAA;IAAA;EAAA,GACH,CAAC;EACD,OAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KACKxB,UAAU;IACPyB,IAAI,WAAAA,KAACC,IAAe,EAAE;MAAA,OAAAxB,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,UAAAuB,SAAA;QAAA,IAAApB,KAAA,EAAAqB,OAAA;QAAA,OAAAzB,mBAAA,GAAAM,IAAA,UAAAoB,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAlB,IAAA,GAAAkB,SAAA,CAAAjB,IAAA;YAAA;cACpBN,KAAmC,GAAGb,IAAI,CAACI,SAAS,CAAC;cAG3D;cACA,IAAIS,KAAK,EAAE;gBACTqB,OAAO,GAAGrB,KAAK,CAACwB,KAAK;gBACrBxB,KAAK,CAACyB,QAAQ,CAACN,IAAI,EAAE,IAAI,CAAC;cAC5B;cAACI,SAAA,CAAAlB,IAAA;cAAAkB,SAAA,CAAAjB,IAAA;cAAA,OAGcpB,cAAc,CAACC,IAAI,EAAEgC,IAAI,CAAC;YAAA;cAAA,OAAAI,SAAA,CAAAf,MAAA,WAAAe,SAAA,CAAAG,IAAA;YAAA;cAAAH,SAAA,CAAAlB,IAAA;cAAAkB,SAAA,CAAAI,EAAA,GAAAJ,SAAA;cAEvC,IAAIvB,KAAK,EAAE;gBACTA,KAAK,CAACyB,QAAQ,CAACJ,OAAO,EAAS,IAAI,CAAC;cACtC;cAAC,MAAAE,SAAA,CAAAI,EAAA;YAAA;YAAA;cAAA,OAAAJ,SAAA,CAAAZ,IAAA;UAAA;QAAA,GAAAS,QAAA;MAAA;IAGL;EAAC;AAEL,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}