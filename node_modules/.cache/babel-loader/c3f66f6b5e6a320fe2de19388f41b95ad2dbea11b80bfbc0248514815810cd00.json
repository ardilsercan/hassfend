{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nvar UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nvar DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport var getCollection = function getCollection(conn, key, fetchCollection, subscribeUpdates) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    unsubGrace: true\n  };\n  if (conn[key]) {\n    return conn[key];\n  }\n  var active = 0;\n  var unsubProm;\n  var unsubTimer;\n  var store = createStore();\n  var refresh = function refresh() {\n    if (!fetchCollection) {\n      throw new Error(\"Collection does not support refresh\");\n    }\n    return fetchCollection(conn).then(function (state) {\n      return store.setState(state, true);\n    });\n  };\n  var refreshSwallow = function refreshSwallow() {\n    return refresh().catch(function (err) {\n      // Swallow errors if socket is connecting, closing or closed.\n      // We will automatically call refresh again when we re-establish the connection.\n      if (conn.connected) {\n        throw err;\n      }\n    });\n  };\n  var setupUpdateSubscription = function setupUpdateSubscription() {\n    if (unsubTimer !== undefined) {\n      if (DEBUG) {\n        console.log(\"Prevented unsubscribe for \".concat(key));\n      }\n      clearTimeout(unsubTimer);\n      unsubTimer = undefined;\n      return;\n    }\n    if (DEBUG) {\n      console.log(\"Subscribing to \".concat(key));\n    }\n    if (subscribeUpdates) {\n      unsubProm = subscribeUpdates(conn, store);\n    }\n    if (fetchCollection) {\n      // Fetch when connection re-established.\n      conn.addEventListener(\"ready\", refreshSwallow);\n      refreshSwallow();\n    }\n    conn.addEventListener(\"disconnected\", handleDisconnect);\n  };\n  var teardownUpdateSubscription = function teardownUpdateSubscription() {\n    if (DEBUG) {\n      console.log(\"Unsubscribing from \".concat(key));\n    }\n    unsubTimer = undefined;\n    // Unsubscribe from changes\n    if (unsubProm) unsubProm.then(function (unsub) {\n      unsub();\n    });\n    store.clearState();\n    conn.removeEventListener(\"ready\", refresh);\n    conn.removeEventListener(\"disconnected\", handleDisconnect);\n  };\n  var scheduleTeardownUpdateSubscription = function scheduleTeardownUpdateSubscription() {\n    if (DEBUG) {\n      console.log(\"Scheduling unsubscribing from \".concat(key));\n    }\n    unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n  };\n  var handleDisconnect = function handleDisconnect() {\n    // If we're going to unsubscribe and then lose connection,\n    // just unsubscribe immediately.\n    if (unsubTimer) {\n      clearTimeout(unsubTimer);\n      teardownUpdateSubscription();\n    }\n  };\n  conn[key] = {\n    get state() {\n      return store.state;\n    },\n    refresh: refresh,\n    subscribe: function subscribe(subscriber) {\n      active++;\n      if (DEBUG) {\n        console.log(\"New subscriber for \".concat(key, \". Active subscribers: \").concat(active));\n      }\n      // If this was the first subscriber, attach collection\n      if (active === 1) {\n        setupUpdateSubscription();\n      }\n      var unsub = store.subscribe(subscriber);\n      if (store.state !== undefined) {\n        // Don't call it right away so that caller has time\n        // to initialize all the things.\n        setTimeout(function () {\n          return subscriber(store.state);\n        }, 0);\n      }\n      return function () {\n        unsub();\n        active--;\n        if (DEBUG) {\n          console.log(\"Unsubscribe for \".concat(key, \". Active subscribers: \").concat(active));\n        }\n        if (!active) {\n          options.unsubGrace ? scheduleTeardownUpdateSubscription() : teardownUpdateSubscription();\n        }\n      };\n    }\n  };\n  return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport var createCollection = function createCollection(key, fetchCollection, subscribeUpdates, conn, onChange) {\n  return getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n};","map":{"version":3,"names":["createStore","UNSUB_GRACE_PERIOD","DEBUG","getCollection","conn","key","fetchCollection","subscribeUpdates","options","arguments","length","undefined","unsubGrace","active","unsubProm","unsubTimer","store","refresh","Error","then","state","setState","refreshSwallow","catch","err","connected","setupUpdateSubscription","console","log","concat","clearTimeout","addEventListener","handleDisconnect","teardownUpdateSubscription","unsub","clearState","removeEventListener","scheduleTeardownUpdateSubscription","setTimeout","subscribe","subscriber","createCollection","onChange"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    if (conn[key]) {\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"mappings":";;AAAA,SAASA,WAAW,QAAQ,YAAY;AACxC;AACA,IAAMC,kBAAkB,GAAG,IAAI,CAAC,CAAC;AACjC,IAAMC,KAAK,GAAG,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAIC,IAAI,EAAEC,GAAG,EAAEC,eAAe,EAAEC,gBAAgB,EAAqC;EAAA,IAAnCC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG;IAAEG,UAAU,EAAE;EAAK,CAAC;EACtG,IAAIR,IAAI,CAACC,GAAG,CAAC,EAAE;IACX,OAAOD,IAAI,CAACC,GAAG,CAAC;EACpB;EACA,IAAIQ,MAAM,GAAG,CAAC;EACd,IAAIC,SAAS;EACb,IAAIC,UAAU;EACd,IAAIC,KAAK,GAAGhB,WAAW,CAAC,CAAC;EACzB,IAAMiB,OAAO,GAAG,SAAVA,OAAOA,CAAA,EAAS;IAClB,IAAI,CAACX,eAAe,EAAE;MAClB,MAAM,IAAIY,KAAK,CAAC,qCAAqC,CAAC;IAC1D;IACA,OAAOZ,eAAe,CAACF,IAAI,CAAC,CAACe,IAAI,CAAC,UAACC,KAAK;MAAA,OAAKJ,KAAK,CAACK,QAAQ,CAACD,KAAK,EAAE,IAAI,CAAC;IAAA,EAAC;EAC7E,CAAC;EACD,IAAME,cAAc,GAAG,SAAjBA,cAAcA,CAAA;IAAA,OAASL,OAAO,CAAC,CAAC,CAACM,KAAK,CAAC,UAACC,GAAG,EAAK;MAClD;MACA;MACA,IAAIpB,IAAI,CAACqB,SAAS,EAAE;QAChB,MAAMD,GAAG;MACb;IACJ,CAAC,CAAC;EAAA;EACF,IAAME,uBAAuB,GAAG,SAA1BA,uBAAuBA,CAAA,EAAS;IAClC,IAAIX,UAAU,KAAKJ,SAAS,EAAE;MAC1B,IAAIT,KAAK,EAAE;QACPyB,OAAO,CAACC,GAAG,8BAAAC,MAAA,CAA8BxB,GAAG,CAAE,CAAC;MACnD;MACAyB,YAAY,CAACf,UAAU,CAAC;MACxBA,UAAU,GAAGJ,SAAS;MACtB;IACJ;IACA,IAAIT,KAAK,EAAE;MACPyB,OAAO,CAACC,GAAG,mBAAAC,MAAA,CAAmBxB,GAAG,CAAE,CAAC;IACxC;IACA,IAAIE,gBAAgB,EAAE;MAClBO,SAAS,GAAGP,gBAAgB,CAACH,IAAI,EAAEY,KAAK,CAAC;IAC7C;IACA,IAAIV,eAAe,EAAE;MACjB;MACAF,IAAI,CAAC2B,gBAAgB,CAAC,OAAO,EAAET,cAAc,CAAC;MAC9CA,cAAc,CAAC,CAAC;IACpB;IACAlB,IAAI,CAAC2B,gBAAgB,CAAC,cAAc,EAAEC,gBAAgB,CAAC;EAC3D,CAAC;EACD,IAAMC,0BAA0B,GAAG,SAA7BA,0BAA0BA,CAAA,EAAS;IACrC,IAAI/B,KAAK,EAAE;MACPyB,OAAO,CAACC,GAAG,uBAAAC,MAAA,CAAuBxB,GAAG,CAAE,CAAC;IAC5C;IACAU,UAAU,GAAGJ,SAAS;IACtB;IACA,IAAIG,SAAS,EACTA,SAAS,CAACK,IAAI,CAAC,UAACe,KAAK,EAAK;MACtBA,KAAK,CAAC,CAAC;IACX,CAAC,CAAC;IACNlB,KAAK,CAACmB,UAAU,CAAC,CAAC;IAClB/B,IAAI,CAACgC,mBAAmB,CAAC,OAAO,EAAEnB,OAAO,CAAC;IAC1Cb,IAAI,CAACgC,mBAAmB,CAAC,cAAc,EAAEJ,gBAAgB,CAAC;EAC9D,CAAC;EACD,IAAMK,kCAAkC,GAAG,SAArCA,kCAAkCA,CAAA,EAAS;IAC7C,IAAInC,KAAK,EAAE;MACPyB,OAAO,CAACC,GAAG,kCAAAC,MAAA,CAAkCxB,GAAG,CAAE,CAAC;IACvD;IACAU,UAAU,GAAGuB,UAAU,CAACL,0BAA0B,EAAEhC,kBAAkB,CAAC;EAC3E,CAAC;EACD,IAAM+B,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAA,EAAS;IAC3B;IACA;IACA,IAAIjB,UAAU,EAAE;MACZe,YAAY,CAACf,UAAU,CAAC;MACxBkB,0BAA0B,CAAC,CAAC;IAChC;EACJ,CAAC;EACD7B,IAAI,CAACC,GAAG,CAAC,GAAG;IACR,IAAIe,KAAKA,CAAA,EAAG;MACR,OAAOJ,KAAK,CAACI,KAAK;IACtB,CAAC;IACDH,OAAO,EAAPA,OAAO;IACPsB,SAAS,WAAAA,UAACC,UAAU,EAAE;MAClB3B,MAAM,EAAE;MACR,IAAIX,KAAK,EAAE;QACPyB,OAAO,CAACC,GAAG,uBAAAC,MAAA,CAAuBxB,GAAG,4BAAAwB,MAAA,CAAyBhB,MAAM,CAAE,CAAC;MAC3E;MACA;MACA,IAAIA,MAAM,KAAK,CAAC,EAAE;QACda,uBAAuB,CAAC,CAAC;MAC7B;MACA,IAAMQ,KAAK,GAAGlB,KAAK,CAACuB,SAAS,CAACC,UAAU,CAAC;MACzC,IAAIxB,KAAK,CAACI,KAAK,KAAKT,SAAS,EAAE;QAC3B;QACA;QACA2B,UAAU,CAAC;UAAA,OAAME,UAAU,CAACxB,KAAK,CAACI,KAAK,CAAC;QAAA,GAAE,CAAC,CAAC;MAChD;MACA,OAAO,YAAM;QACTc,KAAK,CAAC,CAAC;QACPrB,MAAM,EAAE;QACR,IAAIX,KAAK,EAAE;UACPyB,OAAO,CAACC,GAAG,oBAAAC,MAAA,CAAoBxB,GAAG,4BAAAwB,MAAA,CAAyBhB,MAAM,CAAE,CAAC;QACxE;QACA,IAAI,CAACA,MAAM,EAAE;UACTL,OAAO,CAACI,UAAU,GACZyB,kCAAkC,CAAC,CAAC,GACpCJ,0BAA0B,CAAC,CAAC;QACtC;MACJ,CAAC;IACL;EACJ,CAAC;EACD,OAAO7B,IAAI,CAACC,GAAG,CAAC;AACpB,CAAC;AACD;AACA,OAAO,IAAMoC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIpC,GAAG,EAAEC,eAAe,EAAEC,gBAAgB,EAAEH,IAAI,EAAEsC,QAAQ;EAAA,OAAKvC,aAAa,CAACC,IAAI,EAAEC,GAAG,EAAEC,eAAe,EAAEC,gBAAgB,CAAC,CAACgC,SAAS,CAACG,QAAQ,CAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}