{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n(() => {\n  var _a, _b, _c;\n  /* Symbols for private properties */\n  const _blockingElements = Symbol();\n  const _alreadyInertElements = Symbol();\n  const _topElParents = Symbol();\n  const _siblingsToRestore = Symbol();\n  const _parentMO = Symbol();\n  /* Symbols for private static methods */\n  const _topChanged = Symbol();\n  const _swapInertedSibling = Symbol();\n  const _inertSiblings = Symbol();\n  const _restoreInertedSiblings = Symbol();\n  const _getParents = Symbol();\n  const _getDistributedChildren = Symbol();\n  const _isInertable = Symbol();\n  const _handleMutations = Symbol();\n  class BlockingElementsImpl {\n    constructor() {\n      /**\n       * The blocking elements.\n       */\n      this[_a] = [];\n      /**\n       * Used to keep track of the parents of the top element, from the element\n       * itself up to body. When top changes, the old top might have been removed\n       * from the document, so we need to memoize the inerted parents' siblings\n       * in order to restore their inerteness when top changes.\n       */\n      this[_b] = [];\n      /**\n       * Elements that are already inert before the first blocking element is\n       * pushed.\n       */\n      this[_c] = new Set();\n    }\n    destructor() {\n      // Restore original inertness.\n      this[_restoreInertedSiblings](this[_topElParents]);\n      // Note we don't want to make these properties nullable on the class,\n      // since then we'd need non-null casts in many places. Calling a method on\n      // a BlockingElements instance after calling destructor will result in an\n      // exception.\n      const nullable = this;\n      nullable[_blockingElements] = null;\n      nullable[_topElParents] = null;\n      nullable[_alreadyInertElements] = null;\n    }\n    get top() {\n      const elems = this[_blockingElements];\n      return elems[elems.length - 1] || null;\n    }\n    push(element) {\n      if (!element || element === this.top) {\n        return;\n      }\n      // Remove it from the stack, we'll bring it to the top.\n      this.remove(element);\n      this[_topChanged](element);\n      this[_blockingElements].push(element);\n    }\n    remove(element) {\n      const i = this[_blockingElements].indexOf(element);\n      if (i === -1) {\n        return false;\n      }\n      this[_blockingElements].splice(i, 1);\n      // Top changed only if the removed element was the top element.\n      if (i === this[_blockingElements].length) {\n        this[_topChanged](this.top);\n      }\n      return true;\n    }\n    pop() {\n      const top = this.top;\n      top && this.remove(top);\n      return top;\n    }\n    has(element) {\n      return this[_blockingElements].indexOf(element) !== -1;\n    }\n    /**\n     * Sets `inert` to all document elements except the new top element, its\n     * parents, and its distributed content.\n     */\n    [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {\n      const toKeepInert = this[_alreadyInertElements];\n      const oldParents = this[_topElParents];\n      // No new top, reset old top if any.\n      if (!newTop) {\n        this[_restoreInertedSiblings](oldParents);\n        toKeepInert.clear();\n        this[_topElParents] = [];\n        return;\n      }\n      const newParents = this[_getParents](newTop);\n      // New top is not contained in the main document!\n      if (newParents[newParents.length - 1].parentNode !== document.body) {\n        throw Error('Non-connected element cannot be a blocking element');\n      }\n      // Cast here because we know we'll call _inertSiblings on newParents\n      // below.\n      this[_topElParents] = newParents;\n      const toSkip = this[_getDistributedChildren](newTop);\n      // No previous top element.\n      if (!oldParents.length) {\n        this[_inertSiblings](newParents, toSkip, toKeepInert);\n        return;\n      }\n      let i = oldParents.length - 1;\n      let j = newParents.length - 1;\n      // Find common parent. Index 0 is the element itself (so stop before it).\n      while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {\n        i--;\n        j--;\n      }\n      // If up the parents tree there are 2 elements that are siblings, swap\n      // the inerted sibling.\n      if (oldParents[i] !== newParents[j]) {\n        this[_swapInertedSibling](oldParents[i], newParents[j]);\n      }\n      // Restore old parents siblings inertness.\n      i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));\n      // Make new parents siblings inert.\n      j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);\n    }\n    /**\n     * Swaps inertness between two sibling elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_swapInertedSibling](oldInert, newInert) {\n      const siblingsToRestore = oldInert[_siblingsToRestore];\n      // oldInert is not contained in siblings to restore, so we have to check\n      // if it's inertable and if already inert.\n      if (this[_isInertable](oldInert) && !oldInert.inert) {\n        oldInert.inert = true;\n        siblingsToRestore.add(oldInert);\n      }\n      // If newInert was already between the siblings to restore, it means it is\n      // inertable and must be restored.\n      if (siblingsToRestore.has(newInert)) {\n        newInert.inert = false;\n        siblingsToRestore.delete(newInert);\n      }\n      newInert[_parentMO] = oldInert[_parentMO];\n      newInert[_siblingsToRestore] = siblingsToRestore;\n      oldInert[_parentMO] = undefined;\n      oldInert[_siblingsToRestore] = undefined;\n    }\n    /**\n     * Restores original inertness to the siblings of the elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_restoreInertedSiblings](elements) {\n      for (const element of elements) {\n        const mo = element[_parentMO];\n        mo.disconnect();\n        element[_parentMO] = undefined;\n        const siblings = element[_siblingsToRestore];\n        for (const sibling of siblings) {\n          sibling.inert = false;\n        }\n        element[_siblingsToRestore] = undefined;\n      }\n    }\n    /**\n     * Inerts the siblings of the elements except the elements to skip. Stores\n     * the inerted siblings into the element's symbol `_siblingsToRestore`.\n     * Pass `toKeepInert` to collect the already inert elements.\n     * Sets the property `inert` over the attribute since the inert spec\n     * doesn't specify if it should be reflected.\n     * https://html.spec.whatwg.org/multipage/interaction.html#inert\n     */\n    [_inertSiblings](elements, toSkip, toKeepInert) {\n      for (const element of elements) {\n        // Assume element is not a Document, so it must have a parentNode.\n        const parent = element.parentNode;\n        const children = parent.children;\n        const inertedSiblings = new Set();\n        for (let j = 0; j < children.length; j++) {\n          const sibling = children[j];\n          // Skip the input element, if not inertable or to be skipped.\n          if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {\n            continue;\n          }\n          // Should be collected since already inerted.\n          if (toKeepInert && sibling.inert) {\n            toKeepInert.add(sibling);\n          } else {\n            sibling.inert = true;\n            inertedSiblings.add(sibling);\n          }\n        }\n        // Store the siblings that were inerted.\n        element[_siblingsToRestore] = inertedSiblings;\n        // Observe only immediate children mutations on the parent.\n        const mo = new MutationObserver(this[_handleMutations].bind(this));\n        element[_parentMO] = mo;\n        let parentToObserve = parent;\n        // If we're using the ShadyDOM polyfill, then our parent could be a\n        // shady root, which is an object that acts like a ShadowRoot, but isn't\n        // actually a node in the real DOM. Observe the real DOM parent instead.\n        const maybeShadyRoot = parentToObserve;\n        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {\n          parentToObserve = maybeShadyRoot.host;\n        }\n        mo.observe(parentToObserve, {\n          childList: true\n        });\n      }\n    }\n    /**\n     * Handles newly added/removed nodes by toggling their inertness.\n     * It also checks if the current top Blocking Element has been removed,\n     * notifying and removing it.\n     */\n    [_handleMutations](mutations) {\n      const parents = this[_topElParents];\n      const toKeepInert = this[_alreadyInertElements];\n      for (const mutation of mutations) {\n        // If the target is a shadowRoot, get its host as we skip shadowRoots when\n        // computing _topElParents.\n        const target = mutation.target.host || mutation.target;\n        const idx = target === document.body ? parents.length : parents.indexOf(target);\n        const inertedChild = parents[idx - 1];\n        const inertedSiblings = inertedChild[_siblingsToRestore];\n        // To restore.\n        for (let i = 0; i < mutation.removedNodes.length; i++) {\n          const sibling = mutation.removedNodes[i];\n          if (sibling === inertedChild) {\n            console.info('Detected removal of the top Blocking Element.');\n            this.pop();\n            return;\n          }\n          if (inertedSiblings.has(sibling)) {\n            sibling.inert = false;\n            inertedSiblings.delete(sibling);\n          }\n        }\n        // To inert.\n        for (let i = 0; i < mutation.addedNodes.length; i++) {\n          const sibling = mutation.addedNodes[i];\n          if (!this[_isInertable](sibling)) {\n            continue;\n          }\n          if (toKeepInert && sibling.inert) {\n            toKeepInert.add(sibling);\n          } else {\n            sibling.inert = true;\n            inertedSiblings.add(sibling);\n          }\n        }\n      }\n    }\n    /**\n     * Returns if the element is inertable.\n     */\n    [_isInertable](element) {\n      return false === /^(style|template|script)$/.test(element.localName);\n    }\n    /**\n     * Returns the list of newParents of an element, starting from element\n     * (included) up to `document.body` (excluded).\n     */\n    [_getParents](element) {\n      const parents = [];\n      let current = element;\n      // Stop to body.\n      while (current && current !== document.body) {\n        // Skip shadow roots.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          parents.push(current);\n        }\n        // ShadowDom v1\n        if (current.assignedSlot) {\n          // Collect slots from deepest slot to top.\n          while (current = current.assignedSlot) {\n            parents.push(current);\n          }\n          // Continue the search on the top slot.\n          current = parents.pop();\n          continue;\n        }\n        current = current.parentNode || current.host;\n      }\n      return parents;\n    }\n    /**\n     * Returns the distributed children of the element's shadow root.\n     * Returns null if the element doesn't have a shadow root.\n     */\n    [_getDistributedChildren](element) {\n      const shadowRoot = element.shadowRoot;\n      if (!shadowRoot) {\n        return null;\n      }\n      const result = new Set();\n      let i;\n      let j;\n      let nodes;\n      const slots = shadowRoot.querySelectorAll('slot');\n      if (slots.length && slots[0].assignedNodes) {\n        for (i = 0; i < slots.length; i++) {\n          nodes = slots[i].assignedNodes({\n            flatten: true\n          });\n          for (j = 0; j < nodes.length; j++) {\n            if (nodes[j].nodeType === Node.ELEMENT_NODE) {\n              result.add(nodes[j]);\n            }\n          }\n        }\n        // No need to search for <content>.\n      }\n      return result;\n    }\n  }\n  document.$blockingElements = new BlockingElementsImpl();\n})();","map":{"version":3,"names":["_blockingElements","Symbol","_alreadyInertElements","_topElParents","_siblingsToRestore","_parentMO","_topChanged","_swapInertedSibling","_inertSiblings","_restoreInertedSiblings","_getParents","_getDistributedChildren","_isInertable","_handleMutations","BlockingElementsImpl","constructor","_a","_b","_c","Set","destructor","nullable","top","elems","length","push","element","remove","i","indexOf","splice","pop","has","newTop","toKeepInert","oldParents","clear","newParents","parentNode","document","body","Error","toSkip","j","slice","oldInert","newInert","siblingsToRestore","inert","add","delete","undefined","elements","mo","disconnect","siblings","sibling","parent","children","inertedSiblings","MutationObserver","bind","parentToObserve","maybeShadyRoot","__shady","host","observe","childList","mutations","parents","mutation","target","idx","inertedChild","removedNodes","console","info","addedNodes","test","localName","current","nodeType","Node","ELEMENT_NODE","assignedSlot","shadowRoot","result","nodes","slots","querySelectorAll","assignedNodes","flatten","$blockingElements"],"sources":["../src/blocking-elements.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}