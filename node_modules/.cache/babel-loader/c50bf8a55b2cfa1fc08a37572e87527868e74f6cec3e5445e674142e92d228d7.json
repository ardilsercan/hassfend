{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom'\n};\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right'\n};\nconst targetResizeObserver = new ResizeObserver(entries => {\n  setTimeout(() => {\n    entries.forEach(entry => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = superClass => class PositionMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * The element next to which this overlay should be aligned.\n       * The position of the overlay relative to the positionTarget can be adjusted\n       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n       * and `noVerticalOverlap`.\n       */\n      positionTarget: {\n        type: Object,\n        value: null,\n        sync: true\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * left or right side to the target element by default.\n       * Possible values are `start` and `end`.\n       * RTL is taken into account when interpreting the value.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       *\n       * @attr {start|end} horizontal-align\n       */\n      horizontalAlign: {\n        type: String,\n        value: 'start',\n        sync: true\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether to align the overlay's\n       * top or bottom side to the target element by default.\n       * Possible values are `top` and `bottom`.\n       * The overlay is automatically flipped to the opposite side when it doesn't fit into\n       * the default side defined by this property.\n       *\n       * @attr {top|bottom} vertical-align\n       */\n      verticalAlign: {\n        type: String,\n        value: 'top',\n        sync: true\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the x-axis, or be positioned right next to it.\n       *\n       * @attr {boolean} no-horizontal-overlap\n       */\n      noHorizontalOverlap: {\n        type: Boolean,\n        value: false,\n        sync: true\n      },\n      /**\n       * When `positionTarget` is set, this property defines whether the overlay should overlap\n       * the target element in the y-axis, or be positioned right above/below it.\n       *\n       * @attr {boolean} no-vertical-overlap\n       */\n      noVerticalOverlap: {\n        type: Boolean,\n        value: false,\n        sync: true\n      },\n      /**\n       * If the overlay content has no intrinsic height, this property can be used to set\n       * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n       * the property effectively disables the content measurement in favor of using this\n       * fixed value for determining the open direction.\n       *\n       * @attr {number} required-vertical-space\n       */\n      requiredVerticalSpace: {\n        type: Number,\n        value: 0,\n        sync: true\n      }\n    };\n  }\n  static get observers() {\n    return ['__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)', '__overlayOpenedChanged(opened, positionTarget)'];\n  }\n  constructor() {\n    super();\n    this.__onScroll = this.__onScroll.bind(this);\n    this._updatePosition = this._updatePosition.bind(this);\n  }\n\n  /** @protected */\n  connectedCallback() {\n    super.connectedCallback();\n    if (this.opened) {\n      this.__addUpdatePositionEventListeners();\n    }\n  }\n\n  /** @protected */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.__removeUpdatePositionEventListeners();\n  }\n\n  /** @private */\n  __addUpdatePositionEventListeners() {\n    window.addEventListener('resize', this._updatePosition);\n    this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n    this.__positionTargetAncestorRootNodes.forEach(node => {\n      node.addEventListener('scroll', this.__onScroll, true);\n    });\n  }\n\n  /** @private */\n  __removeUpdatePositionEventListeners() {\n    window.removeEventListener('resize', this._updatePosition);\n    if (this.__positionTargetAncestorRootNodes) {\n      this.__positionTargetAncestorRootNodes.forEach(node => {\n        node.removeEventListener('scroll', this.__onScroll, true);\n      });\n      this.__positionTargetAncestorRootNodes = null;\n    }\n  }\n\n  /** @private */\n  __overlayOpenedChanged(opened, positionTarget) {\n    this.__removeUpdatePositionEventListeners();\n    if (positionTarget) {\n      positionTarget.__overlay = null;\n      targetResizeObserver.unobserve(positionTarget);\n      if (opened) {\n        this.__addUpdatePositionEventListeners();\n        positionTarget.__overlay = this;\n        targetResizeObserver.observe(positionTarget);\n      }\n    }\n    if (opened) {\n      const computedStyle = getComputedStyle(this);\n      if (!this.__margins) {\n        this.__margins = {};\n        ['top', 'bottom', 'left', 'right'].forEach(propName => {\n          this.__margins[propName] = parseInt(computedStyle[propName], 10);\n        });\n      }\n      this.setAttribute('dir', computedStyle.direction);\n      this._updatePosition();\n      // Schedule another position update (to cover virtual keyboard opening for example)\n      requestAnimationFrame(() => this._updatePosition());\n    }\n  }\n  __positionSettingsChanged() {\n    this._updatePosition();\n  }\n\n  /** @private */\n  __onScroll(e) {\n    // If the scroll event occurred inside the overlay, ignore it.\n    if (!this.contains(e.target)) {\n      this._updatePosition();\n    }\n  }\n  _updatePosition() {\n    if (!this.positionTarget || !this.opened) {\n      return;\n    }\n    const targetRect = this.positionTarget.getBoundingClientRect();\n\n    // Detect the desired alignment and update the layout accordingly\n    const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n    this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n    const isRTL = this.__isRTL;\n    const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\n    const flexStart = !isRTL && shouldAlignStartHorizontally || isRTL && !shouldAlignStartHorizontally;\n    this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n    // Get the overlay rect after possible overlay alignment changes\n    const overlayRect = this.getBoundingClientRect();\n\n    // Obtain vertical positioning properties\n    const verticalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noVerticalOverlap, PROP_NAMES_VERTICAL, this, shouldAlignStartVertically);\n\n    // Obtain horizontal positioning properties\n    const horizontalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL, this, shouldAlignStartHorizontally);\n\n    // Apply the positioning properties to the overlay\n    Object.assign(this.style, verticalProps, horizontalProps);\n    this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n    this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n    this.toggleAttribute('end-aligned', !flexStart);\n    this.toggleAttribute('start-aligned', flexStart);\n  }\n  __shouldAlignStartHorizontally(targetRect, rtl) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n    this.__oldContentWidth = this.$.overlay.offsetWidth;\n    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n    const defaultAlignLeft = !rtl && this.horizontalAlign === 'start' || rtl && this.horizontalAlign === 'end';\n    return this.__shouldAlignStart(targetRect, contentWidth, viewportWidth, this.__margins, defaultAlignLeft, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL);\n  }\n  __shouldAlignStartVertically(targetRect) {\n    // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n    // smaller than its current space before the fit-calculations.\n    const contentHeight = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n    this.__oldContentHeight = this.$.overlay.offsetHeight;\n    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n    const defaultAlignTop = this.verticalAlign === 'top';\n    return this.__shouldAlignStart(targetRect, contentHeight, viewportHeight, this.__margins, defaultAlignTop, this.noVerticalOverlap, PROP_NAMES_VERTICAL);\n  }\n\n  // eslint-disable-next-line max-params\n  __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n    const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n    const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n    const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n    const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n    const shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n    return defaultAlignStart === shouldGoToDefaultSide;\n  }\n\n  /**\n   * Returns an adjusted value after resizing the browser window,\n   * to avoid wrong calculations when e.g. previously set `bottom`\n   * CSS property value is larger than the updated viewport height.\n   * See https://github.com/vaadin/web-components/issues/4604\n   */\n  __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n    let adjustedProp;\n    if (cssPropNameToSet === propNames.end) {\n      // Adjust horizontally\n      if (propNames.end === PROP_NAMES_VERTICAL.end) {\n        const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n        if (currentValue > viewportHeight && this.__oldViewportHeight) {\n          const heightDiff = this.__oldViewportHeight - viewportHeight;\n          adjustedProp = currentValue - heightDiff;\n        }\n        this.__oldViewportHeight = viewportHeight;\n      }\n\n      // Adjust vertically\n      if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n        const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n        if (currentValue > viewportWidth && this.__oldViewportWidth) {\n          const widthDiff = this.__oldViewportWidth - viewportWidth;\n          adjustedProp = currentValue - widthDiff;\n        }\n        this.__oldViewportWidth = viewportWidth;\n      }\n    }\n    return adjustedProp;\n  }\n\n  /**\n   * Returns an object with CSS position properties to set,\n   * e.g. { top: \"100px\" }\n   */\n  // eslint-disable-next-line max-params\n  __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n    const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n    const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n    const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n    const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n    const diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n    const valueToSet = adjustedValue ? `${adjustedValue}px` : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n    return {\n      [cssPropNameToSet]: valueToSet,\n      [cssPropNameToClear]: ''\n    };\n  }\n};","map":{"version":3,"names":["getAncestorRootNodes","PROP_NAMES_VERTICAL","start","end","PROP_NAMES_HORIZONTAL","targetResizeObserver","ResizeObserver","entries","setTimeout","forEach","entry","target","__overlay","_updatePosition","PositionMixin","superClass","properties","positionTarget","type","Object","value","sync","horizontalAlign","String","verticalAlign","noHorizontalOverlap","Boolean","noVerticalOverlap","requiredVerticalSpace","Number","observers","constructor","__onScroll","bind","connectedCallback","opened","__addUpdatePositionEventListeners","disconnectedCallback","__removeUpdatePositionEventListeners","window","addEventListener","__positionTargetAncestorRootNodes","node","removeEventListener","__overlayOpenedChanged","unobserve","observe","computedStyle","getComputedStyle","__margins","propName","parseInt","setAttribute","direction","requestAnimationFrame","__positionSettingsChanged","e","contains","targetRect","getBoundingClientRect","shouldAlignStartVertically","__shouldAlignStartVertically","style","justifyContent","isRTL","__isRTL","shouldAlignStartHorizontally","__shouldAlignStartHorizontally","flexStart","alignItems","overlayRect","verticalProps","__calculatePositionInOneDimension","horizontalProps","assign","toggleAttribute","rtl","contentWidth","Math","max","__oldContentWidth","$","overlay","offsetWidth","viewportWidth","min","innerWidth","document","documentElement","clientWidth","defaultAlignLeft","__shouldAlignStart","contentHeight","__oldContentHeight","offsetHeight","viewportHeight","innerHeight","clientHeight","defaultAlignTop","contentSize","viewportSize","margins","defaultAlignStart","noOverlap","propNames","spaceForStartAlignment","spaceForEndAlignment","spaceForDefaultAlignment","spaceForOtherAlignment","shouldGoToDefaultSide","__adjustBottomProperty","cssPropNameToSet","currentValue","adjustedProp","__oldViewportHeight","heightDiff","__oldViewportWidth","widthDiff","shouldAlignStart","cssPropNameToClear","parseFloat","adjustedValue","diff","valueToSet"],"sources":["/workspaces/frontend/node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom',\n};\n\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right',\n};\n\nconst targetResizeObserver = new ResizeObserver((entries) => {\n  setTimeout(() => {\n    entries.forEach((entry) => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = (superClass) =>\n  class PositionMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The element next to which this overlay should be aligned.\n         * The position of the overlay relative to the positionTarget can be adjusted\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n         * and `noVerticalOverlap`.\n         */\n        positionTarget: {\n          type: Object,\n          value: null,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * left or right side to the target element by default.\n         * Possible values are `start` and `end`.\n         * RTL is taken into account when interpreting the value.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {start|end} horizontal-align\n         */\n        horizontalAlign: {\n          type: String,\n          value: 'start',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * top or bottom side to the target element by default.\n         * Possible values are `top` and `bottom`.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {top|bottom} vertical-align\n         */\n        verticalAlign: {\n          type: String,\n          value: 'top',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the x-axis, or be positioned right next to it.\n         *\n         * @attr {boolean} no-horizontal-overlap\n         */\n        noHorizontalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the y-axis, or be positioned right above/below it.\n         *\n         * @attr {boolean} no-vertical-overlap\n         */\n        noVerticalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * If the overlay content has no intrinsic height, this property can be used to set\n         * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n         * the property effectively disables the content measurement in favor of using this\n         * fixed value for determining the open direction.\n         *\n         * @attr {number} required-vertical-space\n         */\n        requiredVerticalSpace: {\n          type: Number,\n          value: 0,\n          sync: true,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)',\n        '__overlayOpenedChanged(opened, positionTarget)',\n      ];\n    }\n\n    constructor() {\n      super();\n\n      this.__onScroll = this.__onScroll.bind(this);\n      this._updatePosition = this._updatePosition.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (this.opened) {\n        this.__addUpdatePositionEventListeners();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__removeUpdatePositionEventListeners();\n    }\n\n    /** @private */\n    __addUpdatePositionEventListeners() {\n      window.addEventListener('resize', this._updatePosition);\n\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\n        node.addEventListener('scroll', this.__onScroll, true);\n      });\n    }\n\n    /** @private */\n    __removeUpdatePositionEventListeners() {\n      window.removeEventListener('resize', this._updatePosition);\n\n      if (this.__positionTargetAncestorRootNodes) {\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\n          node.removeEventListener('scroll', this.__onScroll, true);\n        });\n        this.__positionTargetAncestorRootNodes = null;\n      }\n    }\n\n    /** @private */\n    __overlayOpenedChanged(opened, positionTarget) {\n      this.__removeUpdatePositionEventListeners();\n\n      if (positionTarget) {\n        positionTarget.__overlay = null;\n        targetResizeObserver.unobserve(positionTarget);\n\n        if (opened) {\n          this.__addUpdatePositionEventListeners();\n          positionTarget.__overlay = this;\n          targetResizeObserver.observe(positionTarget);\n        }\n      }\n\n      if (opened) {\n        const computedStyle = getComputedStyle(this);\n        if (!this.__margins) {\n          this.__margins = {};\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\n          });\n        }\n        this.setAttribute('dir', computedStyle.direction);\n\n        this._updatePosition();\n        // Schedule another position update (to cover virtual keyboard opening for example)\n        requestAnimationFrame(() => this._updatePosition());\n      }\n    }\n\n    __positionSettingsChanged() {\n      this._updatePosition();\n    }\n\n    /** @private */\n    __onScroll(e) {\n      // If the scroll event occurred inside the overlay, ignore it.\n      if (!this.contains(e.target)) {\n        this._updatePosition();\n      }\n    }\n\n    _updatePosition() {\n      if (!this.positionTarget || !this.opened) {\n        return;\n      }\n\n      const targetRect = this.positionTarget.getBoundingClientRect();\n\n      // Detect the desired alignment and update the layout accordingly\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n      const isRTL = this.__isRTL;\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\n      const flexStart = (!isRTL && shouldAlignStartHorizontally) || (isRTL && !shouldAlignStartHorizontally);\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n      // Get the overlay rect after possible overlay alignment changes\n      const overlayRect = this.getBoundingClientRect();\n\n      // Obtain vertical positioning properties\n      const verticalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n        this,\n        shouldAlignStartVertically,\n      );\n\n      // Obtain horizontal positioning properties\n      const horizontalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n        this,\n        shouldAlignStartHorizontally,\n      );\n\n      // Apply the positioning properties to the overlay\n      Object.assign(this.style, verticalProps, horizontalProps);\n\n      this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n      this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n\n      this.toggleAttribute('end-aligned', !flexStart);\n      this.toggleAttribute('start-aligned', flexStart);\n    }\n\n    __shouldAlignStartHorizontally(targetRect, rtl) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\n\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentWidth,\n        viewportWidth,\n        this.__margins,\n        defaultAlignLeft,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n      );\n    }\n\n    __shouldAlignStartVertically(targetRect) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentHeight =\n        this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\n\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n      const defaultAlignTop = this.verticalAlign === 'top';\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentHeight,\n        viewportHeight,\n        this.__margins,\n        defaultAlignTop,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n      );\n    }\n\n    // eslint-disable-next-line max-params\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n      const spaceForStartAlignment =\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n\n      const shouldGoToDefaultSide =\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n\n      return defaultAlignStart === shouldGoToDefaultSide;\n    }\n\n    /**\n     * Returns an adjusted value after resizing the browser window,\n     * to avoid wrong calculations when e.g. previously set `bottom`\n     * CSS property value is larger than the updated viewport height.\n     * See https://github.com/vaadin/web-components/issues/4604\n     */\n    __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n      let adjustedProp;\n\n      if (cssPropNameToSet === propNames.end) {\n        // Adjust horizontally\n        if (propNames.end === PROP_NAMES_VERTICAL.end) {\n          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n\n          if (currentValue > viewportHeight && this.__oldViewportHeight) {\n            const heightDiff = this.__oldViewportHeight - viewportHeight;\n            adjustedProp = currentValue - heightDiff;\n          }\n\n          this.__oldViewportHeight = viewportHeight;\n        }\n\n        // Adjust vertically\n        if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n          const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n\n          if (currentValue > viewportWidth && this.__oldViewportWidth) {\n            const widthDiff = this.__oldViewportWidth - viewportWidth;\n            adjustedProp = currentValue - widthDiff;\n          }\n\n          this.__oldViewportWidth = viewportWidth;\n        }\n      }\n\n      return adjustedProp;\n    }\n\n    /**\n     * Returns an object with CSS position properties to set,\n     * e.g. { top: \"100px\" }\n     */\n    // eslint-disable-next-line max-params\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n      const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n\n      const diff =\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n\n      const valueToSet = adjustedValue\n        ? `${adjustedValue}px`\n        : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n\n      return {\n        [cssPropNameToSet]: valueToSet,\n        [cssPropNameToClear]: '',\n      };\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}