{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _templateObject;\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\n/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, isServer, LitElement } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { AttachableController } from '../../internal/controller/attachable-controller.js';\nimport { EASING } from '../../internal/motion/animation.js';\nvar PRESS_GROW_MS = 450;\nvar MINIMUM_PRESS_MS = 225;\nvar INITIAL_ORIGIN_SCALE = 0.2;\nvar PADDING = 10;\nvar SOFT_EDGE_MINIMUM_SIZE = 75;\nvar SOFT_EDGE_CONTAINER_RATIO = 0.35;\nvar PRESS_PSEUDO = '::after';\nvar ANIMATION_FILL = 'forwards';\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nvar State;\n(function (State) {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"INACTIVE\"] = 0] = \"INACTIVE\";\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: begin press; transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: begin press; transition to `HOLDING`.\n   */\n  State[State[\"TOUCH_DELAY\"] = 1] = \"TOUCH_DELAY\";\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"HOLDING\"] = 2] = \"HOLDING\";\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click end press; transition to `INACTIVE`.\n   */\n  State[State[\"WAITING_FOR_CLICK\"] = 3] = \"WAITING_FOR_CLICK\";\n})(State || (State = {}));\n/**\n * Events that the ripple listens to.\n */\nvar EVENTS = ['click', 'contextmenu', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerup'];\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nvar TOUCH_DELAY_MS = 150;\n/**\n * Used to detect if HCM is active. Events do not process during HCM when the\n * ripple is not displayed.\n */\nvar FORCED_COLORS = isServer ? null : window.matchMedia('(forced-colors: active)');\n/**\n * A ripple component.\n */\nexport var Ripple = /*#__PURE__*/function (_LitElement) {\n  _inherits(Ripple, _LitElement);\n  function Ripple() {\n    var _this;\n    _classCallCheck(this, Ripple);\n    _this = _callSuper(this, Ripple, arguments);\n    /**\n     * Disables the ripple.\n     */\n    _this.disabled = false;\n    _this.hovered = false;\n    _this.pressed = false;\n    _this.rippleSize = '';\n    _this.rippleScale = '';\n    _this.initialSize = 0;\n    _this.state = State.INACTIVE;\n    _this.checkBoundsAfterContextMenu = false;\n    _this.attachableController = new AttachableController(_assertThisInitialized(_this), _this.onControlChange.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  _createClass(Ripple, [{\n    key: \"htmlFor\",\n    get: function get() {\n      return this.attachableController.htmlFor;\n    },\n    set: function set(htmlFor) {\n      this.attachableController.htmlFor = htmlFor;\n    }\n  }, {\n    key: \"control\",\n    get: function get() {\n      return this.attachableController.control;\n    },\n    set: function set(control) {\n      this.attachableController.control = control;\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(control) {\n      this.attachableController.attach(control);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.attachableController.detach();\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(Ripple.prototype), \"connectedCallback\", this).call(this);\n      // Needed for VoiceOver, which will create a \"group\" if the element is a\n      // sibling to other content.\n      this.setAttribute('aria-hidden', 'true');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var classes = {\n        'hovered': this.hovered,\n        'pressed': this.pressed\n      };\n      return html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"<div class=\\\"surface \", \"\\\"></div>\"])), classMap(classes));\n    }\n  }, {\n    key: \"update\",\n    value: function update(changedProps) {\n      if (changedProps.has('disabled') && this.disabled) {\n        this.hovered = false;\n        this.pressed = false;\n      }\n      _get(_getPrototypeOf(Ripple.prototype), \"update\", this).call(this, changedProps);\n    }\n    /**\n     * TODO(b/269799771): make private\n     * @private only public for slider\n     */\n  }, {\n    key: \"handlePointerenter\",\n    value: function handlePointerenter(event) {\n      if (!this.shouldReactToEvent(event)) {\n        return;\n      }\n      this.hovered = true;\n    }\n    /**\n     * TODO(b/269799771): make private\n     * @private only public for slider\n     */\n  }, {\n    key: \"handlePointerleave\",\n    value: function handlePointerleave(event) {\n      if (!this.shouldReactToEvent(event)) {\n        return;\n      }\n      this.hovered = false;\n      // release a held mouse or pen press that moves outside the element\n      if (this.state !== State.INACTIVE) {\n        this.endPressAnimation();\n      }\n    }\n  }, {\n    key: \"handlePointerup\",\n    value: function handlePointerup(event) {\n      if (!this.shouldReactToEvent(event)) {\n        return;\n      }\n      if (this.state === State.HOLDING) {\n        this.state = State.WAITING_FOR_CLICK;\n        return;\n      }\n      if (this.state === State.TOUCH_DELAY) {\n        this.state = State.WAITING_FOR_CLICK;\n        this.startPressAnimation(this.rippleStartEvent);\n        return;\n      }\n    }\n  }, {\n    key: \"handlePointerdown\",\n    value: function () {\n      var _handlePointerdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this.shouldReactToEvent(event)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              this.rippleStartEvent = event;\n              if (this.isTouch(event)) {\n                _context.next = 7;\n                break;\n              }\n              this.state = State.WAITING_FOR_CLICK;\n              this.startPressAnimation(event);\n              return _context.abrupt(\"return\");\n            case 7:\n              if (!(this.checkBoundsAfterContextMenu && !this.inBounds(event))) {\n                _context.next = 9;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 9:\n              this.checkBoundsAfterContextMenu = false;\n              // Wait for a hold after touch delay\n              this.state = State.TOUCH_DELAY;\n              _context.next = 13;\n              return new Promise(function (resolve) {\n                setTimeout(resolve, TOUCH_DELAY_MS);\n              });\n            case 13:\n              if (!(this.state !== State.TOUCH_DELAY)) {\n                _context.next = 15;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 15:\n              this.state = State.HOLDING;\n              this.startPressAnimation(event);\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function handlePointerdown(_x) {\n        return _handlePointerdown.apply(this, arguments);\n      }\n      return handlePointerdown;\n    }()\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      // Click is a MouseEvent in Firefox and Safari, so we cannot use\n      // `shouldReactToEvent`\n      if (this.disabled) {\n        return;\n      }\n      if (this.state === State.WAITING_FOR_CLICK) {\n        this.endPressAnimation();\n        return;\n      }\n      if (this.state === State.INACTIVE) {\n        // keyboard synthesized click event\n        this.startPressAnimation();\n        this.endPressAnimation();\n      }\n    }\n  }, {\n    key: \"handlePointercancel\",\n    value: function handlePointercancel(event) {\n      if (!this.shouldReactToEvent(event)) {\n        return;\n      }\n      this.endPressAnimation();\n    }\n  }, {\n    key: \"handleContextmenu\",\n    value: function handleContextmenu() {\n      if (this.disabled) {\n        return;\n      }\n      this.checkBoundsAfterContextMenu = true;\n      this.endPressAnimation();\n    }\n  }, {\n    key: \"determineRippleSize\",\n    value: function determineRippleSize() {\n      var _this$getBoundingClie = this.getBoundingClientRect(),\n        height = _this$getBoundingClie.height,\n        width = _this$getBoundingClie.width;\n      var maxDim = Math.max(height, width);\n      var softEdgeSize = Math.max(SOFT_EDGE_CONTAINER_RATIO * maxDim, SOFT_EDGE_MINIMUM_SIZE);\n      var initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n      var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n      var maxRadius = hypotenuse + PADDING;\n      this.initialSize = initialSize;\n      this.rippleScale = \"\".concat((maxRadius + softEdgeSize) / initialSize);\n      this.rippleSize = \"\".concat(initialSize, \"px\");\n    }\n  }, {\n    key: \"getNormalizedPointerEventCoords\",\n    value: function getNormalizedPointerEventCoords(pointerEvent) {\n      var _window = window,\n        scrollX = _window.scrollX,\n        scrollY = _window.scrollY;\n      var _this$getBoundingClie2 = this.getBoundingClientRect(),\n        left = _this$getBoundingClie2.left,\n        top = _this$getBoundingClie2.top;\n      var documentX = scrollX + left;\n      var documentY = scrollY + top;\n      var pageX = pointerEvent.pageX,\n        pageY = pointerEvent.pageY;\n      return {\n        x: pageX - documentX,\n        y: pageY - documentY\n      };\n    }\n  }, {\n    key: \"getTranslationCoordinates\",\n    value: function getTranslationCoordinates(positionEvent) {\n      var _this$getBoundingClie3 = this.getBoundingClientRect(),\n        height = _this$getBoundingClie3.height,\n        width = _this$getBoundingClie3.width;\n      // end in the center\n      var endPoint = {\n        x: (width - this.initialSize) / 2,\n        y: (height - this.initialSize) / 2\n      };\n      var startPoint;\n      if (positionEvent instanceof PointerEvent) {\n        startPoint = this.getNormalizedPointerEventCoords(positionEvent);\n      } else {\n        startPoint = {\n          x: width / 2,\n          y: height / 2\n        };\n      }\n      // center around start point\n      startPoint = {\n        x: startPoint.x - this.initialSize / 2,\n        y: startPoint.y - this.initialSize / 2\n      };\n      return {\n        startPoint: startPoint,\n        endPoint: endPoint\n      };\n    }\n  }, {\n    key: \"startPressAnimation\",\n    value: function startPressAnimation(positionEvent) {\n      var _this$growAnimation;\n      if (!this.mdRoot) {\n        return;\n      }\n      this.pressed = true;\n      (_this$growAnimation = this.growAnimation) === null || _this$growAnimation === void 0 || _this$growAnimation.cancel();\n      this.determineRippleSize();\n      var _this$getTranslationC = this.getTranslationCoordinates(positionEvent),\n        startPoint = _this$getTranslationC.startPoint,\n        endPoint = _this$getTranslationC.endPoint;\n      var translateStart = \"\".concat(startPoint.x, \"px, \").concat(startPoint.y, \"px\");\n      var translateEnd = \"\".concat(endPoint.x, \"px, \").concat(endPoint.y, \"px\");\n      this.growAnimation = this.mdRoot.animate({\n        top: [0, 0],\n        left: [0, 0],\n        height: [this.rippleSize, this.rippleSize],\n        width: [this.rippleSize, this.rippleSize],\n        transform: [\"translate(\".concat(translateStart, \") scale(1)\"), \"translate(\".concat(translateEnd, \") scale(\").concat(this.rippleScale, \")\")]\n      }, {\n        pseudoElement: PRESS_PSEUDO,\n        duration: PRESS_GROW_MS,\n        easing: EASING.STANDARD,\n        fill: ANIMATION_FILL\n      });\n    }\n  }, {\n    key: \"endPressAnimation\",\n    value: function () {\n      var _endPressAnimation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var animation, pressAnimationPlayState;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.rippleStartEvent = undefined;\n              this.state = State.INACTIVE;\n              animation = this.growAnimation;\n              pressAnimationPlayState = Infinity;\n              if (typeof (animation === null || animation === void 0 ? void 0 : animation.currentTime) === 'number') {\n                pressAnimationPlayState = animation.currentTime;\n              } else if (animation !== null && animation !== void 0 && animation.currentTime) {\n                pressAnimationPlayState = animation.currentTime.to('ms').value;\n              }\n              if (!(pressAnimationPlayState >= MINIMUM_PRESS_MS)) {\n                _context2.next = 8;\n                break;\n              }\n              this.pressed = false;\n              return _context2.abrupt(\"return\");\n            case 8:\n              _context2.next = 10;\n              return new Promise(function (resolve) {\n                setTimeout(resolve, MINIMUM_PRESS_MS - pressAnimationPlayState);\n              });\n            case 10:\n              if (!(this.growAnimation !== animation)) {\n                _context2.next = 12;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 12:\n              this.pressed = false;\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function endPressAnimation() {\n        return _endPressAnimation.apply(this, arguments);\n      }\n      return endPressAnimation;\n    }()\n    /**\n     * Returns `true` if\n     *  - the ripple element is enabled\n     *  - the pointer is primary for the input type\n     *  - the pointer is the pointer that started the interaction, or will start\n     * the interaction\n     *  - the pointer is a touch, or the pointer state has the primary button\n     * held, or the pointer is hovering\n     */\n  }, {\n    key: \"shouldReactToEvent\",\n    value: function shouldReactToEvent(event) {\n      if (this.disabled || !event.isPrimary) {\n        return false;\n      }\n      if (this.rippleStartEvent && this.rippleStartEvent.pointerId !== event.pointerId) {\n        return false;\n      }\n      if (event.type === 'pointerenter' || event.type === 'pointerleave') {\n        return !this.isTouch(event);\n      }\n      var isPrimaryButton = event.buttons === 1;\n      return this.isTouch(event) || isPrimaryButton;\n    }\n    /**\n     * Check if the event is within the bounds of the element.\n     *\n     * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n     */\n  }, {\n    key: \"inBounds\",\n    value: function inBounds(_ref) {\n      var x = _ref.x,\n        y = _ref.y;\n      var _this$getBoundingClie4 = this.getBoundingClientRect(),\n        top = _this$getBoundingClie4.top,\n        left = _this$getBoundingClie4.left,\n        bottom = _this$getBoundingClie4.bottom,\n        right = _this$getBoundingClie4.right;\n      return x >= left && x <= right && y >= top && y <= bottom;\n    }\n  }, {\n    key: \"isTouch\",\n    value: function isTouch(_ref2) {\n      var pointerType = _ref2.pointerType;\n      return pointerType === 'touch';\n    }\n    /** @private */\n  }, {\n    key: \"handleEvent\",\n    value: (function () {\n      var _handleEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(event) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(FORCED_COLORS !== null && FORCED_COLORS !== void 0 && FORCED_COLORS.matches)) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\");\n            case 2:\n              _context3.t0 = event.type;\n              _context3.next = _context3.t0 === 'click' ? 5 : _context3.t0 === 'contextmenu' ? 7 : _context3.t0 === 'pointercancel' ? 9 : _context3.t0 === 'pointerdown' ? 11 : _context3.t0 === 'pointerenter' ? 14 : _context3.t0 === 'pointerleave' ? 16 : _context3.t0 === 'pointerup' ? 18 : 20;\n              break;\n            case 5:\n              this.handleClick();\n              return _context3.abrupt(\"break\", 21);\n            case 7:\n              this.handleContextmenu();\n              return _context3.abrupt(\"break\", 21);\n            case 9:\n              this.handlePointercancel(event);\n              return _context3.abrupt(\"break\", 21);\n            case 11:\n              _context3.next = 13;\n              return this.handlePointerdown(event);\n            case 13:\n              return _context3.abrupt(\"break\", 21);\n            case 14:\n              this.handlePointerenter(event);\n              return _context3.abrupt(\"break\", 21);\n            case 16:\n              this.handlePointerleave(event);\n              return _context3.abrupt(\"break\", 21);\n            case 18:\n              this.handlePointerup(event);\n              return _context3.abrupt(\"break\", 21);\n            case 20:\n              return _context3.abrupt(\"break\", 21);\n            case 21:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function handleEvent(_x2) {\n        return _handleEvent.apply(this, arguments);\n      }\n      return handleEvent;\n    }())\n  }, {\n    key: \"onControlChange\",\n    value: function onControlChange(prev, next) {\n      if (isServer) return;\n      for (var _i = 0, _EVENTS = EVENTS; _i < _EVENTS.length; _i++) {\n        var event = _EVENTS[_i];\n        prev === null || prev === void 0 || prev.removeEventListener(event, this);\n        next === null || next === void 0 || next.addEventListener(event, this);\n      }\n    }\n  }]);\n  return Ripple;\n}(LitElement);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], Ripple.prototype, \"disabled\", void 0);\n__decorate([state()], Ripple.prototype, \"hovered\", void 0);\n__decorate([state()], Ripple.prototype, \"pressed\", void 0);\n__decorate([query('.surface')], Ripple.prototype, \"mdRoot\", void 0);","map":{"version":3,"names":["html","isServer","LitElement","property","query","state","classMap","AttachableController","EASING","PRESS_GROW_MS","MINIMUM_PRESS_MS","INITIAL_ORIGIN_SCALE","PADDING","SOFT_EDGE_MINIMUM_SIZE","SOFT_EDGE_CONTAINER_RATIO","PRESS_PSEUDO","ANIMATION_FILL","State","EVENTS","TOUCH_DELAY_MS","FORCED_COLORS","window","matchMedia","Ripple","_LitElement","_inherits","_this","_classCallCheck","disabled","hovered","pressed","rippleSize","rippleScale","initialSize","INACTIVE","checkBoundsAfterContextMenu","attachableController","_assertThisInitialized","onControlChange","bind","_createClass","key","get","htmlFor","set","control","value","attach","detach","connectedCallback","_get","_getPrototypeOf","prototype","call","setAttribute","render","classes","_templateObject","_taggedTemplateLiteral","update","changedProps","has","handlePointerenter","event","shouldReactToEvent","handlePointerleave","endPressAnimation","handlePointerup","HOLDING","WAITING_FOR_CLICK","TOUCH_DELAY","startPressAnimation","rippleStartEvent","_handlePointerdown","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","isTouch","inBounds","Promise","resolve","setTimeout","stop","handlePointerdown","_x","apply","arguments","handleClick","handlePointercancel","handleContextmenu","determineRippleSize","_this$getBoundingClie","getBoundingClientRect","height","width","maxDim","Math","max","softEdgeSize","floor","hypotenuse","sqrt","pow","maxRadius","concat","getNormalizedPointerEventCoords","pointerEvent","_window","scrollX","scrollY","_this$getBoundingClie2","left","top","documentX","documentY","pageX","pageY","x","y","getTranslationCoordinates","positionEvent","_this$getBoundingClie3","endPoint","startPoint","PointerEvent","_this$growAnimation","mdRoot","growAnimation","cancel","_this$getTranslationC","translateStart","translateEnd","animate","transform","pseudoElement","duration","easing","STANDARD","fill","_endPressAnimation","_callee2","animation","pressAnimationPlayState","_callee2$","_context2","undefined","Infinity","currentTime","to","isPrimary","pointerId","type","isPrimaryButton","buttons","_ref","_this$getBoundingClie4","bottom","right","_ref2","pointerType","_handleEvent","_callee3","_callee3$","_context3","matches","t0","handleEvent","_x2","_i","_EVENTS","length","removeEventListener","addEventListener","__decorate","Boolean","reflect"],"sources":["ripple.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, isServer, LitElement, PropertyValues} from 'lit';\nimport {property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nimport {\n  Attachable,\n  AttachableController,\n} from '../../internal/controller/attachable-controller.js';\nimport {EASING} from '../../internal/motion/animation.js';\n\nconst PRESS_GROW_MS = 450;\nconst MINIMUM_PRESS_MS = 225;\nconst INITIAL_ORIGIN_SCALE = 0.2;\nconst PADDING = 10;\nconst SOFT_EDGE_MINIMUM_SIZE = 75;\nconst SOFT_EDGE_CONTAINER_RATIO = 0.35;\nconst PRESS_PSEUDO = '::after';\nconst ANIMATION_FILL = 'forwards';\n\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nenum State {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  INACTIVE,\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: begin press; transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: begin press; transition to `HOLDING`.\n   */\n  TOUCH_DELAY,\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  HOLDING,\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click end press; transition to `INACTIVE`.\n   */\n  WAITING_FOR_CLICK,\n}\n\n/**\n * Events that the ripple listens to.\n */\nconst EVENTS = [\n  'click',\n  'contextmenu',\n  'pointercancel',\n  'pointerdown',\n  'pointerenter',\n  'pointerleave',\n  'pointerup',\n];\n\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n\n/**\n * Used to detect if HCM is active. Events do not process during HCM when the\n * ripple is not displayed.\n */\nconst FORCED_COLORS = isServer\n  ? null\n  : window.matchMedia('(forced-colors: active)');\n\n/**\n * A ripple component.\n */\nexport class Ripple extends LitElement implements Attachable {\n  /**\n   * Disables the ripple.\n   */\n  @property({type: Boolean, reflect: true}) disabled = false;\n\n  get htmlFor() {\n    return this.attachableController.htmlFor;\n  }\n\n  set htmlFor(htmlFor: string | null) {\n    this.attachableController.htmlFor = htmlFor;\n  }\n\n  get control() {\n    return this.attachableController.control;\n  }\n  set control(control: HTMLElement | null) {\n    this.attachableController.control = control;\n  }\n\n  @state() private hovered = false;\n  @state() private pressed = false;\n\n  @query('.surface') private readonly mdRoot!: HTMLElement | null;\n  private rippleSize = '';\n  private rippleScale = '';\n  private initialSize = 0;\n  private growAnimation?: Animation;\n  private state = State.INACTIVE;\n  private rippleStartEvent?: PointerEvent;\n  private checkBoundsAfterContextMenu = false;\n  private readonly attachableController = new AttachableController(\n    this,\n    this.onControlChange.bind(this),\n  );\n\n  attach(control: HTMLElement) {\n    this.attachableController.attach(control);\n  }\n\n  detach() {\n    this.attachableController.detach();\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    // Needed for VoiceOver, which will create a \"group\" if the element is a\n    // sibling to other content.\n    this.setAttribute('aria-hidden', 'true');\n  }\n\n  protected override render() {\n    const classes = {\n      'hovered': this.hovered,\n      'pressed': this.pressed,\n    };\n\n    return html`<div class=\"surface ${classMap(classes)}\"></div>`;\n  }\n\n  protected override update(changedProps: PropertyValues<Ripple>) {\n    if (changedProps.has('disabled') && this.disabled) {\n      this.hovered = false;\n      this.pressed = false;\n    }\n    super.update(changedProps);\n  }\n\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerenter(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.hovered = true;\n  }\n\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerleave(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.hovered = false;\n\n    // release a held mouse or pen press that moves outside the element\n    if (this.state !== State.INACTIVE) {\n      this.endPressAnimation();\n    }\n  }\n\n  private handlePointerup(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n      return;\n    }\n\n    if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(this.rippleStartEvent);\n      return;\n    }\n  }\n\n  private async handlePointerdown(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.rippleStartEvent = event;\n    if (!this.isTouch(event)) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(event);\n      return;\n    }\n\n    // after a longpress contextmenu event, an extra `pointerdown` can be\n    // dispatched to the pressed element. Check that the down is within\n    // bounds of the element in this case.\n    if (this.checkBoundsAfterContextMenu && !this.inBounds(event)) {\n      return;\n    }\n\n    this.checkBoundsAfterContextMenu = false;\n\n    // Wait for a hold after touch delay\n    this.state = State.TOUCH_DELAY;\n    await new Promise((resolve) => {\n      setTimeout(resolve, TOUCH_DELAY_MS);\n    });\n\n    if (this.state !== State.TOUCH_DELAY) {\n      return;\n    }\n\n    this.state = State.HOLDING;\n    this.startPressAnimation(event);\n  }\n\n  private handleClick() {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (this.disabled) {\n      return;\n    }\n\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPressAnimation();\n      return;\n    }\n\n    if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.startPressAnimation();\n      this.endPressAnimation();\n    }\n  }\n\n  private handlePointercancel(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.endPressAnimation();\n  }\n\n  private handleContextmenu() {\n    if (this.disabled) {\n      return;\n    }\n\n    this.checkBoundsAfterContextMenu = true;\n    this.endPressAnimation();\n  }\n\n  private determineRippleSize() {\n    const {height, width} = this.getBoundingClientRect();\n    const maxDim = Math.max(height, width);\n    const softEdgeSize = Math.max(\n      SOFT_EDGE_CONTAINER_RATIO * maxDim,\n      SOFT_EDGE_MINIMUM_SIZE,\n    );\n\n    const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n    const hypotenuse = Math.sqrt(width ** 2 + height ** 2);\n    const maxRadius = hypotenuse + PADDING;\n\n    this.initialSize = initialSize;\n    this.rippleScale = `${(maxRadius + softEdgeSize) / initialSize}`;\n    this.rippleSize = `${initialSize}px`;\n  }\n\n  private getNormalizedPointerEventCoords(pointerEvent: PointerEvent): {\n    x: number;\n    y: number;\n  } {\n    const {scrollX, scrollY} = window;\n    const {left, top} = this.getBoundingClientRect();\n    const documentX = scrollX + left;\n    const documentY = scrollY + top;\n    const {pageX, pageY} = pointerEvent;\n    return {x: pageX - documentX, y: pageY - documentY};\n  }\n\n  private getTranslationCoordinates(positionEvent?: Event) {\n    const {height, width} = this.getBoundingClientRect();\n    // end in the center\n    const endPoint = {\n      x: (width - this.initialSize) / 2,\n      y: (height - this.initialSize) / 2,\n    };\n\n    let startPoint;\n    if (positionEvent instanceof PointerEvent) {\n      startPoint = this.getNormalizedPointerEventCoords(positionEvent);\n    } else {\n      startPoint = {\n        x: width / 2,\n        y: height / 2,\n      };\n    }\n\n    // center around start point\n    startPoint = {\n      x: startPoint.x - this.initialSize / 2,\n      y: startPoint.y - this.initialSize / 2,\n    };\n\n    return {startPoint, endPoint};\n  }\n\n  private startPressAnimation(positionEvent?: Event) {\n    if (!this.mdRoot) {\n      return;\n    }\n\n    this.pressed = true;\n    this.growAnimation?.cancel();\n    this.determineRippleSize();\n    const {startPoint, endPoint} =\n      this.getTranslationCoordinates(positionEvent);\n    const translateStart = `${startPoint.x}px, ${startPoint.y}px`;\n    const translateEnd = `${endPoint.x}px, ${endPoint.y}px`;\n\n    this.growAnimation = this.mdRoot.animate(\n      {\n        top: [0, 0],\n        left: [0, 0],\n        height: [this.rippleSize, this.rippleSize],\n        width: [this.rippleSize, this.rippleSize],\n        transform: [\n          `translate(${translateStart}) scale(1)`,\n          `translate(${translateEnd}) scale(${this.rippleScale})`,\n        ],\n      },\n      {\n        pseudoElement: PRESS_PSEUDO,\n        duration: PRESS_GROW_MS,\n        easing: EASING.STANDARD,\n        fill: ANIMATION_FILL,\n      },\n    );\n  }\n\n  private async endPressAnimation() {\n    this.rippleStartEvent = undefined;\n    this.state = State.INACTIVE;\n    const animation = this.growAnimation;\n    let pressAnimationPlayState = Infinity;\n    if (typeof animation?.currentTime === 'number') {\n      pressAnimationPlayState = animation.currentTime;\n    } else if (animation?.currentTime) {\n      pressAnimationPlayState = animation.currentTime.to('ms').value;\n    }\n\n    if (pressAnimationPlayState >= MINIMUM_PRESS_MS) {\n      this.pressed = false;\n      return;\n    }\n\n    await new Promise((resolve) => {\n      setTimeout(resolve, MINIMUM_PRESS_MS - pressAnimationPlayState);\n    });\n\n    if (this.growAnimation !== animation) {\n      // A new press animation was started. The old animation was canceled and\n      // should not finish the pressed state.\n      return;\n    }\n\n    this.pressed = false;\n  }\n\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  private shouldReactToEvent(event: PointerEvent) {\n    if (this.disabled || !event.isPrimary) {\n      return false;\n    }\n\n    if (\n      this.rippleStartEvent &&\n      this.rippleStartEvent.pointerId !== event.pointerId\n    ) {\n      return false;\n    }\n\n    if (event.type === 'pointerenter' || event.type === 'pointerleave') {\n      return !this.isTouch(event);\n    }\n\n    const isPrimaryButton = event.buttons === 1;\n    return this.isTouch(event) || isPrimaryButton;\n  }\n\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  private inBounds({x, y}: PointerEvent) {\n    const {top, left, bottom, right} = this.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n\n  private isTouch({pointerType}: PointerEvent) {\n    return pointerType === 'touch';\n  }\n\n  /** @private */\n  async handleEvent(event: Event) {\n    if (FORCED_COLORS?.matches) {\n      // Skip event logic since the ripple is `display: none`.\n      return;\n    }\n\n    switch (event.type) {\n      case 'click':\n        this.handleClick();\n        break;\n      case 'contextmenu':\n        this.handleContextmenu();\n        break;\n      case 'pointercancel':\n        this.handlePointercancel(event as PointerEvent);\n        break;\n      case 'pointerdown':\n        await this.handlePointerdown(event as PointerEvent);\n        break;\n      case 'pointerenter':\n        this.handlePointerenter(event as PointerEvent);\n        break;\n      case 'pointerleave':\n        this.handlePointerleave(event as PointerEvent);\n        break;\n      case 'pointerup':\n        this.handlePointerup(event as PointerEvent);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private onControlChange(prev: HTMLElement | null, next: HTMLElement | null) {\n    if (isServer) return;\n\n    for (const event of EVENTS) {\n      prev?.removeEventListener(event, this);\n      next?.addEventListener(event, this);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}