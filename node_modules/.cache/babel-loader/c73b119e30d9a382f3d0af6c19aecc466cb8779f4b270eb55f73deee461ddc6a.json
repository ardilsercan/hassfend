{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\nexport class IronListAdapter {\n  constructor({\n    createElements,\n    updateElement,\n    scrollTarget,\n    scrollContainer,\n    elementsContainer,\n    reorderElements\n  }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100\n    };\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', e => this.__onWheel(e));\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n  get scrollOffset() {\n    return 0;\n  }\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n  __hasPlaceholders() {\n    return this.__getVisibleElements().some(el => el.__virtualizerPlaceholder);\n  }\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    delete this.__pendingScrollToIndex;\n    if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\n      // The condition here is a performance improvement to avoid an unnecessary\n      // re-render when the physical item pool is already covered.\n\n      // Finish rendering at the current scroll position before scrolling\n      this.flush();\n    }\n    index = this._clamp(index, 0, this.size - 1);\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n    if (this.__hasPlaceholders()) {\n      // After rendering synchronously, there are still placeholders in the DOM.\n      // Try again after the next elements update.\n      this.__pendingScrollToIndex = index;\n    }\n  }\n  flush() {\n    const startPhysicalCount = this._physicalCount;\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n    if (this._physicalCount !== startPhysicalCount) {\n      // Flushing again until physical count stabilizes fixes https://github.com/vaadin/flow-components/issues/5595#issuecomment-1770278913\n      this.flush();\n    }\n  }\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach(el => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n    }\n  }\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n    const itemHeight = parseFloat(style.height) || 0;\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.__virtualizerPlaceholder) {\n      el.style.paddingTop = '';\n      el.__virtualizerPlaceholder = false;\n    }\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    updatedElements.forEach(el => {\n      const elementHeight = el.offsetHeight;\n      if (elementHeight === 0) {\n        // If the elements have 0 height after update (for example due to lazy rendering),\n        // it results in iron-list requesting to create an unlimited count of elements.\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\n        // no height.\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\n        el.__virtualizerPlaceholder = true;\n\n        // Manually schedule the resize handler to make sure the placeholder padding is\n        // cleared in case the resize observer never triggers.\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () => this._resizeHandler());\n      } else {\n        // Add element height to the queue\n        this.__elementHeightQueue.push(elementHeight);\n        this.__elementHeightQueue.shift();\n\n        // Calculate new placeholder height based on the average of the defined values in the\n        // element height queue\n        const filteredHeights = this.__elementHeightQueue.filter(h => h !== undefined);\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n      }\n    });\n    if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\n      this.scrollToIndex(this.__pendingScrollToIndex);\n    }\n  }\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find(el => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n  get size() {\n    return this.__size;\n  }\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Change the size\n    this.__size = size;\n    if (!this._physicalItems) {\n      // Not initialized yet\n      this._itemsChanged({\n        path: 'items'\n      });\n      this.__preventElementUpdates = true;\n      flush();\n      this.__preventElementUpdates = false;\n    } else {\n      // Already initialized, just update _virtualCount\n      this._updateScrollerSize();\n      this._virtualCount = this.items.length;\n      this._render();\n    }\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler. This will cause a\n    // re-render for the elements.\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach(el => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n    super._scrollHandler();\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(this.__fixInvalidItemPositioningDebouncer, timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING), () => this.__fixInvalidItemPositioning());\n    }\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(this.__scrollReorderDebouncer, timeOut.after(this.timeouts.SCROLL_REORDER), () => this.__reorderElements());\n    }\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n    if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n    if (!this._deltaYAcc) {\n      this._deltaYAcc = 0;\n    }\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(this.__debouncerWheelAnimationFrame, animationFrame, () => {\n      this._wheelAnimationFrame = false;\n    });\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n      this._hasResidualMomentum = true;\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(this._debouncerIgnoreNewWheel, timeOut.after(this.timeouts.IGNORE_WHEEL), () => {\n        this._ignoreNewWheel = false;\n      });\n    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n  _canScroll(el, deltaX, deltaY) {\n    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter(element => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n    const elementWithFocus = visibleElements.find(element => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement));\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const {\n        transform\n      } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);","map":{"version":3,"names":["animationFrame","timeOut","isSafari","Debouncer","flush","ironList","MAX_VIRTUAL_COUNT","OFFSET_ADJUST_MIN_THRESHOLD","IronListAdapter","constructor","createElements","updateElement","scrollTarget","scrollContainer","elementsContainer","reorderElements","isAttached","_vidxOffset","_maxPages","__placeholderHeight","__elementHeightQueue","Array","timeouts","SCROLL_REORDER","IGNORE_WHEEL","FIX_INVALID_ITEM_POSITIONING","__resizeObserver","ResizeObserver","_resizeHandler","getComputedStyle","overflow","style","position","observe","addEventListener","_scrollHandler","_scrollLineHeight","_getScrollLineHeight","e","__onWheel","__mouseDown","__pendingReorder","__reorderElements","scrollOffset","adjustedFirstVisibleIndex","firstVisibleIndex","adjustedLastVisibleIndex","lastVisibleIndex","__hasPlaceholders","__getVisibleElements","some","el","__virtualizerPlaceholder","scrollToIndex","index","isNaN","size","offsetHeight","__pendingScrollToIndex","_physicalCount","_clamp","visibleElementCount","length","targetVirtualIndex","Math","floor","_virtualCount","__skipNextVirtualIndexAdjust","_scrollTop","_maxScrollTop","grid","__getIndexScrollOffset","startPhysicalCount","__fixInvalidItemPositioningDebouncer","__scrollReorderDebouncer","__debouncerWheelAnimationFrame","update","startIndex","endIndex","updatedElements","forEach","__virtualIndex","__updateElement","push","__afterElementsUpdated","_updateMetrics","itemSet","newPhysicalSize","oldPhysicalSize","prevAvgCount","_physicalAverageCount","prevPhysicalAvg","_physicalAverage","_iterateItems","pidx","vidx","_physicalSizes","ceil","__getBorderBoxHeight","_physicalItems","_physicalSize","round","itemHeight","parseFloat","height","boxSizing","paddingBottom","paddingTop","borderBottomWidth","borderTopWidth","forceSameIndexUpdates","__preventElementUpdates","__lastUpdatedIndex","elementHeight","__placeholderClearDebouncer","debounce","shift","filteredHeights","filter","h","undefined","reduce","a","b","element","find","getBoundingClientRect","top","__size","cancel","_debouncers","_increasePoolIfNeeded","_itemsChanged","path","_updateScrollerSize","items","_render","_isVisible","_assignModels","children","requestAnimationFrame","scrollTop","min","$","updateViewportBoundaries","styles","window","_scrollerPaddingTop","parseInt","_isRTL","Boolean","direction","_viewportWidth","offsetWidth","_viewportHeight","_scrollPageHeight","_updateGridMetrics","setAttribute","_createPool","physicalItems","fragment","document","createDocumentFragment","appendChild","hidden","_isClientFull","setTimeout","__clientFull","translate3d","_x","y","_z","transform","toggleScrollListener","_adjustVirtualIndexOffset","__previousScrollTop","delta","_scrollPosition","isScrollingDown","reusables","_getReusables","indexes","_physicalTop","physicalTop","_virtualStart","_physicalStart","after","__fixInvalidItemPositioning","abs","isConnected","physicalTopBelowTop","physicalBottomAboveBottom","_physicalBottom","_scrollBottom","firstIndexVisible","lastIndexVisible","originalRatio","_ratio","ctrlKey","_hasScrolledAncestor","target","deltaX","deltaY","deltaMode","WheelEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","_deltaYAcc","_wheelAnimationFrame","preventDefault","momentum","_canScroll","scrollLeft","_hasResidualMomentum","_ignoreNewWheel","_debouncerIgnoreNewWheel","_previousMomentum","getRootNode","host","indexOf","parentElement","scrollHeight","scrollWidth","count","totalItemCount","_optPhysicalSize","missingItemCount","max","createElement","fontSize","display","body","removeChild","from","adjustedVirtualStart","visibleElements","elementWithFocus","contains","activeElement","targetElement","targetPhysicalIndex","i","insertBefore","scale","offset","oldOffset","threshold","maxShift","maxOffset","Object","setPrototypeOf","prototype"],"sources":["/workspaces/frontend/node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100,\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  __hasPlaceholders() {\n    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    delete this.__pendingScrollToIndex;\n\n    if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\n      // The condition here is a performance improvement to avoid an unnecessary\n      // re-render when the physical item pool is already covered.\n\n      // Finish rendering at the current scroll position before scrolling\n      this.flush();\n    }\n\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n\n    if (this.__hasPlaceholders()) {\n      // After rendering synchronously, there are still placeholders in the DOM.\n      // Try again after the next elements update.\n      this.__pendingScrollToIndex = index;\n    }\n  }\n\n  flush() {\n    const startPhysicalCount = this._physicalCount;\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n\n    if (this._physicalCount !== startPhysicalCount) {\n      // Flushing again until physical count stabilizes fixes https://github.com/vaadin/flow-components/issues/5595#issuecomment-1770278913\n      this.flush();\n    }\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\n      );\n    }\n  }\n\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n\n    const itemHeight = parseFloat(style.height) || 0;\n\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.__virtualizerPlaceholder) {\n      el.style.paddingTop = '';\n      el.__virtualizerPlaceholder = false;\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    updatedElements.forEach((el) => {\n      const elementHeight = el.offsetHeight;\n      if (elementHeight === 0) {\n        // If the elements have 0 height after update (for example due to lazy rendering),\n        // it results in iron-list requesting to create an unlimited count of elements.\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\n        // no height.\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\n        el.__virtualizerPlaceholder = true;\n\n        // Manually schedule the resize handler to make sure the placeholder padding is\n        // cleared in case the resize observer never triggers.\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () =>\n          this._resizeHandler(),\n        );\n      } else {\n        // Add element height to the queue\n        this.__elementHeightQueue.push(elementHeight);\n        this.__elementHeightQueue.shift();\n\n        // Calculate new placeholder height based on the average of the defined values in the\n        // element height queue\n        const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n      }\n    });\n\n    if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\n      this.scrollToIndex(this.__pendingScrollToIndex);\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Change the size\n    this.__size = size;\n\n    if (!this._physicalItems) {\n      // Not initialized yet\n      this._itemsChanged({\n        path: 'items',\n      });\n      this.__preventElementUpdates = true;\n      flush();\n      this.__preventElementUpdates = false;\n    } else {\n      // Already initialized, just update _virtualCount\n      this._updateScrollerSize();\n      this._virtualCount = this.items.length;\n      this._render();\n    }\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler. This will cause a\n    // re-render for the elements.\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer,\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n\n    super._scrollHandler();\n\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(\n        this.__fixInvalidItemPositioningDebouncer,\n        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),\n        () => this.__fixInvalidItemPositioning(),\n      );\n    }\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements(),\n      );\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n\n    if ((physicalTopBelowTop && !firstIndexVisible) || (physicalBottomAboveBottom && !lastIndexVisible)) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    if (!this._deltaYAcc) {\n      this._deltaYAcc = 0;\n    }\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\n      this.__debouncerWheelAnimationFrame,\n      animationFrame,\n      () => {\n        this._wheelAnimationFrame = false;\n      },\n    );\n\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n\n      this._hasResidualMomentum = true;\n\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\n        this._debouncerIgnoreNewWheel,\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\n        () => {\n          this._ignoreNewWheel = false;\n        },\n      );\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (\n      this._canScroll(el, deltaX, deltaY) &&\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\n    ) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return (\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\n      (deltaY < 0 && el.scrollTop > 0) ||\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\n      (deltaX < 0 && el.scrollLeft > 0)\n    );\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement),\n    );\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}