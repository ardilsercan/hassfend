{"ast":null,"code":"import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { IronFitBehavior } from '@polymer/iron-fit-behavior/iron-fit-behavior.js';\nimport { IronResizableBehavior } from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport { useShadow } from '@polymer/polymer/lib/utils/settings.js';\nimport { IronFocusablesHelper } from './iron-focusables-helper.js';\nimport { IronOverlayManager, IronOverlayManagerClass } from './iron-overlay-manager.js';\nimport { pushScrollLock, removeScrollLock } from './iron-scroll-manager.js';\n\n/** @polymerBehavior */\nexport var IronOverlayBehaviorImpl = {\n  properties: {\n    /**\n     * True if the overlay is currently displayed.\n     */\n    opened: {\n      observer: '_openedChanged',\n      type: Boolean,\n      value: false,\n      notify: true\n    },\n    /**\n     * True if the overlay was canceled when it was last closed.\n     */\n    canceled: {\n      observer: '_canceledChanged',\n      readOnly: true,\n      type: Boolean,\n      value: false\n    },\n    /**\n     * Set to true to display a backdrop behind the overlay. It traps the focus\n     * within the light DOM of the overlay.\n     */\n    withBackdrop: {\n      observer: '_withBackdropChanged',\n      type: Boolean\n    },\n    /**\n     * Set to true to disable auto-focusing the overlay or child nodes with\n     * the `autofocus` attribute` when the overlay is opened.\n     */\n    noAutoFocus: {\n      type: Boolean,\n      value: false\n    },\n    /**\n     * Set to true to disable canceling the overlay with the ESC key.\n     */\n    noCancelOnEscKey: {\n      type: Boolean,\n      value: false\n    },\n    /**\n     * Set to true to disable canceling the overlay by clicking outside it.\n     */\n    noCancelOnOutsideClick: {\n      type: Boolean,\n      value: false\n    },\n    /**\n     * Contains the reason(s) this overlay was last closed (see\n     * `iron-overlay-closed`). `IronOverlayBehavior` provides the `canceled`\n     * reason; implementers of the behavior can provide other reasons in\n     * addition to `canceled`.\n     */\n    closingReason: {\n      // was a getter before, but needs to be a property so other\n      // behaviors can override this.\n      type: Object\n    },\n    /**\n     * Set to true to enable restoring of focus when overlay is closed.\n     */\n    restoreFocusOnClose: {\n      type: Boolean,\n      value: false\n    },\n    /**\n     * Set to true to allow clicks to go through overlays.\n     * When the user clicks outside this overlay, the click may\n     * close the overlay below.\n     */\n    allowClickThrough: {\n      type: Boolean\n    },\n    /**\n     * Set to true to keep overlay always on top.\n     */\n    alwaysOnTop: {\n      type: Boolean\n    },\n    /**\n     * Determines which action to perform when scroll outside an opened overlay\n     * happens. Possible values: lock - blocks scrolling from happening, refit -\n     * computes the new position on the overlay cancel - causes the overlay to\n     * close\n     */\n    scrollAction: {\n      type: String\n    },\n    /**\n     * Shortcut to access to the overlay manager.\n     * @private\n     * @type {!IronOverlayManagerClass}\n     */\n    _manager: {\n      type: Object,\n      value: IronOverlayManager\n    },\n    /**\n     * The node being focused.\n     * @type {?Node}\n     */\n    _focusedChild: {\n      type: Object\n    }\n  },\n  listeners: {\n    'iron-resize': '_onIronResize'\n  },\n  observers: ['__updateScrollObservers(isAttached, opened, scrollAction)'],\n  /**\n   * The backdrop element.\n   * @return {!Element}\n   */\n  get backdropElement() {\n    return this._manager.backdropElement;\n  },\n  /**\n   * Returns the node to give focus to.\n   * @return {!Node}\n   */\n  get _focusNode() {\n    return this._focusedChild || dom(this).querySelector('[autofocus]') || this;\n  },\n  /**\n   * Array of nodes that can receive focus (overlay included), ordered by\n   * `tabindex`. This is used to retrieve which is the first and last focusable\n   * nodes in order to wrap the focus for overlays `with-backdrop`.\n   *\n   * If you know what is your content (specifically the first and last focusable\n   * children), you can override this method to return only `[firstFocusable,\n   * lastFocusable];`\n   * @return {!Array<!Node>}\n   * @protected\n   */\n  get _focusableNodes() {\n    return IronFocusablesHelper.getTabbableNodes(this);\n  },\n  /**\n   * @return {void}\n   */\n  ready: function ready() {\n    // Used to skip calls to notifyResize and refit while the overlay is\n    // animating.\n    this.__isAnimating = false;\n    // with-backdrop needs tabindex to be set in order to trap the focus.\n    // If it is not set, IronOverlayBehavior will set it, and remove it if\n    // with-backdrop = false.\n    this.__shouldRemoveTabIndex = false;\n    // Used for wrapping the focus on TAB / Shift+TAB.\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n    // Used by to keep track of the RAF callbacks.\n    this.__rafs = {};\n    // Focused node before overlay gets opened. Can be restored on close.\n    this.__restoreFocusNode = null;\n    // Scroll info to be restored.\n    this.__scrollTop = this.__scrollLeft = null;\n    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);\n    // Root nodes hosting the overlay, used to listen for scroll events on them.\n    this.__rootNodes = null;\n    this._ensureSetup();\n  },\n  /** @override */\n  attached: function attached() {\n    // Call _openedChanged here so that position can be computed correctly.\n    if (this.opened) {\n      this._openedChanged(this.opened);\n    }\n    this._observer = dom(this).observeNodes(this._onNodesChange);\n  },\n  /** @override */\n  detached: function detached() {\n    // TODO(bicknellr): Per spec, checking `this._observer` should never be\n    // necessary because `connectedCallback` and `disconnectedCallback` should\n    // always be called in alternating order. However, the custom elements\n    // polyfill doesn't implement the reactions stack, so this can sometimes\n    // happen, particularly if ShadyDOM is in noPatch mode where the custom\n    // elements polyfill is installed before ShadyDOM. We should investigate\n    // whether or not we can either implement the reactions stack without major\n    // performance implications or patch ShadyDOM's functions to restore the\n    // typical ShadyDOM-then-custom-elements order and remove this workaround.\n    if (this._observer) {\n      dom(this).unobserveNodes(this._observer);\n    }\n    this._observer = null;\n    for (var cb in this.__rafs) {\n      if (this.__rafs[cb] !== null) {\n        cancelAnimationFrame(this.__rafs[cb]);\n      }\n    }\n    this.__rafs = {};\n    this._manager.removeOverlay(this);\n\n    // We got detached while animating, ensure we show/hide the overlay\n    // and fire iron-overlay-opened/closed event!\n    if (this.__isAnimating) {\n      if (this.opened) {\n        this._finishRenderOpened();\n      } else {\n        // Restore the focus if necessary.\n        this._applyFocus();\n        this._finishRenderClosed();\n      }\n    }\n  },\n  /**\n   * Toggle the opened state of the overlay.\n   */\n  toggle: function toggle() {\n    this._setCanceled(false);\n    this.opened = !this.opened;\n  },\n  /**\n   * Open the overlay.\n   */\n  open: function open() {\n    this._setCanceled(false);\n    this.opened = true;\n  },\n  /**\n   * Close the overlay.\n   */\n  close: function close() {\n    this._setCanceled(false);\n    this.opened = false;\n  },\n  /**\n   * Cancels the overlay.\n   * @param {Event=} event The original event\n   */\n  cancel: function cancel(event) {\n    var cancelEvent = this.fire('iron-overlay-canceled', event, {\n      cancelable: true\n    });\n    if (cancelEvent.defaultPrevented) {\n      return;\n    }\n    this._setCanceled(true);\n    this.opened = false;\n  },\n  /**\n   * Invalidates the cached tabbable nodes. To be called when any of the\n   * focusable content changes (e.g. a button is disabled).\n   */\n  invalidateTabbables: function invalidateTabbables() {\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n  },\n  _ensureSetup: function _ensureSetup() {\n    if (this._overlaySetup) {\n      return;\n    }\n    this._overlaySetup = true;\n    this.style.outline = 'none';\n    this.style.display = 'none';\n  },\n  /**\n   * Called when `opened` changes.\n   * @param {boolean=} opened\n   * @protected\n   */\n  _openedChanged: function _openedChanged(opened) {\n    if (opened) {\n      this.removeAttribute('aria-hidden');\n    } else {\n      this.setAttribute('aria-hidden', 'true');\n    }\n\n    // Defer any animation-related code on attached\n    // (_openedChanged gets called again on attached).\n    if (!this.isAttached) {\n      return;\n    }\n    this.__isAnimating = true;\n\n    // Deraf for non-blocking rendering.\n    this.__deraf('__openedChanged', this.__openedChanged);\n  },\n  _canceledChanged: function _canceledChanged() {\n    this.closingReason = this.closingReason || {};\n    this.closingReason.canceled = this.canceled;\n  },\n  _withBackdropChanged: function _withBackdropChanged() {\n    // If tabindex is already set, no need to override it.\n    if (this.withBackdrop && !this.hasAttribute('tabindex')) {\n      this.setAttribute('tabindex', '-1');\n      this.__shouldRemoveTabIndex = true;\n    } else if (this.__shouldRemoveTabIndex) {\n      this.removeAttribute('tabindex');\n      this.__shouldRemoveTabIndex = false;\n    }\n    if (this.opened && this.isAttached) {\n      this._manager.trackBackdrop();\n    }\n  },\n  /**\n   * tasks which must occur before opening; e.g. making the element visible.\n   * @protected\n   */\n  _prepareRenderOpened: function _prepareRenderOpened() {\n    // Store focused node.\n    this.__restoreFocusNode = this._manager.deepActiveElement;\n\n    // Needed to calculate the size of the overlay so that transitions on its\n    // size will have the correct starting points.\n    this._preparePositioning();\n    this.refit();\n    this._finishPositioning();\n\n    // Safari will apply the focus to the autofocus element when displayed\n    // for the first time, so we make sure to return the focus where it was.\n    if (this.noAutoFocus && document.activeElement === this._focusNode) {\n      this._focusNode.blur();\n      this.__restoreFocusNode.focus();\n    }\n  },\n  /**\n   * Tasks which cause the overlay to actually open; typically play an\n   * animation.\n   * @protected\n   */\n  _renderOpened: function _renderOpened() {\n    this._finishRenderOpened();\n  },\n  /**\n   * Tasks which cause the overlay to actually close; typically play an\n   * animation.\n   * @protected\n   */\n  _renderClosed: function _renderClosed() {\n    this._finishRenderClosed();\n  },\n  /**\n   * Tasks to be performed at the end of open action. Will fire\n   * `iron-overlay-opened`.\n   * @protected\n   */\n  _finishRenderOpened: function _finishRenderOpened() {\n    this.notifyResize();\n    this.__isAnimating = false;\n    this.fire('iron-overlay-opened');\n  },\n  /**\n   * Tasks to be performed at the end of close action. Will fire\n   * `iron-overlay-closed`.\n   * @protected\n   */\n  _finishRenderClosed: function _finishRenderClosed() {\n    // Hide the overlay.\n    this.style.display = 'none';\n    // Reset z-index only at the end of the animation.\n    this.style.zIndex = '';\n    this.notifyResize();\n    this.__isAnimating = false;\n    this.fire('iron-overlay-closed', this.closingReason);\n  },\n  _preparePositioning: function _preparePositioning() {\n    this.style.transition = this.style.webkitTransition = 'none';\n    this.style.transform = this.style.webkitTransform = 'none';\n    this.style.display = '';\n  },\n  _finishPositioning: function _finishPositioning() {\n    // First, make it invisible & reactivate animations.\n    this.style.display = 'none';\n    // Force reflow before re-enabling animations so that they don't start.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n    this.style.transition = this.style.webkitTransition = '';\n    this.style.transform = this.style.webkitTransform = '';\n    // Now that animations are enabled, make it visible again\n    this.style.display = '';\n    // Force reflow, so that following animations are properly started.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n  },\n  /**\n   * Applies focus according to the opened state.\n   * @protected\n   */\n  _applyFocus: function _applyFocus() {\n    if (this.opened) {\n      if (!this.noAutoFocus) {\n        this._focusNode.focus();\n      }\n    } else {\n      // Restore focus.\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by an user interaction (e.g. click on a\n        // button outside the overlay).\n        var activeElement = this._manager.deepActiveElement;\n        if (activeElement === document.body || composedContains(this, activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n      }\n      this.__restoreFocusNode = null;\n      this._focusNode.blur();\n      this._focusedChild = null;\n    }\n  },\n  /**\n   * Cancels (closes) the overlay. Call when click happens outside the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureClick: function _onCaptureClick(event) {\n    if (!this.noCancelOnOutsideClick) {\n      this.cancel(event);\n    }\n  },\n  /**\n   * Keeps track of the focused child. If withBackdrop, traps focus within\n   * overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureFocus: function _onCaptureFocus(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    var path = dom(event).path;\n    if (path.indexOf(this) === -1) {\n      event.stopPropagation();\n      this._applyFocus();\n    } else {\n      this._focusedChild = /** @type {Node} */path[0];\n    }\n  },\n  /**\n   * Handles the ESC key event and cancels (closes) the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureEsc: function _onCaptureEsc(event) {\n    if (!this.noCancelOnEscKey) {\n      this.cancel(event);\n    }\n  },\n  /**\n   * Handles TAB key events to track focus changes.\n   * Will wrap focus for overlays withBackdrop.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureTab: function _onCaptureTab(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    this.__ensureFirstLastFocusables();\n    // TAB wraps from last to first focusable.\n    // Shift + TAB wraps from first to last focusable.\n    var shift = event.shiftKey;\n    var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;\n    var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;\n    var shouldWrap = false;\n    if (nodeToCheck === nodeToSet) {\n      // If nodeToCheck is the same as nodeToSet, it means we have an overlay\n      // with 0 or 1 focusables; in either case we still need to trap the\n      // focus within the overlay.\n      shouldWrap = true;\n    } else {\n      // In dom=shadow, the manager will receive focus changes on the main\n      // root but not the ones within other shadow roots, so we can't rely on\n      // _focusedChild, but we should check the deepest active element.\n      var focusedNode = this._manager.deepActiveElement;\n      // If the active element is not the nodeToCheck but the overlay itself,\n      // it means the focus is about to go outside the overlay, hence we\n      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).\n      shouldWrap = focusedNode === nodeToCheck || focusedNode === this;\n    }\n    if (shouldWrap) {\n      // When the overlay contains the last focusable element of the document\n      // and it's already focused, pressing TAB would move the focus outside\n      // the document (e.g. to the browser search bar). Similarly, when the\n      // overlay contains the first focusable element of the document and it's\n      // already focused, pressing Shift+TAB would move the focus outside the\n      // document (e.g. to the browser search bar).\n      // In both cases, we would not receive a focus event, but only a blur.\n      // In order to achieve focus wrapping, we prevent this TAB event and\n      // force the focus. This will also prevent the focus to temporarily move\n      // outside the overlay, which might cause scrolling.\n      event.preventDefault();\n      this._focusedChild = nodeToSet;\n      this._applyFocus();\n    }\n  },\n  /**\n   * Refits if the overlay is opened and not animating.\n   * @protected\n   */\n  _onIronResize: function _onIronResize() {\n    if (this.opened && !this.__isAnimating) {\n      this.__deraf('refit', this.refit);\n    }\n  },\n  /**\n   * Will call notifyResize if overlay is opened.\n   * Can be overridden in order to avoid multiple observers on the same node.\n   * @protected\n   */\n  _onNodesChange: function _onNodesChange() {\n    if (this.opened && !this.__isAnimating) {\n      // It might have added focusable nodes, so invalidate cached values.\n      this.invalidateTabbables();\n      this.notifyResize();\n    }\n  },\n  /**\n   * Updates the references to the first and last focusable nodes.\n   * @private\n   */\n  __ensureFirstLastFocusables: function __ensureFirstLastFocusables() {\n    var focusableNodes = this._focusableNodes;\n    this.__firstFocusableNode = focusableNodes[0];\n    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];\n  },\n  /**\n   * Tasks executed when opened changes: prepare for the opening, move the\n   * focus, update the manager, render opened/closed.\n   * @private\n   */\n  __openedChanged: function __openedChanged() {\n    if (this.opened) {\n      // Make overlay visible, then add it to the manager.\n      this._prepareRenderOpened();\n      this._manager.addOverlay(this);\n      // Move the focus to the child node with [autofocus].\n      this._applyFocus();\n      this._renderOpened();\n    } else {\n      // Remove overlay, then restore the focus before actually closing.\n      this._manager.removeOverlay(this);\n      this._applyFocus();\n      this._renderClosed();\n    }\n  },\n  /**\n   * Debounces the execution of a callback to the next animation frame.\n   * @param {!string} jobname\n   * @param {!Function} callback Always bound to `this`\n   * @private\n   */\n  __deraf: function __deraf(jobname, callback) {\n    var rafs = this.__rafs;\n    if (rafs[jobname] !== null) {\n      cancelAnimationFrame(rafs[jobname]);\n    }\n    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {\n      rafs[jobname] = null;\n      callback.call(this);\n    }.bind(this));\n  },\n  /**\n   * @param {boolean} isAttached\n   * @param {boolean} opened\n   * @param {string=} scrollAction\n   * @private\n   */\n  __updateScrollObservers: function __updateScrollObservers(isAttached, opened, scrollAction) {\n    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {\n      removeScrollLock(this);\n      this.__removeScrollListeners();\n    } else {\n      if (scrollAction === 'lock') {\n        this.__saveScrollPosition();\n        pushScrollLock(this);\n      }\n      this.__addScrollListeners();\n    }\n  },\n  /**\n   * @private\n   */\n  __addScrollListeners: function __addScrollListeners() {\n    if (!this.__rootNodes) {\n      this.__rootNodes = [];\n      // Listen for scroll events in all shadowRoots hosting this overlay only\n      // when in native ShadowDOM.\n      if (useShadow) {\n        var node = this;\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n            this.__rootNodes.push(node);\n          }\n          node = node.host || node.assignedSlot || node.parentNode;\n        }\n      }\n      this.__rootNodes.push(document);\n    }\n    this.__rootNodes.forEach(function (el) {\n      el.addEventListener('scroll', this.__onCaptureScroll, {\n        capture: true,\n        passive: true\n      });\n    }, this);\n  },\n  /**\n   * @private\n   */\n  __removeScrollListeners: function __removeScrollListeners() {\n    if (this.__rootNodes) {\n      this.__rootNodes.forEach(function (el) {\n        el.removeEventListener('scroll', this.__onCaptureScroll, {\n          capture: true,\n          passive: true\n        });\n      }, this);\n    }\n    if (!this.isAttached) {\n      this.__rootNodes = null;\n    }\n  },\n  /**\n   * @param {string=} scrollAction\n   * @return {boolean}\n   * @private\n   */\n  __isValidScrollAction: function __isValidScrollAction(scrollAction) {\n    return scrollAction === 'lock' || scrollAction === 'refit' || scrollAction === 'cancel';\n  },\n  /**\n   * @private\n   */\n  __onCaptureScroll: function __onCaptureScroll(event) {\n    if (this.__isAnimating) {\n      return;\n    }\n    // Check if scroll outside the overlay.\n    if (dom(event).path.indexOf(this) >= 0) {\n      return;\n    }\n    switch (this.scrollAction) {\n      case 'lock':\n        // NOTE: scrolling might happen if a scroll event is not cancellable, or\n        // if user pressed keys that cause scrolling (they're not prevented in\n        // order not to break a11y features like navigate with arrow keys).\n        this.__restoreScrollPosition();\n        break;\n      case 'refit':\n        this.__deraf('refit', this.refit);\n        break;\n      case 'cancel':\n        this.cancel(event);\n        break;\n    }\n  },\n  /**\n   * Memoizes the scroll position of the outside scrolling element.\n   * @private\n   */\n  __saveScrollPosition: function __saveScrollPosition() {\n    if (document.scrollingElement) {\n      this.__scrollTop = document.scrollingElement.scrollTop;\n      this.__scrollLeft = document.scrollingElement.scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, get max.\n      this.__scrollTop = Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n      this.__scrollLeft = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);\n    }\n  },\n  /**\n   * Resets the scroll position of the outside scrolling element.\n   * @private\n   */\n  __restoreScrollPosition: function __restoreScrollPosition() {\n    if (document.scrollingElement) {\n      document.scrollingElement.scrollTop = this.__scrollTop;\n      document.scrollingElement.scrollLeft = this.__scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, set both.\n      document.documentElement.scrollTop = document.body.scrollTop = this.__scrollTop;\n      document.documentElement.scrollLeft = document.body.scrollLeft = this.__scrollLeft;\n    }\n  }\n};\nvar composedParent = function composedParent(node) {\n  return node.assignedSlot || node.parentNode || node.host;\n};\nvar composedContains = function composedContains(ancestor, descendant) {\n  for (var element = descendant; element; element = composedParent(element)) {\n    if (element === ancestor) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden\n  or shown, and displays on top of other content. It includes an optional\n  backdrop, and can be used to implement a variety of UI controls including\n  dialogs and drop downs. Multiple overlays may be displayed at once.\n\n  See the [demo source\n  code](https://github.com/PolymerElements/iron-overlay-behavior/blob/master/demo/simple-overlay.html)\n  for an example.\n\n  ### Closing and canceling\n\n  An overlay may be hidden by closing or canceling. The difference between close\n  and cancel is user intent. Closing generally implies that the user\n  acknowledged the content on the overlay. By default, it will cancel whenever\n  the user taps outside it or presses the escape key. This behavior is\n  configurable with the `no-cancel-on-esc-key` and the\n  `no-cancel-on-outside-click` properties. `close()` should be called explicitly\n  by the implementer when the user interacts with a control in the overlay\n  element. When the dialog is canceled, the overlay fires an\n  'iron-overlay-canceled' event. Call `preventDefault` on this event to prevent\n  the overlay from closing.\n\n  ### Positioning\n\n  By default the element is sized and positioned to fit and centered inside the\n  window. You can position and size it manually using CSS. See\n  `Polymer.IronFitBehavior`.\n\n  ### Backdrop\n\n  Set the `with-backdrop` attribute to display a backdrop behind the overlay.\n  The backdrop is appended to `<body>` and is of type `<iron-overlay-backdrop>`.\n  See its doc page for styling options.\n\n  In addition, `with-backdrop` will wrap the focus within the content in the\n  light DOM. Override the [`_focusableNodes`\n  getter](#Polymer.IronOverlayBehavior:property-_focusableNodes) to achieve a\n  different behavior.\n\n  ### Limitations\n\n  The element is styled to appear on top of other content by setting its\n  `z-index` property. You must ensure no element has a stacking context with a\n  higher `z-index` than its parent stacking context. You should place this\n  element as a child of `<body>` whenever possible.\n\n  @demo demo/index.html\n  @polymerBehavior\n */\nexport var IronOverlayBehavior = [IronFitBehavior, IronResizableBehavior, IronOverlayBehaviorImpl];\n\n/**\n * Fired after the overlay opens.\n * @event iron-overlay-opened\n */\n\n/**\n * Fired when the overlay is canceled, but before it is closed.\n * @event iron-overlay-canceled\n * @param {Event} event The closing of the overlay can be prevented\n * by calling `event.preventDefault()`. The `event.detail` is the original event\n * that originated the canceling (e.g. ESC keyboard event or click event outside\n * the overlay).\n */\n\n/**\n * Fired after the overlay closes.\n * @event iron-overlay-closed\n * @param {Event} event The `event.detail` is the `closingReason` property\n * (contains `canceled`, whether the overlay was canceled).\n */","map":{"version":3,"names":["IronFitBehavior","IronResizableBehavior","dom","useShadow","IronFocusablesHelper","IronOverlayManager","IronOverlayManagerClass","pushScrollLock","removeScrollLock","IronOverlayBehaviorImpl","properties","opened","observer","type","Boolean","value","notify","canceled","readOnly","withBackdrop","noAutoFocus","noCancelOnEscKey","noCancelOnOutsideClick","closingReason","Object","restoreFocusOnClose","allowClickThrough","alwaysOnTop","scrollAction","String","_manager","_focusedChild","listeners","observers","backdropElement","_focusNode","querySelector","_focusableNodes","getTabbableNodes","ready","__isAnimating","__shouldRemoveTabIndex","__firstFocusableNode","__lastFocusableNode","__rafs","__restoreFocusNode","__scrollTop","__scrollLeft","__onCaptureScroll","bind","__rootNodes","_ensureSetup","attached","_openedChanged","_observer","observeNodes","_onNodesChange","detached","unobserveNodes","cb","cancelAnimationFrame","removeOverlay","_finishRenderOpened","_applyFocus","_finishRenderClosed","toggle","_setCanceled","open","close","cancel","event","cancelEvent","fire","cancelable","defaultPrevented","invalidateTabbables","_overlaySetup","style","outline","display","removeAttribute","setAttribute","isAttached","__deraf","__openedChanged","_canceledChanged","_withBackdropChanged","hasAttribute","trackBackdrop","_prepareRenderOpened","deepActiveElement","_preparePositioning","refit","_finishPositioning","document","activeElement","blur","focus","_renderOpened","_renderClosed","notifyResize","zIndex","transition","webkitTransition","transform","webkitTransform","scrollTop","body","composedContains","_onCaptureClick","_onCaptureFocus","path","indexOf","stopPropagation","_onCaptureEsc","_onCaptureTab","__ensureFirstLastFocusables","shift","shiftKey","nodeToCheck","nodeToSet","shouldWrap","focusedNode","preventDefault","_onIronResize","focusableNodes","length","addOverlay","jobname","callback","rafs","requestAnimationFrame","nextAnimationFrame","call","__updateScrollObservers","__isValidScrollAction","__removeScrollListeners","__saveScrollPosition","__addScrollListeners","node","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","push","assignedSlot","parentNode","forEach","el","addEventListener","capture","passive","removeEventListener","__restoreScrollPosition","scrollingElement","scrollLeft","Math","max","documentElement","composedParent","ancestor","descendant","element","IronOverlayBehavior"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/iron-overlay-behavior/iron-overlay-behavior.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {IronFitBehavior} from '@polymer/iron-fit-behavior/iron-fit-behavior.js';\nimport {IronResizableBehavior} from '@polymer/iron-resizable-behavior/iron-resizable-behavior.js';\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\nimport {useShadow} from '@polymer/polymer/lib/utils/settings.js';\n\nimport {IronFocusablesHelper} from './iron-focusables-helper.js';\nimport {IronOverlayManager, IronOverlayManagerClass} from './iron-overlay-manager.js';\nimport {pushScrollLock, removeScrollLock} from './iron-scroll-manager.js';\n\n/** @polymerBehavior */\nexport const IronOverlayBehaviorImpl = {\n\n  properties: {\n\n    /**\n     * True if the overlay is currently displayed.\n     */\n    opened:\n        {observer: '_openedChanged', type: Boolean, value: false, notify: true},\n\n    /**\n     * True if the overlay was canceled when it was last closed.\n     */\n    canceled: {\n      observer: '_canceledChanged',\n      readOnly: true,\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * Set to true to display a backdrop behind the overlay. It traps the focus\n     * within the light DOM of the overlay.\n     */\n    withBackdrop: {\n      observer: '_withBackdropChanged',\n      type: Boolean,\n    },\n\n    /**\n     * Set to true to disable auto-focusing the overlay or child nodes with\n     * the `autofocus` attribute` when the overlay is opened.\n     */\n    noAutoFocus: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to disable canceling the overlay with the ESC key.\n     */\n    noCancelOnEscKey: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to disable canceling the overlay by clicking outside it.\n     */\n    noCancelOnOutsideClick: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Contains the reason(s) this overlay was last closed (see\n     * `iron-overlay-closed`). `IronOverlayBehavior` provides the `canceled`\n     * reason; implementers of the behavior can provide other reasons in\n     * addition to `canceled`.\n     */\n    closingReason: {\n      // was a getter before, but needs to be a property so other\n      // behaviors can override this.\n      type: Object,\n    },\n\n    /**\n     * Set to true to enable restoring of focus when overlay is closed.\n     */\n    restoreFocusOnClose: {\n      type: Boolean,\n      value: false,\n    },\n\n    /**\n     * Set to true to allow clicks to go through overlays.\n     * When the user clicks outside this overlay, the click may\n     * close the overlay below.\n     */\n    allowClickThrough: {\n      type: Boolean,\n    },\n\n    /**\n     * Set to true to keep overlay always on top.\n     */\n    alwaysOnTop: {\n      type: Boolean,\n    },\n\n    /**\n     * Determines which action to perform when scroll outside an opened overlay\n     * happens. Possible values: lock - blocks scrolling from happening, refit -\n     * computes the new position on the overlay cancel - causes the overlay to\n     * close\n     */\n    scrollAction: {\n      type: String,\n    },\n\n    /**\n     * Shortcut to access to the overlay manager.\n     * @private\n     * @type {!IronOverlayManagerClass}\n     */\n    _manager: {\n      type: Object,\n      value: IronOverlayManager,\n    },\n\n    /**\n     * The node being focused.\n     * @type {?Node}\n     */\n    _focusedChild: {\n      type: Object,\n    }\n\n  },\n\n  listeners: {'iron-resize': '_onIronResize'},\n\n  observers: ['__updateScrollObservers(isAttached, opened, scrollAction)'],\n\n  /**\n   * The backdrop element.\n   * @return {!Element}\n   */\n  get backdropElement() {\n    return this._manager.backdropElement;\n  },\n\n  /**\n   * Returns the node to give focus to.\n   * @return {!Node}\n   */\n  get _focusNode() {\n    return this._focusedChild || dom(this).querySelector('[autofocus]') || this;\n  },\n\n  /**\n   * Array of nodes that can receive focus (overlay included), ordered by\n   * `tabindex`. This is used to retrieve which is the first and last focusable\n   * nodes in order to wrap the focus for overlays `with-backdrop`.\n   *\n   * If you know what is your content (specifically the first and last focusable\n   * children), you can override this method to return only `[firstFocusable,\n   * lastFocusable];`\n   * @return {!Array<!Node>}\n   * @protected\n   */\n  get _focusableNodes() {\n    return IronFocusablesHelper.getTabbableNodes(this);\n  },\n\n  /**\n   * @return {void}\n   */\n  ready: function() {\n    // Used to skip calls to notifyResize and refit while the overlay is\n    // animating.\n    this.__isAnimating = false;\n    // with-backdrop needs tabindex to be set in order to trap the focus.\n    // If it is not set, IronOverlayBehavior will set it, and remove it if\n    // with-backdrop = false.\n    this.__shouldRemoveTabIndex = false;\n    // Used for wrapping the focus on TAB / Shift+TAB.\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n    // Used by to keep track of the RAF callbacks.\n    this.__rafs = {};\n    // Focused node before overlay gets opened. Can be restored on close.\n    this.__restoreFocusNode = null;\n    // Scroll info to be restored.\n    this.__scrollTop = this.__scrollLeft = null;\n    this.__onCaptureScroll = this.__onCaptureScroll.bind(this);\n    // Root nodes hosting the overlay, used to listen for scroll events on them.\n    this.__rootNodes = null;\n    this._ensureSetup();\n  },\n\n  /** @override */\n  attached: function() {\n    // Call _openedChanged here so that position can be computed correctly.\n    if (this.opened) {\n      this._openedChanged(this.opened);\n    }\n    this._observer = dom(this).observeNodes(this._onNodesChange);\n  },\n\n  /** @override */\n  detached: function() {\n    // TODO(bicknellr): Per spec, checking `this._observer` should never be\n    // necessary because `connectedCallback` and `disconnectedCallback` should\n    // always be called in alternating order. However, the custom elements\n    // polyfill doesn't implement the reactions stack, so this can sometimes\n    // happen, particularly if ShadyDOM is in noPatch mode where the custom\n    // elements polyfill is installed before ShadyDOM. We should investigate\n    // whether or not we can either implement the reactions stack without major\n    // performance implications or patch ShadyDOM's functions to restore the\n    // typical ShadyDOM-then-custom-elements order and remove this workaround.\n    if (this._observer) {\n      dom(this).unobserveNodes(this._observer);\n    }\n    this._observer = null;\n    for (var cb in this.__rafs) {\n      if (this.__rafs[cb] !== null) {\n        cancelAnimationFrame(this.__rafs[cb]);\n      }\n    }\n    this.__rafs = {};\n    this._manager.removeOverlay(this);\n\n    // We got detached while animating, ensure we show/hide the overlay\n    // and fire iron-overlay-opened/closed event!\n    if (this.__isAnimating) {\n      if (this.opened) {\n        this._finishRenderOpened();\n      } else {\n        // Restore the focus if necessary.\n        this._applyFocus();\n        this._finishRenderClosed();\n      }\n    }\n  },\n\n  /**\n   * Toggle the opened state of the overlay.\n   */\n  toggle: function() {\n    this._setCanceled(false);\n    this.opened = !this.opened;\n  },\n\n  /**\n   * Open the overlay.\n   */\n  open: function() {\n    this._setCanceled(false);\n    this.opened = true;\n  },\n\n  /**\n   * Close the overlay.\n   */\n  close: function() {\n    this._setCanceled(false);\n    this.opened = false;\n  },\n\n  /**\n   * Cancels the overlay.\n   * @param {Event=} event The original event\n   */\n  cancel: function(event) {\n    var cancelEvent =\n        this.fire('iron-overlay-canceled', event, {cancelable: true});\n    if (cancelEvent.defaultPrevented) {\n      return;\n    }\n\n    this._setCanceled(true);\n    this.opened = false;\n  },\n\n  /**\n   * Invalidates the cached tabbable nodes. To be called when any of the\n   * focusable content changes (e.g. a button is disabled).\n   */\n  invalidateTabbables: function() {\n    this.__firstFocusableNode = this.__lastFocusableNode = null;\n  },\n\n  _ensureSetup: function() {\n    if (this._overlaySetup) {\n      return;\n    }\n    this._overlaySetup = true;\n    this.style.outline = 'none';\n    this.style.display = 'none';\n  },\n\n  /**\n   * Called when `opened` changes.\n   * @param {boolean=} opened\n   * @protected\n   */\n  _openedChanged: function(opened) {\n    if (opened) {\n      this.removeAttribute('aria-hidden');\n    } else {\n      this.setAttribute('aria-hidden', 'true');\n    }\n\n    // Defer any animation-related code on attached\n    // (_openedChanged gets called again on attached).\n    if (!this.isAttached) {\n      return;\n    }\n\n    this.__isAnimating = true;\n\n    // Deraf for non-blocking rendering.\n    this.__deraf('__openedChanged', this.__openedChanged);\n  },\n\n  _canceledChanged: function() {\n    this.closingReason = this.closingReason || {};\n    this.closingReason.canceled = this.canceled;\n  },\n\n  _withBackdropChanged: function() {\n    // If tabindex is already set, no need to override it.\n    if (this.withBackdrop && !this.hasAttribute('tabindex')) {\n      this.setAttribute('tabindex', '-1');\n      this.__shouldRemoveTabIndex = true;\n    } else if (this.__shouldRemoveTabIndex) {\n      this.removeAttribute('tabindex');\n      this.__shouldRemoveTabIndex = false;\n    }\n    if (this.opened && this.isAttached) {\n      this._manager.trackBackdrop();\n    }\n  },\n\n  /**\n   * tasks which must occur before opening; e.g. making the element visible.\n   * @protected\n   */\n  _prepareRenderOpened: function() {\n    // Store focused node.\n    this.__restoreFocusNode = this._manager.deepActiveElement;\n\n    // Needed to calculate the size of the overlay so that transitions on its\n    // size will have the correct starting points.\n    this._preparePositioning();\n    this.refit();\n    this._finishPositioning();\n\n    // Safari will apply the focus to the autofocus element when displayed\n    // for the first time, so we make sure to return the focus where it was.\n    if (this.noAutoFocus && document.activeElement === this._focusNode) {\n      this._focusNode.blur();\n      this.__restoreFocusNode.focus();\n    }\n  },\n\n  /**\n   * Tasks which cause the overlay to actually open; typically play an\n   * animation.\n   * @protected\n   */\n  _renderOpened: function() {\n    this._finishRenderOpened();\n  },\n\n  /**\n   * Tasks which cause the overlay to actually close; typically play an\n   * animation.\n   * @protected\n   */\n  _renderClosed: function() {\n    this._finishRenderClosed();\n  },\n\n  /**\n   * Tasks to be performed at the end of open action. Will fire\n   * `iron-overlay-opened`.\n   * @protected\n   */\n  _finishRenderOpened: function() {\n    this.notifyResize();\n    this.__isAnimating = false;\n\n    this.fire('iron-overlay-opened');\n  },\n\n  /**\n   * Tasks to be performed at the end of close action. Will fire\n   * `iron-overlay-closed`.\n   * @protected\n   */\n  _finishRenderClosed: function() {\n    // Hide the overlay.\n    this.style.display = 'none';\n    // Reset z-index only at the end of the animation.\n    this.style.zIndex = '';\n    this.notifyResize();\n    this.__isAnimating = false;\n    this.fire('iron-overlay-closed', this.closingReason);\n  },\n\n  _preparePositioning: function() {\n    this.style.transition = this.style.webkitTransition = 'none';\n    this.style.transform = this.style.webkitTransform = 'none';\n    this.style.display = '';\n  },\n\n  _finishPositioning: function() {\n    // First, make it invisible & reactivate animations.\n    this.style.display = 'none';\n    // Force reflow before re-enabling animations so that they don't start.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n    this.style.transition = this.style.webkitTransition = '';\n    this.style.transform = this.style.webkitTransform = '';\n    // Now that animations are enabled, make it visible again\n    this.style.display = '';\n    // Force reflow, so that following animations are properly started.\n    // Set scrollTop to itself so that Closure Compiler doesn't remove this.\n    this.scrollTop = this.scrollTop;\n  },\n\n  /**\n   * Applies focus according to the opened state.\n   * @protected\n   */\n  _applyFocus: function() {\n    if (this.opened) {\n      if (!this.noAutoFocus) {\n        this._focusNode.focus();\n      }\n    } else {\n      // Restore focus.\n      if (this.restoreFocusOnClose && this.__restoreFocusNode) {\n        // If the activeElement is `<body>` or inside the overlay,\n        // we are allowed to restore the focus. In all the other\n        // cases focus might have been moved elsewhere by another\n        // component or by an user interaction (e.g. click on a\n        // button outside the overlay).\n        var activeElement = this._manager.deepActiveElement;\n        if (activeElement === document.body ||\n            composedContains(this, activeElement)) {\n          this.__restoreFocusNode.focus();\n        }\n      }\n      this.__restoreFocusNode = null;\n      this._focusNode.blur();\n      this._focusedChild = null;\n    }\n  },\n\n  /**\n   * Cancels (closes) the overlay. Call when click happens outside the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureClick: function(event) {\n    if (!this.noCancelOnOutsideClick) {\n      this.cancel(event);\n    }\n  },\n\n  /**\n   * Keeps track of the focused child. If withBackdrop, traps focus within\n   * overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureFocus: function(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    var path = dom(event).path;\n    if (path.indexOf(this) === -1) {\n      event.stopPropagation();\n      this._applyFocus();\n    } else {\n      this._focusedChild = /** @type {Node} */ (path[0]);\n    }\n  },\n\n  /**\n   * Handles the ESC key event and cancels (closes) the overlay.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureEsc: function(event) {\n    if (!this.noCancelOnEscKey) {\n      this.cancel(event);\n    }\n  },\n\n  /**\n   * Handles TAB key events to track focus changes.\n   * Will wrap focus for overlays withBackdrop.\n   * @param {!Event} event\n   * @protected\n   */\n  _onCaptureTab: function(event) {\n    if (!this.withBackdrop) {\n      return;\n    }\n    this.__ensureFirstLastFocusables();\n    // TAB wraps from last to first focusable.\n    // Shift + TAB wraps from first to last focusable.\n    var shift = event.shiftKey;\n    var nodeToCheck =\n        shift ? this.__firstFocusableNode : this.__lastFocusableNode;\n    var nodeToSet =\n        shift ? this.__lastFocusableNode : this.__firstFocusableNode;\n    var shouldWrap = false;\n    if (nodeToCheck === nodeToSet) {\n      // If nodeToCheck is the same as nodeToSet, it means we have an overlay\n      // with 0 or 1 focusables; in either case we still need to trap the\n      // focus within the overlay.\n      shouldWrap = true;\n    } else {\n      // In dom=shadow, the manager will receive focus changes on the main\n      // root but not the ones within other shadow roots, so we can't rely on\n      // _focusedChild, but we should check the deepest active element.\n      var focusedNode = this._manager.deepActiveElement;\n      // If the active element is not the nodeToCheck but the overlay itself,\n      // it means the focus is about to go outside the overlay, hence we\n      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).\n      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);\n    }\n\n    if (shouldWrap) {\n      // When the overlay contains the last focusable element of the document\n      // and it's already focused, pressing TAB would move the focus outside\n      // the document (e.g. to the browser search bar). Similarly, when the\n      // overlay contains the first focusable element of the document and it's\n      // already focused, pressing Shift+TAB would move the focus outside the\n      // document (e.g. to the browser search bar).\n      // In both cases, we would not receive a focus event, but only a blur.\n      // In order to achieve focus wrapping, we prevent this TAB event and\n      // force the focus. This will also prevent the focus to temporarily move\n      // outside the overlay, which might cause scrolling.\n      event.preventDefault();\n      this._focusedChild = nodeToSet;\n      this._applyFocus();\n    }\n  },\n\n  /**\n   * Refits if the overlay is opened and not animating.\n   * @protected\n   */\n  _onIronResize: function() {\n    if (this.opened && !this.__isAnimating) {\n      this.__deraf('refit', this.refit);\n    }\n  },\n\n  /**\n   * Will call notifyResize if overlay is opened.\n   * Can be overridden in order to avoid multiple observers on the same node.\n   * @protected\n   */\n  _onNodesChange: function() {\n    if (this.opened && !this.__isAnimating) {\n      // It might have added focusable nodes, so invalidate cached values.\n      this.invalidateTabbables();\n      this.notifyResize();\n    }\n  },\n\n  /**\n   * Updates the references to the first and last focusable nodes.\n   * @private\n   */\n  __ensureFirstLastFocusables: function() {\n    var focusableNodes = this._focusableNodes;\n    this.__firstFocusableNode = focusableNodes[0];\n    this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];\n  },\n\n  /**\n   * Tasks executed when opened changes: prepare for the opening, move the\n   * focus, update the manager, render opened/closed.\n   * @private\n   */\n  __openedChanged: function() {\n    if (this.opened) {\n      // Make overlay visible, then add it to the manager.\n      this._prepareRenderOpened();\n      this._manager.addOverlay(this);\n      // Move the focus to the child node with [autofocus].\n      this._applyFocus();\n\n      this._renderOpened();\n    } else {\n      // Remove overlay, then restore the focus before actually closing.\n      this._manager.removeOverlay(this);\n      this._applyFocus();\n\n      this._renderClosed();\n    }\n  },\n\n  /**\n   * Debounces the execution of a callback to the next animation frame.\n   * @param {!string} jobname\n   * @param {!Function} callback Always bound to `this`\n   * @private\n   */\n  __deraf: function(jobname, callback) {\n    var rafs = this.__rafs;\n    if (rafs[jobname] !== null) {\n      cancelAnimationFrame(rafs[jobname]);\n    }\n    rafs[jobname] = requestAnimationFrame(function nextAnimationFrame() {\n      rafs[jobname] = null;\n      callback.call(this);\n    }.bind(this));\n  },\n\n  /**\n   * @param {boolean} isAttached\n   * @param {boolean} opened\n   * @param {string=} scrollAction\n   * @private\n   */\n  __updateScrollObservers: function(isAttached, opened, scrollAction) {\n    if (!isAttached || !opened || !this.__isValidScrollAction(scrollAction)) {\n      removeScrollLock(this);\n      this.__removeScrollListeners();\n    } else {\n      if (scrollAction === 'lock') {\n        this.__saveScrollPosition();\n        pushScrollLock(this);\n      }\n      this.__addScrollListeners();\n    }\n  },\n\n  /**\n   * @private\n   */\n  __addScrollListeners: function() {\n    if (!this.__rootNodes) {\n      this.__rootNodes = [];\n      // Listen for scroll events in all shadowRoots hosting this overlay only\n      // when in native ShadowDOM.\n      if (useShadow) {\n        var node = this;\n        while (node) {\n          if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {\n            this.__rootNodes.push(node);\n          }\n          node = node.host || node.assignedSlot || node.parentNode;\n        }\n      }\n      this.__rootNodes.push(document);\n    }\n    this.__rootNodes.forEach(function(el) {\n      el.addEventListener('scroll', this.__onCaptureScroll, {\n        capture: true,\n        passive: true,\n      });\n    }, this);\n  },\n\n  /**\n   * @private\n   */\n  __removeScrollListeners: function() {\n    if (this.__rootNodes) {\n      this.__rootNodes.forEach(function(el) {\n        el.removeEventListener('scroll', this.__onCaptureScroll, {\n          capture: true,\n          passive: true,\n        });\n      }, this);\n    }\n    if (!this.isAttached) {\n      this.__rootNodes = null;\n    }\n  },\n\n  /**\n   * @param {string=} scrollAction\n   * @return {boolean}\n   * @private\n   */\n  __isValidScrollAction: function(scrollAction) {\n    return scrollAction === 'lock' || scrollAction === 'refit' ||\n        scrollAction === 'cancel';\n  },\n\n  /**\n   * @private\n   */\n  __onCaptureScroll: function(event) {\n    if (this.__isAnimating) {\n      return;\n    }\n    // Check if scroll outside the overlay.\n    if (dom(event).path.indexOf(this) >= 0) {\n      return;\n    }\n    switch (this.scrollAction) {\n      case 'lock':\n        // NOTE: scrolling might happen if a scroll event is not cancellable, or\n        // if user pressed keys that cause scrolling (they're not prevented in\n        // order not to break a11y features like navigate with arrow keys).\n        this.__restoreScrollPosition();\n        break;\n      case 'refit':\n        this.__deraf('refit', this.refit);\n        break;\n      case 'cancel':\n        this.cancel(event);\n        break;\n    }\n  },\n\n  /**\n   * Memoizes the scroll position of the outside scrolling element.\n   * @private\n   */\n  __saveScrollPosition: function() {\n    if (document.scrollingElement) {\n      this.__scrollTop = document.scrollingElement.scrollTop;\n      this.__scrollLeft = document.scrollingElement.scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, get max.\n      this.__scrollTop =\n          Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n      this.__scrollLeft = Math.max(\n          document.documentElement.scrollLeft, document.body.scrollLeft);\n    }\n  },\n\n  /**\n   * Resets the scroll position of the outside scrolling element.\n   * @private\n   */\n  __restoreScrollPosition: function() {\n    if (document.scrollingElement) {\n      document.scrollingElement.scrollTop = this.__scrollTop;\n      document.scrollingElement.scrollLeft = this.__scrollLeft;\n    } else {\n      // Since we don't know if is the body or html, set both.\n      document.documentElement.scrollTop = document.body.scrollTop =\n          this.__scrollTop;\n      document.documentElement.scrollLeft = document.body.scrollLeft =\n          this.__scrollLeft;\n    }\n  },\n\n};\n\nconst composedParent = node =>\n    node.assignedSlot || node.parentNode || node.host;\n\nconst composedContains = (ancestor, descendant) => {\n  for (let element = descendant; element; element = composedParent(element)) {\n    if (element === ancestor) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n  Use `Polymer.IronOverlayBehavior` to implement an element that can be hidden\n  or shown, and displays on top of other content. It includes an optional\n  backdrop, and can be used to implement a variety of UI controls including\n  dialogs and drop downs. Multiple overlays may be displayed at once.\n\n  See the [demo source\n  code](https://github.com/PolymerElements/iron-overlay-behavior/blob/master/demo/simple-overlay.html)\n  for an example.\n\n  ### Closing and canceling\n\n  An overlay may be hidden by closing or canceling. The difference between close\n  and cancel is user intent. Closing generally implies that the user\n  acknowledged the content on the overlay. By default, it will cancel whenever\n  the user taps outside it or presses the escape key. This behavior is\n  configurable with the `no-cancel-on-esc-key` and the\n  `no-cancel-on-outside-click` properties. `close()` should be called explicitly\n  by the implementer when the user interacts with a control in the overlay\n  element. When the dialog is canceled, the overlay fires an\n  'iron-overlay-canceled' event. Call `preventDefault` on this event to prevent\n  the overlay from closing.\n\n  ### Positioning\n\n  By default the element is sized and positioned to fit and centered inside the\n  window. You can position and size it manually using CSS. See\n  `Polymer.IronFitBehavior`.\n\n  ### Backdrop\n\n  Set the `with-backdrop` attribute to display a backdrop behind the overlay.\n  The backdrop is appended to `<body>` and is of type `<iron-overlay-backdrop>`.\n  See its doc page for styling options.\n\n  In addition, `with-backdrop` will wrap the focus within the content in the\n  light DOM. Override the [`_focusableNodes`\n  getter](#Polymer.IronOverlayBehavior:property-_focusableNodes) to achieve a\n  different behavior.\n\n  ### Limitations\n\n  The element is styled to appear on top of other content by setting its\n  `z-index` property. You must ensure no element has a stacking context with a\n  higher `z-index` than its parent stacking context. You should place this\n  element as a child of `<body>` whenever possible.\n\n  @demo demo/index.html\n  @polymerBehavior\n */\nexport const IronOverlayBehavior =\n    [IronFitBehavior, IronResizableBehavior, IronOverlayBehaviorImpl];\n\n/**\n * Fired after the overlay opens.\n * @event iron-overlay-opened\n */\n\n/**\n * Fired when the overlay is canceled, but before it is closed.\n * @event iron-overlay-canceled\n * @param {Event} event The closing of the overlay can be prevented\n * by calling `event.preventDefault()`. The `event.detail` is the original event\n * that originated the canceling (e.g. ESC keyboard event or click event outside\n * the overlay).\n */\n\n/**\n * Fired after the overlay closes.\n * @event iron-overlay-closed\n * @param {Event} event The `event.detail` is the `closingReason` property\n * (contains `canceled`, whether the overlay was canceled).\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}