{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar _window;\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-set.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { RangeChangedEvent, VisibilityChangedEvent, UnpinnedEvent } from './events.js';\nimport { ScrollerController } from './ScrollerController.js';\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nvar _ResizeObserver = (_window = window) === null || _window === void 0 ? void 0 : _window.ResizeObserver;\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor) {\n  _ResizeObserver = Ctor;\n}\nexport var virtualizerRef = Symbol('virtualizerRef');\nvar SIZER_ATTRIBUTE = 'virtualizer-sizer';\nvar DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport var Virtualizer = /*#__PURE__*/function () {\n  function Virtualizer(config) {\n    _classCallCheck(this, Virtualizer);\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    /**\n     * Layout initialization is async because we dynamically load\n     * the default layout if none is specified. This state is to track\n     * whether init is complete.\n     */\n    this._layoutInitialized = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  _createClass(Virtualizer, [{\n    key: \"items\",\n    set: function set(items) {\n      if (Array.isArray(items) && items !== this._items) {\n        this._itemsChanged = true;\n        this._items = items;\n        this._schedule(this._updateLayout);\n      }\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(config) {\n      this._isScroller = !!config.scroller;\n      this._initHostElement(config);\n      // If no layout is specified, we make an empty\n      // layout config, which will result in the default\n      // layout with default parameters\n      var layoutConfig = config.layout || {};\n      // Save the promise returned by `_initLayout` as a state\n      // variable we can check before updating layout config\n      this._layoutInitialized = this._initLayout(layoutConfig);\n    }\n  }, {\n    key: \"_initObservers\",\n    value: function _initObservers() {\n      var _this = this;\n      this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n      this._hostElementRO = new _ResizeObserver(function () {\n        return _this._hostElementSizeChanged();\n      });\n      this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));\n    }\n  }, {\n    key: \"_initHostElement\",\n    value: function _initHostElement(config) {\n      var hostElement = this._hostElement = config.hostElement;\n      this._applyVirtualizerStyles();\n      hostElement[virtualizerRef] = this;\n    }\n  }, {\n    key: \"connected\",\n    value: function connected() {\n      this._initObservers();\n      var includeSelf = this._isScroller;\n      this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n      this._scrollerController = new ScrollerController(this, this._clippingAncestors[0]);\n      this._schedule(this._updateLayout);\n      this._observeAndListen();\n    }\n  }, {\n    key: \"_observeAndListen\",\n    value: function _observeAndListen() {\n      var _this2 = this;\n      this._mutationObserver.observe(this._hostElement, {\n        childList: true\n      });\n      this._hostElementRO.observe(this._hostElement);\n      this._scrollEventListeners.push(window);\n      window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._clippingAncestors.forEach(function (ancestor) {\n        ancestor.addEventListener('scroll', _this2, _this2._scrollEventListenerOptions);\n        _this2._scrollEventListeners.push(ancestor);\n        _this2._hostElementRO.observe(ancestor);\n      });\n      this._hostElementRO.observe(this._scrollerController.element);\n      this._children.forEach(function (child) {\n        return _this2._childrenRO.observe(child);\n      });\n      this._scrollEventListeners.forEach(function (target) {\n        return target.addEventListener('scroll', _this2, _this2._scrollEventListenerOptions);\n      });\n    }\n  }, {\n    key: \"disconnected\",\n    value: function disconnected() {\n      var _this3 = this,\n        _this$_scrollerContro,\n        _this$_mutationObserv,\n        _this$_hostElementRO,\n        _this$_childrenRO;\n      this._scrollEventListeners.forEach(function (target) {\n        return target.removeEventListener('scroll', _this3, _this3._scrollEventListenerOptions);\n      });\n      this._scrollEventListeners = [];\n      this._clippingAncestors = [];\n      (_this$_scrollerContro = this._scrollerController) === null || _this$_scrollerContro === void 0 || _this$_scrollerContro.detach(this);\n      this._scrollerController = null;\n      (_this$_mutationObserv = this._mutationObserver) === null || _this$_mutationObserv === void 0 || _this$_mutationObserv.disconnect();\n      this._mutationObserver = null;\n      (_this$_hostElementRO = this._hostElementRO) === null || _this$_hostElementRO === void 0 || _this$_hostElementRO.disconnect();\n      this._hostElementRO = null;\n      (_this$_childrenRO = this._childrenRO) === null || _this$_childrenRO === void 0 || _this$_childrenRO.disconnect();\n      this._childrenRO = null;\n      this._rejectLayoutCompletePromise('disconnected');\n    }\n  }, {\n    key: \"_applyVirtualizerStyles\",\n    value: function _applyVirtualizerStyles() {\n      var hostElement = this._hostElement;\n      // Would rather set these CSS properties on the host using Shadow Root\n      // style scoping (and falling back to a global stylesheet where native\n      // Shadow DOM is not available), but this Mobile Safari bug is preventing\n      // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n      var style = hostElement.style;\n      style.display = style.display || 'block';\n      style.position = style.position || 'relative';\n      style.contain = style.contain || 'size layout';\n      if (this._isScroller) {\n        style.overflow = style.overflow || 'auto';\n        style.minHeight = style.minHeight || '150px';\n      }\n    }\n  }, {\n    key: \"_getSizer\",\n    value: function _getSizer() {\n      var hostElement = this._hostElement;\n      if (!this._sizer) {\n        // Use a preexisting sizer element if provided (for better integration\n        // with vDOM renderers)\n        var sizer = hostElement.querySelector(\"[\".concat(SIZER_ATTRIBUTE, \"]\"));\n        if (!sizer) {\n          sizer = document.createElement('div');\n          sizer.setAttribute(SIZER_ATTRIBUTE, '');\n          hostElement.appendChild(sizer);\n        }\n        // When the scrollHeight is large, the height of this element might be\n        // ignored. Setting content and font-size ensures the element has a size.\n        Object.assign(sizer.style, {\n          position: 'absolute',\n          margin: '-2px 0 0 0',\n          padding: 0,\n          visibility: 'hidden',\n          fontSize: '2px'\n        });\n        sizer.textContent = '&nbsp;';\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        this._sizer = sizer;\n      }\n      return this._sizer;\n    }\n  }, {\n    key: \"updateLayoutConfig\",\n    value: function () {\n      var _updateLayoutConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(layoutConfig) {\n        var Ctor, config;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._layoutInitialized;\n            case 2:\n              Ctor = layoutConfig.type ||\n              // The new config is compatible with the current layout,\n              // so we update the config and return true to indicate\n              // a successful update\n              DefaultLayoutConstructor;\n              if (!(typeof Ctor === 'function' && this._layout instanceof Ctor)) {\n                _context.next = 8;\n                break;\n              }\n              config = Object.assign({}, layoutConfig);\n              delete config.type;\n              this._layout.config = config;\n              // The new config requires a different layout altogether, but\n              // to limit implementation complexity we don't support dynamically\n              // changing the layout of an existing virtualizer instance.\n              // Returning false here lets the caller know that they should\n              // instead make a new virtualizer instance with the desired layout.\n              return _context.abrupt(\"return\", true);\n            case 8:\n              return _context.abrupt(\"return\", false);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function updateLayoutConfig(_x) {\n        return _updateLayoutConfig.apply(this, arguments);\n      }\n      return updateLayoutConfig;\n    }()\n  }, {\n    key: \"_initLayout\",\n    value: function () {\n      var _initLayout2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(layoutConfig) {\n        var _this4 = this;\n        var config, Ctor, copy;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (typeof layoutConfig.type === 'function') {\n                // If we have a full LayoutSpecifier, the `type` property\n                // gives us our constructor...\n                Ctor = layoutConfig.type;\n                // ...while the rest of the specifier is our layout config\n                copy = Object.assign({}, layoutConfig);\n                delete copy.type;\n                config = copy;\n              } else {\n                // If we don't have a full LayoutSpecifier, we just\n                // have a config for the default layout\n                config = layoutConfig;\n              }\n              if (!(Ctor === undefined)) {\n                _context2.next = 5;\n                break;\n              }\n              _context2.next = 4;\n              return import('./layouts/flow.js');\n            case 4:\n              DefaultLayoutConstructor = Ctor = _context2.sent.FlowLayout;\n            case 5:\n              this._layout = new Ctor(function (message) {\n                return _this4._handleLayoutMessage(message);\n              }, config);\n              if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n                if (typeof this._layout.measureChildren === 'function') {\n                  this._measureChildOverride = this._layout.measureChildren;\n                }\n                this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n              }\n              if (this._layout.listenForChildLoadEvents) {\n                this._hostElement.addEventListener('load', this._loadListener, true);\n              }\n              this._schedule(this._updateLayout);\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _initLayout(_x2) {\n        return _initLayout2.apply(this, arguments);\n      }\n      return _initLayout;\n    }() // TODO (graynorton): Rework benchmarking so that it has no API and\n    // instead is always on except in production builds\n  }, {\n    key: \"startBenchmarking\",\n    value: function startBenchmarking() {\n      if (this._benchmarkStart === null) {\n        this._benchmarkStart = window.performance.now();\n      }\n    }\n  }, {\n    key: \"stopBenchmarking\",\n    value: function stopBenchmarking() {\n      var _this5 = this;\n      if (this._benchmarkStart !== null) {\n        var now = window.performance.now();\n        var timeElapsed = now - this._benchmarkStart;\n        var entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n        var virtualizationTime = entries.filter(function (e) {\n          return e.startTime >= _this5._benchmarkStart && e.startTime < now;\n        }).reduce(function (t, m) {\n          return t + m.duration;\n        }, 0);\n        this._benchmarkStart = null;\n        return {\n          timeElapsed: timeElapsed,\n          virtualizationTime: virtualizationTime\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"_measureChildren\",\n    value: function _measureChildren() {\n      var mm = {};\n      var children = this._children;\n      var fn = this._measureChildOverride || this._measureChild;\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var idx = this._first + i;\n        if (this._itemsChanged || this._toBeMeasured.has(child)) {\n          mm[idx] = fn.call(this, child, this._items[idx]);\n        }\n      }\n      this._childMeasurements = mm;\n      this._schedule(this._updateLayout);\n      this._toBeMeasured.clear();\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     */\n  }, {\n    key: \"_measureChild\",\n    value: function _measureChild(element) {\n      // offsetWidth doesn't take transforms in consideration, so we use\n      // getBoundingClientRect which does.\n      var _element$getBoundingC = element.getBoundingClientRect(),\n        width = _element$getBoundingC.width,\n        height = _element$getBoundingC.height;\n      return Object.assign({\n        width: width,\n        height: height\n      }, getMargins(element));\n    }\n  }, {\n    key: \"_schedule\",\n    value: function () {\n      var _schedule2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(method) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this._scheduled.has(method)) {\n                _context3.next = 6;\n                break;\n              }\n              this._scheduled.add(method);\n              _context3.next = 4;\n              return Promise.resolve();\n            case 4:\n              this._scheduled.delete(method);\n              method.call(this);\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _schedule(_x3) {\n        return _schedule2.apply(this, arguments);\n      }\n      return _schedule;\n    }()\n  }, {\n    key: \"_updateDOM\",\n    value: function () {\n      var _updateDOM2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(state) {\n        var _rangeChanged, _itemsChanged;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              this._scrollSize = state.scrollSize;\n              this._adjustRange(state.range);\n              this._childrenPos = state.childPositions;\n              this._scrollError = state.scrollError || null;\n              _rangeChanged = this._rangeChanged, _itemsChanged = this._itemsChanged;\n              if (this._visibilityChanged) {\n                this._notifyVisibility();\n                this._visibilityChanged = false;\n              }\n              if (_rangeChanged || _itemsChanged) {\n                this._notifyRange();\n                this._rangeChanged = false;\n              }\n              this._finishDOMUpdate();\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _updateDOM(_x4) {\n        return _updateDOM2.apply(this, arguments);\n      }\n      return _updateDOM;\n    }()\n  }, {\n    key: \"_finishDOMUpdate\",\n    value: function _finishDOMUpdate() {\n      var _this6 = this;\n      this._children.forEach(function (child) {\n        return _this6._childrenRO.observe(child);\n      });\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout() {\n      // Only update the layout and trigger a re-render if we have:\n      //   a) A layout\n      //   b) A scrollerController, which means we're connected\n      if (this._layout && this._scrollerController) {\n        this._layout.items = this._items;\n        this._updateView();\n        if (this._childMeasurements !== null) {\n          // If the layout has been changed, we may have measurements but no callback\n          if (this._measureCallback) {\n            this._measureCallback(this._childMeasurements);\n          }\n          this._childMeasurements = null;\n        }\n        this._layout.reflowIfNeeded();\n        if (this._benchmarkStart && 'mark' in window.performance) {\n          window.performance.mark('uv-end');\n        }\n      }\n    }\n  }, {\n    key: \"_handleScrollEvent\",\n    value: function _handleScrollEvent() {\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        try {\n          window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n        } catch (e) {\n          console.warn('Error measuring performance data: ', e);\n        }\n        window.performance.mark('uv-start');\n      }\n      if (this._scrollerController.correctingScrollError === false) {\n        var _this$_layout;\n        // This is a user-initiated scroll, so we unpin the layout\n        (_this$_layout = this._layout) === null || _this$_layout === void 0 || _this$_layout.unpin();\n      }\n      this._schedule(this._updateLayout);\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      switch (event.type) {\n        case 'scroll':\n          if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n            this._handleScrollEvent();\n          }\n          break;\n        default:\n          console.warn('event not handled', event);\n      }\n    }\n  }, {\n    key: \"_handleLayoutMessage\",\n    value: function _handleLayoutMessage(message) {\n      if (message.type === 'stateChanged') {\n        this._updateDOM(message);\n      } else if (message.type === 'visibilityChanged') {\n        this._firstVisible = message.firstVisible;\n        this._lastVisible = message.lastVisible;\n        this._notifyVisibility();\n      } else if (message.type === 'unpinned') {\n        this._hostElement.dispatchEvent(new UnpinnedEvent());\n      }\n    }\n  }, {\n    key: \"_children\",\n    get: function get() {\n      var arr = [];\n      var next = this._hostElement.firstElementChild;\n      while (next) {\n        if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n          arr.push(next);\n        }\n        next = next.nextElementSibling;\n      }\n      return arr;\n    }\n  }, {\n    key: \"_updateView\",\n    value: function _updateView() {\n      var _this$_scrollerContro2;\n      var hostElement = this._hostElement;\n      var scrollingElement = (_this$_scrollerContro2 = this._scrollerController) === null || _this$_scrollerContro2 === void 0 ? void 0 : _this$_scrollerContro2.element;\n      var layout = this._layout;\n      if (hostElement && scrollingElement && layout) {\n        var top, left, bottom, right;\n        var hostElementBounds = hostElement.getBoundingClientRect();\n        top = 0;\n        left = 0;\n        bottom = window.innerHeight;\n        right = window.innerWidth;\n        var ancestorBounds = this._clippingAncestors.map(function (ancestor) {\n          return ancestor.getBoundingClientRect();\n        });\n        ancestorBounds.unshift(hostElementBounds);\n        var _iterator = _createForOfIteratorHelper(ancestorBounds),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var bounds = _step.value;\n            top = Math.max(top, bounds.top);\n            left = Math.max(left, bounds.left);\n            bottom = Math.min(bottom, bounds.bottom);\n            right = Math.min(right, bounds.right);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var scrollingElementBounds = scrollingElement.getBoundingClientRect();\n        var offsetWithinScroller = {\n          left: hostElementBounds.left - scrollingElementBounds.left,\n          top: hostElementBounds.top - scrollingElementBounds.top\n        };\n        var totalScrollSize = {\n          width: scrollingElement.scrollWidth,\n          height: scrollingElement.scrollHeight\n        };\n        var scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n        var scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n        var height = bottom - top;\n        var width = right - left;\n        layout.viewportSize = {\n          width: width,\n          height: height\n        };\n        layout.viewportScroll = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n        layout.totalScrollSize = totalScrollSize;\n        layout.offsetWithinScroller = offsetWithinScroller;\n      }\n    }\n    /**\n     * Styles the host element so that its size reflects the\n     * total size of all items.\n     */\n  }, {\n    key: \"_sizeHostElement\",\n    value: function _sizeHostElement(size) {\n      // Some browsers seem to crap out if the host element gets larger than\n      // a certain size, so we clamp it here (this value based on ad hoc\n      // testing in Chrome / Safari / Firefox Mac)\n      var max = 8200000;\n      var h = size && size.width !== null ? Math.min(max, size.width) : 0;\n      var v = size && size.height !== null ? Math.min(max, size.height) : 0;\n      if (this._isScroller) {\n        this._getSizer().style.transform = \"translate(\".concat(h, \"px, \").concat(v, \"px)\");\n      } else {\n        var style = this._hostElement.style;\n        style.minWidth = h ? \"\".concat(h, \"px\") : '100%';\n        style.minHeight = v ? \"\".concat(v, \"px\") : '100%';\n      }\n    }\n    /**\n     * Sets the top and left transform style of the children from the values in\n     * pos.\n     */\n  }, {\n    key: \"_positionChildren\",\n    value: function _positionChildren(pos) {\n      var _this7 = this;\n      if (pos) {\n        pos.forEach(function (_ref, index) {\n          var top = _ref.top,\n            left = _ref.left,\n            width = _ref.width,\n            height = _ref.height,\n            xOffset = _ref.xOffset,\n            yOffset = _ref.yOffset;\n          var child = _this7._children[index - _this7._first];\n          if (child) {\n            child.style.position = 'absolute';\n            child.style.boxSizing = 'border-box';\n            child.style.transform = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n            if (width !== undefined) {\n              child.style.width = width + 'px';\n            }\n            if (height !== undefined) {\n              child.style.height = height + 'px';\n            }\n            child.style.left = xOffset === undefined ? null : xOffset + 'px';\n            child.style.top = yOffset === undefined ? null : yOffset + 'px';\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_adjustRange\",\n    value: function () {\n      var _adjustRange2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(range) {\n        var _first, _last, _firstVisible, _lastVisible;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _first = this._first, _last = this._last, _firstVisible = this._firstVisible, _lastVisible = this._lastVisible;\n              this._first = range.first;\n              this._last = range.last;\n              this._firstVisible = range.firstVisible;\n              this._lastVisible = range.lastVisible;\n              this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n              this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _adjustRange(_x5) {\n        return _adjustRange2.apply(this, arguments);\n      }\n      return _adjustRange;\n    }()\n  }, {\n    key: \"_correctScrollError\",\n    value: function _correctScrollError() {\n      if (this._scrollError) {\n        var _this$_scrollerContro3 = this._scrollerController,\n          scrollTop = _this$_scrollerContro3.scrollTop,\n          scrollLeft = _this$_scrollerContro3.scrollLeft;\n        var _this$_scrollError = this._scrollError,\n          top = _this$_scrollError.top,\n          left = _this$_scrollError.left;\n        this._scrollError = null;\n        this._scrollerController.correctScrollError({\n          top: scrollTop - top,\n          left: scrollLeft - left\n        });\n      }\n    }\n  }, {\n    key: \"element\",\n    value: function element(index) {\n      var _this$_items,\n        _this8 = this;\n      if (index === Infinity) {\n        index = this._items.length - 1;\n      }\n      return ((_this$_items = this._items) === null || _this$_items === void 0 ? void 0 : _this$_items[index]) === undefined ? undefined : {\n        scrollIntoView: function scrollIntoView() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return _this8._scrollElementIntoView(Object.assign(Object.assign({}, options), {}, {\n            index: index\n          }));\n        }\n      };\n    }\n  }, {\n    key: \"_scrollElementIntoView\",\n    value: function _scrollElementIntoView(options) {\n      var _this9 = this;\n      if (options.index >= this._first && options.index <= this._last) {\n        this._children[options.index - this._first].scrollIntoView(options);\n      } else {\n        options.index = Math.min(options.index, this._items.length - 1);\n        if (options.behavior === 'smooth') {\n          var coordinates = this._layout.getScrollIntoViewCoordinates(options);\n          var behavior = options.behavior;\n          this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n            behavior: behavior\n          }), function () {\n            return _this9._layout.getScrollIntoViewCoordinates(options);\n          }, function () {\n            return _this9._scrollIntoViewTarget = null;\n          });\n          this._scrollIntoViewTarget = options;\n        } else {\n          this._layout.pin = options;\n        }\n      }\n    }\n    /**\n     * If we are smoothly scrolling to an element and the target element\n     * is in the DOM, we update our target coordinates as needed\n     */\n  }, {\n    key: \"_checkScrollIntoViewTarget\",\n    value: function _checkScrollIntoViewTarget(pos) {\n      var _ref2 = this._scrollIntoViewTarget || {},\n        index = _ref2.index;\n      if (index && pos !== null && pos !== void 0 && pos.has(index)) {\n        this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n      }\n    }\n    /**\n     * Emits a rangechange event with the current first, last, firstVisible, and\n     * lastVisible.\n     */\n  }, {\n    key: \"_notifyRange\",\n    value: function _notifyRange() {\n      this._hostElement.dispatchEvent(new RangeChangedEvent({\n        first: this._first,\n        last: this._last\n      }));\n    }\n  }, {\n    key: \"_notifyVisibility\",\n    value: function _notifyVisibility() {\n      this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible\n      }));\n    }\n  }, {\n    key: \"layoutComplete\",\n    get: function get() {\n      var _this10 = this;\n      // Lazily create promise\n      if (!this._layoutCompletePromise) {\n        this._layoutCompletePromise = new Promise(function (resolve, reject) {\n          _this10._layoutCompleteResolver = resolve;\n          _this10._layoutCompleteRejecter = reject;\n        });\n      }\n      return this._layoutCompletePromise;\n    }\n  }, {\n    key: \"_rejectLayoutCompletePromise\",\n    value: function _rejectLayoutCompletePromise(reason) {\n      if (this._layoutCompleteRejecter !== null) {\n        this._layoutCompleteRejecter(reason);\n      }\n      this._resetLayoutCompleteState();\n    }\n  }, {\n    key: \"_scheduleLayoutComplete\",\n    value: function _scheduleLayoutComplete() {\n      var _this11 = this;\n      // Don't do anything unless we have a pending promise\n      // And only request a frame if we haven't already done so\n      if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n        // Wait one additional frame to be sure the layout is stable\n        this._pendingLayoutComplete = requestAnimationFrame(function () {\n          return requestAnimationFrame(function () {\n            return _this11._resolveLayoutCompletePromise();\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_resolveLayoutCompletePromise\",\n    value: function _resolveLayoutCompletePromise() {\n      if (this._layoutCompleteResolver !== null) {\n        this._layoutCompleteResolver();\n      }\n      this._resetLayoutCompleteState();\n    }\n  }, {\n    key: \"_resetLayoutCompleteState\",\n    value: function _resetLayoutCompleteState() {\n      this._layoutCompletePromise = null;\n      this._layoutCompleteResolver = null;\n      this._layoutCompleteRejecter = null;\n      this._pendingLayoutComplete = null;\n    }\n    /**\n     * Render and update the view at the next opportunity with the given\n     * hostElement size.\n     */\n  }, {\n    key: \"_hostElementSizeChanged\",\n    value: function _hostElementSizeChanged() {\n      this._schedule(this._updateLayout);\n    }\n    // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n    // to have dedicated support for; might want some more generic lifecycle hooks for\n    // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n    // a first-class feature?\n  }, {\n    key: \"_childLoaded\",\n    value: function _childLoaded() {}\n    // This is the callback for the ResizeObserver that watches the\n    // virtualizer's children. We land here at the end of every virtualizer\n    // update cycle that results in changes to physical items, and we also\n    // end up here if one or more children change size independently of\n    // the virtualizer update cycle.\n  }, {\n    key: \"_childrenSizeChanged\",\n    value: function _childrenSizeChanged(changes) {\n      var _this$_layout2;\n      // Only measure if the layout requires it\n      if ((_this$_layout2 = this._layout) !== null && _this$_layout2 !== void 0 && _this$_layout2.measureChildren) {\n        var _iterator2 = _createForOfIteratorHelper(changes),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var change = _step2.value;\n            this._toBeMeasured.set(change.target, change.contentRect);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this._measureChildren();\n      }\n      // If this is the end of an update cycle, we need to reset some\n      // internal state. This should be a harmless no-op if we're handling\n      // an out-of-cycle ResizeObserver callback, so we don't need to\n      // distinguish between the two cases.\n      this._scheduleLayoutComplete();\n      this._itemsChanged = false;\n      this._rangeChanged = false;\n    }\n  }]);\n  return Virtualizer;\n}();\nfunction getMargins(el) {\n  var style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  var float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  var parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var ancestors = [];\n  var parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter(function (a) {\n    if (foundFixed) {\n      return false;\n    }\n    var style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}","map":{"version":3,"names":["RangeChangedEvent","VisibilityChangedEvent","UnpinnedEvent","ScrollerController","_ResizeObserver","_window","window","ResizeObserver","provideResizeObserver","Ctor","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","config","_classCallCheck","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","bind","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","_layoutInitialized","Error","hostElement","_init","_createClass","key","set","items","Array","isArray","_schedule","_updateLayout","value","scroller","_initHostElement","layoutConfig","layout","_initLayout","_initObservers","_this","MutationObserver","_finishDOMUpdate","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","connected","includeSelf","getClippingAncestors","_observeAndListen","_this2","observe","childList","push","addEventListener","forEach","ancestor","element","_children","child","target","disconnected","_this3","_this$_scrollerContro","_this$_mutationObserv","_this$_hostElementRO","_this$_childrenRO","removeEventListener","detach","disconnect","_rejectLayoutCompletePromise","style","display","position","contain","overflow","minHeight","_getSizer","sizer","querySelector","concat","document","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","textContent","_updateLayoutConfig","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","type","abrupt","stop","updateLayoutConfig","_x","apply","arguments","_initLayout2","_callee2","_this4","copy","_callee2$","_context2","undefined","sent","FlowLayout","message","_handleLayoutMessage","measureChildren","updateItemSizes","listenForChildLoadEvents","_x2","startBenchmarking","performance","now","stopBenchmarking","_this5","timeElapsed","entries","getEntriesByName","virtualizationTime","filter","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","has","call","clear","_element$getBoundingC","getBoundingClientRect","width","height","getMargins","_schedule2","_callee3","method","_callee3$","_context3","add","Promise","resolve","delete","_x3","_updateDOM2","_callee4","state","_callee4$","_context4","scrollSize","_adjustRange","range","childPositions","scrollError","_notifyVisibility","_notifyRange","_updateDOM","_x4","_this6","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","correctingScrollError","_this$_layout","unpin","handleEvent","event","currentTarget","includes","firstVisible","lastVisible","dispatchEvent","get","arr","firstElementChild","hasAttribute","nextElementSibling","_this$_scrollerContro2","scrollingElement","top","left","bottom","right","hostElementBounds","innerHeight","innerWidth","ancestorBounds","map","unshift","_iterator","_createForOfIteratorHelper","_step","s","n","done","bounds","Math","max","min","err","f","scrollingElementBounds","offsetWithinScroller","totalScrollSize","scrollWidth","scrollHeight","scrollTop","scrollLeft","viewportSize","viewportScroll","size","h","v","transform","minWidth","pos","_this7","_ref","index","xOffset","yOffset","boxSizing","_adjustRange2","_callee5","_callee5$","_context5","first","last","_x5","_this$_scrollerContro3","_this$_scrollError","correctScrollError","_this$_items","_this8","Infinity","scrollIntoView","options","_scrollElementIntoView","_this9","behavior","coordinates","getScrollIntoViewCoordinates","managedScrollTo","pin","_ref2","_this10","reject","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","_this11","requestAnimationFrame","_resolveLayoutCompletePromise","changes","_this$_layout2","_iterator2","_step2","change","contentRect","el","getComputedStyle","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","foundFixed","a"],"sources":["src/Virtualizer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  StateChangedMessage,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  LayoutHostMessage,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver: typeof ResizeObserver | undefined = window?.ResizeObserver;\n\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nexport function provideResizeObserver(Ctor: typeof ResizeObserver) {\n  _ResizeObserver = Ctor;\n}\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured = new Map<HTMLElement, unknown>();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet<Function>();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  /**\n   * Layout initialization is async because we dynamically load\n   * the default layout if none is specified. This state is to track\n   * whether init is complete.\n   */\n  private _layoutInitialized: Promise<void> | null = null;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || ({} as BaseLayoutConfig);\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n\n  private _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    this._hostElementRO = new _ResizeObserver!(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new _ResizeObserver!(\n      this._childrenSizeChanged.bind(this)\n    );\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController?.detach(this);\n    this._scrollerController = null;\n    this._mutationObserver?.disconnect();\n    this._mutationObserver = null;\n    this._hostElementRO?.disconnect();\n    this._hostElementRO = null;\n    this._childrenRO?.disconnect();\n    this._childrenRO = null;\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  async updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      // The new config is compatible with the current layout,\n      // so we update the config and return true to indicate\n      // a successful update\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(\n      (message: LayoutHostMessage) => this._handleLayoutMessage(message),\n      config\n    );\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM(state: StateChangedMessage) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    }\n    this._finishDOMUpdate();\n  }\n\n  _finishDOMUpdate() {\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n\n  _updateLayout() {\n    // Only update the layout and trigger a re-render if we have:\n    //   a) A layout\n    //   b) A scrollerController, which means we're connected\n    if (this._layout && this._scrollerController) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  _handleLayoutMessage(message: LayoutHostMessage) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement!.dispatchEvent(new UnpinnedEvent());\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr: Array<HTMLElement> = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = bottom - top;\n      const width = right - left;\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout?.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors: Array<HTMLElement> = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  let foundFixed = false;\n  return getElementAncestors(el, includeSelf).filter((a) => {\n    if (foundFixed) {\n      return false;\n    }\n    const style = getComputedStyle(a);\n    foundFixed = style.position === 'fixed';\n    return style.overflow !== 'visible';\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}