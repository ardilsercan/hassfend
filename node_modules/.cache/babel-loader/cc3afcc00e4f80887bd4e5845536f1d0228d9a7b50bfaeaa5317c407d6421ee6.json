{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.object.assign.js\";\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\nimport { showHideChildren, templatize } from '../utils/templatize.js';\n\n/**\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Base class for dom-if element; subclassed into concrete\n *   implementation.\n */\nvar DomIfBase = /*#__PURE__*/function (_PolymerElement) {\n  _inherits(DomIfBase, _PolymerElement);\n  function DomIfBase() {\n    var _this;\n    _classCallCheck(this, DomIfBase);\n    _this = _callSuper(this, DomIfBase);\n    _this.__renderDebouncer = null;\n    _this._lastIf = false;\n    _this.__hideTemplateChildren__ = false;\n    /** @type {!HTMLTemplateElement|undefined} */\n    _this.__template;\n    /** @type {!TemplateInfo|undefined} */\n    _this._templateInfo;\n    return _this;\n  }\n  _createClass(DomIfBase, [{\n    key: \"__debounceRender\",\n    value: function __debounceRender() {\n      var _this2 = this;\n      // Render is async for 2 reasons:\n      // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n      //    same turn. This was more common in 1.x where a compound computed\n      //    property could result in the result changing multiple times, but is\n      //    mitigated to a large extent by batched property processing in 2.x.\n      // 2. To avoid double object propagation when a bag including values bound\n      //    to the `if` property as well as one or more hostProps could enqueue\n      //    the <dom-if> to flush before the <template>'s host property\n      //    forwarding. In that scenario creating an instance would result in\n      //    the host props being set once, and then the enqueued changes on the\n      //    template would set properties a second time, potentially causing an\n      //    object to be set to an instance more than once.  Creating the\n      //    instance async from flushing data ensures this doesn't happen. If\n      //    we wanted a sync option in the future, simply having <dom-if> flush\n      //    (or clear) its template's pending host properties before creating\n      //    the instance would also avoid the problem.\n      this.__renderDebouncer = Debouncer.debounce(this.__renderDebouncer, microTask, function () {\n        return _this2.__render();\n      });\n      enqueueDebouncer(this.__renderDebouncer);\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(DomIfBase.prototype), \"disconnectedCallback\", this).call(this);\n      var parent = wrap(this).parentNode;\n      if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap(parent).host) {\n        this.__teardownInstance();\n      }\n    }\n\n    /**\n     * @override\n     * @return {void}\n     */\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(DomIfBase.prototype), \"connectedCallback\", this).call(this);\n      if (!hideElementsGlobally()) {\n        this.style.display = 'none';\n      }\n      if (this.if) {\n        this.__debounceRender();\n      }\n    }\n\n    /**\n     * Ensures a template has been assigned to `this.__template`.  If it has not\n     * yet been, it querySelectors for it in its children and if it does not yet\n     * exist (e.g. in parser-generated case), opens a mutation observer and\n     * waits for it to appear (returns false if it has not yet been found,\n     * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\n     * be the `dom-if` element itself.\n     *\n     * @return {boolean} True when a template has been found, false otherwise\n     */\n  }, {\n    key: \"__ensureTemplate\",\n    value: function __ensureTemplate() {\n      var _this3 = this;\n      if (!this.__template) {\n        // When `removeNestedTemplates` is true, the \"template\" is the element\n        // itself, which has been given a `_templateInfo` property\n        var thisAsTemplate = /** @type {!HTMLTemplateElement} */\n        /** @type {!HTMLElement} */this;\n        var template = thisAsTemplate._templateInfo ? thisAsTemplate : ( /** @type {!HTMLTemplateElement} */\n        wrap(thisAsTemplate).querySelector('template'));\n        if (!template) {\n          // Wait until childList changes and template should be there by then\n          var observer = new MutationObserver(function () {\n            if (wrap(_this3).querySelector('template')) {\n              observer.disconnect();\n              _this3.__render();\n            } else {\n              throw new Error('dom-if requires a <template> child');\n            }\n          });\n          observer.observe(this, {\n            childList: true\n          });\n          return false;\n        }\n        this.__template = template;\n      }\n      return true;\n    }\n\n    /**\n     * Ensures a an instance of the template has been created and inserted. This\n     * method may return false if the template has not yet been found or if\n     * there is no `parentNode` to insert the template into (in either case,\n     * connection or the template-finding mutation observer firing will queue\n     * another render, causing this method to be called again at a more\n     * appropriate time).\n     *\n     * Subclasses should implement the following methods called here:\n     * - `__hasInstance`\n     * - `__createAndInsertInstance`\n     * - `__getInstanceNodes`\n     *\n     * @return {boolean} True if the instance was created, false otherwise.\n     */\n  }, {\n    key: \"__ensureInstance\",\n    value: function __ensureInstance() {\n      var parentNode = wrap(this).parentNode;\n      if (!this.__hasInstance()) {\n        // Guard against element being detached while render was queued\n        if (!parentNode) {\n          return false;\n        }\n        // Find the template (when false, there was no template yet)\n        if (!this.__ensureTemplate()) {\n          return false;\n        }\n        this.__createAndInsertInstance(parentNode);\n      } else {\n        // Move instance children if necessary\n        var children = this.__getInstanceNodes();\n        if (children && children.length) {\n          // Detect case where dom-if was re-attached in new position\n          var lastChild = wrap(this).previousSibling;\n          if (lastChild !== children[children.length - 1]) {\n            for (var i = 0, n; i < children.length && (n = children[i]); i++) {\n              wrap(parentNode).insertBefore(n, this);\n            }\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Forces the element to render its content. Normally rendering is\n     * asynchronous to a provoking change. This is done for efficiency so\n     * that multiple changes trigger only a single render. The render method\n     * should be called if, for example, template rendering is required to\n     * validate application state.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      flush();\n    }\n\n    /**\n     * Performs the key rendering steps:\n     * 1. Ensure a template instance has been stamped (when true)\n     * 2. Remove the template instance (when false and restamp:true)\n     * 3. Sync the hidden state of the instance nodes with the if/restamp state\n     * 4. Fires the `dom-change` event when necessary\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"__render\",\n    value: function __render() {\n      if (this.if) {\n        if (!this.__ensureInstance()) {\n          // No template found yet\n          return;\n        }\n      } else if (this.restamp) {\n        this.__teardownInstance();\n      }\n      this._showHideChildren();\n      if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {\n        this.dispatchEvent(new CustomEvent('dom-change', {\n          bubbles: true,\n          composed: true\n        }));\n        this._lastIf = this.if;\n      }\n    }\n\n    // Ideally these would be annotated as abstract methods in an abstract class,\n    // but closure compiler is finnicky\n    /* eslint-disable valid-jsdoc */\n    /**\n     * Abstract API to be implemented by subclass: Returns true if a template\n     * instance has been created and inserted.\n     *\n     * @protected\n     * @return {boolean} True when an instance has been created.\n     */\n  }, {\n    key: \"__hasInstance\",\n    value: function __hasInstance() {}\n\n    /**\n     * Abstract API to be implemented by subclass: Returns the child nodes stamped\n     * from a template instance.\n     *\n     * @protected\n     * @return {Array<Node>} Array of child nodes stamped from the template\n     * instance.\n     */\n  }, {\n    key: \"__getInstanceNodes\",\n    value: function __getInstanceNodes() {}\n\n    /**\n     * Abstract API to be implemented by subclass: Creates an instance of the\n     * template and inserts it into the given parent node.\n     *\n     * @protected\n     * @param {Node} parentNode The parent node to insert the instance into\n     * @return {void}\n     */\n  }, {\n    key: \"__createAndInsertInstance\",\n    value: function __createAndInsertInstance(parentNode) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Abstract API to be implemented by subclass: Removes nodes created by an\n     * instance of a template and any associated cleanup.\n     *\n     * @protected\n     * @return {void}\n     */\n  }, {\n    key: \"__teardownInstance\",\n    value: function __teardownInstance() {}\n\n    /**\n     * Abstract API to be implemented by subclass: Shows or hides any template\n     * instance childNodes based on the `if` state of the element and its\n     * `__hideTemplateChildren__` property.\n     *\n     * @protected\n     * @return {void}\n     */\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren() {}\n    /* eslint-enable valid-jsdoc */\n  }], [{\n    key: \"is\",\n    get:\n    // Not needed to find template; can be removed once the analyzer\n    // can find the tag name from customElements.define call\n    function get() {\n      return 'dom-if';\n    }\n  }, {\n    key: \"template\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        /**\n         * Fired whenever DOM is added or removed/hidden by this template (by\n         * default, rendering occurs lazily).  To force immediate rendering, call\n         * `render`.\n         *\n         * @event dom-change\n         */\n\n        /**\n         * A boolean indicating whether this template should stamp.\n         */\n        if: {\n          type: Boolean,\n          observer: '__debounceRender'\n        },\n        /**\n         * When true, elements will be removed from DOM and discarded when `if`\n         * becomes false and re-created and added back to the DOM when `if`\n         * becomes true.  By default, stamped elements will be hidden but left\n         * in the DOM when `if` becomes false, which is generally results\n         * in better performance.\n         */\n        restamp: {\n          type: Boolean,\n          observer: '__debounceRender'\n        },\n        /**\n         * When the global `suppressTemplateNotifications` setting is used, setting\n         * `notifyDomChange: true` will enable firing `dom-change` events on this\n         * element.\n         */\n        notifyDomChange: {\n          type: Boolean\n        }\n      };\n    }\n  }]);\n  return DomIfBase;\n}(PolymerElement);\n/**\n * The version of DomIf used when `fastDomIf` setting is in use, which is\n * optimized for first-render (but adds a tax to all subsequent property updates\n * on the host, whether they were used in a given `dom-if` or not).\n *\n * This implementation avoids use of `Templatizer`, which introduces a new scope\n * (a non-element PropertyEffects instance), which is not strictly necessary\n * since `dom-if` never introduces new properties to its scope (unlike\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\n * `__dataHost` and stamps the template directly from the host using the host's\n * runtime `_stampTemplate` API, which binds the property effects of the\n * template directly to the host. This both avoids the intermediary\n * `Templatizer` instance, but also avoids the need to bind host properties to\n * the `<template>` element and forward those into the template instance.\n *\n * In this version of `dom-if`, the `this.__instance` method is the\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\n * handle for later removing it using the `_removeBoundDom` method.\n */\nvar DomIfFast = /*#__PURE__*/function (_DomIfBase) {\n  _inherits(DomIfFast, _DomIfBase);\n  function DomIfFast() {\n    var _this4;\n    _classCallCheck(this, DomIfFast);\n    _this4 = _callSuper(this, DomIfFast);\n    _this4.__instance = null;\n    _this4.__syncInfo = null;\n    return _this4;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  _createClass(DomIfFast, [{\n    key: \"__hasInstance\",\n    value: function __hasInstance() {\n      return Boolean(this.__instance);\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * @override\n     * @return {Array<Node>} Array of child nodes stamped from the template\n     * instance.\n     */\n  }, {\n    key: \"__getInstanceNodes\",\n    value: function __getInstanceNodes() {\n      return this.__instance.templateInfo.childNodes;\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\n     * element and then inserts the resulting nodes into the given `parentNode`.\n     *\n     * @override\n     * @param {Node} parentNode The parent node to insert the instance into\n     * @return {void}\n     */\n  }, {\n    key: \"__createAndInsertInstance\",\n    value: function __createAndInsertInstance(parentNode) {\n      var _this5 = this;\n      var host = this.__dataHost || this;\n      if (strictTemplatePolicy) {\n        if (!this.__dataHost) {\n          throw new Error('strictTemplatePolicy: template owner not trusted');\n        }\n      }\n      // Pre-bind and link the template into the effects system\n      var templateInfo = host._bindTemplate( /** @type {!HTMLTemplateElement} */this.__template, true);\n      // Install runEffects hook that prevents running property effects\n      // (and any nested template effects) when the `if` is false\n      templateInfo.runEffects = function (runEffects, changedProps, hasPaths) {\n        var syncInfo = _this5.__syncInfo;\n        if (_this5.if) {\n          // Mix any props that changed while the `if` was false into `changedProps`\n          if (syncInfo) {\n            // If there were properties received while the `if` was false, it is\n            // important to sync the hidden state with the element _first_, so that\n            // new bindings to e.g. `textContent` do not get stomped on by\n            // pre-hidden values if `_showHideChildren` were to be called later at\n            // the next render. Clearing `__invalidProps` here ensures\n            // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\n            // that we don't call `runEffects` more often than necessary.\n            _this5.__syncInfo = null;\n            _this5._showHideChildren();\n            changedProps = Object.assign(syncInfo.changedProps, changedProps);\n          }\n          runEffects(changedProps, hasPaths);\n        } else {\n          // Accumulate any values changed while `if` was false, along with the\n          // runEffects method to sync them, so that we can replay them once `if`\n          // becomes true\n          if (_this5.__instance) {\n            if (!syncInfo) {\n              syncInfo = _this5.__syncInfo = {\n                runEffects: runEffects,\n                changedProps: {}\n              };\n            }\n            if (hasPaths) {\n              // Store root object of any paths; this will ensure direct bindings\n              // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\n              // note that path notifications like `set('obj.foo.bar', v)` will\n              // not propagate. Since batched path notifications are not\n              // supported, we cannot simply accumulate path notifications. This\n              // is equivalent to the non-fastDomIf case, which stores root(p) in\n              // __invalidProps.\n              for (var p in changedProps) {\n                var rootProp = root(p);\n                syncInfo.changedProps[rootProp] = _this5.__dataHost[rootProp];\n              }\n            } else {\n              Object.assign(syncInfo.changedProps, changedProps);\n            }\n          }\n        }\n      };\n      // Stamp the template, and set its DocumentFragment to the \"instance\"\n      this.__instance = host._stampTemplate( /** @type {!HTMLTemplateElement} */this.__template, templateInfo);\n      wrap(parentNode).insertBefore(this.__instance, this);\n    }\n\n    /**\n     * Run effects for any properties that changed while the `if` was false.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"__syncHostProperties\",\n    value: function __syncHostProperties() {\n      var syncInfo = this.__syncInfo;\n      if (syncInfo) {\n        this.__syncInfo = null;\n        syncInfo.runEffects(syncInfo.changedProps, false);\n      }\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\n     * runtime `_removeBoundDom` method.\n     *\n     * @override\n     * @return {void}\n     */\n  }, {\n    key: \"__teardownInstance\",\n    value: function __teardownInstance() {\n      var host = this.__dataHost || this;\n      if (this.__instance) {\n        host._removeBoundDom(this.__instance);\n        this.__instance = null;\n        this.__syncInfo = null;\n      }\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Shows or hides the template instance top level child nodes. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     *\n     * @override\n     * @return {void}\n     * @protected\n     * @suppress {visibility}\n     */\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren() {\n      var hidden = this.__hideTemplateChildren__ || !this.if;\n      if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n        this.__instance.__hidden = hidden;\n        showHideChildren(hidden, this.__instance.templateInfo.childNodes);\n      }\n      if (!hidden) {\n        this.__syncHostProperties();\n      }\n    }\n  }]);\n  return DomIfFast;\n}(DomIfBase);\n/**\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\n *\n * In this version, `this.__instance` is the `TemplateInstance` returned\n * from the templatized constructor.\n */\nvar DomIfLegacy = /*#__PURE__*/function (_DomIfBase2) {\n  _inherits(DomIfLegacy, _DomIfBase2);\n  function DomIfLegacy() {\n    var _this6;\n    _classCallCheck(this, DomIfLegacy);\n    _this6 = _callSuper(this, DomIfLegacy);\n    _this6.__ctor = null;\n    _this6.__instance = null;\n    _this6.__invalidProps = null;\n    return _this6;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  _createClass(DomIfLegacy, [{\n    key: \"__hasInstance\",\n    value: function __hasInstance() {\n      return Boolean(this.__instance);\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * @override\n     * @return {Array<Node>} Array of child nodes stamped from the template\n     * instance.\n     */\n  }, {\n    key: \"__getInstanceNodes\",\n    value: function __getInstanceNodes() {\n      return this.__instance.children;\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Stamps the template by creating a new instance of the templatized\n     * constructor (which is created lazily if it does not yet exist), and then\n     * inserts its resulting `root` doc fragment into the given `parentNode`.\n     *\n     * @override\n     * @param {Node} parentNode The parent node to insert the instance into\n     * @return {void}\n     */\n  }, {\n    key: \"__createAndInsertInstance\",\n    value: function __createAndInsertInstance(parentNode) {\n      // Ensure we have an instance constructor\n      if (!this.__ctor) {\n        this.__ctor = templatize( /** @type {!HTMLTemplateElement} */this.__template, this, {\n          // dom-if templatizer instances require `mutable: true`, as\n          // `__syncHostProperties` relies on that behavior to sync objects\n          mutableData: true,\n          /**\n           * @param {string} prop Property to forward\n           * @param {*} value Value of property\n           * @this {DomIfLegacy}\n           */\n          forwardHostProp: function forwardHostProp(prop, value) {\n            if (this.__instance) {\n              if (this.if) {\n                this.__instance.forwardHostProp(prop, value);\n              } else {\n                // If we have an instance but are squelching host property\n                // forwarding due to if being false, note the invalidated\n                // properties so `__syncHostProperties` can sync them the next\n                // time `if` becomes true\n                this.__invalidProps = this.__invalidProps || Object.create(null);\n                this.__invalidProps[root(prop)] = true;\n              }\n            }\n          }\n        });\n      }\n      // Create and insert the instance\n      this.__instance = new this.__ctor();\n      wrap(parentNode).insertBefore(this.__instance.root, this);\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Removes the instance and any nodes it created.\n     *\n     * @override\n     * @return {void}\n     */\n  }, {\n    key: \"__teardownInstance\",\n    value: function __teardownInstance() {\n      if (this.__instance) {\n        var c$ = this.__instance.children;\n        if (c$ && c$.length) {\n          // use first child parent, for case when dom-if may have been detached\n          var parent = wrap(c$[0]).parentNode;\n          // Instance children may be disconnected from parents when dom-if\n          // detaches if a tree was innerHTML'ed\n          if (parent) {\n            parent = wrap(parent);\n            for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\n              parent.removeChild(n);\n            }\n          }\n        }\n        this.__invalidProps = null;\n        this.__instance = null;\n      }\n    }\n\n    /**\n     * Forwards any properties that changed while the `if` was false into the\n     * template instance and flushes it.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"__syncHostProperties\",\n    value: function __syncHostProperties() {\n      var props = this.__invalidProps;\n      if (props) {\n        this.__invalidProps = null;\n        for (var prop in props) {\n          this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n        }\n        this.__instance._flushProperties();\n      }\n    }\n\n    /**\n     * Implementation of abstract API needed by DomIfBase.\n     *\n     * Shows or hides the template instance top level child elements. For\n     * text nodes, `textContent` is removed while \"hidden\" and replaced when\n     * \"shown.\"\n     *\n     * @override\n     * @protected\n     * @return {void}\n     * @suppress {visibility}\n     */\n  }, {\n    key: \"_showHideChildren\",\n    value: function _showHideChildren() {\n      var hidden = this.__hideTemplateChildren__ || !this.if;\n      if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n        this.__instance.__hidden = hidden;\n        this.__instance._showHideChildren(hidden);\n      }\n      if (!hidden) {\n        this.__syncHostProperties();\n      }\n    }\n  }]);\n  return DomIfLegacy;\n}(DomIfBase);\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends DomIfBase\n * @constructor\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport var DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\ncustomElements.define(DomIf.is, DomIf);","map":{"version":3,"names":["PolymerElement","Debouncer","enqueueDebouncer","flush","microTask","root","wrap","hideElementsGlobally","fastDomIf","strictTemplatePolicy","suppressTemplateNotifications","showHideChildren","templatize","DomIfBase","_PolymerElement","_inherits","_this","_classCallCheck","_callSuper","__renderDebouncer","_lastIf","__hideTemplateChildren__","__template","_templateInfo","_createClass","key","value","__debounceRender","_this2","debounce","__render","disconnectedCallback","_get","_getPrototypeOf","prototype","call","parent","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","__teardownInstance","connectedCallback","style","display","if","__ensureTemplate","_this3","thisAsTemplate","template","querySelector","observer","MutationObserver","disconnect","Error","observe","childList","__ensureInstance","__hasInstance","__createAndInsertInstance","children","__getInstanceNodes","length","lastChild","previousSibling","i","n","insertBefore","render","restamp","_showHideChildren","notifyDomChange","dispatchEvent","CustomEvent","bubbles","composed","get","type","Boolean","DomIfFast","_DomIfBase","_this4","__instance","__syncInfo","templateInfo","childNodes","_this5","__dataHost","_bindTemplate","runEffects","changedProps","hasPaths","syncInfo","Object","assign","p","rootProp","_stampTemplate","__syncHostProperties","_removeBoundDom","hidden","__hidden","DomIfLegacy","_DomIfBase2","_this6","__ctor","__invalidProps","mutableData","forwardHostProp","prop","create","c$","removeChild","props","_setPendingProperty","_flushProperties","DomIf","customElements","define","is"],"sources":["/workspaces/frontend/node_modules/@polymer/polymer/lib/elements/dom-if.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport { PolymerElement } from '../../polymer-element.js';\n\nimport { Debouncer } from '../utils/debounce.js';\nimport { enqueueDebouncer, flush } from '../utils/flush.js';\nimport { microTask } from '../utils/async.js';\nimport { root } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { hideElementsGlobally } from '../utils/hide-template-controls.js';\nimport { fastDomIf, strictTemplatePolicy, suppressTemplateNotifications } from '../utils/settings.js';\nimport { showHideChildren, templatize } from '../utils/templatize.js';\n\n/**\n * @customElement\n * @polymer\n * @extends PolymerElement\n * @summary Base class for dom-if element; subclassed into concrete\n *   implementation.\n */\nclass DomIfBase extends PolymerElement {\n\n  // Not needed to find template; can be removed once the analyzer\n  // can find the tag name from customElements.define call\n  static get is() { return 'dom-if'; }\n\n  static get template() { return null; }\n\n  static get properties() {\n\n    return {\n\n      /**\n       * Fired whenever DOM is added or removed/hidden by this template (by\n       * default, rendering occurs lazily).  To force immediate rendering, call\n       * `render`.\n       *\n       * @event dom-change\n       */\n\n      /**\n       * A boolean indicating whether this template should stamp.\n       */\n      if: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When true, elements will be removed from DOM and discarded when `if`\n       * becomes false and re-created and added back to the DOM when `if`\n       * becomes true.  By default, stamped elements will be hidden but left\n       * in the DOM when `if` becomes false, which is generally results\n       * in better performance.\n       */\n      restamp: {\n        type: Boolean,\n        observer: '__debounceRender'\n      },\n\n      /**\n       * When the global `suppressTemplateNotifications` setting is used, setting\n       * `notifyDomChange: true` will enable firing `dom-change` events on this\n       * element.\n       */\n      notifyDomChange: {\n        type: Boolean\n      }\n    };\n\n  }\n\n  constructor() {\n    super();\n    this.__renderDebouncer = null;\n    this._lastIf = false;\n    this.__hideTemplateChildren__ = false;\n    /** @type {!HTMLTemplateElement|undefined} */\n    this.__template;\n    /** @type {!TemplateInfo|undefined} */\n    this._templateInfo;\n  }\n\n  __debounceRender() {\n    // Render is async for 2 reasons:\n    // 1. To eliminate dom creation trashing if user code thrashes `if` in the\n    //    same turn. This was more common in 1.x where a compound computed\n    //    property could result in the result changing multiple times, but is\n    //    mitigated to a large extent by batched property processing in 2.x.\n    // 2. To avoid double object propagation when a bag including values bound\n    //    to the `if` property as well as one or more hostProps could enqueue\n    //    the <dom-if> to flush before the <template>'s host property\n    //    forwarding. In that scenario creating an instance would result in\n    //    the host props being set once, and then the enqueued changes on the\n    //    template would set properties a second time, potentially causing an\n    //    object to be set to an instance more than once.  Creating the\n    //    instance async from flushing data ensures this doesn't happen. If\n    //    we wanted a sync option in the future, simply having <dom-if> flush\n    //    (or clear) its template's pending host properties before creating\n    //    the instance would also avoid the problem.\n    this.__renderDebouncer = Debouncer.debounce(\n          this.__renderDebouncer\n        , microTask\n        , () => this.__render());\n    enqueueDebouncer(this.__renderDebouncer);\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    const parent = wrap(this).parentNode;\n    if (!parent || (parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&\n        !wrap(parent).host)) {\n      this.__teardownInstance();\n    }\n  }\n\n  /**\n   * @override\n   * @return {void}\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    if (!hideElementsGlobally()) {\n      this.style.display = 'none';\n    }\n    if (this.if) {\n      this.__debounceRender();\n    }\n  }\n\n  /**\n   * Ensures a template has been assigned to `this.__template`.  If it has not\n   * yet been, it querySelectors for it in its children and if it does not yet\n   * exist (e.g. in parser-generated case), opens a mutation observer and\n   * waits for it to appear (returns false if it has not yet been found,\n   * otherwise true).  In the `removeNestedTemplates` case, the \"template\" will\n   * be the `dom-if` element itself.\n   *\n   * @return {boolean} True when a template has been found, false otherwise\n   */\n  __ensureTemplate() {\n    if (!this.__template) {\n      // When `removeNestedTemplates` is true, the \"template\" is the element\n      // itself, which has been given a `_templateInfo` property\n      const thisAsTemplate = /** @type {!HTMLTemplateElement} */ (\n          /** @type {!HTMLElement} */ (this));\n      let template = thisAsTemplate._templateInfo ?\n          thisAsTemplate :\n          /** @type {!HTMLTemplateElement} */\n          (wrap(thisAsTemplate).querySelector('template'));\n      if (!template) {\n        // Wait until childList changes and template should be there by then\n        let observer = new MutationObserver(() => {\n          if (wrap(this).querySelector('template')) {\n            observer.disconnect();\n            this.__render();\n          } else {\n            throw new Error('dom-if requires a <template> child');\n          }\n        });\n        observer.observe(this, {childList: true});\n        return false;\n      }\n      this.__template = template;\n    }\n    return true;\n  }\n\n  /**\n   * Ensures a an instance of the template has been created and inserted. This\n   * method may return false if the template has not yet been found or if\n   * there is no `parentNode` to insert the template into (in either case,\n   * connection or the template-finding mutation observer firing will queue\n   * another render, causing this method to be called again at a more\n   * appropriate time).\n   *\n   * Subclasses should implement the following methods called here:\n   * - `__hasInstance`\n   * - `__createAndInsertInstance`\n   * - `__getInstanceNodes`\n   *\n   * @return {boolean} True if the instance was created, false otherwise.\n   */\n  __ensureInstance() {\n    let parentNode = wrap(this).parentNode;\n    if (!this.__hasInstance()) {\n      // Guard against element being detached while render was queued\n      if (!parentNode) {\n        return false;\n      }\n      // Find the template (when false, there was no template yet)\n      if (!this.__ensureTemplate()) {\n        return false;\n      }\n      this.__createAndInsertInstance(parentNode);\n    } else {\n      // Move instance children if necessary\n      let children = this.__getInstanceNodes();\n      if (children && children.length) {\n        // Detect case where dom-if was re-attached in new position\n        let lastChild = wrap(this).previousSibling;\n        if (lastChild !== children[children.length-1]) {\n          for (let i=0, n; (i<children.length) && (n=children[i]); i++) {\n            wrap(parentNode).insertBefore(n, this);\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Forces the element to render its content. Normally rendering is\n   * asynchronous to a provoking change. This is done for efficiency so\n   * that multiple changes trigger only a single render. The render method\n   * should be called if, for example, template rendering is required to\n   * validate application state.\n   *\n   * @return {void}\n   */\n  render() {\n    flush();\n  }\n\n  /**\n   * Performs the key rendering steps:\n   * 1. Ensure a template instance has been stamped (when true)\n   * 2. Remove the template instance (when false and restamp:true)\n   * 3. Sync the hidden state of the instance nodes with the if/restamp state\n   * 4. Fires the `dom-change` event when necessary\n   *\n   * @return {void}\n   */\n  __render() {\n    if (this.if) {\n      if (!this.__ensureInstance()) {\n        // No template found yet\n        return;\n      }\n    } else if (this.restamp) {\n      this.__teardownInstance();\n    }\n    this._showHideChildren();\n    if ((!suppressTemplateNotifications || this.notifyDomChange)\n        && this.if != this._lastIf) {\n      this.dispatchEvent(new CustomEvent('dom-change', {\n        bubbles: true,\n        composed: true\n      }));\n      this._lastIf = this.if;\n    }\n  }\n\n  // Ideally these would be annotated as abstract methods in an abstract class,\n  // but closure compiler is finnicky\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Abstract API to be implemented by subclass: Returns true if a template\n   * instance has been created and inserted.\n   *\n   * @protected\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Returns the child nodes stamped\n   * from a template instance.\n   *\n   * @protected\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Creates an instance of the\n   * template and inserts it into the given parent node.\n   *\n   * @protected\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) { } // eslint-disable-line no-unused-vars\n\n  /**\n   * Abstract API to be implemented by subclass: Removes nodes created by an\n   * instance of a template and any associated cleanup.\n   *\n   * @protected\n   * @return {void}\n   */\n  __teardownInstance() { }\n\n  /**\n   * Abstract API to be implemented by subclass: Shows or hides any template\n   * instance childNodes based on the `if` state of the element and its\n   * `__hideTemplateChildren__` property.\n   *\n   * @protected\n   * @return {void}\n   */\n  _showHideChildren() { }\n  /* eslint-enable valid-jsdoc */\n}\n\n/**\n * The version of DomIf used when `fastDomIf` setting is in use, which is\n * optimized for first-render (but adds a tax to all subsequent property updates\n * on the host, whether they were used in a given `dom-if` or not).\n *\n * This implementation avoids use of `Templatizer`, which introduces a new scope\n * (a non-element PropertyEffects instance), which is not strictly necessary\n * since `dom-if` never introduces new properties to its scope (unlike\n * `dom-repeat`). Taking advantage of this fact, the `dom-if` reaches up to its\n * `__dataHost` and stamps the template directly from the host using the host's\n * runtime `_stampTemplate` API, which binds the property effects of the\n * template directly to the host. This both avoids the intermediary\n * `Templatizer` instance, but also avoids the need to bind host properties to\n * the `<template>` element and forward those into the template instance.\n *\n * In this version of `dom-if`, the `this.__instance` method is the\n * `DocumentFragment` returned from `_stampTemplate`, which also serves as the\n * handle for later removing it using the `_removeBoundDom` method.\n */\nclass DomIfFast extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__instance = null;\n    this.__syncInfo = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.templateInfo.childNodes;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this\n   * element and then inserts the resulting nodes into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    const host = this.__dataHost || this;\n    if (strictTemplatePolicy) {\n      if (!this.__dataHost) {\n        throw new Error('strictTemplatePolicy: template owner not trusted');\n      }\n    }\n    // Pre-bind and link the template into the effects system\n    const templateInfo = host._bindTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), true);\n    // Install runEffects hook that prevents running property effects\n    // (and any nested template effects) when the `if` is false\n    templateInfo.runEffects = (runEffects, changedProps, hasPaths) => {\n      let syncInfo = this.__syncInfo;\n      if (this.if) {\n        // Mix any props that changed while the `if` was false into `changedProps`\n        if (syncInfo) {\n          // If there were properties received while the `if` was false, it is\n          // important to sync the hidden state with the element _first_, so that\n          // new bindings to e.g. `textContent` do not get stomped on by\n          // pre-hidden values if `_showHideChildren` were to be called later at\n          // the next render. Clearing `__invalidProps` here ensures\n          // `_showHideChildren`'s call to `__syncHostProperties` no-ops, so\n          // that we don't call `runEffects` more often than necessary.\n          this.__syncInfo = null;\n          this._showHideChildren();\n          changedProps = Object.assign(syncInfo.changedProps, changedProps);\n        }\n        runEffects(changedProps, hasPaths);\n      } else {\n        // Accumulate any values changed while `if` was false, along with the\n        // runEffects method to sync them, so that we can replay them once `if`\n        // becomes true\n        if (this.__instance) {\n          if (!syncInfo) {\n            syncInfo = this.__syncInfo = { runEffects, changedProps: {} };\n          }\n          if (hasPaths) {\n            // Store root object of any paths; this will ensure direct bindings\n            // like [[obj.foo]] bindings run after a `set('obj.foo', v)`, but\n            // note that path notifications like `set('obj.foo.bar', v)` will\n            // not propagate. Since batched path notifications are not\n            // supported, we cannot simply accumulate path notifications. This\n            // is equivalent to the non-fastDomIf case, which stores root(p) in\n            // __invalidProps.\n            for (const p in changedProps) {\n              const rootProp = root(p);\n              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];\n            }\n          } else {\n            Object.assign(syncInfo.changedProps, changedProps);\n          }\n        }\n      }\n    };\n    // Stamp the template, and set its DocumentFragment to the \"instance\"\n    this.__instance = host._stampTemplate(\n        /** @type {!HTMLTemplateElement} */ (this.__template), templateInfo);\n    wrap(parentNode).insertBefore(this.__instance, this);\n  }\n\n  /**\n   * Run effects for any properties that changed while the `if` was false.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    const syncInfo = this.__syncInfo;\n    if (syncInfo) {\n      this.__syncInfo = null;\n      syncInfo.runEffects(syncInfo.changedProps, false);\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s\n   * runtime `_removeBoundDom` method.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    const host = this.__dataHost || this;\n    if (this.__instance) {\n      host._removeBoundDom(this.__instance);\n      this.__instance = null;\n      this.__syncInfo = null;\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child nodes. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @return {void}\n   * @protected\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      showHideChildren(hidden, this.__instance.templateInfo.childNodes);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The \"legacy\" implementation of `dom-if`, implemented using `Templatizer`.\n *\n * In this version, `this.__instance` is the `TemplateInstance` returned\n * from the templatized constructor.\n */\nclass DomIfLegacy extends DomIfBase {\n\n  constructor() {\n    super();\n    this.__ctor = null;\n    this.__instance = null;\n    this.__invalidProps = null;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {boolean} True when an instance has been created.\n   */\n  __hasInstance() {\n    return Boolean(this.__instance);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * @override\n   * @return {Array<Node>} Array of child nodes stamped from the template\n   * instance.\n   */\n  __getInstanceNodes() {\n    return this.__instance.children;\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Stamps the template by creating a new instance of the templatized\n   * constructor (which is created lazily if it does not yet exist), and then\n   * inserts its resulting `root` doc fragment into the given `parentNode`.\n   *\n   * @override\n   * @param {Node} parentNode The parent node to insert the instance into\n   * @return {void}\n   */\n  __createAndInsertInstance(parentNode) {\n    // Ensure we have an instance constructor\n    if (!this.__ctor) {\n      this.__ctor = templatize(\n          /** @type {!HTMLTemplateElement} */ (this.__template), this, {\n            // dom-if templatizer instances require `mutable: true`, as\n            // `__syncHostProperties` relies on that behavior to sync objects\n            mutableData: true,\n            /**\n             * @param {string} prop Property to forward\n             * @param {*} value Value of property\n             * @this {DomIfLegacy}\n             */\n            forwardHostProp: function(prop, value) {\n              if (this.__instance) {\n                if (this.if) {\n                  this.__instance.forwardHostProp(prop, value);\n                } else {\n                  // If we have an instance but are squelching host property\n                  // forwarding due to if being false, note the invalidated\n                  // properties so `__syncHostProperties` can sync them the next\n                  // time `if` becomes true\n                  this.__invalidProps =\n                      this.__invalidProps || Object.create(null);\n                  this.__invalidProps[root(prop)] = true;\n                }\n              }\n            }\n          });\n    }\n    // Create and insert the instance\n    this.__instance = new this.__ctor();\n    wrap(parentNode).insertBefore(this.__instance.root, this);\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Removes the instance and any nodes it created.\n   *\n   * @override\n   * @return {void}\n   */\n  __teardownInstance() {\n    if (this.__instance) {\n      let c$ = this.__instance.children;\n      if (c$ && c$.length) {\n        // use first child parent, for case when dom-if may have been detached\n        let parent = wrap(c$[0]).parentNode;\n        // Instance children may be disconnected from parents when dom-if\n        // detaches if a tree was innerHTML'ed\n        if (parent) {\n          parent = wrap(parent);\n          for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n            parent.removeChild(n);\n          }\n        }\n      }\n      this.__invalidProps = null;\n      this.__instance = null;\n    }\n  }\n\n  /**\n   * Forwards any properties that changed while the `if` was false into the\n   * template instance and flushes it.\n   *\n   * @return {void}\n   */\n  __syncHostProperties() {\n    let props = this.__invalidProps;\n    if (props) {\n      this.__invalidProps = null;\n      for (let prop in props) {\n        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);\n      }\n      this.__instance._flushProperties();\n    }\n  }\n\n  /**\n   * Implementation of abstract API needed by DomIfBase.\n   *\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   *\n   * @override\n   * @protected\n   * @return {void}\n   * @suppress {visibility}\n   */\n  _showHideChildren() {\n    const hidden = this.__hideTemplateChildren__ || !this.if;\n    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {\n      this.__instance.__hidden = hidden;\n      this.__instance._showHideChildren(hidden);\n    }\n    if (!hidden) {\n      this.__syncHostProperties();\n    }\n  }\n}\n\n/**\n * The `<dom-if>` element will stamp a light-dom `<template>` child when\n * the `if` property becomes truthy, and the template can use Polymer\n * data-binding and declarative event features when used in the context of\n * a Polymer element's template.\n *\n * When `if` becomes falsy, the stamped content is hidden but not\n * removed from dom. When `if` subsequently becomes truthy again, the content\n * is simply re-shown. This approach is used due to its favorable performance\n * characteristics: the expense of creating template content is paid only\n * once and lazily.\n *\n * Set the `restamp` property to true to force the stamped content to be\n * created / destroyed when the `if` condition changes.\n *\n * @customElement\n * @polymer\n * @extends DomIfBase\n * @constructor\n * @summary Custom element that conditionally stamps and hides or removes\n *   template content based on a boolean flag.\n */\nexport const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;\n\ncustomElements.define(DomIf.is, DomIf);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}