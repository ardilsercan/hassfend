{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport var flow = function flow(config) {\n  return Object.assign({\n    type: FlowLayout\n  }, config);\n};\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n  var m = [a, b].sort();\n  return m[1] <= 0 ? Math.min.apply(Math, _toConsumableArray(m)) : m[0] >= 0 ? Math.max.apply(Math, _toConsumableArray(m)) : m[0] + m[1];\n}\nvar MetricsCache = /*#__PURE__*/function () {\n  function MetricsCache() {\n    _classCallCheck(this, MetricsCache);\n    this._childSizeCache = new SizeCache();\n    this._marginSizeCache = new SizeCache();\n    this._metricsCache = new Map();\n  }\n  _createClass(MetricsCache, [{\n    key: \"update\",\n    value: function update(metrics, direction) {\n      var _this = this;\n      var marginsToUpdate = new Set();\n      Object.keys(metrics).forEach(function (key) {\n        var k = Number(key);\n        _this._metricsCache.set(k, metrics[k]);\n        _this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n        marginsToUpdate.add(k);\n        marginsToUpdate.add(k + 1);\n      });\n      var _iterator = _createForOfIteratorHelper(marginsToUpdate),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _this$_metricsCache$g, _this$_metricsCache$g2;\n          var k = _step.value;\n          var a = ((_this$_metricsCache$g = this._metricsCache.get(k)) === null || _this$_metricsCache$g === void 0 ? void 0 : _this$_metricsCache$g[leadingMargin(direction)]) || 0;\n          var b = ((_this$_metricsCache$g2 = this._metricsCache.get(k - 1)) === null || _this$_metricsCache$g2 === void 0 ? void 0 : _this$_metricsCache$g2[trailingMargin(direction)]) || 0;\n          this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"averageChildSize\",\n    get: function get() {\n      return this._childSizeCache.averageSize;\n    }\n  }, {\n    key: \"totalChildSize\",\n    get: function get() {\n      return this._childSizeCache.totalSize;\n    }\n  }, {\n    key: \"averageMarginSize\",\n    get: function get() {\n      return this._marginSizeCache.averageSize;\n    }\n  }, {\n    key: \"totalMarginSize\",\n    get: function get() {\n      return this._marginSizeCache.totalSize;\n    }\n  }, {\n    key: \"getLeadingMarginValue\",\n    value: function getLeadingMarginValue(index, direction) {\n      var _this$_metricsCache$g3;\n      return ((_this$_metricsCache$g3 = this._metricsCache.get(index)) === null || _this$_metricsCache$g3 === void 0 ? void 0 : _this$_metricsCache$g3[leadingMargin(direction)]) || 0;\n    }\n  }, {\n    key: \"getChildSize\",\n    value: function getChildSize(index) {\n      return this._childSizeCache.getSize(index);\n    }\n  }, {\n    key: \"getMarginSize\",\n    value: function getMarginSize(index) {\n      return this._marginSizeCache.getSize(index);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._childSizeCache.clear();\n      this._marginSizeCache.clear();\n      this._metricsCache.clear();\n    }\n  }]);\n  return MetricsCache;\n}();\nexport var FlowLayout = /*#__PURE__*/function (_BaseLayout) {\n  _inherits(FlowLayout, _BaseLayout);\n  function FlowLayout() {\n    var _this2;\n    _classCallCheck(this, FlowLayout);\n    _this2 = _callSuper(this, FlowLayout, arguments);\n    /**\n     * Initial estimate of item size\n     */\n    _this2._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n    _this2._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n    _this2._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n    _this2._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n    _this2._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n    _this2._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n    _this2._stable = true;\n    _this2._measureChildren = true;\n    _this2._estimate = true;\n    return _this2;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  _createClass(FlowLayout, [{\n    key: \"measureChildren\",\n    get: function get() {\n      return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n  }, {\n    key: \"updateItemSizes\",\n    value: function updateItemSizes(sizes) {\n      this._metricsCache.update(sizes, this.direction);\n      // if (this._nMeasured) {\n      // this._updateItemSize();\n      this._scheduleReflow();\n      // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n  }, {\n    key: \"_getPhysicalItem\",\n    value: function _getPhysicalItem(idx) {\n      var _this$_newPhysicalIte;\n      return (_this$_newPhysicalIte = this._newPhysicalItems.get(idx)) !== null && _this$_newPhysicalIte !== void 0 ? _this$_newPhysicalIte : this._physicalItems.get(idx);\n    }\n  }, {\n    key: \"_getSize\",\n    value: function _getSize(idx) {\n      var item = this._getPhysicalItem(idx);\n      return item && this._metricsCache.getChildSize(idx);\n    }\n  }, {\n    key: \"_getAverageSize\",\n    value: function _getAverageSize() {\n      return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n  }, {\n    key: \"_estimatePosition\",\n    value: function _estimatePosition(idx) {\n      var c = this._metricsCache;\n      if (this._first === -1 || this._last === -1) {\n        return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n      } else {\n        if (idx < this._first) {\n          var delta = this._first - idx;\n          var refItem = this._getPhysicalItem(this._first);\n          return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n        } else {\n          var _delta = idx - this._last;\n          var _refItem = this._getPhysicalItem(this._last);\n          return _refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + _delta * (c.averageChildSize + c.averageMarginSize);\n        }\n      }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition(idx) {\n      var _this$_metricsCache$g4;\n      var item = this._getPhysicalItem(idx);\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      return idx === 0 ? (_this$_metricsCache$g4 = this._metricsCache.getMarginSize(0)) !== null && _this$_metricsCache$g4 !== void 0 ? _this$_metricsCache$g4 : averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n    }\n  }, {\n    key: \"_calculateAnchor\",\n    value: function _calculateAnchor(lower, upper) {\n      if (lower <= 0) {\n        return 0;\n      }\n      if (upper > this._scrollSize - this._viewDim1) {\n        return this.items.length - 1;\n      }\n      return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n  }, {\n    key: \"_getAnchor\",\n    value: function _getAnchor(lower, upper) {\n      if (this._physicalItems.size === 0) {\n        return this._calculateAnchor(lower, upper);\n      }\n      if (this._first < 0) {\n        return this._calculateAnchor(lower, upper);\n      }\n      if (this._last < 0) {\n        return this._calculateAnchor(lower, upper);\n      }\n      var firstItem = this._getPhysicalItem(this._first),\n        lastItem = this._getPhysicalItem(this._last),\n        firstMin = firstItem.pos,\n        lastMin = lastItem.pos,\n        lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n      if (lastMax < lower) {\n        // Window is entirely past physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      }\n      if (firstMin > upper) {\n        // Window is entirely before physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      }\n      // Window contains a physical item\n      // Find one, starting with the one that was previously first visible\n      var candidateIdx = this._firstVisible - 1;\n      var cMax = -Infinity;\n      while (cMax < lower) {\n        var candidate = this._getPhysicalItem(++candidateIdx);\n        cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n      }\n      return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n  }, {\n    key: \"_getActiveItems\",\n    value: function _getActiveItems() {\n      if (this._viewDim1 === 0 || this.items.length === 0) {\n        this._clearItems();\n      } else {\n        this._getItems();\n      }\n    }\n    /**\n     * Sets the range to empty.\n     */\n  }, {\n    key: \"_clearItems\",\n    value: function _clearItems() {\n      this._first = -1;\n      this._last = -1;\n      this._physicalMin = 0;\n      this._physicalMax = 0;\n      var items = this._newPhysicalItems;\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n      this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n  }, {\n    key: \"_getItems\",\n    value: function _getItems() {\n      var _this$_metricsCache$g5, _this$_metricsCache$g6;\n      var items = this._newPhysicalItems;\n      this._stable = true;\n      var lower, upper;\n      // The anchorIdx is the anchor around which we reflow. It is designed to\n      // allow jumping to any point of the scroll size. We choose it once and\n      // stick with it until stable. first and last are deduced around it.\n      // If we have a pinned item, we anchor on it\n      if (this.pin !== null) {\n        var index = this.pin.index;\n        this._anchorIdx = index;\n        this._anchorPos = this._getPosition(index);\n      }\n      // Determine the lower and upper bounds of the region to be\n      // rendered, relative to the viewport\n      lower = this._scrollPosition - this._overhang; //leadingOverhang;\n      upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n      if (upper < 0 || lower > this._scrollSize) {\n        this._clearItems();\n        return;\n      }\n      // If we are scrolling to a specific index or if we are doing another\n      // pass to stabilize a previously started reflow, we will already\n      // have an anchor. If not, establish an anchor now.\n      if (this._anchorIdx === null || this._anchorPos === null) {\n        this._anchorIdx = this._getAnchor(lower, upper);\n        this._anchorPos = this._getPosition(this._anchorIdx);\n      }\n      var anchorSize = this._getSize(this._anchorIdx);\n      if (anchorSize === undefined) {\n        this._stable = false;\n        anchorSize = this._getAverageSize();\n      }\n      var anchorLeadingMargin = (_this$_metricsCache$g5 = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _this$_metricsCache$g5 !== void 0 ? _this$_metricsCache$g5 : this._metricsCache.averageMarginSize;\n      var anchorTrailingMargin = (_this$_metricsCache$g6 = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _this$_metricsCache$g6 !== void 0 ? _this$_metricsCache$g6 : this._metricsCache.averageMarginSize;\n      if (this._anchorIdx === 0) {\n        this._anchorPos = anchorLeadingMargin;\n      }\n      if (this._anchorIdx === this.items.length - 1) {\n        this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n      }\n      // Anchor might be outside bounds, so prefer correcting the error and keep\n      // that anchorIdx.\n      var anchorErr = 0;\n      if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n        anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n      }\n      if (this._anchorPos - anchorLeadingMargin > upper) {\n        anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n      }\n      if (anchorErr) {\n        this._scrollPosition -= anchorErr;\n        lower -= anchorErr;\n        upper -= anchorErr;\n        this._scrollError += anchorErr;\n      }\n      items.set(this._anchorIdx, {\n        pos: this._anchorPos,\n        size: anchorSize\n      });\n      this._first = this._last = this._anchorIdx;\n      this._physicalMin = this._anchorPos - anchorLeadingMargin;\n      this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n      while (this._physicalMin > lower && this._first > 0) {\n        var size = this._getSize(--this._first);\n        if (size === undefined) {\n          this._stable = false;\n          size = this._getAverageSize();\n        }\n        var margin = this._metricsCache.getMarginSize(this._first);\n        if (margin === undefined) {\n          this._stable = false;\n          margin = this._metricsCache.averageMarginSize;\n        }\n        this._physicalMin -= size;\n        var pos = this._physicalMin;\n        items.set(this._first, {\n          pos: pos,\n          size: size\n        });\n        this._physicalMin -= margin;\n        if (this._stable === false && this._estimate === false) {\n          break;\n        }\n      }\n      while (this._physicalMax < upper && this._last < this.items.length - 1) {\n        var _size = this._getSize(++this._last);\n        if (_size === undefined) {\n          this._stable = false;\n          _size = this._getAverageSize();\n        }\n        var _margin = this._metricsCache.getMarginSize(this._last);\n        if (_margin === undefined) {\n          this._stable = false;\n          _margin = this._metricsCache.averageMarginSize;\n        }\n        var _pos = this._physicalMax;\n        items.set(this._last, {\n          pos: _pos,\n          size: _size\n        });\n        this._physicalMax += _size + _margin;\n        if (!this._stable && !this._estimate) {\n          break;\n        }\n      }\n      // This handles the cases where we were relying on estimated sizes.\n      var extentErr = this._calculateError();\n      if (extentErr) {\n        this._physicalMin -= extentErr;\n        this._physicalMax -= extentErr;\n        this._anchorPos -= extentErr;\n        this._scrollPosition -= extentErr;\n        items.forEach(function (item) {\n          return item.pos -= extentErr;\n        });\n        this._scrollError += extentErr;\n      }\n      if (this._stable) {\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n      }\n    }\n  }, {\n    key: \"_calculateError\",\n    value: function _calculateError() {\n      if (this._first === 0) {\n        return this._physicalMin;\n      } else if (this._physicalMin <= 0) {\n        return this._physicalMin - this._first * this._delta;\n      } else if (this._last === this.items.length - 1) {\n        return this._physicalMax - this._scrollSize;\n      } else if (this._physicalMax >= this._scrollSize) {\n        return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n      }\n      return 0;\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      var _first = this._first,\n        _last = this._last;\n      _get(_getPrototypeOf(FlowLayout.prototype), \"_reflow\", this).call(this);\n      if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n        this._resetReflowState();\n      }\n    }\n  }, {\n    key: \"_resetReflowState\",\n    value: function _resetReflowState() {\n      this._anchorIdx = null;\n      this._anchorPos = null;\n      this._stable = true;\n    }\n  }, {\n    key: \"_updateScrollSize\",\n    value: function _updateScrollSize() {\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n  }, {\n    key: \"_delta\",\n    get: function get() {\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(idx) {\n      var _this$_metricsCache$g7;\n      return _defineProperty(_defineProperty(_defineProperty({}, this._positionDim, this._getPosition(idx)), this._secondaryPositionDim, 0), offset(this.direction), -((_this$_metricsCache$g7 = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _this$_metricsCache$g7 !== void 0 ? _this$_metricsCache$g7 : this._metricsCache.averageMarginSize));\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n  }, {\n    key: \"_getItemSize\",\n    value: function _getItemSize(idx) {\n      return _defineProperty(_defineProperty({}, this._sizeDim, this._getSize(idx) || this._getAverageSize()), this._secondarySizeDim, this._itemSize[this._secondarySizeDim]);\n    }\n  }, {\n    key: \"_viewDim2Changed\",\n    value: function _viewDim2Changed() {\n      this._metricsCache.clear();\n      this._scheduleReflow();\n    }\n  }]);\n  return FlowLayout;\n}(BaseLayout);","map":{"version":3,"names":["SizeCache","BaseLayout","dim1","flow","config","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","Math","min","apply","_toConsumableArray","max","MetricsCache","_classCallCheck","_childSizeCache","_marginSizeCache","_metricsCache","Map","_createClass","key","value","update","metrics","_this","marginsToUpdate","Set","keys","forEach","k","Number","set","add","_iterator","_createForOfIteratorHelper","_step","s","n","done","_this$_metricsCache$g","_this$_metricsCache$g2","get","err","e","f","averageSize","totalSize","getLeadingMarginValue","index","_this$_metricsCache$g3","getChildSize","getSize","getMarginSize","clear","_BaseLayout","_inherits","_this2","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_this$_newPhysicalIte","_getSize","item","_getAverageSize","averageChildSize","_sizeDim","_estimatePosition","c","_first","_last","averageMarginSize","delta","refItem","pos","_getPosition","_this$_metricsCache$g4","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","size","firstItem","lastItem","firstMin","lastMin","lastMax","candidateIdx","_firstVisible","cMax","Infinity","candidate","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","_this$_metricsCache$g5","_this$_metricsCache$g6","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","_get","_getPrototypeOf","prototype","call","_resetReflowState","_updateScrollSize","_getItemPosition","_this$_metricsCache$g7","_defineProperty","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"sources":["../src/layouts/flow.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {SizeCache} from './shared/SizeCache.js';\nimport {BaseLayout, dim1} from './shared/BaseLayout.js';\nimport {\n  Positions,\n  Size,\n  Margins,\n  margin,\n  ScrollDirection,\n  offsetAxis,\n  ChildMeasurements,\n  BaseLayoutConfig,\n  LayoutHostSink,\n} from './shared/Layout.js';\n\ntype ItemBounds = {\n  pos: number;\n  size: number;\n};\n\ntype FlowLayoutConstructor = {\n  prototype: FlowLayout;\n  new (hostSink: LayoutHostSink, config?: BaseLayoutConfig): FlowLayout;\n};\n\ntype FlowLayoutSpecifier = BaseLayoutConfig & {\n  type: FlowLayoutConstructor;\n};\n\ntype FlowLayoutSpecifierFactory = (\n  config?: BaseLayoutConfig\n) => FlowLayoutSpecifier;\n\nexport const flow: FlowLayoutSpecifierFactory = (config?: BaseLayoutConfig) =>\n  Object.assign(\n    {\n      type: FlowLayout,\n    },\n    config\n  );\n\nfunction leadingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction: ScrollDirection): offsetAxis {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a: number, b: number): number {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  private _childSizeCache = new SizeCache();\n  private _marginSizeCache = new SizeCache();\n  private _metricsCache = new Map<number, Size & Margins>();\n\n  update(metrics: {[key: number]: Size & Margins}, direction: ScrollDirection) {\n    const marginsToUpdate = new Set<number>();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize(): number {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize(): number {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize(): number {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize(): number {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index: number, direction: ScrollDirection) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n\n  getChildSize(index: number) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index: number) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\n\nexport class FlowLayout extends BaseLayout<BaseLayoutConfig> {\n  /**\n   * Initial estimate of item size\n   */\n  _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Indices of children mapped to their (position and length) in the scrolling\n   * direction. Used to keep track of children that are in range.\n   */\n  _physicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Used in tandem with _physicalItems to track children in range across\n   * reflows.\n   */\n  _newPhysicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Width and height of children by their index.\n   */\n  _metricsCache = new MetricsCache();\n\n  /**\n   * anchorIdx is the anchor around which we reflow. It is designed to allow\n   * jumping to any point of the scroll size. We choose it once and stick with\n   * it until stable. _first and _last are deduced around it.\n   */\n  _anchorIdx: number | null = null;\n\n  /**\n   * Position in the scrolling direction of the anchor child.\n   */\n  _anchorPos: number | null = null;\n\n  /**\n   * Whether all children in range were in range during the previous reflow.\n   */\n  _stable = true;\n\n  private _measureChildren = true;\n\n  _estimate = true;\n\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n\n  // })\n\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes: ChildMeasurements) {\n    this._metricsCache.update(sizes as Size & Margins, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n  _getPhysicalItem(idx: number): ItemBounds | undefined {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n\n  _getSize(idx: number): number | undefined {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize(): number {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n\n  _estimatePosition(idx: number): number {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return (\n        c.averageMarginSize +\n        idx * (c.averageMarginSize + this._getAverageSize())\n      );\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return (\n          refItem!.pos -\n          (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n          (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize)\n        );\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return (\n          refItem!.pos +\n          (c.getChildSize(this._last) || c.averageChildSize) +\n          (c.getMarginSize(this._last) || c.averageMarginSize) +\n          delta * (c.averageChildSize + c.averageMarginSize)\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx: number): number {\n    const item = this._getPhysicalItem(idx);\n    const {averageMarginSize} = this._metricsCache;\n    return idx === 0\n      ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n      : item\n      ? item.pos\n      : this._estimatePosition(idx);\n  }\n\n  _calculateAnchor(lower: number, upper: number): number {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(\n      0,\n      Math.min(\n        this.items.length - 1,\n        Math.floor((lower + upper) / 2 / this._delta)\n      )\n    );\n  }\n\n  _getAnchor(lower: number, upper: number): number {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem!.pos,\n      lastMin = lastItem!.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last)!;\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate!.pos + this._metricsCache.getChildSize(candidateIdx)!;\n    }\n    return candidateIdx;\n  }\n\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {index} = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    const anchorLeadingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx) ??\n      this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n      this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {pos: this._anchorPos, size: anchorSize});\n\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {pos, size});\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {pos, size});\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => (item.pos -= extentErr));\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError(): number {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return (\n        this._physicalMax -\n        this._scrollSize +\n        (this.items.length - 1 - this._last) * this._delta\n      );\n    }\n    return 0;\n  }\n\n  override _reflow() {\n    const {_first, _last} = this;\n    super._reflow();\n    if (\n      (this._first === -1 && this._last == -1) ||\n      (this._first === _first && this._last === _last)\n    ) {\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {averageMarginSize} = this._metricsCache;\n    this._scrollSize = Math.max(\n      1,\n      this.items.length * (averageMarginSize + this._getAverageSize()) +\n        averageMarginSize\n    );\n  }\n\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  protected get _delta(): number {\n    const {averageMarginSize} = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx: number): Positions {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(\n        this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n        this._metricsCache.averageMarginSize\n      ),\n    } as Positions;\n  }\n\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx: number): Size {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n    } as Size;\n  }\n\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}