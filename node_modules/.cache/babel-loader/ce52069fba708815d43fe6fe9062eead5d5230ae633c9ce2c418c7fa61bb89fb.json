{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.weak-set.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from './context-request-event.js';\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and\n * re-dispatch them when new providers which satisfy matching context keys are\n * available.\n *\n * This allows providers to be added to a DOM tree, or upgraded, after the\n * consumers.\n */\nexport var ContextRoot = /*#__PURE__*/function () {\n  function ContextRoot() {\n    var _this = this;\n    _classCallCheck(this, ContextRoot);\n    this.pendingContextRequests = new Map();\n    this.onContextProvider = function (event) {\n      var pendingRequestData = _this.pendingContextRequests.get(event.context);\n      if (pendingRequestData === undefined) {\n        // No pending requests for this context at this time\n        return;\n      }\n      // Clear our list. Any still unsatisfied requests will re-add themselves\n      // when we dispatch the events below.\n      _this.pendingContextRequests.delete(event.context);\n      // Loop over all pending requests and re-dispatch them from their source\n      var requests = pendingRequestData.requests;\n      var _iterator = _createForOfIteratorHelper(requests),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _step.value,\n            elementRef = _step$value.elementRef,\n            callbackRef = _step$value.callbackRef;\n          var element = elementRef.deref();\n          var callback = callbackRef.deref();\n          if (element === undefined || callback === undefined) {\n            // The element was GC'ed. Do nothing.\n          } else {\n            // Re-dispatch if we still have the element and callback\n            element.dispatchEvent(new ContextRequestEvent(event.context, callback, true));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n    this.onContextRequest = function (event) {\n      // Events that are not subscribing should not be buffered\n      if (event.subscribe !== true) {\n        return;\n      }\n      // Note, it's important to use the initial target via composedPath()\n      // since that's the requesting element and the event may be re-targeted\n      // to an outer host element.\n      var element = event.composedPath()[0];\n      var callback = event.callback;\n      var pendingContextRequests = _this.pendingContextRequests.get(event.context);\n      if (pendingContextRequests === undefined) {\n        _this.pendingContextRequests.set(event.context, pendingContextRequests = {\n          callbacks: new WeakMap(),\n          requests: []\n        });\n      }\n      var callbacks = pendingContextRequests.callbacks.get(element);\n      if (callbacks === undefined) {\n        pendingContextRequests.callbacks.set(element, callbacks = new WeakSet());\n      }\n      if (callbacks.has(callback)) {\n        // We're already tracking this element/callback pair\n        return;\n      }\n      callbacks.add(callback);\n      pendingContextRequests.requests.push({\n        elementRef: new WeakRef(element),\n        callbackRef: new WeakRef(callback)\n      });\n    };\n  }\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  _createClass(ContextRoot, [{\n    key: \"attach\",\n    value: function attach(element) {\n      element.addEventListener('context-request', this.onContextRequest);\n      element.addEventListener('context-provider', this.onContextProvider);\n    }\n    /**\n     * Removes the ContextRoot event listeners from a given element.\n     *\n     * @param element an element from which to remove event listeners\n     */\n  }, {\n    key: \"detach\",\n    value: function detach(element) {\n      element.removeEventListener('context-request', this.onContextRequest);\n      element.removeEventListener('context-provider', this.onContextProvider);\n    }\n  }]);\n  return ContextRoot;\n}();","map":{"version":3,"names":["ContextRequestEvent","ContextRoot","_this","_classCallCheck","pendingContextRequests","Map","onContextProvider","event","pendingRequestData","get","context","undefined","delete","requests","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","value","elementRef","callbackRef","element","deref","callback","dispatchEvent","err","e","f","onContextRequest","subscribe","composedPath","set","callbacks","WeakMap","WeakSet","has","add","push","WeakRef","_createClass","key","attach","addEventListener","detach","removeEventListener"],"sources":["../../src/lib/context-root.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Context} from './create-context.js';\nimport {ContextCallback, ContextRequestEvent} from './context-request-event.js';\nimport {ContextProviderEvent} from './controllers/context-provider.js';\n\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and\n * re-dispatch them when new providers which satisfy matching context keys are\n * available.\n *\n * This allows providers to be added to a DOM tree, or upgraded, after the\n * consumers.\n */\nexport class ContextRoot {\n  private pendingContextRequests = new Map<\n    Context<unknown, unknown>,\n    {\n      // The WeakMap lets us detect if we're seen an element/callback pair yet,\n      // without needing to iterate the `requests` array\n      callbacks: WeakMap<HTMLElement, WeakSet<ContextCallback<unknown>>>;\n\n      // Requests lets us iterate over every element/callback that we need to\n      // replay context events for\n      // Both the element and callback must be stored in WeakRefs because the\n      // callback most likely has a strong ref to the element.\n      requests: Array<{\n        elementRef: WeakRef<HTMLElement>;\n        callbackRef: WeakRef<ContextCallback<unknown>>;\n      }>;\n    }\n  >();\n\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  attach(element: HTMLElement): void {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  detach(element: HTMLElement): void {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n\n  private onContextProvider = (\n    event: ContextProviderEvent<Context<unknown, unknown>>\n  ) => {\n    const pendingRequestData = this.pendingContextRequests.get(event.context);\n    if (pendingRequestData === undefined) {\n      // No pending requests for this context at this time\n      return;\n    }\n\n    // Clear our list. Any still unsatisfied requests will re-add themselves\n    // when we dispatch the events below.\n    this.pendingContextRequests.delete(event.context);\n\n    // Loop over all pending requests and re-dispatch them from their source\n    const {requests} = pendingRequestData;\n    for (const {elementRef, callbackRef} of requests) {\n      const element = elementRef.deref();\n      const callback = callbackRef.deref();\n\n      if (element === undefined || callback === undefined) {\n        // The element was GC'ed. Do nothing.\n      } else {\n        // Re-dispatch if we still have the element and callback\n        element.dispatchEvent(\n          new ContextRequestEvent(event.context, callback, true)\n        );\n      }\n    }\n  };\n\n  private onContextRequest = (\n    event: ContextRequestEvent<Context<unknown, unknown>>\n  ) => {\n    // Events that are not subscribing should not be buffered\n    if (event.subscribe !== true) {\n      return;\n    }\n\n    // Note, it's important to use the initial target via composedPath()\n    // since that's the requesting element and the event may be re-targeted\n    // to an outer host element.\n    const element = event.composedPath()[0] as HTMLElement;\n    const callback = event.callback;\n\n    let pendingContextRequests = this.pendingContextRequests.get(event.context);\n    if (pendingContextRequests === undefined) {\n      this.pendingContextRequests.set(\n        event.context,\n        (pendingContextRequests = {\n          callbacks: new WeakMap(),\n          requests: [],\n        })\n      );\n    }\n\n    let callbacks = pendingContextRequests.callbacks.get(element);\n    if (callbacks === undefined) {\n      pendingContextRequests.callbacks.set(\n        element,\n        (callbacks = new WeakSet())\n      );\n    }\n\n    if (callbacks.has(callback)) {\n      // We're already tracking this element/callback pair\n      return;\n    }\n\n    callbacks.add(callback);\n    pendingContextRequests.requests.push({\n      elementRef: new WeakRef(element),\n      callbackRef: new WeakRef(callback),\n    });\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}