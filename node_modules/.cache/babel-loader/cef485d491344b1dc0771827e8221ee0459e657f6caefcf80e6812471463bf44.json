{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Re-dispatches an event from the provided element.\n *\n * This function is useful for forwarding non-composed events, such as `change`\n * events.\n *\n * @example\n * class MyInput extends LitElement {\n *   render() {\n *     return html`<input @change=${this.redispatchEvent}>`;\n *   }\n *\n *   protected redispatchEvent(event: Event) {\n *     redispatchEvent(this, event);\n *   }\n * }\n *\n * @param element The element to dispatch the event from.\n * @param event The event to re-dispatch.\n * @return Whether or not the event was dispatched (if cancelable).\n */\nexport function redispatchEvent(element, event) {\n  // For bubbling events in SSR light DOM (or composed), stop their propagation\n  // and dispatch the copy.\n  if (event.bubbles && (!element.shadowRoot || event.composed)) {\n    event.stopPropagation();\n  }\n  var copy = Reflect.construct(event.constructor, [event.type, event]);\n  var dispatched = element.dispatchEvent(copy);\n  if (!dispatched) {\n    event.preventDefault();\n  }\n  return dispatched;\n}","map":{"version":3,"names":["redispatchEvent","element","event","bubbles","shadowRoot","composed","stopPropagation","copy","Reflect","construct","constructor","type","dispatched","dispatchEvent","preventDefault"],"sources":["redispatch-event.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Re-dispatches an event from the provided element.\n *\n * This function is useful for forwarding non-composed events, such as `change`\n * events.\n *\n * @example\n * class MyInput extends LitElement {\n *   render() {\n *     return html`<input @change=${this.redispatchEvent}>`;\n *   }\n *\n *   protected redispatchEvent(event: Event) {\n *     redispatchEvent(this, event);\n *   }\n * }\n *\n * @param element The element to dispatch the event from.\n * @param event The event to re-dispatch.\n * @return Whether or not the event was dispatched (if cancelable).\n */\nexport function redispatchEvent(element: Element, event: Event) {\n  // For bubbling events in SSR light DOM (or composed), stop their propagation\n  // and dispatch the copy.\n  if (event.bubbles && (!element.shadowRoot || event.composed)) {\n    event.stopPropagation();\n  }\n\n  const copy = Reflect.construct(event.constructor, [event.type, event]);\n  const dispatched = element.dispatchEvent(copy);\n  if (!dispatched) {\n    event.preventDefault();\n  }\n\n  return dispatched;\n}\n"],"mappings":";;;AAAA;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUA,eAAeA,CAACC,OAAgB,EAAEC,KAAY;EAC5D;EACA;EACA,IAAIA,KAAK,CAACC,OAAO,KAAK,CAACF,OAAO,CAACG,UAAU,IAAIF,KAAK,CAACG,QAAQ,CAAC,EAAE;IAC5DH,KAAK,CAACI,eAAe,EAAE;;EAGzB,IAAMC,IAAI,GAAGC,OAAO,CAACC,SAAS,CAACP,KAAK,CAACQ,WAAW,EAAE,CAACR,KAAK,CAACS,IAAI,EAAET,KAAK,CAAC,CAAC;EACtE,IAAMU,UAAU,GAAGX,OAAO,CAACY,aAAa,CAACN,IAAI,CAAC;EAC9C,IAAI,CAACK,UAAU,EAAE;IACfV,KAAK,CAACY,cAAc,EAAE;;EAGxB,OAAOF,UAAU;AACnB"},"metadata":{},"sourceType":"module","externalDependencies":[]}