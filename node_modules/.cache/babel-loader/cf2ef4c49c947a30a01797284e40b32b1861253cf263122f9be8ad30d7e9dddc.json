{"ast":null,"code":"import { getCollection } from \"./collection.js\";\nimport { getStates } from \"./commands.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nfunction processEvent(store, updates) {\n  const state = Object.assign({}, store.state);\n  if (updates.a) {\n    for (const entityId in updates.a) {\n      const newState = updates.a[entityId];\n      let last_changed = new Date(newState.lc * 1000).toISOString();\n      state[entityId] = {\n        entity_id: entityId,\n        state: newState.s,\n        attributes: newState.a,\n        context: typeof newState.c === \"string\" ? {\n          id: newState.c,\n          parent_id: null,\n          user_id: null\n        } : newState.c,\n        last_changed: last_changed,\n        last_updated: newState.lu ? new Date(newState.lu * 1000).toISOString() : last_changed\n      };\n    }\n  }\n  if (updates.r) {\n    for (const entityId of updates.r) {\n      delete state[entityId];\n    }\n  }\n  if (updates.c) {\n    for (const entityId in updates.c) {\n      let entityState = state[entityId];\n      if (!entityState) {\n        console.warn(\"Received state update for unknown entity\", entityId);\n        continue;\n      }\n      entityState = Object.assign({}, entityState);\n      const {\n        \"+\": toAdd,\n        \"-\": toRemove\n      } = updates.c[entityId];\n      const attributesChanged = (toAdd === null || toAdd === void 0 ? void 0 : toAdd.a) || (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a);\n      const attributes = attributesChanged ? Object.assign({}, entityState.attributes) : entityState.attributes;\n      if (toAdd) {\n        if (toAdd.s !== undefined) {\n          entityState.state = toAdd.s;\n        }\n        if (toAdd.c) {\n          if (typeof toAdd.c === \"string\") {\n            entityState.context = Object.assign(Object.assign({}, entityState.context), {\n              id: toAdd.c\n            });\n          } else {\n            entityState.context = Object.assign(Object.assign({}, entityState.context), toAdd.c);\n          }\n        }\n        if (toAdd.lc) {\n          entityState.last_updated = entityState.last_changed = new Date(toAdd.lc * 1000).toISOString();\n        } else if (toAdd.lu) {\n          entityState.last_updated = new Date(toAdd.lu * 1000).toISOString();\n        }\n        if (toAdd.a) {\n          Object.assign(attributes, toAdd.a);\n        }\n      }\n      if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a) {\n        for (const key of toRemove.a) {\n          delete attributes[key];\n        }\n      }\n      if (attributesChanged) {\n        entityState.attributes = attributes;\n      }\n      state[entityId] = entityState;\n    }\n  }\n  store.setState(state, true);\n}\nconst subscribeUpdates = (conn, store) => conn.subscribeMessage(ev => processEvent(store, ev), {\n  type: \"subscribe_entities\"\n});\nfunction legacyProcessEvent(store, event) {\n  const state = store.state;\n  if (state === undefined) return;\n  const {\n    entity_id,\n    new_state\n  } = event.data;\n  if (new_state) {\n    store.setState({\n      [new_state.entity_id]: new_state\n    });\n  } else {\n    const newEntities = Object.assign({}, state);\n    delete newEntities[entity_id];\n    store.setState(newEntities, true);\n  }\n}\nasync function legacyFetchEntities(conn) {\n  const states = await getStates(conn);\n  const entities = {};\n  for (let i = 0; i < states.length; i++) {\n    const state = states[i];\n    entities[state.entity_id] = state;\n  }\n  return entities;\n}\nconst legacySubscribeUpdates = (conn, store) => conn.subscribeEvents(ev => legacyProcessEvent(store, ev), \"state_changed\");\nexport const entitiesColl = conn => atLeastHaVersion(conn.haVersion, 2022, 4, 0) ? getCollection(conn, \"_ent\", undefined, subscribeUpdates) : getCollection(conn, \"_ent\", legacyFetchEntities, legacySubscribeUpdates);\nexport const subscribeEntities = (conn, onChange) => entitiesColl(conn).subscribe(onChange);","map":{"version":3,"names":["getCollection","getStates","atLeastHaVersion","processEvent","store","updates","state","Object","assign","a","entityId","newState","last_changed","Date","lc","toISOString","entity_id","s","attributes","context","c","id","parent_id","user_id","last_updated","lu","r","entityState","console","warn","toAdd","toRemove","attributesChanged","undefined","key","setState","subscribeUpdates","conn","subscribeMessage","ev","type","legacyProcessEvent","event","new_state","data","newEntities","legacyFetchEntities","states","entities","i","length","legacySubscribeUpdates","subscribeEvents","entitiesColl","haVersion","subscribeEntities","onChange","subscribe"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/home-assistant-js-websocket/dist/entities.js"],"sourcesContent":["import { getCollection } from \"./collection.js\";\nimport { getStates } from \"./commands.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nfunction processEvent(store, updates) {\n    const state = Object.assign({}, store.state);\n    if (updates.a) {\n        for (const entityId in updates.a) {\n            const newState = updates.a[entityId];\n            let last_changed = new Date(newState.lc * 1000).toISOString();\n            state[entityId] = {\n                entity_id: entityId,\n                state: newState.s,\n                attributes: newState.a,\n                context: typeof newState.c === \"string\"\n                    ? { id: newState.c, parent_id: null, user_id: null }\n                    : newState.c,\n                last_changed: last_changed,\n                last_updated: newState.lu\n                    ? new Date(newState.lu * 1000).toISOString()\n                    : last_changed,\n            };\n        }\n    }\n    if (updates.r) {\n        for (const entityId of updates.r) {\n            delete state[entityId];\n        }\n    }\n    if (updates.c) {\n        for (const entityId in updates.c) {\n            let entityState = state[entityId];\n            if (!entityState) {\n                console.warn(\"Received state update for unknown entity\", entityId);\n                continue;\n            }\n            entityState = Object.assign({}, entityState);\n            const { \"+\": toAdd, \"-\": toRemove } = updates.c[entityId];\n            const attributesChanged = (toAdd === null || toAdd === void 0 ? void 0 : toAdd.a) || (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a);\n            const attributes = attributesChanged\n                ? Object.assign({}, entityState.attributes) : entityState.attributes;\n            if (toAdd) {\n                if (toAdd.s !== undefined) {\n                    entityState.state = toAdd.s;\n                }\n                if (toAdd.c) {\n                    if (typeof toAdd.c === \"string\") {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), { id: toAdd.c });\n                    }\n                    else {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), toAdd.c);\n                    }\n                }\n                if (toAdd.lc) {\n                    entityState.last_updated = entityState.last_changed = new Date(toAdd.lc * 1000).toISOString();\n                }\n                else if (toAdd.lu) {\n                    entityState.last_updated = new Date(toAdd.lu * 1000).toISOString();\n                }\n                if (toAdd.a) {\n                    Object.assign(attributes, toAdd.a);\n                }\n            }\n            if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a) {\n                for (const key of toRemove.a) {\n                    delete attributes[key];\n                }\n            }\n            if (attributesChanged) {\n                entityState.attributes = attributes;\n            }\n            state[entityId] = entityState;\n        }\n    }\n    store.setState(state, true);\n}\nconst subscribeUpdates = (conn, store) => conn.subscribeMessage((ev) => processEvent(store, ev), {\n    type: \"subscribe_entities\",\n});\nfunction legacyProcessEvent(store, event) {\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { entity_id, new_state } = event.data;\n    if (new_state) {\n        store.setState({ [new_state.entity_id]: new_state });\n    }\n    else {\n        const newEntities = Object.assign({}, state);\n        delete newEntities[entity_id];\n        store.setState(newEntities, true);\n    }\n}\nasync function legacyFetchEntities(conn) {\n    const states = await getStates(conn);\n    const entities = {};\n    for (let i = 0; i < states.length; i++) {\n        const state = states[i];\n        entities[state.entity_id] = state;\n    }\n    return entities;\n}\nconst legacySubscribeUpdates = (conn, store) => conn.subscribeEvents((ev) => legacyProcessEvent(store, ev), \"state_changed\");\nexport const entitiesColl = (conn) => atLeastHaVersion(conn.haVersion, 2022, 4, 0)\n    ? getCollection(conn, \"_ent\", undefined, subscribeUpdates)\n    : getCollection(conn, \"_ent\", legacyFetchEntities, legacySubscribeUpdates);\nexport const subscribeEntities = (conn, onChange) => entitiesColl(conn).subscribe(onChange);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}