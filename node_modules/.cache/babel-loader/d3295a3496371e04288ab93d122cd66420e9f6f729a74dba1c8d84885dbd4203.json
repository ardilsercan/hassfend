{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Easing functions to use for web animations.\n *\n * **NOTE:** `EASING.EMPHASIZED` is approximated with unknown accuracy.\n *\n * TODO(b/241113345): replace with tokens\n */\nexport var EASING = {\n  STANDARD: 'cubic-bezier(0.2, 0, 0, 1)',\n  STANDARD_ACCELERATE: 'cubic-bezier(.3,0,1,1)',\n  STANDARD_DECELERATE: 'cubic-bezier(0,0,0,1)',\n  EMPHASIZED: 'cubic-bezier(.3,0,0,1)',\n  EMPHASIZED_ACCELERATE: 'cubic-bezier(.3,0,.8,.15)',\n  EMPHASIZED_DECELERATE: 'cubic-bezier(.05,.7,.1,1)'\n};\n/**\n * Creates an `AnimationSignal` that can be used to cancel a previous task.\n *\n * @example\n * class MyClass {\n *   private labelAnimationSignal = createAnimationSignal();\n *\n *   private async animateLabel() {\n *     // Start of the task. Previous tasks will be canceled.\n *     const signal = this.labelAnimationSignal.start();\n *\n *     // Do async work...\n *     if (signal.aborted) {\n *       // Use AbortSignal to check if a request was made to abort after some\n *       // asynchronous work.\n *       return;\n *     }\n *\n *     const animation = this.animate(...);\n *     // Add event listeners to be notified when the task should be canceled.\n *     signal.addEventListener('abort', () => {\n *       animation.cancel();\n *     });\n *\n *     animation.addEventListener('finish', () => {\n *       // Tell the signal that the current task is finished.\n *       this.labelAnimationSignal.finish();\n *     });\n *   }\n * }\n *\n * @return An `AnimationSignal`.\n */\nexport function createAnimationSignal() {\n  // The current animation's AbortController\n  var animationAbortController = null;\n  return {\n    start: function start() {\n      var _animationAbortContro;\n      // Tell the previous animation to cancel.\n      (_animationAbortContro = animationAbortController) === null || _animationAbortContro === void 0 || _animationAbortContro.abort();\n      // Set up a new AbortController for the current animation.\n      animationAbortController = new AbortController();\n      // Provide the AbortSignal so that the caller can check aborted status\n      // and add listeners.\n      return animationAbortController.signal;\n    },\n    finish: function finish() {\n      animationAbortController = null;\n    }\n  };\n}\n/**\n * Returns a function which can be used to throttle function calls\n * mapped to a key via a given function that should produce a promise that\n * determines the throttle amount (defaults to requestAnimationFrame).\n */\nexport function createThrottle() {\n  var stack = new Set();\n  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var key,\n      cb,\n      timeout,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          key = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : '';\n          cb = _args2.length > 1 ? _args2[1] : undefined;\n          timeout = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return new Promise(requestAnimationFrame);\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          if (stack.has(key)) {\n            _context2.next = 8;\n            break;\n          }\n          stack.add(key);\n          _context2.next = 7;\n          return timeout();\n        case 7:\n          if (stack.has(key)) {\n            stack.delete(key);\n            cb();\n          }\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n}\n/**\n * Parses an number in milliseconds from a css time value\n */\nexport function msFromTimeCSSValue(value) {\n  var match = value.trim().match(/([\\d.]+)(\\s*s$)?/);\n  var time = match === null || match === void 0 ? void 0 : match[1];\n  var seconds = match === null || match === void 0 ? void 0 : match[2];\n  return Number(time !== null && time !== void 0 ? time : 0) * (seconds ? 1000 : 1);\n}","map":{"version":3,"names":["EASING","STANDARD","STANDARD_ACCELERATE","STANDARD_DECELERATE","EMPHASIZED","EMPHASIZED_ACCELERATE","EMPHASIZED_DECELERATE","createAnimationSignal","animationAbortController","start","_animationAbortContro","abort","AbortController","signal","finish","createThrottle","stack","Set","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","key","cb","timeout","_args2","arguments","wrap","_callee2$","_context2","prev","next","length","undefined","_callee","_callee$","_context","Promise","requestAnimationFrame","stop","has","add","delete","msFromTimeCSSValue","value","match","trim","time","seconds","Number"],"sources":["animation.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Easing functions to use for web animations.\n *\n * **NOTE:** `EASING.EMPHASIZED` is approximated with unknown accuracy.\n *\n * TODO(b/241113345): replace with tokens\n */\nexport const EASING = {\n  STANDARD: 'cubic-bezier(0.2, 0, 0, 1)',\n  STANDARD_ACCELERATE: 'cubic-bezier(.3,0,1,1)',\n  STANDARD_DECELERATE: 'cubic-bezier(0,0,0,1)',\n  EMPHASIZED: 'cubic-bezier(.3,0,0,1)',\n  EMPHASIZED_ACCELERATE: 'cubic-bezier(.3,0,.8,.15)',\n  EMPHASIZED_DECELERATE: 'cubic-bezier(.05,.7,.1,1)',\n} as const;\n\n/**\n * A signal that is used for abortable tasks.\n */\nexport interface AnimationSignal {\n  /**\n   * Starts the abortable task. Any previous tasks started with this instance\n   * will be aborted.\n   *\n   * @return An `AbortSignal` for the current task.\n   */\n  start(): AbortSignal;\n  /**\n   * Complete the current task.\n   */\n  finish(): void;\n}\n\n/**\n * Creates an `AnimationSignal` that can be used to cancel a previous task.\n *\n * @example\n * class MyClass {\n *   private labelAnimationSignal = createAnimationSignal();\n *\n *   private async animateLabel() {\n *     // Start of the task. Previous tasks will be canceled.\n *     const signal = this.labelAnimationSignal.start();\n *\n *     // Do async work...\n *     if (signal.aborted) {\n *       // Use AbortSignal to check if a request was made to abort after some\n *       // asynchronous work.\n *       return;\n *     }\n *\n *     const animation = this.animate(...);\n *     // Add event listeners to be notified when the task should be canceled.\n *     signal.addEventListener('abort', () => {\n *       animation.cancel();\n *     });\n *\n *     animation.addEventListener('finish', () => {\n *       // Tell the signal that the current task is finished.\n *       this.labelAnimationSignal.finish();\n *     });\n *   }\n * }\n *\n * @return An `AnimationSignal`.\n */\nexport function createAnimationSignal(): AnimationSignal {\n  // The current animation's AbortController\n  let animationAbortController: AbortController | null = null;\n\n  return {\n    start() {\n      // Tell the previous animation to cancel.\n      animationAbortController?.abort();\n      // Set up a new AbortController for the current animation.\n      animationAbortController = new AbortController();\n      // Provide the AbortSignal so that the caller can check aborted status\n      // and add listeners.\n      return animationAbortController.signal;\n    },\n    finish() {\n      animationAbortController = null;\n    },\n  };\n}\n\n/**\n * Returns a function which can be used to throttle function calls\n * mapped to a key via a given function that should produce a promise that\n * determines the throttle amount (defaults to requestAnimationFrame).\n */\nexport function createThrottle() {\n  const stack = new Set();\n  return async (\n    key = '',\n    cb: (...args: unknown[]) => unknown,\n    timeout = async () => {\n      await new Promise(requestAnimationFrame);\n    },\n  ) => {\n    if (!stack.has(key)) {\n      stack.add(key);\n      await timeout();\n      if (stack.has(key)) {\n        stack.delete(key);\n        cb();\n      }\n    }\n  };\n}\n\n/**\n * Parses an number in milliseconds from a css time value\n */\nexport function msFromTimeCSSValue(value: string) {\n  const match = value.trim().match(/([\\d.]+)(\\s*s$)?/);\n  const time = match?.[1];\n  const seconds = match?.[2];\n  return Number(time ?? 0) * (seconds ? 1000 : 1);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}