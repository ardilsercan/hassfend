{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\nimport { html, isServer, LitElement } from 'lit';\nimport { property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { AttachableController } from '../../internal/controller/attachable-controller.js';\nimport { EASING } from '../../internal/motion/animation.js';\nconst PRESS_GROW_MS = 450;\nconst MINIMUM_PRESS_MS = 225;\nconst INITIAL_ORIGIN_SCALE = 0.2;\nconst PADDING = 10;\nconst SOFT_EDGE_MINIMUM_SIZE = 75;\nconst SOFT_EDGE_CONTAINER_RATIO = 0.35;\nconst PRESS_PSEUDO = '::after';\nconst ANIMATION_FILL = 'forwards';\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nvar State;\n(function (State) {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"INACTIVE\"] = 0] = \"INACTIVE\";\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: begin press; transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: begin press; transition to `HOLDING`.\n   */\n  State[State[\"TOUCH_DELAY\"] = 1] = \"TOUCH_DELAY\";\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"HOLDING\"] = 2] = \"HOLDING\";\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click end press; transition to `INACTIVE`.\n   */\n  State[State[\"WAITING_FOR_CLICK\"] = 3] = \"WAITING_FOR_CLICK\";\n})(State || (State = {}));\n/**\n * Events that the ripple listens to.\n */\nconst EVENTS = ['click', 'contextmenu', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerup'];\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n/**\n * Used to detect if HCM is active. Events do not process during HCM when the\n * ripple is not displayed.\n */\nconst FORCED_COLORS = isServer ? null : window.matchMedia('(forced-colors: active)');\n/**\n * A ripple component.\n */\nexport class Ripple extends LitElement {\n  constructor() {\n    super(...arguments);\n    /**\n     * Disables the ripple.\n     */\n    this.disabled = false;\n    this.hovered = false;\n    this.pressed = false;\n    this.rippleSize = '';\n    this.rippleScale = '';\n    this.initialSize = 0;\n    this.state = State.INACTIVE;\n    this.checkBoundsAfterContextMenu = false;\n    this.attachableController = new AttachableController(this, this.onControlChange.bind(this));\n  }\n  get htmlFor() {\n    return this.attachableController.htmlFor;\n  }\n  set htmlFor(htmlFor) {\n    this.attachableController.htmlFor = htmlFor;\n  }\n  get control() {\n    return this.attachableController.control;\n  }\n  set control(control) {\n    this.attachableController.control = control;\n  }\n  attach(control) {\n    this.attachableController.attach(control);\n  }\n  detach() {\n    this.attachableController.detach();\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    // Needed for VoiceOver, which will create a \"group\" if the element is a\n    // sibling to other content.\n    this.setAttribute('aria-hidden', 'true');\n  }\n  render() {\n    const classes = {\n      'hovered': this.hovered,\n      'pressed': this.pressed\n    };\n    return html`<div class=\"surface ${classMap(classes)}\"></div>`;\n  }\n  update(changedProps) {\n    if (changedProps.has('disabled') && this.disabled) {\n      this.hovered = false;\n      this.pressed = false;\n    }\n    super.update(changedProps);\n  }\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerenter(event) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n    this.hovered = true;\n  }\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerleave(event) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n    this.hovered = false;\n    // release a held mouse or pen press that moves outside the element\n    if (this.state !== State.INACTIVE) {\n      this.endPressAnimation();\n    }\n  }\n  handlePointerup(event) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n      return;\n    }\n    if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(this.rippleStartEvent);\n      return;\n    }\n  }\n  async handlePointerdown(event) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n    this.rippleStartEvent = event;\n    if (!this.isTouch(event)) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(event);\n      return;\n    }\n    // after a longpress contextmenu event, an extra `pointerdown` can be\n    // dispatched to the pressed element. Check that the down is within\n    // bounds of the element in this case.\n    if (this.checkBoundsAfterContextMenu && !this.inBounds(event)) {\n      return;\n    }\n    this.checkBoundsAfterContextMenu = false;\n    // Wait for a hold after touch delay\n    this.state = State.TOUCH_DELAY;\n    await new Promise(resolve => {\n      setTimeout(resolve, TOUCH_DELAY_MS);\n    });\n    if (this.state !== State.TOUCH_DELAY) {\n      return;\n    }\n    this.state = State.HOLDING;\n    this.startPressAnimation(event);\n  }\n  handleClick() {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (this.disabled) {\n      return;\n    }\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPressAnimation();\n      return;\n    }\n    if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.startPressAnimation();\n      this.endPressAnimation();\n    }\n  }\n  handlePointercancel(event) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n    this.endPressAnimation();\n  }\n  handleContextmenu() {\n    if (this.disabled) {\n      return;\n    }\n    this.checkBoundsAfterContextMenu = true;\n    this.endPressAnimation();\n  }\n  determineRippleSize() {\n    const {\n      height,\n      width\n    } = this.getBoundingClientRect();\n    const maxDim = Math.max(height, width);\n    const softEdgeSize = Math.max(SOFT_EDGE_CONTAINER_RATIO * maxDim, SOFT_EDGE_MINIMUM_SIZE);\n    const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n    const hypotenuse = Math.sqrt(width ** 2 + height ** 2);\n    const maxRadius = hypotenuse + PADDING;\n    this.initialSize = initialSize;\n    this.rippleScale = `${(maxRadius + softEdgeSize) / initialSize}`;\n    this.rippleSize = `${initialSize}px`;\n  }\n  getNormalizedPointerEventCoords(pointerEvent) {\n    const {\n      scrollX,\n      scrollY\n    } = window;\n    const {\n      left,\n      top\n    } = this.getBoundingClientRect();\n    const documentX = scrollX + left;\n    const documentY = scrollY + top;\n    const {\n      pageX,\n      pageY\n    } = pointerEvent;\n    return {\n      x: pageX - documentX,\n      y: pageY - documentY\n    };\n  }\n  getTranslationCoordinates(positionEvent) {\n    const {\n      height,\n      width\n    } = this.getBoundingClientRect();\n    // end in the center\n    const endPoint = {\n      x: (width - this.initialSize) / 2,\n      y: (height - this.initialSize) / 2\n    };\n    let startPoint;\n    if (positionEvent instanceof PointerEvent) {\n      startPoint = this.getNormalizedPointerEventCoords(positionEvent);\n    } else {\n      startPoint = {\n        x: width / 2,\n        y: height / 2\n      };\n    }\n    // center around start point\n    startPoint = {\n      x: startPoint.x - this.initialSize / 2,\n      y: startPoint.y - this.initialSize / 2\n    };\n    return {\n      startPoint,\n      endPoint\n    };\n  }\n  startPressAnimation(positionEvent) {\n    var _this$growAnimation;\n    if (!this.mdRoot) {\n      return;\n    }\n    this.pressed = true;\n    (_this$growAnimation = this.growAnimation) === null || _this$growAnimation === void 0 || _this$growAnimation.cancel();\n    this.determineRippleSize();\n    const {\n      startPoint,\n      endPoint\n    } = this.getTranslationCoordinates(positionEvent);\n    const translateStart = `${startPoint.x}px, ${startPoint.y}px`;\n    const translateEnd = `${endPoint.x}px, ${endPoint.y}px`;\n    this.growAnimation = this.mdRoot.animate({\n      top: [0, 0],\n      left: [0, 0],\n      height: [this.rippleSize, this.rippleSize],\n      width: [this.rippleSize, this.rippleSize],\n      transform: [`translate(${translateStart}) scale(1)`, `translate(${translateEnd}) scale(${this.rippleScale})`]\n    }, {\n      pseudoElement: PRESS_PSEUDO,\n      duration: PRESS_GROW_MS,\n      easing: EASING.STANDARD,\n      fill: ANIMATION_FILL\n    });\n  }\n  async endPressAnimation() {\n    this.rippleStartEvent = undefined;\n    this.state = State.INACTIVE;\n    const animation = this.growAnimation;\n    let pressAnimationPlayState = Infinity;\n    if (typeof (animation === null || animation === void 0 ? void 0 : animation.currentTime) === 'number') {\n      pressAnimationPlayState = animation.currentTime;\n    } else if (animation !== null && animation !== void 0 && animation.currentTime) {\n      pressAnimationPlayState = animation.currentTime.to('ms').value;\n    }\n    if (pressAnimationPlayState >= MINIMUM_PRESS_MS) {\n      this.pressed = false;\n      return;\n    }\n    await new Promise(resolve => {\n      setTimeout(resolve, MINIMUM_PRESS_MS - pressAnimationPlayState);\n    });\n    if (this.growAnimation !== animation) {\n      // A new press animation was started. The old animation was canceled and\n      // should not finish the pressed state.\n      return;\n    }\n    this.pressed = false;\n  }\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  shouldReactToEvent(event) {\n    if (this.disabled || !event.isPrimary) {\n      return false;\n    }\n    if (this.rippleStartEvent && this.rippleStartEvent.pointerId !== event.pointerId) {\n      return false;\n    }\n    if (event.type === 'pointerenter' || event.type === 'pointerleave') {\n      return !this.isTouch(event);\n    }\n    const isPrimaryButton = event.buttons === 1;\n    return this.isTouch(event) || isPrimaryButton;\n  }\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  inBounds({\n    x,\n    y\n  }) {\n    const {\n      top,\n      left,\n      bottom,\n      right\n    } = this.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n  isTouch({\n    pointerType\n  }) {\n    return pointerType === 'touch';\n  }\n  /** @private */\n  async handleEvent(event) {\n    if (FORCED_COLORS !== null && FORCED_COLORS !== void 0 && FORCED_COLORS.matches) {\n      // Skip event logic since the ripple is `display: none`.\n      return;\n    }\n    switch (event.type) {\n      case 'click':\n        this.handleClick();\n        break;\n      case 'contextmenu':\n        this.handleContextmenu();\n        break;\n      case 'pointercancel':\n        this.handlePointercancel(event);\n        break;\n      case 'pointerdown':\n        await this.handlePointerdown(event);\n        break;\n      case 'pointerenter':\n        this.handlePointerenter(event);\n        break;\n      case 'pointerleave':\n        this.handlePointerleave(event);\n        break;\n      case 'pointerup':\n        this.handlePointerup(event);\n        break;\n      default:\n        break;\n    }\n  }\n  onControlChange(prev, next) {\n    if (isServer) return;\n    for (const event of EVENTS) {\n      prev === null || prev === void 0 || prev.removeEventListener(event, this);\n      next === null || next === void 0 || next.addEventListener(event, this);\n    }\n  }\n}\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], Ripple.prototype, \"disabled\", void 0);\n__decorate([state()], Ripple.prototype, \"hovered\", void 0);\n__decorate([state()], Ripple.prototype, \"pressed\", void 0);\n__decorate([query('.surface')], Ripple.prototype, \"mdRoot\", void 0);","map":{"version":3,"names":["html","isServer","LitElement","property","query","state","classMap","AttachableController","EASING","PRESS_GROW_MS","MINIMUM_PRESS_MS","INITIAL_ORIGIN_SCALE","PADDING","SOFT_EDGE_MINIMUM_SIZE","SOFT_EDGE_CONTAINER_RATIO","PRESS_PSEUDO","ANIMATION_FILL","State","EVENTS","TOUCH_DELAY_MS","FORCED_COLORS","window","matchMedia","Ripple","constructor","disabled","hovered","pressed","rippleSize","rippleScale","initialSize","INACTIVE","checkBoundsAfterContextMenu","attachableController","onControlChange","bind","htmlFor","control","attach","detach","connectedCallback","setAttribute","render","classes","update","changedProps","has","handlePointerenter","event","shouldReactToEvent","handlePointerleave","endPressAnimation","handlePointerup","HOLDING","WAITING_FOR_CLICK","TOUCH_DELAY","startPressAnimation","rippleStartEvent","handlePointerdown","isTouch","inBounds","Promise","resolve","setTimeout","handleClick","handlePointercancel","handleContextmenu","determineRippleSize","height","width","getBoundingClientRect","maxDim","Math","max","softEdgeSize","floor","hypotenuse","sqrt","maxRadius","getNormalizedPointerEventCoords","pointerEvent","scrollX","scrollY","left","top","documentX","documentY","pageX","pageY","x","y","getTranslationCoordinates","positionEvent","endPoint","startPoint","PointerEvent","_this$growAnimation","mdRoot","growAnimation","cancel","translateStart","translateEnd","animate","transform","pseudoElement","duration","easing","STANDARD","fill","undefined","animation","pressAnimationPlayState","Infinity","currentTime","to","value","isPrimary","pointerId","type","isPrimaryButton","buttons","bottom","right","pointerType","handleEvent","matches","prev","next","removeEventListener","addEventListener","__decorate","Boolean","reflect"],"sources":["ripple.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html, isServer, LitElement, PropertyValues} from 'lit';\nimport {property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\n\nimport {\n  Attachable,\n  AttachableController,\n} from '../../internal/controller/attachable-controller.js';\nimport {EASING} from '../../internal/motion/animation.js';\n\nconst PRESS_GROW_MS = 450;\nconst MINIMUM_PRESS_MS = 225;\nconst INITIAL_ORIGIN_SCALE = 0.2;\nconst PADDING = 10;\nconst SOFT_EDGE_MINIMUM_SIZE = 75;\nconst SOFT_EDGE_CONTAINER_RATIO = 0.35;\nconst PRESS_PSEUDO = '::after';\nconst ANIMATION_FILL = 'forwards';\n\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nenum State {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  INACTIVE,\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: begin press; transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: begin press; transition to `HOLDING`.\n   */\n  TOUCH_DELAY,\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  HOLDING,\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click end press; transition to `INACTIVE`.\n   */\n  WAITING_FOR_CLICK,\n}\n\n/**\n * Events that the ripple listens to.\n */\nconst EVENTS = [\n  'click',\n  'contextmenu',\n  'pointercancel',\n  'pointerdown',\n  'pointerenter',\n  'pointerleave',\n  'pointerup',\n];\n\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n\n/**\n * Used to detect if HCM is active. Events do not process during HCM when the\n * ripple is not displayed.\n */\nconst FORCED_COLORS = isServer\n  ? null\n  : window.matchMedia('(forced-colors: active)');\n\n/**\n * A ripple component.\n */\nexport class Ripple extends LitElement implements Attachable {\n  /**\n   * Disables the ripple.\n   */\n  @property({type: Boolean, reflect: true}) disabled = false;\n\n  get htmlFor() {\n    return this.attachableController.htmlFor;\n  }\n\n  set htmlFor(htmlFor: string | null) {\n    this.attachableController.htmlFor = htmlFor;\n  }\n\n  get control() {\n    return this.attachableController.control;\n  }\n  set control(control: HTMLElement | null) {\n    this.attachableController.control = control;\n  }\n\n  @state() private hovered = false;\n  @state() private pressed = false;\n\n  @query('.surface') private readonly mdRoot!: HTMLElement | null;\n  private rippleSize = '';\n  private rippleScale = '';\n  private initialSize = 0;\n  private growAnimation?: Animation;\n  private state = State.INACTIVE;\n  private rippleStartEvent?: PointerEvent;\n  private checkBoundsAfterContextMenu = false;\n  private readonly attachableController = new AttachableController(\n    this,\n    this.onControlChange.bind(this),\n  );\n\n  attach(control: HTMLElement) {\n    this.attachableController.attach(control);\n  }\n\n  detach() {\n    this.attachableController.detach();\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    // Needed for VoiceOver, which will create a \"group\" if the element is a\n    // sibling to other content.\n    this.setAttribute('aria-hidden', 'true');\n  }\n\n  protected override render() {\n    const classes = {\n      'hovered': this.hovered,\n      'pressed': this.pressed,\n    };\n\n    return html`<div class=\"surface ${classMap(classes)}\"></div>`;\n  }\n\n  protected override update(changedProps: PropertyValues<Ripple>) {\n    if (changedProps.has('disabled') && this.disabled) {\n      this.hovered = false;\n      this.pressed = false;\n    }\n    super.update(changedProps);\n  }\n\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerenter(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.hovered = true;\n  }\n\n  /**\n   * TODO(b/269799771): make private\n   * @private only public for slider\n   */\n  handlePointerleave(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.hovered = false;\n\n    // release a held mouse or pen press that moves outside the element\n    if (this.state !== State.INACTIVE) {\n      this.endPressAnimation();\n    }\n  }\n\n  private handlePointerup(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n      return;\n    }\n\n    if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(this.rippleStartEvent);\n      return;\n    }\n  }\n\n  private async handlePointerdown(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.rippleStartEvent = event;\n    if (!this.isTouch(event)) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.startPressAnimation(event);\n      return;\n    }\n\n    // after a longpress contextmenu event, an extra `pointerdown` can be\n    // dispatched to the pressed element. Check that the down is within\n    // bounds of the element in this case.\n    if (this.checkBoundsAfterContextMenu && !this.inBounds(event)) {\n      return;\n    }\n\n    this.checkBoundsAfterContextMenu = false;\n\n    // Wait for a hold after touch delay\n    this.state = State.TOUCH_DELAY;\n    await new Promise((resolve) => {\n      setTimeout(resolve, TOUCH_DELAY_MS);\n    });\n\n    if (this.state !== State.TOUCH_DELAY) {\n      return;\n    }\n\n    this.state = State.HOLDING;\n    this.startPressAnimation(event);\n  }\n\n  private handleClick() {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (this.disabled) {\n      return;\n    }\n\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPressAnimation();\n      return;\n    }\n\n    if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.startPressAnimation();\n      this.endPressAnimation();\n    }\n  }\n\n  private handlePointercancel(event: PointerEvent) {\n    if (!this.shouldReactToEvent(event)) {\n      return;\n    }\n\n    this.endPressAnimation();\n  }\n\n  private handleContextmenu() {\n    if (this.disabled) {\n      return;\n    }\n\n    this.checkBoundsAfterContextMenu = true;\n    this.endPressAnimation();\n  }\n\n  private determineRippleSize() {\n    const {height, width} = this.getBoundingClientRect();\n    const maxDim = Math.max(height, width);\n    const softEdgeSize = Math.max(\n      SOFT_EDGE_CONTAINER_RATIO * maxDim,\n      SOFT_EDGE_MINIMUM_SIZE,\n    );\n\n    const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);\n    const hypotenuse = Math.sqrt(width ** 2 + height ** 2);\n    const maxRadius = hypotenuse + PADDING;\n\n    this.initialSize = initialSize;\n    this.rippleScale = `${(maxRadius + softEdgeSize) / initialSize}`;\n    this.rippleSize = `${initialSize}px`;\n  }\n\n  private getNormalizedPointerEventCoords(pointerEvent: PointerEvent): {\n    x: number;\n    y: number;\n  } {\n    const {scrollX, scrollY} = window;\n    const {left, top} = this.getBoundingClientRect();\n    const documentX = scrollX + left;\n    const documentY = scrollY + top;\n    const {pageX, pageY} = pointerEvent;\n    return {x: pageX - documentX, y: pageY - documentY};\n  }\n\n  private getTranslationCoordinates(positionEvent?: Event) {\n    const {height, width} = this.getBoundingClientRect();\n    // end in the center\n    const endPoint = {\n      x: (width - this.initialSize) / 2,\n      y: (height - this.initialSize) / 2,\n    };\n\n    let startPoint;\n    if (positionEvent instanceof PointerEvent) {\n      startPoint = this.getNormalizedPointerEventCoords(positionEvent);\n    } else {\n      startPoint = {\n        x: width / 2,\n        y: height / 2,\n      };\n    }\n\n    // center around start point\n    startPoint = {\n      x: startPoint.x - this.initialSize / 2,\n      y: startPoint.y - this.initialSize / 2,\n    };\n\n    return {startPoint, endPoint};\n  }\n\n  private startPressAnimation(positionEvent?: Event) {\n    if (!this.mdRoot) {\n      return;\n    }\n\n    this.pressed = true;\n    this.growAnimation?.cancel();\n    this.determineRippleSize();\n    const {startPoint, endPoint} =\n      this.getTranslationCoordinates(positionEvent);\n    const translateStart = `${startPoint.x}px, ${startPoint.y}px`;\n    const translateEnd = `${endPoint.x}px, ${endPoint.y}px`;\n\n    this.growAnimation = this.mdRoot.animate(\n      {\n        top: [0, 0],\n        left: [0, 0],\n        height: [this.rippleSize, this.rippleSize],\n        width: [this.rippleSize, this.rippleSize],\n        transform: [\n          `translate(${translateStart}) scale(1)`,\n          `translate(${translateEnd}) scale(${this.rippleScale})`,\n        ],\n      },\n      {\n        pseudoElement: PRESS_PSEUDO,\n        duration: PRESS_GROW_MS,\n        easing: EASING.STANDARD,\n        fill: ANIMATION_FILL,\n      },\n    );\n  }\n\n  private async endPressAnimation() {\n    this.rippleStartEvent = undefined;\n    this.state = State.INACTIVE;\n    const animation = this.growAnimation;\n    let pressAnimationPlayState = Infinity;\n    if (typeof animation?.currentTime === 'number') {\n      pressAnimationPlayState = animation.currentTime;\n    } else if (animation?.currentTime) {\n      pressAnimationPlayState = animation.currentTime.to('ms').value;\n    }\n\n    if (pressAnimationPlayState >= MINIMUM_PRESS_MS) {\n      this.pressed = false;\n      return;\n    }\n\n    await new Promise((resolve) => {\n      setTimeout(resolve, MINIMUM_PRESS_MS - pressAnimationPlayState);\n    });\n\n    if (this.growAnimation !== animation) {\n      // A new press animation was started. The old animation was canceled and\n      // should not finish the pressed state.\n      return;\n    }\n\n    this.pressed = false;\n  }\n\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  private shouldReactToEvent(event: PointerEvent) {\n    if (this.disabled || !event.isPrimary) {\n      return false;\n    }\n\n    if (\n      this.rippleStartEvent &&\n      this.rippleStartEvent.pointerId !== event.pointerId\n    ) {\n      return false;\n    }\n\n    if (event.type === 'pointerenter' || event.type === 'pointerleave') {\n      return !this.isTouch(event);\n    }\n\n    const isPrimaryButton = event.buttons === 1;\n    return this.isTouch(event) || isPrimaryButton;\n  }\n\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  private inBounds({x, y}: PointerEvent) {\n    const {top, left, bottom, right} = this.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n\n  private isTouch({pointerType}: PointerEvent) {\n    return pointerType === 'touch';\n  }\n\n  /** @private */\n  async handleEvent(event: Event) {\n    if (FORCED_COLORS?.matches) {\n      // Skip event logic since the ripple is `display: none`.\n      return;\n    }\n\n    switch (event.type) {\n      case 'click':\n        this.handleClick();\n        break;\n      case 'contextmenu':\n        this.handleContextmenu();\n        break;\n      case 'pointercancel':\n        this.handlePointercancel(event as PointerEvent);\n        break;\n      case 'pointerdown':\n        await this.handlePointerdown(event as PointerEvent);\n        break;\n      case 'pointerenter':\n        this.handlePointerenter(event as PointerEvent);\n        break;\n      case 'pointerleave':\n        this.handlePointerleave(event as PointerEvent);\n        break;\n      case 'pointerup':\n        this.handlePointerup(event as PointerEvent);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private onControlChange(prev: HTMLElement | null, next: HTMLElement | null) {\n    if (isServer) return;\n\n    for (const event of EVENTS) {\n      prev?.removeEventListener(event, this);\n      next?.addEventListener(event, this);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}