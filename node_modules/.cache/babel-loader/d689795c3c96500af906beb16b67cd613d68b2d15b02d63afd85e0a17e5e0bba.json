{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport { supportsFeature } from \"../common/entity/supports-feature\";\nimport { CAMERA_SUPPORT_STREAM, computeMJPEGStreamUrl, fetchStreamUrl, fetchThumbnailUrlWithCache, STREAM_TYPE_HLS, STREAM_TYPE_WEB_RTC } from \"../data/camera\";\nimport \"./ha-hls-player\";\nimport \"./ha-web-rtc-player\";\nexport let HaCameraStream = _decorate([customElement(\"ha-camera-stream\")], function (_initialize, _LitElement) {\n  class HaCameraStream extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaCameraStream,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"stateObj\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"controls\"\n      })],\n      key: \"controls\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"muted\"\n      })],\n      key: \"muted\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"allow-exoplayer\"\n      })],\n      key: \"allowExoPlayer\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_posterUrl\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_forceMJPEG\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_url\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_connected\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value:\n      // Video background image before its loaded\n\n      // We keep track if we should force MJPEG if there was a failure\n      // to get the HLS stream url. This is reset if we change entities.\n\n      function willUpdate(changedProps) {\n        var _changedProps$get;\n        if (changedProps.has(\"stateObj\") && !this._shouldRenderMJPEG && this.stateObj && ((_changedProps$get = changedProps.get(\"stateObj\")) === null || _changedProps$get === void 0 ? void 0 : _changedProps$get.entity_id) !== this.stateObj.entity_id) {\n          this._getPosterUrl();\n          if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n            this._forceMJPEG = undefined;\n            this._url = undefined;\n            this._getStreamUrl();\n          }\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HaCameraStream.prototype), \"connectedCallback\", this).call(this);\n        this._connected = true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaCameraStream.prototype), \"disconnectedCallback\", this).call(this);\n        this._connected = false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!this.stateObj) {\n          return nothing;\n        }\n        if (__DEMO__ || this._shouldRenderMJPEG) {\n          return html`<img\n        .src=${__DEMO__ ? this.stateObj.attributes.entity_picture : this._connected ? computeMJPEGStreamUrl(this.stateObj) : \"\"}\n        .alt=${`Preview of the ${computeStateName(this.stateObj)} camera.`}\n      />`;\n        }\n        if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n          return this._url ? html`<ha-hls-player\n            autoplay\n            playsinline\n            .allowExoPlayer=${this.allowExoPlayer}\n            .muted=${this.muted}\n            .controls=${this.controls}\n            .hass=${this.hass}\n            .url=${this._url}\n            .posterUrl=${this._posterUrl}\n          ></ha-hls-player>` : nothing;\n        }\n        if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC) {\n          return html`<ha-web-rtc-player\n        autoplay\n        playsinline\n        .muted=${this.muted}\n        .controls=${this.controls}\n        .hass=${this.hass}\n        .entityid=${this.stateObj.entity_id}\n        .posterUrl=${this._posterUrl}\n      ></ha-web-rtc-player>`;\n        }\n        return nothing;\n      }\n    }, {\n      kind: \"get\",\n      key: \"_shouldRenderMJPEG\",\n      value: function _shouldRenderMJPEG() {\n        if (this._forceMJPEG === this.stateObj.entity_id) {\n          // Fallback when unable to fetch stream url\n          return true;\n        }\n        if (!supportsFeature(this.stateObj, CAMERA_SUPPORT_STREAM)) {\n          // Steaming is not supported by the camera so fallback to MJPEG stream\n          return true;\n        }\n        if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC) {\n          // Browser support required for WebRTC\n          return typeof RTCPeerConnection === \"undefined\";\n        }\n        // Server side stream component required for HLS\n        return !isComponentLoaded(this.hass, \"stream\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getPosterUrl\",\n      value: async function _getPosterUrl() {\n        try {\n          this._posterUrl = await fetchThumbnailUrlWithCache(this.hass, this.stateObj.entity_id, this.clientWidth, this.clientHeight);\n        } catch (err) {\n          // poster url is optional\n          this._posterUrl = undefined;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getStreamUrl\",\n      value: async function _getStreamUrl() {\n        try {\n          const {\n            url\n          } = await fetchStreamUrl(this.hass, this.stateObj.entity_id);\n          this._url = url;\n        } catch (err) {\n          // Fails if we were unable to get a stream\n          // eslint-disable-next-line\n          console.error(err);\n          this._forceMJPEG = this.stateObj.entity_id;\n        }\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host,\n      img {\n        display: block;\n      }\n\n      img {\n        width: 100%;\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","nothing","customElement","property","state","isComponentLoaded","computeStateName","supportsFeature","CAMERA_SUPPORT_STREAM","computeMJPEGStreamUrl","fetchStreamUrl","fetchThumbnailUrlWithCache","STREAM_TYPE_HLS","STREAM_TYPE_WEB_RTC","HaCameraStream","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","willUpdate","changedProps","_changedProps$get","has","_shouldRenderMJPEG","stateObj","get","entity_id","_getPosterUrl","attributes","frontend_stream_type","_forceMJPEG","undefined","_url","_getStreamUrl","connectedCallback","_get","_getPrototypeOf","prototype","call","_connected","disconnectedCallback","render","__DEMO__","entity_picture","allowExoPlayer","muted","controls","hass","_posterUrl","RTCPeerConnection","clientWidth","clientHeight","err","url","console","error","static","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/ha-camera-stream.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  nothing,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport { supportsFeature } from \"../common/entity/supports-feature\";\nimport {\n  CameraEntity,\n  CAMERA_SUPPORT_STREAM,\n  computeMJPEGStreamUrl,\n  fetchStreamUrl,\n  fetchThumbnailUrlWithCache,\n  STREAM_TYPE_HLS,\n  STREAM_TYPE_WEB_RTC,\n} from \"../data/camera\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-hls-player\";\nimport \"./ha-web-rtc-player\";\n\n@customElement(\"ha-camera-stream\")\nexport class HaCameraStream extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: CameraEntity;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // Video background image before its loaded\n  @state() private _posterUrl?: string;\n\n  // We keep track if we should force MJPEG if there was a failure\n  // to get the HLS stream url. This is reset if we change entities.\n  @state() private _forceMJPEG?: string;\n\n  @state() private _url?: string;\n\n  @state() private _connected = false;\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (\n      changedProps.has(\"stateObj\") &&\n      !this._shouldRenderMJPEG &&\n      this.stateObj &&\n      (changedProps.get(\"stateObj\") as CameraEntity | undefined)?.entity_id !==\n        this.stateObj.entity_id\n    ) {\n      this._getPosterUrl();\n      if (this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n        this._forceMJPEG = undefined;\n        this._url = undefined;\n        this._getStreamUrl();\n      }\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._connected = true;\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._connected = false;\n  }\n\n  protected render() {\n    if (!this.stateObj) {\n      return nothing;\n    }\n    if (__DEMO__ || this._shouldRenderMJPEG) {\n      return html`<img\n        .src=${__DEMO__\n          ? this.stateObj.attributes.entity_picture!\n          : this._connected\n            ? computeMJPEGStreamUrl(this.stateObj)\n            : \"\"}\n        .alt=${`Preview of the ${computeStateName(this.stateObj)} camera.`}\n      />`;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n      return this._url\n        ? html`<ha-hls-player\n            autoplay\n            playsinline\n            .allowExoPlayer=${this.allowExoPlayer}\n            .muted=${this.muted}\n            .controls=${this.controls}\n            .hass=${this.hass}\n            .url=${this._url}\n            .posterUrl=${this._posterUrl}\n          ></ha-hls-player>`\n        : nothing;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC) {\n      return html`<ha-web-rtc-player\n        autoplay\n        playsinline\n        .muted=${this.muted}\n        .controls=${this.controls}\n        .hass=${this.hass}\n        .entityid=${this.stateObj.entity_id}\n        .posterUrl=${this._posterUrl}\n      ></ha-web-rtc-player>`;\n    }\n    return nothing;\n  }\n\n  private get _shouldRenderMJPEG() {\n    if (this._forceMJPEG === this.stateObj!.entity_id) {\n      // Fallback when unable to fetch stream url\n      return true;\n    }\n    if (!supportsFeature(this.stateObj!, CAMERA_SUPPORT_STREAM)) {\n      // Steaming is not supported by the camera so fallback to MJPEG stream\n      return true;\n    }\n    if (\n      this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC\n    ) {\n      // Browser support required for WebRTC\n      return typeof RTCPeerConnection === \"undefined\";\n    }\n    // Server side stream component required for HLS\n    return !isComponentLoaded(this.hass!, \"stream\");\n  }\n\n  private async _getPosterUrl(): Promise<void> {\n    try {\n      this._posterUrl = await fetchThumbnailUrlWithCache(\n        this.hass!,\n        this.stateObj!.entity_id,\n        this.clientWidth,\n        this.clientHeight\n      );\n    } catch (err: any) {\n      // poster url is optional\n      this._posterUrl = undefined;\n    }\n  }\n\n  private async _getStreamUrl(): Promise<void> {\n    try {\n      const { url } = await fetchStreamUrl(\n        this.hass!,\n        this.stateObj!.entity_id\n      );\n\n      this._url = url;\n    } catch (err: any) {\n      // Fails if we were unable to get a stream\n      // eslint-disable-next-line\n      console.error(err);\n\n      this._forceMJPEG = this.stateObj!.entity_id;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      img {\n        display: block;\n      }\n\n      img {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-camera-stream\": HaCameraStream;\n  }\n}\n"],"mappings":";;;AAAA,SACEA,GAAG,EAEHC,IAAI,EACJC,UAAU,EAEVC,OAAO,QACF,KAAK;AACZ,SAASC,aAAa,EAAEC,QAAQ,EAAEC,KAAK,QAAQ,gBAAgB;AAC/D,SAASC,iBAAiB,QAAQ,sCAAsC;AACxE,SAASC,gBAAgB,QAAQ,qCAAqC;AACtE,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAEEC,qBAAqB,EACrBC,qBAAqB,EACrBC,cAAc,EACdC,0BAA0B,EAC1BC,eAAe,EACfC,mBAAmB,QACd,gBAAgB;AAEvB,OAAO,iBAAiB;AACxB,OAAO,qBAAqB;AAE5B,WACaC,cAAc,GAAAC,SAAA,EAD1Bb,aAAa,CAAC,kBAAkB,CAAC,aAAAc,WAAA,EAAAC,WAAA;EAAlC,MACaH,cAAc,SAAAG,WAAA,CAAoB;IAAAC,YAAA,GAAAC,IAAA;MAAA,SAAAA,IAAA;MAAAH,WAAA;IAAA;EA4J/C;EAAC;IAAAI,CAAA,EA5JYN,cAAc;IAAAO,CAAA;MAAAC,IAAA;MAAAC,UAAA,GACxBpB,QAAQ,CAAC;QAAEqB,SAAS,EAAE;MAAM,CAAC,CAAC;MAAAC,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAE9BpB,QAAQ,CAAC;QAAEqB,SAAS,EAAE;MAAM,CAAC,CAAC;MAAAC,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAE9BpB,QAAQ,CAAC;QAAEwB,IAAI,EAAEC,OAAO;QAAEJ,SAAS,EAAE;MAAW,CAAC,CAAC;MAAAC,GAAA;MAAAC,MAAA;QAAA,OACjC,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEtBpB,QAAQ,CAAC;QAAEwB,IAAI,EAAEC,OAAO;QAAEJ,SAAS,EAAE;MAAQ,CAAC,CAAC;MAAAC,GAAA;MAAAC,MAAA;QAAA,OACjC,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEnBpB,QAAQ,CAAC;QAAEwB,IAAI,EAAEC,OAAO;QAAEJ,SAAS,EAAE;MAAkB,CAAC,CAAC;MAAAC,GAAA;MAAAC,MAAA;QAAA,OAClC,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAG5BnB,KAAK,CAAC,CAAC;MAAAqB,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAIPnB,KAAK,CAAC,CAAC;MAAAqB,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEPnB,KAAK,CAAC,CAAC;MAAAqB,GAAA;MAAAC,KAAA;IAAA;MAAAJ,IAAA;MAAAC,UAAA,GAEPnB,KAAK,CAAC,CAAC;MAAAqB,GAAA;MAAAC,MAAA;QAAA,OAAsB,KAAK;MAAA;IAAA;MAAAJ,IAAA;MAAAG,GAAA;MAAAC,KAAA;MATnC;;MAGA;MACA;;MAOA,SAAAG,WAAkBC,YAA4B,EAAQ;QAAA,IAAAC,iBAAA;QACpD,IACED,YAAY,CAACE,GAAG,CAAC,UAAU,CAAC,IAC5B,CAAC,IAAI,CAACC,kBAAkB,IACxB,IAAI,CAACC,QAAQ,IACb,EAAAH,iBAAA,GAACD,YAAY,CAACK,GAAG,CAAC,UAAU,CAAC,cAAAJ,iBAAA,uBAA7BA,iBAAA,CAA4DK,SAAS,MACnE,IAAI,CAACF,QAAQ,CAACE,SAAS,EACzB;UACA,IAAI,CAACC,aAAa,CAAC,CAAC;UACpB,IAAI,IAAI,CAACH,QAAQ,CAAEI,UAAU,CAACC,oBAAoB,KAAK3B,eAAe,EAAE;YACtE,IAAI,CAAC4B,WAAW,GAAGC,SAAS;YAC5B,IAAI,CAACC,IAAI,GAAGD,SAAS;YACrB,IAAI,CAACE,aAAa,CAAC,CAAC;UACtB;QACF;MACF;IAAC;MAAArB,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAkB,kBAAA,EAA2B;QACzBC,IAAA,CAAAC,eAAA,CA3CShC,cAAc,CAAAiC,SAAA,8BAAAC,IAAA;QA4CvB,IAAI,CAACC,UAAU,GAAG,IAAI;MACxB;IAAC;MAAA3B,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAwB,qBAAA,EAA8B;QAC5BL,IAAA,CAAAC,eAAA,CAhDShC,cAAc,CAAAiC,SAAA,iCAAAC,IAAA;QAiDvB,IAAI,CAACC,UAAU,GAAG,KAAK;MACzB;IAAC;MAAA3B,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAyB,OAAA,EAAmB;QACjB,IAAI,CAAC,IAAI,CAACjB,QAAQ,EAAE;UAClB,OAAOjC,OAAO;QAChB;QACA,IAAImD,QAAQ,IAAI,IAAI,CAACnB,kBAAkB,EAAE;UACvC,OAAOlC,IAAK;AAClB,eAAeqD,QAAQ,GACX,IAAI,CAAClB,QAAQ,CAACI,UAAU,CAACe,cAAc,GACvC,IAAI,CAACJ,UAAU,GACbxC,qBAAqB,CAAC,IAAI,CAACyB,QAAQ,CAAC,GACpC,EAAG;AACjB,eAAgB,kBAAiB5B,gBAAgB,CAAC,IAAI,CAAC4B,QAAQ,CAAE,UAAU;AAC3E,SAAS;QACL;QACA,IAAI,IAAI,CAACA,QAAQ,CAACI,UAAU,CAACC,oBAAoB,KAAK3B,eAAe,EAAE;UACrE,OAAO,IAAI,CAAC8B,IAAI,GACZ3C,IAAK;AACf;AACA;AACA,8BAA8B,IAAI,CAACuD,cAAe;AAClD,qBAAqB,IAAI,CAACC,KAAM;AAChC,wBAAwB,IAAI,CAACC,QAAS;AACtC,oBAAoB,IAAI,CAACC,IAAK;AAC9B,mBAAmB,IAAI,CAACf,IAAK;AAC7B,yBAAyB,IAAI,CAACgB,UAAW;AACzC,4BAA4B,GAClBzD,OAAO;QACb;QACA,IAAI,IAAI,CAACiC,QAAQ,CAACI,UAAU,CAACC,oBAAoB,KAAK1B,mBAAmB,EAAE;UACzE,OAAOd,IAAK;AAClB;AACA;AACA,iBAAiB,IAAI,CAACwD,KAAM;AAC5B,oBAAoB,IAAI,CAACC,QAAS;AAClC,gBAAgB,IAAI,CAACC,IAAK;AAC1B,oBAAoB,IAAI,CAACvB,QAAQ,CAACE,SAAU;AAC5C,qBAAqB,IAAI,CAACsB,UAAW;AACrC,4BAA4B;QACxB;QACA,OAAOzD,OAAO;MAChB;IAAC;MAAAqB,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,SAAAO,mBAAA,EAAiC;QAC/B,IAAI,IAAI,CAACO,WAAW,KAAK,IAAI,CAACN,QAAQ,CAAEE,SAAS,EAAE;UACjD;UACA,OAAO,IAAI;QACb;QACA,IAAI,CAAC7B,eAAe,CAAC,IAAI,CAAC2B,QAAQ,EAAG1B,qBAAqB,CAAC,EAAE;UAC3D;UACA,OAAO,IAAI;QACb;QACA,IACE,IAAI,CAAC0B,QAAQ,CAAEI,UAAU,CAACC,oBAAoB,KAAK1B,mBAAmB,EACtE;UACA;UACA,OAAO,OAAO8C,iBAAiB,KAAK,WAAW;QACjD;QACA;QACA,OAAO,CAACtD,iBAAiB,CAAC,IAAI,CAACoD,IAAI,EAAG,QAAQ,CAAC;MACjD;IAAC;MAAAnC,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAW,cAAA,EAA6C;QAC3C,IAAI;UACF,IAAI,CAACqB,UAAU,GAAG,MAAM/C,0BAA0B,CAChD,IAAI,CAAC8C,IAAI,EACT,IAAI,CAACvB,QAAQ,CAAEE,SAAS,EACxB,IAAI,CAACwB,WAAW,EAChB,IAAI,CAACC,YACP,CAAC;QACH,CAAC,CAAC,OAAOC,GAAQ,EAAE;UACjB;UACA,IAAI,CAACJ,UAAU,GAAGjB,SAAS;QAC7B;MACF;IAAC;MAAAnB,IAAA;MAAAG,GAAA;MAAAC,KAAA,EAED,eAAAiB,cAAA,EAA6C;QAC3C,IAAI;UACF,MAAM;YAAEoB;UAAI,CAAC,GAAG,MAAMrD,cAAc,CAClC,IAAI,CAAC+C,IAAI,EACT,IAAI,CAACvB,QAAQ,CAAEE,SACjB,CAAC;UAED,IAAI,CAACM,IAAI,GAAGqB,GAAG;QACjB,CAAC,CAAC,OAAOD,GAAQ,EAAE;UACjB;UACA;UACAE,OAAO,CAACC,KAAK,CAACH,GAAG,CAAC;UAElB,IAAI,CAACtB,WAAW,GAAG,IAAI,CAACN,QAAQ,CAAEE,SAAS;QAC7C;MACF;IAAC;MAAAd,IAAA;MAAA4C,MAAA;MAAAzC,GAAA;MAAAC,KAAA,EAED,SAAAyC,OAAA,EAAoC;QAClC,OAAOrE,GAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;MACH;IAAC;EAAA;AAAA,GA3JiCE,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}