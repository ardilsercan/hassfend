{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\n/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { ElementMixin } from './element-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { wrap } from '../utils/wrap.js';\nvar DISABLED_ATTR = 'disable-upgrade';\nexport var findObservedAttributesGetter = function findObservedAttributesGetter(ctor) {\n  while (ctor) {\n    var desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');\n    if (desc) {\n      return desc.get;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return function () {\n    return [];\n  };\n};\n\n/**\n * Element class mixin that allows the element to boot up in a non-enabled\n * state when the `disable-upgrade` attribute is present. This mixin is\n * designed to be used with element classes like PolymerElement that perform\n * initial startup work when they are first connected. When the\n * `disable-upgrade` attribute is removed, if the element is connected, it\n * boots up and \"enables\" as it otherwise would; if it is not connected, the\n * element boots up when it is next connected.\n *\n * Using `disable-upgrade` with PolymerElement prevents any data propagation\n * to the element, any element DOM from stamping, or any work done in\n * connected/disconnctedCallback from occuring, but it does not prevent work\n * done in the element constructor.\n *\n * Note, this mixin must be applied on top of any element class that\n * itself implements a `connectedCallback` so that it can control the work\n * done in `connectedCallback`. For example,\n *\n *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport var DisableUpgradeMixin = dedupingMixin(function (base) {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  var superClass = ElementMixin(base);\n\n  // Work around for closure bug #126934458. Using `super` in a property\n  // getter does not work so instead we search the Base prototype for an\n  // implementation of observedAttributes so that we can override and call\n  // the `super` getter. Note, this is done one time ever because we assume\n  // that `Base` is always comes from `Polymer.LegacyElementMixn`.\n  var observedAttributesGetter = findObservedAttributesGetter(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_DisableUpgradeMixin}\n   */\n  var DisableUpgradeClass = /*#__PURE__*/function (_superClass) {\n    _inherits(DisableUpgradeClass, _superClass);\n    function DisableUpgradeClass() {\n      var _this;\n      _classCallCheck(this, DisableUpgradeClass);\n      _this = _callSuper(this, DisableUpgradeClass);\n      /** @type {boolean|undefined} */\n      _this.__isUpgradeDisabled;\n      return _this;\n    }\n    _createClass(DisableUpgradeClass, [{\n      key: \"_initializeProperties\",\n      value:\n      // Prevent element from initializing properties when it's upgrade disabled.\n      /** @override */\n      function _initializeProperties() {\n        if (this.hasAttribute(DISABLED_ATTR)) {\n          this.__isUpgradeDisabled = true;\n        } else {\n          _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"_initializeProperties\", this).call(this);\n        }\n      }\n\n      // Prevent element from enabling properties when it's upgrade disabled.\n      // Normally overriding connectedCallback would be enough, but dom-* elements\n      /** @override */\n    }, {\n      key: \"_enableProperties\",\n      value: function _enableProperties() {\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"_enableProperties\", this).call(this);\n        }\n      }\n\n      // If the element starts upgrade-disabled and a property is set for\n      // which an accessor exists, the default should not be applied.\n      // This additional check is needed because defaults are applied via\n      // `_initializeProperties` which is called after initial properties\n      // have been set when the element starts upgrade-disabled.\n      /** @override */\n    }, {\n      key: \"_canApplyPropertyDefault\",\n      value: function _canApplyPropertyDefault(property) {\n        return _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"_canApplyPropertyDefault\", this).call(this, property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n      }\n\n      /**\n       * @override\n       * @param {string} name Attribute name.\n       * @param {?string} old The previous value for the attribute.\n       * @param {?string} value The new value for the attribute.\n       * @param {?string} namespace The XML namespace for the attribute.\n       * @return {void}\n       */\n    }, {\n      key: \"attributeChangedCallback\",\n      value: function attributeChangedCallback(name, old, value, namespace) {\n        if (name == DISABLED_ATTR) {\n          // When disable-upgrade is removed, initialize properties and\n          // provoke connectedCallback if the element is already connected.\n          if (this.__isUpgradeDisabled && value == null) {\n            _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"_initializeProperties\", this).call(this);\n            this.__isUpgradeDisabled = false;\n            if (wrap(this).isConnected) {\n              _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"connectedCallback\", this).call(this);\n            }\n          }\n        } else {\n          _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"attributeChangedCallback\", this).call(this, name, old, value, /** @type {null|string} */namespace);\n        }\n      }\n\n      // Prevent element from connecting when it's upgrade disabled.\n      // This prevents user code in `attached` from being called.\n      /** @override */\n    }, {\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"connectedCallback\", this).call(this);\n        }\n      }\n\n      // Prevent element from disconnecting when it's upgrade disabled.\n      // This avoids allowing user code `detached` from being called without a\n      // paired call to `attached`.\n      /** @override */\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        if (!this.__isUpgradeDisabled) {\n          _get(_getPrototypeOf(DisableUpgradeClass.prototype), \"disconnectedCallback\", this).call(this);\n        }\n      }\n    }], [{\n      key: \"observedAttributes\",\n      get: function get() {\n        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n      }\n    }]);\n    return DisableUpgradeClass;\n  }(superClass);\n  return DisableUpgradeClass;\n});","map":{"version":3,"names":["ElementMixin","dedupingMixin","wrap","DISABLED_ATTR","findObservedAttributesGetter","ctor","desc","Object","getOwnPropertyDescriptor","get","getPrototypeOf","prototype","constructor","DisableUpgradeMixin","base","superClass","observedAttributesGetter","DisableUpgradeClass","_superClass","_inherits","_this","_classCallCheck","_callSuper","__isUpgradeDisabled","_createClass","key","value","_initializeProperties","hasAttribute","_get","_getPrototypeOf","call","_enableProperties","_canApplyPropertyDefault","property","_isPropertyPending","attributeChangedCallback","name","old","namespace","isConnected","connectedCallback","disconnectedCallback","concat"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/mixins/disable-upgrade-mixin.js"],"sourcesContent":["/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { ElementMixin } from './element-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport { wrap } from '../utils/wrap.js';\n\nconst DISABLED_ATTR = 'disable-upgrade';\n\nexport const findObservedAttributesGetter = (ctor) => {\n  while (ctor) {\n    const desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');\n    if (desc) {\n      return desc.get;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return () => [];\n};\n\n/**\n * Element class mixin that allows the element to boot up in a non-enabled\n * state when the `disable-upgrade` attribute is present. This mixin is\n * designed to be used with element classes like PolymerElement that perform\n * initial startup work when they are first connected. When the\n * `disable-upgrade` attribute is removed, if the element is connected, it\n * boots up and \"enables\" as it otherwise would; if it is not connected, the\n * element boots up when it is next connected.\n *\n * Using `disable-upgrade` with PolymerElement prevents any data propagation\n * to the element, any element DOM from stamping, or any work done in\n * connected/disconnctedCallback from occuring, but it does not prevent work\n * done in the element constructor.\n *\n * Note, this mixin must be applied on top of any element class that\n * itself implements a `connectedCallback` so that it can control the work\n * done in `connectedCallback`. For example,\n *\n *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\nexport const DisableUpgradeMixin = dedupingMixin((base) => {\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const superClass = ElementMixin(base);\n\n  // Work around for closure bug #126934458. Using `super` in a property\n  // getter does not work so instead we search the Base prototype for an\n  // implementation of observedAttributes so that we can override and call\n  // the `super` getter. Note, this is done one time ever because we assume\n  // that `Base` is always comes from `Polymer.LegacyElementMixn`.\n  let observedAttributesGetter = findObservedAttributesGetter(superClass);\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_DisableUpgradeMixin}\n   */\n  class DisableUpgradeClass extends superClass {\n\n    constructor() {\n      super();\n      /** @type {boolean|undefined} */\n      this.__isUpgradeDisabled;\n    }\n\n    static get observedAttributes() {\n      return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n    }\n\n    // Prevent element from initializing properties when it's upgrade disabled.\n    /** @override */\n    _initializeProperties() {\n      if (this.hasAttribute(DISABLED_ATTR)) {\n        this.__isUpgradeDisabled = true;\n      } else {\n        super._initializeProperties();\n      }\n    }\n\n    // Prevent element from enabling properties when it's upgrade disabled.\n    // Normally overriding connectedCallback would be enough, but dom-* elements\n    /** @override */\n    _enableProperties() {\n      if (!this.__isUpgradeDisabled) {\n        super._enableProperties();\n      }\n    }\n\n    // If the element starts upgrade-disabled and a property is set for\n    // which an accessor exists, the default should not be applied.\n    // This additional check is needed because defaults are applied via\n    // `_initializeProperties` which is called after initial properties\n    // have been set when the element starts upgrade-disabled.\n    /** @override */\n    _canApplyPropertyDefault(property) {\n      return super._canApplyPropertyDefault(property) &&\n        !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n    }\n\n    /**\n     * @override\n     * @param {string} name Attribute name.\n     * @param {?string} old The previous value for the attribute.\n     * @param {?string} value The new value for the attribute.\n     * @param {?string} namespace The XML namespace for the attribute.\n     * @return {void}\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (name == DISABLED_ATTR) {\n        // When disable-upgrade is removed, initialize properties and\n        // provoke connectedCallback if the element is already connected.\n        if (this.__isUpgradeDisabled && value == null) {\n          super._initializeProperties();\n          this.__isUpgradeDisabled = false;\n          if (wrap(this).isConnected) {\n            super.connectedCallback();\n          }\n        }\n      } else {\n        super.attributeChangedCallback(\n            name, old, value, /** @type {null|string} */ (namespace));\n      }\n    }\n\n    // Prevent element from connecting when it's upgrade disabled.\n    // This prevents user code in `attached` from being called.\n    /** @override */\n    connectedCallback() {\n      if (!this.__isUpgradeDisabled) {\n        super.connectedCallback();\n      }\n    }\n\n    // Prevent element from disconnecting when it's upgrade disabled.\n    // This avoids allowing user code `detached` from being called without a\n    // paired call to `attached`.\n    /** @override */\n    disconnectedCallback() {\n      if (!this.__isUpgradeDisabled) {\n        super.disconnectedCallback();\n      }\n    }\n\n  }\n\n  return DisableUpgradeClass;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}