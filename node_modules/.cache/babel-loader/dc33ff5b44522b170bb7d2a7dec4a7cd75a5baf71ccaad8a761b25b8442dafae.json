{"ast":null,"code":"import { clamp } from \"../number/clamp\";\nexport const DEFAULT_MIN_KELVIN = 2700;\nexport const DEFAULT_MAX_KELVIN = 6500;\nexport const temperature2rgb = temperature => {\n  const value = temperature / 100;\n  return [temperatureRed(value), temperatureGreen(value), temperatureBlue(value)];\n};\nconst temperatureRed = temperature => {\n  if (temperature <= 66) {\n    return 255;\n  }\n  const red = 329.698727446 * (temperature - 60) ** -0.1332047592;\n  return clamp(red, 0, 255);\n};\nconst temperatureGreen = temperature => {\n  let green;\n  if (temperature <= 66) {\n    green = 99.4708025861 * Math.log(temperature) - 161.1195681661;\n  } else {\n    green = 288.1221695283 * (temperature - 60) ** -0.0755148492;\n  }\n  return clamp(green, 0, 255);\n};\nconst temperatureBlue = temperature => {\n  if (temperature >= 66) {\n    return 255;\n  }\n  if (temperature <= 19) {\n    return 0;\n  }\n  const blue = 138.5177312231 * Math.log(temperature - 10) - 305.0447927307;\n  return clamp(blue, 0, 255);\n};\nconst matchMaxScale = (inputColors, outputColors) => {\n  const maxIn = Math.max(...inputColors);\n  const maxOut = Math.max(...outputColors);\n  let factor;\n  if (maxOut === 0) {\n    factor = 0.0;\n  } else {\n    factor = maxIn / maxOut;\n  }\n  return outputColors.map(value => Math.round(value * factor));\n};\nexport const mired2kelvin = miredTemperature => Math.floor(1000000 / miredTemperature);\nexport const kelvin2mired = kelvintTemperature => Math.floor(1000000 / kelvintTemperature);\nexport const rgbww2rgb = (rgbww, minKelvin, maxKelvin) => {\n  const [r, g, b, cw, ww] = rgbww;\n  // Calculate color temperature of the white channels\n  const maxMireds = kelvin2mired(minKelvin !== null && minKelvin !== void 0 ? minKelvin : DEFAULT_MIN_KELVIN);\n  const minMireds = kelvin2mired(maxKelvin !== null && maxKelvin !== void 0 ? maxKelvin : DEFAULT_MAX_KELVIN);\n  const miredRange = maxMireds - minMireds;\n  let ctRatio;\n  try {\n    ctRatio = ww / (cw + ww);\n  } catch (_error) {\n    ctRatio = 0.5;\n  }\n  const colorTempMired = minMireds + ctRatio * miredRange;\n  const colorTempKelvin = colorTempMired ? mired2kelvin(colorTempMired) : 0;\n  const [wR, wG, wB] = temperature2rgb(colorTempKelvin);\n  const whiteLevel = Math.max(cw, ww) / 255;\n\n  // Add the white channels to the rgb channels.\n  const rgb = [r + wR * whiteLevel, g + wG * whiteLevel, b + wB * whiteLevel];\n\n  // Match the output maximum value to the input. This ensures the\n  // output doesn't overflow.\n  return matchMaxScale([r, g, b, cw, ww], rgb);\n};\nexport const rgbw2rgb = rgbw => {\n  const [r, g, b, w] = rgbw;\n  const rgb = [r + w, g + w, b + w];\n  return matchMaxScale([r, g, b, w], rgb);\n};","map":{"version":3,"names":["clamp","DEFAULT_MIN_KELVIN","DEFAULT_MAX_KELVIN","temperature2rgb","temperature","value","temperatureRed","temperatureGreen","temperatureBlue","red","green","Math","log","blue","matchMaxScale","inputColors","outputColors","maxIn","max","maxOut","factor","map","round","mired2kelvin","miredTemperature","floor","kelvin2mired","kelvintTemperature","rgbww2rgb","rgbww","minKelvin","maxKelvin","r","g","b","cw","ww","maxMireds","minMireds","miredRange","ctRatio","_error","colorTempMired","colorTempKelvin","wR","wG","wB","whiteLevel","rgb","rgbw2rgb","rgbw","w"],"sources":["/workspaces/frontend/src/common/color/convert-light-color.ts"],"sourcesContent":["import { clamp } from \"../number/clamp\";\n\nexport const DEFAULT_MIN_KELVIN = 2700;\nexport const DEFAULT_MAX_KELVIN = 6500;\n\nexport const temperature2rgb = (\n  temperature: number\n): [number, number, number] => {\n  const value = temperature / 100;\n  return [\n    temperatureRed(value),\n    temperatureGreen(value),\n    temperatureBlue(value),\n  ];\n};\n\nconst temperatureRed = (temperature: number): number => {\n  if (temperature <= 66) {\n    return 255;\n  }\n  const red = 329.698727446 * (temperature - 60) ** -0.1332047592;\n  return clamp(red, 0, 255);\n};\n\nconst temperatureGreen = (temperature: number): number => {\n  let green: number;\n  if (temperature <= 66) {\n    green = 99.4708025861 * Math.log(temperature) - 161.1195681661;\n  } else {\n    green = 288.1221695283 * (temperature - 60) ** -0.0755148492;\n  }\n  return clamp(green, 0, 255);\n};\n\nconst temperatureBlue = (temperature: number): number => {\n  if (temperature >= 66) {\n    return 255;\n  }\n  if (temperature <= 19) {\n    return 0;\n  }\n  const blue = 138.5177312231 * Math.log(temperature - 10) - 305.0447927307;\n  return clamp(blue, 0, 255);\n};\n\nconst matchMaxScale = (\n  inputColors: number[],\n  outputColors: number[]\n): number[] => {\n  const maxIn: number = Math.max(...inputColors);\n  const maxOut: number = Math.max(...outputColors);\n  let factor: number;\n  if (maxOut === 0) {\n    factor = 0.0;\n  } else {\n    factor = maxIn / maxOut;\n  }\n  return outputColors.map((value) => Math.round(value * factor));\n};\n\nexport const mired2kelvin = (miredTemperature: number) =>\n  Math.floor(1000000 / miredTemperature);\n\nexport const kelvin2mired = (kelvintTemperature: number) =>\n  Math.floor(1000000 / kelvintTemperature);\n\nexport const rgbww2rgb = (\n  rgbww: [number, number, number, number, number],\n  minKelvin?: number,\n  maxKelvin?: number\n): [number, number, number] => {\n  const [r, g, b, cw, ww] = rgbww;\n  // Calculate color temperature of the white channels\n  const maxMireds: number = kelvin2mired(minKelvin ?? DEFAULT_MIN_KELVIN);\n  const minMireds: number = kelvin2mired(maxKelvin ?? DEFAULT_MAX_KELVIN);\n  const miredRange: number = maxMireds - minMireds;\n  let ctRatio: number;\n  try {\n    ctRatio = ww / (cw + ww);\n  } catch (_error) {\n    ctRatio = 0.5;\n  }\n  const colorTempMired = minMireds + ctRatio * miredRange;\n  const colorTempKelvin = colorTempMired ? mired2kelvin(colorTempMired) : 0;\n  const [wR, wG, wB] = temperature2rgb(colorTempKelvin);\n  const whiteLevel = Math.max(cw, ww) / 255;\n\n  // Add the white channels to the rgb channels.\n  const rgb = [\n    r + wR * whiteLevel,\n    g + wG * whiteLevel,\n    b + wB * whiteLevel,\n  ] as [number, number, number];\n\n  // Match the output maximum value to the input. This ensures the\n  // output doesn't overflow.\n  return matchMaxScale([r, g, b, cw, ww], rgb) as [number, number, number];\n};\n\nexport const rgbw2rgb = (\n  rgbw: [number, number, number, number]\n): [number, number, number] => {\n  const [r, g, b, w] = rgbw;\n  const rgb = [r + w, g + w, b + w] as [number, number, number];\n  return matchMaxScale([r, g, b, w], rgb) as [number, number, number];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}