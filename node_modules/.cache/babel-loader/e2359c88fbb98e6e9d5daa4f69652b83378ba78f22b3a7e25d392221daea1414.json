{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.function.name.js\";\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange, nothing } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nimport { isSingleExpression, setCommittedValue } from '../directive-helpers.js';\nvar LiveDirective = /*#__PURE__*/function (_Directive) {\n  _inherits(LiveDirective, _Directive);\n  function LiveDirective(partInfo) {\n    var _this;\n    _classCallCheck(this, LiveDirective);\n    _this = _callSuper(this, LiveDirective, [partInfo]);\n    if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {\n      throw new Error('The `live` directive is not allowed on child or event bindings');\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n    return _this;\n  }\n  _createClass(LiveDirective, [{\n    key: \"render\",\n    value: function render(value) {\n      return value;\n    }\n  }, {\n    key: \"update\",\n    value: function update(part, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n        value = _ref2[0];\n      if (value === noChange || value === nothing) {\n        return value;\n      }\n      var element = part.element;\n      var name = part.name;\n      if (part.type === PartType.PROPERTY) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (value === element[name]) {\n          return noChange;\n        }\n      } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n        if (!!value === element.hasAttribute(name)) {\n          return noChange;\n        }\n      } else if (part.type === PartType.ATTRIBUTE) {\n        if (element.getAttribute(name) === String(value)) {\n          return noChange;\n        }\n      }\n      // Resets the part's value, causing its dirty-check to fail so that it\n      // always sets the value.\n      setCommittedValue(part);\n      return value;\n    }\n  }]);\n  return LiveDirective;\n}(Directive);\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport var live = directive(LiveDirective);","map":{"version":3,"names":["noChange","nothing","directive","Directive","PartType","isSingleExpression","setCommittedValue","LiveDirective","_Directive","_inherits","partInfo","_this","_classCallCheck","_callSuper","type","PROPERTY","ATTRIBUTE","BOOLEAN_ATTRIBUTE","Error","_createClass","key","value","render","update","part","_ref","_ref2","_slicedToArray","element","name","hasAttribute","getAttribute","String","live"],"sources":["../../src/directives/live.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange, nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {isSingleExpression, setCommittedValue} from '../directive-helpers.js';\n\nclass LiveDirective extends Directive {\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      !(\n        partInfo.type === PartType.PROPERTY ||\n        partInfo.type === PartType.ATTRIBUTE ||\n        partInfo.type === PartType.BOOLEAN_ATTRIBUTE\n      )\n    ) {\n      throw new Error(\n        'The `live` directive is not allowed on child or event bindings'\n      );\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n\n  render(value: unknown) {\n    return value;\n  }\n\n  override update(part: AttributePart, [value]: DirectiveParameters<this>) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === (element as any)[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {LiveDirective};\n"],"mappings":";;;;;;;AAAA;;;;;AAMA,SAAuBA,QAAQ,EAAEC,OAAO,QAAO,gBAAgB;AAC/D,SACEC,SAAS,EACTC,SAAS,EAGTC,QAAQ,QACH,iBAAiB;AACxB,SAAQC,kBAAkB,EAAEC,iBAAiB,QAAO,yBAAyB;AAAC,IAExEC,aAAc,0BAAAC,UAAA;EAAAC,SAAA,CAAAF,aAAA,EAAAC,UAAA;EAClB,SAAAD,cAAYG,QAAkB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAL,aAAA;IAC5BI,KAAA,GAAAE,UAAA,OAAAN,aAAA,GAAMG,QAAQ;IACd,IACE,EACEA,QAAQ,CAACI,IAAI,KAAKV,QAAQ,CAACW,QAAQ,IACnCL,QAAQ,CAACI,IAAI,KAAKV,QAAQ,CAACY,SAAS,IACpCN,QAAQ,CAACI,IAAI,KAAKV,QAAQ,CAACa,iBAAiB,CAC7C,EACD;MACA,MAAM,IAAIC,KAAK,CACb,gEAAgE,CACjE;;IAEH,IAAI,CAACb,kBAAkB,CAACK,QAAQ,CAAC,EAAE;MACjC,MAAM,IAAIQ,KAAK,CAAC,sDAAsD,CAAC;;IACxE,OAAAP,KAAA;EACH;EAACQ,YAAA,CAAAZ,aAAA;IAAAa,GAAA;IAAAC,KAAA,EAED,SAAAC,OAAOD,KAAc;MACnB,OAAOA,KAAK;IACd;EAAC;IAAAD,GAAA;IAAAC,KAAA,EAEQ,SAAAE,OAAOC,IAAmB,EAAAC,IAAA,EAAoC;MAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAF,IAAA;QAAjCJ,KAAK,GAAAK,KAAA;MACzC,IAAIL,KAAK,KAAKrB,QAAQ,IAAIqB,KAAK,KAAKpB,OAAO,EAAE;QAC3C,OAAOoB,KAAK;;MAEd,IAAMO,OAAO,GAAGJ,IAAI,CAACI,OAAO;MAC5B,IAAMC,IAAI,GAAGL,IAAI,CAACK,IAAI;MAEtB,IAAIL,IAAI,CAACV,IAAI,KAAKV,QAAQ,CAACW,QAAQ,EAAE;QACnC;QACA,IAAIM,KAAK,KAAMO,OAAe,CAACC,IAAI,CAAC,EAAE;UACpC,OAAO7B,QAAQ;;OAElB,MAAM,IAAIwB,IAAI,CAACV,IAAI,KAAKV,QAAQ,CAACa,iBAAiB,EAAE;QACnD,IAAI,CAAC,CAACI,KAAK,KAAKO,OAAO,CAACE,YAAY,CAACD,IAAI,CAAC,EAAE;UAC1C,OAAO7B,QAAQ;;OAElB,MAAM,IAAIwB,IAAI,CAACV,IAAI,KAAKV,QAAQ,CAACY,SAAS,EAAE;QAC3C,IAAIY,OAAO,CAACG,YAAY,CAACF,IAAI,CAAC,KAAKG,MAAM,CAACX,KAAK,CAAC,EAAE;UAChD,OAAOrB,QAAQ;;;MAGnB;MACA;MACAM,iBAAiB,CAACkB,IAAI,CAAC;MACvB,OAAOH,KAAK;IACd;EAAC;EAAA,OAAAd,aAAA;AAAA,EAhDyBJ,SAAS;AAmDrC;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAO,IAAM8B,IAAI,GAAG/B,SAAS,CAACK,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}