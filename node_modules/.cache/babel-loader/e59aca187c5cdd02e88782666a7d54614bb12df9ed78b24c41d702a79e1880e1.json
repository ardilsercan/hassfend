{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { isToday } from \"date-fns\";\nimport { css, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { setupLeafletMap } from \"../../common/dom/setup-leaflet-map\";\nimport { formatTimeWithSeconds, formatTimeWeekday } from \"../../common/datetime/format_time\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { loadPolyfillIfNeeded } from \"../../resources/resize-observer.polyfill\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\nimport { isTouch } from \"../../util/is_touch\";\nconst getEntityId = entity => typeof entity === \"string\" ? entity : entity.entity_id;\nexport let HaMap = _decorate([customElement(\"ha-map\")], function (_initialize, _ReactiveElement) {\n  class HaMap extends _ReactiveElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaMap,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"entities\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"paths\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"layers\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"autoFit\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"renderPassive\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"interactiveZones\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"fitZones\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"darkMode\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"zoom\",\n      value() {\n        return 14;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_loaded\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"leafletMap\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"Leaflet\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_resizeObserver\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_mapItems\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapFocusItems\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapZones\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_mapPaths\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HaMap.prototype), \"connectedCallback\", this).call(this);\n        this._loadMap();\n        this._attachObserver();\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaMap.prototype), \"disconnectedCallback\", this).call(this);\n        if (this.leafletMap) {\n          this.leafletMap.remove();\n          this.leafletMap = undefined;\n          this.Leaflet = undefined;\n        }\n        this._loaded = false;\n        if (this._resizeObserver) {\n          this._resizeObserver.unobserve(this);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"update\",\n      value: function update(changedProps) {\n        var _oldHass$themes, _this$hass$themes;\n        _get(_getPrototypeOf(HaMap.prototype), \"update\", this).call(this, changedProps);\n        if (!this._loaded) {\n          return;\n        }\n        let autoFitRequired = false;\n        const oldHass = changedProps.get(\"hass\");\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n          this._drawEntities();\n          autoFitRequired = true;\n        } else if (this._loaded && oldHass && this.entities) {\n          // Check if any state has changed\n          for (const entity of this.entities) {\n            if (oldHass.states[getEntityId(entity)] !== this.hass.states[getEntityId(entity)]) {\n              this._drawEntities();\n              autoFitRequired = true;\n              break;\n            }\n          }\n        }\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n          this._drawPaths();\n        }\n        if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n          this._drawLayers(changedProps.get(\"layers\"));\n          autoFitRequired = true;\n        }\n        if (changedProps.has(\"_loaded\") || this.autoFit && autoFitRequired) {\n          this.fitMap();\n        }\n        if (changedProps.has(\"zoom\")) {\n          this.leafletMap.setZoom(this.zoom);\n        }\n        if (!changedProps.has(\"darkMode\") && (!changedProps.has(\"hass\") || oldHass && ((_oldHass$themes = oldHass.themes) === null || _oldHass$themes === void 0 ? void 0 : _oldHass$themes.darkMode) === ((_this$hass$themes = this.hass.themes) === null || _this$hass$themes === void 0 ? void 0 : _this$hass$themes.darkMode))) {\n          return;\n        }\n        this._updateMapStyle();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_updateMapStyle\",\n      value: function _updateMapStyle() {\n        var _this$hass$themes$dar;\n        const darkMode = this.darkMode || ((_this$hass$themes$dar = this.hass.themes.darkMode) !== null && _this$hass$themes$dar !== void 0 ? _this$hass$themes$dar : false);\n        const forcedDark = this.darkMode;\n        const map = this.renderRoot.querySelector(\"#map\");\n        map.classList.toggle(\"dark\", darkMode);\n        map.classList.toggle(\"forced-dark\", forcedDark);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_loadMap\",\n      value: async function _loadMap() {\n        let map = this.shadowRoot.getElementById(\"map\");\n        if (!map) {\n          map = document.createElement(\"div\");\n          map.id = \"map\";\n          this.shadowRoot.append(map);\n        }\n        [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n        this._updateMapStyle();\n        this._loaded = true;\n      }\n    }, {\n      kind: \"method\",\n      key: \"fitMap\",\n      value: function fitMap(options) {\n        var _this$layers, _this$layers2, _options$pad;\n        if (!this.leafletMap || !this.Leaflet || !this.hass) {\n          return;\n        }\n        if (!this._mapFocusItems.length && !((_this$layers = this.layers) !== null && _this$layers !== void 0 && _this$layers.length)) {\n          this.leafletMap.setView(new this.Leaflet.LatLng(this.hass.config.latitude, this.hass.config.longitude), (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom);\n          return;\n        }\n        let bounds = this.Leaflet.latLngBounds(this._mapFocusItems ? this._mapFocusItems.map(item => item.getLatLng()) : []);\n        if (this.fitZones) {\n          var _this$_mapZones;\n          (_this$_mapZones = this._mapZones) === null || _this$_mapZones === void 0 || _this$_mapZones.forEach(zone => {\n            bounds.extend(\"getBounds\" in zone ? zone.getBounds() : zone.getLatLng());\n          });\n        }\n        (_this$layers2 = this.layers) === null || _this$layers2 === void 0 || _this$layers2.forEach(layer => {\n          bounds.extend(\"getBounds\" in layer ? layer.getBounds() : layer.getLatLng());\n        });\n        bounds = bounds.pad((_options$pad = options === null || options === void 0 ? void 0 : options.pad) !== null && _options$pad !== void 0 ? _options$pad : 0.5);\n        this.leafletMap.fitBounds(bounds, {\n          maxZoom: (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"fitBounds\",\n      value: function fitBounds(boundingbox, options) {\n        var _options$pad2;\n        if (!this.leafletMap || !this.Leaflet || !this.hass) {\n          return;\n        }\n        const bounds = this.Leaflet.latLngBounds(boundingbox).pad((_options$pad2 = options === null || options === void 0 ? void 0 : options.pad) !== null && _options$pad2 !== void 0 ? _options$pad2 : 0.5);\n        this.leafletMap.fitBounds(bounds, {\n          maxZoom: (options === null || options === void 0 ? void 0 : options.zoom) || this.zoom\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawLayers\",\n      value: function _drawLayers(prevLayers) {\n        if (prevLayers) {\n          prevLayers.forEach(layer => layer.remove());\n        }\n        if (!this.layers) {\n          return;\n        }\n        const map = this.leafletMap;\n        this.layers.forEach(layer => {\n          map.addLayer(layer);\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_computePathTooltip\",\n      value: function _computePathTooltip(path, point) {\n        let formattedTime;\n        if (path.fullDatetime) {\n          formattedTime = formatDateTime(point.timestamp, this.hass.locale, this.hass.config);\n        } else if (isToday(point.timestamp)) {\n          formattedTime = formatTimeWithSeconds(point.timestamp, this.hass.locale, this.hass.config);\n        } else {\n          formattedTime = formatTimeWeekday(point.timestamp, this.hass.locale, this.hass.config);\n        }\n        return `${path.name}<br>${formattedTime}`;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawPaths\",\n      value: function _drawPaths() {\n        const hass = this.hass;\n        const map = this.leafletMap;\n        const Leaflet = this.Leaflet;\n        if (!hass || !map || !Leaflet) {\n          return;\n        }\n        if (this._mapPaths.length) {\n          this._mapPaths.forEach(marker => marker.remove());\n          this._mapPaths = [];\n        }\n        if (!this.paths) {\n          return;\n        }\n        const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\"--dark-primary-color\");\n        this.paths.forEach(path => {\n          let opacityStep;\n          let baseOpacity;\n          if (path.gradualOpacity) {\n            opacityStep = path.gradualOpacity / (path.points.length - 2);\n            baseOpacity = 1 - path.gradualOpacity;\n          }\n          for (let pointIndex = 0; pointIndex < path.points.length - 1; pointIndex++) {\n            const opacity = path.gradualOpacity ? baseOpacity + pointIndex * opacityStep : undefined;\n\n            // DRAW point\n            this._mapPaths.push(Leaflet.circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true\n            }).bindTooltip(this._computePathTooltip(path, path.points[pointIndex]), {\n              direction: \"top\"\n            }));\n\n            // DRAW line between this and next point\n            this._mapPaths.push(Leaflet.polyline([path.points[pointIndex].point, path.points[pointIndex + 1].point], {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false\n            }));\n          }\n          const pointIndex = path.points.length - 1;\n          if (pointIndex >= 0) {\n            const opacity = path.gradualOpacity ? baseOpacity + pointIndex * opacityStep : undefined;\n            // DRAW end path point\n            this._mapPaths.push(Leaflet.circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true\n            }).bindTooltip(this._computePathTooltip(path, path.points[pointIndex]), {\n              direction: \"top\"\n            }));\n          }\n          this._mapPaths.forEach(marker => map.addLayer(marker));\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_drawEntities\",\n      value: function _drawEntities() {\n        const hass = this.hass;\n        const map = this.leafletMap;\n        const Leaflet = this.Leaflet;\n        if (!hass || !map || !Leaflet) {\n          return;\n        }\n        if (this._mapItems.length) {\n          this._mapItems.forEach(marker => marker.remove());\n          this._mapItems = [];\n          this._mapFocusItems = [];\n        }\n        if (this._mapZones.length) {\n          this._mapZones.forEach(marker => marker.remove());\n          this._mapZones = [];\n        }\n        if (!this.entities) {\n          return;\n        }\n        const computedStyles = getComputedStyle(this);\n        const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n        const passiveZoneColor = computedStyles.getPropertyValue(\"--secondary-text-color\");\n        const darkPrimaryColor = computedStyles.getPropertyValue(\"--dark-primary-color\");\n        const className = this.darkMode || this.hass.themes.darkMode ? \"dark\" : \"light\";\n        for (const entity of this.entities) {\n          const stateObj = hass.states[getEntityId(entity)];\n          if (!stateObj) {\n            continue;\n          }\n          const customTitle = typeof entity !== \"string\" ? entity.name : undefined;\n          const title = customTitle !== null && customTitle !== void 0 ? customTitle : computeStateName(stateObj);\n          const {\n            latitude,\n            longitude,\n            passive,\n            icon,\n            radius,\n            entity_picture: entityPicture,\n            gps_accuracy: gpsAccuracy\n          } = stateObj.attributes;\n          if (!(latitude && longitude)) {\n            continue;\n          }\n          if (computeStateDomain(stateObj) === \"zone\") {\n            // DRAW ZONE\n            if (passive && !this.renderPassive) {\n              continue;\n            }\n\n            // create icon\n            let iconHTML = \"\";\n            if (icon) {\n              const el = document.createElement(\"ha-icon\");\n              el.setAttribute(\"icon\", icon);\n              iconHTML = el.outerHTML;\n            } else {\n              const el = document.createElement(\"span\");\n              el.innerHTML = title;\n              iconHTML = el.outerHTML;\n            }\n\n            // create marker with the icon\n            this._mapZones.push(Leaflet.marker([latitude, longitude], {\n              icon: Leaflet.divIcon({\n                html: iconHTML,\n                iconSize: [24, 24],\n                className\n              }),\n              interactive: this.interactiveZones,\n              title\n            }));\n\n            // create circle around it\n            this._mapZones.push(Leaflet.circle([latitude, longitude], {\n              interactive: false,\n              color: passive ? passiveZoneColor : zoneColor,\n              radius\n            }));\n            continue;\n          }\n\n          // DRAW ENTITY\n          // create icon\n          const entityName = typeof entity !== \"string\" && entity.label_mode === \"state\" ? this.hass.formatEntityState(stateObj) : customTitle !== null && customTitle !== void 0 ? customTitle : title.split(\" \").map(part => part[0]).join(\"\").substr(0, 3);\n\n          // create marker with the icon\n          const marker = Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${entityPicture ? this.hass.hassUrl(entityPicture) : \"\"}\"\n                ${typeof entity !== \"string\" ? `entity-color=\"${entity.color}\"` : \"\"}\n              ></ha-entity-marker>\n            `,\n              iconSize: [48, 48],\n              className: \"\"\n            }),\n            title: title\n          });\n          this._mapItems.push(marker);\n          if (typeof entity === \"string\" || entity.focus !== false) {\n            this._mapFocusItems.push(marker);\n          }\n\n          // create circle around if entity has accuracy\n          if (gpsAccuracy) {\n            this._mapItems.push(Leaflet.circle([latitude, longitude], {\n              interactive: false,\n              color: darkPrimaryColor,\n              radius: gpsAccuracy\n            }));\n          }\n        }\n        this._mapItems.forEach(marker => map.addLayer(marker));\n        this._mapZones.forEach(marker => map.addLayer(marker));\n      }\n    }, {\n      kind: \"method\",\n      key: \"_attachObserver\",\n      value: async function _attachObserver() {\n        if (!this._resizeObserver) {\n          await loadPolyfillIfNeeded();\n          this._resizeObserver = new ResizeObserver(() => {\n            var _this$leafletMap;\n            (_this$leafletMap = this.leafletMap) === null || _this$leafletMap === void 0 || _this$leafletMap.invalidateSize({\n              debounceMoveend: true\n            });\n          });\n        }\n        this._resizeObserver.observe(this);\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n      }\n      #map.forced-dark {\n        --map-filter: invert(0.9) hue-rotate(170deg) brightness(1.5)\n          contrast(1.2) saturate(0.3);\n      }\n      #map:active {\n        cursor: grabbing;\n        cursor: -moz-grabbing;\n        cursor: -webkit-grabbing;\n      }\n      .light {\n        color: #000000;\n      }\n      .dark {\n        color: #ffffff;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: var(--card-background-color, #1c1c1c);\n        color: #ffffff;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n      .leaflet-tooltip {\n        padding: 8px;\n        font-size: 90%;\n        background: rgba(80, 80, 80, 0.9) !important;\n        color: white !important;\n        border-radius: 4px;\n        box-shadow: none !important;\n        text-align: center;\n      }\n    `;\n      }\n    }]\n  };\n}, ReactiveElement);","map":{"version":3,"names":["isToday","css","ReactiveElement","customElement","property","state","setupLeafletMap","formatTimeWithSeconds","formatTimeWeekday","formatDateTime","computeStateDomain","computeStateName","loadPolyfillIfNeeded","isTouch","getEntityId","entity","entity_id","HaMap","_decorate","_initialize","_ReactiveElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","Number","connectedCallback","_get","_getPrototypeOf","prototype","call","_loadMap","_attachObserver","disconnectedCallback","leafletMap","remove","undefined","Leaflet","_loaded","_resizeObserver","unobserve","update","changedProps","_oldHass$themes","_this$hass$themes","autoFitRequired","oldHass","get","has","_drawEntities","entities","states","hass","_drawPaths","_drawLayers","autoFit","fitMap","setZoom","zoom","themes","darkMode","_updateMapStyle","_this$hass$themes$dar","forcedDark","map","renderRoot","querySelector","classList","toggle","shadowRoot","getElementById","document","createElement","id","append","options","_this$layers","_this$layers2","_options$pad","_mapFocusItems","length","layers","setView","LatLng","config","latitude","longitude","bounds","latLngBounds","item","getLatLng","fitZones","_this$_mapZones","_mapZones","forEach","zone","extend","getBounds","layer","pad","fitBounds","maxZoom","boundingbox","_options$pad2","prevLayers","addLayer","_computePathTooltip","path","point","formattedTime","fullDatetime","timestamp","locale","name","_mapPaths","marker","paths","darkPrimaryColor","getComputedStyle","getPropertyValue","opacityStep","baseOpacity","gradualOpacity","points","pointIndex","opacity","push","circleMarker","radius","color","fillOpacity","interactive","bindTooltip","direction","polyline","_mapItems","computedStyles","zoneColor","passiveZoneColor","className","stateObj","customTitle","title","passive","icon","entity_picture","entityPicture","gps_accuracy","gpsAccuracy","attributes","renderPassive","iconHTML","el","setAttribute","outerHTML","innerHTML","divIcon","html","iconSize","interactiveZones","circle","entityName","label_mode","formatEntityState","split","part","join","substr","hassUrl","focus","ResizeObserver","_this$leafletMap","invalidateSize","debounceMoveend","observe","static","styles"],"sources":["/workspaces/frontend/src/components/map/ha-map.ts"],"sourcesContent":["import type {\n  Circle,\n  CircleMarker,\n  LatLngTuple,\n  LatLngExpression,\n  Layer,\n  Map,\n  Marker,\n  Polyline,\n} from \"leaflet\";\nimport { isToday } from \"date-fns\";\nimport { css, CSSResultGroup, PropertyValues, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport {\n  LeafletModuleType,\n  setupLeafletMap,\n} from \"../../common/dom/setup-leaflet-map\";\nimport {\n  formatTimeWithSeconds,\n  formatTimeWeekday,\n} from \"../../common/datetime/format_time\";\nimport { formatDateTime } from \"../../common/datetime/format_date_time\";\nimport { computeStateDomain } from \"../../common/entity/compute_state_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { loadPolyfillIfNeeded } from \"../../resources/resize-observer.polyfill\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-icon-button\";\nimport \"./ha-entity-marker\";\nimport { isTouch } from \"../../util/is_touch\";\n\nconst getEntityId = (entity: string | HaMapEntity): string =>\n  typeof entity === \"string\" ? entity : entity.entity_id;\n\nexport interface HaMapPathPoint {\n  point: LatLngTuple;\n  timestamp: Date;\n}\nexport interface HaMapPaths {\n  points: HaMapPathPoint[];\n  color?: string;\n  name?: string;\n  gradualOpacity?: number;\n  fullDatetime?: boolean;\n}\n\nexport interface HaMapEntity {\n  entity_id: string;\n  color: string;\n  label_mode?: \"name\" | \"state\";\n  name?: string;\n  focus?: boolean;\n}\n\n@customElement(\"ha-map\")\nexport class HaMap extends ReactiveElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public entities?: string[] | HaMapEntity[];\n\n  @property({ attribute: false }) public paths?: HaMapPaths[];\n\n  @property({ attribute: false }) public layers?: Layer[];\n\n  @property({ type: Boolean }) public autoFit = false;\n\n  @property({ type: Boolean }) public renderPassive = false;\n\n  @property({ type: Boolean }) public interactiveZones = false;\n\n  @property({ type: Boolean }) public fitZones = false;\n\n  @property({ type: Boolean }) public darkMode = false;\n\n  @property({ type: Number }) public zoom = 14;\n\n  @state() private _loaded = false;\n\n  public leafletMap?: Map;\n\n  private Leaflet?: LeafletModuleType;\n\n  private _resizeObserver?: ResizeObserver;\n\n  private _mapItems: Array<Marker | Circle> = [];\n\n  private _mapFocusItems: Array<Marker | Circle> = [];\n\n  private _mapZones: Array<Marker | Circle> = [];\n\n  private _mapPaths: Array<Polyline | CircleMarker> = [];\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    this._loadMap();\n    this._attachObserver();\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    if (this.leafletMap) {\n      this.leafletMap.remove();\n      this.leafletMap = undefined;\n      this.Leaflet = undefined;\n    }\n\n    this._loaded = false;\n\n    if (this._resizeObserver) {\n      this._resizeObserver.unobserve(this);\n    }\n  }\n\n  protected update(changedProps: PropertyValues) {\n    super.update(changedProps);\n\n    if (!this._loaded) {\n      return;\n    }\n    let autoFitRequired = false;\n    const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"entities\")) {\n      this._drawEntities();\n      autoFitRequired = true;\n    } else if (this._loaded && oldHass && this.entities) {\n      // Check if any state has changed\n      for (const entity of this.entities) {\n        if (\n          oldHass.states[getEntityId(entity)] !==\n          this.hass!.states[getEntityId(entity)]\n        ) {\n          this._drawEntities();\n          autoFitRequired = true;\n          break;\n        }\n      }\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"paths\")) {\n      this._drawPaths();\n    }\n\n    if (changedProps.has(\"_loaded\") || changedProps.has(\"layers\")) {\n      this._drawLayers(changedProps.get(\"layers\") as Layer[] | undefined);\n      autoFitRequired = true;\n    }\n\n    if (changedProps.has(\"_loaded\") || (this.autoFit && autoFitRequired)) {\n      this.fitMap();\n    }\n\n    if (changedProps.has(\"zoom\")) {\n      this.leafletMap!.setZoom(this.zoom);\n    }\n\n    if (\n      !changedProps.has(\"darkMode\") &&\n      (!changedProps.has(\"hass\") ||\n        (oldHass && oldHass.themes?.darkMode === this.hass.themes?.darkMode))\n    ) {\n      return;\n    }\n    this._updateMapStyle();\n  }\n\n  private _updateMapStyle(): void {\n    const darkMode = this.darkMode || (this.hass.themes.darkMode ?? false);\n    const forcedDark = this.darkMode;\n    const map = this.renderRoot.querySelector(\"#map\");\n    map!.classList.toggle(\"dark\", darkMode);\n    map!.classList.toggle(\"forced-dark\", forcedDark);\n  }\n\n  private async _loadMap(): Promise<void> {\n    let map = this.shadowRoot!.getElementById(\"map\");\n    if (!map) {\n      map = document.createElement(\"div\");\n      map.id = \"map\";\n      this.shadowRoot!.append(map);\n    }\n    [this.leafletMap, this.Leaflet] = await setupLeafletMap(map);\n    this._updateMapStyle();\n    this._loaded = true;\n  }\n\n  public fitMap(options?: { zoom?: number; pad?: number }): void {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n\n    if (!this._mapFocusItems.length && !this.layers?.length) {\n      this.leafletMap.setView(\n        new this.Leaflet.LatLng(\n          this.hass.config.latitude,\n          this.hass.config.longitude\n        ),\n        options?.zoom || this.zoom\n      );\n      return;\n    }\n\n    let bounds = this.Leaflet.latLngBounds(\n      this._mapFocusItems\n        ? this._mapFocusItems.map((item) => item.getLatLng())\n        : []\n    );\n\n    if (this.fitZones) {\n      this._mapZones?.forEach((zone) => {\n        bounds.extend(\n          \"getBounds\" in zone ? zone.getBounds() : zone.getLatLng()\n        );\n      });\n    }\n\n    this.layers?.forEach((layer: any) => {\n      bounds.extend(\n        \"getBounds\" in layer ? layer.getBounds() : layer.getLatLng()\n      );\n    });\n\n    bounds = bounds.pad(options?.pad ?? 0.5);\n\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  public fitBounds(\n    boundingbox: LatLngExpression[],\n    options?: { zoom?: number; pad?: number }\n  ) {\n    if (!this.leafletMap || !this.Leaflet || !this.hass) {\n      return;\n    }\n    const bounds = this.Leaflet.latLngBounds(boundingbox).pad(\n      options?.pad ?? 0.5\n    );\n    this.leafletMap.fitBounds(bounds, { maxZoom: options?.zoom || this.zoom });\n  }\n\n  private _drawLayers(prevLayers: Layer[] | undefined): void {\n    if (prevLayers) {\n      prevLayers.forEach((layer) => layer.remove());\n    }\n    if (!this.layers) {\n      return;\n    }\n    const map = this.leafletMap!;\n    this.layers.forEach((layer) => {\n      map.addLayer(layer);\n    });\n  }\n\n  private _computePathTooltip(path: HaMapPaths, point: HaMapPathPoint): string {\n    let formattedTime: string;\n    if (path.fullDatetime) {\n      formattedTime = formatDateTime(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else if (isToday(point.timestamp)) {\n      formattedTime = formatTimeWithSeconds(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    } else {\n      formattedTime = formatTimeWeekday(\n        point.timestamp,\n        this.hass.locale,\n        this.hass.config\n      );\n    }\n    return `${path.name}<br>${formattedTime}`;\n  }\n\n  private _drawPaths(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n    if (this._mapPaths.length) {\n      this._mapPaths.forEach((marker) => marker.remove());\n      this._mapPaths = [];\n    }\n    if (!this.paths) {\n      return;\n    }\n\n    const darkPrimaryColor = getComputedStyle(this).getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    this.paths.forEach((path) => {\n      let opacityStep: number;\n      let baseOpacity: number;\n      if (path.gradualOpacity) {\n        opacityStep = path.gradualOpacity / (path.points.length - 2);\n        baseOpacity = 1 - path.gradualOpacity;\n      }\n\n      for (\n        let pointIndex = 0;\n        pointIndex < path.points.length - 1;\n        pointIndex++\n      ) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n\n        // DRAW point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n\n        // DRAW line between this and next point\n        this._mapPaths.push(\n          Leaflet!.polyline(\n            [path.points[pointIndex].point, path.points[pointIndex + 1].point],\n            {\n              color: path.color || darkPrimaryColor,\n              opacity,\n              interactive: false,\n            }\n          )\n        );\n      }\n      const pointIndex = path.points.length - 1;\n      if (pointIndex >= 0) {\n        const opacity = path.gradualOpacity\n          ? baseOpacity! + pointIndex * opacityStep!\n          : undefined;\n        // DRAW end path point\n        this._mapPaths.push(\n          Leaflet!\n            .circleMarker(path.points[pointIndex].point, {\n              radius: isTouch ? 8 : 3,\n              color: path.color || darkPrimaryColor,\n              opacity,\n              fillOpacity: opacity,\n              interactive: true,\n            })\n            .bindTooltip(\n              this._computePathTooltip(path, path.points[pointIndex]),\n              { direction: \"top\" }\n            )\n        );\n      }\n      this._mapPaths.forEach((marker) => map.addLayer(marker));\n    });\n  }\n\n  private _drawEntities(): void {\n    const hass = this.hass;\n    const map = this.leafletMap;\n    const Leaflet = this.Leaflet;\n\n    if (!hass || !map || !Leaflet) {\n      return;\n    }\n\n    if (this._mapItems.length) {\n      this._mapItems.forEach((marker) => marker.remove());\n      this._mapItems = [];\n      this._mapFocusItems = [];\n    }\n\n    if (this._mapZones.length) {\n      this._mapZones.forEach((marker) => marker.remove());\n      this._mapZones = [];\n    }\n\n    if (!this.entities) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(this);\n    const zoneColor = computedStyles.getPropertyValue(\"--accent-color\");\n    const passiveZoneColor = computedStyles.getPropertyValue(\n      \"--secondary-text-color\"\n    );\n\n    const darkPrimaryColor = computedStyles.getPropertyValue(\n      \"--dark-primary-color\"\n    );\n\n    const className =\n      this.darkMode || this.hass.themes.darkMode ? \"dark\" : \"light\";\n\n    for (const entity of this.entities) {\n      const stateObj = hass.states[getEntityId(entity)];\n      if (!stateObj) {\n        continue;\n      }\n      const customTitle = typeof entity !== \"string\" ? entity.name : undefined;\n      const title = customTitle ?? computeStateName(stateObj);\n      const {\n        latitude,\n        longitude,\n        passive,\n        icon,\n        radius,\n        entity_picture: entityPicture,\n        gps_accuracy: gpsAccuracy,\n      } = stateObj.attributes;\n\n      if (!(latitude && longitude)) {\n        continue;\n      }\n\n      if (computeStateDomain(stateObj) === \"zone\") {\n        // DRAW ZONE\n        if (passive && !this.renderPassive) {\n          continue;\n        }\n\n        // create icon\n        let iconHTML = \"\";\n        if (icon) {\n          const el = document.createElement(\"ha-icon\");\n          el.setAttribute(\"icon\", icon);\n          iconHTML = el.outerHTML;\n        } else {\n          const el = document.createElement(\"span\");\n          el.innerHTML = title;\n          iconHTML = el.outerHTML;\n        }\n\n        // create marker with the icon\n        this._mapZones.push(\n          Leaflet.marker([latitude, longitude], {\n            icon: Leaflet.divIcon({\n              html: iconHTML,\n              iconSize: [24, 24],\n              className,\n            }),\n            interactive: this.interactiveZones,\n            title,\n          })\n        );\n\n        // create circle around it\n        this._mapZones.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: passive ? passiveZoneColor : zoneColor,\n            radius,\n          })\n        );\n\n        continue;\n      }\n\n      // DRAW ENTITY\n      // create icon\n      const entityName =\n        typeof entity !== \"string\" && entity.label_mode === \"state\"\n          ? this.hass.formatEntityState(stateObj)\n          : customTitle ??\n            title\n              .split(\" \")\n              .map((part) => part[0])\n              .join(\"\")\n              .substr(0, 3);\n\n      // create marker with the icon\n      const marker = Leaflet.marker([latitude, longitude], {\n        icon: Leaflet.divIcon({\n          html: `\n              <ha-entity-marker\n                entity-id=\"${getEntityId(entity)}\"\n                entity-name=\"${entityName}\"\n                entity-picture=\"${\n                  entityPicture ? this.hass.hassUrl(entityPicture) : \"\"\n                }\"\n                ${\n                  typeof entity !== \"string\"\n                    ? `entity-color=\"${entity.color}\"`\n                    : \"\"\n                }\n              ></ha-entity-marker>\n            `,\n          iconSize: [48, 48],\n          className: \"\",\n        }),\n        title: title,\n      });\n      this._mapItems.push(marker);\n      if (typeof entity === \"string\" || entity.focus !== false) {\n        this._mapFocusItems.push(marker);\n      }\n\n      // create circle around if entity has accuracy\n      if (gpsAccuracy) {\n        this._mapItems.push(\n          Leaflet.circle([latitude, longitude], {\n            interactive: false,\n            color: darkPrimaryColor,\n            radius: gpsAccuracy,\n          })\n        );\n      }\n    }\n\n    this._mapItems.forEach((marker) => map.addLayer(marker));\n    this._mapZones.forEach((marker) => map.addLayer(marker));\n  }\n\n  private async _attachObserver(): Promise<void> {\n    if (!this._resizeObserver) {\n      await loadPolyfillIfNeeded();\n      this._resizeObserver = new ResizeObserver(() => {\n        this.leafletMap?.invalidateSize({ debounceMoveend: true });\n      });\n    }\n    this._resizeObserver.observe(this);\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 300px;\n      }\n      #map {\n        height: 100%;\n      }\n      #map.dark {\n        background: #090909;\n      }\n      #map.forced-dark {\n        --map-filter: invert(0.9) hue-rotate(170deg) brightness(1.5)\n          contrast(1.2) saturate(0.3);\n      }\n      #map:active {\n        cursor: grabbing;\n        cursor: -moz-grabbing;\n        cursor: -webkit-grabbing;\n      }\n      .light {\n        color: #000000;\n      }\n      .dark {\n        color: #ffffff;\n      }\n      .leaflet-tile-pane {\n        filter: var(--map-filter);\n      }\n      .dark .leaflet-bar a {\n        background-color: var(--card-background-color, #1c1c1c);\n        color: #ffffff;\n      }\n      .leaflet-marker-draggable {\n        cursor: move !important;\n      }\n      .leaflet-edit-resize {\n        border-radius: 50%;\n        cursor: nesw-resize !important;\n      }\n      .named-icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-direction: column;\n        text-align: center;\n        color: var(--primary-text-color);\n      }\n      .leaflet-pane {\n        z-index: 0 !important;\n      }\n      .leaflet-control,\n      .leaflet-top,\n      .leaflet-bottom {\n        z-index: 1 !important;\n      }\n      .leaflet-tooltip {\n        padding: 8px;\n        font-size: 90%;\n        background: rgba(80, 80, 80, 0.9) !important;\n        color: white !important;\n        border-radius: 4px;\n        box-shadow: none !important;\n        text-align: center;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-map\": HaMap;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}