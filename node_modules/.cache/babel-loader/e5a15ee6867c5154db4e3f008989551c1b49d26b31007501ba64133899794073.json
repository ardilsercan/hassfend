{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nvar generateStateHistory = function generateStateHistory(state, deltas, start_date, end_date) {\n  var changes = _typeof(deltas[0]) === \"object\" ? deltas : deltas.map(function (st) {\n    return {\n      state: st\n    };\n  });\n  var timeDiff = (end_date.getTime() - start_date.getTime()) / changes.length;\n  return changes.map(function (change, index) {\n    var attributes;\n    if (!change.attributes && !state.attributes) {\n      attributes = {};\n    } else if (!change.attributes) {\n      attributes = state.attributes;\n    } else if (!state.attributes) {\n      attributes = change.attributes;\n    } else {\n      attributes = Object.assign(Object.assign({}, state.attributes), change.attributes);\n    }\n    var time = start_date.getTime() + timeDiff * index;\n    return {\n      a: attributes,\n      s: change.state || state.state,\n      lc: time / 1000,\n      lu: time / 1000\n    };\n  });\n};\nvar incrementalUnits = [\"clients\", \"queries\", \"ads\"];\nexport var mockHistory = function mockHistory(mockHass) {\n  mockHass.mockWS(\"history/stream\", function (_ref, hass, onChange) {\n    var entity_ids = _ref.entity_ids,\n      start_time = _ref.start_time,\n      end_time = _ref.end_time;\n    var states = {};\n    var start = new Date(start_time);\n    var end = end_time ? new Date(end_time) : new Date();\n    var _iterator = _createForOfIteratorHelper(entity_ids),\n      _step;\n    try {\n      var _loop = function _loop() {\n          var entityId = _step.value;\n          states[entityId] = [];\n          var state = hass.states[entityId];\n          if (!state) {\n            return 0; // continue\n          }\n          if (!state.attributes.unit_of_measurement) {\n            states[entityId] = generateStateHistory(state, [state.state], start, end);\n            return 0; // continue\n          }\n          var numberState = Number(state.state);\n          if (isNaN(numberState)) {\n            // eslint-disable-next-line no-console\n            console.log(\"Ignoring state with unparsable state but with a unit\", entityId, state);\n            return 0; // continue\n          }\n          var statesToGenerate = 15;\n          var genFunc;\n          if (incrementalUnits.includes(state.attributes.unit_of_measurement)) {\n            var initial = Math.floor(numberState * 0.4 + numberState * Math.random() * 0.2);\n            var diff = Math.max(1, Math.floor((numberState - initial) / statesToGenerate));\n            genFunc = function genFunc() {\n              initial += diff;\n              return Math.min(numberState, initial);\n            };\n          } else {\n            var _diff = Math.floor(numberState * (numberState > 80 ? 0.05 : 0.5));\n            genFunc = function genFunc() {\n              return numberState - _diff + Math.floor(Math.random() * 2 * _diff);\n            };\n          }\n          states[entityId] = generateStateHistory(state, Array.from({\n            length: statesToGenerate\n          }, genFunc), start, end);\n        },\n        _ret;\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    setTimeout(function () {\n      onChange === null || onChange === void 0 || onChange({\n        states: states,\n        start_time: start,\n        end_time: end\n      });\n    }, 1);\n    return function () {};\n  });\n};","map":{"version":3,"names":["generateStateHistory","state","deltas","start_date","end_date","changes","_typeof","map","st","timeDiff","getTime","length","change","index","attributes","Object","assign","time","a","s","lc","lu","incrementalUnits","mockHistory","mockHass","mockWS","_ref","hass","onChange","entity_ids","start_time","end_time","states","start","Date","end","_iterator","_createForOfIteratorHelper","_step","_loop","entityId","value","unit_of_measurement","numberState","Number","isNaN","console","log","statesToGenerate","genFunc","includes","initial","Math","floor","random","diff","max","min","Array","from","_ret","n","done","err","e","f","setTimeout"],"sources":["/Users/sercanardil/Desktop/frontend/demo/src/stubs/history.ts"],"sourcesContent":["import { HassEntity } from \"home-assistant-js-websocket\";\nimport { HistoryStates } from \"../../../src/data/history\";\nimport { MockHomeAssistant } from \"../../../src/fake_data/provide_hass\";\n\nconst generateStateHistory = (\n  state: HassEntity,\n  deltas,\n  start_date: Date,\n  end_date: Date\n) => {\n  const changes =\n    typeof deltas[0] === \"object\"\n      ? deltas\n      : deltas.map((st) => ({ state: st }));\n\n  const timeDiff = (end_date.getTime() - start_date.getTime()) / changes.length;\n\n  return changes.map((change, index) => {\n    let attributes;\n    if (!change.attributes && !state.attributes) {\n      attributes = {};\n    } else if (!change.attributes) {\n      attributes = state.attributes;\n    } else if (!state.attributes) {\n      attributes = change.attributes;\n    } else {\n      attributes = { ...state.attributes, ...change.attributes };\n    }\n\n    const time = start_date.getTime() + timeDiff * index;\n\n    return {\n      a: attributes,\n      s: change.state || state.state,\n      lc: time / 1000,\n      lu: time / 1000,\n    };\n  });\n};\n\nconst incrementalUnits = [\"clients\", \"queries\", \"ads\"];\n\nexport const mockHistory = (mockHass: MockHomeAssistant) => {\n  mockHass.mockWS(\n    \"history/stream\",\n    (\n      {\n        entity_ids,\n        start_time,\n        end_time,\n      }: {\n        entity_ids: string[];\n        start_time: string;\n        end_time?: string;\n      },\n      hass,\n      onChange\n    ) => {\n      const states: HistoryStates = {};\n\n      const start = new Date(start_time);\n      const end = end_time ? new Date(end_time) : new Date();\n\n      for (const entityId of entity_ids) {\n        states[entityId] = [];\n\n        const state = hass.states[entityId];\n\n        if (!state) {\n          continue;\n        }\n\n        if (!state.attributes.unit_of_measurement) {\n          states[entityId] = generateStateHistory(\n            state,\n            [state.state],\n            start,\n            end\n          );\n          continue;\n        }\n\n        const numberState = Number(state.state);\n\n        if (isNaN(numberState)) {\n          // eslint-disable-next-line no-console\n          console.log(\n            \"Ignoring state with unparsable state but with a unit\",\n            entityId,\n            state\n          );\n          continue;\n        }\n\n        const statesToGenerate = 15;\n        let genFunc;\n\n        if (incrementalUnits.includes(state.attributes.unit_of_measurement)) {\n          let initial = Math.floor(\n            numberState * 0.4 + numberState * Math.random() * 0.2\n          );\n          const diff = Math.max(\n            1,\n            Math.floor((numberState - initial) / statesToGenerate)\n          );\n          genFunc = () => {\n            initial += diff;\n            return Math.min(numberState, initial);\n          };\n        } else {\n          const diff = Math.floor(\n            numberState * (numberState > 80 ? 0.05 : 0.5)\n          );\n          genFunc = () =>\n            numberState - diff + Math.floor(Math.random() * 2 * diff);\n        }\n\n        states[entityId] = generateStateHistory(\n          state,\n          Array.from({ length: statesToGenerate }, genFunc),\n          start,\n          end\n        );\n      }\n\n      setTimeout(() => {\n        onChange?.({\n          states,\n          start_time: start,\n          end_time: end,\n        });\n      }, 1);\n\n      return () => {};\n    }\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}