{"ast":null,"code":"import _taggedTemplateLiteral from \"@babel/runtime/helpers/taggedTemplateLiteral\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _templateObject, _templateObject2;\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { ariaProperty } from '@material/mwc-base/aria-property.js';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { SingleSelectionController } from '@material/mwc-radio/single-selection-controller.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport MDCRadioFoundation from '@material/radio/foundation.js';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/**\n * @fires checked\n * @soyCompatible\n */\nexport var RadioBase = /*#__PURE__*/function (_FormElement) {\n  _inherits(RadioBase, _FormElement);\n  function RadioBase() {\n    var _this;\n    _classCallCheck(this, RadioBase);\n    _this = _callSuper(this, RadioBase, arguments);\n    _this._checked = false;\n    _this.useStateLayerCustomProperties = false;\n    _this.global = false;\n    _this.disabled = false;\n    _this.value = 'on';\n    _this.name = '';\n    /**\n     * Touch target extends beyond visual boundary of a component by default.\n     * Set to `true` to remove touch target added to the component.\n     * @see https://material.io/design/usability/accessibility.html\n     */\n    _this.reducedTouchTarget = false;\n    _this.mdcFoundationClass = MDCRadioFoundation;\n    /**\n     * input's tabindex is updated based on checked status.\n     * Tab navigation will be removed from unchecked radios.\n     */\n    _this.formElementTabIndex = 0;\n    _this.focused = false;\n    _this.shouldRenderRipple = false;\n    _this.rippleElement = null;\n    _this.rippleHandlers = new RippleHandlers(function () {\n      _this.shouldRenderRipple = true;\n      _this.ripple.then(function (v) {\n        _this.rippleElement = v;\n      });\n      return _this.ripple;\n    });\n    return _this;\n  }\n  _createClass(RadioBase, [{\n    key: \"checked\",\n    get: function get() {\n      return this._checked;\n    }\n    /**\n     * We define our own getter/setter for `checked` because we need to track\n     * changes to it synchronously.\n     *\n     * The order in which the `checked` property is set across radio buttons\n     * within the same group is very important. However, we can't rely on\n     * UpdatingElement's `updated` callback to observe these changes (which is\n     * also what the `@observer` decorator uses), because it batches changes to\n     * all properties.\n     *\n     * Consider:\n     *\n     *   radio1.disabled = true;\n     *   radio2.checked = true;\n     *   radio1.checked = true;\n     *\n     * In this case we'd first see all changes for radio1, and then for radio2,\n     * and we couldn't tell that radio1 was the most recently checked.\n     */,\n    set: function set(isChecked) {\n      var _a, _b;\n      var oldValue = this._checked;\n      if (isChecked === oldValue) {\n        return;\n      }\n      this._checked = isChecked;\n      if (this.formElement) {\n        this.formElement.checked = isChecked;\n      }\n      (_a = this._selectionController) === null || _a === void 0 ? void 0 : _a.update(this);\n      if (isChecked === false) {\n        // Remove focus ring when unchecked on other radio programmatically.\n        // Blur on input since this determines the focus style.\n        (_b = this.formElement) === null || _b === void 0 ? void 0 : _b.blur();\n      }\n      this.requestUpdate('checked', oldValue);\n      // useful when unchecks self and wrapping element needs to synchronize\n      // TODO(b/168543810): Remove triggering event on programmatic API call.\n      this.dispatchEvent(new Event('checked', {\n        bubbles: true,\n        composed: true\n      }));\n    }\n  }, {\n    key: \"_handleUpdatedValue\",\n    value: function _handleUpdatedValue(newValue) {\n      // the observer function can't access protected fields (according to\n      // closure compiler) because it's not a method on the class, so we need this\n      // wrapper.\n      this.formElement.value = newValue;\n    }\n    /** @soyTemplate */\n  }, {\n    key: \"renderRipple\",\n    value: function renderRipple() {\n      return this.shouldRenderRipple ? html(_templateObject || (_templateObject = _taggedTemplateLiteral([\"<mwc-ripple unbounded accent\\n        .internalUseStateLayerCustomProperties=\\\"\", \"\\\"\\n        .disabled=\\\"\", \"\\\"></mwc-ripple>\"])), this.useStateLayerCustomProperties, this.disabled) : '';\n    }\n  }, {\n    key: \"isRippleActive\",\n    get: function get() {\n      var _a;\n      return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(RadioBase.prototype), \"connectedCallback\", this).call(this);\n      // Note that we must defer creating the selection controller until the\n      // element has connected, because selection controllers are keyed by the\n      // radio's shadow root. For example, if we're stamping in a lit map\n      // or repeat, then we'll be constructed before we're added to a root node.\n      //\n      // Also note if we aren't using native shadow DOM, we still need a\n      // SelectionController, because we should update checked status of other\n      // radios in the group when selection changes. It also simplifies\n      // implementation and testing to use one in all cases.\n      //\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      this._selectionController = SingleSelectionController.getController(this);\n      this._selectionController.register(this);\n      // Radios maybe checked before connected, update selection as soon it is\n      // connected to DOM. Last checked radio button in the DOM will be selected.\n      //\n      // NOTE: If we update selection only after firstUpdate() we might mistakenly\n      // update checked status before other radios are rendered.\n      this._selectionController.update(this);\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      // The controller is initialized in connectedCallback, so if we are in\n      // disconnectedCallback then it must be initialized.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this._selectionController.unregister(this);\n      this._selectionController = undefined;\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.formElement.focus();\n    }\n  }, {\n    key: \"createAdapter\",\n    value: function createAdapter() {\n      var _this2 = this;\n      return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {\n        setNativeControlDisabled: function setNativeControlDisabled(disabled) {\n          _this2.formElement.disabled = disabled;\n        }\n      });\n    }\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus() {\n      this.focused = true;\n      this.handleRippleFocus();\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick() {\n      // Firefox has weird behavior with radios if they are not focused\n      this.formElement.focus();\n    }\n  }, {\n    key: \"handleBlur\",\n    value: function handleBlur() {\n      this.focused = false;\n      this.formElement.blur();\n      this.rippleHandlers.endFocus();\n    }\n  }, {\n    key: \"setFormData\",\n    value: function setFormData(formData) {\n      if (this.name && this.checked) {\n        formData.append(this.name, this.value);\n      }\n    }\n    /**\n     * @soyTemplate\n     * @soyAttributes radioAttributes: input\n     * @soyClasses radioClasses: .mdc-radio\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      /** @classMap */\n      var classes = {\n        'mdc-radio--touch': !this.reducedTouchTarget,\n        'mdc-ripple-upgraded--background-focused': this.focused,\n        'mdc-radio--disabled': this.disabled\n      };\n      return html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n      <div class=\\\"mdc-radio \", \"\\\">\\n        <input\\n          tabindex=\\\"\", \"\\\"\\n          class=\\\"mdc-radio__native-control\\\"\\n          type=\\\"radio\\\"\\n          name=\\\"\", \"\\\"\\n          aria-label=\\\"\", \"\\\"\\n          aria-labelledby=\\\"\", \"\\\"\\n          .checked=\\\"\", \"\\\"\\n          .value=\\\"\", \"\\\"\\n          ?disabled=\\\"\", \"\\\"\\n          @change=\\\"\", \"\\\"\\n          @focus=\\\"\", \"\\\"\\n          @click=\\\"\", \"\\\"\\n          @blur=\\\"\", \"\\\"\\n          @mousedown=\\\"\", \"\\\"\\n          @mouseenter=\\\"\", \"\\\"\\n          @mouseleave=\\\"\", \"\\\"\\n          @touchstart=\\\"\", \"\\\"\\n          @touchend=\\\"\", \"\\\"\\n          @touchcancel=\\\"\", \"\\\">\\n        <div class=\\\"mdc-radio__background\\\">\\n          <div class=\\\"mdc-radio__outer-circle\\\"></div>\\n          <div class=\\\"mdc-radio__inner-circle\\\"></div>\\n        </div>\\n        \", \"\\n      </div>\"])), classMap(classes), this.formElementTabIndex, this.name, ifDefined(this.ariaLabel), ifDefined(this.ariaLabelledBy), this.checked, this.value, this.disabled, this.changeHandler, this.handleFocus, this.handleClick, this.handleBlur, this.handleRippleMouseDown, this.handleRippleMouseEnter, this.handleRippleMouseLeave, this.handleRippleTouchStart, this.handleRippleDeactivate, this.handleRippleDeactivate, this.renderRipple());\n    }\n  }, {\n    key: \"handleRippleMouseDown\",\n    value: function handleRippleMouseDown(event) {\n      var _this3 = this;\n      var onUp = function onUp() {\n        window.removeEventListener('mouseup', onUp);\n        _this3.handleRippleDeactivate();\n      };\n      window.addEventListener('mouseup', onUp);\n      this.rippleHandlers.startPress(event);\n    }\n  }, {\n    key: \"handleRippleTouchStart\",\n    value: function handleRippleTouchStart(event) {\n      this.rippleHandlers.startPress(event);\n    }\n  }, {\n    key: \"handleRippleDeactivate\",\n    value: function handleRippleDeactivate() {\n      this.rippleHandlers.endPress();\n    }\n  }, {\n    key: \"handleRippleMouseEnter\",\n    value: function handleRippleMouseEnter() {\n      this.rippleHandlers.startHover();\n    }\n  }, {\n    key: \"handleRippleMouseLeave\",\n    value: function handleRippleMouseLeave() {\n      this.rippleHandlers.endHover();\n    }\n  }, {\n    key: \"handleRippleFocus\",\n    value: function handleRippleFocus() {\n      this.rippleHandlers.startFocus();\n    }\n  }, {\n    key: \"changeHandler\",\n    value: function changeHandler() {\n      this.checked = this.formElement.checked;\n    }\n  }]);\n  return RadioBase;\n}(FormElement);\n__decorate([query('.mdc-radio')], RadioBase.prototype, \"mdcRoot\", void 0);\n__decorate([query('input')], RadioBase.prototype, \"formElement\", void 0);\n__decorate([state()], RadioBase.prototype, \"useStateLayerCustomProperties\", void 0);\n__decorate([property({\n  type: Boolean\n})], RadioBase.prototype, \"global\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], RadioBase.prototype, \"checked\", null);\n__decorate([property({\n  type: Boolean\n}), observer(function (disabled) {\n  this.mdcFoundation.setDisabled(disabled);\n})], RadioBase.prototype, \"disabled\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (value) {\n  this._handleUpdatedValue(value);\n})], RadioBase.prototype, \"value\", void 0);\n__decorate([property({\n  type: String\n})], RadioBase.prototype, \"name\", void 0);\n__decorate([property({\n  type: Boolean\n})], RadioBase.prototype, \"reducedTouchTarget\", void 0);\n__decorate([property({\n  type: Number\n})], RadioBase.prototype, \"formElementTabIndex\", void 0);\n__decorate([state()], RadioBase.prototype, \"focused\", void 0);\n__decorate([state()], RadioBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([queryAsync('mwc-ripple')], RadioBase.prototype, \"ripple\", void 0);\n__decorate([ariaProperty, property({\n  attribute: 'aria-label'\n})], RadioBase.prototype, \"ariaLabel\", void 0);\n__decorate([ariaProperty, property({\n  attribute: 'aria-labelledby'\n})], RadioBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([eventOptions({\n  passive: true\n})], RadioBase.prototype, \"handleRippleTouchStart\", null);","map":{"version":3,"names":["ariaProperty","addHasRemoveClass","FormElement","observer","SingleSelectionController","RippleHandlers","MDCRadioFoundation","html","eventOptions","property","query","queryAsync","state","classMap","ifDefined","RadioBase","_FormElement","_inherits","_this","_classCallCheck","_checked","useStateLayerCustomProperties","global","disabled","value","name","reducedTouchTarget","mdcFoundationClass","formElementTabIndex","focused","shouldRenderRipple","rippleElement","rippleHandlers","ripple","then","v","_createClass","key","get","set","isChecked","oldValue","formElement","checked","_a","_selectionController","update","_b","blur","requestUpdate","dispatchEvent","Event","bubbles","composed","_handleUpdatedValue","newValue","renderRipple","_templateObject","_taggedTemplateLiteral","isActive","connectedCallback","_get","_getPrototypeOf","prototype","call","getController","register","disconnectedCallback","unregister","undefined","focus","createAdapter","_this2","Object","assign","mdcRoot","setNativeControlDisabled","handleFocus","handleRippleFocus","handleClick","handleBlur","endFocus","setFormData","formData","append","render","classes","_templateObject2","ariaLabel","ariaLabelledBy","changeHandler","handleRippleMouseDown","handleRippleMouseEnter","handleRippleMouseLeave","handleRippleTouchStart","handleRippleDeactivate","event","_this3","onUp","window","removeEventListener","addEventListener","startPress","endPress","startHover","endHover","startFocus","__decorate","type","Boolean","reflect","mdcFoundation","setDisabled","String","Number","attribute","passive"],"sources":["mwc-radio-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport '@material/mwc-ripple/mwc-ripple.js';\n\nimport {ariaProperty} from '@material/mwc-base/aria-property.js';\nimport {addHasRemoveClass, FormElement} from '@material/mwc-base/form-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {SingleSelectionController} from '@material/mwc-radio/single-selection-controller.js';\nimport {Ripple} from '@material/mwc-ripple/mwc-ripple.js';\nimport {RippleHandlers} from '@material/mwc-ripple/ripple-handlers.js';\nimport {MDCRadioAdapter} from '@material/radio/adapter.js';\nimport MDCRadioFoundation from '@material/radio/foundation.js';\nimport {html, TemplateResult} from 'lit';\nimport {eventOptions, property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\n\n/**\n * @fires checked\n * @soyCompatible\n */\nexport class RadioBase extends FormElement {\n  @query('.mdc-radio') protected mdcRoot!: HTMLElement;\n\n  @query('input') protected formElement!: HTMLInputElement;\n\n  protected _checked = false;\n\n  @state() protected useStateLayerCustomProperties = false;\n\n  @property({type: Boolean}) global = false;\n\n  @property({type: Boolean, reflect: true})\n  get checked(): boolean {\n    return this._checked;\n  }\n\n  /**\n   * We define our own getter/setter for `checked` because we need to track\n   * changes to it synchronously.\n   *\n   * The order in which the `checked` property is set across radio buttons\n   * within the same group is very important. However, we can't rely on\n   * UpdatingElement's `updated` callback to observe these changes (which is\n   * also what the `@observer` decorator uses), because it batches changes to\n   * all properties.\n   *\n   * Consider:\n   *\n   *   radio1.disabled = true;\n   *   radio2.checked = true;\n   *   radio1.checked = true;\n   *\n   * In this case we'd first see all changes for radio1, and then for radio2,\n   * and we couldn't tell that radio1 was the most recently checked.\n   */\n  set checked(isChecked: boolean) {\n    const oldValue = this._checked;\n    if (isChecked === oldValue) {\n      return;\n    }\n    this._checked = isChecked;\n    if (this.formElement) {\n      this.formElement.checked = isChecked;\n    }\n    this._selectionController?.update(this);\n\n    if (isChecked === false) {\n      // Remove focus ring when unchecked on other radio programmatically.\n      // Blur on input since this determines the focus style.\n      this.formElement?.blur();\n    }\n    this.requestUpdate('checked', oldValue);\n\n    // useful when unchecks self and wrapping element needs to synchronize\n    // TODO(b/168543810): Remove triggering event on programmatic API call.\n    this.dispatchEvent(new Event('checked', {bubbles: true, composed: true}));\n  }\n\n  @property({type: Boolean})\n  @observer(function(this: RadioBase, disabled: boolean) {\n    this.mdcFoundation.setDisabled(disabled);\n  })\n  override disabled = false;\n\n  @property({type: String})\n  @observer(function(this: RadioBase, value: string) {\n    this._handleUpdatedValue(value);\n  })\n  value = 'on';\n\n  _handleUpdatedValue(newValue: string) {\n    // the observer function can't access protected fields (according to\n    // closure compiler) because it's not a method on the class, so we need this\n    // wrapper.\n    this.formElement.value = newValue;\n  }\n\n  @property({type: String}) name = '';\n\n  /**\n   * Touch target extends beyond visual boundary of a component by default.\n   * Set to `true` to remove touch target added to the component.\n   * @see https://material.io/design/usability/accessibility.html\n   */\n  @property({type: Boolean}) reducedTouchTarget = false;\n\n  protected mdcFoundationClass = MDCRadioFoundation;\n\n  protected mdcFoundation!: MDCRadioFoundation;\n\n  protected _selectionController?: SingleSelectionController;\n\n  /**\n   * input's tabindex is updated based on checked status.\n   * Tab navigation will be removed from unchecked radios.\n   */\n  @property({type: Number}) formElementTabIndex = 0;\n\n  @state() protected focused = false;\n  @state() protected shouldRenderRipple = false;\n\n  @queryAsync('mwc-ripple') override ripple!: Promise<Ripple|null>;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({attribute: 'aria-label'})\n  override ariaLabel!: string;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({attribute: 'aria-labelledby'})\n  ariaLabelledBy!: string;\n\n  protected rippleElement: Ripple|null = null;\n\n  protected rippleHandlers: RippleHandlers = new RippleHandlers(() => {\n    this.shouldRenderRipple = true;\n    this.ripple.then((v) => {\n      this.rippleElement = v;\n    });\n\n    return this.ripple;\n  });\n\n  /** @soyTemplate */\n  protected renderRipple(): TemplateResult|string {\n    return this.shouldRenderRipple ? html`<mwc-ripple unbounded accent\n        .internalUseStateLayerCustomProperties=\"${\n                                         this.useStateLayerCustomProperties}\"\n        .disabled=\"${this.disabled}\"></mwc-ripple>` :\n                                     '';\n  }\n\n  get isRippleActive() {\n    return this.rippleElement?.isActive || false;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    // Note that we must defer creating the selection controller until the\n    // element has connected, because selection controllers are keyed by the\n    // radio's shadow root. For example, if we're stamping in a lit map\n    // or repeat, then we'll be constructed before we're added to a root node.\n    //\n    // Also note if we aren't using native shadow DOM, we still need a\n    // SelectionController, because we should update checked status of other\n    // radios in the group when selection changes. It also simplifies\n    // implementation and testing to use one in all cases.\n    //\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    this._selectionController = SingleSelectionController.getController(this);\n    this._selectionController.register(this);\n\n    // Radios maybe checked before connected, update selection as soon it is\n    // connected to DOM. Last checked radio button in the DOM will be selected.\n    //\n    // NOTE: If we update selection only after firstUpdate() we might mistakenly\n    // update checked status before other radios are rendered.\n    this._selectionController.update(this);\n  }\n\n  override disconnectedCallback() {\n    // The controller is initialized in connectedCallback, so if we are in\n    // disconnectedCallback then it must be initialized.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._selectionController!.unregister(this);\n    this._selectionController = undefined;\n  }\n\n  override focus() {\n    this.formElement.focus();\n  }\n\n  protected createAdapter(): MDCRadioAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      setNativeControlDisabled: (disabled: boolean) => {\n        this.formElement.disabled = disabled;\n      },\n    };\n  }\n\n  protected handleFocus() {\n    this.focused = true;\n    this.handleRippleFocus();\n  }\n\n  protected handleClick() {\n    // Firefox has weird behavior with radios if they are not focused\n    this.formElement.focus();\n  }\n\n  protected handleBlur() {\n    this.focused = false;\n    this.formElement.blur();\n    this.rippleHandlers.endFocus();\n  }\n\n  protected setFormData(formData: FormData) {\n    if (this.name && this.checked) {\n      formData.append(this.name, this.value);\n    }\n  }\n\n  /**\n   * @soyTemplate\n   * @soyAttributes radioAttributes: input\n   * @soyClasses radioClasses: .mdc-radio\n   */\n  protected override render(): TemplateResult {\n    /** @classMap */\n    const classes = {\n      'mdc-radio--touch': !this.reducedTouchTarget,\n      'mdc-ripple-upgraded--background-focused': this.focused,\n      'mdc-radio--disabled': this.disabled,\n    };\n\n    return html`\n      <div class=\"mdc-radio ${classMap(classes)}\">\n        <input\n          tabindex=\"${this.formElementTabIndex}\"\n          class=\"mdc-radio__native-control\"\n          type=\"radio\"\n          name=\"${this.name}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n          .checked=\"${this.checked}\"\n          .value=\"${this.value}\"\n          ?disabled=\"${this.disabled}\"\n          @change=\"${this.changeHandler}\"\n          @focus=\"${this.handleFocus}\"\n          @click=\"${this.handleClick}\"\n          @blur=\"${this.handleBlur}\"\n          @mousedown=\"${this.handleRippleMouseDown}\"\n          @mouseenter=\"${this.handleRippleMouseEnter}\"\n          @mouseleave=\"${this.handleRippleMouseLeave}\"\n          @touchstart=\"${this.handleRippleTouchStart}\"\n          @touchend=\"${this.handleRippleDeactivate}\"\n          @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-radio__background\">\n          <div class=\"mdc-radio__outer-circle\"></div>\n          <div class=\"mdc-radio__inner-circle\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n  }\n\n  protected handleRippleMouseDown(event: Event) {\n    const onUp = () => {\n      window.removeEventListener('mouseup', onUp);\n\n      this.handleRippleDeactivate();\n    };\n\n    window.addEventListener('mouseup', onUp);\n    this.rippleHandlers.startPress(event);\n  }\n\n  @eventOptions({passive: true})\n  protected handleRippleTouchStart(event: Event) {\n    this.rippleHandlers.startPress(event);\n  }\n\n  protected handleRippleDeactivate() {\n    this.rippleHandlers.endPress();\n  }\n\n  protected handleRippleMouseEnter() {\n    this.rippleHandlers.startHover();\n  }\n\n  protected handleRippleMouseLeave() {\n    this.rippleHandlers.endHover();\n  }\n\n  protected handleRippleFocus() {\n    this.rippleHandlers.startFocus();\n  }\n\n  protected changeHandler() {\n    this.checked = this.formElement.checked;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}