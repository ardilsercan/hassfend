{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin, builtCSS } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { scopeSubtree } from '../utils/scope-subtree.js';\nimport { legacyOptimizations, legacyNoObservedAttributes } from '../utils/settings.js';\nimport { findObservedAttributesGetter } from '../mixins/disable-upgrade-mixin.js';\nimport { register } from '../utils/telemetry.js';\nconst DISABLED_ATTR = 'disable-upgrade';\nlet styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @appliesMixin DirMixin\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport const LegacyElementMixin = dedupingMixin(base => {\n  // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here\n  // (rather than on legacyElementBase) for unknown reasons.\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const GesturesElement = GestureEventListeners(ElementMixin(base));\n\n  // Note, the DirMixin does nothing if css is built so avoid including it\n  // in that case.\n\n  /**\n   * @constructor\n   * @extends {GesturesElement}\n   * @private\n   */\n  const legacyElementBase = builtCSS ? GesturesElement : DirMixin(GesturesElement);\n  const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  const DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  class LegacyElement extends legacyElementBase {\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      this._debouncers;\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      /** @type {boolean|undefined} */\n      this.__isUpgradeDisabled;\n      /** @type {boolean|undefined} */\n      this.__needsAttributesAtConnected;\n      /** @type {boolean|undefined} */\n      this._legacyForceObservedAttributes;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     * @nocollapse\n     */\n    static get importMeta() {\n      return this.prototype.importMeta;\n    }\n\n    /**\n     * Legacy callback called during the `constructor`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    created() {}\n\n    /**\n     * Processes an attribute reaction when the `legacyNoObservedAttributes`\n     * setting is in use.\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @return {void}\n     */\n    __attributeReaction(name, old, value) {\n      if (this.__dataAttributes && this.__dataAttributes[name] || name === DISABLED_ATTR) {\n        this.attributeChangedCallback(name, old, value, null);\n      }\n    }\n\n    /**\n     * Sets the value of an attribute.\n     * @override\n     */\n    setAttribute(name, value) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.setAttribute(name, value);\n        // value coerced to String for closure's benefit\n        this.__attributeReaction(name, oldValue, String(value));\n      } else {\n        super.setAttribute(name, value);\n      }\n    }\n\n    /**\n     * Removes an attribute.\n     * @override\n     */\n    removeAttribute(name) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.removeAttribute(name);\n        this.__attributeReaction(name, oldValue, null);\n      } else {\n        super.removeAttribute(name);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    static get observedAttributes() {\n      if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {\n        // Ensure this element is property registered with the telemetry system.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          this.__observedAttributes = [];\n          register(this.prototype);\n        }\n        return this.__observedAttributes;\n      } else {\n        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // Prevent element from enabling properties when it's upgrade disabled.\n    // Normally overriding connectedCallback would be enough, but dom-* elements\n    /** @override */\n    _enableProperties() {\n      if (!this.__isUpgradeDisabled) {\n        super._enableProperties();\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // If the element starts upgrade-disabled and a property is set for\n    // which an accessor exists, the default should not be applied.\n    // This additional check is needed because defaults are applied via\n    // `_initializeProperties` which is called after initial properties\n    // have been set when the element starts upgrade-disabled.\n    /** @override */\n    _canApplyPropertyDefault(property) {\n      return super._canApplyPropertyDefault(property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n    }\n\n    /**\n     * Provides an implementation of `connectedCallback`\n     * which adds Polymer legacy API's `attached` method.\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      if (this.__needsAttributesAtConnected) {\n        this._takeAttributes();\n      }\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.connectedCallback();\n        this.isAttached = true;\n        this.attached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `connectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    attached() {}\n\n    /**\n     * Provides an implementation of `disconnectedCallback`\n     * which adds Polymer legacy API's `detached` method.\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.disconnectedCallback();\n        this.isAttached = false;\n        this.detached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `disconnectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    detached() {}\n\n    /**\n     * Provides an override implementation of `attributeChangedCallback`\n     * which adds the Polymer legacy API's `attributeChanged` method.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        if (name == DISABLED_ATTR) {\n          // When disable-upgrade is removed, intialize properties and\n          // provoke connectedCallback if the element is already connected.\n          if (this.__isUpgradeDisabled && value == null) {\n            this._initializeProperties();\n            this.__isUpgradeDisabled = false;\n            if (wrap(this).isConnected) {\n              this.connectedCallback();\n            }\n          }\n        } else {\n          super.attributeChangedCallback(name, old, value, namespace);\n          this.attributeChanged(name, old, value);\n        }\n      }\n    }\n\n    /**\n     * Legacy callback called during `attributeChangedChallback`, for overriding\n     * by the user.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     * @override\n     */\n    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for class initialization via the `_registered` callback.\n     * This is called only when the first instance of the element is created.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n    _initializeProperties() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      // Only auto-use disable-upgrade if legacyOptimizations is set.\n      if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {\n        this.__isUpgradeDisabled = true;\n      } else {\n        let proto = Object.getPrototypeOf(this);\n        if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {\n          this._registered();\n          // backstop in case the `_registered` implementation does not set this\n          proto.__hasRegisterFinished = true;\n        }\n        super._initializeProperties();\n        this.root = /** @type {HTMLElement} */this;\n        this.created();\n        // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.\n        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n          if (this.hasAttributes()) {\n            this._takeAttributes();\n            // Element created from scratch or parser generated\n          } else if (!this.parentNode) {\n            this.__needsAttributesAtConnected = true;\n          }\n        }\n        // Ensure listeners are applied immediately so that they are\n        // added before declarative event listeners. This allows an element to\n        // decorate itself via an event prior to any declarative listeners\n        // seeing the event. Note, this ensures compatibility with 1.x ordering.\n        this._applyListeners();\n      }\n    }\n    _takeAttributes() {\n      const a = this.attributes;\n      for (let i = 0, l = a.length; i < l; i++) {\n        const attr = a[i];\n        this.__attributeReaction(attr.name, null, attr.value);\n      }\n    }\n\n    /**\n     * Called automatically when an element is initializing.\n     * Users may override this method to perform class registration time\n     * work. The implementation should ensure the work is performed\n     * only once for the class.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _registered() {}\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for installing `hostAttributes` and `listeners`.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      this._ensureAttributes();\n      super.ready();\n    }\n\n    /**\n     * Ensures an element has required attributes. Called when the element\n     * is being readied via `ready`. Users should override to set the\n     * element's required attributes. The implementation should be sure\n     * to check and not override existing attributes added by\n     * the user of the element. Typically, setting attributes should be left\n     * to the element user and not done here; reasonable exceptions include\n     * setting aria roles and focusability.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _ensureAttributes() {}\n\n    /**\n     * Adds element event listeners. Called when the element\n     * is being readied via `ready`. Users should override to\n     * add any required element event listeners.\n     * In performance critical elements, the work done here should be kept\n     * to a minimum since it is done before the element is rendered. In\n     * these elements, consider adding listeners asynchronously so as not to\n     * block render.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _applyListeners() {}\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features. To customize\n     * how properties are serialized to attributes for attribute bindings and\n     * `reflectToAttribute: true` properties as well as this method, override\n     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {*} value Value to deserialize\n     * @return {string | undefined} Serialized value\n     * @override\n     */\n    serialize(value) {\n      return this._serializeValue(value);\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.  To customize\n     * how attributes are deserialized to properties for in\n     * `attributeChangedCallback`, override `_deserializeValue` method\n     * provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {string} value String to deserialize\n     * @param {*} type Type to deserialize the string to\n     * @return {*} Returns the deserialized value in the `type` given.\n     * @override\n     */\n    deserialize(value, type) {\n      return this._deserializeValue(value, type);\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect.\n     * @param {*=} value Property value to reflect.\n     * @return {void}\n     * @override\n     */\n    reflectPropertyToAttribute(property, attribute, value) {\n      this._propertyToAttribute(property, attribute, value);\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @param {Element} node Element to set attribute to.\n     * @return {void}\n     * @override\n     */\n    serializeValueToAttribute(value, attribute, node) {\n      this._valueToNodeAttribute( /** @type {Element} */node || this, value, attribute);\n    }\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     * @override\n     */\n    extend(prototype, api) {\n      if (!(prototype && api)) {\n        return prototype || api;\n      }\n      let n$ = Object.getOwnPropertyNames(api);\n      for (let i = 0, n; i < n$.length && (n = n$[i]); i++) {\n        let pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          Object.defineProperty(prototype, n, pd);\n        }\n      }\n      return prototype;\n    }\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @param {!Object} target Target object to copy properties to.\n     * @param {!Object} source Source object to copy properties from.\n     * @return {!Object} Target object that was passed as first argument.\n     * @override\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n\n    /**\n     * Sets the prototype of an object.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     * @param {Object} object The object on which to set the prototype.\n     * @param {Object} prototype The prototype that will be set on the given\n     * `object`.\n     * @return {Object} Returns the given `object` with its prototype set\n     * to the given `prototype` object.\n     * @override\n     */\n    chainObject(object, prototype) {\n      if (object && prototype && object !== prototype) {\n        object.__proto__ = prototype;\n      }\n      return object;\n    }\n\n    /* **** Begin Template **** */\n\n    /**\n     * Calls `importNode` on the `content` of the `template` specified and\n     * returns a document fragment containing the imported content.\n     *\n     * @param {HTMLTemplateElement} template HTML template element to instance.\n     * @return {!DocumentFragment} Document fragment containing the imported\n     *   template content.\n     * @override\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    instanceTemplate(template) {\n      let content = this.constructor._contentForTemplate(template);\n      let dom = /** @type {!DocumentFragment} */\n      document.importNode(content, true);\n      return dom;\n    }\n\n    /* **** Begin Events **** */\n\n    /**\n     * Dispatches a custom event with an optional detail value.\n     *\n     * @param {string} type Name of event type.\n     * @param {*=} detail Detail value containing event-specific\n     *   payload.\n     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n     *     composed: (boolean|undefined) }=}\n     *  options Object specifying options.  These may include:\n     *  `bubbles` (boolean, defaults to `true`),\n     *  `cancelable` (boolean, defaults to false), and\n     *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n     * @return {!Event} The new event that was fired.\n     * @override\n     */\n    fire(type, detail, options) {\n      options = options || {};\n      detail = detail === null || detail === undefined ? {} : detail;\n      let event = new Event(type, {\n        bubbles: options.bubbles === undefined ? true : options.bubbles,\n        cancelable: Boolean(options.cancelable),\n        composed: options.composed === undefined ? true : options.composed\n      });\n      event.detail = detail;\n      let node = options.node || this;\n      wrap(node).dispatchEvent(event);\n      return event;\n    }\n\n    /**\n     * Convenience method to add an event listener on a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to add event listener to.\n     * @param {string} eventName Name of event to listen for.\n     * @param {string} methodName Name of handler method on `this` to call.\n     * @return {void}\n     * @override\n     */\n    listen(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */node || this;\n      let hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());\n      let bl = hbl.get(node);\n      if (!bl) {\n        bl = {};\n        hbl.set(node, bl);\n      }\n      let key = eventName + methodName;\n      if (!bl[key]) {\n        bl[key] = this._addMethodEventListenerToNode( /** @type {!Node} */node, eventName, methodName, this);\n      }\n    }\n\n    /**\n     * Convenience method to remove an event listener from a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to remove event listener from.\n     * @param {string} eventName Name of event to stop listening to.\n     * @param {string} methodName Name of handler method on `this` to not call\n     anymore.\n     * @return {void}\n     * @override\n     */\n    unlisten(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */node || this;\n      let bl = this.__boundListeners && this.__boundListeners.get( /** @type {!Element} */node);\n      let key = eventName + methodName;\n      let handler = bl && bl[key];\n      if (handler) {\n        this._removeEventListenerFromNode( /** @type {!Node} */node, eventName, handler);\n        bl[key] = /** @type {?} */null;\n      }\n    }\n\n    /**\n     * Override scrolling behavior to all direction, one direction, or none.\n     *\n     * Valid scroll directions:\n     *   - 'all': scroll in any direction\n     *   - 'x': scroll only in the 'x' direction\n     *   - 'y': scroll only in the 'y' direction\n     *   - 'none': disable scrolling for this node\n     *\n     * @param {string=} direction Direction to allow scrolling\n     * Defaults to `all`.\n     * @param {Element=} node Element to apply scroll direction setting.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    setScrollDirection(direction, node) {\n      setTouchAction( /** @type {!Element} */node || this, DIRECTION_MAP[direction] || 'auto');\n    }\n    /* **** End Events **** */\n\n    /**\n     * Convenience method to run `querySelector` on this local DOM scope.\n     *\n     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n     *\n     * @param {string} slctr Selector to run on this local DOM scope\n     * @return {Element} Element found by the selector, or null if not found.\n     * @override\n     */\n    $$(slctr) {\n      // Note, no need to `wrap` this because root is always patched\n      return this.root.querySelector(slctr);\n    }\n\n    /**\n     * Return the element whose local dom within which this element\n     * is contained. This is a shorthand for\n     * `this.getRootNode().host`.\n     * @this {Element}\n     * @return {?Node} The element whose local dom within which this element is\n     * contained.\n     * @override\n     */\n    get domHost() {\n      let root = wrap(this).getRootNode();\n      return root instanceof DocumentFragment ? /** @type {ShadowRoot} */root.host : root;\n    }\n\n    /**\n     * Force this element to distribute its children to its local dom.\n     * This should not be necessary as of Polymer 2.0.2 and is provided only\n     * for backwards compatibility.\n     * @return {void}\n     * @override\n     */\n    distributeContent() {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      if (window.ShadyDOM && domApi.shadowRoot) {\n        ShadyDOM.flush();\n      }\n    }\n\n    /**\n     * Returns a list of nodes that are the effective childNodes. The effective\n     * childNodes list is the same as the element's childNodes except that\n     * any `<content>` elements are replaced with the list of nodes distributed\n     * to the `<content>`, the result of its `getDistributedNodes` method.\n     * @return {!Array<!Node>} List of effective child nodes.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getEffectiveChildNodes() {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      return domApi.getEffectiveChildNodes();\n    }\n\n    /**\n     * Returns a list of nodes distributed within this element that match\n     * `selector`. These can be dom children or elements distributed to\n     * children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of distributed elements that match selector.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    queryDistributedElements(selector) {\n      const thisEl = /** @type {Element} */this;\n      const domApi = /** @type {PolymerDomApi} */dom(thisEl);\n      return domApi.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of elements that are the effective children. The effective\n     * children list is the same as the element's children except that\n     * any `<content>` elements are replaced with the list of elements\n     * distributed to the `<content>`.\n     *\n     * @return {!Array<!Node>} List of effective children.\n     * @override\n     */\n    getEffectiveChildren() {\n      let list = this.getEffectiveChildNodes();\n      return list.filter(function ( /** @type {!Node} */n) {\n        return n.nodeType === Node.ELEMENT_NODE;\n      });\n    }\n\n    /**\n     * Returns a string of text content that is the concatenation of the\n     * text content's of the element's effective childNodes (the elements\n     * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n     *\n     * @return {string} List of effective children.\n     * @override\n     */\n    getEffectiveTextContent() {\n      let cn = this.getEffectiveChildNodes();\n      let tc = [];\n      for (let i = 0, c; c = cn[i]; i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c.textContent);\n        }\n      }\n      return tc.join('');\n    }\n\n    /**\n     * Returns the first effective childNode within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {Node} First effective child node that matches selector.\n     * @override\n     */\n    queryEffectiveChildren(selector) {\n      let e$ = this.queryDistributedElements(selector);\n      return e$ && e$[0];\n    }\n\n    /**\n     * Returns a list of effective childNodes within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of effective child nodes that match\n     *     selector.\n     * @override\n     */\n    queryAllEffectiveChildren(selector) {\n      return this.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of nodes distributed to this element's `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its local DOM,\n     * an optional selector may be passed to choose the desired content.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<slot>`.  Defaults to `content`.\n     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n     * @override\n     */\n    getContentChildNodes(slctr) {\n      // Note, no need to `wrap` this because root is always\n      let content = this.root.querySelector(slctr || 'slot');\n      return content ? /** @type {PolymerDomApi} */dom(content).getDistributedNodes() : [];\n    }\n\n    /**\n     * Returns a list of element children distributed to this element's\n     * `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its\n     * local DOM, an optional selector may be passed to choose the desired\n     * content.  This method differs from `getContentChildNodes` in that only\n     * elements are returned.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<content>`.  Defaults to `content`.\n     * @return {!Array<!HTMLElement>} List of distributed nodes for the\n     *   `<slot>`.\n     * @suppress {invalidCasts}\n     * @override\n     */\n    getContentChildren(slctr) {\n      let children = /** @type {!Array<!HTMLElement>} */this.getContentChildNodes(slctr).filter(function (n) {\n        return n.nodeType === Node.ELEMENT_NODE;\n      });\n      return children;\n    }\n\n    /**\n     * Checks whether an element is in this element's light DOM tree.\n     *\n     * @param {?Node} node The element to be checked.\n     * @return {boolean} true if node is in this element's light DOM tree.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    isLightDescendant(node) {\n      const thisNode = /** @type {Node} */this;\n      return thisNode !== node && wrap(thisNode).contains(node) && wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n    }\n\n    /**\n     * Checks whether an element is in this element's local DOM tree.\n     *\n     * @param {!Element} node The element to be checked.\n     * @return {boolean} true if node is in this element's local DOM tree.\n     * @override\n     */\n    isLocalDescendant(node) {\n      return this.root === wrap(node).getRootNode();\n    }\n\n    /**\n     * No-op for backwards compatibility. This should now be handled by\n     * ShadyCss library.\n     * @param  {!Element} container Container element to scope\n     * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n     * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n     * @override\n     */\n    scopeSubtree(container, shouldObserve = false) {\n      return scopeSubtree(container, shouldObserve);\n    }\n\n    /**\n     * Returns the computed style value for the given property.\n     * @param {string} property The css property name.\n     * @return {string} Returns the computed css property value for the given\n     * `property`.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getComputedStyleValue(property) {\n      return styleInterface.getComputedStyleValue( /** @type {!Element} */this, property);\n    }\n\n    // debounce\n\n    /**\n     * Call `debounce` to collapse multiple requests for a named task into\n     * one invocation which is made after the wait time has elapsed with\n     * no new request.  If no wait time is given, the callback will be called\n     * at microtask timing (guaranteed before paint).\n     *\n     *     debouncedClickAction(e) {\n     *       // will not call `processClick` more than once per 100ms\n     *       this.debounce('click', function() {\n     *        this.processClick();\n     *       } 100);\n     *     }\n     *\n     * @param {string} jobName String to identify the debounce job.\n     * @param {function():void} callback Function that is called (with `this`\n     *   context) when the wait time elapses.\n     * @param {number=} wait Optional wait time in milliseconds (ms) after the\n     *   last signal that must elapse before invoking `callback`\n     * @return {!Object} Returns a debouncer object on which exists the\n     * following methods: `isActive()` returns true if the debouncer is\n     * active; `cancel()` cancels the debouncer if it is active;\n     * `flush()` immediately invokes the debounced callback if the debouncer\n     * is active.\n     * @override\n     */\n    debounce(jobName, callback, wait) {\n      this._debouncers = this._debouncers || {};\n      return this._debouncers[jobName] = Debouncer.debounce(this._debouncers[jobName], wait > 0 ? timeOut.after(wait) : microTask, callback.bind(this));\n    }\n\n    /**\n     * Returns whether a named debouncer is active.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {boolean} Whether the debouncer is active (has not yet fired).\n     * @override\n     */\n    isDebouncerActive(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      return !!(debouncer && debouncer.isActive());\n    }\n\n    /**\n     * Immediately calls the debouncer `callback` and inactivates it.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    flushDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.flush();\n      }\n    }\n\n    /**\n     * Cancels an active debouncer.  The `callback` will not be called.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    cancelDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.cancel();\n      }\n    }\n\n    /**\n     * Runs a callback function asynchronously.\n     *\n     * By default (if no waitTime is specified), async callbacks are run at\n     * microtask timing, which will occur before paint.\n     *\n     * @param {!Function} callback The callback function to run, bound to\n     *     `this`.\n     * @param {number=} waitTime Time to wait before calling the\n     *   `callback`.  If unspecified or 0, the callback will be run at microtask\n     *   timing (before paint).\n     * @return {number} Handle that may be used to cancel the async job.\n     * @override\n     */\n    async(callback, waitTime) {\n      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) : ~microTask.run(callback.bind(this));\n    }\n\n    /**\n     * Cancels an async operation started with `async`.\n     *\n     * @param {number} handle Handle returned from original `async` call to\n     *   cancel.\n     * @return {void}\n     * @override\n     */\n    cancelAsync(handle) {\n      handle < 0 ? microTask.cancel(~handle) : timeOut.cancel(handle);\n    }\n\n    // other\n\n    /**\n     * Convenience method for creating an element and configuring it.\n     *\n     * @param {string} tag HTML element tag to create.\n     * @param {Object=} props Object of properties to configure on the\n     *    instance.\n     * @return {!Element} Newly created and configured element.\n     * @override\n     */\n    create(tag, props) {\n      let elt = document.createElement(tag);\n      if (props) {\n        if (elt.setProperties) {\n          elt.setProperties(props);\n        } else {\n          for (let n in props) {\n            elt[n] = props[n];\n          }\n        }\n      }\n      return elt;\n    }\n\n    /**\n     * Polyfill for Element.prototype.matches, which is sometimes still\n     * prefixed.\n     *\n     * @param {string} selector Selector to test.\n     * @param {!Element=} node Element to test the selector against.\n     * @return {boolean} Whether the element matches the selector.\n     * @override\n     */\n    elementMatches(selector, node) {\n      return matchesSelector(node || this, selector);\n    }\n\n    /**\n     * Toggles an HTML attribute on or off.\n     *\n     * @param {string} name HTML attribute name\n     * @param {boolean=} bool Boolean to force the attribute on or off.\n     *    When unspecified, the state of the attribute will be reversed.\n     * @return {boolean} true if the attribute now exists\n     * @override\n     */\n    toggleAttribute(name, bool) {\n      let node = /** @type {Element} */this;\n      if (arguments.length === 3) {\n        node = /** @type {Element} */arguments[2];\n      }\n      if (arguments.length == 1) {\n        bool = !node.hasAttribute(name);\n      }\n      if (bool) {\n        wrap(node).setAttribute(name, '');\n        return true;\n      } else {\n        wrap(node).removeAttribute(name);\n        return false;\n      }\n    }\n\n    /**\n     * Toggles a CSS class on or off.\n     *\n     * @param {string} name CSS class name\n     * @param {boolean=} bool Boolean to force the class on or off.\n     *    When unspecified, the state of the class will be reversed.\n     * @param {Element=} node Node to target.  Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    toggleClass(name, bool, node) {\n      node = /** @type {Element} */node || this;\n      if (arguments.length == 1) {\n        bool = !node.classList.contains(name);\n      }\n      if (bool) {\n        node.classList.add(name);\n      } else {\n        node.classList.remove(name);\n      }\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `transform` property.\n     *\n     * @param {string} transformText Transform setting.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`\n     * @return {void}\n     * @override\n     */\n    transform(transformText, node) {\n      node = /** @type {Element} */node || this;\n      node.style.webkitTransform = transformText;\n      node.style.transform = transformText;\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `translate3d`\n     * property.\n     *\n     * @param {number|string} x X offset.\n     * @param {number|string} y Y offset.\n     * @param {number|string} z Z offset.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    translate3d(x, y, z, node) {\n      node = /** @type {Element} */node || this;\n      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n    }\n\n    /**\n     * Removes an item from an array, if it exists.\n     *\n     * If the array is specified by path, a change notification is\n     * generated, so that observers, data bindings and computed\n     * properties watching that path can update.\n     *\n     * If the array is passed directly, **no change\n     * notification is generated**.\n     *\n     * @param {string | !Array<number|string>} arrayOrPath Path to array from\n     *     which to remove the item\n     *   (or the array itself).\n     * @param {*} item Item to remove.\n     * @return {Array} Array containing item removed.\n     * @override\n     */\n    arrayDelete(arrayOrPath, item) {\n      let index;\n      if (Array.isArray(arrayOrPath)) {\n        index = arrayOrPath.indexOf(item);\n        if (index >= 0) {\n          return arrayOrPath.splice(index, 1);\n        }\n      } else {\n        let arr = get(this, arrayOrPath);\n        index = arr.indexOf(item);\n        if (index >= 0) {\n          return this.splice(arrayOrPath, index, 1);\n        }\n      }\n      return null;\n    }\n\n    // logging\n\n    /**\n     * Facades `console.log`/`warn`/`error` as override point.\n     *\n     * @param {string} level One of 'log', 'warn', 'error'\n     * @param {Array} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      switch (level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level](...args);\n      }\n    }\n\n    /**\n     * Facades `console.log` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _log(...args) {\n      this._logger('log', args);\n    }\n\n    /**\n     * Facades `console.warn` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _warn(...args) {\n      this._logger('warn', args);\n    }\n\n    /**\n     * Facades `console.error` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _error(...args) {\n      this._logger('error', args);\n    }\n\n    /**\n     * Formats a message using the element type an a method name.\n     *\n     * @param {string} methodName Method name to associate with message\n     * @param {...*} args Array of strings or objects to log\n     * @return {!Array} Array with formatting information for `console`\n     *   logging.\n     * @override\n     */\n    _logf(methodName, ...args) {\n      return ['[%s::%s]', this.is, methodName, ...args];\n    }\n  }\n  LegacyElement.prototype.is = '';\n  return LegacyElement;\n});","map":{"version":3,"names":["ElementMixin","builtCSS","GestureEventListeners","DirMixin","dedupingMixin","dom","matchesSelector","setTouchAction","Debouncer","timeOut","microTask","get","wrap","scopeSubtree","legacyOptimizations","legacyNoObservedAttributes","findObservedAttributesGetter","register","DISABLED_ATTR","styleInterface","window","ShadyCSS","LegacyElementMixin","base","GesturesElement","legacyElementBase","observedAttributesGetter","DIRECTION_MAP","LegacyElement","constructor","isAttached","__boundListeners","_debouncers","__isUpgradeDisabled","__needsAttributesAtConnected","_legacyForceObservedAttributes","importMeta","prototype","created","__attributeReaction","name","old","value","__dataAttributes","attributeChangedCallback","setAttribute","oldValue","getAttribute","String","removeAttribute","observedAttributes","hasOwnProperty","JSCompiler_renameProperty","__observedAttributes","call","concat","_enableProperties","_canApplyPropertyDefault","property","_isPropertyPending","connectedCallback","_takeAttributes","attached","disconnectedCallback","detached","namespace","_initializeProperties","isConnected","attributeChanged","hasAttribute","proto","Object","getPrototypeOf","_registered","__hasRegisterFinished","root","hasAttributes","parentNode","_applyListeners","a","attributes","i","l","length","attr","ready","_ensureAttributes","serialize","_serializeValue","deserialize","type","_deserializeValue","reflectPropertyToAttribute","attribute","_propertyToAttribute","serializeValueToAttribute","node","_valueToNodeAttribute","extend","api","n$","getOwnPropertyNames","n","pd","getOwnPropertyDescriptor","defineProperty","mixin","target","source","chainObject","object","__proto__","instanceTemplate","template","content","_contentForTemplate","document","importNode","fire","detail","options","undefined","event","Event","bubbles","cancelable","Boolean","composed","dispatchEvent","listen","eventName","methodName","hbl","WeakMap","bl","set","key","_addMethodEventListenerToNode","unlisten","handler","_removeEventListenerFromNode","setScrollDirection","direction","$$","slctr","querySelector","domHost","getRootNode","DocumentFragment","host","distributeContent","thisEl","domApi","ShadyDOM","shadowRoot","flush","getEffectiveChildNodes","queryDistributedElements","selector","getEffectiveChildren","list","filter","nodeType","Node","ELEMENT_NODE","getEffectiveTextContent","cn","tc","c","COMMENT_NODE","push","textContent","join","queryEffectiveChildren","e$","queryAllEffectiveChildren","getContentChildNodes","getDistributedNodes","getContentChildren","children","isLightDescendant","thisNode","contains","isLocalDescendant","container","shouldObserve","getComputedStyleValue","debounce","jobName","callback","wait","after","bind","isDebouncerActive","debouncer","isActive","flushDebouncer","cancelDebouncer","cancel","async","waitTime","run","cancelAsync","handle","create","tag","props","elt","createElement","setProperties","elementMatches","toggleAttribute","bool","arguments","toggleClass","classList","add","remove","transform","transformText","style","webkitTransform","translate3d","x","y","z","arrayDelete","arrayOrPath","item","index","Array","isArray","indexOf","splice","arr","_logger","level","args","console","_log","_warn","_error","_logf","is"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/polymer/lib/legacy/legacy-element-mixin.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport '@webcomponents/shadycss/entrypoints/apply-shim.js';\nimport { ElementMixin, builtCSS } from '../mixins/element-mixin.js';\nimport { GestureEventListeners } from '../mixins/gesture-event-listeners.js';\nimport { DirMixin } from '../mixins/dir-mixin.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport '../utils/render-status.js';\nimport '../utils/unresolved.js';\nimport { dom, matchesSelector } from './polymer.dom.js';\nimport { setTouchAction } from '../utils/gestures.js';\nimport { Debouncer } from '../utils/debounce.js';\nimport { timeOut, microTask } from '../utils/async.js';\nimport { get } from '../utils/path.js';\nimport { wrap } from '../utils/wrap.js';\nimport { scopeSubtree } from '../utils/scope-subtree.js';\nimport { legacyOptimizations, legacyNoObservedAttributes } from '../utils/settings.js';\nimport { findObservedAttributesGetter } from '../mixins/disable-upgrade-mixin.js';\nimport { register } from '../utils/telemetry.js';\n\nconst DISABLED_ATTR = 'disable-upgrade';\n\nlet styleInterface = window.ShadyCSS;\n\n/**\n * Element class mixin that provides Polymer's \"legacy\" API intended to be\n * backward-compatible to the greatest extent possible with the API\n * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements\n * defined using the `Polymer({...})` function.\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin ElementMixin\n * @appliesMixin GestureEventListeners\n * @appliesMixin DirMixin\n * @property isAttached {boolean} Set to `true` in this element's\n *   `connectedCallback` and `false` in `disconnectedCallback`\n * @summary Element class mixin that provides Polymer's \"legacy\" API\n */\nexport const LegacyElementMixin = dedupingMixin((base) => {\n\n  // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here\n  // (rather than on legacyElementBase) for unknown reasons.\n  /**\n   * @constructor\n   * @implements {Polymer_ElementMixin}\n   * @implements {Polymer_GestureEventListeners}\n   * @implements {Polymer_DirMixin}\n   * @extends {HTMLElement}\n   * @private\n   */\n  const GesturesElement = GestureEventListeners(ElementMixin(base));\n\n  // Note, the DirMixin does nothing if css is built so avoid including it\n  // in that case.\n\n  /**\n   * @constructor\n   * @extends {GesturesElement}\n   * @private\n   */\n  const legacyElementBase = builtCSS ? GesturesElement :\n    DirMixin(GesturesElement);\n\n  const observedAttributesGetter = findObservedAttributesGetter(legacyElementBase);\n\n  /**\n   * Map of simple names to touch action names\n   * @dict\n   */\n  const DIRECTION_MAP = {\n    'x': 'pan-x',\n    'y': 'pan-y',\n    'none': 'none',\n    'all': 'auto'\n  };\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @extends {legacyElementBase}\n   * @implements {Polymer_LegacyElementMixin}\n   * @unrestricted\n   */\n  class LegacyElement extends legacyElementBase {\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n      this.isAttached;\n      /** @type {?WeakMap<!Element, !Object<string, !Function>>} */\n      this.__boundListeners;\n      /** @type {?Object<string, ?Function>} */\n      this._debouncers;\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      /** @type {boolean|undefined} */\n      this.__isUpgradeDisabled;\n      /** @type {boolean|undefined} */\n      this.__needsAttributesAtConnected;\n      /** @type {boolean|undefined} */\n      this._legacyForceObservedAttributes;\n    }\n\n    /**\n     * Forwards `importMeta` from the prototype (i.e. from the info object\n     * passed to `Polymer({...})`) to the static API.\n     *\n     * @return {!Object} The `import.meta` object set on the prototype\n     * @suppress {missingProperties} `this` is always in the instance in\n     *  closure for some reason even in a static method, rather than the class\n     * @nocollapse\n     */\n    static get importMeta() {\n      return this.prototype.importMeta;\n    }\n\n    /**\n     * Legacy callback called during the `constructor`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    created() {}\n\n    /**\n     * Processes an attribute reaction when the `legacyNoObservedAttributes`\n     * setting is in use.\n     * @param {string} name Name of attribute that changed\n     * @param {?string} old Old attribute value\n     * @param {?string} value New attribute value\n     * @return {void}\n     */\n    __attributeReaction(name, old, value) {\n      if ((this.__dataAttributes && this.__dataAttributes[name]) || name === DISABLED_ATTR) {\n        this.attributeChangedCallback(name, old, value, null);\n      }\n    }\n\n    /**\n     * Sets the value of an attribute.\n     * @override\n     */\n    setAttribute(name, value) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.setAttribute(name, value);\n        // value coerced to String for closure's benefit\n        this.__attributeReaction(name, oldValue, String(value));\n      } else {\n        super.setAttribute(name, value);\n      }\n    }\n\n    /**\n     * Removes an attribute.\n     * @override\n     */\n    removeAttribute(name) {\n      if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n        const oldValue = this.getAttribute(name);\n        super.removeAttribute(name);\n        this.__attributeReaction(name, oldValue, null);\n      } else {\n        super.removeAttribute(name);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    static get observedAttributes() {\n      if (legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {\n        // Ensure this element is property registered with the telemetry system.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {\n          this.__observedAttributes = [];\n          register(this.prototype);\n        }\n        return this.__observedAttributes;\n      } else {\n        return observedAttributesGetter.call(this).concat(DISABLED_ATTR);\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // Prevent element from enabling properties when it's upgrade disabled.\n    // Normally overriding connectedCallback would be enough, but dom-* elements\n    /** @override */\n    _enableProperties() {\n      if (!this.__isUpgradeDisabled) {\n        super._enableProperties();\n      }\n    }\n\n    // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n    // If the element starts upgrade-disabled and a property is set for\n    // which an accessor exists, the default should not be applied.\n    // This additional check is needed because defaults are applied via\n    // `_initializeProperties` which is called after initial properties\n    // have been set when the element starts upgrade-disabled.\n    /** @override */\n    _canApplyPropertyDefault(property) {\n      return super._canApplyPropertyDefault(property) &&\n        !(this.__isUpgradeDisabled && this._isPropertyPending(property));\n    }\n\n    /**\n     * Provides an implementation of `connectedCallback`\n     * which adds Polymer legacy API's `attached` method.\n     * @return {void}\n     * @override\n     */\n    connectedCallback() {\n      if (this.__needsAttributesAtConnected) {\n        this._takeAttributes();\n      }\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.connectedCallback();\n        this.isAttached = true;\n        this.attached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `connectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    attached() {}\n\n    /**\n     * Provides an implementation of `disconnectedCallback`\n     * which adds Polymer legacy API's `detached` method.\n     * @return {void}\n     * @override\n     */\n    disconnectedCallback() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      if (!this.__isUpgradeDisabled) {\n        super.disconnectedCallback();\n        this.isAttached = false;\n        this.detached();\n      }\n    }\n\n    /**\n     * Legacy callback called during `disconnectedCallback`, for overriding\n     * by the user.\n     * @override\n     * @return {void}\n     */\n    detached() {}\n\n    /**\n     * Provides an override implementation of `attributeChangedCallback`\n     * which adds the Polymer legacy API's `attributeChanged` method.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @param {?string} namespace Attribute namespace.\n     * @return {void}\n     * @override\n     */\n    attributeChangedCallback(name, old, value, namespace) {\n      if (old !== value) {\n        // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n        if (name == DISABLED_ATTR) {\n          // When disable-upgrade is removed, intialize properties and\n          // provoke connectedCallback if the element is already connected.\n          if (this.__isUpgradeDisabled && value == null) {\n            this._initializeProperties();\n            this.__isUpgradeDisabled = false;\n            if (wrap(this).isConnected) {\n              this.connectedCallback();\n            }\n          }\n        } else {\n          super.attributeChangedCallback(name, old, value, namespace);\n          this.attributeChanged(name, old, value);\n        }\n      }\n    }\n\n    /**\n     * Legacy callback called during `attributeChangedChallback`, for overriding\n     * by the user.\n     * @param {string} name Name of attribute.\n     * @param {?string} old Old value of attribute.\n     * @param {?string} value Current value of attribute.\n     * @return {void}\n     * @override\n     */\n    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for class initialization via the `_registered` callback.\n     * This is called only when the first instance of the element is created.\n     *\n     * @return {void}\n     * @override\n     * @suppress {invalidCasts}\n     */\n    _initializeProperties() {\n      // NOTE: Inlined for perf from version of DisableUpgradeMixin.\n      // Only auto-use disable-upgrade if legacyOptimizations is set.\n      if (legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {\n        this.__isUpgradeDisabled = true;\n      } else {\n        let proto = Object.getPrototypeOf(this);\n        if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {\n          this._registered();\n          // backstop in case the `_registered` implementation does not set this\n          proto.__hasRegisterFinished = true;\n        }\n        super._initializeProperties();\n        this.root = /** @type {HTMLElement} */(this);\n        this.created();\n        // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.\n        if (legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {\n          if (this.hasAttributes()) {\n            this._takeAttributes();\n          // Element created from scratch or parser generated\n          } else if (!this.parentNode) {\n            this.__needsAttributesAtConnected = true;\n          }\n        }\n        // Ensure listeners are applied immediately so that they are\n        // added before declarative event listeners. This allows an element to\n        // decorate itself via an event prior to any declarative listeners\n        // seeing the event. Note, this ensures compatibility with 1.x ordering.\n        this._applyListeners();\n      }\n    }\n\n    _takeAttributes() {\n      const a = this.attributes;\n      for (let i=0, l=a.length; i < l; i++) {\n        const attr = a[i];\n        this.__attributeReaction(attr.name, null, attr.value);\n      }\n    }\n\n    /**\n     * Called automatically when an element is initializing.\n     * Users may override this method to perform class registration time\n     * work. The implementation should ensure the work is performed\n     * only once for the class.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _registered() {}\n\n    /**\n     * Overrides the default `Polymer.PropertyEffects` implementation to\n     * add support for installing `hostAttributes` and `listeners`.\n     *\n     * @return {void}\n     * @override\n     */\n    ready() {\n      this._ensureAttributes();\n      super.ready();\n    }\n\n    /**\n     * Ensures an element has required attributes. Called when the element\n     * is being readied via `ready`. Users should override to set the\n     * element's required attributes. The implementation should be sure\n     * to check and not override existing attributes added by\n     * the user of the element. Typically, setting attributes should be left\n     * to the element user and not done here; reasonable exceptions include\n     * setting aria roles and focusability.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _ensureAttributes() {}\n\n    /**\n     * Adds element event listeners. Called when the element\n     * is being readied via `ready`. Users should override to\n     * add any required element event listeners.\n     * In performance critical elements, the work done here should be kept\n     * to a minimum since it is done before the element is rendered. In\n     * these elements, consider adding listeners asynchronously so as not to\n     * block render.\n     * @protected\n     * @return {void}\n     * @override\n     */\n    _applyListeners() {}\n\n    /**\n     * Converts a typed JavaScript value to a string.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features. To customize\n     * how properties are serialized to attributes for attribute bindings and\n     * `reflectToAttribute: true` properties as well as this method, override\n     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {*} value Value to deserialize\n     * @return {string | undefined} Serialized value\n     * @override\n     */\n    serialize(value) {\n      return this._serializeValue(value);\n    }\n\n    /**\n     * Converts a string to a typed JavaScript value.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.  To customize\n     * how attributes are deserialized to properties for in\n     * `attributeChangedCallback`, override `_deserializeValue` method\n     * provided by `Polymer.PropertyAccessors`.\n     *\n     * @param {string} value String to deserialize\n     * @param {*} type Type to deserialize the string to\n     * @return {*} Returns the deserialized value in the `type` given.\n     * @override\n     */\n    deserialize(value, type) {\n      return this._deserializeValue(value, type);\n    }\n\n    /**\n     * Serializes a property to its associated attribute.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {string} property Property name to reflect.\n     * @param {string=} attribute Attribute name to reflect.\n     * @param {*=} value Property value to reflect.\n     * @return {void}\n     * @override\n     */\n    reflectPropertyToAttribute(property, attribute, value) {\n      this._propertyToAttribute(property, attribute, value);\n    }\n\n    /**\n     * Sets a typed value to an HTML attribute on a node.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     *\n     * @param {*} value Value to serialize.\n     * @param {string} attribute Attribute name to serialize to.\n     * @param {Element} node Element to set attribute to.\n     * @return {void}\n     * @override\n     */\n    serializeValueToAttribute(value, attribute, node) {\n      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);\n    }\n\n    /**\n     * Copies own properties (including accessor descriptors) from a source\n     * object to a target object.\n     *\n     * @param {Object} prototype Target object to copy properties to.\n     * @param {Object} api Source object to copy properties from.\n     * @return {Object} prototype object that was passed as first argument.\n     * @override\n     */\n    extend(prototype, api) {\n      if (!(prototype && api)) {\n        return prototype || api;\n      }\n      let n$ = Object.getOwnPropertyNames(api);\n      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n        let pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          Object.defineProperty(prototype, n, pd);\n        }\n      }\n      return prototype;\n    }\n\n    /**\n     * Copies props from a source object to a target object.\n     *\n     * Note, this method uses a simple `for...in` strategy for enumerating\n     * properties.  To ensure only `ownProperties` are copied from source\n     * to target and that accessor implementations are copied, use `extend`.\n     *\n     * @param {!Object} target Target object to copy properties to.\n     * @param {!Object} source Source object to copy properties from.\n     * @return {!Object} Target object that was passed as first argument.\n     * @override\n     */\n    mixin(target, source) {\n      for (let i in source) {\n        target[i] = source[i];\n      }\n      return target;\n    }\n\n    /**\n     * Sets the prototype of an object.\n     *\n     * Note this method is provided as backward-compatible legacy API\n     * only.  It is not directly called by any Polymer features.\n     * @param {Object} object The object on which to set the prototype.\n     * @param {Object} prototype The prototype that will be set on the given\n     * `object`.\n     * @return {Object} Returns the given `object` with its prototype set\n     * to the given `prototype` object.\n     * @override\n     */\n    chainObject(object, prototype) {\n      if (object && prototype && object !== prototype) {\n        object.__proto__ = prototype;\n      }\n      return object;\n    }\n\n    /* **** Begin Template **** */\n\n    /**\n     * Calls `importNode` on the `content` of the `template` specified and\n     * returns a document fragment containing the imported content.\n     *\n     * @param {HTMLTemplateElement} template HTML template element to instance.\n     * @return {!DocumentFragment} Document fragment containing the imported\n     *   template content.\n     * @override\n     * @suppress {missingProperties} go/missingfnprops\n     */\n    instanceTemplate(template) {\n      let content = this.constructor._contentForTemplate(template);\n      let dom = /** @type {!DocumentFragment} */\n        (document.importNode(content, true));\n      return dom;\n    }\n\n    /* **** Begin Events **** */\n\n\n\n    /**\n     * Dispatches a custom event with an optional detail value.\n     *\n     * @param {string} type Name of event type.\n     * @param {*=} detail Detail value containing event-specific\n     *   payload.\n     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),\n     *     composed: (boolean|undefined) }=}\n     *  options Object specifying options.  These may include:\n     *  `bubbles` (boolean, defaults to `true`),\n     *  `cancelable` (boolean, defaults to false), and\n     *  `node` on which to fire the event (HTMLElement, defaults to `this`).\n     * @return {!Event} The new event that was fired.\n     * @override\n     */\n    fire(type, detail, options) {\n      options = options || {};\n      detail = (detail === null || detail === undefined) ? {} : detail;\n      let event = new Event(type, {\n        bubbles: options.bubbles === undefined ? true : options.bubbles,\n        cancelable: Boolean(options.cancelable),\n        composed: options.composed === undefined ? true: options.composed\n      });\n      event.detail = detail;\n      let node = options.node || this;\n      wrap(node).dispatchEvent(event);\n      return event;\n    }\n\n    /**\n     * Convenience method to add an event listener on a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to add event listener to.\n     * @param {string} eventName Name of event to listen for.\n     * @param {string} methodName Name of handler method on `this` to call.\n     * @return {void}\n     * @override\n     */\n    listen(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let hbl = this.__boundListeners ||\n        (this.__boundListeners = new WeakMap());\n      let bl = hbl.get(node);\n      if (!bl) {\n        bl = {};\n        hbl.set(node, bl);\n      }\n      let key = eventName + methodName;\n      if (!bl[key]) {\n        bl[key] = this._addMethodEventListenerToNode(\n            /** @type {!Node} */ (node), eventName, methodName, this);\n      }\n    }\n\n    /**\n     * Convenience method to remove an event listener from a given element,\n     * late bound to a named method on this element.\n     *\n     * @param {?EventTarget} node Element to remove event listener from.\n     * @param {string} eventName Name of event to stop listening to.\n     * @param {string} methodName Name of handler method on `this` to not call\n     anymore.\n     * @return {void}\n     * @override\n     */\n    unlisten(node, eventName, methodName) {\n      node = /** @type {!EventTarget} */ (node || this);\n      let bl = this.__boundListeners &&\n          this.__boundListeners.get(/** @type {!Element} */ (node));\n      let key = eventName + methodName;\n      let handler = bl && bl[key];\n      if (handler) {\n        this._removeEventListenerFromNode(\n            /** @type {!Node} */ (node), eventName, handler);\n        bl[key] = /** @type {?} */ (null);\n      }\n    }\n\n    /**\n     * Override scrolling behavior to all direction, one direction, or none.\n     *\n     * Valid scroll directions:\n     *   - 'all': scroll in any direction\n     *   - 'x': scroll only in the 'x' direction\n     *   - 'y': scroll only in the 'y' direction\n     *   - 'none': disable scrolling for this node\n     *\n     * @param {string=} direction Direction to allow scrolling\n     * Defaults to `all`.\n     * @param {Element=} node Element to apply scroll direction setting.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    setScrollDirection(direction, node) {\n      setTouchAction(\n          /** @type {!Element} */ (node || this),\n          DIRECTION_MAP[direction] || 'auto');\n    }\n    /* **** End Events **** */\n\n    /**\n     * Convenience method to run `querySelector` on this local DOM scope.\n     *\n     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.\n     *\n     * @param {string} slctr Selector to run on this local DOM scope\n     * @return {Element} Element found by the selector, or null if not found.\n     * @override\n     */\n    $$(slctr) {\n      // Note, no need to `wrap` this because root is always patched\n      return this.root.querySelector(slctr);\n    }\n\n    /**\n     * Return the element whose local dom within which this element\n     * is contained. This is a shorthand for\n     * `this.getRootNode().host`.\n     * @this {Element}\n     * @return {?Node} The element whose local dom within which this element is\n     * contained.\n     * @override\n     */\n    get domHost() {\n      let root = wrap(this).getRootNode();\n      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;\n    }\n\n    /**\n     * Force this element to distribute its children to its local dom.\n     * This should not be necessary as of Polymer 2.0.2 and is provided only\n     * for backwards compatibility.\n     * @return {void}\n     * @override\n     */\n    distributeContent() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */(dom(thisEl));\n      if (window.ShadyDOM && domApi.shadowRoot) {\n        ShadyDOM.flush();\n      }\n    }\n\n    /**\n     * Returns a list of nodes that are the effective childNodes. The effective\n     * childNodes list is the same as the element's childNodes except that\n     * any `<content>` elements are replaced with the list of nodes distributed\n     * to the `<content>`, the result of its `getDistributedNodes` method.\n     * @return {!Array<!Node>} List of effective child nodes.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getEffectiveChildNodes() {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.getEffectiveChildNodes();\n    }\n\n    /**\n     * Returns a list of nodes distributed within this element that match\n     * `selector`. These can be dom children or elements distributed to\n     * children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of distributed elements that match selector.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    queryDistributedElements(selector) {\n      const thisEl = /** @type {Element} */ (this);\n      const domApi = /** @type {PolymerDomApi} */ (dom(thisEl));\n      return domApi.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of elements that are the effective children. The effective\n     * children list is the same as the element's children except that\n     * any `<content>` elements are replaced with the list of elements\n     * distributed to the `<content>`.\n     *\n     * @return {!Array<!Node>} List of effective children.\n     * @override\n     */\n    getEffectiveChildren() {\n      let list = this.getEffectiveChildNodes();\n      return list.filter(function(/** @type {!Node} */ n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      });\n    }\n\n    /**\n     * Returns a string of text content that is the concatenation of the\n     * text content's of the element's effective childNodes (the elements\n     * returned by <a href=\"#getEffectiveChildNodes>getEffectiveChildNodes</a>.\n     *\n     * @return {string} List of effective children.\n     * @override\n     */\n    getEffectiveTextContent() {\n      let cn = this.getEffectiveChildNodes();\n      let tc = [];\n      for (let i=0, c; (c = cn[i]); i++) {\n        if (c.nodeType !== Node.COMMENT_NODE) {\n          tc.push(c.textContent);\n        }\n      }\n      return tc.join('');\n    }\n\n    /**\n     * Returns the first effective childNode within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {Node} First effective child node that matches selector.\n     * @override\n     */\n    queryEffectiveChildren(selector) {\n      let e$ = this.queryDistributedElements(selector);\n      return e$ && e$[0];\n    }\n\n    /**\n     * Returns a list of effective childNodes within this element that\n     * match `selector`. These can be dom child nodes or elements distributed\n     * to children that are insertion points.\n     * @param {string} selector Selector to run.\n     * @return {!Array<!Node>} List of effective child nodes that match\n     *     selector.\n     * @override\n     */\n    queryAllEffectiveChildren(selector) {\n      return this.queryDistributedElements(selector);\n    }\n\n    /**\n     * Returns a list of nodes distributed to this element's `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its local DOM,\n     * an optional selector may be passed to choose the desired content.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<slot>`.  Defaults to `content`.\n     * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.\n     * @override\n     */\n    getContentChildNodes(slctr) {\n      // Note, no need to `wrap` this because root is always\n      let content = this.root.querySelector(slctr || 'slot');\n      return content ?\n          /** @type {PolymerDomApi} */ (dom(content)).getDistributedNodes() :\n          [];\n    }\n\n    /**\n     * Returns a list of element children distributed to this element's\n     * `<slot>`.\n     *\n     * If this element contains more than one `<slot>` in its\n     * local DOM, an optional selector may be passed to choose the desired\n     * content.  This method differs from `getContentChildNodes` in that only\n     * elements are returned.\n     *\n     * @param {string=} slctr CSS selector to choose the desired\n     *   `<content>`.  Defaults to `content`.\n     * @return {!Array<!HTMLElement>} List of distributed nodes for the\n     *   `<slot>`.\n     * @suppress {invalidCasts}\n     * @override\n     */\n    getContentChildren(slctr) {\n      let children = /** @type {!Array<!HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {\n        return (n.nodeType === Node.ELEMENT_NODE);\n      }));\n      return children;\n    }\n\n    /**\n     * Checks whether an element is in this element's light DOM tree.\n     *\n     * @param {?Node} node The element to be checked.\n     * @return {boolean} true if node is in this element's light DOM tree.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     * HTMLElement\n     * @override\n     */\n    isLightDescendant(node) {\n      const thisNode = /** @type {Node} */ (this);\n      return thisNode !== node && wrap(thisNode).contains(node) &&\n        wrap(thisNode).getRootNode() === wrap(node).getRootNode();\n    }\n\n    /**\n     * Checks whether an element is in this element's local DOM tree.\n     *\n     * @param {!Element} node The element to be checked.\n     * @return {boolean} true if node is in this element's local DOM tree.\n     * @override\n     */\n    isLocalDescendant(node) {\n      return this.root === wrap(node).getRootNode();\n    }\n\n    /**\n     * No-op for backwards compatibility. This should now be handled by\n     * ShadyCss library.\n     * @param  {!Element} container Container element to scope\n     * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n     * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n     * @override\n     */\n    scopeSubtree(container, shouldObserve = false) {\n      return scopeSubtree(container, shouldObserve);\n    }\n\n    /**\n     * Returns the computed style value for the given property.\n     * @param {string} property The css property name.\n     * @return {string} Returns the computed css property value for the given\n     * `property`.\n     * @suppress {invalidCasts} LegacyElementMixin must be applied to an\n     *     HTMLElement\n     * @override\n     */\n    getComputedStyleValue(property) {\n      return styleInterface.getComputedStyleValue(/** @type {!Element} */(this), property);\n    }\n\n    // debounce\n\n    /**\n     * Call `debounce` to collapse multiple requests for a named task into\n     * one invocation which is made after the wait time has elapsed with\n     * no new request.  If no wait time is given, the callback will be called\n     * at microtask timing (guaranteed before paint).\n     *\n     *     debouncedClickAction(e) {\n     *       // will not call `processClick` more than once per 100ms\n     *       this.debounce('click', function() {\n     *        this.processClick();\n     *       } 100);\n     *     }\n     *\n     * @param {string} jobName String to identify the debounce job.\n     * @param {function():void} callback Function that is called (with `this`\n     *   context) when the wait time elapses.\n     * @param {number=} wait Optional wait time in milliseconds (ms) after the\n     *   last signal that must elapse before invoking `callback`\n     * @return {!Object} Returns a debouncer object on which exists the\n     * following methods: `isActive()` returns true if the debouncer is\n     * active; `cancel()` cancels the debouncer if it is active;\n     * `flush()` immediately invokes the debounced callback if the debouncer\n     * is active.\n     * @override\n     */\n    debounce(jobName, callback, wait) {\n      this._debouncers = this._debouncers || {};\n      return this._debouncers[jobName] = Debouncer.debounce(\n            this._debouncers[jobName]\n          , wait > 0 ? timeOut.after(wait) : microTask\n          , callback.bind(this));\n    }\n\n    /**\n     * Returns whether a named debouncer is active.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {boolean} Whether the debouncer is active (has not yet fired).\n     * @override\n     */\n    isDebouncerActive(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      return !!(debouncer && debouncer.isActive());\n    }\n\n    /**\n     * Immediately calls the debouncer `callback` and inactivates it.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    flushDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.flush();\n      }\n    }\n\n    /**\n     * Cancels an active debouncer.  The `callback` will not be called.\n     *\n     * @param {string} jobName The name of the debouncer started with `debounce`\n     * @return {void}\n     * @override\n     */\n    cancelDebouncer(jobName) {\n      this._debouncers = this._debouncers || {};\n      let debouncer = this._debouncers[jobName];\n      if (debouncer) {\n        debouncer.cancel();\n      }\n    }\n\n    /**\n     * Runs a callback function asynchronously.\n     *\n     * By default (if no waitTime is specified), async callbacks are run at\n     * microtask timing, which will occur before paint.\n     *\n     * @param {!Function} callback The callback function to run, bound to\n     *     `this`.\n     * @param {number=} waitTime Time to wait before calling the\n     *   `callback`.  If unspecified or 0, the callback will be run at microtask\n     *   timing (before paint).\n     * @return {number} Handle that may be used to cancel the async job.\n     * @override\n     */\n    async(callback, waitTime) {\n      return waitTime > 0 ? timeOut.run(callback.bind(this), waitTime) :\n          ~microTask.run(callback.bind(this));\n    }\n\n    /**\n     * Cancels an async operation started with `async`.\n     *\n     * @param {number} handle Handle returned from original `async` call to\n     *   cancel.\n     * @return {void}\n     * @override\n     */\n    cancelAsync(handle) {\n      handle < 0 ? microTask.cancel(~handle) :\n          timeOut.cancel(handle);\n    }\n\n    // other\n\n    /**\n     * Convenience method for creating an element and configuring it.\n     *\n     * @param {string} tag HTML element tag to create.\n     * @param {Object=} props Object of properties to configure on the\n     *    instance.\n     * @return {!Element} Newly created and configured element.\n     * @override\n     */\n    create(tag, props) {\n      let elt = document.createElement(tag);\n      if (props) {\n        if (elt.setProperties) {\n          elt.setProperties(props);\n        } else {\n          for (let n in props) {\n            elt[n] = props[n];\n          }\n        }\n      }\n      return elt;\n    }\n\n    /**\n     * Polyfill for Element.prototype.matches, which is sometimes still\n     * prefixed.\n     *\n     * @param {string} selector Selector to test.\n     * @param {!Element=} node Element to test the selector against.\n     * @return {boolean} Whether the element matches the selector.\n     * @override\n     */\n    elementMatches(selector, node) {\n      return matchesSelector( (node || this), selector);\n    }\n\n    /**\n     * Toggles an HTML attribute on or off.\n     *\n     * @param {string} name HTML attribute name\n     * @param {boolean=} bool Boolean to force the attribute on or off.\n     *    When unspecified, the state of the attribute will be reversed.\n     * @return {boolean} true if the attribute now exists\n     * @override\n     */\n    toggleAttribute(name, bool) {\n      let node = /** @type {Element} */(this);\n      if (arguments.length === 3) {\n        node = /** @type {Element} */(arguments[2]);\n      }\n      if (arguments.length == 1) {\n        bool = !node.hasAttribute(name);\n      }\n      if (bool) {\n        wrap(node).setAttribute(name, '');\n        return true;\n      } else {\n        wrap(node).removeAttribute(name);\n        return false;\n      }\n    }\n\n\n    /**\n     * Toggles a CSS class on or off.\n     *\n     * @param {string} name CSS class name\n     * @param {boolean=} bool Boolean to force the class on or off.\n     *    When unspecified, the state of the class will be reversed.\n     * @param {Element=} node Node to target.  Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    toggleClass(name, bool, node) {\n      node = /** @type {Element} */ (node || this);\n      if (arguments.length == 1) {\n        bool = !node.classList.contains(name);\n      }\n      if (bool) {\n        node.classList.add(name);\n      } else {\n        node.classList.remove(name);\n      }\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `transform` property.\n     *\n     * @param {string} transformText Transform setting.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`\n     * @return {void}\n     * @override\n     */\n    transform(transformText, node) {\n      node = /** @type {Element} */ (node || this);\n      node.style.webkitTransform = transformText;\n      node.style.transform = transformText;\n    }\n\n    /**\n     * Cross-platform helper for setting an element's CSS `translate3d`\n     * property.\n     *\n     * @param {number|string} x X offset.\n     * @param {number|string} y Y offset.\n     * @param {number|string} z Z offset.\n     * @param {Element=} node Element to apply the transform to.\n     * Defaults to `this`.\n     * @return {void}\n     * @override\n     */\n    translate3d(x, y, z, node) {\n      node = /** @type {Element} */ (node || this);\n      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n    }\n\n    /**\n     * Removes an item from an array, if it exists.\n     *\n     * If the array is specified by path, a change notification is\n     * generated, so that observers, data bindings and computed\n     * properties watching that path can update.\n     *\n     * If the array is passed directly, **no change\n     * notification is generated**.\n     *\n     * @param {string | !Array<number|string>} arrayOrPath Path to array from\n     *     which to remove the item\n     *   (or the array itself).\n     * @param {*} item Item to remove.\n     * @return {Array} Array containing item removed.\n     * @override\n     */\n    arrayDelete(arrayOrPath, item) {\n      let index;\n      if (Array.isArray(arrayOrPath)) {\n        index = arrayOrPath.indexOf(item);\n        if (index >= 0) {\n          return arrayOrPath.splice(index, 1);\n        }\n      } else {\n        let arr = get(this, arrayOrPath);\n        index = arr.indexOf(item);\n        if (index >= 0) {\n          return this.splice(arrayOrPath, index, 1);\n        }\n      }\n      return null;\n    }\n\n    // logging\n\n    /**\n     * Facades `console.log`/`warn`/`error` as override point.\n     *\n     * @param {string} level One of 'log', 'warn', 'error'\n     * @param {Array} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _logger(level, args) {\n      // accept ['foo', 'bar'] and [['foo', 'bar']]\n      if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {\n        args = args[0];\n      }\n      switch(level) {\n        case 'log':\n        case 'warn':\n        case 'error':\n          console[level](...args);\n      }\n    }\n\n    /**\n     * Facades `console.log` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _log(...args) {\n      this._logger('log', args);\n    }\n\n    /**\n     * Facades `console.warn` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _warn(...args) {\n      this._logger('warn', args);\n    }\n\n    /**\n     * Facades `console.error` as an override point.\n     *\n     * @param {...*} args Array of strings or objects to log\n     * @return {void}\n     * @override\n     */\n    _error(...args) {\n      this._logger('error', args);\n    }\n\n    /**\n     * Formats a message using the element type an a method name.\n     *\n     * @param {string} methodName Method name to associate with message\n     * @param {...*} args Array of strings or objects to log\n     * @return {!Array} Array with formatting information for `console`\n     *   logging.\n     * @override\n     */\n    _logf(methodName, ...args) {\n      return ['[%s::%s]', this.is, methodName, ...args];\n    }\n\n  }\n\n  LegacyElement.prototype.is = '';\n\n  return LegacyElement;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}