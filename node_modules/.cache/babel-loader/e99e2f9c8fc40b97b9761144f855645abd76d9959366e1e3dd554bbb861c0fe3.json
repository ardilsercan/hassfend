{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush as _flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nvar MAX_VIRTUAL_COUNT = 100000;\nvar OFFSET_ADJUST_MIN_THRESHOLD = 1000;\nexport var IronListAdapter = /*#__PURE__*/function () {\n  function IronListAdapter(_ref) {\n    var _this = this;\n    var createElements = _ref.createElements,\n      updateElement = _ref.updateElement,\n      scrollTarget = _ref.scrollTarget,\n      scrollContainer = _ref.scrollContainer,\n      elementsContainer = _ref.elementsContainer,\n      reorderElements = _ref.reorderElements;\n    _classCallCheck(this, IronListAdapter);\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100\n    };\n    this.__resizeObserver = new ResizeObserver(function () {\n      return _this._resizeHandler();\n    });\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', function () {\n      return _this._scrollHandler();\n    });\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', function (e) {\n      return _this.__onWheel(e);\n    });\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', function () {\n        _this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', function () {\n        _this.__mouseDown = false;\n        if (_this.__pendingReorder) {\n          _this.__reorderElements();\n        }\n      });\n    }\n  }\n  _createClass(IronListAdapter, [{\n    key: \"scrollOffset\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"adjustedFirstVisibleIndex\",\n    get: function get() {\n      return this.firstVisibleIndex + this._vidxOffset;\n    }\n  }, {\n    key: \"adjustedLastVisibleIndex\",\n    get: function get() {\n      return this.lastVisibleIndex + this._vidxOffset;\n    }\n  }, {\n    key: \"__hasPlaceholders\",\n    value: function __hasPlaceholders() {\n      return this.__getVisibleElements().some(function (el) {\n        return el.__virtualizerPlaceholder;\n      });\n    }\n  }, {\n    key: \"scrollToIndex\",\n    value: function scrollToIndex(index) {\n      if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n        return;\n      }\n      delete this.__pendingScrollToIndex;\n      if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\n        // The condition here is a performance improvement to avoid an unnecessary\n        // re-render when the physical item pool is already covered.\n\n        // Finish rendering at the current scroll position before scrolling\n        this.flush();\n      }\n      index = this._clamp(index, 0, this.size - 1);\n      var visibleElementCount = this.__getVisibleElements().length;\n      var targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);\n      if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n        targetVirtualIndex = this._virtualCount - (this.size - index);\n        this._vidxOffset = this.size - this._virtualCount;\n      } else if (targetVirtualIndex < visibleElementCount) {\n        if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n          targetVirtualIndex = index;\n          this._vidxOffset = 0;\n        } else {\n          targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n          this._vidxOffset = index - targetVirtualIndex;\n        }\n      } else {\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n      this.__skipNextVirtualIndexAdjust = true;\n      _get(_getPrototypeOf(IronListAdapter.prototype), \"scrollToIndex\", this).call(this, targetVirtualIndex);\n      if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n        // Workaround an iron-list issue by manually adjusting the scroll position\n        this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n      }\n      this._scrollHandler();\n      if (this.__hasPlaceholders()) {\n        // After rendering synchronously, there are still placeholders in the DOM.\n        // Try again after the next elements update.\n        this.__pendingScrollToIndex = index;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var startPhysicalCount = this._physicalCount;\n      // The scroll target is hidden.\n      if (this.scrollTarget.offsetHeight === 0) {\n        return;\n      }\n      this._resizeHandler();\n      _flush();\n      this._scrollHandler();\n      if (this.__fixInvalidItemPositioningDebouncer) {\n        this.__fixInvalidItemPositioningDebouncer.flush();\n      }\n      if (this.__scrollReorderDebouncer) {\n        this.__scrollReorderDebouncer.flush();\n      }\n      if (this.__debouncerWheelAnimationFrame) {\n        this.__debouncerWheelAnimationFrame.flush();\n      }\n      if (this._physicalCount !== startPhysicalCount) {\n        // Flushing again until physical count stabilizes fixes https://github.com/vaadin/flow-components/issues/5595#issuecomment-1770278913\n        this.flush();\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this2 = this;\n      var startIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var endIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size - 1;\n      var updatedElements = [];\n      this.__getVisibleElements().forEach(function (el) {\n        if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n          _this2.__updateElement(el, el.__virtualIndex, true);\n          updatedElements.push(el);\n        }\n      });\n      this.__afterElementsUpdated(updatedElements);\n    }\n\n    /**\n     * Updates the height for a given set of items.\n     *\n     * @param {!Array<number>=} itemSet\n     */\n  }, {\n    key: \"_updateMetrics\",\n    value: function _updateMetrics(itemSet) {\n      var _this3 = this;\n      // Make sure we distributed all the physical items\n      // so we can measure them.\n      _flush();\n      var newPhysicalSize = 0;\n      var oldPhysicalSize = 0;\n      var prevAvgCount = this._physicalAverageCount;\n      var prevPhysicalAvg = this._physicalAverage;\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      this._iterateItems(function (pidx, vidx) {\n        oldPhysicalSize += _this3._physicalSizes[pidx];\n        _this3._physicalSizes[pidx] = Math.ceil(_this3.__getBorderBoxHeight(_this3._physicalItems[pidx]));\n        newPhysicalSize += _this3._physicalSizes[pidx];\n        _this3._physicalAverageCount += _this3._physicalSizes[pidx] ? 1 : 0;\n      }, itemSet);\n      this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n      // Update the average if it measured something.\n      if (this._physicalAverageCount !== prevAvgCount) {\n        this._physicalAverage = Math.round((prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount);\n      }\n    }\n  }, {\n    key: \"__getBorderBoxHeight\",\n    value: function __getBorderBoxHeight(el) {\n      var style = getComputedStyle(el);\n      var itemHeight = parseFloat(style.height) || 0;\n      if (style.boxSizing === 'border-box') {\n        return itemHeight;\n      }\n      var paddingBottom = parseFloat(style.paddingBottom) || 0;\n      var paddingTop = parseFloat(style.paddingTop) || 0;\n      var borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n      var borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n      return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n    }\n  }, {\n    key: \"__updateElement\",\n    value: function __updateElement(el, index, forceSameIndexUpdates) {\n      // Clean up temporary placeholder sizing\n      if (el.__virtualizerPlaceholder) {\n        el.style.paddingTop = '';\n        el.__virtualizerPlaceholder = false;\n      }\n      if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n        this.updateElement(el, index);\n        el.__lastUpdatedIndex = index;\n      }\n    }\n\n    /**\n     * Called synchronously right after elements have been updated.\n     * This is a good place to do any post-update work.\n     *\n     * @param {!Array<!HTMLElement>} updatedElements\n     */\n  }, {\n    key: \"__afterElementsUpdated\",\n    value: function __afterElementsUpdated(updatedElements) {\n      var _this4 = this;\n      updatedElements.forEach(function (el) {\n        var elementHeight = el.offsetHeight;\n        if (elementHeight === 0) {\n          // If the elements have 0 height after update (for example due to lazy rendering),\n          // it results in iron-list requesting to create an unlimited count of elements.\n          // Assign a temporary placeholder sizing to elements that would otherwise end up having\n          // no height.\n          el.style.paddingTop = \"\".concat(_this4.__placeholderHeight, \"px\");\n          el.__virtualizerPlaceholder = true;\n\n          // Manually schedule the resize handler to make sure the placeholder padding is\n          // cleared in case the resize observer never triggers.\n          _this4.__placeholderClearDebouncer = Debouncer.debounce(_this4.__placeholderClearDebouncer, animationFrame, function () {\n            return _this4._resizeHandler();\n          });\n        } else {\n          // Add element height to the queue\n          _this4.__elementHeightQueue.push(elementHeight);\n          _this4.__elementHeightQueue.shift();\n\n          // Calculate new placeholder height based on the average of the defined values in the\n          // element height queue\n          var filteredHeights = _this4.__elementHeightQueue.filter(function (h) {\n            return h !== undefined;\n          });\n          _this4.__placeholderHeight = Math.round(filteredHeights.reduce(function (a, b) {\n            return a + b;\n          }, 0) / filteredHeights.length);\n        }\n      });\n      if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\n        this.scrollToIndex(this.__pendingScrollToIndex);\n      }\n    }\n  }, {\n    key: \"__getIndexScrollOffset\",\n    value: function __getIndexScrollOffset(index) {\n      var element = this.__getVisibleElements().find(function (el) {\n        return el.__virtualIndex === index;\n      });\n      return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.__size;\n    },\n    set: function set(size) {\n      var _this5 = this;\n      if (size === this.size) {\n        return;\n      }\n      // Cancel active debouncers\n      if (this.__fixInvalidItemPositioningDebouncer) {\n        this.__fixInvalidItemPositioningDebouncer.cancel();\n      }\n      if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n        // Avoid creating unnecessary elements on the following flush()\n        this._debouncers._increasePoolIfNeeded.cancel();\n      }\n\n      // Change the size\n      this.__size = size;\n      if (!this._physicalItems) {\n        // Not initialized yet\n        this._itemsChanged({\n          path: 'items'\n        });\n        this.__preventElementUpdates = true;\n        _flush();\n        this.__preventElementUpdates = false;\n      } else {\n        // Already initialized, just update _virtualCount\n        this._updateScrollerSize();\n        this._virtualCount = this.items.length;\n        this._render();\n      }\n\n      // When reducing size while invisible, iron-list does not update items, so\n      // their hidden state is not updated and their __lastUpdatedIndex is not\n      // reset. In that case force an update here.\n      if (!this._isVisible) {\n        this._assignModels();\n      }\n      if (!this.elementsContainer.children.length) {\n        requestAnimationFrame(function () {\n          return _this5._resizeHandler();\n        });\n      }\n\n      // Schedule and flush a resize handler. This will cause a\n      // re-render for the elements.\n      this._resizeHandler();\n      _flush();\n    }\n\n    /** @private */\n  }, {\n    key: \"_scrollTop\",\n    get: function get() {\n      return this.scrollTarget.scrollTop;\n    }\n\n    /** @private */,\n    set: function set(top) {\n      this.scrollTarget.scrollTop = top;\n    }\n\n    /** @private */\n  }, {\n    key: \"items\",\n    get: function get() {\n      return {\n        length: Math.min(this.size, MAX_VIRTUAL_COUNT)\n      };\n    }\n\n    /** @private */\n  }, {\n    key: \"offsetHeight\",\n    get: function get() {\n      return this.scrollTarget.offsetHeight;\n    }\n\n    /** @private */\n  }, {\n    key: \"$\",\n    get: function get() {\n      return {\n        items: this.scrollContainer\n      };\n    }\n\n    /** @private */\n  }, {\n    key: \"updateViewportBoundaries\",\n    value: function updateViewportBoundaries() {\n      var styles = window.getComputedStyle(this.scrollTarget);\n      this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n      this._isRTL = Boolean(styles.direction === 'rtl');\n      this._viewportWidth = this.elementsContainer.offsetWidth;\n      this._viewportHeight = this.scrollTarget.offsetHeight;\n      this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n      if (this.grid) {\n        this._updateGridMetrics();\n      }\n    }\n\n    /** @private */\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute() {}\n\n    /** @private */\n  }, {\n    key: \"_createPool\",\n    value: function _createPool(size) {\n      var _this6 = this;\n      var physicalItems = this.createElements(size);\n      var fragment = document.createDocumentFragment();\n      physicalItems.forEach(function (el) {\n        el.style.position = 'absolute';\n        fragment.appendChild(el);\n        _this6.__resizeObserver.observe(el);\n      });\n      this.elementsContainer.appendChild(fragment);\n      return physicalItems;\n    }\n\n    /** @private */\n  }, {\n    key: \"_assignModels\",\n    value: function _assignModels(itemSet) {\n      var _this7 = this;\n      var updatedElements = [];\n      this._iterateItems(function (pidx, vidx) {\n        var el = _this7._physicalItems[pidx];\n        el.hidden = vidx >= _this7.size;\n        if (!el.hidden) {\n          el.__virtualIndex = vidx + (_this7._vidxOffset || 0);\n          _this7.__updateElement(el, el.__virtualIndex);\n          updatedElements.push(el);\n        } else {\n          delete el.__lastUpdatedIndex;\n        }\n      }, itemSet);\n      this.__afterElementsUpdated(updatedElements);\n    }\n\n    /** @private */\n  }, {\n    key: \"_isClientFull\",\n    value: function _isClientFull() {\n      var _this8 = this;\n      // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n      setTimeout(function () {\n        _this8.__clientFull = true;\n      });\n      return this.__clientFull || _get(_getPrototypeOf(IronListAdapter.prototype), \"_isClientFull\", this).call(this);\n    }\n\n    /** @private */\n  }, {\n    key: \"translate3d\",\n    value: function translate3d(_x, y, _z, el) {\n      el.style.transform = \"translateY(\".concat(y, \")\");\n    }\n\n    /** @private */\n  }, {\n    key: \"toggleScrollListener\",\n    value: function toggleScrollListener() {}\n  }, {\n    key: \"_scrollHandler\",\n    value: function _scrollHandler() {\n      var _this9 = this;\n      // The scroll target is hidden.\n      if (this.scrollTarget.offsetHeight === 0) {\n        return;\n      }\n      this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n      var delta = this.scrollTarget.scrollTop - this._scrollPosition;\n      _get(_getPrototypeOf(IronListAdapter.prototype), \"_scrollHandler\", this).call(this);\n      if (this._physicalCount !== 0) {\n        var isScrollingDown = delta >= 0;\n        var reusables = this._getReusables(!isScrollingDown);\n        if (reusables.indexes.length) {\n          // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n          // See https://github.com/vaadin/web-components/issues/1691\n          this._physicalTop = reusables.physicalTop;\n          if (isScrollingDown) {\n            this._virtualStart -= reusables.indexes.length;\n            this._physicalStart -= reusables.indexes.length;\n          } else {\n            this._virtualStart += reusables.indexes.length;\n            this._physicalStart += reusables.indexes.length;\n          }\n          this._resizeHandler();\n        }\n      }\n      if (delta) {\n        // There was a change in scroll top. Schedule a check for invalid item positioning.\n        this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(this.__fixInvalidItemPositioningDebouncer, timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING), function () {\n          return _this9.__fixInvalidItemPositioning();\n        });\n      }\n      if (this.reorderElements) {\n        this.__scrollReorderDebouncer = Debouncer.debounce(this.__scrollReorderDebouncer, timeOut.after(this.timeouts.SCROLL_REORDER), function () {\n          return _this9.__reorderElements();\n        });\n      }\n      this.__previousScrollTop = this._scrollTop;\n\n      // If the first visible index is not 0 when scrolled to the top,\n      // scroll to index 0 to fix the issue.\n      if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n        this.scrollToIndex(0);\n      }\n    }\n\n    /**\n     * Work around an iron-list issue with invalid item positioning.\n     * See https://github.com/vaadin/flow-components/issues/4306\n     * @private\n     */\n  }, {\n    key: \"__fixInvalidItemPositioning\",\n    value: function __fixInvalidItemPositioning() {\n      if (!this.scrollTarget.isConnected) {\n        return;\n      }\n\n      // Check if the first physical item element is below the top of the viewport\n      var physicalTopBelowTop = this._physicalTop > this._scrollTop;\n      // Check if the last physical item element is above the bottom of the viewport\n      var physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n      // Check if the first index is visible\n      var firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n      // Check if the last index is visible\n      var lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n      if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {\n        // Invalid state! Try to recover.\n\n        var isScrollingDown = physicalBottomAboveBottom;\n        // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n        // place all the free physical items on one side of the viewport.\n        var originalRatio = this._ratio;\n        this._ratio = 0;\n        // Fake a scroll change to make _scrollHandler place the physical items\n        // on the desired side.\n        this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n        this._scrollHandler();\n        // Restore the original \"_ratio\" value.\n        this._ratio = originalRatio;\n      }\n    }\n\n    /** @private */\n  }, {\n    key: \"__onWheel\",\n    value: function __onWheel(e) {\n      var _this10 = this;\n      if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n        return;\n      }\n      var deltaY = e.deltaY;\n      if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        // Scrolling by \"lines of text\" instead of pixels\n        deltaY *= this._scrollLineHeight;\n      } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n        // Scrolling by \"pages\" instead of pixels\n        deltaY *= this._scrollPageHeight;\n      }\n      if (!this._deltaYAcc) {\n        this._deltaYAcc = 0;\n      }\n      if (this._wheelAnimationFrame) {\n        // Accumulate wheel delta while a frame is being processed\n        this._deltaYAcc += deltaY;\n        e.preventDefault();\n        return;\n      }\n      deltaY += this._deltaYAcc;\n      this._deltaYAcc = 0;\n      this._wheelAnimationFrame = true;\n      this.__debouncerWheelAnimationFrame = Debouncer.debounce(this.__debouncerWheelAnimationFrame, animationFrame, function () {\n        _this10._wheelAnimationFrame = false;\n      });\n      var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n      if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n        e.preventDefault();\n        this.scrollTarget.scrollTop += deltaY;\n        this.scrollTarget.scrollLeft += e.deltaX;\n        this._hasResidualMomentum = true;\n        this._ignoreNewWheel = true;\n        this._debouncerIgnoreNewWheel = Debouncer.debounce(this._debouncerIgnoreNewWheel, timeOut.after(this.timeouts.IGNORE_WHEEL), function () {\n          _this10._ignoreNewWheel = false;\n        });\n      } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {\n        e.preventDefault();\n      } else if (momentum > this._previousMomentum) {\n        this._hasResidualMomentum = false;\n      }\n      this._previousMomentum = momentum;\n    }\n\n    /**\n     * Determines if the element has an ancestor that handles the scroll delta prior to this\n     *\n     * @private\n     */\n  }, {\n    key: \"_hasScrolledAncestor\",\n    value: function _hasScrolledAncestor(el, deltaX, deltaY) {\n      if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n        return false;\n      } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {\n        return true;\n      } else if (el !== this && el.parentElement) {\n        return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n      }\n    }\n  }, {\n    key: \"_canScroll\",\n    value: function _canScroll(el, deltaX, deltaY) {\n      return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;\n    }\n\n    /**\n     * Increases the pool size.\n     * @override\n     */\n  }, {\n    key: \"_increasePoolIfNeeded\",\n    value: function _increasePoolIfNeeded(count) {\n      if (this._physicalCount > 2 && count) {\n        // The iron-list logic has already created some physical items and\n        // has decided to create more. Since each item creation round is\n        // expensive, let's try to create the remaining items in one go.\n\n        // Calculate the total item count that would be needed to fill the viewport\n        // plus the buffer assuming rest of the items to be of the average size\n        // of the items already created.\n        var totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n        var missingItemCount = totalItemCount - this._physicalCount;\n        // Create the remaining items in one go. Use a maximum of 100 items\n        // as a safety measure.\n        _get(_getPrototypeOf(IronListAdapter.prototype), \"_increasePoolIfNeeded\", this).call(this, Math.max(count, Math.min(100, missingItemCount)));\n      } else {\n        _get(_getPrototypeOf(IronListAdapter.prototype), \"_increasePoolIfNeeded\", this).call(this, count);\n      }\n    }\n\n    /**\n     * @returns {Number|undefined} - The browser's default font-size in pixels\n     * @private\n     */\n  }, {\n    key: \"_getScrollLineHeight\",\n    value: function _getScrollLineHeight() {\n      var el = document.createElement('div');\n      el.style.fontSize = 'initial';\n      el.style.display = 'none';\n      document.body.appendChild(el);\n      var fontSize = window.getComputedStyle(el).fontSize;\n      document.body.removeChild(el);\n      return fontSize ? window.parseInt(fontSize) : undefined;\n    }\n  }, {\n    key: \"__getVisibleElements\",\n    value: function __getVisibleElements() {\n      return Array.from(this.elementsContainer.children).filter(function (element) {\n        return !element.hidden;\n      });\n    }\n\n    /** @private */\n  }, {\n    key: \"__reorderElements\",\n    value: function __reorderElements() {\n      var _this11 = this;\n      if (this.__mouseDown) {\n        this.__pendingReorder = true;\n        return;\n      }\n      this.__pendingReorder = false;\n      var adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n      // Which row to use as a target?\n      var visibleElements = this.__getVisibleElements();\n      var elementWithFocus = visibleElements.find(function (element) {\n        return element.contains(_this11.elementsContainer.getRootNode().activeElement) || element.contains(_this11.scrollTarget.getRootNode().activeElement);\n      });\n      var targetElement = elementWithFocus || visibleElements[0];\n      if (!targetElement) {\n        // All elements are hidden, don't reorder\n        return;\n      }\n\n      // Where the target row should be?\n      var targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n      // Reodrer the DOM elements to keep the target row at the target physical index\n      var delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n      if (delta > 0) {\n        for (var i = 0; i < delta; i++) {\n          this.elementsContainer.appendChild(visibleElements[i]);\n        }\n      } else if (delta < 0) {\n        for (var _i = visibleElements.length + delta; _i < visibleElements.length; _i++) {\n          this.elementsContainer.insertBefore(visibleElements[_i], visibleElements[0]);\n        }\n      }\n\n      // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n      // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n      // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n      if (isSafari) {\n        var transform = this.scrollTarget.style.transform;\n        this.scrollTarget.style.transform = 'translateZ(0)';\n        setTimeout(function () {\n          _this11.scrollTarget.style.transform = transform;\n        });\n      }\n    }\n\n    /** @private */\n  }, {\n    key: \"_adjustVirtualIndexOffset\",\n    value: function _adjustVirtualIndexOffset(delta) {\n      if (this._virtualCount >= this.size) {\n        this._vidxOffset = 0;\n      } else if (this.__skipNextVirtualIndexAdjust) {\n        this.__skipNextVirtualIndexAdjust = false;\n      } else if (Math.abs(delta) > 10000) {\n        // Process a large scroll position change\n        var scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n        var offset = scale * this.size;\n        this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n      } else {\n        // Make sure user can always swipe/wheel scroll to the start and end\n        var oldOffset = this._vidxOffset;\n        var threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n        var maxShift = 100;\n\n        // Near start\n        if (this._scrollTop === 0) {\n          this._vidxOffset = 0;\n          if (oldOffset !== this._vidxOffset) {\n            _get(_getPrototypeOf(IronListAdapter.prototype), \"scrollToIndex\", this).call(this, 0);\n          }\n        } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n          this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n          _get(_getPrototypeOf(IronListAdapter.prototype), \"scrollToIndex\", this).call(this, this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n        }\n\n        // Near end\n        var maxOffset = this.size - this._virtualCount;\n        if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n          this._vidxOffset = maxOffset;\n          if (oldOffset !== this._vidxOffset) {\n            _get(_getPrototypeOf(IronListAdapter.prototype), \"scrollToIndex\", this).call(this, this._virtualCount - 1);\n          }\n        } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n          this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n          _get(_getPrototypeOf(IronListAdapter.prototype), \"scrollToIndex\", this).call(this, this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n        }\n      }\n    }\n  }]);\n  return IronListAdapter;\n}();\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);","map":{"version":3,"names":["animationFrame","timeOut","isSafari","Debouncer","flush","ironList","MAX_VIRTUAL_COUNT","OFFSET_ADJUST_MIN_THRESHOLD","IronListAdapter","_ref","_this","createElements","updateElement","scrollTarget","scrollContainer","elementsContainer","reorderElements","_classCallCheck","isAttached","_vidxOffset","_maxPages","__placeholderHeight","__elementHeightQueue","Array","timeouts","SCROLL_REORDER","IGNORE_WHEEL","FIX_INVALID_ITEM_POSITIONING","__resizeObserver","ResizeObserver","_resizeHandler","getComputedStyle","overflow","style","position","observe","addEventListener","_scrollHandler","_scrollLineHeight","_getScrollLineHeight","e","__onWheel","__mouseDown","__pendingReorder","__reorderElements","_createClass","key","get","firstVisibleIndex","lastVisibleIndex","value","__hasPlaceholders","__getVisibleElements","some","el","__virtualizerPlaceholder","scrollToIndex","index","isNaN","size","offsetHeight","__pendingScrollToIndex","_physicalCount","_clamp","visibleElementCount","length","targetVirtualIndex","Math","floor","_virtualCount","__skipNextVirtualIndexAdjust","_get","_getPrototypeOf","prototype","call","adjustedFirstVisibleIndex","_scrollTop","_maxScrollTop","grid","__getIndexScrollOffset","startPhysicalCount","__fixInvalidItemPositioningDebouncer","__scrollReorderDebouncer","__debouncerWheelAnimationFrame","update","_this2","startIndex","arguments","undefined","endIndex","updatedElements","forEach","__virtualIndex","__updateElement","push","__afterElementsUpdated","_updateMetrics","itemSet","_this3","newPhysicalSize","oldPhysicalSize","prevAvgCount","_physicalAverageCount","prevPhysicalAvg","_physicalAverage","_iterateItems","pidx","vidx","_physicalSizes","ceil","__getBorderBoxHeight","_physicalItems","_physicalSize","round","itemHeight","parseFloat","height","boxSizing","paddingBottom","paddingTop","borderBottomWidth","borderTopWidth","forceSameIndexUpdates","__preventElementUpdates","__lastUpdatedIndex","_this4","elementHeight","concat","__placeholderClearDebouncer","debounce","shift","filteredHeights","filter","h","reduce","a","b","element","find","getBoundingClientRect","top","__size","set","_this5","cancel","_debouncers","_increasePoolIfNeeded","_itemsChanged","path","_updateScrollerSize","items","_render","_isVisible","_assignModels","children","requestAnimationFrame","scrollTop","min","updateViewportBoundaries","styles","window","_scrollerPaddingTop","parseInt","_isRTL","Boolean","direction","_viewportWidth","offsetWidth","_viewportHeight","_scrollPageHeight","_updateGridMetrics","setAttribute","_createPool","_this6","physicalItems","fragment","document","createDocumentFragment","appendChild","_this7","hidden","_isClientFull","_this8","setTimeout","__clientFull","translate3d","_x","y","_z","transform","toggleScrollListener","_this9","_adjustVirtualIndexOffset","__previousScrollTop","delta","_scrollPosition","isScrollingDown","reusables","_getReusables","indexes","_physicalTop","physicalTop","_virtualStart","_physicalStart","after","__fixInvalidItemPositioning","abs","isConnected","physicalTopBelowTop","physicalBottomAboveBottom","_physicalBottom","_scrollBottom","firstIndexVisible","lastIndexVisible","adjustedLastVisibleIndex","originalRatio","_ratio","_this10","ctrlKey","_hasScrolledAncestor","target","deltaX","deltaY","deltaMode","WheelEvent","DOM_DELTA_LINE","DOM_DELTA_PAGE","_deltaYAcc","_wheelAnimationFrame","preventDefault","momentum","_canScroll","scrollLeft","_hasResidualMomentum","_ignoreNewWheel","_debouncerIgnoreNewWheel","_previousMomentum","getRootNode","host","indexOf","parentElement","scrollHeight","scrollWidth","count","totalItemCount","_optPhysicalSize","missingItemCount","max","createElement","fontSize","display","body","removeChild","from","_this11","adjustedVirtualStart","visibleElements","elementWithFocus","contains","activeElement","targetElement","targetPhysicalIndex","i","insertBefore","scale","offset","oldOffset","threshold","maxShift","maxOffset","Object","setPrototypeOf"],"sources":["/workspaces/frontend/node_modules/@vaadin/component-base/src/virtualizer-iron-list-adapter.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2021 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\n/* eslint-disable @typescript-eslint/member-ordering */\n// https://github.com/vaadin/eslint-config-vaadin/issues/33\nimport { animationFrame, timeOut } from './async.js';\nimport { isSafari } from './browser-utils.js';\nimport { Debouncer, flush } from './debounce.js';\nimport { ironList } from './iron-list-core.js';\n\n// Iron-list can by default handle sizes up to around 100000.\n// When the size is larger than MAX_VIRTUAL_COUNT _vidxOffset is used\nconst MAX_VIRTUAL_COUNT = 100000;\nconst OFFSET_ADJUST_MIN_THRESHOLD = 1000;\n\nexport class IronListAdapter {\n  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {\n    this.isAttached = true;\n    this._vidxOffset = 0;\n    this.createElements = createElements;\n    this.updateElement = updateElement;\n    this.scrollTarget = scrollTarget;\n    this.scrollContainer = scrollContainer;\n    this.elementsContainer = elementsContainer || scrollContainer;\n    this.reorderElements = reorderElements;\n    // Iron-list uses this value to determine how many pages of elements to render\n    this._maxPages = 1.3;\n\n    // Placeholder height (used for sizing elements that have intrinsic 0 height after update)\n    this.__placeholderHeight = 200;\n    // A queue of 10 previous element heights\n    this.__elementHeightQueue = Array(10);\n\n    this.timeouts = {\n      SCROLL_REORDER: 500,\n      IGNORE_WHEEL: 500,\n      FIX_INVALID_ITEM_POSITIONING: 100,\n    };\n\n    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());\n\n    if (getComputedStyle(this.scrollTarget).overflow === 'visible') {\n      this.scrollTarget.style.overflow = 'auto';\n    }\n\n    if (getComputedStyle(this.scrollContainer).position === 'static') {\n      this.scrollContainer.style.position = 'relative';\n    }\n\n    this.__resizeObserver.observe(this.scrollTarget);\n    this.scrollTarget.addEventListener('scroll', () => this._scrollHandler());\n\n    this._scrollLineHeight = this._getScrollLineHeight();\n    this.scrollTarget.addEventListener('wheel', (e) => this.__onWheel(e));\n\n    if (this.reorderElements) {\n      // Reordering the physical elements cancels the user's grab of the scroll bar handle on Safari.\n      // Need to defer reordering until the user lets go of the scroll bar handle.\n      this.scrollTarget.addEventListener('mousedown', () => {\n        this.__mouseDown = true;\n      });\n      this.scrollTarget.addEventListener('mouseup', () => {\n        this.__mouseDown = false;\n        if (this.__pendingReorder) {\n          this.__reorderElements();\n        }\n      });\n    }\n  }\n\n  get scrollOffset() {\n    return 0;\n  }\n\n  get adjustedFirstVisibleIndex() {\n    return this.firstVisibleIndex + this._vidxOffset;\n  }\n\n  get adjustedLastVisibleIndex() {\n    return this.lastVisibleIndex + this._vidxOffset;\n  }\n\n  __hasPlaceholders() {\n    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);\n  }\n\n  scrollToIndex(index) {\n    if (typeof index !== 'number' || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {\n      return;\n    }\n    delete this.__pendingScrollToIndex;\n\n    if (this._physicalCount <= 3 /* iron-list-core.DEFAULT_PHYSICAL_COUNT */) {\n      // The condition here is a performance improvement to avoid an unnecessary\n      // re-render when the physical item pool is already covered.\n\n      // Finish rendering at the current scroll position before scrolling\n      this.flush();\n    }\n\n    index = this._clamp(index, 0, this.size - 1);\n\n    const visibleElementCount = this.__getVisibleElements().length;\n    let targetVirtualIndex = Math.floor((index / this.size) * this._virtualCount);\n    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {\n      targetVirtualIndex = this._virtualCount - (this.size - index);\n      this._vidxOffset = this.size - this._virtualCount;\n    } else if (targetVirtualIndex < visibleElementCount) {\n      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {\n        targetVirtualIndex = index;\n        this._vidxOffset = 0;\n      } else {\n        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;\n        this._vidxOffset = index - targetVirtualIndex;\n      }\n    } else {\n      this._vidxOffset = index - targetVirtualIndex;\n    }\n\n    this.__skipNextVirtualIndexAdjust = true;\n    super.scrollToIndex(targetVirtualIndex);\n\n    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {\n      // Workaround an iron-list issue by manually adjusting the scroll position\n      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;\n    }\n    this._scrollHandler();\n\n    if (this.__hasPlaceholders()) {\n      // After rendering synchronously, there are still placeholders in the DOM.\n      // Try again after the next elements update.\n      this.__pendingScrollToIndex = index;\n    }\n  }\n\n  flush() {\n    const startPhysicalCount = this._physicalCount;\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._resizeHandler();\n    flush();\n    this._scrollHandler();\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.flush();\n    }\n    if (this.__scrollReorderDebouncer) {\n      this.__scrollReorderDebouncer.flush();\n    }\n    if (this.__debouncerWheelAnimationFrame) {\n      this.__debouncerWheelAnimationFrame.flush();\n    }\n\n    if (this._physicalCount !== startPhysicalCount) {\n      // Flushing again until physical count stabilizes fixes https://github.com/vaadin/flow-components/issues/5595#issuecomment-1770278913\n      this.flush();\n    }\n  }\n\n  update(startIndex = 0, endIndex = this.size - 1) {\n    const updatedElements = [];\n    this.__getVisibleElements().forEach((el) => {\n      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {\n        this.__updateElement(el, el.__virtualIndex, true);\n        updatedElements.push(el);\n      }\n    });\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /**\n   * Updates the height for a given set of items.\n   *\n   * @param {!Array<number>=} itemSet\n   */\n  _updateMetrics(itemSet) {\n    // Make sure we distributed all the physical items\n    // so we can measure them.\n    flush();\n\n    let newPhysicalSize = 0;\n    let oldPhysicalSize = 0;\n    const prevAvgCount = this._physicalAverageCount;\n    const prevPhysicalAvg = this._physicalAverage;\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._iterateItems((pidx, vidx) => {\n      oldPhysicalSize += this._physicalSizes[pidx];\n      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));\n      newPhysicalSize += this._physicalSizes[pidx];\n      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;\n    }, itemSet);\n\n    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;\n\n    // Update the average if it measured something.\n    if (this._physicalAverageCount !== prevAvgCount) {\n      this._physicalAverage = Math.round(\n        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount,\n      );\n    }\n  }\n\n  __getBorderBoxHeight(el) {\n    const style = getComputedStyle(el);\n\n    const itemHeight = parseFloat(style.height) || 0;\n\n    if (style.boxSizing === 'border-box') {\n      return itemHeight;\n    }\n\n    const paddingBottom = parseFloat(style.paddingBottom) || 0;\n    const paddingTop = parseFloat(style.paddingTop) || 0;\n    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;\n    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;\n\n    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;\n  }\n\n  __updateElement(el, index, forceSameIndexUpdates) {\n    // Clean up temporary placeholder sizing\n    if (el.__virtualizerPlaceholder) {\n      el.style.paddingTop = '';\n      el.__virtualizerPlaceholder = false;\n    }\n\n    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {\n      this.updateElement(el, index);\n      el.__lastUpdatedIndex = index;\n    }\n  }\n\n  /**\n   * Called synchronously right after elements have been updated.\n   * This is a good place to do any post-update work.\n   *\n   * @param {!Array<!HTMLElement>} updatedElements\n   */\n  __afterElementsUpdated(updatedElements) {\n    updatedElements.forEach((el) => {\n      const elementHeight = el.offsetHeight;\n      if (elementHeight === 0) {\n        // If the elements have 0 height after update (for example due to lazy rendering),\n        // it results in iron-list requesting to create an unlimited count of elements.\n        // Assign a temporary placeholder sizing to elements that would otherwise end up having\n        // no height.\n        el.style.paddingTop = `${this.__placeholderHeight}px`;\n        el.__virtualizerPlaceholder = true;\n\n        // Manually schedule the resize handler to make sure the placeholder padding is\n        // cleared in case the resize observer never triggers.\n        this.__placeholderClearDebouncer = Debouncer.debounce(this.__placeholderClearDebouncer, animationFrame, () =>\n          this._resizeHandler(),\n        );\n      } else {\n        // Add element height to the queue\n        this.__elementHeightQueue.push(elementHeight);\n        this.__elementHeightQueue.shift();\n\n        // Calculate new placeholder height based on the average of the defined values in the\n        // element height queue\n        const filteredHeights = this.__elementHeightQueue.filter((h) => h !== undefined);\n        this.__placeholderHeight = Math.round(filteredHeights.reduce((a, b) => a + b, 0) / filteredHeights.length);\n      }\n    });\n\n    if (this.__pendingScrollToIndex !== undefined && !this.__hasPlaceholders()) {\n      this.scrollToIndex(this.__pendingScrollToIndex);\n    }\n  }\n\n  __getIndexScrollOffset(index) {\n    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);\n    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : undefined;\n  }\n\n  get size() {\n    return this.__size;\n  }\n\n  set size(size) {\n    if (size === this.size) {\n      return;\n    }\n    // Cancel active debouncers\n    if (this.__fixInvalidItemPositioningDebouncer) {\n      this.__fixInvalidItemPositioningDebouncer.cancel();\n    }\n    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {\n      // Avoid creating unnecessary elements on the following flush()\n      this._debouncers._increasePoolIfNeeded.cancel();\n    }\n\n    // Change the size\n    this.__size = size;\n\n    if (!this._physicalItems) {\n      // Not initialized yet\n      this._itemsChanged({\n        path: 'items',\n      });\n      this.__preventElementUpdates = true;\n      flush();\n      this.__preventElementUpdates = false;\n    } else {\n      // Already initialized, just update _virtualCount\n      this._updateScrollerSize();\n      this._virtualCount = this.items.length;\n      this._render();\n    }\n\n    // When reducing size while invisible, iron-list does not update items, so\n    // their hidden state is not updated and their __lastUpdatedIndex is not\n    // reset. In that case force an update here.\n    if (!this._isVisible) {\n      this._assignModels();\n    }\n\n    if (!this.elementsContainer.children.length) {\n      requestAnimationFrame(() => this._resizeHandler());\n    }\n\n    // Schedule and flush a resize handler. This will cause a\n    // re-render for the elements.\n    this._resizeHandler();\n    flush();\n  }\n\n  /** @private */\n  get _scrollTop() {\n    return this.scrollTarget.scrollTop;\n  }\n\n  /** @private */\n  set _scrollTop(top) {\n    this.scrollTarget.scrollTop = top;\n  }\n\n  /** @private */\n  get items() {\n    return {\n      length: Math.min(this.size, MAX_VIRTUAL_COUNT),\n    };\n  }\n\n  /** @private */\n  get offsetHeight() {\n    return this.scrollTarget.offsetHeight;\n  }\n\n  /** @private */\n  get $() {\n    return {\n      items: this.scrollContainer,\n    };\n  }\n\n  /** @private */\n  updateViewportBoundaries() {\n    const styles = window.getComputedStyle(this.scrollTarget);\n    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles['padding-top'], 10);\n    this._isRTL = Boolean(styles.direction === 'rtl');\n    this._viewportWidth = this.elementsContainer.offsetWidth;\n    this._viewportHeight = this.scrollTarget.offsetHeight;\n    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;\n    if (this.grid) {\n      this._updateGridMetrics();\n    }\n  }\n\n  /** @private */\n  setAttribute() {}\n\n  /** @private */\n  _createPool(size) {\n    const physicalItems = this.createElements(size);\n    const fragment = document.createDocumentFragment();\n    physicalItems.forEach((el) => {\n      el.style.position = 'absolute';\n      fragment.appendChild(el);\n      this.__resizeObserver.observe(el);\n    });\n    this.elementsContainer.appendChild(fragment);\n    return physicalItems;\n  }\n\n  /** @private */\n  _assignModels(itemSet) {\n    const updatedElements = [];\n    this._iterateItems((pidx, vidx) => {\n      const el = this._physicalItems[pidx];\n      el.hidden = vidx >= this.size;\n      if (!el.hidden) {\n        el.__virtualIndex = vidx + (this._vidxOffset || 0);\n        this.__updateElement(el, el.__virtualIndex);\n        updatedElements.push(el);\n      } else {\n        delete el.__lastUpdatedIndex;\n      }\n    }, itemSet);\n\n    this.__afterElementsUpdated(updatedElements);\n  }\n\n  /** @private */\n  _isClientFull() {\n    // Workaround an issue in iron-list that can cause it to freeze on fast scroll\n    setTimeout(() => {\n      this.__clientFull = true;\n    });\n    return this.__clientFull || super._isClientFull();\n  }\n\n  /** @private */\n  translate3d(_x, y, _z, el) {\n    el.style.transform = `translateY(${y})`;\n  }\n\n  /** @private */\n  toggleScrollListener() {}\n\n  _scrollHandler() {\n    // The scroll target is hidden.\n    if (this.scrollTarget.offsetHeight === 0) {\n      return;\n    }\n\n    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));\n    const delta = this.scrollTarget.scrollTop - this._scrollPosition;\n\n    super._scrollHandler();\n\n    if (this._physicalCount !== 0) {\n      const isScrollingDown = delta >= 0;\n      const reusables = this._getReusables(!isScrollingDown);\n\n      if (reusables.indexes.length) {\n        // After running super._scrollHandler, fix internal properties to workaround an iron-list issue.\n        // See https://github.com/vaadin/web-components/issues/1691\n        this._physicalTop = reusables.physicalTop;\n\n        if (isScrollingDown) {\n          this._virtualStart -= reusables.indexes.length;\n          this._physicalStart -= reusables.indexes.length;\n        } else {\n          this._virtualStart += reusables.indexes.length;\n          this._physicalStart += reusables.indexes.length;\n        }\n        this._resizeHandler();\n      }\n    }\n\n    if (delta) {\n      // There was a change in scroll top. Schedule a check for invalid item positioning.\n      this.__fixInvalidItemPositioningDebouncer = Debouncer.debounce(\n        this.__fixInvalidItemPositioningDebouncer,\n        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),\n        () => this.__fixInvalidItemPositioning(),\n      );\n    }\n\n    if (this.reorderElements) {\n      this.__scrollReorderDebouncer = Debouncer.debounce(\n        this.__scrollReorderDebouncer,\n        timeOut.after(this.timeouts.SCROLL_REORDER),\n        () => this.__reorderElements(),\n      );\n    }\n\n    this.__previousScrollTop = this._scrollTop;\n\n    // If the first visible index is not 0 when scrolled to the top,\n    // scroll to index 0 to fix the issue.\n    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {\n      this.scrollToIndex(0);\n    }\n  }\n\n  /**\n   * Work around an iron-list issue with invalid item positioning.\n   * See https://github.com/vaadin/flow-components/issues/4306\n   * @private\n   */\n  __fixInvalidItemPositioning() {\n    if (!this.scrollTarget.isConnected) {\n      return;\n    }\n\n    // Check if the first physical item element is below the top of the viewport\n    const physicalTopBelowTop = this._physicalTop > this._scrollTop;\n    // Check if the last physical item element is above the bottom of the viewport\n    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;\n\n    // Check if the first index is visible\n    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;\n    // Check if the last index is visible\n    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;\n\n    if ((physicalTopBelowTop && !firstIndexVisible) || (physicalBottomAboveBottom && !lastIndexVisible)) {\n      // Invalid state! Try to recover.\n\n      const isScrollingDown = physicalBottomAboveBottom;\n      // Set the \"_ratio\" property temporarily to 0 to make iron-list's _getReusables\n      // place all the free physical items on one side of the viewport.\n      const originalRatio = this._ratio;\n      this._ratio = 0;\n      // Fake a scroll change to make _scrollHandler place the physical items\n      // on the desired side.\n      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);\n      this._scrollHandler();\n      // Restore the original \"_ratio\" value.\n      this._ratio = originalRatio;\n    }\n  }\n\n  /** @private */\n  __onWheel(e) {\n    if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {\n      return;\n    }\n\n    let deltaY = e.deltaY;\n    if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n      // Scrolling by \"lines of text\" instead of pixels\n      deltaY *= this._scrollLineHeight;\n    } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n      // Scrolling by \"pages\" instead of pixels\n      deltaY *= this._scrollPageHeight;\n    }\n\n    if (!this._deltaYAcc) {\n      this._deltaYAcc = 0;\n    }\n\n    if (this._wheelAnimationFrame) {\n      // Accumulate wheel delta while a frame is being processed\n      this._deltaYAcc += deltaY;\n      e.preventDefault();\n      return;\n    }\n\n    deltaY += this._deltaYAcc;\n    this._deltaYAcc = 0;\n\n    this._wheelAnimationFrame = true;\n    this.__debouncerWheelAnimationFrame = Debouncer.debounce(\n      this.__debouncerWheelAnimationFrame,\n      animationFrame,\n      () => {\n        this._wheelAnimationFrame = false;\n      },\n    );\n\n    const momentum = Math.abs(e.deltaX) + Math.abs(deltaY);\n\n    if (this._canScroll(this.scrollTarget, e.deltaX, deltaY)) {\n      e.preventDefault();\n      this.scrollTarget.scrollTop += deltaY;\n      this.scrollTarget.scrollLeft += e.deltaX;\n\n      this._hasResidualMomentum = true;\n\n      this._ignoreNewWheel = true;\n      this._debouncerIgnoreNewWheel = Debouncer.debounce(\n        this._debouncerIgnoreNewWheel,\n        timeOut.after(this.timeouts.IGNORE_WHEEL),\n        () => {\n          this._ignoreNewWheel = false;\n        },\n      );\n    } else if ((this._hasResidualMomentum && momentum <= this._previousMomentum) || this._ignoreNewWheel) {\n      e.preventDefault();\n    } else if (momentum > this._previousMomentum) {\n      this._hasResidualMomentum = false;\n    }\n    this._previousMomentum = momentum;\n  }\n\n  /**\n   * Determines if the element has an ancestor that handles the scroll delta prior to this\n   *\n   * @private\n   */\n  _hasScrolledAncestor(el, deltaX, deltaY) {\n    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {\n      return false;\n    } else if (\n      this._canScroll(el, deltaX, deltaY) &&\n      ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1\n    ) {\n      return true;\n    } else if (el !== this && el.parentElement) {\n      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);\n    }\n  }\n\n  _canScroll(el, deltaX, deltaY) {\n    return (\n      (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||\n      (deltaY < 0 && el.scrollTop > 0) ||\n      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||\n      (deltaX < 0 && el.scrollLeft > 0)\n    );\n  }\n\n  /**\n   * Increases the pool size.\n   * @override\n   */\n  _increasePoolIfNeeded(count) {\n    if (this._physicalCount > 2 && count) {\n      // The iron-list logic has already created some physical items and\n      // has decided to create more. Since each item creation round is\n      // expensive, let's try to create the remaining items in one go.\n\n      // Calculate the total item count that would be needed to fill the viewport\n      // plus the buffer assuming rest of the items to be of the average size\n      // of the items already created.\n      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);\n      const missingItemCount = totalItemCount - this._physicalCount;\n      // Create the remaining items in one go. Use a maximum of 100 items\n      // as a safety measure.\n      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));\n    } else {\n      super._increasePoolIfNeeded(count);\n    }\n  }\n\n  /**\n   * @returns {Number|undefined} - The browser's default font-size in pixels\n   * @private\n   */\n  _getScrollLineHeight() {\n    const el = document.createElement('div');\n    el.style.fontSize = 'initial';\n    el.style.display = 'none';\n    document.body.appendChild(el);\n    const fontSize = window.getComputedStyle(el).fontSize;\n    document.body.removeChild(el);\n    return fontSize ? window.parseInt(fontSize) : undefined;\n  }\n\n  __getVisibleElements() {\n    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);\n  }\n\n  /** @private */\n  __reorderElements() {\n    if (this.__mouseDown) {\n      this.__pendingReorder = true;\n      return;\n    }\n    this.__pendingReorder = false;\n\n    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);\n\n    // Which row to use as a target?\n    const visibleElements = this.__getVisibleElements();\n\n    const elementWithFocus = visibleElements.find(\n      (element) =>\n        element.contains(this.elementsContainer.getRootNode().activeElement) ||\n        element.contains(this.scrollTarget.getRootNode().activeElement),\n    );\n    const targetElement = elementWithFocus || visibleElements[0];\n    if (!targetElement) {\n      // All elements are hidden, don't reorder\n      return;\n    }\n\n    // Where the target row should be?\n    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;\n\n    // Reodrer the DOM elements to keep the target row at the target physical index\n    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;\n    if (delta > 0) {\n      for (let i = 0; i < delta; i++) {\n        this.elementsContainer.appendChild(visibleElements[i]);\n      }\n    } else if (delta < 0) {\n      for (let i = visibleElements.length + delta; i < visibleElements.length; i++) {\n        this.elementsContainer.insertBefore(visibleElements[i], visibleElements[0]);\n      }\n    }\n\n    // Due to a rendering bug, reordering the rows can make parts of the scroll target disappear\n    // on Safari when using sticky positioning in case the scroll target is inside a flexbox.\n    // This issue manifests with grid (the header can disappear if grid is used inside a flexbox)\n    if (isSafari) {\n      const { transform } = this.scrollTarget.style;\n      this.scrollTarget.style.transform = 'translateZ(0)';\n      setTimeout(() => {\n        this.scrollTarget.style.transform = transform;\n      });\n    }\n  }\n\n  /** @private */\n  _adjustVirtualIndexOffset(delta) {\n    if (this._virtualCount >= this.size) {\n      this._vidxOffset = 0;\n    } else if (this.__skipNextVirtualIndexAdjust) {\n      this.__skipNextVirtualIndexAdjust = false;\n    } else if (Math.abs(delta) > 10000) {\n      // Process a large scroll position change\n      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.offsetHeight);\n      const offset = scale * this.size;\n      this._vidxOffset = Math.round(offset - scale * this._virtualCount);\n    } else {\n      // Make sure user can always swipe/wheel scroll to the start and end\n      const oldOffset = this._vidxOffset;\n      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;\n      const maxShift = 100;\n\n      // Near start\n      if (this._scrollTop === 0) {\n        this._vidxOffset = 0;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(0);\n        }\n      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {\n        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));\n      }\n\n      // Near end\n      const maxOffset = this.size - this._virtualCount;\n      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {\n        this._vidxOffset = maxOffset;\n        if (oldOffset !== this._vidxOffset) {\n          super.scrollToIndex(this._virtualCount - 1);\n        }\n      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {\n        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);\n        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));\n      }\n    }\n  }\n}\n\nObject.setPrototypeOf(IronListAdapter.prototype, ironList);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}