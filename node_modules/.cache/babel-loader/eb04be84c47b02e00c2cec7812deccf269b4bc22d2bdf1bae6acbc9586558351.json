{"ast":null,"code":"var _typeof = require(\"@babel/runtime/helpers/typeof\").default;\nrequire(\"core-js/modules/es.error.cause.js\");\nrequire(\"core-js/modules/es.array.slice.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\nrequire(\"core-js/modules/es.object.get-own-property-names.js\");\nrequire(\"core-js/modules/es.object.get-prototype-of.js\");\nrequire(\"core-js/modules/es.object.seal.js\");\nrequire(\"core-js/modules/es.object.to-string.js\");\nrequire(\"core-js/modules/esnext.iterator.constructor.js\");\nrequire(\"core-js/modules/esnext.iterator.for-each.js\");\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nmodule.exports = function proxyPolyfill() {\n  var lastRevokeFn = null;\n  var _ProxyPolyfill;\n\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n  function isObject(o) {\n    return o ? _typeof(o) === 'object' || typeof o === 'function' : false;\n  }\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n  var $Object = Object;\n\n  // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n  var canCreateNullProtoObjects = Boolean($Object.create) || !({\n    __proto__: null\n  } instanceof $Object);\n  var objectCreate = $Object.create || (canCreateNullProtoObjects ? function create(proto) {\n    validateProto(proto);\n    return {\n      __proto__: proto\n    };\n  } : function create(proto) {\n    validateProto(proto);\n    if (proto === null) {\n      throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n    }\n\n    // nb. cast to convince Closure compiler that this is a constructor\n    var T = /** @type {!Function} */function T() {};\n    T.prototype = proto;\n    return new T();\n  });\n  var noop = function noop() {\n    return null;\n  };\n  var getProto = $Object.getPrototypeOf || ([].__proto__ === Array.prototype ? function getPrototypeOf(O) {\n    // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n    // as it's inherited from `Object.prototype`\n    var proto = O.__proto__;\n    return isObject(proto) ? proto : null;\n  } : noop);\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  _ProxyPolyfill = function ProxyPolyfill(target, handler) {\n    var newTarget = this && this instanceof _ProxyPolyfill ? this.constructor : undefined;\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    var throwRevoked = function throwRevoked() {};\n    lastRevokeFn = function lastRevokeFn() {\n      /** @suppress {checkTypes} */\n      target = null; // clear ref\n      throwRevoked = function throwRevoked(trap) {\n        throw new TypeError(\"Cannot perform '\".concat(trap, \"' on a proxy that has been revoked\"));\n      };\n    };\n    setTimeout(function () {\n      lastRevokeFn = null;\n    }, 0);\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    var unsafeHandler = handler;\n    handler = {\n      'get': null,\n      'set': null,\n      'apply': null,\n      'construct': null\n    };\n    for (var k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(\"Proxy polyfill does not support trap '\".concat(k, \"'\"));\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n    var proto = getProto(target); // can return null in old browsers\n    var proxy;\n    var isMethod = false;\n    var isArray = false;\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        var usingNew = this && this.constructor === proxy;\n        var args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        }\n\n        // since the target was a function, fallback to calling it directly.\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n          var f = /** @type {!Function} */target.bind.apply(target, args);\n          return new f();\n        }\n        return target.apply(this, args);\n      };\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = canCreateNullProtoObjects || proto !== null ? objectCreate(proto) : {};\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    var getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    var setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      var status = handler.set(this, prop, value, proxy);\n      // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n      // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n      // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    var propertyNames = $Object.getOwnPropertyNames(target);\n    var propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      var real = $Object.getOwnPropertyDescriptor(target, prop);\n      var desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    var prototypeOk = true;\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      var setProto = $Object.setPrototypeOf || ([].__proto__ === Array.prototype ? function setPrototypeOf(O, proto) {\n        validateProto(proto);\n        O.__proto__ = proto;\n        return O;\n      } : noop);\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n    if (handler.get || !prototypeOk) {\n      for (var _k in target) {\n        if (propertyMap[_k]) {\n          continue;\n        }\n        $Object.defineProperty(proxy, _k, {\n          get: getter.bind(target, _k)\n        });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    $Object.seal(target);\n    $Object.seal(proxy);\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n  _ProxyPolyfill.revocable = function (target, handler) {\n    var p = new _ProxyPolyfill(target, handler);\n    return {\n      'proxy': p,\n      'revoke': lastRevokeFn\n    };\n  };\n  return _ProxyPolyfill;\n};","map":{"version":3,"names":["module","exports","proxyPolyfill","lastRevokeFn","ProxyPolyfill","isObject","o","_typeof","validateProto","proto","TypeError","$Object","Object","canCreateNullProtoObjects","Boolean","create","__proto__","objectCreate","SyntaxError","T","prototype","noop","getProto","getPrototypeOf","Array","O","target","handler","newTarget","constructor","undefined","throwRevoked","trap","concat","setTimeout","unsafeHandler","k","apply","bind","proxy","isMethod","isArray","usingNew","args","slice","call","arguments","unshift","f","getter","get","prop","setter","set","value","status","propertyNames","getOwnPropertyNames","propertyMap","forEach","real","getOwnPropertyDescriptor","desc","enumerable","defineProperty","prototypeOk","setProto","setPrototypeOf","seal","revocable","p"],"sources":["/workspaces/frontend/node_modules/proxy-polyfill/src/proxy.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n  function isObject(o) {\n    return o ? (typeof o === 'object' || typeof o === 'function') : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n\n  const $Object = Object;\n\n  // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n  const canCreateNullProtoObjects = Boolean($Object.create) || !({ __proto__: null } instanceof $Object);\n  const objectCreate =\n    $Object.create ||\n    (canCreateNullProtoObjects\n      ? function create(proto) {\n          validateProto(proto);\n          return { __proto__: proto };\n        }\n      : function create(proto) {\n          validateProto(proto);\n          if (proto === null) {\n            throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n          }\n\n          // nb. cast to convince Closure compiler that this is a constructor\n          var T = /** @type {!Function} */ (function T() {});\n          T.prototype = proto;\n          return new T();\n        });\n\n  const noop = function() { return null; };\n\n  const getProto =\n    $Object.getPrototypeOf ||\n    ([].__proto__ === Array.prototype\n      ? function getPrototypeOf(O) {\n          // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n          // as it's inherited from `Object.prototype`\n          const proto = O.__proto__;\n          return isObject(proto) ? proto : null;\n        }\n      : noop);\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  ProxyPolyfill = function(target, handler) {\n    const newTarget = this && this instanceof ProxyPolyfill ? this.constructor : undefined;\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    let throwRevoked = function() {};\n    lastRevokeFn = function() {\n      /** @suppress {checkTypes} */\n      target = null;  // clear ref\n      throwRevoked = function(trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n    setTimeout(function() {\n      lastRevokeFn = null;\n    }, 0);\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    const unsafeHandler = handler;\n    handler = { 'get': null, 'set': null, 'apply': null, 'construct': null };\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n    const proto = getProto(target);  // can return null in old browsers\n    let proxy;\n    let isMethod = false;\n    let isArray = false;\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = (this && this.constructor === proxy);\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        }\n\n        // since the target was a function, fallback to calling it directly.\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target);  // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n          const f = /** @type {!Function} */ (target.bind.apply(target, args));\n          return new f();\n        }\n        return target.apply(this, args);\n      };\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = (canCreateNullProtoObjects || proto !== null) ? objectCreate(proto) : {};\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    const getter = handler.get ? function(prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function(prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function(prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy);\n      // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n        // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n        // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function(prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    const propertyNames = $Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function(prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return;  // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      const real = $Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop),\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    let prototypeOk = true;\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      const setProto =\n        $Object.setPrototypeOf ||\n        ([].__proto__ === Array.prototype\n          ? function setPrototypeOf(O, proto) {\n              validateProto(proto);\n              O.__proto__ = proto;\n              return O;\n            }\n          : noop);\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n        $Object.defineProperty(proxy, k, { get: getter.bind(target, k) });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    $Object.seal(target);\n    $Object.seal(proxy);\n\n    return proxy;  // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function(target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return { 'proxy': p, 'revoke': lastRevokeFn };\n  };\n\n  return ProxyPolyfill;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}