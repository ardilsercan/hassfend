{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/wrapNativeSuper\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from '../context-request-event.js';\nimport { ValueNotifier } from '../value-notifier.js';\nexport var ContextProviderEvent = /*#__PURE__*/function (_Event) {\n  _inherits(ContextProviderEvent, _Event);\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  function ContextProviderEvent(context) {\n    var _this;\n    _classCallCheck(this, ContextProviderEvent);\n    _this = _callSuper(this, ContextProviderEvent, ['context-provider', {\n      bubbles: true,\n      composed: true\n    }]);\n    _this.context = context;\n    return _this;\n  }\n  return _createClass(ContextProviderEvent);\n}( /*#__PURE__*/_wrapNativeSuper(Event));\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport var ContextProvider = /*#__PURE__*/function (_ValueNotifier) {\n  _inherits(ContextProvider, _ValueNotifier);\n  function ContextProvider(host, contextOrOptions, initialValue) {\n    var _this2;\n    _classCallCheck(this, ContextProvider);\n    _this2 = _callSuper(this, ContextProvider, [contextOrOptions.context !== undefined ? contextOrOptions.initialValue : initialValue]);\n    _this2.onContextRequest = function (ev) {\n      // Only call the callback if the context matches.\n      // Also, in case an element is a consumer AND a provider\n      // of the same context, we want to avoid the element to self-register.\n      // The check on composedPath (as opposed to ev.target) is to cover cases\n      // where the consumer is in the shadowDom of the provider (in which case,\n      // event.target === this.host because of event retargeting).\n      var consumerHost = ev.composedPath()[0];\n      if (ev.context !== _this2.context || consumerHost === _this2.host) {\n        return;\n      }\n      ev.stopPropagation();\n      _this2.addCallback(ev.callback, consumerHost, ev.subscribe);\n    };\n    /**\n     * When we get a provider request event, that means a child of this element\n     * has just woken up. If it's a provider of our context, then we may need to\n     * re-parent our subscriptions, because is a more specific provider than us\n     * for its subtree.\n     */\n    _this2.onProviderRequest = function (ev) {\n      // Ignore events when the context doesn't match.\n      // Also, in case an element is a consumer AND a provider\n      // of the same context it shouldn't provide to itself.\n      // We use composedPath (as opposed to ev.target) to cover cases\n      // where the consumer is in the shadowDom of the provider (in which case,\n      // event.target === this.host because of event retargeting).\n      var childProviderHost = ev.composedPath()[0];\n      if (ev.context !== _this2.context || childProviderHost === _this2.host) {\n        return;\n      }\n      // Re-parent all of our subscriptions in case this new child provider\n      // should take them over.\n      var seen = new Set();\n      var _iterator = _createForOfIteratorHelper(_this2.subscriptions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            callback = _step$value[0],\n            consumerHost = _step$value[1].consumerHost;\n          // Prevent infinite loops in the case where a one host element\n          // is providing the same context multiple times.\n          //\n          // While normally it's a no-op to attempt to re-parent a subscription\n          // that already has its proper parent, in the case where there's more\n          // than one ValueProvider for the same context on the same hostElement,\n          // they will each call the consumer, and since they will each have their\n          // own dispose function, a well behaved consumer will notice the change\n          // in dispose function and call their old one.\n          //\n          // This will cause the subscriptions to thrash, but worse, without this\n          // set check here, we can end up in an infinite loop, as we add and remove\n          // the same subscriptions onto the end of the map over and over.\n          if (seen.has(callback)) {\n            continue;\n          }\n          seen.add(callback);\n          consumerHost.dispatchEvent(new ContextRequestEvent(_this2.context, callback, true));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      ev.stopPropagation();\n    };\n    _this2.host = host;\n    if (contextOrOptions.context !== undefined) {\n      _this2.context = contextOrOptions.context;\n    } else {\n      _this2.context = contextOrOptions;\n    }\n    _this2.attachListeners();\n    _this2.host.addController(_assertThisInitialized(_this2));\n    return _this2;\n  }\n  _createClass(ContextProvider, [{\n    key: \"attachListeners\",\n    value: function attachListeners() {\n      this.host.addEventListener('context-request', this.onContextRequest);\n      this.host.addEventListener('context-provider', this.onProviderRequest);\n    }\n  }, {\n    key: \"hostConnected\",\n    value: function hostConnected() {\n      // emit an event to signal a provider is available for this context\n      this.host.dispatchEvent(new ContextProviderEvent(this.context));\n    }\n  }]);\n  return ContextProvider;\n}(ValueNotifier);","map":{"version":3,"names":["ContextRequestEvent","ValueNotifier","ContextProviderEvent","_Event","_inherits","context","_this","_classCallCheck","_callSuper","bubbles","composed","_createClass","_wrapNativeSuper","Event","ContextProvider","_ValueNotifier","host","contextOrOptions","initialValue","_this2","undefined","onContextRequest","ev","consumerHost","composedPath","stopPropagation","addCallback","callback","subscribe","onProviderRequest","childProviderHost","seen","Set","_iterator","_createForOfIteratorHelper","subscriptions","_step","s","n","done","_step$value","_slicedToArray","value","has","add","dispatchEvent","err","e","f","attachListeners","addController","_assertThisInitialized","key","addEventListener","hostConnected"],"sources":["../../../src/lib/controllers/context-provider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>\n> extends Event {\n  readonly context: C;\n\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  constructor(context: C) {\n    super('context-provider', {bubbles: true, composed: true});\n    this.context = context;\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider<T extends Context<unknown, unknown>>\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  protected readonly host: ReactiveElement;\n  private readonly context: T;\n\n  constructor(host: ReactiveElement, options: Options<T>);\n  /** @deprecated Use new ContextProvider(host, options) */\n  constructor(host: ReactiveElement, context: T, initialValue?: ContextType<T>);\n  constructor(\n    host: ReactiveElement,\n    contextOrOptions: T | Options<T>,\n    initialValue?: ContextType<T>\n  ) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n    this.host.addController(this);\n  }\n\n  onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const consumerHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || consumerHost === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, consumerHost, ev.subscribe);\n  };\n\n  /**\n   * When we get a provider request event, that means a child of this element\n   * has just woken up. If it's a provider of our context, then we may need to\n   * re-parent our subscriptions, because is a more specific provider than us\n   * for its subtree.\n   */\n  onProviderRequest = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ): void => {\n    // Ignore events when the context doesn't match.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context it shouldn't provide to itself.\n    // We use composedPath (as opposed to ev.target) to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    const childProviderHost = ev.composedPath()[0] as Element;\n    if (ev.context !== this.context || childProviderHost === this.host) {\n      return;\n    }\n    // Re-parent all of our subscriptions in case this new child provider\n    // should take them over.\n    const seen = new Set<unknown>();\n    for (const [callback, {consumerHost}] of this.subscriptions) {\n      // Prevent infinite loops in the case where a one host element\n      // is providing the same context multiple times.\n      //\n      // While normally it's a no-op to attempt to re-parent a subscription\n      // that already has its proper parent, in the case where there's more\n      // than one ValueProvider for the same context on the same hostElement,\n      // they will each call the consumer, and since they will each have their\n      // own dispose function, a well behaved consumer will notice the change\n      // in dispose function and call their old one.\n      //\n      // This will cause the subscriptions to thrash, but worse, without this\n      // set check here, we can end up in an infinite loop, as we add and remove\n      // the same subscriptions onto the end of the map over and over.\n      if (seen.has(callback)) {\n        continue;\n      }\n      seen.add(callback);\n      consumerHost.dispatchEvent(\n        new ContextRequestEvent(this.context, callback, true)\n      );\n    }\n    ev.stopPropagation();\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n    this.host.addEventListener('context-provider', this.onProviderRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,SAAQA,mBAAmB,QAAO,6BAA6B;AAE/D,SAAQC,aAAa,QAAO,sBAAsB;AAalD,WAAaC,oBAEX,0BAAAC,MAAA;EAAAC,SAAA,CAAAF,oBAAA,EAAAC,MAAA;EAGA;;;;EAIA,SAAAD,qBAAYG,OAAU;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAL,oBAAA;IACpBI,KAAA,GAAAE,UAAA,OAAAN,oBAAA,GAAM,kBAAkB,EAAE;MAACO,OAAO,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAI,CAAC;IACzDJ,KAAA,CAAKD,OAAO,GAAGA,OAAO;IAAC,OAAAC,KAAA;EACzB;EAAC,OAAAK,YAAA,CAAAT,oBAAA;AAAA,gBAAAU,gBAAA,CAVOC,KAAK;AAkBf;;;;;;;;AAQA,WAAaC,eACX,0BAAAC,cAAA;EAAAX,SAAA,CAAAU,eAAA,EAAAC,cAAA;EASA,SAAAD,gBACEE,IAAqB,EACrBC,gBAAgC,EAChCC,YAA6B;IAAA,IAAAC,MAAA;IAAAZ,eAAA,OAAAO,eAAA;IAE7BK,MAAA,GAAAX,UAAA,OAAAM,eAAA,GACGG,gBAA+B,CAACZ,OAAO,KAAKe,SAAS,GACjDH,gBAA+B,CAACC,YAAY,GAC7CA,YAAY;IAYpBC,MAAA,CAAAE,gBAAgB,GAAG,UACjBC,EAAkD,EAC1C;MACR;MACA;MACA;MACA;MACA;MACA;MACA,IAAMC,YAAY,GAAGD,EAAE,CAACE,YAAY,EAAE,CAAC,CAAC,CAAY;MACpD,IAAIF,EAAE,CAACjB,OAAO,KAAKc,MAAA,CAAKd,OAAO,IAAIkB,YAAY,KAAKJ,MAAA,CAAKH,IAAI,EAAE;QAC7D;;MAEFM,EAAE,CAACG,eAAe,EAAE;MACpBN,MAAA,CAAKO,WAAW,CAACJ,EAAE,CAACK,QAAQ,EAAEJ,YAAY,EAAED,EAAE,CAACM,SAAS,CAAC;IAC3D,CAAC;IAED;;;;;;IAMAT,MAAA,CAAAU,iBAAiB,GAAG,UAClBP,EAAmD,EAC3C;MACR;MACA;MACA;MACA;MACA;MACA;MACA,IAAMQ,iBAAiB,GAAGR,EAAE,CAACE,YAAY,EAAE,CAAC,CAAC,CAAY;MACzD,IAAIF,EAAE,CAACjB,OAAO,KAAKc,MAAA,CAAKd,OAAO,IAAIyB,iBAAiB,KAAKX,MAAA,CAAKH,IAAI,EAAE;QAClE;;MAEF;MACA;MACA,IAAMe,IAAI,GAAG,IAAIC,GAAG,EAAW;MAAC,IAAAC,SAAA,GAAAC,0BAAA,CACSf,MAAA,CAAKgB,aAAa;QAAAC,KAAA;MAAA;QAA3D,KAAAH,SAAA,CAAAI,CAAA,MAAAD,KAAA,GAAAH,SAAA,CAAAK,CAAA,IAAAC,IAAA,GAA6D;UAAA,IAAAC,WAAA,GAAAC,cAAA,CAAAL,KAAA,CAAAM,KAAA;YAAjDf,QAAQ,GAAAa,WAAA;YAAGjB,YAAY,GAAAiB,WAAA,IAAZjB,YAAY;UACjC;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAIQ,IAAI,CAACY,GAAG,CAAChB,QAAQ,CAAC,EAAE;YACtB;;UAEFI,IAAI,CAACa,GAAG,CAACjB,QAAQ,CAAC;UAClBJ,YAAY,CAACsB,aAAa,CACxB,IAAI7C,mBAAmB,CAACmB,MAAA,CAAKd,OAAO,EAAEsB,QAAQ,EAAE,IAAI,CAAC,CACtD;;MACF,SAAAmB,GAAA;QAAAb,SAAA,CAAAc,CAAA,CAAAD,GAAA;MAAA;QAAAb,SAAA,CAAAe,CAAA;MAAA;MACD1B,EAAE,CAACG,eAAe,EAAE;IACtB,CAAC;IAxECN,MAAA,CAAKH,IAAI,GAAGA,IAAI;IAChB,IAAKC,gBAA+B,CAACZ,OAAO,KAAKe,SAAS,EAAE;MAC1DD,MAAA,CAAKd,OAAO,GAAIY,gBAA+B,CAACZ,OAAO;KACxD,MAAM;MACLc,MAAA,CAAKd,OAAO,GAAGY,gBAAqB;;IAEtCE,MAAA,CAAK8B,eAAe,EAAE;IACtB9B,MAAA,CAAKH,IAAI,CAACkC,aAAa,CAAAC,sBAAA,CAAAhC,MAAA,CAAK,CAAC;IAAC,OAAAA,MAAA;EAChC;EAACR,YAAA,CAAAG,eAAA;IAAAsC,GAAA;IAAAV,KAAA,EAkEO,SAAAO,gBAAA,EAAe;MACrB,IAAI,CAACjC,IAAI,CAACqC,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAAChC,gBAAgB,CAAC;MACpE,IAAI,CAACL,IAAI,CAACqC,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAACxB,iBAAiB,CAAC;IACxE;EAAC;IAAAuB,GAAA;IAAAV,KAAA,EAED,SAAAY,cAAA,EAAa;MACX;MACA,IAAI,CAACtC,IAAI,CAAC6B,aAAa,CAAC,IAAI3C,oBAAoB,CAAC,IAAI,CAACG,OAAO,CAAC,CAAC;IACjE;EAAC;EAAA,OAAAS,eAAA;AAAA,EArGOb,aAA6B"},"metadata":{},"sourceType":"module","externalDependencies":[]}