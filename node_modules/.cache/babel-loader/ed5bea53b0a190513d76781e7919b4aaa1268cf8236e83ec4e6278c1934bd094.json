{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-notched-outline/mwc-notched-outline.js';\nimport '@material/mwc-menu/mwc-menu.js';\nimport '@material/mwc-icon/mwc-icon.js';\nimport { KEY, normalizeKey } from '@material/dom/keyboard.js';\nimport * as typeahead from '@material/list/typeahead.js';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { isNodeElement } from '@material/mwc-base/utils.js';\nimport { floatingLabel } from '@material/mwc-floating-label/mwc-floating-label-directive.js';\nimport { lineRipple } from '@material/mwc-line-ripple/mwc-line-ripple-directive.js';\nimport MDCSelectFoundation from '@material/select/foundation.js';\nimport { html, nothing } from 'lit';\nimport { eventOptions, property, query, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nconst createValidityObj = (customValidity = {}) => {\n  /*\n   * We need to make ValidityState an object because it is readonly and\n   * we cannot use the spread operator. Also, we don't export\n   * `CustomValidityState` because it is a leaky implementation and the user\n   * already has access to `ValidityState` in lib.dom.ts. Also an interface\n   * {a: Type} can be casted to {readonly a: Type} so passing any object\n   * should be fine.\n   */\n  const objectifiedCustomValidity = {};\n  // eslint-disable-next-line guard-for-in\n  for (const propName in customValidity) {\n    /*\n     * Casting is needed because ValidityState's props are all readonly and\n     * thus cannot be set on `onjectifiedCustomValidity`. In the end, the\n     * interface is the same as ValidityState (but not readonly), but the\n     * function signature casts the output to ValidityState (thus readonly).\n     */\n    objectifiedCustomValidity[propName] = customValidity[propName];\n  }\n  return Object.assign({\n    badInput: false,\n    customError: false,\n    patternMismatch: false,\n    rangeOverflow: false,\n    rangeUnderflow: false,\n    stepMismatch: false,\n    tooLong: false,\n    tooShort: false,\n    typeMismatch: false,\n    valid: true,\n    valueMissing: false\n  }, objectifiedCustomValidity);\n};\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires opened\n * @fires closed\n * @fires change\n * @fires invalid\n */\nexport class SelectBase extends FormElement {\n  constructor() {\n    super(...arguments);\n    this.mdcFoundationClass = MDCSelectFoundation;\n    this.disabled = false;\n    this.outlined = false;\n    this.label = '';\n    this.outlineOpen = false;\n    this.outlineWidth = 0;\n    this.value = '';\n    this.name = '';\n    this.selectedText = '';\n    this.icon = '';\n    this.menuOpen = false;\n    this.helper = '';\n    this.validateOnInitialRender = false;\n    this.validationMessage = '';\n    this.required = false;\n    this.naturalMenuWidth = false;\n    this.isUiValid = true;\n    this.fixedMenuPosition = false;\n    // Transiently holds current typeahead prefix from user.\n    this.typeaheadState = typeahead.initState();\n    this.sortedIndexByFirstChar = new Map();\n    this.menuElement_ = null;\n    this.listeners = [];\n    this.onBodyClickBound = () => undefined;\n    this._menuUpdateComplete = null;\n    this.valueSetDirectly = false;\n    this.validityTransform = null;\n    this._validity = createValidityObj();\n  }\n  get items() {\n    // memoize menuElement to prevent unnecessary querySelector calls.\n    if (!this.menuElement_) {\n      this.menuElement_ = this.menuElement;\n    }\n    if (this.menuElement_) {\n      return this.menuElement_.items;\n    }\n    return [];\n  }\n  get selected() {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      return menuElement.selected;\n    }\n    return null;\n  }\n  get index() {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      return menuElement.index;\n    }\n    return -1;\n  }\n  get shouldRenderHelperText() {\n    return !!this.helper || !!this.validationMessage;\n  }\n  get validity() {\n    this._checkValidity(this.value);\n    return this._validity;\n  }\n  render() {\n    const classes = {\n      'mdc-select--disabled': this.disabled,\n      'mdc-select--no-label': !this.label,\n      'mdc-select--filled': !this.outlined,\n      'mdc-select--outlined': this.outlined,\n      'mdc-select--with-leading-icon': !!this.icon,\n      'mdc-select--required': this.required,\n      'mdc-select--invalid': !this.isUiValid\n    };\n    const labelledby = !!this.label ? 'label' : undefined;\n    const describedby = this.shouldRenderHelperText ? 'helper-text' : undefined;\n    return html`\n      <div\n          class=\"mdc-select ${classMap(classes)}\">\n        <input\n            class=\"formElement\"\n            name=\"${this.name}\"\n            .value=\"${this.value}\"\n            hidden\n            ?disabled=\"${this.disabled}\"\n            ?required=${this.required}>\n        <!-- @ts-ignore -->\n        <div class=\"mdc-select__anchor\"\n            aria-autocomplete=\"none\"\n            role=\"combobox\"\n            aria-expanded=${this.menuOpen}\n            aria-invalid=${!this.isUiValid}\n            aria-haspopup=\"listbox\"\n            aria-labelledby=${ifDefined(labelledby)}\n            aria-required=${this.required}\n            aria-describedby=${ifDefined(describedby)}\n            @click=${this.onClick}\n            @focus=${this.onFocus}\n            @blur=${this.onBlur}\n            @keydown=${this.onKeydown}>\n          ${this.renderRipple()}\n          ${this.outlined ? this.renderOutline() : this.renderLabel()}\n          ${this.renderLeadingIcon()}\n          <span class=\"mdc-select__selected-text-container\">\n            <span class=\"mdc-select__selected-text\">${this.selectedText}</span>\n          </span>\n          <span class=\"mdc-select__dropdown-icon\">\n            <svg\n                class=\"mdc-select__dropdown-icon-graphic\"\n                viewBox=\"7 10 10 5\"\n                focusable=\"false\">\n              <polygon\n                  class=\"mdc-select__dropdown-icon-inactive\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 10 12 15 17 10\">\n              </polygon>\n              <polygon\n                  class=\"mdc-select__dropdown-icon-active\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 15 12 10 17 15\">\n              </polygon>\n            </svg>\n          </span>\n          ${this.renderLineRipple()}\n        </div>\n        ${this.renderMenu()}\n      </div>\n      ${this.renderHelperText()}`;\n  }\n  renderMenu() {\n    const classes = this.getMenuClasses();\n    return html`\n      <mwc-menu\n        innerRole=\"listbox\"\n        wrapFocus\n        class=\" ${classMap(classes)}\"\n        activatable\n        .fullwidth=${this.fixedMenuPosition ? false : !this.naturalMenuWidth}\n        .open=${this.menuOpen}\n        .anchor=${this.anchorElement}\n        .fixed=${this.fixedMenuPosition}\n        @selected=${this.onSelected}\n        @opened=${this.onOpened}\n        @closed=${this.onClosed}\n        @items-updated=${this.onItemsUpdated}\n        @keydown=${this.handleTypeahead}>\n      ${this.renderMenuContent()}\n    </mwc-menu>`;\n  }\n  getMenuClasses() {\n    return {\n      'mdc-select__menu': true,\n      'mdc-menu': true,\n      'mdc-menu-surface': true,\n      'mdc-select__menu--invalid': !this.isUiValid\n    };\n  }\n  renderMenuContent() {\n    return html`<slot></slot>`;\n  }\n  renderRipple() {\n    if (this.outlined) {\n      return nothing;\n    }\n    return html`\n      <span class=\"mdc-select__ripple\"></span>\n    `;\n  }\n  renderOutline() {\n    if (!this.outlined) {\n      return nothing;\n    }\n    return html`\n      <mwc-notched-outline\n          .width=${this.outlineWidth}\n          .open=${this.outlineOpen}\n          class=\"mdc-notched-outline\">\n        ${this.renderLabel()}\n      </mwc-notched-outline>`;\n  }\n  renderLabel() {\n    if (!this.label) {\n      return nothing;\n    }\n    return html`\n      <span\n          .floatingLabelFoundation=${floatingLabel(this.label)}\n          id=\"label\">${this.label}</span>\n    `;\n  }\n  renderLeadingIcon() {\n    if (!this.icon) {\n      return nothing;\n    }\n    return html`<mwc-icon class=\"mdc-select__icon\"><div>${this.icon}</div></mwc-icon>`;\n  }\n  renderLineRipple() {\n    if (this.outlined) {\n      return nothing;\n    }\n    return html`\n      <span .lineRippleFoundation=${lineRipple()}></span>\n    `;\n  }\n  renderHelperText() {\n    if (!this.shouldRenderHelperText) {\n      return nothing;\n    }\n    const showValidationMessage = this.validationMessage && !this.isUiValid;\n    const classes = {\n      'mdc-select-helper-text--validation-msg': showValidationMessage\n    };\n    return html`\n        <p\n          class=\"mdc-select-helper-text ${classMap(classes)}\"\n          id=\"helper-text\">${showValidationMessage ? this.validationMessage : this.helper}</p>`;\n  }\n  createAdapter() {\n    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {\n      activateBottomLine: () => {\n        if (this.lineRippleElement) {\n          this.lineRippleElement.lineRippleFoundation.activate();\n        }\n      },\n      deactivateBottomLine: () => {\n        if (this.lineRippleElement) {\n          this.lineRippleElement.lineRippleFoundation.deactivate();\n        }\n      },\n      hasLabel: () => {\n        return !!this.label;\n      },\n      floatLabel: shouldFloat => {\n        if (this.labelElement) {\n          this.labelElement.floatingLabelFoundation.float(shouldFloat);\n        }\n      },\n      getLabelWidth: () => {\n        if (this.labelElement) {\n          return this.labelElement.floatingLabelFoundation.getWidth();\n        }\n        return 0;\n      },\n      setLabelRequired: isRequired => {\n        if (this.labelElement) {\n          this.labelElement.floatingLabelFoundation.setRequired(isRequired);\n        }\n      },\n      hasOutline: () => this.outlined,\n      notchOutline: labelWidth => {\n        const outlineElement = this.outlineElement;\n        if (outlineElement && !this.outlineOpen) {\n          this.outlineWidth = labelWidth;\n          this.outlineOpen = true;\n        }\n      },\n      closeOutline: () => {\n        if (this.outlineElement) {\n          this.outlineOpen = false;\n        }\n      },\n      setRippleCenter: normalizedX => {\n        if (this.lineRippleElement) {\n          const foundation = this.lineRippleElement.lineRippleFoundation;\n          foundation.setRippleCenter(normalizedX);\n        }\n      },\n      notifyChange: async value => {\n        if (!this.valueSetDirectly && value === this.value) {\n          return;\n        }\n        this.valueSetDirectly = false;\n        this.value = value;\n        await this.updateComplete;\n        const ev = new Event('change', {\n          bubbles: true\n        });\n        this.dispatchEvent(ev);\n      },\n      setSelectedText: value => this.selectedText = value,\n      isSelectAnchorFocused: () => {\n        const selectAnchorElement = this.anchorElement;\n        if (!selectAnchorElement) {\n          return false;\n        }\n        const rootNode = selectAnchorElement.getRootNode();\n        return rootNode.activeElement === selectAnchorElement;\n      },\n      getSelectAnchorAttr: attr => {\n        const selectAnchorElement = this.anchorElement;\n        if (!selectAnchorElement) {\n          return null;\n        }\n        return selectAnchorElement.getAttribute(attr);\n      },\n      setSelectAnchorAttr: (attr, value) => {\n        const selectAnchorElement = this.anchorElement;\n        if (!selectAnchorElement) {\n          return;\n        }\n        selectAnchorElement.setAttribute(attr, value);\n      },\n      removeSelectAnchorAttr: attr => {\n        const selectAnchorElement = this.anchorElement;\n        if (!selectAnchorElement) {\n          return;\n        }\n        selectAnchorElement.removeAttribute(attr);\n      },\n      openMenu: () => {\n        this.menuOpen = true;\n      },\n      closeMenu: () => {\n        this.menuOpen = false;\n      },\n      addMenuClass: () => undefined,\n      removeMenuClass: () => undefined,\n      getAnchorElement: () => this.anchorElement,\n      setMenuAnchorElement: () => {\n        /* Handled by anchor directive */\n      },\n      setMenuAnchorCorner: () => {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n          menuElement.corner = 'BOTTOM_START';\n        }\n      },\n      setMenuWrapFocus: wrapFocus => {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n          menuElement.wrapFocus = wrapFocus;\n        }\n      },\n      focusMenuItemAtIndex: index => {\n        const menuElement = this.menuElement;\n        if (!menuElement) {\n          return;\n        }\n        const element = menuElement.items[index];\n        if (!element) {\n          return;\n        }\n        element.focus();\n      },\n      getMenuItemCount: () => {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n          return menuElement.items.length;\n        }\n        return 0;\n      },\n      getMenuItemValues: () => {\n        const menuElement = this.menuElement;\n        if (!menuElement) {\n          return [];\n        }\n        const items = menuElement.items;\n        return items.map(item => item.value);\n      },\n      getMenuItemTextAtIndex: index => {\n        const menuElement = this.menuElement;\n        if (!menuElement) {\n          return '';\n        }\n        const element = menuElement.items[index];\n        if (!element) {\n          return '';\n        }\n        return element.text;\n      },\n      getSelectedIndex: () => this.index,\n      setSelectedIndex: () => undefined,\n      isTypeaheadInProgress: () => typeahead.isTypingInProgress(this.typeaheadState),\n      typeaheadMatchItem: (nextChar, startingIndex) => {\n        if (!this.menuElement) {\n          return -1;\n        }\n        const opts = {\n          focusItemAtIndex: index => {\n            this.menuElement.focusItemAtIndex(index);\n          },\n          focusedItemIndex: startingIndex ? startingIndex : this.menuElement.getFocusedItemIndex(),\n          nextChar,\n          sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n          skipFocus: false,\n          isItemAtIndexDisabled: index => this.items[index].disabled\n        };\n        const index = typeahead.matchItem(opts, this.typeaheadState);\n        if (index !== -1) {\n          this.select(index);\n        }\n        return index;\n      }\n    });\n  }\n  checkValidity() {\n    const isValid = this._checkValidity(this.value);\n    if (!isValid) {\n      const invalidEvent = new Event('invalid', {\n        bubbles: false,\n        cancelable: true\n      });\n      this.dispatchEvent(invalidEvent);\n    }\n    return isValid;\n  }\n  reportValidity() {\n    const isValid = this.checkValidity();\n    this.isUiValid = isValid;\n    return isValid;\n  }\n  _checkValidity(value) {\n    const nativeValidity = this.formElement.validity;\n    let validity = createValidityObj(nativeValidity);\n    if (this.validityTransform) {\n      const customValidity = this.validityTransform(value, validity);\n      validity = Object.assign(Object.assign({}, validity), customValidity);\n    }\n    this._validity = validity;\n    return this._validity.valid;\n  }\n  setCustomValidity(message) {\n    this.validationMessage = message;\n    this.formElement.setCustomValidity(message);\n  }\n  // tslint:disable:ban-ts-ignore\n  async getUpdateComplete() {\n    await this._menuUpdateComplete;\n    // @ts-ignore\n    const result = await super.getUpdateComplete();\n    return result;\n  }\n  // tslint:enable:ban-ts-ignore\n  async firstUpdated() {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      this._menuUpdateComplete = menuElement.updateComplete;\n      await this._menuUpdateComplete;\n    }\n    super.firstUpdated();\n    this.mdcFoundation.isValid = () => true;\n    this.mdcFoundation.setValid = () => undefined;\n    this.mdcFoundation.setDisabled(this.disabled);\n    if (this.validateOnInitialRender) {\n      this.reportValidity();\n    }\n    // Select an option based on init value\n    if (!this.selected) {\n      if (!this.items.length && this.slotElement && this.slotElement.assignedNodes({\n        flatten: true\n      }).length) {\n        // Shady DOM initial render fix\n        await new Promise(res => requestAnimationFrame(res));\n        await this.layout();\n      }\n      const hasEmptyFirstOption = this.items.length && this.items[0].value === '';\n      if (!this.value && hasEmptyFirstOption) {\n        this.select(0);\n        return;\n      }\n      this.selectByValue(this.value);\n    }\n    this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, index => this.items[index].text);\n  }\n  onItemsUpdated() {\n    this.sortedIndexByFirstChar = typeahead.initSortedIndex(this.items.length, index => this.items[index].text);\n  }\n  select(index) {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      menuElement.select(index);\n    }\n  }\n  selectByValue(value) {\n    let indexToSelect = -1;\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      if (item.value === value) {\n        indexToSelect = i;\n        break;\n      }\n    }\n    this.valueSetDirectly = true;\n    this.select(indexToSelect);\n    this.mdcFoundation.handleChange();\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    for (const listener of this.listeners) {\n      listener.target.removeEventListener(listener.name, listener.cb);\n    }\n  }\n  focus() {\n    const focusEvt = new CustomEvent('focus');\n    const selectAnchorElement = this.anchorElement;\n    if (selectAnchorElement) {\n      selectAnchorElement.dispatchEvent(focusEvt);\n      selectAnchorElement.focus();\n    }\n  }\n  blur() {\n    const focusEvt = new CustomEvent('blur');\n    const selectAnchorElement = this.anchorElement;\n    if (selectAnchorElement) {\n      selectAnchorElement.dispatchEvent(focusEvt);\n      selectAnchorElement.blur();\n    }\n  }\n  onFocus() {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleFocus();\n    }\n  }\n  onBlur() {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleBlur();\n    }\n    const menuElement = this.menuElement;\n    if (menuElement && !menuElement.open) {\n      this.reportValidity();\n    }\n  }\n  onClick(evt) {\n    if (this.mdcFoundation) {\n      this.focus();\n      const targetClientRect = evt.target.getBoundingClientRect();\n      let xCoord = 0;\n      if ('touches' in evt) {\n        xCoord = evt.touches[0].clientX;\n      } else {\n        xCoord = evt.clientX;\n      }\n      const normalizedX = xCoord - targetClientRect.left;\n      this.mdcFoundation.handleClick(normalizedX);\n    }\n  }\n  onKeydown(evt) {\n    const arrowUp = normalizeKey(evt) === KEY.ARROW_UP;\n    const arrowDown = normalizeKey(evt) === KEY.ARROW_DOWN;\n    if (arrowDown || arrowUp) {\n      const shouldSelectNextItem = arrowUp && this.index > 0;\n      const shouldSelectPrevItem = arrowDown && this.index < this.items.length - 1;\n      if (shouldSelectNextItem) {\n        this.select(this.index - 1);\n      } else if (shouldSelectPrevItem) {\n        this.select(this.index + 1);\n      }\n      evt.preventDefault();\n      this.mdcFoundation.openMenu();\n      return;\n    }\n    this.mdcFoundation.handleKeydown(evt);\n  }\n  // must capture to run before list foundation captures event\n  handleTypeahead(event) {\n    if (!this.menuElement) {\n      return;\n    }\n    const focusedItemIndex = this.menuElement.getFocusedItemIndex();\n    const target = isNodeElement(event.target) ? event.target : null;\n    const isTargetListItem = target ? target.hasAttribute('mwc-list-item') : false;\n    const opts = {\n      event,\n      focusItemAtIndex: index => {\n        this.menuElement.focusItemAtIndex(index);\n      },\n      focusedItemIndex,\n      isTargetListItem,\n      sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n      isItemAtIndexDisabled: index => this.items[index].disabled\n    };\n    typeahead.handleKeydown(opts, this.typeaheadState);\n  }\n  async onSelected(event) {\n    if (!this.mdcFoundation) {\n      await this.updateComplete;\n    }\n    this.mdcFoundation.handleMenuItemAction(event.detail.index);\n    const item = this.items[event.detail.index];\n    if (item) {\n      this.value = item.value;\n    }\n  }\n  onOpened() {\n    if (this.mdcFoundation) {\n      this.menuOpen = true;\n      this.mdcFoundation.handleMenuOpened();\n    }\n  }\n  onClosed() {\n    if (this.mdcFoundation) {\n      this.menuOpen = false;\n      this.mdcFoundation.handleMenuClosed();\n    }\n  }\n  setFormData(formData) {\n    if (this.name && this.selected !== null) {\n      formData.append(this.name, this.value);\n    }\n  }\n  async layout(updateItems = true) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.layout();\n    }\n    await this.updateComplete;\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      menuElement.layout(updateItems);\n    }\n    const labelElement = this.labelElement;\n    if (!labelElement) {\n      this.outlineOpen = false;\n      return;\n    }\n    const shouldFloat = !!this.label && !!this.value;\n    labelElement.floatingLabelFoundation.float(shouldFloat);\n    if (!this.outlined) {\n      return;\n    }\n    this.outlineOpen = shouldFloat;\n    await this.updateComplete;\n    /* When the textfield automatically notches due to a value and label\n     * being defined, the textfield may be set to `display: none` by the user.\n     * this means that the notch is of size 0px. We provide this function so\n     * that the user may manually resize the notch to the floated label's\n     * width.\n     */\n    const labelWidth = labelElement.floatingLabelFoundation.getWidth();\n    if (this.outlineOpen) {\n      this.outlineWidth = labelWidth;\n    }\n  }\n  async layoutOptions() {\n    if (!this.mdcFoundation) {\n      return;\n    }\n    this.mdcFoundation.layoutOptions();\n  }\n}\n__decorate([query('.mdc-select')], SelectBase.prototype, \"mdcRoot\", void 0);\n__decorate([query('.formElement')], SelectBase.prototype, \"formElement\", void 0);\n__decorate([query('slot')], SelectBase.prototype, \"slotElement\", void 0);\n__decorate([query('select')], SelectBase.prototype, \"nativeSelectElement\", void 0);\n__decorate([query('input')], SelectBase.prototype, \"nativeInputElement\", void 0);\n__decorate([query('.mdc-line-ripple')], SelectBase.prototype, \"lineRippleElement\", void 0);\n__decorate([query('.mdc-floating-label')], SelectBase.prototype, \"labelElement\", void 0);\n__decorate([query('mwc-notched-outline')], SelectBase.prototype, \"outlineElement\", void 0);\n__decorate([query('.mdc-menu')], SelectBase.prototype, \"menuElement\", void 0);\n__decorate([query('.mdc-select__anchor')], SelectBase.prototype, \"anchorElement\", void 0);\n__decorate([property({\n  type: Boolean,\n  attribute: 'disabled',\n  reflect: true\n}), observer(function (value) {\n  if (this.mdcFoundation) {\n    this.mdcFoundation.setDisabled(value);\n  }\n})], SelectBase.prototype, \"disabled\", void 0);\n__decorate([property({\n  type: Boolean\n}), observer(function (_newVal, oldVal) {\n  if (oldVal !== undefined && this.outlined !== oldVal) {\n    this.layout(false);\n  }\n})], SelectBase.prototype, \"outlined\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (_newVal, oldVal) {\n  if (oldVal !== undefined && this.label !== oldVal) {\n    this.layout(false);\n  }\n})], SelectBase.prototype, \"label\", void 0);\n__decorate([state()], SelectBase.prototype, \"outlineOpen\", void 0);\n__decorate([state()], SelectBase.prototype, \"outlineWidth\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (value) {\n  if (this.mdcFoundation) {\n    const initialization = this.selected === null && !!value;\n    const valueSetByUser = this.selected && this.selected.value !== value;\n    if (initialization || valueSetByUser) {\n      this.selectByValue(value);\n    }\n    this.reportValidity();\n  }\n})], SelectBase.prototype, \"value\", void 0);\n__decorate([property()], SelectBase.prototype, \"name\", void 0);\n__decorate([state()], SelectBase.prototype, \"selectedText\", void 0);\n__decorate([property({\n  type: String\n})], SelectBase.prototype, \"icon\", void 0);\n__decorate([state()], SelectBase.prototype, \"menuOpen\", void 0);\n__decorate([property({\n  type: String\n})], SelectBase.prototype, \"helper\", void 0);\n__decorate([property({\n  type: Boolean\n})], SelectBase.prototype, \"validateOnInitialRender\", void 0);\n__decorate([property({\n  type: String\n})], SelectBase.prototype, \"validationMessage\", void 0);\n__decorate([property({\n  type: Boolean\n})], SelectBase.prototype, \"required\", void 0);\n__decorate([property({\n  type: Boolean\n})], SelectBase.prototype, \"naturalMenuWidth\", void 0);\n__decorate([state()], SelectBase.prototype, \"isUiValid\", void 0);\n__decorate([property({\n  type: Boolean\n})], SelectBase.prototype, \"fixedMenuPosition\", void 0);\n__decorate([eventOptions({\n  capture: true\n})], SelectBase.prototype, \"handleTypeahead\", null);","map":{"version":3,"names":["KEY","normalizeKey","typeahead","addHasRemoveClass","FormElement","observer","isNodeElement","floatingLabel","lineRipple","MDCSelectFoundation","html","nothing","eventOptions","property","query","state","classMap","ifDefined","createValidityObj","customValidity","objectifiedCustomValidity","propName","Object","assign","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valid","valueMissing","SelectBase","constructor","mdcFoundationClass","disabled","outlined","label","outlineOpen","outlineWidth","value","name","selectedText","icon","menuOpen","helper","validateOnInitialRender","validationMessage","required","naturalMenuWidth","isUiValid","fixedMenuPosition","typeaheadState","initState","sortedIndexByFirstChar","Map","menuElement_","listeners","onBodyClickBound","undefined","_menuUpdateComplete","valueSetDirectly","validityTransform","_validity","items","menuElement","selected","index","shouldRenderHelperText","validity","_checkValidity","render","classes","labelledby","describedby","onClick","onFocus","onBlur","onKeydown","renderRipple","renderOutline","renderLabel","renderLeadingIcon","renderLineRipple","renderMenu","renderHelperText","getMenuClasses","anchorElement","onSelected","onOpened","onClosed","onItemsUpdated","handleTypeahead","renderMenuContent","showValidationMessage","createAdapter","mdcRoot","activateBottomLine","lineRippleElement","lineRippleFoundation","activate","deactivateBottomLine","deactivate","hasLabel","floatLabel","shouldFloat","labelElement","floatingLabelFoundation","float","getLabelWidth","getWidth","setLabelRequired","isRequired","setRequired","hasOutline","notchOutline","labelWidth","outlineElement","closeOutline","setRippleCenter","normalizedX","foundation","notifyChange","updateComplete","ev","Event","bubbles","dispatchEvent","setSelectedText","isSelectAnchorFocused","selectAnchorElement","rootNode","getRootNode","activeElement","getSelectAnchorAttr","attr","getAttribute","setSelectAnchorAttr","setAttribute","removeSelectAnchorAttr","removeAttribute","openMenu","closeMenu","addMenuClass","removeMenuClass","getAnchorElement","setMenuAnchorElement","setMenuAnchorCorner","corner","setMenuWrapFocus","wrapFocus","focusMenuItemAtIndex","element","focus","getMenuItemCount","length","getMenuItemValues","map","item","getMenuItemTextAtIndex","text","getSelectedIndex","setSelectedIndex","isTypeaheadInProgress","isTypingInProgress","typeaheadMatchItem","nextChar","startingIndex","opts","focusItemAtIndex","focusedItemIndex","getFocusedItemIndex","skipFocus","isItemAtIndexDisabled","matchItem","select","checkValidity","isValid","invalidEvent","cancelable","reportValidity","nativeValidity","formElement","setCustomValidity","message","getUpdateComplete","result","firstUpdated","mdcFoundation","setValid","setDisabled","slotElement","assignedNodes","flatten","Promise","res","requestAnimationFrame","layout","hasEmptyFirstOption","selectByValue","initSortedIndex","indexToSelect","i","handleChange","disconnectedCallback","listener","target","removeEventListener","cb","focusEvt","CustomEvent","blur","handleFocus","handleBlur","open","evt","targetClientRect","getBoundingClientRect","xCoord","touches","clientX","left","handleClick","arrowUp","ARROW_UP","arrowDown","ARROW_DOWN","shouldSelectNextItem","shouldSelectPrevItem","preventDefault","handleKeydown","event","isTargetListItem","hasAttribute","handleMenuItemAction","detail","handleMenuOpened","handleMenuClosed","setFormData","formData","append","updateItems","layoutOptions","__decorate","type","Boolean","attribute","reflect","_newVal","oldVal","String","initialization","valueSetByUser","capture"],"sources":["mwc-select-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport '@material/mwc-notched-outline/mwc-notched-outline.js';\nimport '@material/mwc-menu/mwc-menu.js';\nimport '@material/mwc-icon/mwc-icon.js';\n\nimport {KEY, normalizeKey} from '@material/dom/keyboard.js';\nimport {MDCFloatingLabelFoundation} from '@material/floating-label/foundation.js';\nimport {MDCLineRippleFoundation} from '@material/line-ripple/foundation.js';\nimport * as typeahead from '@material/list/typeahead.js';\nimport {MDCListTextAndIndex} from '@material/list/types.js';\nimport {addHasRemoveClass, FormElement} from '@material/mwc-base/form-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {isNodeElement} from '@material/mwc-base/utils.js';\nimport {floatingLabel, FloatingLabel} from '@material/mwc-floating-label/mwc-floating-label-directive.js';\nimport {lineRipple, LineRipple} from '@material/mwc-line-ripple/mwc-line-ripple-directive.js';\nimport {ListItemBase} from '@material/mwc-list/mwc-list-item-base.js';\nimport {Menu} from '@material/mwc-menu/mwc-menu.js';\nimport {NotchedOutline} from '@material/mwc-notched-outline/mwc-notched-outline.js';\nimport {MDCSelectAdapter} from '@material/select/adapter.js';\nimport MDCSelectFoundation from '@material/select/foundation.js';\nimport {html, nothing} from 'lit';\nimport {eventOptions, property, query, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\n\n// must be done to get past lit-analyzer checks\ndeclare global {\n  interface Element {\n    floatingLabelFoundation?: MDCFloatingLabelFoundation;\n    lineRippleFoundation?: MDCLineRippleFoundation;\n  }\n}\n\ntype CustomValidityState = {\n  -readonly[P in keyof ValidityState]: ValidityState[P]\n};\n\nconst createValidityObj =\n    (customValidity: Partial<ValidityState> = {}): ValidityState => {\n      /*\n       * We need to make ValidityState an object because it is readonly and\n       * we cannot use the spread operator. Also, we don't export\n       * `CustomValidityState` because it is a leaky implementation and the user\n       * already has access to `ValidityState` in lib.dom.ts. Also an interface\n       * {a: Type} can be casted to {readonly a: Type} so passing any object\n       * should be fine.\n       */\n      const objectifiedCustomValidity: Partial<CustomValidityState> = {};\n\n      // eslint-disable-next-line guard-for-in\n      for (const propName in customValidity) {\n        /*\n         * Casting is needed because ValidityState's props are all readonly and\n         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the\n         * interface is the same as ValidityState (but not readonly), but the\n         * function signature casts the output to ValidityState (thus readonly).\n         */\n        objectifiedCustomValidity[propName as keyof CustomValidityState] =\n            customValidity[propName as keyof ValidityState];\n      }\n\n      return {\n        badInput: false,\n        customError: false,\n        patternMismatch: false,\n        rangeOverflow: false,\n        rangeUnderflow: false,\n        stepMismatch: false,\n        tooLong: false,\n        tooShort: false,\n        typeMismatch: false,\n        valid: true,\n        valueMissing: false,\n        ...objectifiedCustomValidity\n      };\n    };\n\n/**\n * @fires selected {SelectedDetail}\n * @fires action {ActionDetail}\n * @fires opened\n * @fires closed\n * @fires change\n * @fires invalid\n */\nexport abstract class SelectBase extends FormElement {\n  protected mdcFoundation!: MDCSelectFoundation;\n\n  protected readonly mdcFoundationClass = MDCSelectFoundation;\n\n  @query('.mdc-select') protected mdcRoot!: HTMLElement;\n\n  @query('.formElement') protected formElement!: HTMLInputElement;\n\n  @query('slot') protected slotElement!: HTMLSlotElement|null;\n\n  @query('select') protected nativeSelectElement!: HTMLSelectElement|null;\n\n  @query('input') protected nativeInputElement!: HTMLInputElement|null;\n\n  @query('.mdc-line-ripple') protected lineRippleElement!: LineRipple|null;\n\n  @query('.mdc-floating-label') protected labelElement!: FloatingLabel|null;\n\n  @query('mwc-notched-outline') protected outlineElement!: NotchedOutline|null;\n\n  @query('.mdc-menu') protected menuElement!: Menu|null;\n\n  @query('.mdc-select__anchor') protected anchorElement!: HTMLDivElement|null;\n\n  @property({type: Boolean, attribute: 'disabled', reflect: true})\n  @observer(function(this: SelectBase, value: boolean) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.setDisabled(value);\n    }\n  })\n  override disabled = false;\n\n  @property({type: Boolean})\n  @observer(function(this: SelectBase, _newVal: boolean, oldVal: boolean) {\n    if (oldVal !== undefined && this.outlined !== oldVal) {\n      this.layout(false);\n    }\n  })\n  outlined = false;\n\n  @property({type: String})\n  @observer(function(this: SelectBase, _newVal: string, oldVal: string) {\n    if (oldVal !== undefined && this.label !== oldVal) {\n      this.layout(false);\n    }\n  })\n  label = '';\n\n  @state() protected outlineOpen = false;\n\n  @state() protected outlineWidth = 0;\n\n  @property({type: String})\n  @observer(function(this: SelectBase, value: string) {\n    if (this.mdcFoundation) {\n      const initialization = this.selected === null && !!value;\n      const valueSetByUser = this.selected && this.selected.value !== value;\n\n      if (initialization || valueSetByUser) {\n        this.selectByValue(value);\n      }\n      this.reportValidity();\n    }\n  })\n  value = '';\n\n  @property() name = '';\n\n  @state() protected selectedText = '';\n\n  @property({type: String}) icon = '';\n\n  @state() protected menuOpen = false;\n\n  @property({type: String}) helper = '';\n\n  @property({type: Boolean}) validateOnInitialRender = false;\n\n  @property({type: String}) validationMessage = '';\n\n  @property({type: Boolean}) required = false;\n\n  @property({type: Boolean}) naturalMenuWidth = false;\n\n  @state() protected isUiValid = true;\n\n  @property({type: Boolean}) fixedMenuPosition = false;\n\n  // Transiently holds current typeahead prefix from user.\n  protected typeaheadState = typeahead.initState();\n  protected sortedIndexByFirstChar = new Map<string, MDCListTextAndIndex[]>();\n\n  protected menuElement_: Menu|null = null;\n\n  get items(): ListItemBase[] {\n    // memoize menuElement to prevent unnecessary querySelector calls.\n    if (!this.menuElement_) {\n      this.menuElement_ = this.menuElement;\n    }\n\n    if (this.menuElement_) {\n      return this.menuElement_.items;\n    }\n\n    return [];\n  }\n\n  get selected(): ListItemBase|null {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      return menuElement.selected as ListItemBase | null;\n    }\n\n    return null;\n  }\n\n  get index(): number {\n    const menuElement = this.menuElement;\n    if (menuElement) {\n      return menuElement.index as number;\n    }\n\n    return -1;\n  }\n\n  protected listeners: ({\n    target: Element;\n    name: string;\n    cb: EventListenerOrEventListenerObject;\n  })[] = [];\n  protected onBodyClickBound: (evt: MouseEvent) => void = () => undefined;\n  protected _menuUpdateComplete: null|Promise<unknown> = null;\n  protected get shouldRenderHelperText(): boolean {\n    return !!this.helper || !!this.validationMessage;\n  }\n\n  protected valueSetDirectly = false;\n\n  validityTransform:\n      ((value: string,\n        nativeValidity: ValidityState) => Partial<ValidityState>)|null = null;\n\n  protected _validity: ValidityState = createValidityObj();\n\n  get validity(): ValidityState {\n    this._checkValidity(this.value);\n\n    return this._validity;\n  }\n\n  override render() {\n    const classes = {\n      'mdc-select--disabled': this.disabled,\n      'mdc-select--no-label': !this.label,\n      'mdc-select--filled': !this.outlined,\n      'mdc-select--outlined': this.outlined,\n      'mdc-select--with-leading-icon': !!this.icon,\n      'mdc-select--required': this.required,\n      'mdc-select--invalid': !this.isUiValid,\n    };\n\n    const labelledby = !!this.label ? 'label' : undefined;\n    const describedby = this.shouldRenderHelperText ? 'helper-text' : undefined;\n\n    return html`\n      <div\n          class=\"mdc-select ${classMap(classes)}\">\n        <input\n            class=\"formElement\"\n            name=\"${this.name}\"\n            .value=\"${this.value}\"\n            hidden\n            ?disabled=\"${this.disabled}\"\n            ?required=${this.required}>\n        <!-- @ts-ignore -->\n        <div class=\"mdc-select__anchor\"\n            aria-autocomplete=\"none\"\n            role=\"combobox\"\n            aria-expanded=${this.menuOpen}\n            aria-invalid=${!this.isUiValid}\n            aria-haspopup=\"listbox\"\n            aria-labelledby=${ifDefined(labelledby)}\n            aria-required=${this.required}\n            aria-describedby=${ifDefined(describedby)}\n            @click=${this.onClick}\n            @focus=${this.onFocus}\n            @blur=${this.onBlur}\n            @keydown=${this.onKeydown}>\n          ${this.renderRipple()}\n          ${this.outlined ? this.renderOutline() : this.renderLabel()}\n          ${this.renderLeadingIcon()}\n          <span class=\"mdc-select__selected-text-container\">\n            <span class=\"mdc-select__selected-text\">${this.selectedText}</span>\n          </span>\n          <span class=\"mdc-select__dropdown-icon\">\n            <svg\n                class=\"mdc-select__dropdown-icon-graphic\"\n                viewBox=\"7 10 10 5\"\n                focusable=\"false\">\n              <polygon\n                  class=\"mdc-select__dropdown-icon-inactive\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 10 12 15 17 10\">\n              </polygon>\n              <polygon\n                  class=\"mdc-select__dropdown-icon-active\"\n                  stroke=\"none\"\n                  fill-rule=\"evenodd\"\n                  points=\"7 15 12 10 17 15\">\n              </polygon>\n            </svg>\n          </span>\n          ${this.renderLineRipple()}\n        </div>\n        ${this.renderMenu()}\n      </div>\n      ${this.renderHelperText()}`;\n  }\n\n  protected renderMenu() {\n    const classes = this.getMenuClasses();\n    return html`\n      <mwc-menu\n        innerRole=\"listbox\"\n        wrapFocus\n        class=\" ${classMap(classes)}\"\n        activatable\n        .fullwidth=${this.fixedMenuPosition ? false : !this.naturalMenuWidth}\n        .open=${this.menuOpen}\n        .anchor=${this.anchorElement}\n        .fixed=${this.fixedMenuPosition}\n        @selected=${this.onSelected}\n        @opened=${this.onOpened}\n        @closed=${this.onClosed}\n        @items-updated=${this.onItemsUpdated}\n        @keydown=${this.handleTypeahead}>\n      ${this.renderMenuContent()}\n    </mwc-menu>`;\n  }\n\n  protected getMenuClasses() {\n    return {\n      'mdc-select__menu': true,\n      'mdc-menu': true,\n      'mdc-menu-surface': true,\n      'mdc-select__menu--invalid': !this.isUiValid,\n    };\n  }\n\n  protected renderMenuContent() {\n    return html`<slot></slot>`;\n  }\n\n  protected renderRipple() {\n    if (this.outlined) {\n      return nothing;\n    }\n\n    return html`\n      <span class=\"mdc-select__ripple\"></span>\n    `;\n  }\n\n  protected renderOutline() {\n    if (!this.outlined) {\n      return nothing;\n    }\n\n    return html`\n      <mwc-notched-outline\n          .width=${this.outlineWidth}\n          .open=${this.outlineOpen}\n          class=\"mdc-notched-outline\">\n        ${this.renderLabel()}\n      </mwc-notched-outline>`;\n  }\n\n  protected renderLabel() {\n    if (!this.label) {\n      return nothing;\n    }\n\n    return html`\n      <span\n          .floatingLabelFoundation=${\n        floatingLabel(this.label) as unknown as MDCFloatingLabelFoundation}\n          id=\"label\">${this.label}</span>\n    `;\n  }\n\n  protected renderLeadingIcon() {\n    if (!this.icon) {\n      return nothing;\n    }\n\n    return html`<mwc-icon class=\"mdc-select__icon\"><div>${\n        this.icon}</div></mwc-icon>`;\n  }\n\n  protected renderLineRipple() {\n    if (this.outlined) {\n      return nothing;\n    }\n\n    return html`\n      <span .lineRippleFoundation=${\n        lineRipple() as unknown as MDCLineRippleFoundation}></span>\n    `;\n  }\n\n  protected renderHelperText() {\n    if (!this.shouldRenderHelperText) {\n      return nothing;\n    }\n\n    const showValidationMessage = this.validationMessage && !this.isUiValid;\n    const classes = {\n      'mdc-select-helper-text--validation-msg': showValidationMessage,\n    };\n\n    return html`\n        <p\n          class=\"mdc-select-helper-text ${classMap(classes)}\"\n          id=\"helper-text\">${\n        showValidationMessage ? this.validationMessage : this.helper}</p>`;\n  }\n\n  protected createAdapter(): MDCSelectAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      activateBottomLine: () => {\n        if (this.lineRippleElement) {\n          this.lineRippleElement.lineRippleFoundation.activate();\n        }\n      },\n      deactivateBottomLine: () => {\n        if (this.lineRippleElement) {\n          this.lineRippleElement.lineRippleFoundation.deactivate();\n        }\n      },\n      hasLabel: () => {\n        return !!this.label;\n      },\n      floatLabel: (shouldFloat) => {\n        if (this.labelElement) {\n          this.labelElement.floatingLabelFoundation.float(shouldFloat);\n        }\n      },\n      getLabelWidth: () => {\n        if (this.labelElement) {\n          return this.labelElement.floatingLabelFoundation.getWidth();\n        }\n\n        return 0;\n      },\n      setLabelRequired: (isRequired) => {\n        if (this.labelElement) {\n          this.labelElement.floatingLabelFoundation.setRequired(isRequired);\n        }\n      },\n      hasOutline: () => this.outlined,\n      notchOutline: (labelWidth) => {\n        const outlineElement = this.outlineElement;\n        if (outlineElement && !this.outlineOpen) {\n          this.outlineWidth = labelWidth;\n          this.outlineOpen = true;\n        }\n      },\n      closeOutline: () => {\n        if (this.outlineElement) {\n          this.outlineOpen = false;\n        }\n      },\n      setRippleCenter: (normalizedX) => {\n        if (this.lineRippleElement) {\n          const foundation = this.lineRippleElement.lineRippleFoundation;\n          foundation.setRippleCenter(normalizedX);\n        }\n      },\n      notifyChange: async (value) => {\n        if (!this.valueSetDirectly && value === this.value) {\n          return;\n        }\n\n        this.valueSetDirectly = false;\n        this.value = value;\n        await this.updateComplete;\n        const ev = new Event('change', {bubbles: true});\n        this.dispatchEvent(ev);\n      },\n      setSelectedText: (value) => this.selectedText = value,\n      isSelectAnchorFocused: () => {\n        const selectAnchorElement = this.anchorElement;\n\n        if (!selectAnchorElement) {\n          return false;\n        }\n\n        const rootNode =\n            selectAnchorElement.getRootNode() as ShadowRoot | Document;\n\n        return rootNode.activeElement === selectAnchorElement;\n      },\n      getSelectAnchorAttr: (attr) => {\n        const selectAnchorElement = this.anchorElement;\n\n        if (!selectAnchorElement) {\n          return null;\n        }\n\n        return selectAnchorElement.getAttribute(attr);\n      },\n      setSelectAnchorAttr: (attr, value) => {\n        const selectAnchorElement = this.anchorElement;\n\n        if (!selectAnchorElement) {\n          return;\n        }\n\n        selectAnchorElement.setAttribute(attr, value);\n      },\n      removeSelectAnchorAttr: (attr) => {\n        const selectAnchorElement = this.anchorElement;\n\n        if (!selectAnchorElement) {\n          return;\n        }\n\n        selectAnchorElement.removeAttribute(attr);\n      },\n      openMenu: () => {\n        this.menuOpen = true;\n      },\n      closeMenu: () => {\n        this.menuOpen = false;\n      },\n      addMenuClass: () => undefined,\n      removeMenuClass: () => undefined,\n      getAnchorElement: () => this.anchorElement,\n      setMenuAnchorElement: () => {\n          /* Handled by anchor directive */\n      },\n      setMenuAnchorCorner: () => {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n          menuElement.corner = 'BOTTOM_START';\n        }\n      },\n      setMenuWrapFocus: (wrapFocus) => {\n        const menuElement = this.menuElement;\n        if (menuElement) {\n          menuElement.wrapFocus = wrapFocus;\n        }\n      },\n      focusMenuItemAtIndex: (index) => {\n        const menuElement = this.menuElement;\n        if (!menuElement) {\n          return;\n        }\n\n        const element = menuElement.items[index];\n\n        if (!element) {\n          return;\n        }\n\n        (element as HTMLElement).focus();\n      },\n      getMenuItemCount: () => {\n        const menuElement = this.menuElement;\n\n        if (menuElement) {\n          return menuElement.items.length;\n        }\n\n        return 0;\n      },\n      getMenuItemValues: () => {\n        const menuElement = this.menuElement;\n\n        if (!menuElement) {\n          return [];\n        }\n\n        const items = menuElement.items;\n\n        return items.map((item) => item.value);\n      },\n      getMenuItemTextAtIndex: (index) => {\n        const menuElement = this.menuElement;\n        if (!menuElement) {\n          return '';\n        }\n\n        const element = menuElement.items[index];\n\n        if (!element) {\n          return '';\n        }\n\n        return element.text;\n      },\n      getSelectedIndex: () => this.index,\n      setSelectedIndex: () => undefined,\n      isTypeaheadInProgress: () =>\n          typeahead.isTypingInProgress(this.typeaheadState),\n      typeaheadMatchItem: (nextChar, startingIndex) => {\n        if (!this.menuElement) {\n          return -1;\n        }\n\n        const opts: typeahead.TypeaheadMatchItemOpts = {\n          focusItemAtIndex: (index) => {\n            this.menuElement!.focusItemAtIndex(index);\n          },\n          focusedItemIndex: startingIndex ?\n              startingIndex :\n              this.menuElement.getFocusedItemIndex(),\n          nextChar,\n          sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n          skipFocus: false,\n          isItemAtIndexDisabled: (index) => this.items[index].disabled,\n        };\n\n        const index = typeahead.matchItem(opts, this.typeaheadState);\n\n        if (index !== -1) {\n          this.select(index);\n        }\n\n        return index;\n      },\n    };\n  }\n\n  checkValidity(): boolean {\n    const isValid = this._checkValidity(this.value);\n\n    if (!isValid) {\n      const invalidEvent =\n          new Event('invalid', {bubbles: false, cancelable: true});\n      this.dispatchEvent(invalidEvent);\n    }\n\n    return isValid;\n  }\n\n  reportValidity(): boolean {\n    const isValid = this.checkValidity();\n\n    this.isUiValid = isValid;\n\n    return isValid;\n  }\n\n  protected _checkValidity(value: string) {\n    const nativeValidity = this.formElement.validity;\n\n    let validity = createValidityObj(nativeValidity);\n\n    if (this.validityTransform) {\n      const customValidity = this.validityTransform(value, validity);\n      validity = {...validity, ...customValidity};\n    }\n\n    this._validity = validity;\n\n    return this._validity.valid;\n  }\n\n  setCustomValidity(message: string) {\n    this.validationMessage = message;\n    this.formElement.setCustomValidity(message);\n  }\n\n  // tslint:disable:ban-ts-ignore\n  protected override async getUpdateComplete() {\n    await this._menuUpdateComplete;\n    // @ts-ignore\n    const result = await super.getUpdateComplete();\n    return result;\n  }\n  // tslint:enable:ban-ts-ignore\n\n  protected override async firstUpdated() {\n    const menuElement = this.menuElement;\n\n    if (menuElement) {\n      this._menuUpdateComplete = menuElement.updateComplete;\n      await this._menuUpdateComplete;\n    }\n\n    super.firstUpdated();\n\n    this.mdcFoundation.isValid = () => true;\n    this.mdcFoundation.setValid = () => undefined;\n    this.mdcFoundation.setDisabled(this.disabled);\n\n    if (this.validateOnInitialRender) {\n      this.reportValidity();\n    }\n\n    // Select an option based on init value\n    if (!this.selected) {\n      if (!this.items.length && this.slotElement &&\n          this.slotElement.assignedNodes({flatten: true}).length) {\n        // Shady DOM initial render fix\n        await new Promise((res) => requestAnimationFrame(res));\n        await this.layout();\n      }\n\n      const hasEmptyFirstOption =\n          this.items.length && this.items[0].value === '';\n      if (!this.value && hasEmptyFirstOption) {\n        this.select(0);\n        return;\n      }\n\n      this.selectByValue(this.value);\n    }\n\n    this.sortedIndexByFirstChar = typeahead.initSortedIndex(\n        this.items.length, (index) => this.items[index].text);\n  }\n\n  protected onItemsUpdated() {\n    this.sortedIndexByFirstChar = typeahead.initSortedIndex(\n        this.items.length, (index) => this.items[index].text);\n  }\n\n  select(index: number) {\n    const menuElement = this.menuElement;\n\n    if (menuElement) {\n      menuElement.select(index);\n    }\n  }\n\n  protected selectByValue(value: string) {\n    let indexToSelect = -1;\n    for (let i = 0; i < this.items.length; i++) {\n      const item = this.items[i];\n      if (item.value === value) {\n        indexToSelect = i;\n        break;\n      }\n    }\n    this.valueSetDirectly = true;\n    this.select(indexToSelect);\n    this.mdcFoundation.handleChange();\n  }\n\n  override disconnectedCallback() {\n    super.disconnectedCallback();\n\n    for (const listener of this.listeners) {\n      listener.target.removeEventListener(listener.name, listener.cb);\n    }\n  }\n\n  override focus() {\n    const focusEvt = new CustomEvent('focus');\n    const selectAnchorElement = this.anchorElement;\n\n    if (selectAnchorElement) {\n      selectAnchorElement.dispatchEvent(focusEvt);\n      selectAnchorElement.focus();\n    }\n  }\n\n  override blur() {\n    const focusEvt = new CustomEvent('blur');\n    const selectAnchorElement = this.anchorElement;\n\n    if (selectAnchorElement) {\n      selectAnchorElement.dispatchEvent(focusEvt);\n      selectAnchorElement.blur();\n    }\n  }\n\n  protected onFocus() {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleFocus();\n    }\n  }\n\n  protected onBlur() {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.handleBlur();\n    }\n\n    const menuElement = this.menuElement;\n\n    if (menuElement && !menuElement.open) {\n      this.reportValidity();\n    }\n  }\n\n  protected onClick(evt: MouseEvent|TouchEvent) {\n    if (this.mdcFoundation) {\n      this.focus();\n      const targetClientRect = (evt.target as Element).getBoundingClientRect();\n      let xCoord = 0;\n\n      if ('touches' in evt) {\n        xCoord = evt.touches[0].clientX;\n      } else {\n        xCoord = evt.clientX;\n      }\n\n      const normalizedX = xCoord - targetClientRect.left;\n      this.mdcFoundation.handleClick(normalizedX);\n    }\n  }\n\n  protected onKeydown(evt: KeyboardEvent) {\n    const arrowUp = normalizeKey(evt) === KEY.ARROW_UP;\n    const arrowDown = normalizeKey(evt) === KEY.ARROW_DOWN;\n\n    if (arrowDown || arrowUp) {\n      const shouldSelectNextItem = arrowUp && this.index > 0;\n      const shouldSelectPrevItem =\n          arrowDown && this.index < this.items.length - 1;\n\n      if (shouldSelectNextItem) {\n        this.select(this.index - 1);\n      } else if (shouldSelectPrevItem) {\n        this.select(this.index + 1);\n      }\n      evt.preventDefault();\n\n      this.mdcFoundation.openMenu();\n      return;\n    }\n\n    this.mdcFoundation.handleKeydown(evt);\n  }\n\n  // must capture to run before list foundation captures event\n  @eventOptions({capture: true})\n  protected handleTypeahead(event: KeyboardEvent) {\n    if (!this.menuElement) {\n      return;\n    }\n\n    const focusedItemIndex = this.menuElement.getFocusedItemIndex();\n    const target = isNodeElement(event.target as Node) ?\n        event.target as HTMLElement :\n        null;\n    const isTargetListItem =\n        target ? target.hasAttribute('mwc-list-item') : false;\n\n    const opts: typeahead.HandleKeydownOpts = {\n      event,\n      focusItemAtIndex: (index) => {\n        this.menuElement!.focusItemAtIndex(index);\n      },\n      focusedItemIndex,\n      isTargetListItem,\n      sortedIndexByFirstChar: this.sortedIndexByFirstChar,\n      isItemAtIndexDisabled: (index) => this.items[index].disabled,\n    };\n\n    typeahead.handleKeydown(opts, this.typeaheadState);\n  }\n\n  protected async onSelected(event: CustomEvent<{index: number}>) {\n    if (!this.mdcFoundation) {\n      await this.updateComplete;\n    }\n\n    this.mdcFoundation.handleMenuItemAction(event.detail.index);\n    const item = this.items[event.detail.index];\n    if (item) {\n      this.value = item.value;\n    }\n  }\n\n  protected onOpened() {\n    if (this.mdcFoundation) {\n      this.menuOpen = true;\n      this.mdcFoundation.handleMenuOpened();\n    }\n  }\n\n  protected onClosed() {\n    if (this.mdcFoundation) {\n      this.menuOpen = false;\n      this.mdcFoundation.handleMenuClosed();\n    }\n  }\n\n  protected setFormData(formData: FormData) {\n    if (this.name && this.selected !== null) {\n      formData.append(this.name, this.value);\n    }\n  }\n\n  async layout(updateItems = true) {\n    if (this.mdcFoundation) {\n      this.mdcFoundation.layout();\n    }\n\n    await this.updateComplete;\n\n    const menuElement = this.menuElement;\n\n    if (menuElement) {\n      menuElement.layout(updateItems);\n    }\n\n    const labelElement = this.labelElement;\n\n    if (!labelElement) {\n      this.outlineOpen = false;\n      return;\n    }\n\n    const shouldFloat = !!this.label && !!this.value;\n    labelElement.floatingLabelFoundation.float(shouldFloat);\n\n    if (!this.outlined) {\n      return;\n    }\n\n    this.outlineOpen = shouldFloat;\n    await this.updateComplete;\n\n    /* When the textfield automatically notches due to a value and label\n     * being defined, the textfield may be set to `display: none` by the user.\n     * this means that the notch is of size 0px. We provide this function so\n     * that the user may manually resize the notch to the floated label's\n     * width.\n     */\n    const labelWidth = labelElement.floatingLabelFoundation.getWidth();\n    if (this.outlineOpen) {\n      this.outlineWidth = labelWidth;\n    }\n  }\n\n  async layoutOptions() {\n    if (!this.mdcFoundation) {\n      return;\n    }\n\n    this.mdcFoundation.layoutOptions();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}