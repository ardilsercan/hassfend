{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages.js\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors.js\";\nvar DEBUG = false;\nexport var Connection = /*#__PURE__*/function () {\n  function Connection(socket, options) {\n    var _this = this;\n    _classCallCheck(this, Connection);\n    this._handleMessage = function (event) {\n      var messageGroup = JSON.parse(event.data);\n      if (!Array.isArray(messageGroup)) {\n        messageGroup = [messageGroup];\n      }\n      messageGroup.forEach(function (message) {\n        if (DEBUG) {\n          console.log(\"Received\", message);\n        }\n        var info = _this.commands.get(message.id);\n        switch (message.type) {\n          case \"event\":\n            if (info) {\n              info.callback(message.event);\n            } else {\n              console.warn(\"Received event for unknown subscription \".concat(message.id, \". Unsubscribing.\"));\n              _this.sendMessagePromise(messages.unsubscribeEvents(message.id)).catch(function (err) {\n                if (DEBUG) {\n                  console.warn(\" Error unsubsribing from unknown subscription \".concat(message.id), err);\n                }\n              });\n            }\n            break;\n          case \"result\":\n            // No info is fine. If just sendMessage is used, we did not store promise for result\n            if (info) {\n              if (message.success) {\n                info.resolve(message.result);\n                // Don't remove subscriptions.\n                if (!(\"subscribe\" in info)) {\n                  _this.commands.delete(message.id);\n                }\n              } else {\n                info.reject(message.error);\n                _this.commands.delete(message.id);\n              }\n            }\n            break;\n          case \"pong\":\n            if (info) {\n              info.resolve();\n              _this.commands.delete(message.id);\n            } else {\n              console.warn(\"Received unknown pong response \".concat(message.id));\n            }\n            break;\n          default:\n            if (DEBUG) {\n              console.warn(\"Unhandled message\", message);\n            }\n        }\n      });\n    };\n    this._handleClose = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var oldCommands, options, reconnect;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            oldCommands = _this.commands; // reset to original state except haVersion\n            _this.commandId = 1;\n            _this.oldSubscriptions = _this.commands;\n            _this.commands = new Map();\n            _this.socket = undefined;\n            // Reject in-flight sendMessagePromise requests\n            oldCommands.forEach(function (info) {\n              // We don't cancel subscribeEvents commands in flight\n              // as we will be able to recover them.\n              if (!(\"subscribe\" in info)) {\n                info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n              }\n            });\n            if (!_this.closeRequested) {\n              _context2.next = 8;\n              break;\n            }\n            return _context2.abrupt(\"return\");\n          case 8:\n            _this.fireEvent(\"disconnected\");\n            // Disable setupRetry, we control it here with auto-backoff\n            options = Object.assign(Object.assign({}, _this.options), {\n              setupRetry: 0\n            });\n            reconnect = function reconnect(tries) {\n              setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                var _socket, queuedMessages, _iterator, _step, msg;\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!_this.closeRequested) {\n                        _context.next = 2;\n                        break;\n                      }\n                      return _context.abrupt(\"return\");\n                    case 2:\n                      if (DEBUG) {\n                        console.log(\"Trying to reconnect\");\n                      }\n                      _context.prev = 3;\n                      _context.next = 6;\n                      return options.createSocket(options);\n                    case 6:\n                      _socket = _context.sent;\n                      _this._setSocket(_socket);\n                      _context.next = 14;\n                      break;\n                    case 10:\n                      _context.prev = 10;\n                      _context.t0 = _context[\"catch\"](3);\n                      if (_this._queuedMessages) {\n                        queuedMessages = _this._queuedMessages;\n                        _this._queuedMessages = undefined;\n                        _iterator = _createForOfIteratorHelper(queuedMessages);\n                        try {\n                          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                            msg = _step.value;\n                            if (msg.reject) {\n                              msg.reject(ERR_CONNECTION_LOST);\n                            }\n                          }\n                        } catch (err) {\n                          _iterator.e(err);\n                        } finally {\n                          _iterator.f();\n                        }\n                      }\n                      if (_context.t0 === ERR_INVALID_AUTH) {\n                        _this.fireEvent(\"reconnect-error\", _context.t0);\n                      } else {\n                        reconnect(tries + 1);\n                      }\n                    case 14:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee, null, [[3, 10]]);\n              })), Math.min(tries, 5) * 1000);\n            };\n            if (!_this.suspendReconnectPromise) {\n              _context2.next = 16;\n              break;\n            }\n            _context2.next = 14;\n            return _this.suspendReconnectPromise;\n          case 14:\n            _this.suspendReconnectPromise = undefined;\n            // For the first retry after suspend, we will queue up\n            // all messages.\n            _this._queuedMessages = [];\n          case 16:\n            reconnect(0);\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    // connection options\n    //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n    //  - createSocket: create a new Socket connection\n    this.options = options;\n    // id if next command to send\n    this.commandId = 2; // socket may send 1 at the start to enable features\n    // info about active subscriptions and commands in flight\n    this.commands = new Map();\n    // map of event listeners\n    this.eventListeners = new Map();\n    // true if a close is requested by the user\n    this.closeRequested = false;\n    this._setSocket(socket);\n  }\n  _createClass(Connection, [{\n    key: \"connected\",\n    get: function get() {\n      // Using conn.socket.OPEN instead of WebSocket for better node support\n      return this.socket !== undefined && this.socket.readyState == this.socket.OPEN;\n    }\n  }, {\n    key: \"_setSocket\",\n    value: function _setSocket(socket) {\n      this.socket = socket;\n      this.haVersion = socket.haVersion;\n      socket.addEventListener(\"message\", this._handleMessage);\n      socket.addEventListener(\"close\", this._handleClose);\n      var oldSubscriptions = this.oldSubscriptions;\n      if (oldSubscriptions) {\n        this.oldSubscriptions = undefined;\n        oldSubscriptions.forEach(function (info) {\n          if (\"subscribe\" in info && info.subscribe) {\n            info.subscribe().then(function (unsub) {\n              info.unsubscribe = unsub;\n              // We need to resolve this in case it wasn't resolved yet.\n              // This allows us to subscribe while we're disconnected\n              // and recover properly.\n              info.resolve();\n            });\n          }\n        });\n      }\n      var queuedMessages = this._queuedMessages;\n      if (queuedMessages) {\n        this._queuedMessages = undefined;\n        var _iterator2 = _createForOfIteratorHelper(queuedMessages),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var queuedMsg = _step2.value;\n            queuedMsg.resolve();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      this.fireEvent(\"ready\");\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(eventType, callback) {\n      var listeners = this.eventListeners.get(eventType);\n      if (!listeners) {\n        listeners = [];\n        this.eventListeners.set(eventType, listeners);\n      }\n      listeners.push(callback);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(eventType, callback) {\n      var listeners = this.eventListeners.get(eventType);\n      if (!listeners) {\n        return;\n      }\n      var index = listeners.indexOf(callback);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"fireEvent\",\n    value: function fireEvent(eventType, eventData) {\n      var _this2 = this;\n      (this.eventListeners.get(eventType) || []).forEach(function (callback) {\n        return callback(_this2, eventData);\n      });\n    }\n  }, {\n    key: \"suspendReconnectUntil\",\n    value: function suspendReconnectUntil(suspendPromise) {\n      this.suspendReconnectPromise = suspendPromise;\n    }\n  }, {\n    key: \"suspend\",\n    value: function suspend() {\n      if (!this.suspendReconnectPromise) {\n        throw new Error(\"Suspend promise not set\");\n      }\n      if (this.socket) {\n        this.socket.close();\n      }\n    }\n    /**\n     * Reconnect the websocket connection.\n     * @param force discard old socket instead of gracefully closing it.\n     */\n  }, {\n    key: \"reconnect\",\n    value: function reconnect() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this.socket) {\n        return;\n      }\n      if (!force) {\n        this.socket.close();\n        return;\n      }\n      this.socket.removeEventListener(\"message\", this._handleMessage);\n      this.socket.removeEventListener(\"close\", this._handleClose);\n      this.socket.close();\n      this._handleClose();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.closeRequested = true;\n      if (this.socket) {\n        this.socket.close();\n      }\n    }\n    /**\n     * Subscribe to a specific or all events.\n     *\n     * @param callback Callback  to be called when a new event fires\n     * @param eventType\n     * @returns promise that resolves to an unsubscribe function\n     */\n  }, {\n    key: \"subscribeEvents\",\n    value: (function () {\n      var _subscribeEvents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(callback, eventType) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", this.subscribeMessage(callback, messages.subscribeEvents(eventType)));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function subscribeEvents(_x, _x2) {\n        return _subscribeEvents.apply(this, arguments);\n      }\n      return subscribeEvents;\n    }())\n  }, {\n    key: \"ping\",\n    value: function ping() {\n      return this.sendMessagePromise(messages.ping());\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message, commandId) {\n      var _this3 = this;\n      if (!this.connected) {\n        throw ERR_CONNECTION_LOST;\n      }\n      if (DEBUG) {\n        console.log(\"Sending\", message);\n      }\n      if (this._queuedMessages) {\n        if (commandId) {\n          throw new Error(\"Cannot queue with commandId\");\n        }\n        this._queuedMessages.push({\n          resolve: function resolve() {\n            return _this3.sendMessage(message);\n          }\n        });\n        return;\n      }\n      if (!commandId) {\n        commandId = this._genCmdId();\n      }\n      message.id = commandId;\n      this.socket.send(JSON.stringify(message));\n    }\n  }, {\n    key: \"sendMessagePromise\",\n    value: function sendMessagePromise(message) {\n      var _this4 = this;\n      return new Promise(function (_resolve, reject) {\n        if (_this4._queuedMessages) {\n          _this4._queuedMessages.push({\n            reject: reject,\n            resolve: function () {\n              var _resolve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.prev = 0;\n                      _context4.t0 = _resolve;\n                      _context4.next = 4;\n                      return _this4.sendMessagePromise(message);\n                    case 4:\n                      _context4.t1 = _context4.sent;\n                      (0, _context4.t0)(_context4.t1);\n                      _context4.next = 11;\n                      break;\n                    case 8:\n                      _context4.prev = 8;\n                      _context4.t2 = _context4[\"catch\"](0);\n                      reject(_context4.t2);\n                    case 11:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4, null, [[0, 8]]);\n              }));\n              function resolve() {\n                return _resolve2.apply(this, arguments);\n              }\n              return resolve;\n            }()\n          });\n          return;\n        }\n        var commandId = _this4._genCmdId();\n        _this4.commands.set(commandId, {\n          resolve: _resolve,\n          reject: reject\n        });\n        _this4.sendMessage(message, commandId);\n      });\n    }\n    /**\n     * Call a websocket command that starts a subscription on the backend.\n     *\n     * @param message the message to start the subscription\n     * @param callback the callback to be called when a new item arrives\n     * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n     * @returns promise that resolves to an unsubscribe function\n     */\n  }, {\n    key: \"subscribeMessage\",\n    value: (function () {\n      var _subscribeMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(callback, _subscribeMessage, options) {\n        var _this5 = this;\n        var info;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!this._queuedMessages) {\n                _context6.next = 3;\n                break;\n              }\n              _context6.next = 3;\n              return new Promise(function (resolve, reject) {\n                _this5._queuedMessages.push({\n                  resolve: resolve,\n                  reject: reject\n                });\n              });\n            case 3:\n              _context6.next = 5;\n              return new Promise(function (resolve, reject) {\n                // Command ID that will be used\n                var commandId = _this5._genCmdId();\n                // We store unsubscribe on info object. That way we can overwrite it in case\n                // we get disconnected and we have to subscribe again.\n                info = {\n                  resolve: resolve,\n                  reject: reject,\n                  callback: callback,\n                  subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false ? function () {\n                    return _this5.subscribeMessage(callback, _subscribeMessage);\n                  } : undefined,\n                  unsubscribe: function () {\n                    var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n                      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n                        while (1) switch (_context5.prev = _context5.next) {\n                          case 0:\n                            if (!_this5.connected) {\n                              _context5.next = 3;\n                              break;\n                            }\n                            _context5.next = 3;\n                            return _this5.sendMessagePromise(messages.unsubscribeEvents(commandId));\n                          case 3:\n                            _this5.commands.delete(commandId);\n                          case 4:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }, _callee5);\n                    }));\n                    function unsubscribe() {\n                      return _unsubscribe.apply(this, arguments);\n                    }\n                    return unsubscribe;\n                  }()\n                };\n                _this5.commands.set(commandId, info);\n                try {\n                  _this5.sendMessage(_subscribeMessage, commandId);\n                } catch (err) {\n                  // Happens when the websocket is already closing.\n                  // Don't have to handle the error, reconnect logic will pick it up.\n                }\n              });\n            case 5:\n              return _context6.abrupt(\"return\", function () {\n                return info.unsubscribe();\n              });\n            case 6:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function subscribeMessage(_x3, _x4, _x5) {\n        return _subscribeMessage2.apply(this, arguments);\n      }\n      return subscribeMessage;\n    }())\n  }, {\n    key: \"_genCmdId\",\n    value: function _genCmdId() {\n      return ++this.commandId;\n    }\n  }]);\n  return Connection;\n}();","map":{"version":3,"names":["messages","ERR_INVALID_AUTH","ERR_CONNECTION_LOST","DEBUG","Connection","socket","options","_this","_classCallCheck","_handleMessage","event","messageGroup","JSON","parse","data","Array","isArray","forEach","message","console","log","info","commands","get","id","type","callback","warn","concat","sendMessagePromise","unsubscribeEvents","catch","err","success","resolve","result","delete","reject","error","_handleClose","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","oldCommands","reconnect","wrap","_callee2$","_context2","prev","next","commandId","oldSubscriptions","Map","undefined","closeRequested","abrupt","fireEvent","Object","assign","setupRetry","tries","setTimeout","_callee","_socket","queuedMessages","_iterator","_step","msg","_callee$","_context","createSocket","sent","_setSocket","t0","_queuedMessages","_createForOfIteratorHelper","s","n","done","value","e","f","stop","Math","min","suspendReconnectPromise","eventListeners","_createClass","key","readyState","OPEN","haVersion","addEventListener","subscribe","then","unsub","unsubscribe","_iterator2","_step2","queuedMsg","eventType","listeners","set","push","removeEventListener","index","indexOf","splice","eventData","_this2","suspendReconnectUntil","suspendPromise","suspend","Error","close","force","arguments","length","_subscribeEvents","_callee3","_callee3$","_context3","subscribeMessage","subscribeEvents","_x","_x2","apply","ping","sendMessage","_this3","connected","_genCmdId","send","stringify","_this4","Promise","_resolve2","_callee4","_callee4$","_context4","t1","t2","_subscribeMessage2","_callee6","_this5","_callee6$","_context6","resubscribe","_unsubscribe","_callee5","_callee5$","_context5","_x3","_x4","_x5"],"sources":["/workspaces/frontend/node_modules/home-assistant-js-websocket/dist/connection.js"],"sourcesContent":["/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages.js\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors.js\";\nconst DEBUG = false;\nexport class Connection {\n    constructor(socket, options) {\n        this._handleMessage = (event) => {\n            let messageGroup = JSON.parse(event.data);\n            if (!Array.isArray(messageGroup)) {\n                messageGroup = [messageGroup];\n            }\n            messageGroup.forEach((message) => {\n                if (DEBUG) {\n                    console.log(\"Received\", message);\n                }\n                const info = this.commands.get(message.id);\n                switch (message.type) {\n                    case \"event\":\n                        if (info) {\n                            info.callback(message.event);\n                        }\n                        else {\n                            console.warn(`Received event for unknown subscription ${message.id}. Unsubscribing.`);\n                            this.sendMessagePromise(messages.unsubscribeEvents(message.id)).catch((err) => {\n                                if (DEBUG) {\n                                    console.warn(` Error unsubsribing from unknown subscription ${message.id}`, err);\n                                }\n                            });\n                        }\n                        break;\n                    case \"result\":\n                        // No info is fine. If just sendMessage is used, we did not store promise for result\n                        if (info) {\n                            if (message.success) {\n                                info.resolve(message.result);\n                                // Don't remove subscriptions.\n                                if (!(\"subscribe\" in info)) {\n                                    this.commands.delete(message.id);\n                                }\n                            }\n                            else {\n                                info.reject(message.error);\n                                this.commands.delete(message.id);\n                            }\n                        }\n                        break;\n                    case \"pong\":\n                        if (info) {\n                            info.resolve();\n                            this.commands.delete(message.id);\n                        }\n                        else {\n                            console.warn(`Received unknown pong response ${message.id}`);\n                        }\n                        break;\n                    default:\n                        if (DEBUG) {\n                            console.warn(\"Unhandled message\", message);\n                        }\n                }\n            });\n        };\n        this._handleClose = async () => {\n            const oldCommands = this.commands;\n            // reset to original state except haVersion\n            this.commandId = 1;\n            this.oldSubscriptions = this.commands;\n            this.commands = new Map();\n            this.socket = undefined;\n            // Reject in-flight sendMessagePromise requests\n            oldCommands.forEach((info) => {\n                // We don't cancel subscribeEvents commands in flight\n                // as we will be able to recover them.\n                if (!(\"subscribe\" in info)) {\n                    info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n                }\n            });\n            if (this.closeRequested) {\n                return;\n            }\n            this.fireEvent(\"disconnected\");\n            // Disable setupRetry, we control it here with auto-backoff\n            const options = Object.assign(Object.assign({}, this.options), { setupRetry: 0 });\n            const reconnect = (tries) => {\n                setTimeout(async () => {\n                    if (this.closeRequested) {\n                        return;\n                    }\n                    if (DEBUG) {\n                        console.log(\"Trying to reconnect\");\n                    }\n                    try {\n                        const socket = await options.createSocket(options);\n                        this._setSocket(socket);\n                    }\n                    catch (err) {\n                        if (this._queuedMessages) {\n                            const queuedMessages = this._queuedMessages;\n                            this._queuedMessages = undefined;\n                            for (const msg of queuedMessages) {\n                                if (msg.reject) {\n                                    msg.reject(ERR_CONNECTION_LOST);\n                                }\n                            }\n                        }\n                        if (err === ERR_INVALID_AUTH) {\n                            this.fireEvent(\"reconnect-error\", err);\n                        }\n                        else {\n                            reconnect(tries + 1);\n                        }\n                    }\n                }, Math.min(tries, 5) * 1000);\n            };\n            if (this.suspendReconnectPromise) {\n                await this.suspendReconnectPromise;\n                this.suspendReconnectPromise = undefined;\n                // For the first retry after suspend, we will queue up\n                // all messages.\n                this._queuedMessages = [];\n            }\n            reconnect(0);\n        };\n        // connection options\n        //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n        //  - createSocket: create a new Socket connection\n        this.options = options;\n        // id if next command to send\n        this.commandId = 2; // socket may send 1 at the start to enable features\n        // info about active subscriptions and commands in flight\n        this.commands = new Map();\n        // map of event listeners\n        this.eventListeners = new Map();\n        // true if a close is requested by the user\n        this.closeRequested = false;\n        this._setSocket(socket);\n    }\n    get connected() {\n        // Using conn.socket.OPEN instead of WebSocket for better node support\n        return (this.socket !== undefined && this.socket.readyState == this.socket.OPEN);\n    }\n    _setSocket(socket) {\n        this.socket = socket;\n        this.haVersion = socket.haVersion;\n        socket.addEventListener(\"message\", this._handleMessage);\n        socket.addEventListener(\"close\", this._handleClose);\n        const oldSubscriptions = this.oldSubscriptions;\n        if (oldSubscriptions) {\n            this.oldSubscriptions = undefined;\n            oldSubscriptions.forEach((info) => {\n                if (\"subscribe\" in info && info.subscribe) {\n                    info.subscribe().then((unsub) => {\n                        info.unsubscribe = unsub;\n                        // We need to resolve this in case it wasn't resolved yet.\n                        // This allows us to subscribe while we're disconnected\n                        // and recover properly.\n                        info.resolve();\n                    });\n                }\n            });\n        }\n        const queuedMessages = this._queuedMessages;\n        if (queuedMessages) {\n            this._queuedMessages = undefined;\n            for (const queuedMsg of queuedMessages) {\n                queuedMsg.resolve();\n            }\n        }\n        this.fireEvent(\"ready\");\n    }\n    addEventListener(eventType, callback) {\n        let listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            listeners = [];\n            this.eventListeners.set(eventType, listeners);\n        }\n        listeners.push(callback);\n    }\n    removeEventListener(eventType, callback) {\n        const listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(callback);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    }\n    fireEvent(eventType, eventData) {\n        (this.eventListeners.get(eventType) || []).forEach((callback) => callback(this, eventData));\n    }\n    suspendReconnectUntil(suspendPromise) {\n        this.suspendReconnectPromise = suspendPromise;\n    }\n    suspend() {\n        if (!this.suspendReconnectPromise) {\n            throw new Error(\"Suspend promise not set\");\n        }\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Reconnect the websocket connection.\n     * @param force discard old socket instead of gracefully closing it.\n     */\n    reconnect(force = false) {\n        if (!this.socket) {\n            return;\n        }\n        if (!force) {\n            this.socket.close();\n            return;\n        }\n        this.socket.removeEventListener(\"message\", this._handleMessage);\n        this.socket.removeEventListener(\"close\", this._handleClose);\n        this.socket.close();\n        this._handleClose();\n    }\n    close() {\n        this.closeRequested = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Subscribe to a specific or all events.\n     *\n     * @param callback Callback  to be called when a new event fires\n     * @param eventType\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeEvents(callback, eventType) {\n        return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n    }\n    ping() {\n        return this.sendMessagePromise(messages.ping());\n    }\n    sendMessage(message, commandId) {\n        if (!this.connected) {\n            throw ERR_CONNECTION_LOST;\n        }\n        if (DEBUG) {\n            console.log(\"Sending\", message);\n        }\n        if (this._queuedMessages) {\n            if (commandId) {\n                throw new Error(\"Cannot queue with commandId\");\n            }\n            this._queuedMessages.push({ resolve: () => this.sendMessage(message) });\n            return;\n        }\n        if (!commandId) {\n            commandId = this._genCmdId();\n        }\n        message.id = commandId;\n        this.socket.send(JSON.stringify(message));\n    }\n    sendMessagePromise(message) {\n        return new Promise((resolve, reject) => {\n            if (this._queuedMessages) {\n                this._queuedMessages.push({\n                    reject,\n                    resolve: async () => {\n                        try {\n                            resolve(await this.sendMessagePromise(message));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    },\n                });\n                return;\n            }\n            const commandId = this._genCmdId();\n            this.commands.set(commandId, { resolve, reject });\n            this.sendMessage(message, commandId);\n        });\n    }\n    /**\n     * Call a websocket command that starts a subscription on the backend.\n     *\n     * @param message the message to start the subscription\n     * @param callback the callback to be called when a new item arrives\n     * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeMessage(callback, subscribeMessage, options) {\n        if (this._queuedMessages) {\n            await new Promise((resolve, reject) => {\n                this._queuedMessages.push({ resolve, reject });\n            });\n        }\n        let info;\n        await new Promise((resolve, reject) => {\n            // Command ID that will be used\n            const commandId = this._genCmdId();\n            // We store unsubscribe on info object. That way we can overwrite it in case\n            // we get disconnected and we have to subscribe again.\n            info = {\n                resolve,\n                reject,\n                callback,\n                subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false\n                    ? () => this.subscribeMessage(callback, subscribeMessage)\n                    : undefined,\n                unsubscribe: async () => {\n                    // No need to unsubscribe if we're disconnected\n                    if (this.connected) {\n                        await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n                    }\n                    this.commands.delete(commandId);\n                },\n            };\n            this.commands.set(commandId, info);\n            try {\n                this.sendMessage(subscribeMessage, commandId);\n            }\n            catch (err) {\n                // Happens when the websocket is already closing.\n                // Don't have to handle the error, reconnect logic will pick it up.\n            }\n        });\n        return () => info.unsubscribe();\n    }\n    _genCmdId() {\n        return ++this.commandId;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,QAAQ,MAAM,eAAe;AACzC,SAASC,gBAAgB,EAAEC,mBAAmB,QAAQ,aAAa;AACnE,IAAMC,KAAK,GAAG,KAAK;AACnB,WAAaC,UAAU;EACnB,SAAAA,WAAYC,MAAM,EAAEC,OAAO,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAJ,UAAA;IACzB,IAAI,CAACK,cAAc,GAAG,UAACC,KAAK,EAAK;MAC7B,IAAIC,YAAY,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACI,IAAI,CAAC;MACzC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACL,YAAY,CAAC,EAAE;QAC9BA,YAAY,GAAG,CAACA,YAAY,CAAC;MACjC;MACAA,YAAY,CAACM,OAAO,CAAC,UAACC,OAAO,EAAK;QAC9B,IAAIf,KAAK,EAAE;UACPgB,OAAO,CAACC,GAAG,CAAC,UAAU,EAAEF,OAAO,CAAC;QACpC;QACA,IAAMG,IAAI,GAAGd,KAAI,CAACe,QAAQ,CAACC,GAAG,CAACL,OAAO,CAACM,EAAE,CAAC;QAC1C,QAAQN,OAAO,CAACO,IAAI;UAChB,KAAK,OAAO;YACR,IAAIJ,IAAI,EAAE;cACNA,IAAI,CAACK,QAAQ,CAACR,OAAO,CAACR,KAAK,CAAC;YAChC,CAAC,MACI;cACDS,OAAO,CAACQ,IAAI,4CAAAC,MAAA,CAA4CV,OAAO,CAACM,EAAE,qBAAkB,CAAC;cACrFjB,KAAI,CAACsB,kBAAkB,CAAC7B,QAAQ,CAAC8B,iBAAiB,CAACZ,OAAO,CAACM,EAAE,CAAC,CAAC,CAACO,KAAK,CAAC,UAACC,GAAG,EAAK;gBAC3E,IAAI7B,KAAK,EAAE;kBACPgB,OAAO,CAACQ,IAAI,kDAAAC,MAAA,CAAkDV,OAAO,CAACM,EAAE,GAAIQ,GAAG,CAAC;gBACpF;cACJ,CAAC,CAAC;YACN;YACA;UACJ,KAAK,QAAQ;YACT;YACA,IAAIX,IAAI,EAAE;cACN,IAAIH,OAAO,CAACe,OAAO,EAAE;gBACjBZ,IAAI,CAACa,OAAO,CAAChB,OAAO,CAACiB,MAAM,CAAC;gBAC5B;gBACA,IAAI,EAAE,WAAW,IAAId,IAAI,CAAC,EAAE;kBACxBd,KAAI,CAACe,QAAQ,CAACc,MAAM,CAAClB,OAAO,CAACM,EAAE,CAAC;gBACpC;cACJ,CAAC,MACI;gBACDH,IAAI,CAACgB,MAAM,CAACnB,OAAO,CAACoB,KAAK,CAAC;gBAC1B/B,KAAI,CAACe,QAAQ,CAACc,MAAM,CAAClB,OAAO,CAACM,EAAE,CAAC;cACpC;YACJ;YACA;UACJ,KAAK,MAAM;YACP,IAAIH,IAAI,EAAE;cACNA,IAAI,CAACa,OAAO,CAAC,CAAC;cACd3B,KAAI,CAACe,QAAQ,CAACc,MAAM,CAAClB,OAAO,CAACM,EAAE,CAAC;YACpC,CAAC,MACI;cACDL,OAAO,CAACQ,IAAI,mCAAAC,MAAA,CAAmCV,OAAO,CAACM,EAAE,CAAE,CAAC;YAChE;YACA;UACJ;YACI,IAAIrB,KAAK,EAAE;cACPgB,OAAO,CAACQ,IAAI,CAAC,mBAAmB,EAAET,OAAO,CAAC;YAC9C;QACR;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAI,CAACqB,YAAY,gBAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,SAAA;MAAA,IAAAC,WAAA,EAAAtC,OAAA,EAAAuC,SAAA;MAAA,OAAAJ,mBAAA,GAAAK,IAAA,UAAAC,UAAAC,SAAA;QAAA,kBAAAA,SAAA,CAAAC,IAAA,GAAAD,SAAA,CAAAE,IAAA;UAAA;YACVN,WAAW,GAAGrC,KAAI,CAACe,QAAQ,EACjC;YACAf,KAAI,CAAC4C,SAAS,GAAG,CAAC;YAClB5C,KAAI,CAAC6C,gBAAgB,GAAG7C,KAAI,CAACe,QAAQ;YACrCf,KAAI,CAACe,QAAQ,GAAG,IAAI+B,GAAG,CAAC,CAAC;YACzB9C,KAAI,CAACF,MAAM,GAAGiD,SAAS;YACvB;YACAV,WAAW,CAAC3B,OAAO,CAAC,UAACI,IAAI,EAAK;cAC1B;cACA;cACA,IAAI,EAAE,WAAW,IAAIA,IAAI,CAAC,EAAE;gBACxBA,IAAI,CAACgB,MAAM,CAACrC,QAAQ,CAACsC,KAAK,CAACpC,mBAAmB,EAAE,iBAAiB,CAAC,CAAC;cACvE;YACJ,CAAC,CAAC;YAAC,KACCK,KAAI,CAACgD,cAAc;cAAAP,SAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,SAAA,CAAAQ,MAAA;UAAA;YAGvBjD,KAAI,CAACkD,SAAS,CAAC,cAAc,CAAC;YAC9B;YACMnD,OAAO,GAAGoD,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEpD,KAAI,CAACD,OAAO,CAAC,EAAE;cAAEsD,UAAU,EAAE;YAAE,CAAC,CAAC;YAC3Ef,SAAS,GAAG,SAAZA,SAASA,CAAIgB,KAAK,EAAK;cACzBC,UAAU,eAAAtB,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAC,SAAAqB,QAAA;gBAAA,IAAAC,OAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,KAAA,EAAAC,GAAA;gBAAA,OAAA3B,mBAAA,GAAAK,IAAA,UAAAuB,SAAAC,QAAA;kBAAA,kBAAAA,QAAA,CAAArB,IAAA,GAAAqB,QAAA,CAAApB,IAAA;oBAAA;sBAAA,KACH3C,KAAI,CAACgD,cAAc;wBAAAe,QAAA,CAAApB,IAAA;wBAAA;sBAAA;sBAAA,OAAAoB,QAAA,CAAAd,MAAA;oBAAA;sBAGvB,IAAIrD,KAAK,EAAE;wBACPgB,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;sBACtC;sBAACkD,QAAA,CAAArB,IAAA;sBAAAqB,QAAA,CAAApB,IAAA;sBAAA,OAEwB5C,OAAO,CAACiE,YAAY,CAACjE,OAAO,CAAC;oBAAA;sBAA5CD,OAAM,GAAAiE,QAAA,CAAAE,IAAA;sBACZjE,KAAI,CAACkE,UAAU,CAACpE,OAAM,CAAC;sBAACiE,QAAA,CAAApB,IAAA;sBAAA;oBAAA;sBAAAoB,QAAA,CAAArB,IAAA;sBAAAqB,QAAA,CAAAI,EAAA,GAAAJ,QAAA;sBAGxB,IAAI/D,KAAI,CAACoE,eAAe,EAAE;wBAChBV,cAAc,GAAG1D,KAAI,CAACoE,eAAe;wBAC3CpE,KAAI,CAACoE,eAAe,GAAGrB,SAAS;wBAACY,SAAA,GAAAU,0BAAA,CACfX,cAAc;wBAAA;0BAAhC,KAAAC,SAAA,CAAAW,CAAA,MAAAV,KAAA,GAAAD,SAAA,CAAAY,CAAA,IAAAC,IAAA,GAAkC;4BAAvBX,GAAG,GAAAD,KAAA,CAAAa,KAAA;4BACV,IAAIZ,GAAG,CAAC/B,MAAM,EAAE;8BACZ+B,GAAG,CAAC/B,MAAM,CAACnC,mBAAmB,CAAC;4BACnC;0BACJ;wBAAC,SAAA8B,GAAA;0BAAAkC,SAAA,CAAAe,CAAA,CAAAjD,GAAA;wBAAA;0BAAAkC,SAAA,CAAAgB,CAAA;wBAAA;sBACL;sBACA,IAAIZ,QAAA,CAAAI,EAAA,KAAQzE,gBAAgB,EAAE;wBAC1BM,KAAI,CAACkD,SAAS,CAAC,iBAAiB,EAAAa,QAAA,CAAAI,EAAK,CAAC;sBAC1C,CAAC,MACI;wBACD7B,SAAS,CAACgB,KAAK,GAAG,CAAC,CAAC;sBACxB;oBAAC;oBAAA;sBAAA,OAAAS,QAAA,CAAAa,IAAA;kBAAA;gBAAA,GAAApB,OAAA;cAAA,CAER,IAAEqB,IAAI,CAACC,GAAG,CAACxB,KAAK,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC;YACjC,CAAC;YAAA,KACGtD,KAAI,CAAC+E,uBAAuB;cAAAtC,SAAA,CAAAE,IAAA;cAAA;YAAA;YAAAF,SAAA,CAAAE,IAAA;YAAA,OACtB3C,KAAI,CAAC+E,uBAAuB;UAAA;YAClC/E,KAAI,CAAC+E,uBAAuB,GAAGhC,SAAS;YACxC;YACA;YACA/C,KAAI,CAACoE,eAAe,GAAG,EAAE;UAAC;YAE9B9B,SAAS,CAAC,CAAC,CAAC;UAAC;UAAA;YAAA,OAAAG,SAAA,CAAAmC,IAAA;QAAA;MAAA,GAAAxC,QAAA;IAAA,CAChB;IACD;IACA;IACA;IACA,IAAI,CAACrC,OAAO,GAAGA,OAAO;IACtB;IACA,IAAI,CAAC6C,SAAS,GAAG,CAAC,CAAC,CAAC;IACpB;IACA,IAAI,CAAC7B,QAAQ,GAAG,IAAI+B,GAAG,CAAC,CAAC;IACzB;IACA,IAAI,CAACkC,cAAc,GAAG,IAAIlC,GAAG,CAAC,CAAC;IAC/B;IACA,IAAI,CAACE,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACkB,UAAU,CAACpE,MAAM,CAAC;EAC3B;EAACmF,YAAA,CAAApF,UAAA;IAAAqF,GAAA;IAAAlE,GAAA,EACD,SAAAA,IAAA,EAAgB;MACZ;MACA,OAAQ,IAAI,CAAClB,MAAM,KAAKiD,SAAS,IAAI,IAAI,CAACjD,MAAM,CAACqF,UAAU,IAAI,IAAI,CAACrF,MAAM,CAACsF,IAAI;IACnF;EAAC;IAAAF,GAAA;IAAAT,KAAA,EACD,SAAAP,WAAWpE,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,GAAGA,MAAM;MACpB,IAAI,CAACuF,SAAS,GAAGvF,MAAM,CAACuF,SAAS;MACjCvF,MAAM,CAACwF,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACpF,cAAc,CAAC;MACvDJ,MAAM,CAACwF,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAACtD,YAAY,CAAC;MACnD,IAAMa,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;MAC9C,IAAIA,gBAAgB,EAAE;QAClB,IAAI,CAACA,gBAAgB,GAAGE,SAAS;QACjCF,gBAAgB,CAACnC,OAAO,CAAC,UAACI,IAAI,EAAK;UAC/B,IAAI,WAAW,IAAIA,IAAI,IAAIA,IAAI,CAACyE,SAAS,EAAE;YACvCzE,IAAI,CAACyE,SAAS,CAAC,CAAC,CAACC,IAAI,CAAC,UAACC,KAAK,EAAK;cAC7B3E,IAAI,CAAC4E,WAAW,GAAGD,KAAK;cACxB;cACA;cACA;cACA3E,IAAI,CAACa,OAAO,CAAC,CAAC;YAClB,CAAC,CAAC;UACN;QACJ,CAAC,CAAC;MACN;MACA,IAAM+B,cAAc,GAAG,IAAI,CAACU,eAAe;MAC3C,IAAIV,cAAc,EAAE;QAChB,IAAI,CAACU,eAAe,GAAGrB,SAAS;QAAC,IAAA4C,UAAA,GAAAtB,0BAAA,CACTX,cAAc;UAAAkC,MAAA;QAAA;UAAtC,KAAAD,UAAA,CAAArB,CAAA,MAAAsB,MAAA,GAAAD,UAAA,CAAApB,CAAA,IAAAC,IAAA,GAAwC;YAAA,IAA7BqB,SAAS,GAAAD,MAAA,CAAAnB,KAAA;YAChBoB,SAAS,CAAClE,OAAO,CAAC,CAAC;UACvB;QAAC,SAAAF,GAAA;UAAAkE,UAAA,CAAAjB,CAAA,CAAAjD,GAAA;QAAA;UAAAkE,UAAA,CAAAhB,CAAA;QAAA;MACL;MACA,IAAI,CAACzB,SAAS,CAAC,OAAO,CAAC;IAC3B;EAAC;IAAAgC,GAAA;IAAAT,KAAA,EACD,SAAAa,iBAAiBQ,SAAS,EAAE3E,QAAQ,EAAE;MAClC,IAAI4E,SAAS,GAAG,IAAI,CAACf,cAAc,CAAChE,GAAG,CAAC8E,SAAS,CAAC;MAClD,IAAI,CAACC,SAAS,EAAE;QACZA,SAAS,GAAG,EAAE;QACd,IAAI,CAACf,cAAc,CAACgB,GAAG,CAACF,SAAS,EAAEC,SAAS,CAAC;MACjD;MACAA,SAAS,CAACE,IAAI,CAAC9E,QAAQ,CAAC;IAC5B;EAAC;IAAA+D,GAAA;IAAAT,KAAA,EACD,SAAAyB,oBAAoBJ,SAAS,EAAE3E,QAAQ,EAAE;MACrC,IAAM4E,SAAS,GAAG,IAAI,CAACf,cAAc,CAAChE,GAAG,CAAC8E,SAAS,CAAC;MACpD,IAAI,CAACC,SAAS,EAAE;QACZ;MACJ;MACA,IAAMI,KAAK,GAAGJ,SAAS,CAACK,OAAO,CAACjF,QAAQ,CAAC;MACzC,IAAIgF,KAAK,KAAK,CAAC,CAAC,EAAE;QACdJ,SAAS,CAACM,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;MAC9B;IACJ;EAAC;IAAAjB,GAAA;IAAAT,KAAA,EACD,SAAAvB,UAAU4C,SAAS,EAAEQ,SAAS,EAAE;MAAA,IAAAC,MAAA;MAC5B,CAAC,IAAI,CAACvB,cAAc,CAAChE,GAAG,CAAC8E,SAAS,CAAC,IAAI,EAAE,EAAEpF,OAAO,CAAC,UAACS,QAAQ;QAAA,OAAKA,QAAQ,CAACoF,MAAI,EAAED,SAAS,CAAC;MAAA,EAAC;IAC/F;EAAC;IAAApB,GAAA;IAAAT,KAAA,EACD,SAAA+B,sBAAsBC,cAAc,EAAE;MAClC,IAAI,CAAC1B,uBAAuB,GAAG0B,cAAc;IACjD;EAAC;IAAAvB,GAAA;IAAAT,KAAA,EACD,SAAAiC,QAAA,EAAU;MACN,IAAI,CAAC,IAAI,CAAC3B,uBAAuB,EAAE;QAC/B,MAAM,IAAI4B,KAAK,CAAC,yBAAyB,CAAC;MAC9C;MACA,IAAI,IAAI,CAAC7G,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC8G,KAAK,CAAC,CAAC;MACvB;IACJ;IACA;AACJ;AACA;AACA;EAHI;IAAA1B,GAAA;IAAAT,KAAA,EAIA,SAAAnC,UAAA,EAAyB;MAAA,IAAfuE,KAAK,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA/D,SAAA,GAAA+D,SAAA,MAAG,KAAK;MACnB,IAAI,CAAC,IAAI,CAAChH,MAAM,EAAE;QACd;MACJ;MACA,IAAI,CAAC+G,KAAK,EAAE;QACR,IAAI,CAAC/G,MAAM,CAAC8G,KAAK,CAAC,CAAC;QACnB;MACJ;MACA,IAAI,CAAC9G,MAAM,CAACoG,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAChG,cAAc,CAAC;MAC/D,IAAI,CAACJ,MAAM,CAACoG,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAClE,YAAY,CAAC;MAC3D,IAAI,CAAClC,MAAM,CAAC8G,KAAK,CAAC,CAAC;MACnB,IAAI,CAAC5E,YAAY,CAAC,CAAC;IACvB;EAAC;IAAAkD,GAAA;IAAAT,KAAA,EACD,SAAAmC,MAAA,EAAQ;MACJ,IAAI,CAAC5D,cAAc,GAAG,IAAI;MAC1B,IAAI,IAAI,CAAClD,MAAM,EAAE;QACb,IAAI,CAACA,MAAM,CAAC8G,KAAK,CAAC,CAAC;MACvB;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EANI;IAAA1B,GAAA;IAAAT,KAAA;MAAA,IAAAuC,gBAAA,GAAA/E,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAOA,SAAA8E,SAAsB9F,QAAQ,EAAE2E,SAAS;QAAA,OAAA5D,mBAAA,GAAAK,IAAA,UAAA2E,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAzE,IAAA,GAAAyE,SAAA,CAAAxE,IAAA;YAAA;cAAA,OAAAwE,SAAA,CAAAlE,MAAA,WAC9B,IAAI,CAACmE,gBAAgB,CAACjG,QAAQ,EAAE1B,QAAQ,CAAC4H,eAAe,CAACvB,SAAS,CAAC,CAAC;YAAA;YAAA;cAAA,OAAAqB,SAAA,CAAAvC,IAAA;UAAA;QAAA,GAAAqC,QAAA;MAAA,CAC9E;MAAA,SAAAI,gBAAAC,EAAA,EAAAC,GAAA;QAAA,OAAAP,gBAAA,CAAAQ,KAAA,OAAAV,SAAA;MAAA;MAAA,OAAAO,eAAA;IAAA;EAAA;IAAAnC,GAAA;IAAAT,KAAA,EACD,SAAAgD,KAAA,EAAO;MACH,OAAO,IAAI,CAACnG,kBAAkB,CAAC7B,QAAQ,CAACgI,IAAI,CAAC,CAAC,CAAC;IACnD;EAAC;IAAAvC,GAAA;IAAAT,KAAA,EACD,SAAAiD,YAAY/G,OAAO,EAAEiC,SAAS,EAAE;MAAA,IAAA+E,MAAA;MAC5B,IAAI,CAAC,IAAI,CAACC,SAAS,EAAE;QACjB,MAAMjI,mBAAmB;MAC7B;MACA,IAAIC,KAAK,EAAE;QACPgB,OAAO,CAACC,GAAG,CAAC,SAAS,EAAEF,OAAO,CAAC;MACnC;MACA,IAAI,IAAI,CAACyD,eAAe,EAAE;QACtB,IAAIxB,SAAS,EAAE;UACX,MAAM,IAAI+D,KAAK,CAAC,6BAA6B,CAAC;QAClD;QACA,IAAI,CAACvC,eAAe,CAAC6B,IAAI,CAAC;UAAEtE,OAAO,EAAE,SAAAA,QAAA;YAAA,OAAMgG,MAAI,CAACD,WAAW,CAAC/G,OAAO,CAAC;UAAA;QAAC,CAAC,CAAC;QACvE;MACJ;MACA,IAAI,CAACiC,SAAS,EAAE;QACZA,SAAS,GAAG,IAAI,CAACiF,SAAS,CAAC,CAAC;MAChC;MACAlH,OAAO,CAACM,EAAE,GAAG2B,SAAS;MACtB,IAAI,CAAC9C,MAAM,CAACgI,IAAI,CAACzH,IAAI,CAAC0H,SAAS,CAACpH,OAAO,CAAC,CAAC;IAC7C;EAAC;IAAAuE,GAAA;IAAAT,KAAA,EACD,SAAAnD,mBAAmBX,OAAO,EAAE;MAAA,IAAAqH,MAAA;MACxB,OAAO,IAAIC,OAAO,CAAC,UAACtG,QAAO,EAAEG,MAAM,EAAK;QACpC,IAAIkG,MAAI,CAAC5D,eAAe,EAAE;UACtB4D,MAAI,CAAC5D,eAAe,CAAC6B,IAAI,CAAC;YACtBnE,MAAM,EAANA,MAAM;YACNH,OAAO;cAAA,IAAAuG,SAAA,GAAAjG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAE,SAAAgG,SAAA;gBAAA,OAAAjG,mBAAA,GAAAK,IAAA,UAAA6F,UAAAC,SAAA;kBAAA,kBAAAA,SAAA,CAAA3F,IAAA,GAAA2F,SAAA,CAAA1F,IAAA;oBAAA;sBAAA0F,SAAA,CAAA3F,IAAA;sBAAA2F,SAAA,CAAAlE,EAAA,GAEDxC,QAAO;sBAAA0G,SAAA,CAAA1F,IAAA;sBAAA,OAAOqF,MAAI,CAAC1G,kBAAkB,CAACX,OAAO,CAAC;oBAAA;sBAAA0H,SAAA,CAAAC,EAAA,GAAAD,SAAA,CAAApE,IAAA;sBAAA,IAAAoE,SAAA,CAAAlE,EAAA,EAAAkE,SAAA,CAAAC,EAAA;sBAAAD,SAAA,CAAA1F,IAAA;sBAAA;oBAAA;sBAAA0F,SAAA,CAAA3F,IAAA;sBAAA2F,SAAA,CAAAE,EAAA,GAAAF,SAAA;sBAG9CvG,MAAM,CAAAuG,SAAA,CAAAE,EAAI,CAAC;oBAAC;oBAAA;sBAAA,OAAAF,SAAA,CAAAzD,IAAA;kBAAA;gBAAA,GAAAuD,QAAA;cAAA,CAEnB;cAAA,SAAAxG,QAAA;gBAAA,OAAAuG,SAAA,CAAAV,KAAA,OAAAV,SAAA;cAAA;cAAA,OAAAnF,OAAA;YAAA;UACL,CAAC,CAAC;UACF;QACJ;QACA,IAAMiB,SAAS,GAAGoF,MAAI,CAACH,SAAS,CAAC,CAAC;QAClCG,MAAI,CAACjH,QAAQ,CAACiF,GAAG,CAACpD,SAAS,EAAE;UAAEjB,OAAO,EAAPA,QAAO;UAAEG,MAAM,EAANA;QAAO,CAAC,CAAC;QACjDkG,MAAI,CAACN,WAAW,CAAC/G,OAAO,EAAEiC,SAAS,CAAC;MACxC,CAAC,CAAC;IACN;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAPI;IAAAsC,GAAA;IAAAT,KAAA;MAAA,IAAA+D,kBAAA,GAAAvG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAQA,SAAAsG,SAAuBtH,QAAQ,EAAEiG,iBAAgB,EAAErH,OAAO;QAAA,IAAA2I,MAAA;QAAA,IAAA5H,IAAA;QAAA,OAAAoB,mBAAA,GAAAK,IAAA,UAAAoG,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAlG,IAAA,GAAAkG,SAAA,CAAAjG,IAAA;YAAA;cAAA,KAClD,IAAI,CAACyB,eAAe;gBAAAwE,SAAA,CAAAjG,IAAA;gBAAA;cAAA;cAAAiG,SAAA,CAAAjG,IAAA;cAAA,OACd,IAAIsF,OAAO,CAAC,UAACtG,OAAO,EAAEG,MAAM,EAAK;gBACnC4G,MAAI,CAACtE,eAAe,CAAC6B,IAAI,CAAC;kBAAEtE,OAAO,EAAPA,OAAO;kBAAEG,MAAM,EAANA;gBAAO,CAAC,CAAC;cAClD,CAAC,CAAC;YAAA;cAAA8G,SAAA,CAAAjG,IAAA;cAAA,OAGA,IAAIsF,OAAO,CAAC,UAACtG,OAAO,EAAEG,MAAM,EAAK;gBACnC;gBACA,IAAMc,SAAS,GAAG8F,MAAI,CAACb,SAAS,CAAC,CAAC;gBAClC;gBACA;gBACA/G,IAAI,GAAG;kBACHa,OAAO,EAAPA,OAAO;kBACPG,MAAM,EAANA,MAAM;kBACNX,QAAQ,EAARA,QAAQ;kBACRoE,SAAS,EAAE,CAACxF,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC8I,WAAW,MAAM,KAAK,GACtF;oBAAA,OAAMH,MAAI,CAACtB,gBAAgB,CAACjG,QAAQ,EAAEiG,iBAAgB,CAAC;kBAAA,IACvDrE,SAAS;kBACf2C,WAAW;oBAAA,IAAAoD,YAAA,GAAA7G,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAE,SAAA4G,SAAA;sBAAA,OAAA7G,mBAAA,GAAAK,IAAA,UAAAyG,UAAAC,SAAA;wBAAA,kBAAAA,SAAA,CAAAvG,IAAA,GAAAuG,SAAA,CAAAtG,IAAA;0BAAA;4BAAA,KAEL+F,MAAI,CAACd,SAAS;8BAAAqB,SAAA,CAAAtG,IAAA;8BAAA;4BAAA;4BAAAsG,SAAA,CAAAtG,IAAA;4BAAA,OACR+F,MAAI,CAACpH,kBAAkB,CAAC7B,QAAQ,CAAC8B,iBAAiB,CAACqB,SAAS,CAAC,CAAC;0BAAA;4BAExE8F,MAAI,CAAC3H,QAAQ,CAACc,MAAM,CAACe,SAAS,CAAC;0BAAC;0BAAA;4BAAA,OAAAqG,SAAA,CAAArE,IAAA;wBAAA;sBAAA,GAAAmE,QAAA;oBAAA,CACnC;oBAAA,SAAArD,YAAA;sBAAA,OAAAoD,YAAA,CAAAtB,KAAA,OAAAV,SAAA;oBAAA;oBAAA,OAAApB,WAAA;kBAAA;gBACL,CAAC;gBACDgD,MAAI,CAAC3H,QAAQ,CAACiF,GAAG,CAACpD,SAAS,EAAE9B,IAAI,CAAC;gBAClC,IAAI;kBACA4H,MAAI,CAAChB,WAAW,CAACN,iBAAgB,EAAExE,SAAS,CAAC;gBACjD,CAAC,CACD,OAAOnB,GAAG,EAAE;kBACR;kBACA;gBAAA;cAER,CAAC,CAAC;YAAA;cAAA,OAAAmH,SAAA,CAAA3F,MAAA,WACK;gBAAA,OAAMnC,IAAI,CAAC4E,WAAW,CAAC,CAAC;cAAA;YAAA;YAAA;cAAA,OAAAkD,SAAA,CAAAhE,IAAA;UAAA;QAAA,GAAA6D,QAAA;MAAA,CAClC;MAAA,SAAArB,iBAAA8B,GAAA,EAAAC,GAAA,EAAAC,GAAA;QAAA,OAAAZ,kBAAA,CAAAhB,KAAA,OAAAV,SAAA;MAAA;MAAA,OAAAM,gBAAA;IAAA;EAAA;IAAAlC,GAAA;IAAAT,KAAA,EACD,SAAAoD,UAAA,EAAY;MACR,OAAO,EAAE,IAAI,CAACjF,SAAS;IAC3B;EAAC;EAAA,OAAA/C,UAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}