{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 Anton Korzunov\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @fileoverview\n *\n * This module includes JS code copied from the `aria-hidden` package:\n * https://github.com/theKashey/aria-hidden/blob/master/src/index.ts\n */\n\n/** @type {WeakMap<Element, number>} */\nlet counterMap = new WeakMap();\n\n/** @type {WeakMap<Element, boolean>} */\nlet uncontrolledNodes = new WeakMap();\n\n/** @type {Record<string, WeakMap<Element, number>>} */\nlet markerMap = {};\n\n/** @type {number} */\nlet lockCount = 0;\n\n/**\n * @param {?Node} node\n * @return {boolean}\n */\nconst isElement = node => node && node.nodeType === Node.ELEMENT_NODE;\n\n/**\n * @param  {...unknown} args\n */\nconst logError = (...args) => {\n  console.error(`Error: ${args.join(' ')}. Skip setting aria-hidden.`);\n};\n\n/**\n * @param {HTMLElement} parent\n * @param {Element[]} targets\n * @return {Element[]}\n */\nconst correctTargets = (parent, targets) => {\n  if (!isElement(parent)) {\n    logError(parent, 'is not a valid element');\n    return [];\n  }\n  return targets.map(target => {\n    if (!isElement(target)) {\n      logError(target, 'is not a valid element');\n      return null;\n    }\n    let node = target;\n    while (node && node !== parent) {\n      if (parent.contains(node)) {\n        return target;\n      }\n      node = node.getRootNode().host;\n    }\n    logError(target, 'is not contained inside', parent);\n    return null;\n  }).filter(x => Boolean(x));\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Function}\n */\nconst applyAttributeToOthers = (originalTarget, parentNode, markerName, controlAttribute) => {\n  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n\n  /** @type {Element[]} */\n  const hiddenNodes = [];\n\n  /** @type {Set<Node>} */\n  const elementsToKeep = new Set();\n\n  /** @type {Set<Node>} */\n  const elementsToStop = new Set(targets);\n\n  /**\n   * @param {?Node} el\n   */\n  const keep = el => {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    const slot = el.assignedSlot;\n    if (slot) {\n      keep(slot);\n    }\n    keep(el.parentNode || el.host);\n  };\n  targets.forEach(keep);\n\n  /**\n   * @param {?Node} el\n   */\n  const deep = parent => {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    const root = parent.shadowRoot;\n    const children = root ? [...parent.children, ...root.children] : [...parent.children];\n    children.forEach(node => {\n      // Skip elements that don't need to be hidden\n      if (['template', 'script', 'style'].includes(node.localName)) {\n        return;\n      }\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = node.getAttribute(controlAttribute);\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenNodes.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledNodes.set(node, true);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, 'true');\n        }\n        if (!alreadyHidden) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  };\n  deep(parentNode);\n  elementsToKeep.clear();\n  lockCount += 1;\n  return () => {\n    hiddenNodes.forEach(node => {\n      const counterValue = counterMap.get(node) - 1;\n      const markerValue = markerCounter.get(node) - 1;\n      counterMap.set(node, counterValue);\n      markerCounter.set(node, markerValue);\n      if (!counterValue) {\n        if (uncontrolledNodes.has(node)) {\n          uncontrolledNodes.delete(node);\n        } else {\n          node.removeAttribute(controlAttribute);\n        }\n      }\n      if (!markerValue) {\n        node.removeAttribute(markerName);\n      }\n    });\n    lockCount -= 1;\n    if (!lockCount) {\n      // clear\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledNodes = new WeakMap();\n      markerMap = {};\n    }\n  };\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const hideOthers = (originalTarget, parentNode = document.body, markerName = 'data-aria-hidden') => {\n  const targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n  if (parentNode) {\n    // We should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push(...Array.from(parentNode.querySelectorAll('[aria-live]')));\n  }\n  return applyAttributeToOthers(targets, parentNode, markerName, 'aria-hidden');\n};\n\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const inertOthers = (originalTarget, parentNode = document.body, markerName = 'data-inert-ed') => {\n  return applyAttributeToOthers(originalTarget, parentNode, markerName, 'inert');\n};\n\n/**\n * @return if current browser supports inert\n */\nexport const supportsInert = ('inert' in HTMLElement.prototype);\n\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const suppressOthers = (originalTarget, parentNode, markerName) => (supportsInert ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);","map":{"version":3,"names":["counterMap","WeakMap","uncontrolledNodes","markerMap","lockCount","isElement","node","nodeType","Node","ELEMENT_NODE","logError","args","console","error","join","correctTargets","parent","targets","map","target","contains","getRootNode","host","filter","x","Boolean","applyAttributeToOthers","originalTarget","parentNode","markerName","controlAttribute","Array","isArray","markerCounter","hiddenNodes","elementsToKeep","Set","elementsToStop","keep","el","has","add","slot","assignedSlot","forEach","deep","root","shadowRoot","children","includes","localName","attr","getAttribute","alreadyHidden","counterValue","get","markerValue","set","push","setAttribute","clear","delete","removeAttribute","hideOthers","document","body","from","querySelectorAll","inertOthers","supportsInert","HTMLElement","prototype","suppressOthers"],"sources":["/workspaces/frontend/node_modules/@vaadin/a11y-base/src/aria-hidden.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 Anton Korzunov\n * SPDX-License-Identifier: MIT\n */\n\n/**\n * @fileoverview\n *\n * This module includes JS code copied from the `aria-hidden` package:\n * https://github.com/theKashey/aria-hidden/blob/master/src/index.ts\n */\n\n/** @type {WeakMap<Element, number>} */\nlet counterMap = new WeakMap();\n\n/** @type {WeakMap<Element, boolean>} */\nlet uncontrolledNodes = new WeakMap();\n\n/** @type {Record<string, WeakMap<Element, number>>} */\nlet markerMap = {};\n\n/** @type {number} */\nlet lockCount = 0;\n\n/**\n * @param {?Node} node\n * @return {boolean}\n */\nconst isElement = (node) => node && node.nodeType === Node.ELEMENT_NODE;\n\n/**\n * @param  {...unknown} args\n */\nconst logError = (...args) => {\n  console.error(`Error: ${args.join(' ')}. Skip setting aria-hidden.`);\n};\n\n/**\n * @param {HTMLElement} parent\n * @param {Element[]} targets\n * @return {Element[]}\n */\nconst correctTargets = (parent, targets) => {\n  if (!isElement(parent)) {\n    logError(parent, 'is not a valid element');\n    return [];\n  }\n\n  return targets\n    .map((target) => {\n      if (!isElement(target)) {\n        logError(target, 'is not a valid element');\n        return null;\n      }\n\n      let node = target;\n      while (node && node !== parent) {\n        if (parent.contains(node)) {\n          return target;\n        }\n        node = node.getRootNode().host;\n      }\n\n      logError(target, 'is not contained inside', parent);\n      return null;\n    })\n    .filter((x) => Boolean(x));\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @param {String} [controlAttribute] - html Attribute to control\n * @return {Function}\n */\nconst applyAttributeToOthers = (originalTarget, parentNode, markerName, controlAttribute) => {\n  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n\n  const markerCounter = markerMap[markerName];\n\n  /** @type {Element[]} */\n  const hiddenNodes = [];\n\n  /** @type {Set<Node>} */\n  const elementsToKeep = new Set();\n\n  /** @type {Set<Node>} */\n  const elementsToStop = new Set(targets);\n\n  /**\n   * @param {?Node} el\n   */\n  const keep = (el) => {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n\n    elementsToKeep.add(el);\n\n    const slot = el.assignedSlot;\n    if (slot) {\n      keep(slot);\n    }\n\n    keep(el.parentNode || el.host);\n  };\n\n  targets.forEach(keep);\n\n  /**\n   * @param {?Node} el\n   */\n  const deep = (parent) => {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n\n    const root = parent.shadowRoot;\n    const children = root ? [...parent.children, ...root.children] : [...parent.children];\n    children.forEach((node) => {\n      // Skip elements that don't need to be hidden\n      if (['template', 'script', 'style'].includes(node.localName)) {\n        return;\n      }\n\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = node.getAttribute(controlAttribute);\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenNodes.push(node);\n\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledNodes.set(node, true);\n        }\n\n        if (markerValue === 1) {\n          node.setAttribute(markerName, 'true');\n        }\n\n        if (!alreadyHidden) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  };\n\n  deep(parentNode);\n\n  elementsToKeep.clear();\n\n  lockCount += 1;\n\n  return () => {\n    hiddenNodes.forEach((node) => {\n      const counterValue = counterMap.get(node) - 1;\n      const markerValue = markerCounter.get(node) - 1;\n\n      counterMap.set(node, counterValue);\n      markerCounter.set(node, markerValue);\n\n      if (!counterValue) {\n        if (uncontrolledNodes.has(node)) {\n          uncontrolledNodes.delete(node);\n        } else {\n          node.removeAttribute(controlAttribute);\n        }\n      }\n\n      if (!markerValue) {\n        node.removeAttribute(markerName);\n      }\n    });\n\n    lockCount -= 1;\n\n    if (!lockCount) {\n      // clear\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledNodes = new WeakMap();\n      markerMap = {};\n    }\n  };\n};\n\n/**\n * Marks everything except given node(or nodes) as aria-hidden\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const hideOthers = (originalTarget, parentNode = document.body, markerName = 'data-aria-hidden') => {\n  const targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);\n\n  if (parentNode) {\n    // We should not hide ariaLive elements - https://github.com/theKashey/aria-hidden/issues/10\n    targets.push(...Array.from(parentNode.querySelectorAll('[aria-live]')));\n  }\n\n  return applyAttributeToOthers(targets, parentNode, markerName, 'aria-hidden');\n};\n\n/**\n * Marks everything except given node(or nodes) as inert\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const inertOthers = (originalTarget, parentNode = document.body, markerName = 'data-inert-ed') => {\n  return applyAttributeToOthers(originalTarget, parentNode, markerName, 'inert');\n};\n\n/**\n * @return if current browser supports inert\n */\nexport const supportsInert = 'inert' in HTMLElement.prototype;\n\n/**\n * Automatic function to \"suppress\" DOM elements - _hide_ or _inert_ in the best possible way\n * @param {Element | Element[]} originalTarget - elements to keep on the page\n * @param {HTMLElement} [parentNode] - top element, defaults to document.body\n * @param {String} [markerName] - a special attribute to mark every node\n * @return {Function} undo command\n */\nexport const suppressOthers = (originalTarget, parentNode, markerName) =>\n  (supportsInert ? inertOthers : hideOthers)(originalTarget, parentNode, markerName);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}