{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport { endOfToday, isToday, startOfToday } from \"date-fns/esm\";\nimport { css, html, LitElement, nothing } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { hex2rgb, lab2rgb, rgb2hex, rgb2lab } from \"../../../../common/color/convert-color\";\nimport { labBrighten, labDarken } from \"../../../../common/color/lab\";\nimport { formatNumber } from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport { getEnergyDataCollection } from \"../../../../data/energy\";\nimport { getStatisticLabel } from \"../../../../data/recorder\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { hasConfigChanged } from \"../../common/has-changed\";\nimport { getCommonOptions } from \"./common/energy-chart-options\";\nexport let HuiEnergyUsageGraphCard = _decorate([customElement(\"hui-energy-usage-graph-card\")], function (_initialize, _SubscribeMixin) {\n  class HuiEnergyUsageGraphCard extends _SubscribeMixin {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HuiEnergyUsageGraphCard,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_config\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartData\",\n      value() {\n        return {\n          datasets: []\n        };\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_start\",\n      value() {\n        return startOfToday();\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_end\",\n      value() {\n        return endOfToday();\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_compareStart\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_compareEnd\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"hassSubscribeRequiredHostProps\",\n      value() {\n        return [\"_config\"];\n      }\n    }, {\n      kind: \"method\",\n      key: \"hassSubscribe\",\n      value: function hassSubscribe() {\n        var _this$_config;\n        return [getEnergyDataCollection(this.hass, {\n          key: (_this$_config = this._config) === null || _this$_config === void 0 ? void 0 : _this$_config.collection_key\n        }).subscribe(data => this._getStatistics(data))];\n      }\n    }, {\n      kind: \"method\",\n      key: \"getCardSize\",\n      value: function getCardSize() {\n        return 3;\n      }\n    }, {\n      kind: \"method\",\n      key: \"setConfig\",\n      value: function setConfig(config) {\n        this._config = config;\n      }\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        return hasConfigChanged(this, changedProps) || changedProps.size > 1 || !changedProps.has(\"hass\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!this.hass || !this._config) {\n          return nothing;\n        }\n        return html`\n      <ha-card>\n        ${this._config.title ? html`<h1 class=\"card-header\">${this._config.title}</h1>` : \"\"}\n        <div\n          class=\"content ${classMap({\n          \"has-header\": !!this._config.title\n        })}\"\n        >\n          <ha-chart-base\n            .hass=${this.hass}\n            .data=${this._chartData}\n            .options=${this._createOptions(this._start, this._end, this.hass.locale, this.hass.config, this._compareStart, this._compareEnd)}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n          ${!this._chartData.datasets.some(dataset => dataset.data.length) ? html`<div class=\"no-data\">\n                ${isToday(this._start) ? this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data\") : this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data_period\")}\n              </div>` : \"\"}\n        </div>\n      </ha-card>\n    `;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_createOptions\",\n      value() {\n        return memoizeOne((start, end, locale, config, compareStart, compareEnd) => {\n          const commonOptions = getCommonOptions(start, end, locale, config, \"kWh\", compareStart, compareEnd);\n          const options = {\n            ...commonOptions,\n            plugins: {\n              ...commonOptions.plugins,\n              tooltip: {\n                ...commonOptions.plugins.tooltip,\n                itemSort: function (a, b) {\n                  var _a$raw, _b$raw, _b$raw2, _a$raw2, _a$raw3;\n                  if (((_a$raw = a.raw) === null || _a$raw === void 0 ? void 0 : _a$raw.y) > 0 && ((_b$raw = b.raw) === null || _b$raw === void 0 ? void 0 : _b$raw.y) < 0) {\n                    return -1;\n                  }\n                  if (((_b$raw2 = b.raw) === null || _b$raw2 === void 0 ? void 0 : _b$raw2.y) > 0 && ((_a$raw2 = a.raw) === null || _a$raw2 === void 0 ? void 0 : _a$raw2.y) < 0) {\n                    return 1;\n                  }\n                  if (((_a$raw3 = a.raw) === null || _a$raw3 === void 0 ? void 0 : _a$raw3.y) > 0) {\n                    return b.datasetIndex - a.datasetIndex;\n                  }\n                  return a.datasetIndex - b.datasetIndex;\n                },\n                callbacks: {\n                  ...commonOptions.plugins.tooltip.callbacks,\n                  footer: contexts => {\n                    let totalConsumed = 0;\n                    let totalReturned = 0;\n                    for (const context of contexts) {\n                      const value = context.dataset.data[context.dataIndex].y;\n                      if (value > 0) {\n                        totalConsumed += value;\n                      } else {\n                        totalReturned += Math.abs(value);\n                      }\n                    }\n                    return [totalConsumed ? this.hass.localize(\"ui.panel.lovelace.cards.energy.energy_usage_graph.total_consumed\", {\n                      num: formatNumber(totalConsumed, locale)\n                    }) : \"\", totalReturned ? this.hass.localize(\"ui.panel.lovelace.cards.energy.energy_usage_graph.total_returned\", {\n                      num: formatNumber(totalReturned, locale)\n                    }) : \"\"].filter(Boolean);\n                  }\n                }\n              }\n            }\n          };\n          return options;\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_getStatistics\",\n      value: async function _getStatistics(energyData) {\n        const datasets = [];\n        const statIds = {};\n        for (const source of energyData.prefs.energy_sources) {\n          if (source.type === \"solar\") {\n            if (statIds.solar) {\n              statIds.solar.push(source.stat_energy_from);\n            } else {\n              statIds.solar = [source.stat_energy_from];\n            }\n            continue;\n          }\n          if (source.type === \"battery\") {\n            if (statIds.to_battery) {\n              statIds.to_battery.push(source.stat_energy_to);\n              statIds.from_battery.push(source.stat_energy_from);\n            } else {\n              statIds.to_battery = [source.stat_energy_to];\n              statIds.from_battery = [source.stat_energy_from];\n            }\n            continue;\n          }\n          if (source.type !== \"grid\") {\n            continue;\n          }\n\n          // grid source\n          for (const flowFrom of source.flow_from) {\n            if (statIds.from_grid) {\n              statIds.from_grid.push(flowFrom.stat_energy_from);\n            } else {\n              statIds.from_grid = [flowFrom.stat_energy_from];\n            }\n          }\n          for (const flowTo of source.flow_to) {\n            if (statIds.to_grid) {\n              statIds.to_grid.push(flowTo.stat_energy_to);\n            } else {\n              statIds.to_grid = [flowTo.stat_energy_to];\n            }\n          }\n        }\n        const computedStyles = getComputedStyle(this);\n        const colorPropertyMap = {\n          to_grid: \"--energy-grid-return-color\",\n          to_battery: \"--energy-battery-in-color\",\n          from_grid: \"--energy-grid-consumption-color\",\n          used_grid: \"--energy-grid-consumption-color\",\n          used_solar: \"--energy-solar-color\",\n          used_battery: \"--energy-battery-out-color\"\n        };\n        const colors = {\n          to_grid: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.to_grid).trim()\n          },\n          to_battery: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.to_battery).trim()\n          },\n          from_grid: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.from_grid).trim()\n          },\n          used_grid: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.used_grid).trim()\n          },\n          used_solar: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.used_solar).trim()\n          },\n          used_battery: {\n            base: computedStyles.getPropertyValue(colorPropertyMap.used_battery).trim()\n          }\n        };\n        Object.entries(colorPropertyMap).forEach(([key, colorProp]) => {\n          if (key === \"used_grid\" || key === \"used_solar\" || key === \"used_battery\") {\n            return;\n          }\n          colors[key].overrides = [];\n          if (statIds[key]) {\n            Object.values(statIds[key]).forEach((id, idx) => {\n              const override = computedStyles.getPropertyValue(colorProp + \"-\" + idx).trim();\n              if (override.length > 0) {\n                colors[key].overrides[id] = override;\n              }\n            });\n          }\n        });\n        const labels = {\n          used_grid: this.hass.localize(\"ui.panel.lovelace.cards.energy.energy_usage_graph.combined_from_grid\"),\n          used_solar: this.hass.localize(\"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_solar\"),\n          used_battery: this.hass.localize(\"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_battery\")\n        };\n        this._start = energyData.start;\n        this._end = energyData.end || endOfToday();\n        this._compareStart = energyData.startCompare;\n        this._compareEnd = energyData.endCompare;\n        datasets.push(...this._processDataSet(energyData.stats, energyData.statsMetadata, statIds, colors, labels, false));\n        if (energyData.statsCompare) {\n          // Add empty dataset to align the bars\n          datasets.push({\n            order: 0,\n            data: []\n          });\n          datasets.push({\n            order: 999,\n            data: [],\n            xAxisID: \"xAxisCompare\"\n          });\n          datasets.push(...this._processDataSet(energyData.statsCompare, energyData.statsMetadata, statIds, colors, labels, true));\n        }\n        this._chartData = {\n          datasets\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_processDataSet\",\n      value: function _processDataSet(statistics, statisticsMetaData, statIdsByCat, colors, labels, compare = false) {\n        const data = [];\n        const combinedData = {};\n        const summedData = {};\n        let pointEndTime;\n        Object.entries(statIdsByCat).forEach(([key, statIds]) => {\n          const sum = [\"solar\", \"to_grid\", \"from_grid\", \"to_battery\", \"from_battery\"].includes(key);\n          const add = ![\"solar\", \"from_battery\"].includes(key);\n          const totalStats = {};\n          const sets = {};\n          statIds.forEach(id => {\n            const stats = statistics[id];\n            if (!stats) {\n              return;\n            }\n            const set = {};\n            stats.forEach(stat => {\n              if (stat.change === null || stat.change === undefined) {\n                return;\n              }\n              const val = stat.change;\n              // Get total of solar and to grid to calculate the solar energy used\n              if (sum) {\n                totalStats[stat.start] = stat.start in totalStats ? totalStats[stat.start] + val : val;\n                pointEndTime = stat.end;\n              }\n              if (add && !(stat.start in set)) {\n                set[stat.start] = val;\n                pointEndTime = stat.end;\n              }\n            });\n            sets[id] = set;\n          });\n          if (sum) {\n            summedData[key] = totalStats;\n          }\n          if (add) {\n            combinedData[key] = sets;\n          }\n        });\n        const grid_to_battery = {};\n        const battery_to_grid = {};\n        if ((summedData.to_grid || summedData.to_battery) && summedData.solar) {\n          const used_solar = {};\n          for (const start of Object.keys(summedData.solar)) {\n            var _summedData$to_grid, _summedData$to_batter;\n            used_solar[start] = (summedData.solar[start] || 0) - (((_summedData$to_grid = summedData.to_grid) === null || _summedData$to_grid === void 0 ? void 0 : _summedData$to_grid[start]) || 0) - (((_summedData$to_batter = summedData.to_battery) === null || _summedData$to_batter === void 0 ? void 0 : _summedData$to_batter[start]) || 0);\n            if (used_solar[start] < 0) {\n              if (summedData.to_battery) {\n                var _summedData$from_grid;\n                grid_to_battery[start] = used_solar[start] * -1;\n                if (grid_to_battery[start] > (((_summedData$from_grid = summedData.from_grid) === null || _summedData$from_grid === void 0 ? void 0 : _summedData$from_grid[start]) || 0)) {\n                  var _summedData$from_grid2, _summedData$from_grid3;\n                  battery_to_grid[start] = Math.min(0, grid_to_battery[start] - (((_summedData$from_grid2 = summedData.from_grid) === null || _summedData$from_grid2 === void 0 ? void 0 : _summedData$from_grid2[start]) || 0));\n                  grid_to_battery[start] = (_summedData$from_grid3 = summedData.from_grid) === null || _summedData$from_grid3 === void 0 ? void 0 : _summedData$from_grid3[start];\n                }\n              }\n              used_solar[start] = 0;\n            }\n          }\n          combinedData.used_solar = {\n            used_solar\n          };\n        }\n        if (summedData.from_battery) {\n          if (summedData.to_grid) {\n            const used_battery = {};\n            for (const start of Object.keys(summedData.from_battery)) {\n              used_battery[start] = (summedData.from_battery[start] || 0) - (battery_to_grid[start] || 0);\n            }\n            combinedData.used_battery = {\n              used_battery\n            };\n          } else {\n            combinedData.used_battery = {\n              used_battery: summedData.from_battery\n            };\n          }\n        }\n        if (combinedData.from_grid && summedData.to_battery) {\n          const used_grid = {};\n          for (const start of Object.keys(grid_to_battery)) {\n            let noOfSources = 0;\n            let source;\n            for (const [key, stats] of Object.entries(combinedData.from_grid)) {\n              if (stats[start]) {\n                source = key;\n                noOfSources++;\n              }\n              if (noOfSources > 1) {\n                break;\n              }\n            }\n            if (noOfSources === 1) {\n              combinedData.from_grid[source][start] -= grid_to_battery[start] || 0;\n            } else {\n              let total_from_grid = 0;\n              Object.values(combinedData.from_grid).forEach(stats => {\n                total_from_grid += stats[start] || 0;\n                delete stats[start];\n              });\n              used_grid[start] = total_from_grid - (grid_to_battery[start] || 0);\n            }\n          }\n          combinedData.used_grid = {\n            used_grid\n          };\n        }\n        let allKeys = [];\n        Object.values(combinedData).forEach(sources => {\n          Object.values(sources).forEach(source => {\n            allKeys = allKeys.concat(Object.keys(source));\n          });\n        });\n        const uniqueKeys = Array.from(new Set(allKeys)).sort((a, b) => Number(a) - Number(b));\n        Object.entries(combinedData).forEach(([type, sources]) => {\n          Object.entries(sources).forEach(([statId, source], idx) => {\n            var _colors$type$override;\n            let borderColor = (_colors$type$override = colors[type].overrides) === null || _colors$type$override === void 0 ? void 0 : _colors$type$override[statId];\n            if (!borderColor) {\n              const modifiedColor = idx > 0 ? this.hass.themes.darkMode ? labBrighten(rgb2lab(hex2rgb(colors[type].base)), idx) : labDarken(rgb2lab(hex2rgb(colors[type].base)), idx) : undefined;\n              borderColor = modifiedColor ? rgb2hex(lab2rgb(modifiedColor)) : colors[type].base;\n            }\n            const points = [];\n            // Process chart data.\n            for (const key of uniqueKeys) {\n              const value = source[key] || 0;\n              points.push({\n                x: Number(key),\n                y: value && [\"to_grid\", \"to_battery\"].includes(type) ? -1 * value : value\n              });\n            }\n            if (points.length === 1) {\n              points.push({\n                x: pointEndTime,\n                y: 0\n              });\n            }\n            data.push({\n              label: type in labels ? labels[type] : getStatisticLabel(this.hass, statId, statisticsMetaData[statId]),\n              order: type === \"used_solar\" ? 1 : type === \"to_battery\" ? Object.keys(combinedData).length : idx + 2,\n              borderColor: compare ? borderColor + \"7F\" : borderColor,\n              backgroundColor: compare ? borderColor + \"32\" : borderColor + \"7F\",\n              stack: \"stack\",\n              data: points,\n              xAxisID: compare ? \"xAxisCompare\" : undefined\n            });\n          });\n        });\n        return data;\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      ha-card {\n        height: 100%;\n      }\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      .no-data {\n        position: absolute;\n        height: 100%;\n        top: 0;\n        left: 0;\n        right: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 20%;\n        margin-left: 32px;\n        margin-inline-start: 32px;\n        margin-inline-end: initial;\n        box-sizing: border-box;\n      }\n    `;\n      }\n    }]\n  };\n}, SubscribeMixin(LitElement));","map":{"version":3,"names":["endOfToday","isToday","startOfToday","css","html","LitElement","nothing","customElement","property","state","classMap","memoizeOne","hex2rgb","lab2rgb","rgb2hex","rgb2lab","labBrighten","labDarken","formatNumber","getEnergyDataCollection","getStatisticLabel","SubscribeMixin","hasConfigChanged","getCommonOptions","HuiEnergyUsageGraphCard","_decorate","_initialize","_SubscribeMixin","constructor","args","F","d","kind","decorators","attribute","key","value","datasets","hassSubscribe","_this$_config","hass","_config","collection_key","subscribe","data","_getStatistics","getCardSize","setConfig","config","shouldUpdate","changedProps","size","has","render","title","_chartData","_createOptions","_start","_end","locale","_compareStart","_compareEnd","some","dataset","length","localize","start","end","compareStart","compareEnd","commonOptions","options","plugins","tooltip","itemSort","a","b","_a$raw","_b$raw","_b$raw2","_a$raw2","_a$raw3","raw","y","datasetIndex","callbacks","footer","contexts","totalConsumed","totalReturned","context","dataIndex","Math","abs","num","filter","Boolean","energyData","statIds","source","prefs","energy_sources","type","solar","push","stat_energy_from","to_battery","stat_energy_to","from_battery","flowFrom","flow_from","from_grid","flowTo","flow_to","to_grid","computedStyles","getComputedStyle","colorPropertyMap","used_grid","used_solar","used_battery","colors","base","getPropertyValue","trim","Object","entries","forEach","colorProp","overrides","values","id","idx","override","labels","startCompare","endCompare","_processDataSet","stats","statsMetadata","statsCompare","order","xAxisID","statistics","statisticsMetaData","statIdsByCat","compare","combinedData","summedData","pointEndTime","sum","includes","add","totalStats","sets","set","stat","change","undefined","val","grid_to_battery","battery_to_grid","keys","_summedData$to_grid","_summedData$to_batter","_summedData$from_grid","_summedData$from_grid2","_summedData$from_grid3","min","noOfSources","total_from_grid","allKeys","sources","concat","uniqueKeys","Array","from","Set","sort","Number","statId","_colors$type$override","borderColor","modifiedColor","themes","darkMode","points","x","label","backgroundColor","stack","static","styles"],"sources":["/workspaces/frontend/src/panels/lovelace/cards/energy/hui-energy-usage-graph-card.ts"],"sourcesContent":["import {\n  ChartData,\n  ChartDataset,\n  ChartOptions,\n  ScatterDataPoint,\n} from \"chart.js\";\nimport { endOfToday, isToday, startOfToday } from \"date-fns/esm\";\nimport { HassConfig, UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  nothing,\n  PropertyValues,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport {\n  hex2rgb,\n  lab2rgb,\n  rgb2hex,\n  rgb2lab,\n} from \"../../../../common/color/convert-color\";\nimport { labBrighten, labDarken } from \"../../../../common/color/lab\";\nimport { formatNumber } from \"../../../../common/number/format_number\";\nimport \"../../../../components/chart/ha-chart-base\";\nimport \"../../../../components/ha-card\";\nimport { EnergyData, getEnergyDataCollection } from \"../../../../data/energy\";\nimport {\n  getStatisticLabel,\n  Statistics,\n  StatisticsMetaData,\n} from \"../../../../data/recorder\";\nimport { FrontendLocaleData } from \"../../../../data/translation\";\nimport { SubscribeMixin } from \"../../../../mixins/subscribe-mixin\";\nimport { HomeAssistant } from \"../../../../types\";\nimport { LovelaceCard } from \"../../types\";\nimport { EnergyUsageGraphCardConfig } from \"../types\";\nimport { hasConfigChanged } from \"../../common/has-changed\";\nimport { getCommonOptions } from \"./common/energy-chart-options\";\n\ninterface ColorSet {\n  base: string;\n  overrides?: Record<string, string>;\n}\n\n@customElement(\"hui-energy-usage-graph-card\")\nexport class HuiEnergyUsageGraphCard\n  extends SubscribeMixin(LitElement)\n  implements LovelaceCard\n{\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @state() private _config?: EnergyUsageGraphCardConfig;\n\n  @state() private _chartData: ChartData = {\n    datasets: [],\n  };\n\n  @state() private _start = startOfToday();\n\n  @state() private _end = endOfToday();\n\n  @state() private _compareStart?: Date;\n\n  @state() private _compareEnd?: Date;\n\n  protected hassSubscribeRequiredHostProps = [\"_config\"];\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      getEnergyDataCollection(this.hass, {\n        key: this._config?.collection_key,\n      }).subscribe((data) => this._getStatistics(data)),\n    ];\n  }\n\n  public getCardSize(): Promise<number> | number {\n    return 3;\n  }\n\n  public setConfig(config: EnergyUsageGraphCardConfig): void {\n    this._config = config;\n  }\n\n  protected shouldUpdate(changedProps: PropertyValues): boolean {\n    return (\n      hasConfigChanged(this, changedProps) ||\n      changedProps.size > 1 ||\n      !changedProps.has(\"hass\")\n    );\n  }\n\n  protected render() {\n    if (!this.hass || !this._config) {\n      return nothing;\n    }\n\n    return html`\n      <ha-card>\n        ${this._config.title\n          ? html`<h1 class=\"card-header\">${this._config.title}</h1>`\n          : \"\"}\n        <div\n          class=\"content ${classMap({\n            \"has-header\": !!this._config.title,\n          })}\"\n        >\n          <ha-chart-base\n            .hass=${this.hass}\n            .data=${this._chartData}\n            .options=${this._createOptions(\n              this._start,\n              this._end,\n              this.hass.locale,\n              this.hass.config,\n              this._compareStart,\n              this._compareEnd\n            )}\n            chart-type=\"bar\"\n          ></ha-chart-base>\n          ${!this._chartData.datasets.some((dataset) => dataset.data.length)\n            ? html`<div class=\"no-data\">\n                ${isToday(this._start)\n                  ? this.hass.localize(\"ui.panel.lovelace.cards.energy.no_data\")\n                  : this.hass.localize(\n                      \"ui.panel.lovelace.cards.energy.no_data_period\"\n                    )}\n              </div>`\n            : \"\"}\n        </div>\n      </ha-card>\n    `;\n  }\n\n  private _createOptions = memoizeOne(\n    (\n      start: Date,\n      end: Date,\n      locale: FrontendLocaleData,\n      config: HassConfig,\n      compareStart?: Date,\n      compareEnd?: Date\n    ): ChartOptions => {\n      const commonOptions = getCommonOptions(\n        start,\n        end,\n        locale,\n        config,\n        \"kWh\",\n        compareStart,\n        compareEnd\n      );\n      const options: ChartOptions = {\n        ...commonOptions,\n        plugins: {\n          ...commonOptions.plugins,\n          tooltip: {\n            ...commonOptions.plugins!.tooltip,\n            itemSort: function (a: any, b: any) {\n              if (a.raw?.y > 0 && b.raw?.y < 0) {\n                return -1;\n              }\n              if (b.raw?.y > 0 && a.raw?.y < 0) {\n                return 1;\n              }\n              if (a.raw?.y > 0) {\n                return b.datasetIndex - a.datasetIndex;\n              }\n              return a.datasetIndex - b.datasetIndex;\n            },\n            callbacks: {\n              ...commonOptions.plugins!.tooltip!.callbacks,\n              footer: (contexts) => {\n                let totalConsumed = 0;\n                let totalReturned = 0;\n                for (const context of contexts) {\n                  const value = (context.dataset.data[context.dataIndex] as any)\n                    .y;\n                  if (value > 0) {\n                    totalConsumed += value;\n                  } else {\n                    totalReturned += Math.abs(value);\n                  }\n                }\n                return [\n                  totalConsumed\n                    ? this.hass.localize(\n                        \"ui.panel.lovelace.cards.energy.energy_usage_graph.total_consumed\",\n                        { num: formatNumber(totalConsumed, locale) }\n                      )\n                    : \"\",\n                  totalReturned\n                    ? this.hass.localize(\n                        \"ui.panel.lovelace.cards.energy.energy_usage_graph.total_returned\",\n                        { num: formatNumber(totalReturned, locale) }\n                      )\n                    : \"\",\n                ].filter(Boolean);\n              },\n            },\n          },\n        },\n      };\n      return options;\n    }\n  );\n\n  private async _getStatistics(energyData: EnergyData): Promise<void> {\n    const datasets: ChartDataset<\"bar\", ScatterDataPoint[]>[] = [];\n\n    const statIds: {\n      to_grid?: string[];\n      from_grid?: string[];\n      solar?: string[];\n      to_battery?: string[];\n      from_battery?: string[];\n    } = {};\n\n    for (const source of energyData.prefs.energy_sources) {\n      if (source.type === \"solar\") {\n        if (statIds.solar) {\n          statIds.solar.push(source.stat_energy_from);\n        } else {\n          statIds.solar = [source.stat_energy_from];\n        }\n        continue;\n      }\n\n      if (source.type === \"battery\") {\n        if (statIds.to_battery) {\n          statIds.to_battery.push(source.stat_energy_to);\n          statIds.from_battery!.push(source.stat_energy_from);\n        } else {\n          statIds.to_battery = [source.stat_energy_to];\n          statIds.from_battery = [source.stat_energy_from];\n        }\n        continue;\n      }\n\n      if (source.type !== \"grid\") {\n        continue;\n      }\n\n      // grid source\n      for (const flowFrom of source.flow_from) {\n        if (statIds.from_grid) {\n          statIds.from_grid.push(flowFrom.stat_energy_from);\n        } else {\n          statIds.from_grid = [flowFrom.stat_energy_from];\n        }\n      }\n      for (const flowTo of source.flow_to) {\n        if (statIds.to_grid) {\n          statIds.to_grid.push(flowTo.stat_energy_to);\n        } else {\n          statIds.to_grid = [flowTo.stat_energy_to];\n        }\n      }\n    }\n\n    const computedStyles = getComputedStyle(this);\n\n    const colorPropertyMap = {\n      to_grid: \"--energy-grid-return-color\",\n      to_battery: \"--energy-battery-in-color\",\n      from_grid: \"--energy-grid-consumption-color\",\n      used_grid: \"--energy-grid-consumption-color\",\n      used_solar: \"--energy-solar-color\",\n      used_battery: \"--energy-battery-out-color\",\n    };\n\n    const colors = {\n      to_grid: {\n        base: computedStyles.getPropertyValue(colorPropertyMap.to_grid).trim(),\n      },\n      to_battery: {\n        base: computedStyles\n          .getPropertyValue(colorPropertyMap.to_battery)\n          .trim(),\n      },\n      from_grid: {\n        base: computedStyles\n          .getPropertyValue(colorPropertyMap.from_grid)\n          .trim(),\n      },\n      used_grid: {\n        base: computedStyles\n          .getPropertyValue(colorPropertyMap.used_grid)\n          .trim(),\n      },\n      used_solar: {\n        base: computedStyles\n          .getPropertyValue(colorPropertyMap.used_solar)\n          .trim(),\n      },\n      used_battery: {\n        base: computedStyles\n          .getPropertyValue(colorPropertyMap.used_battery)\n          .trim(),\n      },\n    };\n\n    Object.entries(colorPropertyMap).forEach(([key, colorProp]) => {\n      if (\n        key === \"used_grid\" ||\n        key === \"used_solar\" ||\n        key === \"used_battery\"\n      ) {\n        return;\n      }\n      colors[key].overrides = [];\n      if (statIds[key]) {\n        Object.values(statIds[key]).forEach((id, idx) => {\n          const override = computedStyles\n            .getPropertyValue(colorProp + \"-\" + idx)\n            .trim();\n          if (override.length > 0) {\n            colors[key].overrides[id] = override;\n          }\n        });\n      }\n    });\n\n    const labels = {\n      used_grid: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.combined_from_grid\"\n      ),\n      used_solar: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_solar\"\n      ),\n      used_battery: this.hass.localize(\n        \"ui.panel.lovelace.cards.energy.energy_usage_graph.consumed_battery\"\n      ),\n    };\n\n    this._start = energyData.start;\n    this._end = energyData.end || endOfToday();\n\n    this._compareStart = energyData.startCompare;\n    this._compareEnd = energyData.endCompare;\n\n    datasets.push(\n      ...this._processDataSet(\n        energyData.stats,\n        energyData.statsMetadata,\n        statIds,\n        colors,\n        labels,\n        false\n      )\n    );\n\n    if (energyData.statsCompare) {\n      // Add empty dataset to align the bars\n      datasets.push({\n        order: 0,\n        data: [],\n      });\n      datasets.push({\n        order: 999,\n        data: [],\n        xAxisID: \"xAxisCompare\",\n      });\n\n      datasets.push(\n        ...this._processDataSet(\n          energyData.statsCompare,\n          energyData.statsMetadata,\n          statIds,\n          colors,\n          labels,\n          true\n        )\n      );\n    }\n\n    this._chartData = {\n      datasets,\n    };\n  }\n\n  private _processDataSet(\n    statistics: Statistics,\n    statisticsMetaData: Record<string, StatisticsMetaData>,\n    statIdsByCat: {\n      to_grid?: string[] | undefined;\n      from_grid?: string[] | undefined;\n      solar?: string[] | undefined;\n      to_battery?: string[] | undefined;\n      from_battery?: string[] | undefined;\n    },\n    colors: {\n      to_grid: ColorSet;\n      to_battery: ColorSet;\n      from_grid: ColorSet;\n      used_grid: ColorSet;\n      used_solar: ColorSet;\n      used_battery: ColorSet;\n    },\n    labels: {\n      used_grid: string;\n      used_solar: string;\n      used_battery: string;\n    },\n    compare = false\n  ) {\n    const data: ChartDataset<\"bar\", ScatterDataPoint[]>[] = [];\n\n    const combinedData: {\n      to_grid?: { [statId: string]: { [start: number]: number } };\n      to_battery?: { [statId: string]: { [start: number]: number } };\n      from_grid?: { [statId: string]: { [start: number]: number } };\n      used_grid?: { [statId: string]: { [start: number]: number } };\n      used_solar?: { [statId: string]: { [start: number]: number } };\n      used_battery?: { [statId: string]: { [start: number]: number } };\n    } = {};\n\n    const summedData: {\n      to_grid?: { [start: number]: number };\n      from_grid?: { [start: number]: number };\n      to_battery?: { [start: number]: number };\n      from_battery?: { [start: number]: number };\n      solar?: { [start: number]: number };\n    } = {};\n\n    let pointEndTime;\n    Object.entries(statIdsByCat).forEach(([key, statIds]) => {\n      const sum = [\n        \"solar\",\n        \"to_grid\",\n        \"from_grid\",\n        \"to_battery\",\n        \"from_battery\",\n      ].includes(key);\n      const add = ![\"solar\", \"from_battery\"].includes(key);\n      const totalStats: { [start: number]: number } = {};\n      const sets: { [statId: string]: { [start: number]: number } } = {};\n      statIds!.forEach((id) => {\n        const stats = statistics[id];\n        if (!stats) {\n          return;\n        }\n\n        const set = {};\n        stats.forEach((stat) => {\n          if (stat.change === null || stat.change === undefined) {\n            return;\n          }\n          const val = stat.change;\n          // Get total of solar and to grid to calculate the solar energy used\n          if (sum) {\n            totalStats[stat.start] =\n              stat.start in totalStats ? totalStats[stat.start] + val : val;\n            pointEndTime = stat.end;\n          }\n          if (add && !(stat.start in set)) {\n            set[stat.start] = val;\n            pointEndTime = stat.end;\n          }\n        });\n        sets[id] = set;\n      });\n      if (sum) {\n        summedData[key] = totalStats;\n      }\n      if (add) {\n        combinedData[key] = sets;\n      }\n    });\n\n    const grid_to_battery = {};\n    const battery_to_grid = {};\n    if ((summedData.to_grid || summedData.to_battery) && summedData.solar) {\n      const used_solar = {};\n      for (const start of Object.keys(summedData.solar)) {\n        used_solar[start] =\n          (summedData.solar[start] || 0) -\n          (summedData.to_grid?.[start] || 0) -\n          (summedData.to_battery?.[start] || 0);\n        if (used_solar[start] < 0) {\n          if (summedData.to_battery) {\n            grid_to_battery[start] = used_solar[start] * -1;\n            if (grid_to_battery[start] > (summedData.from_grid?.[start] || 0)) {\n              battery_to_grid[start] = Math.min(\n                0,\n                grid_to_battery[start] - (summedData.from_grid?.[start] || 0)\n              );\n              grid_to_battery[start] = summedData.from_grid?.[start];\n            }\n          }\n          used_solar[start] = 0;\n        }\n      }\n      combinedData.used_solar = { used_solar };\n    }\n\n    if (summedData.from_battery) {\n      if (summedData.to_grid) {\n        const used_battery = {};\n        for (const start of Object.keys(summedData.from_battery)) {\n          used_battery[start] =\n            (summedData.from_battery![start] || 0) -\n            (battery_to_grid[start] || 0);\n        }\n        combinedData.used_battery = { used_battery };\n      } else {\n        combinedData.used_battery = { used_battery: summedData.from_battery };\n      }\n    }\n\n    if (combinedData.from_grid && summedData.to_battery) {\n      const used_grid = {};\n      for (const start of Object.keys(grid_to_battery)) {\n        let noOfSources = 0;\n        let source: string;\n        for (const [key, stats] of Object.entries(combinedData.from_grid)) {\n          if (stats[start]) {\n            source = key;\n            noOfSources++;\n          }\n          if (noOfSources > 1) {\n            break;\n          }\n        }\n        if (noOfSources === 1) {\n          combinedData.from_grid[source!][start] -= grid_to_battery[start] || 0;\n        } else {\n          let total_from_grid = 0;\n          Object.values(combinedData.from_grid).forEach((stats) => {\n            total_from_grid += stats[start] || 0;\n            delete stats[start];\n          });\n          used_grid[start] = total_from_grid - (grid_to_battery[start] || 0);\n        }\n      }\n      combinedData.used_grid = { used_grid };\n    }\n\n    let allKeys: string[] = [];\n\n    Object.values(combinedData).forEach((sources) => {\n      Object.values(sources).forEach((source) => {\n        allKeys = allKeys.concat(Object.keys(source));\n      });\n    });\n\n    const uniqueKeys = Array.from(new Set(allKeys)).sort(\n      (a, b) => Number(a) - Number(b)\n    );\n\n    Object.entries(combinedData).forEach(([type, sources]) => {\n      Object.entries(sources).forEach(([statId, source], idx) => {\n        let borderColor = colors[type].overrides?.[statId];\n        if (!borderColor) {\n          const modifiedColor =\n            idx > 0\n              ? this.hass.themes.darkMode\n                ? labBrighten(rgb2lab(hex2rgb(colors[type].base)), idx)\n                : labDarken(rgb2lab(hex2rgb(colors[type].base)), idx)\n              : undefined;\n          borderColor = modifiedColor\n            ? rgb2hex(lab2rgb(modifiedColor))\n            : colors[type].base;\n        }\n\n        const points: ScatterDataPoint[] = [];\n        // Process chart data.\n        for (const key of uniqueKeys) {\n          const value = source[key] || 0;\n          points.push({\n            x: Number(key),\n            y:\n              value && [\"to_grid\", \"to_battery\"].includes(type)\n                ? -1 * value\n                : value,\n          });\n        }\n        if (points.length === 1) {\n          points.push({\n            x: pointEndTime,\n            y: 0,\n          });\n        }\n\n        data.push({\n          label:\n            type in labels\n              ? labels[type]\n              : getStatisticLabel(\n                  this.hass,\n                  statId,\n                  statisticsMetaData[statId]\n                ),\n          order:\n            type === \"used_solar\"\n              ? 1\n              : type === \"to_battery\"\n                ? Object.keys(combinedData).length\n                : idx + 2,\n          borderColor: compare ? borderColor + \"7F\" : borderColor,\n          backgroundColor: compare ? borderColor + \"32\" : borderColor + \"7F\",\n          stack: \"stack\",\n          data: points,\n          xAxisID: compare ? \"xAxisCompare\" : undefined,\n        });\n      });\n    });\n    return data;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-card {\n        height: 100%;\n      }\n      .card-header {\n        padding-bottom: 0;\n      }\n      .content {\n        padding: 16px;\n      }\n      .has-header {\n        padding-top: 0;\n      }\n      .no-data {\n        position: absolute;\n        height: 100%;\n        top: 0;\n        left: 0;\n        right: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        padding: 20%;\n        margin-left: 32px;\n        margin-inline-start: 32px;\n        margin-inline-end: initial;\n        box-sizing: border-box;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-energy-usage-graph-card\": HuiEnergyUsageGraphCard;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}