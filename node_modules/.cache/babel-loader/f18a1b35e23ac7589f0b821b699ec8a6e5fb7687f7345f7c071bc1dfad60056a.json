{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __decorate } from \"tslib\";\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\nimport '@material/mwc-ripple/mwc-ripple.js';\nimport { ariaProperty } from '@material/mwc-base/aria-property.js';\nimport { addHasRemoveClass, FormElement } from '@material/mwc-base/form-element.js';\nimport { observer } from '@material/mwc-base/observer.js';\nimport { SingleSelectionController } from '@material/mwc-radio/single-selection-controller.js';\nimport { RippleHandlers } from '@material/mwc-ripple/ripple-handlers.js';\nimport MDCRadioFoundation from '@material/radio/foundation.js';\nimport { html } from 'lit';\nimport { eventOptions, property, query, queryAsync, state } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\n/**\n * @fires checked\n * @soyCompatible\n */\nexport class RadioBase extends FormElement {\n  constructor() {\n    super(...arguments);\n    this._checked = false;\n    this.useStateLayerCustomProperties = false;\n    this.global = false;\n    this.disabled = false;\n    this.value = 'on';\n    this.name = '';\n    /**\n     * Touch target extends beyond visual boundary of a component by default.\n     * Set to `true` to remove touch target added to the component.\n     * @see https://material.io/design/usability/accessibility.html\n     */\n    this.reducedTouchTarget = false;\n    this.mdcFoundationClass = MDCRadioFoundation;\n    /**\n     * input's tabindex is updated based on checked status.\n     * Tab navigation will be removed from unchecked radios.\n     */\n    this.formElementTabIndex = 0;\n    this.focused = false;\n    this.shouldRenderRipple = false;\n    this.rippleElement = null;\n    this.rippleHandlers = new RippleHandlers(() => {\n      this.shouldRenderRipple = true;\n      this.ripple.then(v => {\n        this.rippleElement = v;\n      });\n      return this.ripple;\n    });\n  }\n  get checked() {\n    return this._checked;\n  }\n  /**\n   * We define our own getter/setter for `checked` because we need to track\n   * changes to it synchronously.\n   *\n   * The order in which the `checked` property is set across radio buttons\n   * within the same group is very important. However, we can't rely on\n   * UpdatingElement's `updated` callback to observe these changes (which is\n   * also what the `@observer` decorator uses), because it batches changes to\n   * all properties.\n   *\n   * Consider:\n   *\n   *   radio1.disabled = true;\n   *   radio2.checked = true;\n   *   radio1.checked = true;\n   *\n   * In this case we'd first see all changes for radio1, and then for radio2,\n   * and we couldn't tell that radio1 was the most recently checked.\n   */\n  set checked(isChecked) {\n    var _a, _b;\n    const oldValue = this._checked;\n    if (isChecked === oldValue) {\n      return;\n    }\n    this._checked = isChecked;\n    if (this.formElement) {\n      this.formElement.checked = isChecked;\n    }\n    (_a = this._selectionController) === null || _a === void 0 ? void 0 : _a.update(this);\n    if (isChecked === false) {\n      // Remove focus ring when unchecked on other radio programmatically.\n      // Blur on input since this determines the focus style.\n      (_b = this.formElement) === null || _b === void 0 ? void 0 : _b.blur();\n    }\n    this.requestUpdate('checked', oldValue);\n    // useful when unchecks self and wrapping element needs to synchronize\n    // TODO(b/168543810): Remove triggering event on programmatic API call.\n    this.dispatchEvent(new Event('checked', {\n      bubbles: true,\n      composed: true\n    }));\n  }\n  _handleUpdatedValue(newValue) {\n    // the observer function can't access protected fields (according to\n    // closure compiler) because it's not a method on the class, so we need this\n    // wrapper.\n    this.formElement.value = newValue;\n  }\n  /** @soyTemplate */\n  renderRipple() {\n    return this.shouldRenderRipple ? html`<mwc-ripple unbounded accent\n        .internalUseStateLayerCustomProperties=\"${this.useStateLayerCustomProperties}\"\n        .disabled=\"${this.disabled}\"></mwc-ripple>` : '';\n  }\n  get isRippleActive() {\n    var _a;\n    return ((_a = this.rippleElement) === null || _a === void 0 ? void 0 : _a.isActive) || false;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    // Note that we must defer creating the selection controller until the\n    // element has connected, because selection controllers are keyed by the\n    // radio's shadow root. For example, if we're stamping in a lit map\n    // or repeat, then we'll be constructed before we're added to a root node.\n    //\n    // Also note if we aren't using native shadow DOM, we still need a\n    // SelectionController, because we should update checked status of other\n    // radios in the group when selection changes. It also simplifies\n    // implementation and testing to use one in all cases.\n    //\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    this._selectionController = SingleSelectionController.getController(this);\n    this._selectionController.register(this);\n    // Radios maybe checked before connected, update selection as soon it is\n    // connected to DOM. Last checked radio button in the DOM will be selected.\n    //\n    // NOTE: If we update selection only after firstUpdate() we might mistakenly\n    // update checked status before other radios are rendered.\n    this._selectionController.update(this);\n  }\n  disconnectedCallback() {\n    // The controller is initialized in connectedCallback, so if we are in\n    // disconnectedCallback then it must be initialized.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._selectionController.unregister(this);\n    this._selectionController = undefined;\n  }\n  focus() {\n    this.formElement.focus();\n  }\n  createAdapter() {\n    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {\n      setNativeControlDisabled: disabled => {\n        this.formElement.disabled = disabled;\n      }\n    });\n  }\n  handleFocus() {\n    this.focused = true;\n    this.handleRippleFocus();\n  }\n  handleClick() {\n    // Firefox has weird behavior with radios if they are not focused\n    this.formElement.focus();\n  }\n  handleBlur() {\n    this.focused = false;\n    this.formElement.blur();\n    this.rippleHandlers.endFocus();\n  }\n  setFormData(formData) {\n    if (this.name && this.checked) {\n      formData.append(this.name, this.value);\n    }\n  }\n  /**\n   * @soyTemplate\n   * @soyAttributes radioAttributes: input\n   * @soyClasses radioClasses: .mdc-radio\n   */\n  render() {\n    /** @classMap */\n    const classes = {\n      'mdc-radio--touch': !this.reducedTouchTarget,\n      'mdc-ripple-upgraded--background-focused': this.focused,\n      'mdc-radio--disabled': this.disabled\n    };\n    return html`\n      <div class=\"mdc-radio ${classMap(classes)}\">\n        <input\n          tabindex=\"${this.formElementTabIndex}\"\n          class=\"mdc-radio__native-control\"\n          type=\"radio\"\n          name=\"${this.name}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n          .checked=\"${this.checked}\"\n          .value=\"${this.value}\"\n          ?disabled=\"${this.disabled}\"\n          @change=\"${this.changeHandler}\"\n          @focus=\"${this.handleFocus}\"\n          @click=\"${this.handleClick}\"\n          @blur=\"${this.handleBlur}\"\n          @mousedown=\"${this.handleRippleMouseDown}\"\n          @mouseenter=\"${this.handleRippleMouseEnter}\"\n          @mouseleave=\"${this.handleRippleMouseLeave}\"\n          @touchstart=\"${this.handleRippleTouchStart}\"\n          @touchend=\"${this.handleRippleDeactivate}\"\n          @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-radio__background\">\n          <div class=\"mdc-radio__outer-circle\"></div>\n          <div class=\"mdc-radio__inner-circle\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n  }\n  handleRippleMouseDown(event) {\n    const onUp = () => {\n      window.removeEventListener('mouseup', onUp);\n      this.handleRippleDeactivate();\n    };\n    window.addEventListener('mouseup', onUp);\n    this.rippleHandlers.startPress(event);\n  }\n  handleRippleTouchStart(event) {\n    this.rippleHandlers.startPress(event);\n  }\n  handleRippleDeactivate() {\n    this.rippleHandlers.endPress();\n  }\n  handleRippleMouseEnter() {\n    this.rippleHandlers.startHover();\n  }\n  handleRippleMouseLeave() {\n    this.rippleHandlers.endHover();\n  }\n  handleRippleFocus() {\n    this.rippleHandlers.startFocus();\n  }\n  changeHandler() {\n    this.checked = this.formElement.checked;\n  }\n}\n__decorate([query('.mdc-radio')], RadioBase.prototype, \"mdcRoot\", void 0);\n__decorate([query('input')], RadioBase.prototype, \"formElement\", void 0);\n__decorate([state()], RadioBase.prototype, \"useStateLayerCustomProperties\", void 0);\n__decorate([property({\n  type: Boolean\n})], RadioBase.prototype, \"global\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], RadioBase.prototype, \"checked\", null);\n__decorate([property({\n  type: Boolean\n}), observer(function (disabled) {\n  this.mdcFoundation.setDisabled(disabled);\n})], RadioBase.prototype, \"disabled\", void 0);\n__decorate([property({\n  type: String\n}), observer(function (value) {\n  this._handleUpdatedValue(value);\n})], RadioBase.prototype, \"value\", void 0);\n__decorate([property({\n  type: String\n})], RadioBase.prototype, \"name\", void 0);\n__decorate([property({\n  type: Boolean\n})], RadioBase.prototype, \"reducedTouchTarget\", void 0);\n__decorate([property({\n  type: Number\n})], RadioBase.prototype, \"formElementTabIndex\", void 0);\n__decorate([state()], RadioBase.prototype, \"focused\", void 0);\n__decorate([state()], RadioBase.prototype, \"shouldRenderRipple\", void 0);\n__decorate([queryAsync('mwc-ripple')], RadioBase.prototype, \"ripple\", void 0);\n__decorate([ariaProperty, property({\n  attribute: 'aria-label'\n})], RadioBase.prototype, \"ariaLabel\", void 0);\n__decorate([ariaProperty, property({\n  attribute: 'aria-labelledby'\n})], RadioBase.prototype, \"ariaLabelledBy\", void 0);\n__decorate([eventOptions({\n  passive: true\n})], RadioBase.prototype, \"handleRippleTouchStart\", null);","map":{"version":3,"names":["ariaProperty","addHasRemoveClass","FormElement","observer","SingleSelectionController","RippleHandlers","MDCRadioFoundation","html","eventOptions","property","query","queryAsync","state","classMap","ifDefined","RadioBase","constructor","_checked","useStateLayerCustomProperties","global","disabled","value","name","reducedTouchTarget","mdcFoundationClass","formElementTabIndex","focused","shouldRenderRipple","rippleElement","rippleHandlers","ripple","then","v","checked","isChecked","oldValue","formElement","_a","_selectionController","update","_b","blur","requestUpdate","dispatchEvent","Event","bubbles","composed","_handleUpdatedValue","newValue","renderRipple","isRippleActive","isActive","connectedCallback","getController","register","disconnectedCallback","unregister","undefined","focus","createAdapter","Object","assign","mdcRoot","setNativeControlDisabled","handleFocus","handleRippleFocus","handleClick","handleBlur","endFocus","setFormData","formData","append","render","classes","ariaLabel","ariaLabelledBy","changeHandler","handleRippleMouseDown","handleRippleMouseEnter","handleRippleMouseLeave","handleRippleTouchStart","handleRippleDeactivate","event","onUp","window","removeEventListener","addEventListener","startPress","endPress","startHover","endHover","startFocus","__decorate","type","Boolean","reflect","mdcFoundation","setDisabled","String","Number","attribute","passive"],"sources":["mwc-radio-base.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\nimport '@material/mwc-ripple/mwc-ripple.js';\n\nimport {ariaProperty} from '@material/mwc-base/aria-property.js';\nimport {addHasRemoveClass, FormElement} from '@material/mwc-base/form-element.js';\nimport {observer} from '@material/mwc-base/observer.js';\nimport {SingleSelectionController} from '@material/mwc-radio/single-selection-controller.js';\nimport {Ripple} from '@material/mwc-ripple/mwc-ripple.js';\nimport {RippleHandlers} from '@material/mwc-ripple/ripple-handlers.js';\nimport {MDCRadioAdapter} from '@material/radio/adapter.js';\nimport MDCRadioFoundation from '@material/radio/foundation.js';\nimport {html, TemplateResult} from 'lit';\nimport {eventOptions, property, query, queryAsync, state} from 'lit/decorators.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport {ifDefined} from 'lit/directives/if-defined.js';\n\n/**\n * @fires checked\n * @soyCompatible\n */\nexport class RadioBase extends FormElement {\n  @query('.mdc-radio') protected mdcRoot!: HTMLElement;\n\n  @query('input') protected formElement!: HTMLInputElement;\n\n  protected _checked = false;\n\n  @state() protected useStateLayerCustomProperties = false;\n\n  @property({type: Boolean}) global = false;\n\n  @property({type: Boolean, reflect: true})\n  get checked(): boolean {\n    return this._checked;\n  }\n\n  /**\n   * We define our own getter/setter for `checked` because we need to track\n   * changes to it synchronously.\n   *\n   * The order in which the `checked` property is set across radio buttons\n   * within the same group is very important. However, we can't rely on\n   * UpdatingElement's `updated` callback to observe these changes (which is\n   * also what the `@observer` decorator uses), because it batches changes to\n   * all properties.\n   *\n   * Consider:\n   *\n   *   radio1.disabled = true;\n   *   radio2.checked = true;\n   *   radio1.checked = true;\n   *\n   * In this case we'd first see all changes for radio1, and then for radio2,\n   * and we couldn't tell that radio1 was the most recently checked.\n   */\n  set checked(isChecked: boolean) {\n    const oldValue = this._checked;\n    if (isChecked === oldValue) {\n      return;\n    }\n    this._checked = isChecked;\n    if (this.formElement) {\n      this.formElement.checked = isChecked;\n    }\n    this._selectionController?.update(this);\n\n    if (isChecked === false) {\n      // Remove focus ring when unchecked on other radio programmatically.\n      // Blur on input since this determines the focus style.\n      this.formElement?.blur();\n    }\n    this.requestUpdate('checked', oldValue);\n\n    // useful when unchecks self and wrapping element needs to synchronize\n    // TODO(b/168543810): Remove triggering event on programmatic API call.\n    this.dispatchEvent(new Event('checked', {bubbles: true, composed: true}));\n  }\n\n  @property({type: Boolean})\n  @observer(function(this: RadioBase, disabled: boolean) {\n    this.mdcFoundation.setDisabled(disabled);\n  })\n  override disabled = false;\n\n  @property({type: String})\n  @observer(function(this: RadioBase, value: string) {\n    this._handleUpdatedValue(value);\n  })\n  value = 'on';\n\n  _handleUpdatedValue(newValue: string) {\n    // the observer function can't access protected fields (according to\n    // closure compiler) because it's not a method on the class, so we need this\n    // wrapper.\n    this.formElement.value = newValue;\n  }\n\n  @property({type: String}) name = '';\n\n  /**\n   * Touch target extends beyond visual boundary of a component by default.\n   * Set to `true` to remove touch target added to the component.\n   * @see https://material.io/design/usability/accessibility.html\n   */\n  @property({type: Boolean}) reducedTouchTarget = false;\n\n  protected mdcFoundationClass = MDCRadioFoundation;\n\n  protected mdcFoundation!: MDCRadioFoundation;\n\n  protected _selectionController?: SingleSelectionController;\n\n  /**\n   * input's tabindex is updated based on checked status.\n   * Tab navigation will be removed from unchecked radios.\n   */\n  @property({type: Number}) formElementTabIndex = 0;\n\n  @state() protected focused = false;\n  @state() protected shouldRenderRipple = false;\n\n  @queryAsync('mwc-ripple') override ripple!: Promise<Ripple|null>;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({attribute: 'aria-label'})\n  override ariaLabel!: string;\n\n  /** @soyPrefixAttribute */\n  @ariaProperty\n  @property({attribute: 'aria-labelledby'})\n  ariaLabelledBy!: string;\n\n  protected rippleElement: Ripple|null = null;\n\n  protected rippleHandlers: RippleHandlers = new RippleHandlers(() => {\n    this.shouldRenderRipple = true;\n    this.ripple.then((v) => {\n      this.rippleElement = v;\n    });\n\n    return this.ripple;\n  });\n\n  /** @soyTemplate */\n  protected renderRipple(): TemplateResult|string {\n    return this.shouldRenderRipple ? html`<mwc-ripple unbounded accent\n        .internalUseStateLayerCustomProperties=\"${\n                                         this.useStateLayerCustomProperties}\"\n        .disabled=\"${this.disabled}\"></mwc-ripple>` :\n                                     '';\n  }\n\n  get isRippleActive() {\n    return this.rippleElement?.isActive || false;\n  }\n\n  override connectedCallback() {\n    super.connectedCallback();\n    // Note that we must defer creating the selection controller until the\n    // element has connected, because selection controllers are keyed by the\n    // radio's shadow root. For example, if we're stamping in a lit map\n    // or repeat, then we'll be constructed before we're added to a root node.\n    //\n    // Also note if we aren't using native shadow DOM, we still need a\n    // SelectionController, because we should update checked status of other\n    // radios in the group when selection changes. It also simplifies\n    // implementation and testing to use one in all cases.\n    //\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    this._selectionController = SingleSelectionController.getController(this);\n    this._selectionController.register(this);\n\n    // Radios maybe checked before connected, update selection as soon it is\n    // connected to DOM. Last checked radio button in the DOM will be selected.\n    //\n    // NOTE: If we update selection only after firstUpdate() we might mistakenly\n    // update checked status before other radios are rendered.\n    this._selectionController.update(this);\n  }\n\n  override disconnectedCallback() {\n    // The controller is initialized in connectedCallback, so if we are in\n    // disconnectedCallback then it must be initialized.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._selectionController!.unregister(this);\n    this._selectionController = undefined;\n  }\n\n  override focus() {\n    this.formElement.focus();\n  }\n\n  protected createAdapter(): MDCRadioAdapter {\n    return {\n      ...addHasRemoveClass(this.mdcRoot),\n      setNativeControlDisabled: (disabled: boolean) => {\n        this.formElement.disabled = disabled;\n      },\n    };\n  }\n\n  protected handleFocus() {\n    this.focused = true;\n    this.handleRippleFocus();\n  }\n\n  protected handleClick() {\n    // Firefox has weird behavior with radios if they are not focused\n    this.formElement.focus();\n  }\n\n  protected handleBlur() {\n    this.focused = false;\n    this.formElement.blur();\n    this.rippleHandlers.endFocus();\n  }\n\n  protected setFormData(formData: FormData) {\n    if (this.name && this.checked) {\n      formData.append(this.name, this.value);\n    }\n  }\n\n  /**\n   * @soyTemplate\n   * @soyAttributes radioAttributes: input\n   * @soyClasses radioClasses: .mdc-radio\n   */\n  protected override render(): TemplateResult {\n    /** @classMap */\n    const classes = {\n      'mdc-radio--touch': !this.reducedTouchTarget,\n      'mdc-ripple-upgraded--background-focused': this.focused,\n      'mdc-radio--disabled': this.disabled,\n    };\n\n    return html`\n      <div class=\"mdc-radio ${classMap(classes)}\">\n        <input\n          tabindex=\"${this.formElementTabIndex}\"\n          class=\"mdc-radio__native-control\"\n          type=\"radio\"\n          name=\"${this.name}\"\n          aria-label=\"${ifDefined(this.ariaLabel)}\"\n          aria-labelledby=\"${ifDefined(this.ariaLabelledBy)}\"\n          .checked=\"${this.checked}\"\n          .value=\"${this.value}\"\n          ?disabled=\"${this.disabled}\"\n          @change=\"${this.changeHandler}\"\n          @focus=\"${this.handleFocus}\"\n          @click=\"${this.handleClick}\"\n          @blur=\"${this.handleBlur}\"\n          @mousedown=\"${this.handleRippleMouseDown}\"\n          @mouseenter=\"${this.handleRippleMouseEnter}\"\n          @mouseleave=\"${this.handleRippleMouseLeave}\"\n          @touchstart=\"${this.handleRippleTouchStart}\"\n          @touchend=\"${this.handleRippleDeactivate}\"\n          @touchcancel=\"${this.handleRippleDeactivate}\">\n        <div class=\"mdc-radio__background\">\n          <div class=\"mdc-radio__outer-circle\"></div>\n          <div class=\"mdc-radio__inner-circle\"></div>\n        </div>\n        ${this.renderRipple()}\n      </div>`;\n  }\n\n  protected handleRippleMouseDown(event: Event) {\n    const onUp = () => {\n      window.removeEventListener('mouseup', onUp);\n\n      this.handleRippleDeactivate();\n    };\n\n    window.addEventListener('mouseup', onUp);\n    this.rippleHandlers.startPress(event);\n  }\n\n  @eventOptions({passive: true})\n  protected handleRippleTouchStart(event: Event) {\n    this.rippleHandlers.startPress(event);\n  }\n\n  protected handleRippleDeactivate() {\n    this.rippleHandlers.endPress();\n  }\n\n  protected handleRippleMouseEnter() {\n    this.rippleHandlers.startHover();\n  }\n\n  protected handleRippleMouseLeave() {\n    this.rippleHandlers.endHover();\n  }\n\n  protected handleRippleFocus() {\n    this.rippleHandlers.startFocus();\n  }\n\n  protected changeHandler() {\n    this.checked = this.formElement.checked;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}