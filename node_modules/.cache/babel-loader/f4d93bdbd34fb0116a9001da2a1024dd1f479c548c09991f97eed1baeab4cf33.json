{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/createForOfIteratorHelper\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/esnext.set.difference.v2.js\";\nimport \"core-js/modules/esnext.set.intersection.v2.js\";\nimport \"core-js/modules/esnext.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/esnext.set.is-subset-of.v2.js\";\nimport \"core-js/modules/esnext.set.is-superset-of.v2.js\";\nimport \"core-js/modules/esnext.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/esnext.set.union.v2.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\n/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n/**\n * Unique symbol for marking roots\n */\nvar selectionController = Symbol('selection controller');\n/**\n * Set of checkable elements with added metadata\n */\nexport var SingleSelectionSet = /*#__PURE__*/_createClass(function SingleSelectionSet() {\n  _classCallCheck(this, SingleSelectionSet);\n  this.selected = null;\n  this.ordered = null;\n  this.set = new Set();\n});\n/**\n * Controller that provides behavior similar to a native `<input type=\"radio\">`\n * group.\n *\n * Behaviors:\n *\n * - Selection via key navigation (currently LTR is supported)\n * - Deselection of other grouped, checkable controls upon selection\n * - Grouping of checkable elements by name\n *   - Defaults grouping scope to host shadow root\n *   - Document-wide scoping enabled\n * - Land focus only on checked element. Focuses leading element when none\n *   checked.\n *\n * Intended Usage:\n *\n * ```ts\n * class MyElement extends HTMLElement {\n *   private selectionController: SingleSelectionController | null = null;\n *   name = \"\";\n *   global = false;\n *\n *   private _checked = false;\n *   set checked(checked: boolean) {\n *     const oldVal = this._checked;\n *     if (checked === oldVal) return;\n *\n *     this._checked = checked;\n *\n *     if (this.selectionController) {\n *       this.selectionController.update(this)\n *     }\n *   }\n *\n *   get checked() {\n *     return this._checked;\n *   }\n *\n *   connectedCallback() {\n *     this.selectionController = SelectionController.getController(this);\n *     this.selectionController.register(this);\n *     this.selectionController.update(this);\n *   }\n *\n *   disconnectedCallback() {\n *     this.selectionController!.unregister(this);\n *     this.selectionController = null;\n *   }\n * }\n * ```\n */\nexport var SingleSelectionController = /*#__PURE__*/function () {\n  function SingleSelectionController(element) {\n    var _this = this;\n    _classCallCheck(this, SingleSelectionController);\n    this.sets = {};\n    this.focusedSet = null;\n    this.mouseIsDown = false;\n    this.updating = false;\n    element.addEventListener('keydown', function (e) {\n      _this.keyDownHandler(e);\n    });\n    element.addEventListener('mousedown', function () {\n      _this.mousedownHandler();\n    });\n    element.addEventListener('mouseup', function () {\n      _this.mouseupHandler();\n    });\n  }\n  /**\n   * Get a controller for the given element. If no controller exists, one will\n   * be created. Defaults to getting the controller scoped to the element's root\n   * node shadow root unless `element.global` is true. Then, it will get a\n   * `window.document`-scoped controller.\n   *\n   * @param element Element from which to get / create a SelectionController. If\n   *     `element.global` is true, it gets a selection controller scoped to\n   *     `window.document`.\n   */\n  _createClass(SingleSelectionController, [{\n    key: \"keyDownHandler\",\n    value: function keyDownHandler(e) {\n      var element = e.target;\n      if (!('checked' in element)) {\n        return;\n      }\n      if (!this.has(element)) {\n        return;\n      }\n      if (e.key == 'ArrowRight' || e.key == 'ArrowDown') {\n        this.selectNext(element);\n      } else if (e.key == 'ArrowLeft' || e.key == 'ArrowUp') {\n        this.selectPrevious(element);\n      }\n    }\n  }, {\n    key: \"mousedownHandler\",\n    value: function mousedownHandler() {\n      this.mouseIsDown = true;\n    }\n  }, {\n    key: \"mouseupHandler\",\n    value: function mouseupHandler() {\n      this.mouseIsDown = false;\n    }\n    /**\n     * Whether or not the controller controls  the given element.\n     *\n     * @param element element to check\n     */\n  }, {\n    key: \"has\",\n    value: function has(element) {\n      var set = this.getSet(element.name);\n      return set.set.has(element);\n    }\n    /**\n     * Selects and returns the controlled element previous to the given element in\n     * document position order. See\n     * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n     *\n     * @param element element relative from which preceding element is fetched\n     */\n  }, {\n    key: \"selectPrevious\",\n    value: function selectPrevious(element) {\n      var order = this.getOrdered(element);\n      var i = order.indexOf(element);\n      var previous = order[i - 1] || order[order.length - 1];\n      this.select(previous);\n      return previous;\n    }\n    /**\n     * Selects and returns the controlled element next to the given element in\n     * document position order. See\n     * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n     *\n     * @param element element relative from which following element is fetched\n     */\n  }, {\n    key: \"selectNext\",\n    value: function selectNext(element) {\n      var order = this.getOrdered(element);\n      var i = order.indexOf(element);\n      var next = order[i + 1] || order[0];\n      this.select(next);\n      return next;\n    }\n  }, {\n    key: \"select\",\n    value: function select(element) {\n      element.click();\n    }\n    /**\n     * Focuses the selected element in the given element's selection set. User's\n     * mouse selection will override this focus.\n     *\n     * @param element Element from which selection set is derived and subsequently\n     *     focused.\n     * @deprecated update() method now handles focus management by setting\n     *     appropriate tabindex to form element.\n     */\n  }, {\n    key: \"focus\",\n    value: function focus(element) {\n      // Only manage focus state when using keyboard\n      if (this.mouseIsDown) {\n        return;\n      }\n      var set = this.getSet(element.name);\n      var currentFocusedSet = this.focusedSet;\n      this.focusedSet = set;\n      if (currentFocusedSet != set && set.selected && set.selected != element) {\n        set.selected.focus();\n      }\n    }\n    /**\n     * @return Returns true if atleast one radio is selected in the radio group.\n     */\n  }, {\n    key: \"isAnySelected\",\n    value: function isAnySelected(element) {\n      var set = this.getSet(element.name);\n      var _iterator = _createForOfIteratorHelper(set.set),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var e = _step.value;\n          if (e.checked) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n    /**\n     * Returns the elements in the given element's selection set in document\n     * position order.\n     * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n     *\n     * @param element Element from which selection set is derived and subsequently\n     *     ordered.\n     */\n  }, {\n    key: \"getOrdered\",\n    value: function getOrdered(element) {\n      var set = this.getSet(element.name);\n      if (!set.ordered) {\n        set.ordered = Array.from(set.set);\n        set.ordered.sort(function (a, b) {\n          return a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;\n        });\n      }\n      return set.ordered;\n    }\n    /**\n     * Gets the selection set of the given name and creates one if it does not yet\n     * exist.\n     *\n     * @param name Name of set\n     */\n  }, {\n    key: \"getSet\",\n    value: function getSet(name) {\n      if (!this.sets[name]) {\n        this.sets[name] = new SingleSelectionSet();\n      }\n      return this.sets[name];\n    }\n    /**\n     * Register the element in the selection controller.\n     *\n     * @param element Element to register. Registers in set of `element.name`.\n     */\n  }, {\n    key: \"register\",\n    value: function register(element) {\n      // TODO(b/168546148): Remove accessing 'name' via getAttribute() when new\n      // base class is created without single selection controller. Component\n      // maybe booted up after it is connected to DOM in which case properties\n      // (including `name`) are not updated yet.\n      var name = element.name || element.getAttribute('name') || '';\n      var set = this.getSet(name);\n      set.set.add(element);\n      set.ordered = null;\n    }\n    /**\n     * Unregister the element from selection controller.\n     *\n     * @param element Element to register. Registers in set of `element.name`.\n     */\n  }, {\n    key: \"unregister\",\n    value: function unregister(element) {\n      var set = this.getSet(element.name);\n      set.set.delete(element);\n      set.ordered = null;\n      if (set.selected == element) {\n        set.selected = null;\n      }\n    }\n    /**\n     * Unselects other elements in element's set if element is checked. Noop\n     * otherwise.\n     *\n     * @param element Element from which to calculate selection controller update.\n     */\n  }, {\n    key: \"update\",\n    value: function update(element) {\n      if (this.updating) {\n        return;\n      }\n      this.updating = true;\n      var set = this.getSet(element.name);\n      if (element.checked) {\n        var _iterator2 = _createForOfIteratorHelper(set.set),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var e = _step2.value;\n            if (e == element) {\n              continue;\n            }\n            e.checked = false;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        set.selected = element;\n      }\n      // When tabbing through land focus on the checked radio in the group.\n      if (this.isAnySelected(element)) {\n        var _iterator3 = _createForOfIteratorHelper(set.set),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _e = _step3.value;\n            if (_e.formElementTabIndex === undefined) {\n              break;\n            }\n            _e.formElementTabIndex = _e.checked ? 0 : -1;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      this.updating = false;\n    }\n  }], [{\n    key: \"getController\",\n    value: function getController(element) {\n      var useGlobal = !('global' in element) || 'global' in element && element.global;\n      var root = useGlobal ? document : element.getRootNode();\n      var controller = root[selectionController];\n      if (controller === undefined) {\n        controller = new SingleSelectionController(root);\n        root[selectionController] = controller;\n      }\n      return controller;\n    }\n  }]);\n  return SingleSelectionController;\n}();","map":{"version":3,"names":["selectionController","Symbol","SingleSelectionSet","_createClass","_classCallCheck","selected","ordered","set","Set","SingleSelectionController","element","_this","sets","focusedSet","mouseIsDown","updating","addEventListener","e","keyDownHandler","mousedownHandler","mouseupHandler","key","value","target","has","selectNext","selectPrevious","getSet","name","order","getOrdered","i","indexOf","previous","length","select","next","click","focus","currentFocusedSet","isAnySelected","_iterator","_createForOfIteratorHelper","_step","s","n","done","checked","err","f","Array","from","sort","a","b","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","register","getAttribute","add","unregister","delete","update","_iterator2","_step2","_iterator3","_step3","formElementTabIndex","undefined","getController","useGlobal","global","root","document","getRootNode","controller"],"sources":["single-selection-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// Style preference for leading underscores.\n// tslint:disable:strip-private-property-underscore\n\n/**\n * Unique symbol for marking roots\n */\nconst selectionController = Symbol('selection controller');\n\n/**\n * Set of checkable elements with added metadata\n */\nexport class SingleSelectionSet {\n  selected: CheckableElement|null = null;\n  ordered: CheckableElement[]|null = null;\n  readonly set = new Set<CheckableElement>();\n}\n\n/**\n * Element that is checkable consumed by\n * `SingleSelectionController` and `SingleSelectionSet`\n */\nexport type CheckableElement = HTMLElement&{\n  name: string;\n  checked: boolean;\n  formElementTabIndex?: number;\n};\n\n/**\n * Controller that provides behavior similar to a native `<input type=\"radio\">`\n * group.\n *\n * Behaviors:\n *\n * - Selection via key navigation (currently LTR is supported)\n * - Deselection of other grouped, checkable controls upon selection\n * - Grouping of checkable elements by name\n *   - Defaults grouping scope to host shadow root\n *   - Document-wide scoping enabled\n * - Land focus only on checked element. Focuses leading element when none\n *   checked.\n *\n * Intended Usage:\n *\n * ```ts\n * class MyElement extends HTMLElement {\n *   private selectionController: SingleSelectionController | null = null;\n *   name = \"\";\n *   global = false;\n *\n *   private _checked = false;\n *   set checked(checked: boolean) {\n *     const oldVal = this._checked;\n *     if (checked === oldVal) return;\n *\n *     this._checked = checked;\n *\n *     if (this.selectionController) {\n *       this.selectionController.update(this)\n *     }\n *   }\n *\n *   get checked() {\n *     return this._checked;\n *   }\n *\n *   connectedCallback() {\n *     this.selectionController = SelectionController.getController(this);\n *     this.selectionController.register(this);\n *     this.selectionController.update(this);\n *   }\n *\n *   disconnectedCallback() {\n *     this.selectionController!.unregister(this);\n *     this.selectionController = null;\n *   }\n * }\n * ```\n */\nexport class SingleSelectionController {\n  private readonly sets: {[name: string]: SingleSelectionSet} = {};\n\n  private focusedSet: SingleSelectionSet|null = null;\n\n  private mouseIsDown = false;\n\n  private updating = false;\n\n  /**\n   * Get a controller for the given element. If no controller exists, one will\n   * be created. Defaults to getting the controller scoped to the element's root\n   * node shadow root unless `element.global` is true. Then, it will get a\n   * `window.document`-scoped controller.\n   *\n   * @param element Element from which to get / create a SelectionController. If\n   *     `element.global` is true, it gets a selection controller scoped to\n   *     `window.document`.\n   */\n  static getController(element: HTMLElement|HTMLElement&{global: boolean}) {\n    const useGlobal =\n        !('global' in element) || ('global' in element && element.global);\n    const root = useGlobal ? document as Document &\n            {[selectionController]?: SingleSelectionController} :\n                             (element as Element).getRootNode() as Node &\n            {[selectionController]?: SingleSelectionController};\n    let controller = root[selectionController];\n    if (controller === undefined) {\n      controller = new SingleSelectionController(root);\n      root[selectionController] = controller;\n    }\n    return controller;\n  }\n\n  constructor(element: Node) {\n    element.addEventListener('keydown', (e: Event) => {\n      this.keyDownHandler(e as KeyboardEvent);\n    });\n    element.addEventListener('mousedown', () => {\n      this.mousedownHandler();\n    });\n    element.addEventListener('mouseup', () => {\n      this.mouseupHandler();\n    });\n  }\n\n  protected keyDownHandler(e: KeyboardEvent) {\n    const element = e.target as EventTarget | CheckableElement;\n    if (!('checked' in element)) {\n      return;\n    }\n    if (!this.has(element)) {\n      return;\n    }\n    if (e.key == 'ArrowRight' || e.key == 'ArrowDown') {\n      this.selectNext(element);\n    } else if (e.key == 'ArrowLeft' || e.key == 'ArrowUp') {\n      this.selectPrevious(element);\n    }\n  }\n\n  protected mousedownHandler() {\n    this.mouseIsDown = true;\n  }\n\n  protected mouseupHandler() {\n    this.mouseIsDown = false;\n  }\n\n  /**\n   * Whether or not the controller controls  the given element.\n   *\n   * @param element element to check\n   */\n  has(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    return set.set.has(element);\n  }\n\n  /**\n   * Selects and returns the controlled element previous to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which preceding element is fetched\n   */\n  selectPrevious(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const previous = order[i - 1] || order[order.length - 1];\n    this.select(previous);\n\n    return previous;\n  }\n\n  /**\n   * Selects and returns the controlled element next to the given element in\n   * document position order. See\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element element relative from which following element is fetched\n   */\n  selectNext(element: CheckableElement) {\n    const order = this.getOrdered(element);\n    const i = order.indexOf(element);\n    const next = order[i + 1] || order[0];\n    this.select(next);\n\n    return next;\n  }\n\n  select(element: CheckableElement) {\n    element.click();\n  }\n\n  /**\n   * Focuses the selected element in the given element's selection set. User's\n   * mouse selection will override this focus.\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     focused.\n   * @deprecated update() method now handles focus management by setting\n   *     appropriate tabindex to form element.\n   */\n  focus(element: CheckableElement) {\n    // Only manage focus state when using keyboard\n    if (this.mouseIsDown) {\n      return;\n    }\n    const set = this.getSet(element.name);\n    const currentFocusedSet = this.focusedSet;\n    this.focusedSet = set;\n    if (currentFocusedSet != set && set.selected && set.selected != element) {\n      set.selected.focus();\n    }\n  }\n\n  /**\n   * @return Returns true if atleast one radio is selected in the radio group.\n   */\n  isAnySelected(element: CheckableElement): boolean {\n    const set = this.getSet(element.name);\n\n    for (const e of set.set) {\n      if (e.checked) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the elements in the given element's selection set in document\n   * position order.\n   * [Node.compareDocumentPosition](https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * @param element Element from which selection set is derived and subsequently\n   *     ordered.\n   */\n  getOrdered(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    if (!set.ordered) {\n      set.ordered = Array.from(set.set);\n      set.ordered.sort(\n          (a, b) =>\n              a.compareDocumentPosition(b) == Node.DOCUMENT_POSITION_PRECEDING ?\n              1 :\n              0);\n    }\n    return set.ordered;\n  }\n\n  /**\n   * Gets the selection set of the given name and creates one if it does not yet\n   * exist.\n   *\n   * @param name Name of set\n   */\n  getSet(name: string): SingleSelectionSet {\n    if (!this.sets[name]) {\n      this.sets[name] = new SingleSelectionSet();\n    }\n    return this.sets[name];\n  }\n\n  /**\n   * Register the element in the selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  register(element: CheckableElement) {\n    // TODO(b/168546148): Remove accessing 'name' via getAttribute() when new\n    // base class is created without single selection controller. Component\n    // maybe booted up after it is connected to DOM in which case properties\n    // (including `name`) are not updated yet.\n    const name = element.name || element.getAttribute('name') || '';\n    const set = this.getSet(name);\n    set.set.add(element);\n    set.ordered = null;\n  }\n\n  /**\n   * Unregister the element from selection controller.\n   *\n   * @param element Element to register. Registers in set of `element.name`.\n   */\n  unregister(element: CheckableElement) {\n    const set = this.getSet(element.name);\n    set.set.delete(element);\n    set.ordered = null;\n    if (set.selected == element) {\n      set.selected = null;\n    }\n  }\n\n  /**\n   * Unselects other elements in element's set if element is checked. Noop\n   * otherwise.\n   *\n   * @param element Element from which to calculate selection controller update.\n   */\n  update(element: CheckableElement) {\n    if (this.updating) {\n      return;\n    }\n    this.updating = true;\n    const set = this.getSet(element.name);\n    if (element.checked) {\n      for (const e of set.set) {\n        if (e == element) {\n          continue;\n        }\n        e.checked = false;\n      }\n      set.selected = element;\n    }\n\n    // When tabbing through land focus on the checked radio in the group.\n    if (this.isAnySelected(element)) {\n      for (const e of set.set) {\n        if (e.formElementTabIndex === undefined) {\n          break;\n        }\n\n        e.formElementTabIndex = e.checked ? 0 : -1;\n      }\n    }\n    this.updating = false;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}