{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport { strokeWidth } from \"../../../../data/graph\";\nvar average = function average(items) {\n  return items.reduce(function (sum, entry) {\n    return sum + parseFloat(entry.state);\n  }, 0) / items.length;\n};\nvar lastValue = function lastValue(items) {\n  return parseFloat(items[items.length - 1].state) || 0;\n};\nvar calcPoints = function calcPoints(history, hours, width, detail, min, max) {\n  var coords = [];\n  var height = 80;\n  var yRatio = (max - min) / height;\n  yRatio = yRatio !== 0 ? yRatio : height;\n  var xRatio = width / (hours - (detail === 1 ? 1 : 0));\n  xRatio = isFinite(xRatio) ? xRatio : width;\n  var first = history.filter(Boolean)[0];\n  var last = [average(first), lastValue(first)];\n  var getCoords = function getCoords(item, i) {\n    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    if (depth > 1 && item) {\n      return item.forEach(function (subItem, index) {\n        return getCoords(subItem, i, index, depth - 1);\n      });\n    }\n    var x = xRatio * (i + offset / 6);\n    if (item) {\n      last = [average(item), lastValue(item)];\n    }\n    var y = height + strokeWidth / 2 - ((item ? last[0] : last[1]) - min) / yRatio;\n    return coords.push([x, y]);\n  };\n  for (var i = 0; i < history.length; i += 1) {\n    getCoords(history[i], i, 0, detail);\n  }\n  if (coords.length === 1) {\n    coords[1] = [width, coords[0][1]];\n  }\n  coords.push([width, coords[coords.length - 1][1]]);\n  return coords;\n};\nexport var coordinates = function coordinates(history, hours, width, detail, limits) {\n  history.forEach(function (item) {\n    item.state = Number(item.state);\n  });\n  history = history.filter(function (item) {\n    return !Number.isNaN(item.state);\n  });\n  var min = (limits === null || limits === void 0 ? void 0 : limits.min) !== undefined ? limits.min : Math.min.apply(Math, _toConsumableArray(history.map(function (item) {\n    return item.state;\n  })));\n  var max = (limits === null || limits === void 0 ? void 0 : limits.max) !== undefined ? limits.max : Math.max.apply(Math, _toConsumableArray(history.map(function (item) {\n    return item.state;\n  })));\n  var now = new Date().getTime();\n  var reduce = function reduce(res, item, point) {\n    var age = now - new Date(item.last_changed).getTime();\n    var key = Math.abs(age / (1000 * 3600) - hours);\n    if (point) {\n      key = (key - Math.floor(key)) * 60;\n      key = Number((Math.round(key / 10) * 10).toString()[0]);\n    } else {\n      key = Math.floor(key);\n    }\n    if (!res[key]) {\n      res[key] = [];\n    }\n    res[key].push(item);\n    return res;\n  };\n  history = history.reduce(function (res, item) {\n    return reduce(res, item, false);\n  }, []);\n  if (detail > 1) {\n    history = history.map(function (entry) {\n      return entry.reduce(function (res, item) {\n        return reduce(res, item, true);\n      }, []);\n    });\n  }\n  if (!history.length) {\n    return undefined;\n  }\n  return calcPoints(history, hours, width, detail, min, max);\n};\nexport var coordinatesMinimalResponseCompressedState = function coordinatesMinimalResponseCompressedState(history, hours, width, detail, limits) {\n  if (!history) {\n    return undefined;\n  }\n  var numericHistory = history.map(function (item) {\n    return {\n      state: Number(item.s),\n      // With minimal response and compressed state, we don't have last_changed,\n      // so we use last_updated since its always the same as last_changed since\n      // we already filtered out states that are the same.\n      last_changed: item.lu * 1000\n    };\n  });\n  return coordinates(numericHistory, hours, width, detail, limits);\n};","map":{"version":3,"names":["strokeWidth","average","items","reduce","sum","entry","parseFloat","state","length","lastValue","calcPoints","history","hours","width","detail","min","max","coords","height","yRatio","xRatio","isFinite","first","filter","Boolean","last","getCoords","item","i","offset","arguments","undefined","depth","forEach","subItem","index","x","y","push","coordinates","limits","Number","isNaN","Math","apply","_toConsumableArray","map","now","Date","getTime","res","point","age","last_changed","key","abs","floor","round","toString","coordinatesMinimalResponseCompressedState","numericHistory","s","lu"],"sources":["/workspaces/frontend/src/panels/lovelace/common/graph/coordinates.ts"],"sourcesContent":["import { strokeWidth } from \"../../../../data/graph\";\nimport { EntityHistoryState } from \"../../../../data/history\";\n\nconst average = (items: any[]): number =>\n  items.reduce((sum, entry) => sum + parseFloat(entry.state), 0) / items.length;\n\nconst lastValue = (items: any[]): number =>\n  parseFloat(items[items.length - 1].state) || 0;\n\nconst calcPoints = (\n  history: any,\n  hours: number,\n  width: number,\n  detail: number,\n  min: number,\n  max: number\n): number[][] => {\n  const coords = [] as number[][];\n  const height = 80;\n  let yRatio = (max - min) / height;\n  yRatio = yRatio !== 0 ? yRatio : height;\n  let xRatio = width / (hours - (detail === 1 ? 1 : 0));\n  xRatio = isFinite(xRatio) ? xRatio : width;\n\n  const first = history.filter(Boolean)[0];\n  let last = [average(first), lastValue(first)];\n\n  const getCoords = (item: any[], i: number, offset = 0, depth = 1) => {\n    if (depth > 1 && item) {\n      return item.forEach((subItem, index) =>\n        getCoords(subItem, i, index, depth - 1)\n      );\n    }\n\n    const x = xRatio * (i + offset / 6);\n\n    if (item) {\n      last = [average(item), lastValue(item)];\n    }\n    const y =\n      height + strokeWidth / 2 - ((item ? last[0] : last[1]) - min) / yRatio;\n    return coords.push([x, y]);\n  };\n\n  for (let i = 0; i < history.length; i += 1) {\n    getCoords(history[i], i, 0, detail);\n  }\n\n  if (coords.length === 1) {\n    coords[1] = [width, coords[0][1]];\n  }\n\n  coords.push([width, coords[coords.length - 1][1]]);\n  return coords;\n};\n\nexport const coordinates = (\n  history: any,\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number }\n): number[][] | undefined => {\n  history.forEach((item) => {\n    item.state = Number(item.state);\n  });\n  history = history.filter((item) => !Number.isNaN(item.state));\n\n  const min =\n    limits?.min !== undefined\n      ? limits.min\n      : Math.min(...history.map((item) => item.state));\n  const max =\n    limits?.max !== undefined\n      ? limits.max\n      : Math.max(...history.map((item) => item.state));\n  const now = new Date().getTime();\n\n  const reduce = (res, item, point) => {\n    const age = now - new Date(item.last_changed).getTime();\n\n    let key = Math.abs(age / (1000 * 3600) - hours);\n    if (point) {\n      key = (key - Math.floor(key)) * 60;\n      key = Number((Math.round(key / 10) * 10).toString()[0]);\n    } else {\n      key = Math.floor(key);\n    }\n    if (!res[key]) {\n      res[key] = [];\n    }\n    res[key].push(item);\n    return res;\n  };\n\n  history = history.reduce((res, item) => reduce(res, item, false), []);\n  if (detail > 1) {\n    history = history.map((entry) =>\n      entry.reduce((res, item) => reduce(res, item, true), [])\n    );\n  }\n\n  if (!history.length) {\n    return undefined;\n  }\n\n  return calcPoints(history, hours, width, detail, min, max);\n};\n\ninterface NumericEntityHistoryState {\n  state: number;\n  last_changed: number;\n}\n\nexport const coordinatesMinimalResponseCompressedState = (\n  history: EntityHistoryState[],\n  hours: number,\n  width: number,\n  detail: number,\n  limits?: { min?: number; max?: number }\n): number[][] | undefined => {\n  if (!history) {\n    return undefined;\n  }\n  const numericHistory: NumericEntityHistoryState[] = history.map((item) => ({\n    state: Number(item.s),\n    // With minimal response and compressed state, we don't have last_changed,\n    // so we use last_updated since its always the same as last_changed since\n    // we already filtered out states that are the same.\n    last_changed: item.lu * 1000,\n  }));\n  return coordinates(numericHistory, hours, width, detail, limits);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}