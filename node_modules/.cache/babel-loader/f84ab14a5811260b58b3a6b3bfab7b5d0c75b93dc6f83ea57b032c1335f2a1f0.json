{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _callSuper from \"@babel/runtime/helpers/callSuper\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.object.assign.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.parse-int.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n/**\n * @license\n * Copyright (c) 2017 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\nvar PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom'\n};\nvar PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right'\n};\nvar targetResizeObserver = new ResizeObserver(function (entries) {\n  setTimeout(function () {\n    entries.forEach(function (entry) {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport var PositionMixin = function PositionMixin(superClass) {\n  return /*#__PURE__*/function (_superClass) {\n    _inherits(PositionMixin, _superClass);\n    function PositionMixin() {\n      var _this;\n      _classCallCheck(this, PositionMixin);\n      _this = _callSuper(this, PositionMixin);\n      _this.__onScroll = _this.__onScroll.bind(_assertThisInitialized(_this));\n      _this._updatePosition = _this._updatePosition.bind(_assertThisInitialized(_this));\n      return _this;\n    }\n\n    /** @protected */\n    _createClass(PositionMixin, [{\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(PositionMixin.prototype), \"connectedCallback\", this).call(this);\n        if (this.opened) {\n          this.__addUpdatePositionEventListeners();\n        }\n      }\n\n      /** @protected */\n    }, {\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(PositionMixin.prototype), \"disconnectedCallback\", this).call(this);\n        this.__removeUpdatePositionEventListeners();\n      }\n\n      /** @private */\n    }, {\n      key: \"__addUpdatePositionEventListeners\",\n      value: function __addUpdatePositionEventListeners() {\n        var _this2 = this;\n        window.addEventListener('resize', this._updatePosition);\n        this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n        this.__positionTargetAncestorRootNodes.forEach(function (node) {\n          node.addEventListener('scroll', _this2.__onScroll, true);\n        });\n      }\n\n      /** @private */\n    }, {\n      key: \"__removeUpdatePositionEventListeners\",\n      value: function __removeUpdatePositionEventListeners() {\n        var _this3 = this;\n        window.removeEventListener('resize', this._updatePosition);\n        if (this.__positionTargetAncestorRootNodes) {\n          this.__positionTargetAncestorRootNodes.forEach(function (node) {\n            node.removeEventListener('scroll', _this3.__onScroll, true);\n          });\n          this.__positionTargetAncestorRootNodes = null;\n        }\n      }\n\n      /** @private */\n    }, {\n      key: \"__overlayOpenedChanged\",\n      value: function __overlayOpenedChanged(opened, positionTarget) {\n        var _this4 = this;\n        this.__removeUpdatePositionEventListeners();\n        if (positionTarget) {\n          positionTarget.__overlay = null;\n          targetResizeObserver.unobserve(positionTarget);\n          if (opened) {\n            this.__addUpdatePositionEventListeners();\n            positionTarget.__overlay = this;\n            targetResizeObserver.observe(positionTarget);\n          }\n        }\n        if (opened) {\n          var computedStyle = getComputedStyle(this);\n          if (!this.__margins) {\n            this.__margins = {};\n            ['top', 'bottom', 'left', 'right'].forEach(function (propName) {\n              _this4.__margins[propName] = parseInt(computedStyle[propName], 10);\n            });\n          }\n          this.setAttribute('dir', computedStyle.direction);\n          this._updatePosition();\n          // Schedule another position update (to cover virtual keyboard opening for example)\n          requestAnimationFrame(function () {\n            return _this4._updatePosition();\n          });\n        }\n      }\n    }, {\n      key: \"__positionSettingsChanged\",\n      value: function __positionSettingsChanged() {\n        this._updatePosition();\n      }\n\n      /** @private */\n    }, {\n      key: \"__onScroll\",\n      value: function __onScroll(e) {\n        // If the scroll event occurred inside the overlay, ignore it.\n        if (!this.contains(e.target)) {\n          this._updatePosition();\n        }\n      }\n    }, {\n      key: \"_updatePosition\",\n      value: function _updatePosition() {\n        if (!this.positionTarget || !this.opened) {\n          return;\n        }\n        var targetRect = this.positionTarget.getBoundingClientRect();\n\n        // Detect the desired alignment and update the layout accordingly\n        var shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n        this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n        var isRTL = this.__isRTL;\n        var shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\n        var flexStart = !isRTL && shouldAlignStartHorizontally || isRTL && !shouldAlignStartHorizontally;\n        this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n        // Get the overlay rect after possible overlay alignment changes\n        var overlayRect = this.getBoundingClientRect();\n\n        // Obtain vertical positioning properties\n        var verticalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noVerticalOverlap, PROP_NAMES_VERTICAL, this, shouldAlignStartVertically);\n\n        // Obtain horizontal positioning properties\n        var horizontalProps = this.__calculatePositionInOneDimension(targetRect, overlayRect, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL, this, shouldAlignStartHorizontally);\n\n        // Apply the positioning properties to the overlay\n        Object.assign(this.style, verticalProps, horizontalProps);\n        this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n        this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n        this.toggleAttribute('end-aligned', !flexStart);\n        this.toggleAttribute('start-aligned', flexStart);\n      }\n    }, {\n      key: \"__shouldAlignStartHorizontally\",\n      value: function __shouldAlignStartHorizontally(targetRect, rtl) {\n        // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n        // smaller than its current space before the fit-calculations.\n        var contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n        this.__oldContentWidth = this.$.overlay.offsetWidth;\n        var viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n        var defaultAlignLeft = !rtl && this.horizontalAlign === 'start' || rtl && this.horizontalAlign === 'end';\n        return this.__shouldAlignStart(targetRect, contentWidth, viewportWidth, this.__margins, defaultAlignLeft, this.noHorizontalOverlap, PROP_NAMES_HORIZONTAL);\n      }\n    }, {\n      key: \"__shouldAlignStartVertically\",\n      value: function __shouldAlignStartVertically(targetRect) {\n        // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n        // smaller than its current space before the fit-calculations.\n        var contentHeight = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n        this.__oldContentHeight = this.$.overlay.offsetHeight;\n        var viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n        var defaultAlignTop = this.verticalAlign === 'top';\n        return this.__shouldAlignStart(targetRect, contentHeight, viewportHeight, this.__margins, defaultAlignTop, this.noVerticalOverlap, PROP_NAMES_VERTICAL);\n      }\n\n      // eslint-disable-next-line max-params\n    }, {\n      key: \"__shouldAlignStart\",\n      value: function __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n        var spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n        var spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n        var spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n        var spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n        var shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n        return defaultAlignStart === shouldGoToDefaultSide;\n      }\n\n      /**\n       * Returns an adjusted value after resizing the browser window,\n       * to avoid wrong calculations when e.g. previously set `bottom`\n       * CSS property value is larger than the updated viewport height.\n       * See https://github.com/vaadin/web-components/issues/4604\n       */\n    }, {\n      key: \"__adjustBottomProperty\",\n      value: function __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n        var adjustedProp;\n        if (cssPropNameToSet === propNames.end) {\n          // Adjust horizontally\n          if (propNames.end === PROP_NAMES_VERTICAL.end) {\n            var viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n            if (currentValue > viewportHeight && this.__oldViewportHeight) {\n              var heightDiff = this.__oldViewportHeight - viewportHeight;\n              adjustedProp = currentValue - heightDiff;\n            }\n            this.__oldViewportHeight = viewportHeight;\n          }\n\n          // Adjust vertically\n          if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n            var viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n            if (currentValue > viewportWidth && this.__oldViewportWidth) {\n              var widthDiff = this.__oldViewportWidth - viewportWidth;\n              adjustedProp = currentValue - widthDiff;\n            }\n            this.__oldViewportWidth = viewportWidth;\n          }\n        }\n        return adjustedProp;\n      }\n\n      /**\n       * Returns an object with CSS position properties to set,\n       * e.g. { top: \"100px\" }\n       */\n      // eslint-disable-next-line max-params\n    }, {\n      key: \"__calculatePositionInOneDimension\",\n      value: function __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n        var cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n        var cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n        var currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n        var adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n        var diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n        var valueToSet = adjustedValue ? \"\".concat(adjustedValue, \"px\") : \"\".concat(currentValue + diff * (shouldAlignStart ? -1 : 1), \"px\");\n        return _defineProperty(_defineProperty({}, cssPropNameToSet, valueToSet), cssPropNameToClear, '');\n      }\n    }], [{\n      key: \"properties\",\n      get: function get() {\n        return {\n          /**\n           * The element next to which this overlay should be aligned.\n           * The position of the overlay relative to the positionTarget can be adjusted\n           * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n           * and `noVerticalOverlap`.\n           */\n          positionTarget: {\n            type: Object,\n            value: null,\n            sync: true\n          },\n          /**\n           * When `positionTarget` is set, this property defines whether to align the overlay's\n           * left or right side to the target element by default.\n           * Possible values are `start` and `end`.\n           * RTL is taken into account when interpreting the value.\n           * The overlay is automatically flipped to the opposite side when it doesn't fit into\n           * the default side defined by this property.\n           *\n           * @attr {start|end} horizontal-align\n           */\n          horizontalAlign: {\n            type: String,\n            value: 'start',\n            sync: true\n          },\n          /**\n           * When `positionTarget` is set, this property defines whether to align the overlay's\n           * top or bottom side to the target element by default.\n           * Possible values are `top` and `bottom`.\n           * The overlay is automatically flipped to the opposite side when it doesn't fit into\n           * the default side defined by this property.\n           *\n           * @attr {top|bottom} vertical-align\n           */\n          verticalAlign: {\n            type: String,\n            value: 'top',\n            sync: true\n          },\n          /**\n           * When `positionTarget` is set, this property defines whether the overlay should overlap\n           * the target element in the x-axis, or be positioned right next to it.\n           *\n           * @attr {boolean} no-horizontal-overlap\n           */\n          noHorizontalOverlap: {\n            type: Boolean,\n            value: false,\n            sync: true\n          },\n          /**\n           * When `positionTarget` is set, this property defines whether the overlay should overlap\n           * the target element in the y-axis, or be positioned right above/below it.\n           *\n           * @attr {boolean} no-vertical-overlap\n           */\n          noVerticalOverlap: {\n            type: Boolean,\n            value: false,\n            sync: true\n          },\n          /**\n           * If the overlay content has no intrinsic height, this property can be used to set\n           * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n           * the property effectively disables the content measurement in favor of using this\n           * fixed value for determining the open direction.\n           *\n           * @attr {number} required-vertical-space\n           */\n          requiredVerticalSpace: {\n            type: Number,\n            value: 0,\n            sync: true\n          }\n        };\n      }\n    }, {\n      key: \"observers\",\n      get: function get() {\n        return ['__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)', '__overlayOpenedChanged(opened, positionTarget)'];\n      }\n    }]);\n    return PositionMixin;\n  }(superClass);\n};","map":{"version":3,"names":["getAncestorRootNodes","PROP_NAMES_VERTICAL","start","end","PROP_NAMES_HORIZONTAL","targetResizeObserver","ResizeObserver","entries","setTimeout","forEach","entry","target","__overlay","_updatePosition","PositionMixin","superClass","_superClass","_inherits","_this","_classCallCheck","_callSuper","__onScroll","bind","_assertThisInitialized","_createClass","key","value","connectedCallback","_get","_getPrototypeOf","prototype","call","opened","__addUpdatePositionEventListeners","disconnectedCallback","__removeUpdatePositionEventListeners","_this2","window","addEventListener","__positionTargetAncestorRootNodes","positionTarget","node","_this3","removeEventListener","__overlayOpenedChanged","_this4","unobserve","observe","computedStyle","getComputedStyle","__margins","propName","parseInt","setAttribute","direction","requestAnimationFrame","__positionSettingsChanged","e","contains","targetRect","getBoundingClientRect","shouldAlignStartVertically","__shouldAlignStartVertically","style","justifyContent","isRTL","__isRTL","shouldAlignStartHorizontally","__shouldAlignStartHorizontally","flexStart","alignItems","overlayRect","verticalProps","__calculatePositionInOneDimension","noVerticalOverlap","horizontalProps","noHorizontalOverlap","Object","assign","toggleAttribute","rtl","contentWidth","Math","max","__oldContentWidth","$","overlay","offsetWidth","viewportWidth","min","innerWidth","document","documentElement","clientWidth","defaultAlignLeft","horizontalAlign","__shouldAlignStart","contentHeight","requiredVerticalSpace","__oldContentHeight","offsetHeight","viewportHeight","innerHeight","clientHeight","defaultAlignTop","verticalAlign","contentSize","viewportSize","margins","defaultAlignStart","noOverlap","propNames","spaceForStartAlignment","spaceForEndAlignment","spaceForDefaultAlignment","spaceForOtherAlignment","shouldGoToDefaultSide","__adjustBottomProperty","cssPropNameToSet","currentValue","adjustedProp","__oldViewportHeight","heightDiff","__oldViewportWidth","widthDiff","shouldAlignStart","cssPropNameToClear","parseFloat","adjustedValue","diff","valueToSet","concat","_defineProperty","get","type","sync","String","Boolean","Number"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@vaadin/overlay/src/vaadin-overlay-position-mixin.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 - 2023 Vaadin Ltd.\n * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n */\nimport { getAncestorRootNodes } from '@vaadin/component-base/src/dom-utils.js';\n\nconst PROP_NAMES_VERTICAL = {\n  start: 'top',\n  end: 'bottom',\n};\n\nconst PROP_NAMES_HORIZONTAL = {\n  start: 'left',\n  end: 'right',\n};\n\nconst targetResizeObserver = new ResizeObserver((entries) => {\n  setTimeout(() => {\n    entries.forEach((entry) => {\n      if (entry.target.__overlay) {\n        entry.target.__overlay._updatePosition();\n      }\n    });\n  });\n});\n\n/**\n * @polymerMixin\n */\nexport const PositionMixin = (superClass) =>\n  class PositionMixin extends superClass {\n    static get properties() {\n      return {\n        /**\n         * The element next to which this overlay should be aligned.\n         * The position of the overlay relative to the positionTarget can be adjusted\n         * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`\n         * and `noVerticalOverlap`.\n         */\n        positionTarget: {\n          type: Object,\n          value: null,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * left or right side to the target element by default.\n         * Possible values are `start` and `end`.\n         * RTL is taken into account when interpreting the value.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {start|end} horizontal-align\n         */\n        horizontalAlign: {\n          type: String,\n          value: 'start',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether to align the overlay's\n         * top or bottom side to the target element by default.\n         * Possible values are `top` and `bottom`.\n         * The overlay is automatically flipped to the opposite side when it doesn't fit into\n         * the default side defined by this property.\n         *\n         * @attr {top|bottom} vertical-align\n         */\n        verticalAlign: {\n          type: String,\n          value: 'top',\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the x-axis, or be positioned right next to it.\n         *\n         * @attr {boolean} no-horizontal-overlap\n         */\n        noHorizontalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * When `positionTarget` is set, this property defines whether the overlay should overlap\n         * the target element in the y-axis, or be positioned right above/below it.\n         *\n         * @attr {boolean} no-vertical-overlap\n         */\n        noVerticalOverlap: {\n          type: Boolean,\n          value: false,\n          sync: true,\n        },\n\n        /**\n         * If the overlay content has no intrinsic height, this property can be used to set\n         * the minimum vertical space (in pixels) required by the overlay. Setting a value to\n         * the property effectively disables the content measurement in favor of using this\n         * fixed value for determining the open direction.\n         *\n         * @attr {number} required-vertical-space\n         */\n        requiredVerticalSpace: {\n          type: Number,\n          value: 0,\n          sync: true,\n        },\n      };\n    }\n\n    static get observers() {\n      return [\n        '__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)',\n        '__overlayOpenedChanged(opened, positionTarget)',\n      ];\n    }\n\n    constructor() {\n      super();\n\n      this.__onScroll = this.__onScroll.bind(this);\n      this._updatePosition = this._updatePosition.bind(this);\n    }\n\n    /** @protected */\n    connectedCallback() {\n      super.connectedCallback();\n\n      if (this.opened) {\n        this.__addUpdatePositionEventListeners();\n      }\n    }\n\n    /** @protected */\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this.__removeUpdatePositionEventListeners();\n    }\n\n    /** @private */\n    __addUpdatePositionEventListeners() {\n      window.addEventListener('resize', this._updatePosition);\n\n      this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);\n      this.__positionTargetAncestorRootNodes.forEach((node) => {\n        node.addEventListener('scroll', this.__onScroll, true);\n      });\n    }\n\n    /** @private */\n    __removeUpdatePositionEventListeners() {\n      window.removeEventListener('resize', this._updatePosition);\n\n      if (this.__positionTargetAncestorRootNodes) {\n        this.__positionTargetAncestorRootNodes.forEach((node) => {\n          node.removeEventListener('scroll', this.__onScroll, true);\n        });\n        this.__positionTargetAncestorRootNodes = null;\n      }\n    }\n\n    /** @private */\n    __overlayOpenedChanged(opened, positionTarget) {\n      this.__removeUpdatePositionEventListeners();\n\n      if (positionTarget) {\n        positionTarget.__overlay = null;\n        targetResizeObserver.unobserve(positionTarget);\n\n        if (opened) {\n          this.__addUpdatePositionEventListeners();\n          positionTarget.__overlay = this;\n          targetResizeObserver.observe(positionTarget);\n        }\n      }\n\n      if (opened) {\n        const computedStyle = getComputedStyle(this);\n        if (!this.__margins) {\n          this.__margins = {};\n          ['top', 'bottom', 'left', 'right'].forEach((propName) => {\n            this.__margins[propName] = parseInt(computedStyle[propName], 10);\n          });\n        }\n        this.setAttribute('dir', computedStyle.direction);\n\n        this._updatePosition();\n        // Schedule another position update (to cover virtual keyboard opening for example)\n        requestAnimationFrame(() => this._updatePosition());\n      }\n    }\n\n    __positionSettingsChanged() {\n      this._updatePosition();\n    }\n\n    /** @private */\n    __onScroll(e) {\n      // If the scroll event occurred inside the overlay, ignore it.\n      if (!this.contains(e.target)) {\n        this._updatePosition();\n      }\n    }\n\n    _updatePosition() {\n      if (!this.positionTarget || !this.opened) {\n        return;\n      }\n\n      const targetRect = this.positionTarget.getBoundingClientRect();\n\n      // Detect the desired alignment and update the layout accordingly\n      const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);\n      this.style.justifyContent = shouldAlignStartVertically ? 'flex-start' : 'flex-end';\n\n      const isRTL = this.__isRTL;\n      const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);\n      const flexStart = (!isRTL && shouldAlignStartHorizontally) || (isRTL && !shouldAlignStartHorizontally);\n      this.style.alignItems = flexStart ? 'flex-start' : 'flex-end';\n\n      // Get the overlay rect after possible overlay alignment changes\n      const overlayRect = this.getBoundingClientRect();\n\n      // Obtain vertical positioning properties\n      const verticalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n        this,\n        shouldAlignStartVertically,\n      );\n\n      // Obtain horizontal positioning properties\n      const horizontalProps = this.__calculatePositionInOneDimension(\n        targetRect,\n        overlayRect,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n        this,\n        shouldAlignStartHorizontally,\n      );\n\n      // Apply the positioning properties to the overlay\n      Object.assign(this.style, verticalProps, horizontalProps);\n\n      this.toggleAttribute('bottom-aligned', !shouldAlignStartVertically);\n      this.toggleAttribute('top-aligned', shouldAlignStartVertically);\n\n      this.toggleAttribute('end-aligned', !flexStart);\n      this.toggleAttribute('start-aligned', flexStart);\n    }\n\n    __shouldAlignStartHorizontally(targetRect, rtl) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);\n      this.__oldContentWidth = this.$.overlay.offsetWidth;\n\n      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentWidth,\n        viewportWidth,\n        this.__margins,\n        defaultAlignLeft,\n        this.noHorizontalOverlap,\n        PROP_NAMES_HORIZONTAL,\n      );\n    }\n\n    __shouldAlignStartVertically(targetRect) {\n      // Using previous size to fix a case where window resize may cause the overlay to be squeezed\n      // smaller than its current space before the fit-calculations.\n      const contentHeight =\n        this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);\n      this.__oldContentHeight = this.$.overlay.offsetHeight;\n\n      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n      const defaultAlignTop = this.verticalAlign === 'top';\n\n      return this.__shouldAlignStart(\n        targetRect,\n        contentHeight,\n        viewportHeight,\n        this.__margins,\n        defaultAlignTop,\n        this.noVerticalOverlap,\n        PROP_NAMES_VERTICAL,\n      );\n    }\n\n    // eslint-disable-next-line max-params\n    __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {\n      const spaceForStartAlignment =\n        viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];\n      const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];\n\n      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;\n      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;\n\n      const shouldGoToDefaultSide =\n        spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;\n\n      return defaultAlignStart === shouldGoToDefaultSide;\n    }\n\n    /**\n     * Returns an adjusted value after resizing the browser window,\n     * to avoid wrong calculations when e.g. previously set `bottom`\n     * CSS property value is larger than the updated viewport height.\n     * See https://github.com/vaadin/web-components/issues/4604\n     */\n    __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {\n      let adjustedProp;\n\n      if (cssPropNameToSet === propNames.end) {\n        // Adjust horizontally\n        if (propNames.end === PROP_NAMES_VERTICAL.end) {\n          const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);\n\n          if (currentValue > viewportHeight && this.__oldViewportHeight) {\n            const heightDiff = this.__oldViewportHeight - viewportHeight;\n            adjustedProp = currentValue - heightDiff;\n          }\n\n          this.__oldViewportHeight = viewportHeight;\n        }\n\n        // Adjust vertically\n        if (propNames.end === PROP_NAMES_HORIZONTAL.end) {\n          const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);\n\n          if (currentValue > viewportWidth && this.__oldViewportWidth) {\n            const widthDiff = this.__oldViewportWidth - viewportWidth;\n            adjustedProp = currentValue - widthDiff;\n          }\n\n          this.__oldViewportWidth = viewportWidth;\n        }\n      }\n\n      return adjustedProp;\n    }\n\n    /**\n     * Returns an object with CSS position properties to set,\n     * e.g. { top: \"100px\" }\n     */\n    // eslint-disable-next-line max-params\n    __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay, shouldAlignStart) {\n      const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;\n      const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;\n\n      const currentValue = parseFloat(overlay.style[cssPropNameToSet] || getComputedStyle(overlay)[cssPropNameToSet]);\n      const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);\n\n      const diff =\n        overlayRect[shouldAlignStart ? propNames.start : propNames.end] -\n        targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];\n\n      const valueToSet = adjustedValue\n        ? `${adjustedValue}px`\n        : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;\n\n      return {\n        [cssPropNameToSet]: valueToSet,\n        [cssPropNameToClear]: '',\n      };\n    }\n  };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}