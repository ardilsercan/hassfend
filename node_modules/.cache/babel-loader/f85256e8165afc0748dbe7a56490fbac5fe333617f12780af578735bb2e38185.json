{"ast":null,"code":"/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\nimport { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';\nvar p = Element.prototype;\nvar matches = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\nclass IronFocusablesHelperClass {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the chidren,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  getTabbableNodes(node) {\n    var result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    var needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return this._sortByTabIndex(result);\n    }\n    return result;\n  }\n\n  /**\n   * Returns if a element is focusable.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isFocusable(element) {\n    // From http://stackoverflow.com/a/1600194/4228703:\n    // There isn't a definite list, it's up to the browser. The only\n    // standard we have is DOM Level 2 HTML\n    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the\n    // only elements that have a focus() method are HTMLInputElement,\n    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This\n    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these\n    // tests with tabbables in different browsers\n    // http://allyjs.io/data-tables/focusable.html\n\n    // Elements that cannot be focused if they have [disabled] attribute.\n    if (matches.call(element, 'input, select, textarea, button, object')) {\n      return matches.call(element, ':not([disabled])');\n    }\n    // Elements that can be focused even if they have [disabled] attribute.\n    return matches.call(element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');\n  }\n\n  /**\n   * Returns if a element is tabbable. To be tabbable, a element must be\n   * focusable, visible, and with a tabindex !== -1.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isTabbable(element) {\n    return this.isFocusable(element) && matches.call(element, ':not([tabindex=\"-1\"])') && this._isVisible(element);\n  }\n\n  /**\n   * Returns the normalized element tabindex. If not focusable, returns -1.\n   * It checks for the attribute \"tabindex\" instead of the element property\n   * `tabIndex` since browsers assign different values to it.\n   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n   * @param {!HTMLElement} element\n   * @return {!number}\n   * @private\n   */\n  _normalizedTabIndex(element) {\n    if (this.isFocusable(element)) {\n      var tabIndex = element.getAttribute('tabindex') || 0;\n      return Number(tabIndex);\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result`\n   * if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  _collectTabbableNodes(node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n    var element = /** @type {!HTMLElement} */node;\n    if (!this._isVisible(element)) {\n      return false;\n    }\n    var tabIndex = this._normalizedTabIndex(element);\n    var needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n    // In ShadowDOM v1, tab order is affected by the order of distrubution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distrubution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.\n    var children;\n    if (element.localName === 'content' || element.localName === 'slot') {\n      children = dom(element).getDistributedNodes();\n    } else {\n      // Use shadow root if possible, will check for distributed nodes.\n      children = dom(element.root || element).children;\n    }\n    for (var i = 0; i < children.length; i++) {\n      // Ensure method is always invoked to collect tabbable children.\n      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n    }\n    return needsSort;\n  }\n\n  /**\n   * Returns false if the element has `visibility: hidden` or `display: none`\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   * @private\n   */\n  _isVisible(element) {\n    // Check inline style first to save a re-flow. If looks good, check also\n    // computed style.\n    var style = element.style;\n    if (style.visibility !== 'hidden' && style.display !== 'none') {\n      style = window.getComputedStyle(element);\n      return style.visibility !== 'hidden' && style.display !== 'none';\n    }\n    return false;\n  }\n\n  /**\n   * Sorts an array of tabbable elements by tabindex. Returns a new array.\n   * @param {!Array<!HTMLElement>} tabbables\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _sortByTabIndex(tabbables) {\n    // Implement a merge sort as Array.prototype.sort does a non-stable sort\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    var len = tabbables.length;\n    if (len < 2) {\n      return tabbables;\n    }\n    var pivot = Math.ceil(len / 2);\n    var left = this._sortByTabIndex(tabbables.slice(0, pivot));\n    var right = this._sortByTabIndex(tabbables.slice(pivot));\n    return this._mergeSortByTabIndex(left, right);\n  }\n\n  /**\n   * Merge sort iterator, merges the two arrays into one, sorted by tab index.\n   * @param {!Array<!HTMLElement>} left\n   * @param {!Array<!HTMLElement>} right\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _mergeSortByTabIndex(left, right) {\n    var result = [];\n    while (left.length > 0 && right.length > 0) {\n      if (this._hasLowerTabOrder(left[0], right[0])) {\n        result.push(right.shift());\n      } else {\n        result.push(left.shift());\n      }\n    }\n    return result.concat(left, right);\n  }\n\n  /**\n   * Returns if element `a` has lower tab order compared to element `b`\n   * (both elements are assumed to be focusable and tabbable).\n   * Elements with tabindex = 0 have lower tab order compared to elements\n   * with tabindex > 0.\n   * If both have same tabindex, it returns false.\n   * @param {!HTMLElement} a\n   * @param {!HTMLElement} b\n   * @return {boolean}\n   * @private\n   */\n  _hasLowerTabOrder(a, b) {\n    // Normalize tabIndexes\n    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n    var ati = Math.max(a.tabIndex, 0);\n    var bti = Math.max(b.tabIndex, 0);\n    return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n  }\n}\nexport const IronFocusablesHelper = new IronFocusablesHelperClass();","map":{"version":3,"names":["dom","p","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","IronFocusablesHelperClass","getTabbableNodes","node","result","needsSortByTabIndex","_collectTabbableNodes","_sortByTabIndex","isFocusable","element","call","isTabbable","_isVisible","_normalizedTabIndex","tabIndex","getAttribute","Number","nodeType","Node","ELEMENT_NODE","needsSort","push","children","localName","getDistributedNodes","root","i","length","style","visibility","display","window","getComputedStyle","tabbables","len","pivot","Math","ceil","left","slice","right","_mergeSortByTabIndex","_hasLowerTabOrder","shift","concat","a","b","ati","max","bti","IronFocusablesHelper"],"sources":["/Users/sercanardil/Desktop/frontend/node_modules/@polymer/iron-overlay-behavior/iron-focusables-helper.js"],"sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nimport '@polymer/polymer/polymer-legacy.js';\n\nimport {dom} from '@polymer/polymer/lib/legacy/polymer.dom.js';\n\nvar p = Element.prototype;\nvar matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||\n    p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\n\nclass IronFocusablesHelperClass {\n  /**\n   * Returns a sorted array of tabbable nodes, including the root node.\n   * It searches the tabbable nodes in the light and shadow dom of the chidren,\n   * sorting the result by tabindex.\n   * @param {!Node} node\n   * @return {!Array<!HTMLElement>}\n   */\n  getTabbableNodes(node) {\n    var result = [];\n    // If there is at least one element with tabindex > 0, we need to sort\n    // the final array by tabindex.\n    var needsSortByTabIndex = this._collectTabbableNodes(node, result);\n    if (needsSortByTabIndex) {\n      return this._sortByTabIndex(result);\n    }\n    return result;\n  }\n\n  /**\n   * Returns if a element is focusable.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isFocusable(element) {\n    // From http://stackoverflow.com/a/1600194/4228703:\n    // There isn't a definite list, it's up to the browser. The only\n    // standard we have is DOM Level 2 HTML\n    // https://www.w3.org/TR/DOM-Level-2-HTML/html.html, according to which the\n    // only elements that have a focus() method are HTMLInputElement,\n    // HTMLSelectElement, HTMLTextAreaElement and HTMLAnchorElement. This\n    // notably omits HTMLButtonElement and HTMLAreaElement. Referring to these\n    // tests with tabbables in different browsers\n    // http://allyjs.io/data-tables/focusable.html\n\n    // Elements that cannot be focused if they have [disabled] attribute.\n    if (matches.call(element, 'input, select, textarea, button, object')) {\n      return matches.call(element, ':not([disabled])');\n    }\n    // Elements that can be focused even if they have [disabled] attribute.\n    return matches.call(\n        element, 'a[href], area[href], iframe, [tabindex], [contentEditable]');\n  }\n\n  /**\n   * Returns if a element is tabbable. To be tabbable, a element must be\n   * focusable, visible, and with a tabindex !== -1.\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   */\n  isTabbable(element) {\n    return this.isFocusable(element) &&\n        matches.call(element, ':not([tabindex=\"-1\"])') &&\n        this._isVisible(element);\n  }\n\n  /**\n   * Returns the normalized element tabindex. If not focusable, returns -1.\n   * It checks for the attribute \"tabindex\" instead of the element property\n   * `tabIndex` since browsers assign different values to it.\n   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n   * @param {!HTMLElement} element\n   * @return {!number}\n   * @private\n   */\n  _normalizedTabIndex(element) {\n    if (this.isFocusable(element)) {\n      var tabIndex = element.getAttribute('tabindex') || 0;\n      return Number(tabIndex);\n    }\n    return -1;\n  }\n\n  /**\n   * Searches for nodes that are tabbable and adds them to the `result` array.\n   * Returns if the `result` array needs to be sorted by tabindex.\n   * @param {!Node} node The starting point for the search; added to `result`\n   * if tabbable.\n   * @param {!Array<!HTMLElement>} result\n   * @return {boolean}\n   * @private\n   */\n  _collectTabbableNodes(node, result) {\n    // If not an element or not visible, no need to explore children.\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return false;\n    }\n    var element = /** @type {!HTMLElement} */ (node);\n    if (!this._isVisible(element)) {\n      return false;\n    }\n    var tabIndex = this._normalizedTabIndex(element);\n    var needsSort = tabIndex > 0;\n    if (tabIndex >= 0) {\n      result.push(element);\n    }\n    // In ShadowDOM v1, tab order is affected by the order of distrubution.\n    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];\n    // in ShadowDOM v0 tab order is not affected by the distrubution order,\n    // in fact getTabbableNodes(#root) returns [#B, #A].\n    //  <div id=\"root\">\n    //   <!-- shadow -->\n    //     <slot name=\"a\">\n    //     <slot name=\"b\">\n    //   <!-- /shadow -->\n    //   <input id=\"A\" slot=\"a\">\n    //   <input id=\"B\" slot=\"b\" tabindex=\"1\">\n    //  </div>\n    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.\n    var children;\n    if (element.localName === 'content' || element.localName === 'slot') {\n      children = dom(element).getDistributedNodes();\n    } else {\n      // Use shadow root if possible, will check for distributed nodes.\n      children = dom(element.root || element).children;\n    }\n    for (var i = 0; i < children.length; i++) {\n      // Ensure method is always invoked to collect tabbable children.\n      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;\n    }\n    return needsSort;\n  }\n\n  /**\n   * Returns false if the element has `visibility: hidden` or `display: none`\n   * @param {!HTMLElement} element\n   * @return {boolean}\n   * @private\n   */\n  _isVisible(element) {\n    // Check inline style first to save a re-flow. If looks good, check also\n    // computed style.\n    var style = element.style;\n    if (style.visibility !== 'hidden' && style.display !== 'none') {\n      style = window.getComputedStyle(element);\n      return (style.visibility !== 'hidden' && style.display !== 'none');\n    }\n    return false;\n  }\n\n  /**\n   * Sorts an array of tabbable elements by tabindex. Returns a new array.\n   * @param {!Array<!HTMLElement>} tabbables\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _sortByTabIndex(tabbables) {\n    // Implement a merge sort as Array.prototype.sort does a non-stable sort\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n    var len = tabbables.length;\n    if (len < 2) {\n      return tabbables;\n    }\n    var pivot = Math.ceil(len / 2);\n    var left = this._sortByTabIndex(tabbables.slice(0, pivot));\n    var right = this._sortByTabIndex(tabbables.slice(pivot));\n    return this._mergeSortByTabIndex(left, right);\n  }\n\n  /**\n   * Merge sort iterator, merges the two arrays into one, sorted by tab index.\n   * @param {!Array<!HTMLElement>} left\n   * @param {!Array<!HTMLElement>} right\n   * @return {!Array<!HTMLElement>}\n   * @private\n   */\n  _mergeSortByTabIndex(left, right) {\n    var result = [];\n    while ((left.length > 0) && (right.length > 0)) {\n      if (this._hasLowerTabOrder(left[0], right[0])) {\n        result.push(right.shift());\n      } else {\n        result.push(left.shift());\n      }\n    }\n\n    return result.concat(left, right);\n  }\n\n  /**\n   * Returns if element `a` has lower tab order compared to element `b`\n   * (both elements are assumed to be focusable and tabbable).\n   * Elements with tabindex = 0 have lower tab order compared to elements\n   * with tabindex > 0.\n   * If both have same tabindex, it returns false.\n   * @param {!HTMLElement} a\n   * @param {!HTMLElement} b\n   * @return {boolean}\n   * @private\n   */\n  _hasLowerTabOrder(a, b) {\n    // Normalize tabIndexes\n    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n    var ati = Math.max(a.tabIndex, 0);\n    var bti = Math.max(b.tabIndex, 0);\n    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;\n  }\n}\n\nexport const IronFocusablesHelper = new IronFocusablesHelperClass();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}