{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { activateFirstItem, activateLastItem, activateNextItem, activatePreviousItem, getActiveItem, getFirstActivatableItem } from './list-navigation-helpers.js';\n// TODO: move this file to List and make List use this\n/**\n * Default keys that trigger navigation.\n */\n// tslint:disable:enforce-name-casing Following Enum style\nexport const NavigableKeys = {\n  ArrowDown: 'ArrowDown',\n  ArrowLeft: 'ArrowLeft',\n  ArrowUp: 'ArrowUp',\n  ArrowRight: 'ArrowRight',\n  Home: 'Home',\n  End: 'End'\n};\n/**\n * A controller that handles list keyboard navigation and item management.\n */\nexport class ListController {\n  constructor(config) {\n    /**\n     * Handles keyboard navigation. Should be bound to the node that will act as\n     * the List.\n     */\n    this.handleKeydown = event => {\n      const key = event.key;\n      if (event.defaultPrevented || !this.isNavigableKey(key)) {\n        return;\n      }\n      // do not use this.items directly in upcoming calculations so we don't\n      // re-query the DOM unnecessarily\n      const items = this.items;\n      if (!items.length) {\n        return;\n      }\n      const activeItemRecord = getActiveItem(items, this.isActivatable);\n      if (activeItemRecord) {\n        activeItemRecord.item.tabIndex = -1;\n      }\n      event.preventDefault();\n      const isRtl = this.isRtl();\n      const inlinePrevious = isRtl ? NavigableKeys.ArrowRight : NavigableKeys.ArrowLeft;\n      const inlineNext = isRtl ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;\n      switch (key) {\n        // Activate the next item\n        case NavigableKeys.ArrowDown:\n        case inlineNext:\n          activateNextItem(items, activeItemRecord, this.isActivatable);\n          break;\n        // Activate the previous item\n        case NavigableKeys.ArrowUp:\n        case inlinePrevious:\n          activatePreviousItem(items, activeItemRecord, this.isActivatable);\n          break;\n        // Activate the first item\n        case NavigableKeys.Home:\n          activateFirstItem(items, this.isActivatable);\n          break;\n        // Activate the last item\n        case NavigableKeys.End:\n          activateLastItem(items, this.isActivatable);\n          break;\n        default:\n          break;\n      }\n    };\n    /**\n     * Listener to be bound to the `deactivate-items` item event.\n     */\n    this.onDeactivateItems = () => {\n      const items = this.items;\n      for (const item of items) {\n        this.deactivateItem(item);\n      }\n    };\n    /**\n     * Listener to be bound to the `request-activation` item event..\n     */\n    this.onRequestActivation = event => {\n      this.onDeactivateItems();\n      const target = event.target;\n      this.activateItem(target);\n      target.focus();\n    };\n    /**\n     * Listener to be bound to the `slotchange` event for the slot that renders\n     * the items.\n     */\n    this.onSlotchange = () => {\n      const items = this.items;\n      // Whether we have encountered an item that has been activated\n      let encounteredActivated = false;\n      for (const item of items) {\n        const isActivated = !item.disabled && item.tabIndex > -1;\n        if (isActivated && !encounteredActivated) {\n          encounteredActivated = true;\n          item.tabIndex = 0;\n          continue;\n        }\n        // Deactivate the rest including disabled\n        item.tabIndex = -1;\n      }\n      if (encounteredActivated) {\n        return;\n      }\n      const firstActivatableItem = getFirstActivatableItem(items, this.isActivatable);\n      if (!firstActivatableItem) {\n        return;\n      }\n      firstActivatableItem.tabIndex = 0;\n    };\n    const {\n      isItem,\n      getPossibleItems,\n      isRtl,\n      deactivateItem,\n      activateItem,\n      isNavigableKey,\n      isActivatable\n    } = config;\n    this.isItem = isItem;\n    this.getPossibleItems = getPossibleItems;\n    this.isRtl = isRtl;\n    this.deactivateItem = deactivateItem;\n    this.activateItem = activateItem;\n    this.isNavigableKey = isNavigableKey;\n    this.isActivatable = isActivatable;\n  }\n  /**\n   * The items being managed by the list. Additionally, attempts to see if the\n   * object has a sub-item in the `.item` property.\n   */\n  get items() {\n    const maybeItems = this.getPossibleItems();\n    const items = [];\n    for (const itemOrParent of maybeItems) {\n      const isItem = this.isItem(itemOrParent);\n      // if the item is a list item, add it to the list of items\n      if (isItem) {\n        items.push(itemOrParent);\n        continue;\n      }\n      // If the item exposes an `item` property check if it is a list item.\n      const subItem = itemOrParent.item;\n      if (subItem && this.isItem(subItem)) {\n        items.push(subItem);\n      }\n    }\n    return items;\n  }\n  /**\n   * Activates the next item in the list. If at the end of the list, the first\n   * item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activateNextItem() {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activateNextItem(items, activeItemRecord, this.isActivatable);\n  }\n  /**\n   * Activates the previous item in the list. If at the start of the list, the\n   * last item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activatePreviousItem() {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activatePreviousItem(items, activeItemRecord, this.isActivatable);\n  }\n}","map":{"version":3,"names":["activateFirstItem","activateLastItem","activateNextItem","activatePreviousItem","getActiveItem","getFirstActivatableItem","NavigableKeys","ArrowDown","ArrowLeft","ArrowUp","ArrowRight","Home","End","ListController","constructor","config","handleKeydown","event","key","defaultPrevented","isNavigableKey","items","length","activeItemRecord","isActivatable","item","tabIndex","preventDefault","isRtl","inlinePrevious","inlineNext","onDeactivateItems","deactivateItem","onRequestActivation","target","activateItem","focus","onSlotchange","encounteredActivated","isActivated","disabled","firstActivatableItem","isItem","getPossibleItems","maybeItems","itemOrParent","push","subItem"],"sources":["list-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  activateFirstItem,\n  activateLastItem,\n  activateNextItem,\n  activatePreviousItem,\n  getActiveItem,\n  getFirstActivatableItem,\n  ListItem,\n} from './list-navigation-helpers.js';\n\n// TODO: move this file to List and make List use this\n\n/**\n * Default keys that trigger navigation.\n */\n// tslint:disable:enforce-name-casing Following Enum style\nexport const NavigableKeys = {\n  ArrowDown: 'ArrowDown',\n  ArrowLeft: 'ArrowLeft',\n  ArrowUp: 'ArrowUp',\n  ArrowRight: 'ArrowRight',\n  Home: 'Home',\n  End: 'End',\n} as const;\n// tslint:enable:enforce-name-casing\n\n/**\n * Default set of navigable keys.\n */\nexport type NavigableKeys = (typeof NavigableKeys)[keyof typeof NavigableKeys];\n\n/**\n * The configuration object to customize the behavior of the List Controller\n */\nexport interface ListControllerConfig<Item extends ListItem> {\n  /**\n   * A function that determines whether or not the given element is an Item\n   */\n  isItem: (item: HTMLElement) => item is Item;\n  /**\n   * A function that returns an array of elements to consider as items. For\n   * example, all the slotted elements.\n   */\n  getPossibleItems: () => HTMLElement[];\n  /**\n   * A function that returns whether or not the list is in an RTL context.\n   */\n  isRtl: () => boolean;\n  /**\n   * Deactivates an item such as setting the tabindex to -1 and or sets selected\n   * to false.\n   */\n  deactivateItem: (item: Item) => void;\n  /**\n   * Activates an item such as setting the tabindex to 1 and or sets selected to\n   * true (but does not focus).\n   */\n  activateItem: (item: Item) => void;\n  /**\n   * Whether or not the key should be handled by the list for navigation.\n   */\n  isNavigableKey: (key: string) => boolean;\n  /**\n   * Whether or not the item can be activated. Defaults to items that are not\n   * disabled.\n   */\n  isActivatable?: (item: Item) => boolean;\n}\n\n/**\n * A controller that handles list keyboard navigation and item management.\n */\nexport class ListController<Item extends ListItem> {\n  isItem: (item: HTMLElement) => item is Item;\n  private readonly getPossibleItems: () => HTMLElement[];\n  private readonly isRtl: () => boolean;\n  private readonly deactivateItem: (item: Item) => void;\n  private readonly activateItem: (item: Item) => void;\n  private readonly isNavigableKey: (key: string) => boolean;\n  private readonly isActivatable?: (item: Item) => boolean;\n\n  constructor(config: ListControllerConfig<Item>) {\n    const {\n      isItem,\n      getPossibleItems,\n      isRtl,\n      deactivateItem,\n      activateItem,\n      isNavigableKey,\n      isActivatable,\n    } = config;\n    this.isItem = isItem;\n    this.getPossibleItems = getPossibleItems;\n    this.isRtl = isRtl;\n    this.deactivateItem = deactivateItem;\n    this.activateItem = activateItem;\n    this.isNavigableKey = isNavigableKey;\n    this.isActivatable = isActivatable;\n  }\n\n  /**\n   * The items being managed by the list. Additionally, attempts to see if the\n   * object has a sub-item in the `.item` property.\n   */\n  get items(): Item[] {\n    const maybeItems = this.getPossibleItems();\n    const items: Item[] = [];\n\n    for (const itemOrParent of maybeItems) {\n      const isItem = this.isItem(itemOrParent);\n      // if the item is a list item, add it to the list of items\n      if (isItem) {\n        items.push(itemOrParent);\n        continue;\n      }\n\n      // If the item exposes an `item` property check if it is a list item.\n      const subItem = (itemOrParent as HTMLElement & {item?: Item}).item;\n      if (subItem && this.isItem(subItem)) {\n        items.push(subItem);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * Handles keyboard navigation. Should be bound to the node that will act as\n   * the List.\n   */\n  handleKeydown = (event: KeyboardEvent) => {\n    const key = event.key;\n    if (event.defaultPrevented || !this.isNavigableKey(key)) {\n      return;\n    }\n    // do not use this.items directly in upcoming calculations so we don't\n    // re-query the DOM unnecessarily\n    const items = this.items;\n\n    if (!items.length) {\n      return;\n    }\n\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n\n    event.preventDefault();\n\n    const isRtl = this.isRtl();\n    const inlinePrevious = isRtl\n      ? NavigableKeys.ArrowRight\n      : NavigableKeys.ArrowLeft;\n    const inlineNext = isRtl\n      ? NavigableKeys.ArrowLeft\n      : NavigableKeys.ArrowRight;\n\n    switch (key) {\n      // Activate the next item\n      case NavigableKeys.ArrowDown:\n      case inlineNext:\n        activateNextItem(items, activeItemRecord, this.isActivatable);\n        break;\n\n      // Activate the previous item\n      case NavigableKeys.ArrowUp:\n      case inlinePrevious:\n        activatePreviousItem(items, activeItemRecord, this.isActivatable);\n        break;\n\n      // Activate the first item\n      case NavigableKeys.Home:\n        activateFirstItem(items, this.isActivatable);\n        break;\n\n      // Activate the last item\n      case NavigableKeys.End:\n        activateLastItem(items, this.isActivatable);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  /**\n   * Activates the next item in the list. If at the end of the list, the first\n   * item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activateNextItem(): Item | null {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activateNextItem(items, activeItemRecord, this.isActivatable);\n  }\n\n  /**\n   * Activates the previous item in the list. If at the start of the list, the\n   * last item will be activated.\n   *\n   * @return The activated list item or `null` if there are no items.\n   */\n  activatePreviousItem(): Item | null {\n    const items = this.items;\n    const activeItemRecord = getActiveItem(items, this.isActivatable);\n    if (activeItemRecord) {\n      activeItemRecord.item.tabIndex = -1;\n    }\n    return activatePreviousItem(items, activeItemRecord, this.isActivatable);\n  }\n\n  /**\n   * Listener to be bound to the `deactivate-items` item event.\n   */\n  onDeactivateItems = () => {\n    const items = this.items;\n\n    for (const item of items) {\n      this.deactivateItem(item);\n    }\n  };\n\n  /**\n   * Listener to be bound to the `request-activation` item event..\n   */\n  onRequestActivation = (event: Event) => {\n    this.onDeactivateItems();\n    const target = event.target as Item;\n    this.activateItem(target);\n    target.focus();\n  };\n\n  /**\n   * Listener to be bound to the `slotchange` event for the slot that renders\n   * the items.\n   */\n  onSlotchange = () => {\n    const items = this.items;\n    // Whether we have encountered an item that has been activated\n    let encounteredActivated = false;\n\n    for (const item of items) {\n      const isActivated = !item.disabled && item.tabIndex > -1;\n\n      if (isActivated && !encounteredActivated) {\n        encounteredActivated = true;\n        item.tabIndex = 0;\n        continue;\n      }\n\n      // Deactivate the rest including disabled\n      item.tabIndex = -1;\n    }\n\n    if (encounteredActivated) {\n      return;\n    }\n\n    const firstActivatableItem = getFirstActivatableItem(\n      items,\n      this.isActivatable,\n    );\n\n    if (!firstActivatableItem) {\n      return;\n    }\n\n    firstActivatableItem.tabIndex = 0;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}