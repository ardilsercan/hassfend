{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport \"@material/mwc-button\";\nimport deepFreeze from \"deep-freeze\";\nimport { html, LitElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { constructUrlCurrentPath } from \"../../common/url/construct-url\";\nimport { addSearchParam, removeSearchParam } from \"../../common/url/search-params\";\nimport { domainToName } from \"../../data/integration\";\nimport { subscribeLovelaceUpdates } from \"../../data/lovelace\";\nimport { deleteConfig, fetchConfig, isStrategyDashboard, saveConfig } from \"../../data/lovelace/config/types\";\nimport { isStrategyView } from \"../../data/lovelace/config/view\";\nimport { fetchResources } from \"../../data/lovelace/resource\";\nimport \"../../layouts/hass-error-screen\";\nimport \"../../layouts/hass-loading-screen\";\nimport { showToast } from \"../../util/toast\";\nimport { loadLovelaceResources } from \"./common/load-resources\";\nimport { showSaveDialog } from \"./editor/show-save-config-dialog\";\nimport \"./hui-root\";\nimport { generateLovelaceDashboardStrategy } from \"./strategies/get-strategy\";\nwindow.loadCardHelpers = () => import(\"./custom-card-helpers\");\nconst DEFAULT_CONFIG = {\n  strategy: {\n    type: \"original-states\"\n  }\n};\nlet editorLoaded = false;\nlet resourcesLoaded = false;\nexport let LovelacePanel = _decorate([customElement(\"ha-panel-lovelace\")], function (_initialize, _LitElement) {\n  class LovelacePanel extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: LovelacePanel,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"panel\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"narrow\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"route\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_panelState\",\n      value() {\n        return \"loading\";\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_errorMsg\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"lovelace\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_ignoreNextUpdateEvent\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_fetchConfigOnConnect\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_unsubUpdates\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_loading\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(LovelacePanel.prototype), \"connectedCallback\", this).call(this);\n        if (this.lovelace && this.hass && this.lovelace.locale !== this.hass.locale) {\n          // language has been changed, rebuild UI\n          this._setLovelaceConfig(this.lovelace.config, this.lovelace.rawConfig, this.lovelace.mode);\n        } else if (this.lovelace && this.lovelace.mode === \"generated\") {\n          // When lovelace is generated, we re-generate each time a user goes\n          // to the states panel to make sure new entities are shown.\n          this._panelState = \"loading\";\n          this._regenerateConfig();\n        } else if (this._fetchConfigOnConnect) {\n          // Config was changed when we were not at the lovelace panel\n          this._fetchConfig(false);\n        }\n        window.addEventListener(\"connection-status\", this._handleConnectionStatus);\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(LovelacePanel.prototype), \"disconnectedCallback\", this).call(this);\n        // On the main dashboard we want to stay subscribed as that one is cached.\n        if (this.urlPath !== null && this._unsubUpdates) {\n          this._unsubUpdates.then(unsub => unsub());\n          this._unsubUpdates = undefined;\n        }\n        // reload lovelace on reconnect so we are sure we have the latest config\n        window.removeEventListener(\"connection-status\", this._handleConnectionStatus);\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        const panelState = this._panelState;\n        if (panelState === \"loaded\") {\n          return html`\n        <hui-root\n          .hass=${this.hass}\n          .lovelace=${this.lovelace}\n          .route=${this.route}\n          .narrow=${this.narrow}\n          @config-refresh=${this._forceFetchConfig}\n        ></hui-root>\n      `;\n        }\n        if (panelState === \"error\") {\n          return html`\n        <hass-error-screen\n          .hass=${this.hass}\n          title=${domainToName(this.hass.localize, \"lovelace\")}\n          .error=${this._errorMsg}\n        >\n          <mwc-button raised @click=${this._forceFetchConfig}>\n            ${this.hass.localize(\"ui.panel.lovelace.reload_lovelace\")}\n          </mwc-button>\n        </hass-error-screen>\n      `;\n        }\n        if (panelState === \"yaml-editor\") {\n          return html`\n        <hui-editor\n          .hass=${this.hass}\n          .lovelace=${this.lovelace}\n          .closeEditor=${this._closeEditor}\n        ></hui-editor>\n      `;\n        }\n        return html`\n      <hass-loading-screen\n        rootnav\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n      ></hass-loading-screen>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        _get(_getPrototypeOf(LovelacePanel.prototype), \"willUpdate\", this).call(this, changedProps);\n        if (!this.lovelace && this._panelState !== \"error\" && !this._loading) {\n          this._fetchConfig(false);\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated(changedProps) {\n        _get(_getPrototypeOf(LovelacePanel.prototype), \"firstUpdated\", this).call(this, changedProps);\n        if (!this._unsubUpdates) {\n          this._subscribeUpdates();\n        }\n      }\n    }, {\n      kind: \"field\",\n      key: \"_handleConnectionStatus\",\n      value() {\n        return ev => {\n          // reload lovelace on reconnect so we are sure we have the latest config\n          if (ev.detail === \"connected\") {\n            this._fetchConfig(false);\n          }\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_regenerateConfig\",\n      value: async function _regenerateConfig() {\n        const conf = await generateLovelaceDashboardStrategy(DEFAULT_CONFIG.strategy, this.hass);\n        this._setLovelaceConfig(conf, DEFAULT_CONFIG, \"generated\");\n        this._panelState = \"loaded\";\n      }\n    }, {\n      kind: \"method\",\n      key: \"_subscribeUpdates\",\n      value: async function _subscribeUpdates() {\n        this._unsubUpdates = subscribeLovelaceUpdates(this.hass.connection, this.urlPath, () => this._lovelaceChanged());\n      }\n    }, {\n      kind: \"field\",\n      key: \"_closeEditor\",\n      value() {\n        return () => {\n          this._panelState = \"loaded\";\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_lovelaceChanged\",\n      value: function _lovelaceChanged() {\n        if (this._ignoreNextUpdateEvent) {\n          this._ignoreNextUpdateEvent = false;\n          return;\n        }\n        if (!this.isConnected) {\n          // We can't fire events from an element that is not connected\n          // Make sure we fetch the config as soon as the user goes back to Lovelace\n          this._fetchConfigOnConnect = true;\n          return;\n        }\n        showToast(this, {\n          message: this.hass.localize(\"ui.panel.lovelace.changed_toast.message\"),\n          action: {\n            action: () => this._fetchConfig(false),\n            text: this.hass.localize(\"ui.common.refresh\")\n          },\n          duration: 0,\n          dismissable: false\n        });\n      }\n    }, {\n      kind: \"get\",\n      key: \"urlPath\",\n      value: function urlPath() {\n        return this.panel.url_path === \"lovelace\" ? null : this.panel.url_path;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_forceFetchConfig\",\n      value: function _forceFetchConfig() {\n        this._fetchConfig(true);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_fetchConfig\",\n      value: async function _fetchConfig(forceDiskRefresh) {\n        this._loading = true;\n        let conf;\n        let rawConf;\n        let confMode = this.panel.config.mode;\n        let confProm;\n        const preloadWindow = window;\n\n        // On first load, we speed up loading page by having LL promise ready\n        if (preloadWindow.llConfProm) {\n          confProm = preloadWindow.llConfProm;\n          preloadWindow.llConfProm = undefined;\n        }\n        if (!resourcesLoaded) {\n          resourcesLoaded = true;\n          (preloadWindow.llResProm || fetchResources(this.hass.connection)).then(resources => loadLovelaceResources(resources, this.hass));\n        }\n        if (this.urlPath !== null || !confProm) {\n          // Refreshing a YAML config can trigger an update event. We will ignore\n          // all update events while fetching the config and for 2 seconds after the config is back.\n          // We ignore because we already have the latest config.\n          if (this.lovelace && this.lovelace.mode === \"yaml\") {\n            this._ignoreNextUpdateEvent = true;\n          }\n          confProm = fetchConfig(this.hass.connection, this.urlPath, forceDiskRefresh);\n        }\n        try {\n          rawConf = await confProm;\n\n          // If strategy defined, apply it here.\n          if (isStrategyDashboard(rawConf)) {\n            var _this$hass;\n            if (!((_this$hass = this.hass) !== null && _this$hass !== void 0 && _this$hass.entities) || !this.hass.devices || !this.hass.areas) {\n              // We need these to generate a dashboard, wait for them\n              return;\n            }\n            conf = await generateLovelaceDashboardStrategy(rawConf.strategy, this.hass);\n          } else {\n            conf = rawConf;\n          }\n        } catch (err) {\n          var _this$hass2;\n          if (err.code !== \"config_not_found\") {\n            // eslint-disable-next-line\n            console.log(err);\n            this._panelState = \"error\";\n            this._errorMsg = err.message;\n            return;\n          }\n          if (!((_this$hass2 = this.hass) !== null && _this$hass2 !== void 0 && _this$hass2.entities) || !this.hass.devices || !this.hass.areas) {\n            // We need these to generate a dashboard, wait for them\n            return;\n          }\n          conf = await generateLovelaceDashboardStrategy(DEFAULT_CONFIG.strategy, this.hass);\n          rawConf = DEFAULT_CONFIG;\n          confMode = \"generated\";\n        } finally {\n          this._loading = false;\n          // Ignore updates for another 2 seconds.\n          if (this.lovelace && this.lovelace.mode === \"yaml\") {\n            setTimeout(() => {\n              this._ignoreNextUpdateEvent = false;\n            }, 2000);\n          }\n        }\n        this._panelState = this._panelState === \"yaml-editor\" ? this._panelState : \"loaded\";\n        this._setLovelaceConfig(conf, rawConf, confMode);\n      }\n    }, {\n      kind: \"method\",\n      key: \"_checkLovelaceConfig\",\n      value: function _checkLovelaceConfig(config) {\n        // Somehow there can be badges with value null, we remove those\n        if (isStrategyDashboard(config)) {\n          return config;\n        }\n        let checkedConfig = !Object.isFrozen(config) ? config : undefined;\n        config.views.forEach((view, index) => {\n          if (isStrategyView(view)) {\n            return;\n          }\n          if (view.badges && !view.badges.every(Boolean)) {\n            checkedConfig = checkedConfig || {\n              ...config,\n              views: [...config.views]\n            };\n            const updatedView = {\n              ...view\n            };\n            updatedView.badges = view.badges.filter(Boolean);\n            checkedConfig.views[index] = updatedView;\n          }\n        });\n        return checkedConfig ? deepFreeze(checkedConfig) : config;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_setLovelaceConfig\",\n      value: function _setLovelaceConfig(config, rawConfig, mode) {\n        config = this._checkLovelaceConfig(config);\n        const urlPath = this.urlPath;\n        this.lovelace = {\n          config,\n          rawConfig,\n          mode,\n          urlPath: this.urlPath,\n          editMode: this.lovelace ? this.lovelace.editMode : false,\n          locale: this.hass.locale,\n          enableFullEditMode: () => {\n            if (!editorLoaded) {\n              editorLoaded = true;\n              import(\"./hui-editor\");\n            }\n            this._panelState = \"yaml-editor\";\n          },\n          setEditMode: editMode => {\n            // If the dashboard is generated (default dashboard)\n            // Propose to take control of it\n            if (this.lovelace.mode === \"generated\" && editMode) {\n              showSaveDialog(this, {\n                lovelace: this.lovelace,\n                mode: this.panel.config.mode,\n                narrow: this.narrow\n              });\n              return;\n            }\n\n            // If we use a strategy for dashboard, we cannot show the edit UI\n            // So go straight to the YAML editor\n            if (isStrategyDashboard(this.lovelace.rawConfig) && editMode) {\n              this.lovelace.enableFullEditMode();\n              return;\n            }\n            this._updateLovelace({\n              editMode\n            });\n          },\n          saveConfig: async newConfig => {\n            const {\n              config: previousConfig,\n              rawConfig: previousRawConfig,\n              mode: previousMode\n            } = this.lovelace;\n            newConfig = this._checkLovelaceConfig(newConfig);\n            let conf;\n            // If strategy defined, apply it here.\n            if (isStrategyDashboard(newConfig)) {\n              conf = await generateLovelaceDashboardStrategy(newConfig.strategy, this.hass);\n            } else {\n              conf = newConfig;\n            }\n            try {\n              // Optimistic update\n              this._updateLovelace({\n                config: conf,\n                rawConfig: newConfig,\n                mode: \"storage\"\n              });\n              this._ignoreNextUpdateEvent = true;\n              await saveConfig(this.hass, urlPath, newConfig);\n            } catch (err) {\n              // eslint-disable-next-line\n              console.error(err);\n              // Rollback the optimistic update\n              this._updateLovelace({\n                config: previousConfig,\n                rawConfig: previousRawConfig,\n                mode: previousMode\n              });\n              throw err;\n            }\n          },\n          deleteConfig: async () => {\n            const {\n              config: previousConfig,\n              rawConfig: previousRawConfig,\n              mode: previousMode\n            } = this.lovelace;\n            try {\n              // Optimistic update\n              const generatedConf = await generateLovelaceDashboardStrategy(DEFAULT_CONFIG.strategy, this.hass);\n              this._updateLovelace({\n                config: generatedConf,\n                rawConfig: DEFAULT_CONFIG,\n                mode: \"generated\",\n                editMode: false\n              });\n              this._ignoreNextUpdateEvent = true;\n              await deleteConfig(this.hass, urlPath);\n            } catch (err) {\n              // eslint-disable-next-line\n              console.error(err);\n              // Rollback the optimistic update\n              this._updateLovelace({\n                config: previousConfig,\n                rawConfig: previousRawConfig,\n                mode: previousMode\n              });\n              throw err;\n            }\n          }\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_updateLovelace\",\n      value: function _updateLovelace(props) {\n        this.lovelace = {\n          ...this.lovelace,\n          ...props\n        };\n        if (\"editMode\" in props) {\n          window.history.replaceState(null, \"\", constructUrlCurrentPath(props.editMode ? addSearchParam({\n            edit: \"1\"\n          }) : removeSearchParam(\"edit\")));\n        }\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["deepFreeze","html","LitElement","customElement","property","state","constructUrlCurrentPath","addSearchParam","removeSearchParam","domainToName","subscribeLovelaceUpdates","deleteConfig","fetchConfig","isStrategyDashboard","saveConfig","isStrategyView","fetchResources","showToast","loadLovelaceResources","showSaveDialog","generateLovelaceDashboardStrategy","window","loadCardHelpers","DEFAULT_CONFIG","strategy","type","editorLoaded","resourcesLoaded","LovelacePanel","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","Boolean","connectedCallback","_get","_getPrototypeOf","prototype","call","lovelace","hass","locale","_setLovelaceConfig","config","rawConfig","mode","_panelState","_regenerateConfig","_fetchConfigOnConnect","_fetchConfig","addEventListener","_handleConnectionStatus","disconnectedCallback","urlPath","_unsubUpdates","then","unsub","undefined","removeEventListener","render","panelState","route","narrow","_forceFetchConfig","localize","_errorMsg","_closeEditor","willUpdate","changedProps","_loading","firstUpdated","_subscribeUpdates","ev","detail","conf","connection","_lovelaceChanged","_ignoreNextUpdateEvent","isConnected","message","action","text","duration","dismissable","panel","url_path","forceDiskRefresh","rawConf","confMode","confProm","preloadWindow","llConfProm","llResProm","resources","_this$hass","entities","devices","areas","err","_this$hass2","code","console","log","setTimeout","_checkLovelaceConfig","checkedConfig","Object","isFrozen","views","forEach","view","index","badges","every","updatedView","filter","editMode","enableFullEditMode","setEditMode","_updateLovelace","newConfig","previousConfig","previousRawConfig","previousMode","error","generatedConf","props","history","replaceState","edit"],"sources":["/workspaces/frontend/src/panels/lovelace/ha-panel-lovelace.ts"],"sourcesContent":["import \"@material/mwc-button\";\nimport deepFreeze from \"deep-freeze\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { constructUrlCurrentPath } from \"../../common/url/construct-url\";\nimport {\n  addSearchParam,\n  removeSearchParam,\n} from \"../../common/url/search-params\";\nimport { domainToName } from \"../../data/integration\";\nimport { subscribeLovelaceUpdates } from \"../../data/lovelace\";\nimport {\n  deleteConfig,\n  fetchConfig,\n  isStrategyDashboard,\n  LovelaceConfig,\n  LovelaceDashboardStrategyConfig,\n  LovelaceRawConfig,\n  saveConfig,\n} from \"../../data/lovelace/config/types\";\nimport {\n  isStrategyView,\n  LovelaceViewConfig,\n} from \"../../data/lovelace/config/view\";\nimport { fetchResources } from \"../../data/lovelace/resource\";\nimport { WindowWithPreloads } from \"../../data/preloads\";\nimport \"../../layouts/hass-error-screen\";\nimport \"../../layouts/hass-loading-screen\";\nimport { HomeAssistant, PanelInfo, Route } from \"../../types\";\nimport { showToast } from \"../../util/toast\";\nimport { loadLovelaceResources } from \"./common/load-resources\";\nimport { showSaveDialog } from \"./editor/show-save-config-dialog\";\nimport \"./hui-root\";\nimport { generateLovelaceDashboardStrategy } from \"./strategies/get-strategy\";\nimport { Lovelace } from \"./types\";\n\n(window as any).loadCardHelpers = () => import(\"./custom-card-helpers\");\n\nconst DEFAULT_CONFIG: LovelaceDashboardStrategyConfig = {\n  strategy: {\n    type: \"original-states\",\n  },\n};\n\ninterface LovelacePanelConfig {\n  mode: \"yaml\" | \"storage\";\n}\n\nlet editorLoaded = false;\nlet resourcesLoaded = false;\n\n@customElement(\"ha-panel-lovelace\")\nexport class LovelacePanel extends LitElement {\n  @property({ attribute: false }) public panel?: PanelInfo<LovelacePanelConfig>;\n\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ type: Boolean }) public narrow = false;\n\n  @property({ attribute: false }) public route?: Route;\n\n  @state() private _panelState: \"loading\" | \"loaded\" | \"error\" | \"yaml-editor\" =\n    \"loading\";\n\n  @state() private _errorMsg?: string;\n\n  @state() private lovelace?: Lovelace;\n\n  private _ignoreNextUpdateEvent = false;\n\n  private _fetchConfigOnConnect = false;\n\n  private _unsubUpdates?: Promise<UnsubscribeFunc>;\n\n  private _loading = false;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    if (\n      this.lovelace &&\n      this.hass &&\n      this.lovelace.locale !== this.hass.locale\n    ) {\n      // language has been changed, rebuild UI\n      this._setLovelaceConfig(\n        this.lovelace.config,\n        this.lovelace.rawConfig,\n        this.lovelace.mode\n      );\n    } else if (this.lovelace && this.lovelace.mode === \"generated\") {\n      // When lovelace is generated, we re-generate each time a user goes\n      // to the states panel to make sure new entities are shown.\n      this._panelState = \"loading\";\n      this._regenerateConfig();\n    } else if (this._fetchConfigOnConnect) {\n      // Config was changed when we were not at the lovelace panel\n      this._fetchConfig(false);\n    }\n    window.addEventListener(\"connection-status\", this._handleConnectionStatus);\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    // On the main dashboard we want to stay subscribed as that one is cached.\n    if (this.urlPath !== null && this._unsubUpdates) {\n      this._unsubUpdates.then((unsub) => unsub());\n      this._unsubUpdates = undefined;\n    }\n    // reload lovelace on reconnect so we are sure we have the latest config\n    window.removeEventListener(\n      \"connection-status\",\n      this._handleConnectionStatus\n    );\n  }\n\n  protected render(): TemplateResult | void {\n    const panelState = this._panelState;\n\n    if (panelState === \"loaded\") {\n      return html`\n        <hui-root\n          .hass=${this.hass}\n          .lovelace=${this.lovelace}\n          .route=${this.route}\n          .narrow=${this.narrow}\n          @config-refresh=${this._forceFetchConfig}\n        ></hui-root>\n      `;\n    }\n\n    if (panelState === \"error\") {\n      return html`\n        <hass-error-screen\n          .hass=${this.hass}\n          title=${domainToName(this.hass!.localize, \"lovelace\")}\n          .error=${this._errorMsg}\n        >\n          <mwc-button raised @click=${this._forceFetchConfig}>\n            ${this.hass!.localize(\"ui.panel.lovelace.reload_lovelace\")}\n          </mwc-button>\n        </hass-error-screen>\n      `;\n    }\n\n    if (panelState === \"yaml-editor\") {\n      return html`\n        <hui-editor\n          .hass=${this.hass}\n          .lovelace=${this.lovelace}\n          .closeEditor=${this._closeEditor}\n        ></hui-editor>\n      `;\n    }\n\n    return html`\n      <hass-loading-screen\n        rootnav\n        .hass=${this.hass}\n        .narrow=${this.narrow}\n      ></hass-loading-screen>\n    `;\n  }\n\n  protected willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (!this.lovelace && this._panelState !== \"error\" && !this._loading) {\n      this._fetchConfig(false);\n    }\n  }\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n    if (!this._unsubUpdates) {\n      this._subscribeUpdates();\n    }\n  }\n\n  private _handleConnectionStatus = (ev) => {\n    // reload lovelace on reconnect so we are sure we have the latest config\n    if (ev.detail === \"connected\") {\n      this._fetchConfig(false);\n    }\n  };\n\n  private async _regenerateConfig() {\n    const conf = await generateLovelaceDashboardStrategy(\n      DEFAULT_CONFIG.strategy,\n      this.hass!\n    );\n    this._setLovelaceConfig(conf, DEFAULT_CONFIG, \"generated\");\n    this._panelState = \"loaded\";\n  }\n\n  private async _subscribeUpdates() {\n    this._unsubUpdates = subscribeLovelaceUpdates(\n      this.hass!.connection,\n      this.urlPath,\n      () => this._lovelaceChanged()\n    );\n  }\n\n  private _closeEditor = () => {\n    this._panelState = \"loaded\";\n  };\n\n  private _lovelaceChanged() {\n    if (this._ignoreNextUpdateEvent) {\n      this._ignoreNextUpdateEvent = false;\n      return;\n    }\n    if (!this.isConnected) {\n      // We can't fire events from an element that is not connected\n      // Make sure we fetch the config as soon as the user goes back to Lovelace\n      this._fetchConfigOnConnect = true;\n      return;\n    }\n    showToast(this, {\n      message: this.hass!.localize(\"ui.panel.lovelace.changed_toast.message\"),\n      action: {\n        action: () => this._fetchConfig(false),\n        text: this.hass!.localize(\"ui.common.refresh\"),\n      },\n      duration: 0,\n      dismissable: false,\n    });\n  }\n\n  public get urlPath() {\n    return this.panel!.url_path === \"lovelace\" ? null : this.panel!.url_path;\n  }\n\n  private _forceFetchConfig() {\n    this._fetchConfig(true);\n  }\n\n  private async _fetchConfig(forceDiskRefresh: boolean) {\n    this._loading = true;\n\n    let conf: LovelaceConfig;\n    let rawConf: LovelaceRawConfig | undefined;\n    let confMode: Lovelace[\"mode\"] = this.panel!.config.mode;\n    let confProm: Promise<LovelaceRawConfig> | undefined;\n    const preloadWindow = window as WindowWithPreloads;\n\n    // On first load, we speed up loading page by having LL promise ready\n    if (preloadWindow.llConfProm) {\n      confProm = preloadWindow.llConfProm;\n      preloadWindow.llConfProm = undefined;\n    }\n    if (!resourcesLoaded) {\n      resourcesLoaded = true;\n      (preloadWindow.llResProm || fetchResources(this.hass!.connection)).then(\n        (resources) => loadLovelaceResources(resources, this.hass!)\n      );\n    }\n\n    if (this.urlPath !== null || !confProm) {\n      // Refreshing a YAML config can trigger an update event. We will ignore\n      // all update events while fetching the config and for 2 seconds after the config is back.\n      // We ignore because we already have the latest config.\n      if (this.lovelace && this.lovelace.mode === \"yaml\") {\n        this._ignoreNextUpdateEvent = true;\n      }\n\n      confProm = fetchConfig(\n        this.hass!.connection,\n        this.urlPath,\n        forceDiskRefresh\n      );\n    }\n\n    try {\n      rawConf = await confProm!;\n\n      // If strategy defined, apply it here.\n      if (isStrategyDashboard(rawConf)) {\n        if (!this.hass?.entities || !this.hass.devices || !this.hass.areas) {\n          // We need these to generate a dashboard, wait for them\n          return;\n        }\n        conf = await generateLovelaceDashboardStrategy(\n          rawConf.strategy,\n          this.hass!\n        );\n      } else {\n        conf = rawConf;\n      }\n    } catch (err: any) {\n      if (err.code !== \"config_not_found\") {\n        // eslint-disable-next-line\n        console.log(err);\n        this._panelState = \"error\";\n        this._errorMsg = err.message;\n        return;\n      }\n      if (!this.hass?.entities || !this.hass.devices || !this.hass.areas) {\n        // We need these to generate a dashboard, wait for them\n        return;\n      }\n      conf = await generateLovelaceDashboardStrategy(\n        DEFAULT_CONFIG.strategy,\n        this.hass!\n      );\n      rawConf = DEFAULT_CONFIG;\n      confMode = \"generated\";\n    } finally {\n      this._loading = false;\n      // Ignore updates for another 2 seconds.\n      if (this.lovelace && this.lovelace.mode === \"yaml\") {\n        setTimeout(() => {\n          this._ignoreNextUpdateEvent = false;\n        }, 2000);\n      }\n    }\n\n    this._panelState =\n      this._panelState === \"yaml-editor\" ? this._panelState : \"loaded\";\n    this._setLovelaceConfig(conf, rawConf, confMode);\n  }\n\n  private _checkLovelaceConfig(config: LovelaceRawConfig) {\n    // Somehow there can be badges with value null, we remove those\n    if (isStrategyDashboard(config)) {\n      return config;\n    }\n    let checkedConfig = !Object.isFrozen(config) ? config : undefined;\n    config.views.forEach((view, index) => {\n      if (isStrategyView(view)) {\n        return;\n      }\n      if (view.badges && !view.badges.every(Boolean)) {\n        checkedConfig = checkedConfig || {\n          ...config,\n          views: [...config.views],\n        };\n        const updatedView = { ...view } as LovelaceViewConfig;\n        updatedView.badges = view.badges.filter(Boolean);\n        checkedConfig.views[index] = updatedView;\n      }\n    });\n    return checkedConfig ? deepFreeze(checkedConfig) : config;\n  }\n\n  private _setLovelaceConfig(\n    config: LovelaceConfig,\n    rawConfig: LovelaceRawConfig,\n    mode: Lovelace[\"mode\"]\n  ) {\n    config = this._checkLovelaceConfig(config);\n    const urlPath = this.urlPath;\n    this.lovelace = {\n      config,\n      rawConfig,\n      mode,\n      urlPath: this.urlPath,\n      editMode: this.lovelace ? this.lovelace.editMode : false,\n      locale: this.hass!.locale,\n      enableFullEditMode: () => {\n        if (!editorLoaded) {\n          editorLoaded = true;\n          import(\"./hui-editor\");\n        }\n        this._panelState = \"yaml-editor\";\n      },\n      setEditMode: (editMode: boolean) => {\n        // If the dashboard is generated (default dashboard)\n        // Propose to take control of it\n        if (this.lovelace!.mode === \"generated\" && editMode) {\n          showSaveDialog(this, {\n            lovelace: this.lovelace!,\n            mode: this.panel!.config.mode,\n            narrow: this.narrow!,\n          });\n          return;\n        }\n\n        // If we use a strategy for dashboard, we cannot show the edit UI\n        // So go straight to the YAML editor\n        if (isStrategyDashboard(this.lovelace!.rawConfig) && editMode) {\n          this.lovelace!.enableFullEditMode();\n          return;\n        }\n\n        this._updateLovelace({ editMode });\n      },\n      saveConfig: async (newConfig: LovelaceRawConfig): Promise<void> => {\n        const {\n          config: previousConfig,\n          rawConfig: previousRawConfig,\n          mode: previousMode,\n        } = this.lovelace!;\n        newConfig = this._checkLovelaceConfig(newConfig);\n        let conf: LovelaceConfig;\n        // If strategy defined, apply it here.\n        if (isStrategyDashboard(newConfig)) {\n          conf = await generateLovelaceDashboardStrategy(\n            newConfig.strategy,\n            this.hass!\n          );\n        } else {\n          conf = newConfig;\n        }\n        try {\n          // Optimistic update\n          this._updateLovelace({\n            config: conf,\n            rawConfig: newConfig,\n            mode: \"storage\",\n          });\n          this._ignoreNextUpdateEvent = true;\n          await saveConfig(this.hass!, urlPath, newConfig);\n        } catch (err: any) {\n          // eslint-disable-next-line\n          console.error(err);\n          // Rollback the optimistic update\n          this._updateLovelace({\n            config: previousConfig,\n            rawConfig: previousRawConfig,\n            mode: previousMode,\n          });\n          throw err;\n        }\n      },\n      deleteConfig: async (): Promise<void> => {\n        const {\n          config: previousConfig,\n          rawConfig: previousRawConfig,\n          mode: previousMode,\n        } = this.lovelace!;\n        try {\n          // Optimistic update\n          const generatedConf = await generateLovelaceDashboardStrategy(\n            DEFAULT_CONFIG.strategy,\n            this.hass!\n          );\n          this._updateLovelace({\n            config: generatedConf,\n            rawConfig: DEFAULT_CONFIG,\n            mode: \"generated\",\n            editMode: false,\n          });\n          this._ignoreNextUpdateEvent = true;\n          await deleteConfig(this.hass!, urlPath);\n        } catch (err: any) {\n          // eslint-disable-next-line\n          console.error(err);\n          // Rollback the optimistic update\n          this._updateLovelace({\n            config: previousConfig,\n            rawConfig: previousRawConfig,\n            mode: previousMode,\n          });\n          throw err;\n        }\n      },\n    };\n  }\n\n  private _updateLovelace(props: Partial<Lovelace>) {\n    this.lovelace = {\n      ...this.lovelace!,\n      ...props,\n    };\n\n    if (\"editMode\" in props) {\n      window.history.replaceState(\n        null,\n        \"\",\n        constructUrlCurrentPath(\n          props.editMode\n            ? addSearchParam({ edit: \"1\" })\n            : removeSearchParam(\"edit\")\n        )\n      );\n    }\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-panel-lovelace\": LovelacePanel;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}