{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport { html, LitElement } from \"lit\";\nimport { property, query, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport { formatNumber, numberFormatToLocale, getNumberFormatOptions } from \"../../common/number/format_number\";\nimport { MIN_TIME_BETWEEN_UPDATES } from \"./ha-chart-base\";\nconst safeParseFloat = value => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\nexport let StateHistoryChartLine = _decorate(null, function (_initialize, _LitElement) {\n  class StateHistoryChartLine extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: StateHistoryChartLine,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"data\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"names\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"identifier\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"showNames\",\n      value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"clickForMoreInfo\",\n      value() {\n        return true;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"startTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"paddingYAxis\",\n      value() {\n        return 0;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"chartIndex\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"logarithmicScale\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"minYAxis\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Number\n      })],\n      key: \"maxYAxis\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean\n      })],\n      key: \"fitYData\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_entityIds\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      key: \"_datasetToDataIndex\",\n      value() {\n        return [];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_yWidth\",\n      value() {\n        return 0;\n      }\n    }, {\n      kind: \"field\",\n      key: \"_chartTime\",\n      value() {\n        return new Date();\n      }\n    }, {\n      kind: \"field\",\n      decorators: [query(\"ha-chart-base\")],\n      key: \"_chart\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"resize\",\n      value() {\n        return options => {\n          var _this$_chart;\n          (_this$_chart = this._chart) === null || _this$_chart === void 0 || _this$_chart.resize(options);\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .paddingYAxis=${this.paddingYAxis - this._yWidth}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated || changedProps.has(\"showNames\") || changedProps.has(\"startTime\") || changedProps.has(\"endTime\") || changedProps.has(\"unit\") || changedProps.has(\"logarithmicScale\") || changedProps.has(\"minYAxis\") || changedProps.has(\"maxYAxis\") || changedProps.has(\"fitYData\")) {\n          this._chartOptions = {\n            parsing: false,\n            animation: false,\n            interaction: {\n              mode: \"nearest\",\n              axis: \"xy\"\n            },\n            scales: {\n              x: {\n                type: \"time\",\n                adapters: {\n                  date: {\n                    locale: this.hass.locale,\n                    config: this.hass.config\n                  }\n                },\n                suggestedMin: this.startTime,\n                suggestedMax: this.endTime,\n                ticks: {\n                  maxRotation: 0,\n                  sampleSize: 5,\n                  autoSkipPadding: 20,\n                  major: {\n                    enabled: true\n                  },\n                  font: context => context.tick && context.tick.major ? {\n                    weight: \"bold\"\n                  } : {}\n                },\n                time: {\n                  tooltipFormat: \"datetimeseconds\"\n                }\n              },\n              y: {\n                suggestedMin: this.fitYData ? this.minYAxis : null,\n                suggestedMax: this.fitYData ? this.maxYAxis : null,\n                min: this.fitYData ? null : this.minYAxis,\n                max: this.fitYData ? null : this.maxYAxis,\n                ticks: {\n                  maxTicksLimit: 7\n                },\n                title: {\n                  display: true,\n                  text: this.unit\n                },\n                afterUpdate: y => {\n                  if (this._yWidth !== Math.floor(y.width)) {\n                    this._yWidth = Math.floor(y.width);\n                    fireEvent(this, \"y-width-changed\", {\n                      value: this._yWidth,\n                      chartIndex: this.chartIndex\n                    });\n                  }\n                },\n                position: computeRTL(this.hass) ? \"right\" : \"left\",\n                type: this.logarithmicScale ? \"logarithmic\" : \"linear\"\n              }\n            },\n            plugins: {\n              tooltip: {\n                callbacks: {\n                  label: context => {\n                    let label = `${context.dataset.label}: ${formatNumber(context.parsed.y, this.hass.locale, getNumberFormatOptions(undefined, this.hass.entities[this._entityIds[context.datasetIndex]]))} ${this.unit}`;\n                    const dataIndex = this._datasetToDataIndex[context.datasetIndex];\n                    const data = this.data[dataIndex];\n                    if (data.statistics && data.statistics.length > 0) {\n                      const source = data.states.length === 0 || context.parsed.x < data.states[0].last_changed ? `\\n${this.hass.localize(\"ui.components.history_charts.source_stats\")}` : `\\n${this.hass.localize(\"ui.components.history_charts.source_history\")}`;\n                      label += source;\n                    }\n                    return label;\n                  }\n                }\n              },\n              filler: {\n                propagate: true\n              },\n              legend: {\n                display: this.showNames,\n                labels: {\n                  usePointStyle: true\n                }\n              }\n            },\n            elements: {\n              line: {\n                tension: 0.1,\n                borderWidth: 1.5\n              },\n              point: {\n                hitRadius: 50\n              }\n            },\n            segment: {\n              borderColor: context => {\n                // render stat data with a slightly transparent line\n                const dataIndex = this._datasetToDataIndex[context.datasetIndex];\n                const data = this.data[dataIndex];\n                return data.statistics && data.statistics.length > 0 && (data.states.length === 0 || context.p0.parsed.x < data.states[0].last_changed) ? this._chartData.datasets[dataIndex].borderColor + \"7F\" : undefined;\n              }\n            },\n            // @ts-expect-error\n            locale: numberFormatToLocale(this.hass.locale),\n            onClick: e => {\n              if (!this.clickForMoreInfo || !(e.native instanceof MouseEvent) || e.native instanceof PointerEvent && e.native.pointerType !== \"mouse\") {\n                return;\n              }\n              const chart = e.chart;\n              const points = chart.getElementsAtEventForMode(e, \"nearest\", {\n                intersect: true\n              }, true);\n              if (points.length) {\n                const firstPoint = points[0];\n                fireEvent(this, \"hass-more-info\", {\n                  entityId: this._entityIds[firstPoint.datasetIndex]\n                });\n                chart.canvas.dispatchEvent(new Event(\"mouseout\")); // to hide tooltip\n              }\n            }\n          };\n        }\n        if (changedProps.has(\"data\") || changedProps.has(\"startTime\") || changedProps.has(\"endTime\") || this._chartTime < new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)) {\n          // If the line is more than 5 minutes old, re-gen it\n          // so the X axis grows even if there is no new data\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: function _generateData() {\n        let colorIndex = 0;\n        const computedStyles = getComputedStyle(this);\n        const entityStates = this.data;\n        const datasets = [];\n        const entityIds = [];\n        const datasetToDataIndex = [];\n        if (entityStates.length === 0) {\n          return;\n        }\n        this._chartTime = new Date();\n        const endTime = this.endTime;\n        const names = this.names || {};\n        entityStates.forEach((states, dataIdx) => {\n          const domain = states.domain;\n          const name = names[states.entity_id] || states.name;\n          // array containing [value1, value2, etc]\n          let prevValues = null;\n          const data = [];\n          const pushData = (timestamp, datavalues) => {\n            if (!datavalues) return;\n            if (timestamp > endTime) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n            data.forEach((d, i) => {\n              if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n                // null data values show up as gaps in the chart.\n                // If the current value for the dataset is null and the previous\n                // value of the data set is not null, then add an 'end' point\n                // to the chart for the previous value. Otherwise the gap will\n                // be too big. It will go from the start of the previous data\n                // value until the start of the next data value.\n                d.data.push({\n                  x: timestamp.getTime(),\n                  y: prevValues[i]\n                });\n              }\n              d.data.push({\n                x: timestamp.getTime(),\n                y: datavalues[i]\n              });\n            });\n            prevValues = datavalues;\n          };\n          const addDataSet = (nameY, fill = false, color) => {\n            if (!color) {\n              color = getGraphColorByIndex(colorIndex, computedStyles);\n              colorIndex++;\n            }\n            data.push({\n              label: nameY,\n              fill: fill ? \"origin\" : false,\n              borderColor: color,\n              backgroundColor: color + \"7F\",\n              stepped: \"before\",\n              pointRadius: 0,\n              data: []\n            });\n            entityIds.push(states.entity_id);\n            datasetToDataIndex.push(dataIdx);\n          };\n          if (domain === \"thermostat\" || domain === \"climate\" || domain === \"water_heater\") {\n            const hasHvacAction = states.states.some(entityState => {\n              var _entityState$attribut;\n              return (_entityState$attribut = entityState.attributes) === null || _entityState$attribut === void 0 ? void 0 : _entityState$attribut.hvac_action;\n            });\n            const isHeating = domain === \"climate\" && hasHvacAction ? entityState => {\n              var _entityState$attribut2;\n              return ((_entityState$attribut2 = entityState.attributes) === null || _entityState$attribut2 === void 0 ? void 0 : _entityState$attribut2.hvac_action) === \"heating\";\n            } : entityState => entityState.state === \"heat\";\n            const isCooling = domain === \"climate\" && hasHvacAction ? entityState => {\n              var _entityState$attribut3;\n              return ((_entityState$attribut3 = entityState.attributes) === null || _entityState$attribut3 === void 0 ? void 0 : _entityState$attribut3.hvac_action) === \"cooling\";\n            } : entityState => entityState.state === \"cool\";\n            const hasHeat = states.states.some(isHeating);\n            const hasCool = states.states.some(isCooling);\n            // We differentiate between thermostats that have a target temperature\n            // range versus ones that have just a target temperature\n\n            // Using step chart by step-before so manually interpolation not needed.\n            const hasTargetRange = states.states.some(entityState => entityState.attributes && entityState.attributes.target_temp_high !== entityState.attributes.target_temp_low);\n            addDataSet(`${this.hass.localize(\"ui.card.climate.current_temperature\", {\n              name: name\n            })}`);\n            if (hasHeat) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.heating\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-climate-heat-color\"));\n              // The \"heating\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n            if (hasCool) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.cooling\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-climate-cool-color\"));\n              // The \"cooling\" series uses steppedArea to shade the area below the current\n              // temperature when the thermostat is calling for heat.\n            }\n            if (hasTargetRange) {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: this.hass.localize(\"ui.card.climate.high\")\n              })}`);\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n                name: name,\n                mode: this.hass.localize(\"ui.card.climate.low\")\n              })}`);\n            } else {\n              addDataSet(`${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n                name: name\n              })}`);\n            }\n            states.states.forEach(entityState => {\n              if (!entityState.attributes) return;\n              const curTemp = safeParseFloat(entityState.attributes.current_temperature);\n              const series = [curTemp];\n              if (hasHeat) {\n                series.push(isHeating(entityState) ? curTemp : null);\n              }\n              if (hasCool) {\n                series.push(isCooling(entityState) ? curTemp : null);\n              }\n              if (hasTargetRange) {\n                const targetHigh = safeParseFloat(entityState.attributes.target_temp_high);\n                const targetLow = safeParseFloat(entityState.attributes.target_temp_low);\n                series.push(targetHigh, targetLow);\n                pushData(new Date(entityState.last_changed), series);\n              } else {\n                const target = safeParseFloat(entityState.attributes.temperature);\n                series.push(target);\n                pushData(new Date(entityState.last_changed), series);\n              }\n            });\n          } else if (domain === \"humidifier\") {\n            const hasAction = states.states.some(entityState => {\n              var _entityState$attribut4;\n              return (_entityState$attribut4 = entityState.attributes) === null || _entityState$attribut4 === void 0 ? void 0 : _entityState$attribut4.action;\n            });\n            const hasCurrent = states.states.some(entityState => {\n              var _entityState$attribut5;\n              return (_entityState$attribut5 = entityState.attributes) === null || _entityState$attribut5 === void 0 ? void 0 : _entityState$attribut5.current_humidity;\n            });\n            const hasHumidifying = hasAction && states.states.some(entityState => {\n              var _entityState$attribut6;\n              return ((_entityState$attribut6 = entityState.attributes) === null || _entityState$attribut6 === void 0 ? void 0 : _entityState$attribut6.action) === \"humidifying\";\n            });\n            const hasDrying = hasAction && states.states.some(entityState => {\n              var _entityState$attribut7;\n              return ((_entityState$attribut7 = entityState.attributes) === null || _entityState$attribut7 === void 0 ? void 0 : _entityState$attribut7.action) === \"drying\";\n            });\n            addDataSet(`${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n              name: name\n            })}`);\n            if (hasCurrent) {\n              addDataSet(`${this.hass.localize(\"ui.card.humidifier.current_humidity_entity\", {\n                name: name\n              })}`);\n            }\n\n            // If action attribute is available, we used it to shade the area below the humidity.\n            // If action attribute is not available, we shade the area when the device is on\n            if (hasHumidifying) {\n              addDataSet(`${this.hass.localize(\"ui.card.humidifier.humidifying\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-humidifier-on-color\"));\n            } else if (hasDrying) {\n              addDataSet(`${this.hass.localize(\"ui.card.humidifier.drying\", {\n                name: name\n              })}`, true, computedStyles.getPropertyValue(\"--state-humidifier-on-color\"));\n            } else {\n              addDataSet(`${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n                name: name\n              })}`, true);\n            }\n            states.states.forEach(entityState => {\n              var _entityState$attribut8;\n              if (!entityState.attributes) return;\n              const target = safeParseFloat(entityState.attributes.humidity);\n              // If the current humidity is not available, then we fill up to the target humidity\n              const current = hasCurrent ? safeParseFloat((_entityState$attribut8 = entityState.attributes) === null || _entityState$attribut8 === void 0 ? void 0 : _entityState$attribut8.current_humidity) : target;\n              const series = [target];\n              if (hasCurrent) {\n                series.push(current);\n              }\n              if (hasHumidifying) {\n                var _entityState$attribut9;\n                series.push(((_entityState$attribut9 = entityState.attributes) === null || _entityState$attribut9 === void 0 ? void 0 : _entityState$attribut9.action) === \"humidifying\" ? current : null);\n              } else if (hasDrying) {\n                var _entityState$attribut10;\n                series.push(((_entityState$attribut10 = entityState.attributes) === null || _entityState$attribut10 === void 0 ? void 0 : _entityState$attribut10.action) === \"drying\" ? current : null);\n              } else {\n                series.push(entityState.state === \"on\" ? current : null);\n              }\n              pushData(new Date(entityState.last_changed), series);\n            });\n          } else {\n            addDataSet(name);\n            let lastValue;\n            let lastDate;\n            let lastNullDate = null;\n\n            // Process chart data.\n            // When state is `unknown`, calculate the value and break the line.\n            const processData = entityState => {\n              const value = safeParseFloat(entityState.state);\n              const date = new Date(entityState.last_changed);\n              if (value !== null && lastNullDate) {\n                var _lastDate;\n                const dateTime = date.getTime();\n                const lastNullDateTime = lastNullDate.getTime();\n                const lastDateTime = (_lastDate = lastDate) === null || _lastDate === void 0 ? void 0 : _lastDate.getTime();\n                const tmpValue = (value - lastValue) * ((lastNullDateTime - lastDateTime) / (dateTime - lastDateTime)) + lastValue;\n                pushData(lastNullDate, [tmpValue]);\n                pushData(new Date(lastNullDateTime + 1), [null]);\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n                lastNullDate = null;\n              } else if (value !== null && lastNullDate === null) {\n                pushData(date, [value]);\n                lastDate = date;\n                lastValue = value;\n              } else if (value === null && lastNullDate === null && lastValue !== undefined) {\n                lastNullDate = date;\n              }\n            };\n            if (states.statistics) {\n              const stopTime = !states.states || states.states.length === 0 ? 0 : states.states[0].last_changed;\n              for (let i = 0; i < states.statistics.length; i++) {\n                if (stopTime && states.statistics[i].last_changed >= stopTime) {\n                  break;\n                }\n                processData(states.statistics[i]);\n              }\n            }\n            states.states.forEach(entityState => {\n              processData(entityState);\n            });\n            if (lastNullDate !== null) {\n              pushData(lastNullDate, [null]);\n            }\n          }\n\n          // Add an entry for final values\n          pushData(endTime, prevValues);\n\n          // Concat two arrays\n          Array.prototype.push.apply(datasets, data);\n        });\n        this._chartData = {\n          datasets\n        };\n        this._entityIds = entityIds;\n        this._datasetToDataIndex = datasetToDataIndex;\n      }\n    }]\n  };\n}, LitElement);\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);","map":{"version":3,"names":["html","LitElement","property","query","state","getGraphColorByIndex","fireEvent","computeRTL","formatNumber","numberFormatToLocale","getNumberFormatOptions","MIN_TIME_BETWEEN_UPDATES","safeParseFloat","value","parsed","parseFloat","isFinite","StateHistoryChartLine","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","type","Boolean","Number","Date","options","_this$_chart","_chart","resize","render","hass","_chartData","_chartOptions","paddingYAxis","_yWidth","willUpdate","changedProps","hasUpdated","has","parsing","animation","interaction","mode","axis","scales","x","adapters","date","locale","config","suggestedMin","startTime","suggestedMax","endTime","ticks","maxRotation","sampleSize","autoSkipPadding","major","enabled","font","context","tick","weight","time","tooltipFormat","y","fitYData","minYAxis","maxYAxis","min","max","maxTicksLimit","title","display","text","unit","afterUpdate","Math","floor","width","chartIndex","position","logarithmicScale","plugins","tooltip","callbacks","label","dataset","undefined","entities","_entityIds","datasetIndex","dataIndex","_datasetToDataIndex","data","statistics","length","source","states","last_changed","localize","filler","propagate","legend","showNames","labels","usePointStyle","elements","line","tension","borderWidth","point","hitRadius","segment","borderColor","p0","datasets","onClick","e","clickForMoreInfo","native","MouseEvent","PointerEvent","pointerType","chart","points","getElementsAtEventForMode","intersect","firstPoint","entityId","canvas","dispatchEvent","Event","_chartTime","getTime","_generateData","colorIndex","computedStyles","getComputedStyle","entityStates","entityIds","datasetToDataIndex","names","forEach","dataIdx","domain","name","entity_id","prevValues","pushData","timestamp","datavalues","i","push","addDataSet","nameY","fill","color","backgroundColor","stepped","pointRadius","hasHvacAction","some","entityState","_entityState$attribut","attributes","hvac_action","isHeating","_entityState$attribut2","isCooling","_entityState$attribut3","hasHeat","hasCool","hasTargetRange","target_temp_high","target_temp_low","getPropertyValue","curTemp","current_temperature","series","targetHigh","targetLow","target","temperature","hasAction","_entityState$attribut4","action","hasCurrent","_entityState$attribut5","current_humidity","hasHumidifying","_entityState$attribut6","hasDrying","_entityState$attribut7","_entityState$attribut8","humidity","current","_entityState$attribut9","_entityState$attribut10","lastValue","lastDate","lastNullDate","processData","_lastDate","dateTime","lastNullDateTime","lastDateTime","tmpValue","stopTime","Array","prototype","apply","customElements","define"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/chart/state-history-chart-line.ts"],"sourcesContent":["import type { ChartData, ChartDataset, ChartOptions } from \"chart.js\";\nimport { html, LitElement, PropertyValues } from \"lit\";\nimport { property, query, state } from \"lit/decorators\";\nimport { getGraphColorByIndex } from \"../../common/color/colors\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeRTL } from \"../../common/util/compute_rtl\";\nimport {\n  formatNumber,\n  numberFormatToLocale,\n  getNumberFormatOptions,\n} from \"../../common/number/format_number\";\nimport { LineChartEntity, LineChartState } from \"../../data/history\";\nimport { HomeAssistant } from \"../../types\";\nimport {\n  ChartResizeOptions,\n  HaChartBase,\n  MIN_TIME_BETWEEN_UPDATES,\n} from \"./ha-chart-base\";\n\nconst safeParseFloat = (value) => {\n  const parsed = parseFloat(value);\n  return isFinite(parsed) ? parsed : null;\n};\n\nexport class StateHistoryChartLine extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public data: LineChartEntity[] = [];\n\n  @property({ attribute: false }) public names?: Record<string, string>;\n\n  @property() public unit?: string;\n\n  @property() public identifier?: string;\n\n  @property({ type: Boolean }) public showNames = true;\n\n  @property({ type: Boolean }) public clickForMoreInfo = true;\n\n  @property({ attribute: false }) public startTime!: Date;\n\n  @property({ attribute: false }) public endTime!: Date;\n\n  @property({ type: Number }) public paddingYAxis = 0;\n\n  @property({ type: Number }) public chartIndex?;\n\n  @property({ type: Boolean }) public logarithmicScale = false;\n\n  @property({ type: Number }) public minYAxis?: number;\n\n  @property({ type: Number }) public maxYAxis?: number;\n\n  @property({ type: Boolean }) public fitYData = false;\n\n  @state() private _chartData?: ChartData<\"line\">;\n\n  @state() private _entityIds: string[] = [];\n\n  private _datasetToDataIndex: number[] = [];\n\n  @state() private _chartOptions?: ChartOptions;\n\n  @state() private _yWidth = 0;\n\n  private _chartTime: Date = new Date();\n\n  @query(\"ha-chart-base\") private _chart?: HaChartBase;\n\n  public resize = (options?: ChartResizeOptions): void => {\n    this._chart?.resize(options);\n  };\n\n  protected render() {\n    return html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .paddingYAxis=${this.paddingYAxis - this._yWidth}\n        chart-type=\"line\"\n      ></ha-chart-base>\n    `;\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (\n      !this.hasUpdated ||\n      changedProps.has(\"showNames\") ||\n      changedProps.has(\"startTime\") ||\n      changedProps.has(\"endTime\") ||\n      changedProps.has(\"unit\") ||\n      changedProps.has(\"logarithmicScale\") ||\n      changedProps.has(\"minYAxis\") ||\n      changedProps.has(\"maxYAxis\") ||\n      changedProps.has(\"fitYData\")\n    ) {\n      this._chartOptions = {\n        parsing: false,\n        animation: false,\n        interaction: {\n          mode: \"nearest\",\n          axis: \"xy\",\n        },\n        scales: {\n          x: {\n            type: \"time\",\n            adapters: {\n              date: {\n                locale: this.hass.locale,\n                config: this.hass.config,\n              },\n            },\n            suggestedMin: this.startTime,\n            suggestedMax: this.endTime,\n            ticks: {\n              maxRotation: 0,\n              sampleSize: 5,\n              autoSkipPadding: 20,\n              major: {\n                enabled: true,\n              },\n              font: (context) =>\n                context.tick && context.tick.major\n                  ? ({ weight: \"bold\" } as any)\n                  : {},\n            },\n            time: {\n              tooltipFormat: \"datetimeseconds\",\n            },\n          },\n          y: {\n            suggestedMin: this.fitYData ? this.minYAxis : null,\n            suggestedMax: this.fitYData ? this.maxYAxis : null,\n            min: this.fitYData ? null : this.minYAxis,\n            max: this.fitYData ? null : this.maxYAxis,\n            ticks: {\n              maxTicksLimit: 7,\n            },\n            title: {\n              display: true,\n              text: this.unit,\n            },\n            afterUpdate: (y) => {\n              if (this._yWidth !== Math.floor(y.width)) {\n                this._yWidth = Math.floor(y.width);\n                fireEvent(this, \"y-width-changed\", {\n                  value: this._yWidth,\n                  chartIndex: this.chartIndex,\n                });\n              }\n            },\n            position: computeRTL(this.hass) ? \"right\" : \"left\",\n            type: this.logarithmicScale ? \"logarithmic\" : \"linear\",\n          },\n        },\n        plugins: {\n          tooltip: {\n            callbacks: {\n              label: (context) => {\n                let label = `${context.dataset.label}: ${formatNumber(\n                  context.parsed.y,\n                  this.hass.locale,\n                  getNumberFormatOptions(\n                    undefined,\n                    this.hass.entities[this._entityIds[context.datasetIndex]]\n                  )\n                )} ${this.unit}`;\n                const dataIndex =\n                  this._datasetToDataIndex[context.datasetIndex];\n                const data = this.data[dataIndex];\n                if (data.statistics && data.statistics.length > 0) {\n                  const source =\n                    data.states.length === 0 ||\n                    context.parsed.x < data.states[0].last_changed\n                      ? `\\n${this.hass.localize(\n                          \"ui.components.history_charts.source_stats\"\n                        )}`\n                      : `\\n${this.hass.localize(\n                          \"ui.components.history_charts.source_history\"\n                        )}`;\n                  label += source;\n                }\n                return label;\n              },\n            },\n          },\n          filler: {\n            propagate: true,\n          },\n          legend: {\n            display: this.showNames,\n            labels: {\n              usePointStyle: true,\n            },\n          },\n        },\n        elements: {\n          line: {\n            tension: 0.1,\n            borderWidth: 1.5,\n          },\n          point: {\n            hitRadius: 50,\n          },\n        },\n        segment: {\n          borderColor: (context) => {\n            // render stat data with a slightly transparent line\n            const dataIndex = this._datasetToDataIndex[context.datasetIndex];\n            const data = this.data[dataIndex];\n            return data.statistics &&\n              data.statistics.length > 0 &&\n              (data.states.length === 0 ||\n                context.p0.parsed.x < data.states[0].last_changed)\n              ? this._chartData!.datasets[dataIndex].borderColor + \"7F\"\n              : undefined;\n          },\n        },\n        // @ts-expect-error\n        locale: numberFormatToLocale(this.hass.locale),\n        onClick: (e: any) => {\n          if (\n            !this.clickForMoreInfo ||\n            !(e.native instanceof MouseEvent) ||\n            (e.native instanceof PointerEvent &&\n              e.native.pointerType !== \"mouse\")\n          ) {\n            return;\n          }\n\n          const chart = e.chart;\n\n          const points = chart.getElementsAtEventForMode(\n            e,\n            \"nearest\",\n            { intersect: true },\n            true\n          );\n\n          if (points.length) {\n            const firstPoint = points[0];\n            fireEvent(this, \"hass-more-info\", {\n              entityId: this._entityIds[firstPoint.datasetIndex],\n            });\n            chart.canvas.dispatchEvent(new Event(\"mouseout\")); // to hide tooltip\n          }\n        },\n      };\n    }\n    if (\n      changedProps.has(\"data\") ||\n      changedProps.has(\"startTime\") ||\n      changedProps.has(\"endTime\") ||\n      this._chartTime <\n        new Date(this.endTime.getTime() - MIN_TIME_BETWEEN_UPDATES)\n    ) {\n      // If the line is more than 5 minutes old, re-gen it\n      // so the X axis grows even if there is no new data\n      this._generateData();\n    }\n  }\n\n  private _generateData() {\n    let colorIndex = 0;\n    const computedStyles = getComputedStyle(this);\n    const entityStates = this.data;\n    const datasets: ChartDataset<\"line\">[] = [];\n    const entityIds: string[] = [];\n    const datasetToDataIndex: number[] = [];\n    if (entityStates.length === 0) {\n      return;\n    }\n\n    this._chartTime = new Date();\n    const endTime = this.endTime;\n    const names = this.names || {};\n    entityStates.forEach((states, dataIdx) => {\n      const domain = states.domain;\n      const name = names[states.entity_id] || states.name;\n      // array containing [value1, value2, etc]\n      let prevValues: any[] | null = null;\n\n      const data: ChartDataset<\"line\">[] = [];\n\n      const pushData = (timestamp: Date, datavalues: any[] | null) => {\n        if (!datavalues) return;\n        if (timestamp > endTime) {\n          // Drop data points that are after the requested endTime. This could happen if\n          // endTime is \"now\" and client time is not in sync with server time.\n          return;\n        }\n        data.forEach((d, i) => {\n          if (datavalues[i] === null && prevValues && prevValues[i] !== null) {\n            // null data values show up as gaps in the chart.\n            // If the current value for the dataset is null and the previous\n            // value of the data set is not null, then add an 'end' point\n            // to the chart for the previous value. Otherwise the gap will\n            // be too big. It will go from the start of the previous data\n            // value until the start of the next data value.\n            d.data.push({ x: timestamp.getTime(), y: prevValues[i] });\n          }\n          d.data.push({ x: timestamp.getTime(), y: datavalues[i] });\n        });\n        prevValues = datavalues;\n      };\n\n      const addDataSet = (nameY: string, fill = false, color?: string) => {\n        if (!color) {\n          color = getGraphColorByIndex(colorIndex, computedStyles);\n          colorIndex++;\n        }\n        data.push({\n          label: nameY,\n          fill: fill ? \"origin\" : false,\n          borderColor: color,\n          backgroundColor: color + \"7F\",\n          stepped: \"before\",\n          pointRadius: 0,\n          data: [],\n        });\n        entityIds.push(states.entity_id);\n        datasetToDataIndex.push(dataIdx);\n      };\n\n      if (\n        domain === \"thermostat\" ||\n        domain === \"climate\" ||\n        domain === \"water_heater\"\n      ) {\n        const hasHvacAction = states.states.some(\n          (entityState) => entityState.attributes?.hvac_action\n        );\n\n        const isHeating =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"heating\"\n            : (entityState: LineChartState) => entityState.state === \"heat\";\n        const isCooling =\n          domain === \"climate\" && hasHvacAction\n            ? (entityState: LineChartState) =>\n                entityState.attributes?.hvac_action === \"cooling\"\n            : (entityState: LineChartState) => entityState.state === \"cool\";\n\n        const hasHeat = states.states.some(isHeating);\n        const hasCool = states.states.some(isCooling);\n        // We differentiate between thermostats that have a target temperature\n        // range versus ones that have just a target temperature\n\n        // Using step chart by step-before so manually interpolation not needed.\n        const hasTargetRange = states.states.some(\n          (entityState) =>\n            entityState.attributes &&\n            entityState.attributes.target_temp_high !==\n              entityState.attributes.target_temp_low\n        );\n        addDataSet(\n          `${this.hass.localize(\"ui.card.climate.current_temperature\", {\n            name: name,\n          })}`\n        );\n        if (hasHeat) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.heating\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-heat-color\")\n          );\n          // The \"heating\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n        if (hasCool) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.cooling\", { name: name })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-climate-cool-color\")\n          );\n          // The \"cooling\" series uses steppedArea to shade the area below the current\n          // temperature when the thermostat is calling for heat.\n        }\n\n        if (hasTargetRange) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.high\"),\n            })}`\n          );\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_mode\", {\n              name: name,\n              mode: this.hass.localize(\"ui.card.climate.low\"),\n            })}`\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.climate.target_temperature_entity\", {\n              name: name,\n            })}`\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const curTemp = safeParseFloat(\n            entityState.attributes.current_temperature\n          );\n          const series = [curTemp];\n          if (hasHeat) {\n            series.push(isHeating(entityState) ? curTemp : null);\n          }\n          if (hasCool) {\n            series.push(isCooling(entityState) ? curTemp : null);\n          }\n          if (hasTargetRange) {\n            const targetHigh = safeParseFloat(\n              entityState.attributes.target_temp_high\n            );\n            const targetLow = safeParseFloat(\n              entityState.attributes.target_temp_low\n            );\n            series.push(targetHigh, targetLow);\n            pushData(new Date(entityState.last_changed), series);\n          } else {\n            const target = safeParseFloat(entityState.attributes.temperature);\n            series.push(target);\n            pushData(new Date(entityState.last_changed), series);\n          }\n        });\n      } else if (domain === \"humidifier\") {\n        const hasAction = states.states.some(\n          (entityState) => entityState.attributes?.action\n        );\n        const hasCurrent = states.states.some(\n          (entityState) => entityState.attributes?.current_humidity\n        );\n\n        const hasHumidifying =\n          hasAction &&\n          states.states.some(\n            (entityState: LineChartState) =>\n              entityState.attributes?.action === \"humidifying\"\n          );\n        const hasDrying =\n          hasAction &&\n          states.states.some(\n            (entityState: LineChartState) =>\n              entityState.attributes?.action === \"drying\"\n          );\n\n        addDataSet(\n          `${this.hass.localize(\"ui.card.humidifier.target_humidity_entity\", {\n            name: name,\n          })}`\n        );\n\n        if (hasCurrent) {\n          addDataSet(\n            `${this.hass.localize(\n              \"ui.card.humidifier.current_humidity_entity\",\n              {\n                name: name,\n              }\n            )}`\n          );\n        }\n\n        // If action attribute is available, we used it to shade the area below the humidity.\n        // If action attribute is not available, we shade the area when the device is on\n        if (hasHumidifying) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.humidifying\", {\n              name: name,\n            })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-humidifier-on-color\")\n          );\n        } else if (hasDrying) {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.drying\", {\n              name: name,\n            })}`,\n            true,\n            computedStyles.getPropertyValue(\"--state-humidifier-on-color\")\n          );\n        } else {\n          addDataSet(\n            `${this.hass.localize(\"ui.card.humidifier.on_entity\", {\n              name: name,\n            })}`,\n            true\n          );\n        }\n\n        states.states.forEach((entityState) => {\n          if (!entityState.attributes) return;\n          const target = safeParseFloat(entityState.attributes.humidity);\n          // If the current humidity is not available, then we fill up to the target humidity\n          const current = hasCurrent\n            ? safeParseFloat(entityState.attributes?.current_humidity)\n            : target;\n          const series = [target];\n\n          if (hasCurrent) {\n            series.push(current);\n          }\n\n          if (hasHumidifying) {\n            series.push(\n              entityState.attributes?.action === \"humidifying\" ? current : null\n            );\n          } else if (hasDrying) {\n            series.push(\n              entityState.attributes?.action === \"drying\" ? current : null\n            );\n          } else {\n            series.push(entityState.state === \"on\" ? current : null);\n          }\n          pushData(new Date(entityState.last_changed), series);\n        });\n      } else {\n        addDataSet(name);\n\n        let lastValue: number;\n        let lastDate: Date;\n        let lastNullDate: Date | null = null;\n\n        // Process chart data.\n        // When state is `unknown`, calculate the value and break the line.\n        const processData = (entityState: LineChartState) => {\n          const value = safeParseFloat(entityState.state);\n          const date = new Date(entityState.last_changed);\n          if (value !== null && lastNullDate) {\n            const dateTime = date.getTime();\n            const lastNullDateTime = lastNullDate.getTime();\n            const lastDateTime = lastDate?.getTime();\n            const tmpValue =\n              (value - lastValue) *\n                ((lastNullDateTime - lastDateTime) /\n                  (dateTime - lastDateTime)) +\n              lastValue;\n            pushData(lastNullDate, [tmpValue]);\n            pushData(new Date(lastNullDateTime + 1), [null]);\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n            lastNullDate = null;\n          } else if (value !== null && lastNullDate === null) {\n            pushData(date, [value]);\n            lastDate = date;\n            lastValue = value;\n          } else if (\n            value === null &&\n            lastNullDate === null &&\n            lastValue !== undefined\n          ) {\n            lastNullDate = date;\n          }\n        };\n\n        if (states.statistics) {\n          const stopTime =\n            !states.states || states.states.length === 0\n              ? 0\n              : states.states[0].last_changed;\n          for (let i = 0; i < states.statistics.length; i++) {\n            if (stopTime && states.statistics[i].last_changed >= stopTime) {\n              break;\n            }\n            processData(states.statistics[i]);\n          }\n        }\n        states.states.forEach((entityState) => {\n          processData(entityState);\n        });\n        if (lastNullDate !== null) {\n          pushData(lastNullDate, [null]);\n        }\n      }\n\n      // Add an entry for final values\n      pushData(endTime, prevValues);\n\n      // Concat two arrays\n      Array.prototype.push.apply(datasets, data);\n    });\n\n    this._chartData = {\n      datasets,\n    };\n    this._entityIds = entityIds;\n    this._datasetToDataIndex = datasetToDataIndex;\n  }\n}\ncustomElements.define(\"state-history-chart-line\", StateHistoryChartLine);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"state-history-chart-line\": StateHistoryChartLine;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}