{"ast":null,"code":"import _decorate from \"@babel/runtime/helpers/decorate\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { css, html, LitElement } from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { handleWebRtcOffer } from \"../data/camera\";\nimport { fetchWebRtcSettings } from \"../data/rtsp_to_webrtc\";\nimport \"./ha-alert\";\n\n/**\n * A WebRTC stream is established by first sending an offer through a signal\n * path via an integration. An answer is returned, then the rest of the stream\n * is handled entirely client side.\n */\nlet HaWebRtcPlayer = _decorate([customElement(\"ha-web-rtc-player\")], function (_initialize, _LitElement) {\n  class HaWebRtcPlayer extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: HaWebRtcPlayer,\n    d: [{\n      kind: \"field\",\n      decorators: [property({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"entityid\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"controls\"\n      })],\n      key: \"controls\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"muted\"\n      })],\n      key: \"muted\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"autoplay\"\n      })],\n      key: \"autoPlay\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property({\n        type: Boolean,\n        attribute: \"playsinline\"\n      })],\n      key: \"playsInline\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [property()],\n      key: \"posterUrl\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [state()],\n      key: \"_error\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [query(\"#remote-stream\")],\n      key: \"_videoEl\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_peerConnection\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_remoteStream\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value:\n      // don't cache this, as we remove it on disconnects\n\n      function render() {\n        if (this._error) {\n          return html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`;\n        }\n        return html`\n      <video\n        id=\"remote-stream\"\n        ?autoplay=${this.autoPlay}\n        .muted=${this.muted}\n        ?playsinline=${this.playsInline}\n        ?controls=${this.controls}\n        .poster=${this.posterUrl}\n        @loadeddata=${this._loadedData}\n      ></video>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"connectedCallback\",\n      value: function connectedCallback() {\n        _get(_getPrototypeOf(HaWebRtcPlayer.prototype), \"connectedCallback\", this).call(this);\n        if (this.hasUpdated) {\n          this._startWebRtc();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"disconnectedCallback\",\n      value: function disconnectedCallback() {\n        _get(_getPrototypeOf(HaWebRtcPlayer.prototype), \"disconnectedCallback\", this).call(this);\n        this._cleanUp();\n      }\n    }, {\n      kind: \"method\",\n      key: \"updated\",\n      value: function updated(changedProperties) {\n        if (!changedProperties.has(\"entityid\")) {\n          return;\n        }\n        if (!this._videoEl) {\n          return;\n        }\n        this._startWebRtc();\n      }\n    }, {\n      kind: \"method\",\n      key: \"_startWebRtc\",\n      value: async function _startWebRtc() {\n        this._error = undefined;\n        const configuration = await this._fetchPeerConfiguration();\n        const peerConnection = new RTCPeerConnection(configuration);\n        // Some cameras (such as nest) require a data channel to establish a stream\n        // however, not used by any integrations.\n        peerConnection.createDataChannel(\"dataSendChannel\");\n        peerConnection.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        });\n        peerConnection.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        });\n        const offerOptions = {\n          offerToReceiveAudio: true,\n          offerToReceiveVideo: true\n        };\n        const offer = await peerConnection.createOffer(offerOptions);\n        await peerConnection.setLocalDescription(offer);\n        let candidates = \"\"; // Build an Offer SDP string with ice candidates\n        const iceResolver = new Promise(resolve => {\n          peerConnection.addEventListener(\"icecandidate\", async event => {\n            if (!event.candidate) {\n              resolve(); // Gathering complete\n              return;\n            }\n            candidates += `a=${event.candidate.candidate}\\r\\n`;\n          });\n        });\n        await iceResolver;\n        const offer_sdp = offer.sdp + candidates;\n        let webRtcAnswer;\n        try {\n          webRtcAnswer = await handleWebRtcOffer(this.hass, this.entityid, offer_sdp);\n        } catch (err) {\n          this._error = \"Failed to start WebRTC stream: \" + err.message;\n          peerConnection.close();\n          return;\n        }\n\n        // Setup callbacks to render remote stream once media tracks are discovered.\n        const remoteStream = new MediaStream();\n        peerConnection.addEventListener(\"track\", event => {\n          remoteStream.addTrack(event.track);\n          this._videoEl.srcObject = remoteStream;\n        });\n        this._remoteStream = remoteStream;\n\n        // Initiate the stream with the remote device\n        const remoteDesc = new RTCSessionDescription({\n          type: \"answer\",\n          sdp: webRtcAnswer.answer\n        });\n        try {\n          await peerConnection.setRemoteDescription(remoteDesc);\n        } catch (err) {\n          this._error = \"Failed to connect WebRTC stream: \" + err.message;\n          peerConnection.close();\n          return;\n        }\n        this._peerConnection = peerConnection;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_fetchPeerConfiguration\",\n      value: async function _fetchPeerConfiguration() {\n        if (!isComponentLoaded(this.hass, \"rtsp_to_webrtc\")) {\n          return {};\n        }\n        const settings = await fetchWebRtcSettings(this.hass);\n        if (!settings || !settings.stun_server) {\n          return {};\n        }\n        return {\n          iceServers: [{\n            urls: [`stun:${settings.stun_server}`]\n          }]\n        };\n      }\n    }, {\n      kind: \"method\",\n      key: \"_cleanUp\",\n      value: function _cleanUp() {\n        if (this._remoteStream) {\n          this._remoteStream.getTracks().forEach(track => {\n            track.stop();\n          });\n          this._remoteStream = undefined;\n        }\n        if (this._videoEl) {\n          this._videoEl.removeAttribute(\"src\");\n          this._videoEl.load();\n        }\n        if (this._peerConnection) {\n          this._peerConnection.close();\n          this._peerConnection = undefined;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_loadedData\",\n      value: function _loadedData() {\n        // @ts-ignore\n        fireEvent(this, \"load\");\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n    `;\n      }\n    }]\n  };\n}, LitElement);","map":{"version":3,"names":["css","html","LitElement","customElement","property","state","query","isComponentLoaded","fireEvent","handleWebRtcOffer","fetchWebRtcSettings","HaWebRtcPlayer","_decorate","_initialize","_LitElement","constructor","args","F","d","kind","decorators","attribute","key","value","type","Boolean","render","_error","autoPlay","muted","playsInline","controls","posterUrl","_loadedData","connectedCallback","_get","_getPrototypeOf","prototype","call","hasUpdated","_startWebRtc","disconnectedCallback","_cleanUp","updated","changedProperties","has","_videoEl","undefined","configuration","_fetchPeerConfiguration","peerConnection","RTCPeerConnection","createDataChannel","addTransceiver","direction","offerOptions","offerToReceiveAudio","offerToReceiveVideo","offer","createOffer","setLocalDescription","candidates","iceResolver","Promise","resolve","addEventListener","event","candidate","offer_sdp","sdp","webRtcAnswer","hass","entityid","err","message","close","remoteStream","MediaStream","addTrack","track","srcObject","_remoteStream","remoteDesc","RTCSessionDescription","answer","setRemoteDescription","_peerConnection","settings","stun_server","iceServers","urls","getTracks","forEach","stop","removeAttribute","load","static","styles"],"sources":["/Users/sercanardil/Desktop/frontend/src/components/ha-web-rtc-player.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { handleWebRtcOffer, WebRtcAnswer } from \"../data/camera\";\nimport { fetchWebRtcSettings } from \"../data/rtsp_to_webrtc\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\n/**\n * A WebRTC stream is established by first sending an offer through a signal\n * path via an integration. An answer is returned, then the rest of the stream\n * is handled entirely client side.\n */\n@customElement(\"ha-web-rtc-player\")\nclass HaWebRtcPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public entityid!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @property() public posterUrl!: string;\n\n  @state() private _error?: string;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"#remote-stream\") private _videoEl!: HTMLVideoElement;\n\n  private _peerConnection?: RTCPeerConnection;\n\n  private _remoteStream?: MediaStream;\n\n  protected override render(): TemplateResult {\n    if (this._error) {\n      return html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`;\n    }\n    return html`\n      <video\n        id=\"remote-stream\"\n        ?autoplay=${this.autoPlay}\n        .muted=${this.muted}\n        ?playsinline=${this.playsInline}\n        ?controls=${this.controls}\n        .poster=${this.posterUrl}\n        @loadeddata=${this._loadedData}\n      ></video>\n    `;\n  }\n\n  public override connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._startWebRtc();\n    }\n  }\n\n  public override disconnectedCallback() {\n    super.disconnectedCallback();\n    this._cleanUp();\n  }\n\n  protected override updated(changedProperties: PropertyValues<this>) {\n    if (!changedProperties.has(\"entityid\")) {\n      return;\n    }\n    if (!this._videoEl) {\n      return;\n    }\n    this._startWebRtc();\n  }\n\n  private async _startWebRtc(): Promise<void> {\n    this._error = undefined;\n\n    const configuration = await this._fetchPeerConfiguration();\n    const peerConnection = new RTCPeerConnection(configuration);\n    // Some cameras (such as nest) require a data channel to establish a stream\n    // however, not used by any integrations.\n    peerConnection.createDataChannel(\"dataSendChannel\");\n    peerConnection.addTransceiver(\"audio\", { direction: \"recvonly\" });\n    peerConnection.addTransceiver(\"video\", { direction: \"recvonly\" });\n\n    const offerOptions: RTCOfferOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true,\n    };\n    const offer: RTCSessionDescriptionInit =\n      await peerConnection.createOffer(offerOptions);\n    await peerConnection.setLocalDescription(offer);\n\n    let candidates = \"\"; // Build an Offer SDP string with ice candidates\n    const iceResolver = new Promise<void>((resolve) => {\n      peerConnection.addEventListener(\"icecandidate\", async (event) => {\n        if (!event.candidate) {\n          resolve(); // Gathering complete\n          return;\n        }\n        candidates += `a=${event.candidate.candidate}\\r\\n`;\n      });\n    });\n    await iceResolver;\n    const offer_sdp = offer.sdp! + candidates;\n\n    let webRtcAnswer: WebRtcAnswer;\n    try {\n      webRtcAnswer = await handleWebRtcOffer(\n        this.hass,\n        this.entityid,\n        offer_sdp\n      );\n    } catch (err: any) {\n      this._error = \"Failed to start WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n\n    // Setup callbacks to render remote stream once media tracks are discovered.\n    const remoteStream = new MediaStream();\n    peerConnection.addEventListener(\"track\", (event) => {\n      remoteStream.addTrack(event.track);\n      this._videoEl.srcObject = remoteStream;\n    });\n    this._remoteStream = remoteStream;\n\n    // Initiate the stream with the remote device\n    const remoteDesc = new RTCSessionDescription({\n      type: \"answer\",\n      sdp: webRtcAnswer.answer,\n    });\n    try {\n      await peerConnection.setRemoteDescription(remoteDesc);\n    } catch (err: any) {\n      this._error = \"Failed to connect WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n    this._peerConnection = peerConnection;\n  }\n\n  private async _fetchPeerConfiguration(): Promise<RTCConfiguration> {\n    if (!isComponentLoaded(this.hass!, \"rtsp_to_webrtc\")) {\n      return {};\n    }\n    const settings = await fetchWebRtcSettings(this.hass!);\n    if (!settings || !settings.stun_server) {\n      return {};\n    }\n    return {\n      iceServers: [\n        {\n          urls: [`stun:${settings.stun_server!}`],\n        },\n      ],\n    };\n  }\n\n  private _cleanUp() {\n    if (this._remoteStream) {\n      this._remoteStream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      this._remoteStream = undefined;\n    }\n    if (this._videoEl) {\n      this._videoEl.removeAttribute(\"src\");\n      this._videoEl.load();\n    }\n    if (this._peerConnection) {\n      this._peerConnection.close();\n      this._peerConnection = undefined;\n    }\n  }\n\n  private _loadedData() {\n    // @ts-ignore\n    fireEvent(this, \"load\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-web-rtc-player\": HaWebRtcPlayer;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}