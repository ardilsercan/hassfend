{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _regeneratorRuntime from \"@babel/runtime/helpers/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/asyncIterator\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport var forAwaitOf = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(iterable, callback) {\n    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, v;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context.prev = 2;\n          _iterator = _asyncIterator(iterable);\n        case 4:\n          _context.next = 6;\n          return _iterator.next();\n        case 6:\n          if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n            _context.next = 16;\n            break;\n          }\n          v = _step.value;\n          _context.next = 10;\n          return callback(v);\n        case 10:\n          _context.t0 = _context.sent;\n          if (!(_context.t0 === false)) {\n            _context.next = 13;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 13:\n          _iteratorAbruptCompletion = false;\n          _context.next = 4;\n          break;\n        case 16:\n          _context.next = 22;\n          break;\n        case 18:\n          _context.prev = 18;\n          _context.t1 = _context[\"catch\"](2);\n          _didIteratorError = true;\n          _iteratorError = _context.t1;\n        case 22:\n          _context.prev = 22;\n          _context.prev = 23;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context.next = 27;\n            break;\n          }\n          _context.next = 27;\n          return _iterator.return();\n        case 27:\n          _context.prev = 27;\n          if (!_didIteratorError) {\n            _context.next = 30;\n            break;\n          }\n          throw _iteratorError;\n        case 30:\n          return _context.finish(27);\n        case 31:\n          return _context.finish(22);\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[2, 18, 22, 32], [23,, 27, 31]]);\n  }));\n  return function forAwaitOf(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport var PseudoWeakRef = /*#__PURE__*/function () {\n  function PseudoWeakRef(ref) {\n    _classCallCheck(this, PseudoWeakRef);\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  _createClass(PseudoWeakRef, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this._ref = undefined;\n    }\n    /**\n     * Reassociates the ref with the backing instance.\n     */\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(ref) {\n      this._ref = ref;\n    }\n    /**\n     * Retrieves the backing instance (will be undefined when disconnected)\n     */\n  }, {\n    key: \"deref\",\n    value: function deref() {\n      return this._ref;\n    }\n  }]);\n  return PseudoWeakRef;\n}();\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport var Pauser = /*#__PURE__*/function () {\n  function Pauser() {\n    _classCallCheck(this, Pauser);\n    this._promise = undefined;\n    this._resolve = undefined;\n  }\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  _createClass(Pauser, [{\n    key: \"get\",\n    value: function get() {\n      return this._promise;\n    }\n    /**\n     * Creates a promise to be awaited\n     */\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _this = this;\n      var _a;\n      (_a = this._promise) !== null && _a !== void 0 ? _a : this._promise = new Promise(function (resolve) {\n        return _this._resolve = resolve;\n      });\n    }\n    /**\n     * Resolves the promise which may be awaited\n     */\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      var _a;\n      (_a = this._resolve) === null || _a === void 0 ? void 0 : _a.call(this);\n      this._promise = this._resolve = undefined;\n    }\n  }]);\n  return Pauser;\n}();","map":{"version":3,"names":["forAwaitOf","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","iterable","callback","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","v","wrap","_callee$","_context","prev","next","_asyncIterator","sent","done","value","t0","abrupt","t1","return","finish","stop","_x","_x2","apply","arguments","PseudoWeakRef","ref","_classCallCheck","_createClass","key","disconnect","undefined","reconnect","deref","Pauser","_promise","_resolve","get","pause","_this","_a","Promise","resolve","resume","call"],"sources":["../../src/directives/private-async-helpers.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async <T>(\n  iterable: AsyncIterable<T>,\n  callback: (value: T) => Promise<boolean>\n) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef<T> {\n  private _ref?: T;\n  constructor(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n  reconnect(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n  deref() {\n    return this._ref;\n  }\n}\n\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n  private _promise?: Promise<void> = undefined;\n  private _resolve?: () => void = undefined;\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n  pause() {\n    this._promise ??= new Promise((resolve) => (this._resolve = resolve));\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n  resume() {\n    this._resolve?.();\n    this._promise = this._resolve = undefined;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}