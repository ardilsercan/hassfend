import type { Plugin, WebSocketsManager, Logger, WebSocketData, ServerStartParams, DevServerCoreConfig } from '@web/dev-server-core';
import WebSocket from 'ws';
import type { Context } from 'koa';
export interface HmrReloadMessage {
    type: 'hmr:reload';
}
export interface HmrUpdateMessage {
    type: 'hmr:update';
    url: string;
}
export interface HmrModuleOptions {
    bubbles: boolean;
}
export interface HmrAcceptMessage extends WebSocketData {
    type: 'hmr:accept';
    id: string;
    options?: Partial<HmrModuleOptions>;
}
export declare type HmrMessage = HmrReloadMessage | HmrUpdateMessage;
export declare type HmrClientMessage = HmrAcceptMessage;
export interface HmrModule {
    dependencies: Set<string>;
    dependents: Set<string>;
    hmrAccepted: boolean;
    hmrEnabled: boolean;
    options?: Partial<HmrModuleOptions>;
    needsReplacement: boolean;
    replacementRequests: number;
}
export declare const NAME_HMR_CLIENT_IMPORT = "/__web-dev-server__/hmr.js";
/**
 * Dev server plugin to provide hot module reloading
 */
export declare class HmrPlugin implements Plugin {
    name: string;
    injectWebSocket: boolean;
    protected _dependencyTree: Map<string, HmrModule>;
    protected _webSockets?: WebSocketsManager;
    protected _logger?: Logger;
    protected _config?: DevServerCoreConfig;
    /** @inheritDoc */
    serverStart({ webSockets, fileWatcher, logger, config }: ServerStartParams): Promise<void>;
    /** @inheritDoc */
    serve(context: Context): Promise<string | undefined>;
    resolveImport({ source }: {
        source: string;
    }): "/__web-dev-server__/hmr.js" | undefined;
    transformCacheKey(context: Context): string | undefined;
    /** @inheritDoc */
    transformImport({ source, context }: {
        source: string;
        context: Context;
    }): Promise<string | undefined>;
    /** @inheritDoc */
    transform(context: Context): Promise<string | undefined>;
    /**
     * Clears the dependency cache/tree of a particular module
     * @param path Module path to clear
     */
    protected _clearDependencies(path: string): void;
    /** @inheritDoc */
    serverStop(): void;
    /**
     * Fired when a file has changed.
     * @param path Module path which has changed
     */
    protected _onFileChanged(filePath: string): void;
    /**
     * Triggers an update for a given module.
     * This will result in the client being sent a message to tell them
     * how to deal with this module updating.
     * @param path Module path to update
     * @param visited Modules already updated (cache)
     */
    protected _triggerUpdate(path: string, visited?: Set<string>): void;
    private _setNeedsReplacement;
    /**
     * Broadcasts a HMR message to the client
     * @param message HMR message to emit
     */
    protected _broadcast(message: HmrMessage): void;
    /**
     * Determines if the dependency tree already has a given module
     * @param path Module path to check
     */
    protected _hasModule(path: string): boolean;
    /**
     * Fired when a message is received from a client
     * @param socket Socket the message was received on
     * @param message Message received
     */
    protected _onMessage(socket: WebSocket, data: WebSocketData): void;
    /**
     * Retrieves a module from the cache and creates it if it does not
     * exist already.
     * @param path Module path to retrieve
     */
    protected _getOrCreateModule(path: string): HmrModule;
    /**
     * Retrieves a module from the cache if it exists
     * @param path Module path to retrieve
     */
    protected _getModule(path: string): HmrModule | null;
    /**
     * Creates a module and initialises the dependency tree cache entry
     * for it.
     * @param path Module path to create an entry for
     */
    protected _createModule(path: string): HmrModule;
}
//# sourceMappingURL=HmrPlugin.d.ts.map