"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HmrPlugin = exports.NAME_HMR_CLIENT_IMPORT = void 0;
const path_1 = __importStar(require("path"));
const fs_1 = __importDefault(require("fs"));
const hmrClientScriptPath = require.resolve('../scripts/hmrClientScript.js');
let hmrClientScript = fs_1.default.readFileSync(hmrClientScriptPath, 'utf-8');
exports.NAME_HMR_CLIENT_IMPORT = '/__web-dev-server__/hmr.js';
/**
 * Dev server plugin to provide hot module reloading
 */
class HmrPlugin {
    constructor() {
        this.name = 'hmr';
        this.injectWebSocket = true;
        this._dependencyTree = new Map();
    }
    /** @inheritDoc */
    async serverStart({ webSockets, fileWatcher, logger, config }) {
        var _a;
        if (!fileWatcher) {
            throw new Error('Cannot use HMR when watch mode is disabled.');
        }
        if (!webSockets) {
            throw new Error('Cannot use HMR when web sockets are disabled.');
        }
        hmrClientScript = hmrClientScript.replace('__WEBSOCKET_IMPORT__', webSockets.webSocketImport);
        this._config = config;
        this._webSockets = webSockets;
        this._logger = logger;
        webSockets.on('message', ({ webSocket, data }) => this._onMessage(webSocket, data));
        fileWatcher.on('change', path => this._onFileChanged(path));
        fileWatcher.on('unlink', path => this._onFileChanged(path));
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug('[hmr] Listening for HMR messages');
    }
    /** @inheritDoc */
    async serve(context) {
        // Someone is requesting the injected client script
        if (context.path === exports.NAME_HMR_CLIENT_IMPORT) {
            if (!this._webSockets) {
                return;
            }
            return hmrClientScript;
        }
    }
    resolveImport({ source }) {
        if (source === '/__web-dev-server__/hmr.js') {
            return source;
        }
    }
    transformCacheKey(context) {
        var _a;
        const mod = this._getOrCreateModule(context.path);
        if (mod.needsReplacement) {
            const marker = (_a = context.URL.searchParams.get('m')) !== null && _a !== void 0 ? _a : Date.now();
            return `${context.path}${marker}`;
        }
    }
    /** @inheritDoc */
    async transformImport({ source, context }) {
        var _a, _b;
        if (source.startsWith('/__web-dev-server__') ||
            context.path.startsWith('/__web-dev-server__')) {
            return source;
        }
        const importPath = path_1.posix.resolve(path_1.posix.dirname(context.path), source);
        const mod = this._getOrCreateModule(context.path);
        const dependencyMod = this._getOrCreateModule(importPath);
        mod.dependencies.add(importPath);
        dependencyMod.dependents.add(context.path);
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`[hmr] Added dependency from ${context.path} -> ${importPath}`);
        if (dependencyMod.needsReplacement) {
            const marker = (_b = context.URL.searchParams.get('m')) !== null && _b !== void 0 ? _b : Date.now();
            const divider = source.includes('?') ? '&' : '?';
            return `${source}${divider}m=${marker}`;
        }
    }
    /** @inheritDoc */
    async transform(context) {
        var _a;
        // Don't want to handle the hmr plugin itself
        if (context.path === exports.NAME_HMR_CLIENT_IMPORT) {
            return;
        }
        // If the module references import.meta.hot it can be assumed it
        // supports hot reloading
        const hmrEnabled = context.body.includes('import.meta.hot') === true;
        const mod = this._getOrCreateModule(context.path);
        mod.hmrEnabled = hmrEnabled;
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`[hmr] Setting hmrEnabled=${hmrEnabled} for ${context.path}`);
        if (context.URL.searchParams.has('m')) {
            this._setNeedsReplacement(context.path, mod, false);
        }
        if (hmrEnabled && context.response.is('js')) {
            return (`import {create as __WDS_HMR__} from '${exports.NAME_HMR_CLIENT_IMPORT}';` +
                'import.meta.hot = __WDS_HMR__(import.meta.url);' +
                context.body);
        }
    }
    /**
     * Clears the dependency cache/tree of a particular module
     * @param path Module path to clear
     */
    _clearDependencies(path) {
        const mod = this._getModule(path);
        if (!mod) {
            return;
        }
        for (const dep of mod.dependencies) {
            const depMod = this._getModule(dep);
            if (depMod) {
                depMod.dependents.delete(path);
            }
        }
        mod.dependencies = new Set();
    }
    /** @inheritDoc */
    serverStop() {
        this._webSockets = undefined;
    }
    /**
     * Fired when a file has changed.
     * @param path Module path which has changed
     */
    _onFileChanged(filePath) {
        var _a;
        if (!((_a = this._config) === null || _a === void 0 ? void 0 : _a.rootDir)) {
            return;
        }
        const relativePath = path_1.default.relative(this._config.rootDir, filePath);
        const browserPath = relativePath.split(path_1.default.sep).join('/');
        this._triggerUpdate(`/${browserPath}`);
    }
    /**
     * Triggers an update for a given module.
     * This will result in the client being sent a message to tell them
     * how to deal with this module updating.
     * @param path Module path to update
     * @param visited Modules already updated (cache)
     */
    _triggerUpdate(path, visited = new Set()) {
        var _a, _b;
        // We already visited this module
        if (visited.has(path)) {
            return;
        }
        const mod = this._getModule(path);
        visited.add(path);
        this._clearDependencies(path);
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`[hmr] Cleared dependency tree cache of ${path}`);
        // We're not aware of this module so can't handle it
        if (!mod) {
            this._broadcast({ type: 'hmr:reload' });
            return;
        }
        this._setNeedsReplacement(path, mod, true);
        const dependents = new Set(mod.dependents);
        // The module supports HMR so lets tell it to update
        if (mod.hmrEnabled) {
            this._broadcast({ type: 'hmr:update', url: path });
        }
        if (((_b = mod.options) === null || _b === void 0 ? void 0 : _b.bubbles) || !mod.hmrEnabled) {
            // Trigger an update for every module that depends on this one
            for (const dep of dependents) {
                this._triggerUpdate(dep, visited);
            }
        }
        // If this module doesn't support HMR and it has no dependents,
        // nothing will handle this. So we must reload.
        if (!mod.hmrEnabled && dependents.size === 0) {
            this._broadcast({ type: 'hmr:reload' });
        }
    }
    _setNeedsReplacement(path, module, needsReplacement) {
        if (needsReplacement) {
            module.replacementRequests += 1;
        }
        else {
            module.replacementRequests = Math.max(0, module.replacementRequests - 1);
        }
        module.needsReplacement = module.replacementRequests > 0;
    }
    /**
     * Broadcasts a HMR message to the client
     * @param message HMR message to emit
     */
    _broadcast(message) {
        var _a;
        if (!this._webSockets) {
            return;
        }
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.debug(`[hmr] emitting ${message.type} message`);
        this._webSockets.send(JSON.stringify(message));
    }
    /**
     * Determines if the dependency tree already has a given module
     * @param path Module path to check
     */
    _hasModule(path) {
        return this._dependencyTree.has(path);
    }
    /**
     * Fired when a message is received from a client
     * @param socket Socket the message was received on
     * @param message Message received
     */
    _onMessage(socket, data) {
        const message = data;
        // Only handle HMR requests
        if (!message.type.startsWith('hmr:')) {
            return;
        }
        if (message.type === 'hmr:accept') {
            const mod = this._getOrCreateModule(message.id);
            mod.options = message.options;
            mod.hmrAccepted = true;
            mod.hmrEnabled = true;
        }
    }
    /**
     * Retrieves a module from the cache and creates it if it does not
     * exist already.
     * @param path Module path to retrieve
     */
    _getOrCreateModule(path) {
        // TODO (43081j): some kind of normalisation of the paths?
        const mod = this._getModule(path);
        return mod !== null && mod !== void 0 ? mod : this._createModule(path);
    }
    /**
     * Retrieves a module from the cache if it exists
     * @param path Module path to retrieve
     */
    _getModule(path) {
        const mod = this._dependencyTree.get(path);
        return mod !== null && mod !== void 0 ? mod : null;
    }
    /**
     * Creates a module and initialises the dependency tree cache entry
     * for it.
     * @param path Module path to create an entry for
     */
    _createModule(path) {
        const mod = {
            hmrAccepted: false,
            hmrEnabled: false,
            dependencies: new Set(),
            dependents: new Set(),
            needsReplacement: false,
            replacementRequests: 0,
        };
        this._dependencyTree.set(path, mod);
        return mod;
    }
}
exports.HmrPlugin = HmrPlugin;
//# sourceMappingURL=HmrPlugin.js.map