"use strict";
/**
 * @fileoverview Enforces that custom element classes are exposed on the
 * global object (i.e. `window`)
 * @author James Garbutt <https://github.com/43081j>
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const ast_1 = require("../util/ast");
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const rule = {
    meta: {
        docs: {
            description: 'Enforces that custom element classes are exposed on the ' +
                'global object (i.e. window)',
            url: 'https://github.com/43081j/eslint-plugin-wc/blob/master/docs/rules/expose-class-on-global.md'
        },
        messages: {
            expose: 'Custom element classes should be exposed on the global ' +
                'object (i.e. window)',
            sameName: 'The exposed global name should match that of the ' +
                'custom element class'
        }
    },
    create(context) {
        const seenClasses = new Set();
        const source = context.getSourceCode();
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        const globalNames = new Set(['window', 'globalThis']);
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        return {
            'ClassDeclaration,ClassExpression': (node) => {
                if ((0, util_1.isCustomElement)(context, node, source.getJSDocComment(node))) {
                    seenClasses.add(node);
                }
            },
            'AssignmentExpression:exit': (node) => {
                if (node.left.type === 'MemberExpression' &&
                    node.left.object.type === 'Identifier' &&
                    globalNames.has(node.left.object.name) &&
                    node.left.property.type === 'Identifier' &&
                    (node.right.type === 'Identifier' ||
                        node.right.type === 'ClassExpression')) {
                    const classDef = (0, ast_1.resolveReference)(node.right, context);
                    if (classDef &&
                        seenClasses.has(classDef) &&
                        (classDef.type === 'ClassExpression' ||
                            classDef.type === 'ClassDeclaration')) {
                        seenClasses.delete(classDef);
                        if (classDef.id?.name !== node.left.property.name) {
                            context.report({
                                node,
                                messageId: 'sameName'
                            });
                        }
                    }
                }
            },
            'Program:exit': () => {
                for (const node of seenClasses) {
                    context.report({
                        node,
                        messageId: 'expose'
                    });
                }
                seenClasses.clear();
            }
        };
    }
};
exports.default = rule;
