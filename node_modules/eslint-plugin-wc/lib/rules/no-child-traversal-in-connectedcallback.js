"use strict";
/**
 * @fileoverview Disallows traversal of children in the
 * `connectedCallback` method
 * @author James Garbutt <https://github.com/43081j>
 * @author Keith Cirkel <https://github.com/keithamus>
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const dom_1 = require("../util/dom");
const allowedScopes = new Set(['addEventListener', 'MutationObserver']);
/**
 * Determines if a scope should allow child traversal
 * @param {Rule.Scope.Scope} scope Scope to test
 * @return {boolean}
 */
function isAllowedScope(scope) {
    if (scope.type !== 'function') {
        return false;
    }
    const blockNode = scope.block;
    if (!blockNode.parent) {
        return false;
    }
    const parentNode = blockNode.parent;
    if (parentNode.type !== 'CallExpression' &&
        parentNode.type !== 'NewExpression') {
        return false;
    }
    if (parentNode.callee.type === 'MemberExpression' &&
        parentNode.callee.property.type === 'Identifier' &&
        allowedScopes.has(parentNode.callee.property.name)) {
        return true;
    }
    if (parentNode.callee.type === 'Identifier' &&
        allowedScopes.has(parentNode.callee.name)) {
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const rule = {
    meta: {
        docs: {
            description: 'Disallows traversal of children in the ' +
                '`connectedCallback` method',
            url: 'https://github.com/43081j/eslint-plugin-wc/blob/master/docs/rules/no-child-traversal-in-connectedcallback.md'
        },
        messages: {
            domMethod: 'Traversing children in the `connectedCallback` ' +
                'method is error prone and should be avoided',
            domProp: 'Accessing local DOM properties in the ' +
                '`connectedCallback` method is error prone and should be avoided'
        }
    },
    create(context) {
        // variables should be defined here
        let insideCallback = false;
        let insideElement = false;
        const source = context.getSourceCode();
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        return {
            'ClassDeclaration,ClassExpression': (node) => {
                if ((0, util_1.isCustomElement)(context, node, source.getJSDocComment(node))) {
                    insideElement = true;
                }
            },
            'ClassDeclaration,ClassExpression:exit': () => {
                insideElement = false;
            },
            MethodDefinition: (node) => {
                if (insideElement &&
                    !node.static &&
                    node.key.type === 'Identifier' &&
                    node.key.name === 'connectedCallback') {
                    insideCallback = true;
                }
            },
            'MethodDefinition:exit': () => {
                insideCallback = false;
            },
            MemberExpression: (node) => {
                if (!insideCallback) {
                    return;
                }
                if (node.property.type !== 'Identifier') {
                    // Don't bother with expressions that have funky properties
                    return;
                }
                const parentNode = node.parent;
                if (parentNode.type === 'AssignmentExpression') {
                    // Allow things like textContent/innerHTML assignments
                    return;
                }
                const scope = context.getScope();
                const name = node.property.name;
                if (isAllowedScope(scope)) {
                    // some scopes, like event handlers, are fine
                    return;
                }
                if (!(0, dom_1.isThisOrShadowRoot)(node.object)) {
                    // Only look for `this.*` or `this.shadowRoot.*`
                    return;
                }
                if (dom_1.childPropertyList.has(name)) {
                    context.report({
                        node,
                        messageId: 'domProp'
                    });
                }
                if (parentNode.type === 'CallExpression' &&
                    parentNode.callee === node &&
                    dom_1.childMethodList.has(name)) {
                    context.report({
                        node,
                        messageId: 'domMethod'
                    });
                }
            }
        };
    }
};
exports.default = rule;
