import * as ESTree from 'estree';
import { Rule } from 'eslint';
export interface DecoratorNode extends ESTree.BaseNode {
    type: 'Decorator';
    expression: ESTree.Expression;
}
export type WithDecorators<T extends ESTree.Node> = T & {
    decorators?: DecoratorNode[];
};
/**
 * Determines if a given decorator is the `@customElement` decorator
 *
 * @param {DecoratorNode} node Decorator to test
 * @return {boolean}
 */
export declare function isCustomElementDecorator(node: DecoratorNode): boolean;
/**
 * Retrieves the configured element base class list
 *
 * @param {Rule.RuleContext} context ESLint rule context
 * @return {string[]}
 */
export declare function getElementBaseClasses(context: Rule.RuleContext): string[];
/**
 * Determines if a node is an element class or not.
 *
 * @param {Rule.RuleContext} context ESLint rule context
 * @param {ESTree.Class} node Node to test
 * @param {AST.Token=} jsdoc JSDoc to parse
 * @return {boolean}
 */
export declare function isCustomElement(context: Rule.RuleContext, node: ESTree.Class, jsdoc?: ESTree.Comment | null): boolean;
/**
 * Determines if a node is an extension of HTMLElement class or not.
 *
 * @param {ESTree.Class} node Node to test
 * @return {boolean}
 */
export declare function isNativeCustomElement(node: ESTree.Class): boolean;
/**
 * Converts a literal-or-array value to an array value
 * @param {unknown} val Value to convert
 * @return {Array<unknown>}
 */
export declare function coerceArray<T>(val: T | T[]): T[];
