"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coerceArray = exports.isNativeCustomElement = exports.isCustomElement = exports.getElementBaseClasses = exports.isCustomElementDecorator = void 0;
const customElementsCache = new WeakMap();
/**
 * Determines if a given decorator is the `@customElement` decorator
 *
 * @param {DecoratorNode} node Decorator to test
 * @return {boolean}
 */
function isCustomElementDecorator(node) {
    return ((node.expression.type === 'CallExpression' &&
        node.expression.callee.type === 'Identifier' &&
        node.expression.callee.name === 'customElement') ||
        (node.expression.type === 'Identifier' &&
            node.expression.name === 'customElement'));
}
exports.isCustomElementDecorator = isCustomElementDecorator;
const knownModuleBaseClasses = new Map([
    ['lit', new Set(['LitElement'])]
]);
/**
 * Retrieves the configured element base class list
 *
 * @param {Rule.RuleContext} context ESLint rule context
 * @return {string[]}
 */
function getElementBaseClasses(context) {
    const bases = new Set(['HTMLElement']);
    for (const [moduleName, moduleClasses] of knownModuleBaseClasses) {
        try {
            require.resolve(moduleName, { paths: [context.cwd] });
            for (const moduleClass of moduleClasses) {
                bases.add(moduleClass);
            }
        }
        catch (_err) {
            // do nothing, lit didn't exist
        }
    }
    if (Array.isArray(context.settings.wc?.elementBaseClasses)) {
        const configuredBases = context.settings.wc.elementBaseClasses;
        for (const base of configuredBases) {
            bases.add(base);
        }
    }
    return [...bases];
}
exports.getElementBaseClasses = getElementBaseClasses;
/**
 * Determines if a node is an element class or not.
 *
 * @param {Rule.RuleContext} context ESLint rule context
 * @param {ESTree.Class} node Node to test
 * @param {AST.Token=} jsdoc JSDoc to parse
 * @return {boolean}
 */
function isCustomElement(context, node, jsdoc) {
    const asDecorated = node;
    const customElementBases = getElementBaseClasses(context);
    const cached = customElementsCache.get(node);
    if (cached !== undefined) {
        return cached;
    }
    if (node.superClass?.type === 'Identifier' &&
        customElementBases.includes(node.superClass.name)) {
        customElementsCache.set(node, true);
        return true;
    }
    if (jsdoc?.value.includes('@customElement')) {
        customElementsCache.set(node, true);
        return true;
    }
    if (asDecorated.decorators?.some(isCustomElementDecorator)) {
        customElementsCache.set(node, true);
        return true;
    }
    customElementsCache.set(node, false);
    return false;
}
exports.isCustomElement = isCustomElement;
/**
 * Determines if a node is an extension of HTMLElement class or not.
 *
 * @param {ESTree.Class} node Node to test
 * @return {boolean}
 */
function isNativeCustomElement(node) {
    return (node.superClass?.type === 'Identifier' &&
        node.superClass.name === 'HTMLElement');
}
exports.isNativeCustomElement = isNativeCustomElement;
/**
 * Converts a literal-or-array value to an array value
 * @param {unknown} val Value to convert
 * @return {Array<unknown>}
 */
function coerceArray(val) {
    return Array.isArray(val) ? val : [val];
}
exports.coerceArray = coerceArray;
