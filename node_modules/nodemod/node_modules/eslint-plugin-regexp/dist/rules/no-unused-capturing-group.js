"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const ast_utils_1 = require("../utils/ast-utils");
const type_tracker_1 = require("../utils/type-tracker");
const replacements_utils_1 = require("../utils/replacements-utils");
class CapturingData {
    constructor(regexpContext) {
        this.unused = new Set();
        this.unusedNames = new Map();
        this.indexToCapturingGroup = new Map();
        this.countOfCapturingGroup = 0;
        this.state = {
            used: false,
            track: true,
        };
        this.regexpContext = regexpContext;
    }
    getUnused() {
        const unusedCapturingGroups = new Set(this.unused);
        const unusedNames = new Set();
        for (const cgNodes of this.unusedNames.values()) {
            for (const cgNode of cgNodes) {
                if (!unusedCapturingGroups.has(cgNode)) {
                    unusedNames.add(cgNode);
                }
            }
        }
        return {
            unusedCapturingGroups,
            unusedNames,
        };
    }
    usedIndex(ref) {
        const cgNode = this.indexToCapturingGroup.get(ref);
        if (cgNode) {
            this.unused.delete(cgNode);
        }
    }
    usedName(ref) {
        const cgNodes = this.unusedNames.get(ref);
        if (cgNodes) {
            this.unusedNames.delete(ref);
            for (const cgNode of cgNodes) {
                this.unused.delete(cgNode);
            }
        }
    }
    usedAllNames() {
        for (const cgNodes of this.unusedNames.values()) {
            for (const cgNode of cgNodes) {
                this.unused.delete(cgNode);
            }
        }
        this.unusedNames.clear();
    }
    usedAllUnnamed() {
        this.unused.clear();
    }
    isAllUsed() {
        return !this.unused.size && !this.unusedNames.size;
    }
    markAsUsed() {
        this.state.used = true;
    }
    markAsCannotTrack() {
        this.state.track = false;
    }
    isNeedReport() {
        return this.state.used && this.state.track && !this.isAllUsed();
    }
    visitor() {
        return {
            onCapturingGroupEnter: (cgNode) => {
                this.countOfCapturingGroup++;
                if (!cgNode.references.length) {
                    this.unused.add(cgNode);
                    this.indexToCapturingGroup.set(this.countOfCapturingGroup, cgNode);
                }
                else if (cgNode.references.some((ref) => typeof ref.ref === "string")) {
                    return;
                }
                if (cgNode.name) {
                    const array = this.unusedNames.get(cgNode.name);
                    if (array) {
                        array.push(cgNode);
                    }
                    else {
                        this.unusedNames.set(cgNode.name, [cgNode]);
                    }
                }
            },
        };
    }
}
function getProperty(node) {
    if (node.type === "MemberExpression") {
        if (node.computed) {
            if (node.property.type === "Literal") {
                if (typeof node.property.value === "string" ||
                    typeof node.property.value === "number")
                    return String(node.property.value);
            }
        }
        else if (node.property.type === "Identifier") {
            return node.property.name;
        }
        return null;
    }
    if (node.type === "Property") {
        if (node.computed) {
            if (node.key.type === "Literal") {
                if (typeof node.key.value === "string" ||
                    typeof node.key.value === "number")
                    return String(node.key.value);
            }
        }
        else if (node.key.type === "Identifier") {
            return node.key.name;
        }
        return null;
    }
    return null;
}
function extractUsedReferencesFromPattern(node, context) {
    const references = [];
    if (node.type === "ArrayPattern") {
        for (let index = 0; index < node.elements.length; index++) {
            const element = node.elements[index];
            if (!element) {
                continue;
            }
            if (element.type === "RestElement") {
                return null;
            }
            references.push({
                ref: String(index),
                node: element,
                getSubReferences: () => extractUsedReferencesFromPattern(element, context),
            });
        }
        return references;
    }
    if (node.type === "ObjectPattern") {
        for (const prop of node.properties) {
            if (prop.type === "RestElement") {
                return null;
            }
            const property = getProperty(prop);
            if (property == null)
                return null;
            references.push({
                ref: property,
                node: prop.value,
                getSubReferences: () => extractUsedReferencesFromPattern(prop.value, context),
            });
        }
        return references;
    }
    if (node.type === "AssignmentPattern") {
        return extractUsedReferencesFromPattern(node.left, context);
    }
    if (node.type === "Identifier") {
        const variable = ast_utils_1.findVariable(context, node);
        if (!variable) {
            return null;
        }
        for (const reference of variable.references) {
            if (reference.isRead()) {
                const res = extractUsedReferencesFromExpression(reference.identifier, context);
                if (res == null) {
                    return null;
                }
                references.push(...res);
            }
        }
        return references;
    }
    return null;
}
function extractUsedReferencesFromExpression(node, context) {
    const parent = node.parent;
    if (parent.type === "MemberExpression") {
        if (parent.object !== node) {
            return null;
        }
        const property = getProperty(parent);
        if (property == null)
            return null;
        return [
            {
                ref: property,
                node: parent,
                getSubReferences: () => extractUsedReferencesFromExpression(parent, context),
            },
        ];
    }
    else if (parent.type === "AssignmentExpression") {
        if (parent.right !== node || parent.operator !== "=") {
            return null;
        }
        return extractUsedReferencesFromPattern(parent.left, context);
    }
    else if (parent.type === "VariableDeclarator") {
        if (parent.init !== node) {
            return null;
        }
        return extractUsedReferencesFromPattern(parent.id, context);
    }
    return null;
}
exports.default = utils_1.createRule("no-unused-capturing-group", {
    meta: {
        docs: {
            description: "disallow unused capturing group",
            category: "Best Practices",
            recommended: false,
        },
        schema: [],
        messages: {
            unusedCapturingGroup: "Capturing group is defined but never used.",
            unusedNamedCapturingGroup: "'{{name}}' capturing group is defined but never used.",
            unusedName: "'{{name}}' is defined for capturing group, but it name is never used.",
        },
        type: "suggestion",
    },
    create(context) {
        const typeTracer = type_tracker_1.createTypeTracker(context);
        const capturingDataMap = new Map();
        function getCapturingData(node) {
            const re = capturingDataMap.get(node);
            if (re) {
                return re;
            }
            if (node.type === "Identifier") {
                const variable = ast_utils_1.findVariable(context, node);
                if (variable && variable.defs.length === 1) {
                    const def = variable.defs[0];
                    if (def.type === "Variable" &&
                        def.parent.kind === "const" &&
                        def.node.init) {
                        return getCapturingData(def.node.init);
                    }
                }
            }
            return null;
        }
        function reportUnused(capturingData) {
            const { node, getRegexpLocation } = capturingData.regexpContext;
            const { unusedCapturingGroups, unusedNames, } = capturingData.getUnused();
            for (const cgNode of unusedCapturingGroups) {
                context.report({
                    node,
                    loc: getRegexpLocation(cgNode),
                    messageId: cgNode.name
                        ? "unusedNamedCapturingGroup"
                        : "unusedCapturingGroup",
                    data: cgNode.name ? { name: cgNode.name } : {},
                });
            }
            for (const cgNode of unusedNames) {
                context.report({
                    node,
                    loc: getRegexpLocation(cgNode),
                    messageId: "unusedName",
                    data: { name: cgNode.name },
                });
            }
        }
        function verifyForMatch(node) {
            const capturingData = getCapturingData(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            if (capturingData.regexpContext.flags.global) {
                capturingData.markAsUsed();
            }
            else {
                capturingData.markAsUsed();
                verifyForExecResult(node, capturingData);
            }
        }
        function verifyForSearch(node) {
            const capturingData = getCapturingData(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
        }
        function verifyForTest(node) {
            const capturingData = getCapturingData(node.callee.object);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            capturingData.markAsUsed();
        }
        function verifyForReplace(node) {
            const capturingData = getCapturingData(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            const replacementNode = node.arguments[1];
            if (replacementNode.type === "FunctionExpression" ||
                replacementNode.type === "ArrowFunctionExpression") {
                capturingData.markAsUsed();
                verifyForReplaceFunction(replacementNode, capturingData);
            }
            else {
                const evaluated = ast_utils_1.getStaticValue(context, node.arguments[1]);
                if (!evaluated || typeof evaluated.value !== "string") {
                    capturingData.markAsCannotTrack();
                    return;
                }
                capturingData.markAsUsed();
                verifyForReplacePattern(evaluated.value, capturingData);
            }
        }
        function verifyForReplacePattern(replacementPattern, capturingData) {
            for (const replacement of replacements_utils_1.parseReplacementsForString(replacementPattern)) {
                if (replacement.type === "ReferenceElement") {
                    if (typeof replacement.ref === "number") {
                        capturingData.usedIndex(replacement.ref);
                    }
                    else {
                        capturingData.usedName(replacement.ref);
                    }
                }
            }
        }
        function verifyForReplaceFunction(replacementNode, capturingData) {
            for (let index = 0; index < replacementNode.params.length; index++) {
                const arg = replacementNode.params[index];
                if (arg.type === "RestElement") {
                    capturingData.markAsCannotTrack();
                    return;
                }
                if (index === 0) {
                    continue;
                }
                else if (index <= capturingData.countOfCapturingGroup) {
                    capturingData.usedIndex(index);
                }
                else if (capturingData.countOfCapturingGroup + 3 <= index) {
                    capturingData.usedAllNames();
                }
            }
        }
        function verifyForExec(node) {
            const capturingData = getCapturingData(node.callee.object);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            capturingData.markAsUsed();
            verifyForExecResult(node, capturingData);
        }
        function verifyForExecResult(node, capturingData) {
            const refs = extractUsedReferencesFromExpression(node, context);
            if (refs == null) {
                capturingData.markAsCannotTrack();
                return;
            }
            for (const ref of refs) {
                if (ref.ref === "groups") {
                    const sub = ref.getSubReferences();
                    if (sub == null) {
                        capturingData.usedAllNames();
                    }
                    else {
                        for (const namedRef of sub) {
                            capturingData.usedName(namedRef.ref);
                        }
                    }
                }
                else {
                    capturingData.usedIndex(Number(ref.ref));
                }
            }
        }
        function verifyForMatchAll(node) {
            const capturingData = getCapturingData(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
            const refs = extractUsedReferencesForIteration(node);
            if (refs == null) {
                capturingData.markAsCannotTrack();
                return;
            }
            for (const ref of refs) {
                if (ref.ref === "groups") {
                    const sub = ref.getSubReferences();
                    if (sub == null) {
                        capturingData.usedAllNames();
                    }
                    else {
                        for (const namedRef of sub) {
                            capturingData.usedName(namedRef.ref);
                        }
                    }
                }
                else {
                    capturingData.usedIndex(Number(ref.ref));
                }
            }
            function extractUsedReferencesForIteration(expr) {
                const parent = expr.parent;
                if (parent.type === "AssignmentExpression") {
                    if (parent.right !== expr || parent.operator !== "=") {
                        return null;
                    }
                    return extractUsedReferencesForIdIteration(parent.left);
                }
                else if (parent.type === "VariableDeclarator") {
                    if (parent.init !== expr) {
                        return null;
                    }
                    return extractUsedReferencesForIdIteration(parent.id);
                }
                else if (parent.type === "ForOfStatement") {
                    if (parent.right !== expr) {
                        return null;
                    }
                    let left = parent.left;
                    if (left.type === "VariableDeclaration") {
                        left = left.declarations[0].id;
                    }
                    return extractUsedReferencesFromPattern(left, context);
                }
                return null;
            }
            function extractUsedReferencesForIdIteration(ptn) {
                if (ptn.type === "Identifier") {
                    const references = [];
                    const variable = ast_utils_1.findVariable(context, ptn);
                    if (!variable) {
                        return null;
                    }
                    for (const reference of variable.references) {
                        if (reference.isRead()) {
                            const resForId = extractUsedReferencesForIteration(reference.identifier);
                            if (resForId == null) {
                                return null;
                            }
                            references.push(...resForId);
                        }
                    }
                    return references;
                }
                return null;
            }
        }
        function verifyForSplit(node) {
            const capturingData = getCapturingData(node.arguments[0]);
            if (capturingData == null || capturingData.isAllUsed()) {
                return;
            }
            if (!typeTracer.isString(node.callee.object)) {
                capturingData.markAsCannotTrack();
                return;
            }
            capturingData.markAsUsed();
            capturingData.usedAllUnnamed();
        }
        function createVisitor(regexpContext) {
            const { regexpNode } = regexpContext;
            const capturingData = new CapturingData(regexpContext);
            capturingDataMap.set(regexpNode, capturingData);
            return capturingData.visitor();
        }
        return utils_1.compositingVisitors(utils_1.defineRegexpVisitor(context, {
            createVisitor,
        }), {
            "Program:exit"() {
                for (const capturingData of capturingDataMap.values()) {
                    if (capturingData.isNeedReport()) {
                        reportUnused(capturingData);
                    }
                }
            },
            "CallExpression:exit"(node) {
                if (!ast_utils_1.isKnownMethodCall(node, {
                    match: 1,
                    test: 1,
                    search: 1,
                    replace: 2,
                    replaceAll: 2,
                    matchAll: 1,
                    exec: 1,
                    split: 1,
                })) {
                    return;
                }
                if (node.callee.property.name === "match") {
                    verifyForMatch(node);
                }
                else if (node.callee.property.name === "test") {
                    verifyForTest(node);
                }
                else if (node.callee.property.name === "search") {
                    verifyForSearch(node);
                }
                else if (node.callee.property.name === "replace" ||
                    node.callee.property.name === "replaceAll") {
                    verifyForReplace(node);
                }
                else if (node.callee.property.name === "exec") {
                    verifyForExec(node);
                }
                else if (node.callee.property.name === "matchAll") {
                    verifyForMatchAll(node);
                }
                else if (node.callee.property.name === "split") {
                    verifyForSplit(node);
                }
            },
        });
    },
});
