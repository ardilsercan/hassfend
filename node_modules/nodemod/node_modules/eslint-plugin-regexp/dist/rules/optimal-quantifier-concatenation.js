"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
function hasCapturingGroup(node) {
    return regexp_ast_analysis_1.hasSomeDescendant(node, (d) => d.type === "CapturingGroup");
}
const EMPTY_UTF16 = {
    chars: regexp_ast_analysis_1.Chars.empty({}),
    complete: false,
};
const EMPTY_UNICODE = {
    chars: regexp_ast_analysis_1.Chars.empty({ unicode: true }),
    complete: false,
};
function createChars(element, context) {
    const empty = context.flags.unicode ? EMPTY_UNICODE : EMPTY_UTF16;
    switch (element.type) {
        case "Character":
        case "CharacterSet":
            return {
                chars: context.toCharSet(element),
                complete: true,
            };
        case "CharacterClass":
            return {
                chars: context.toCharSet(element),
                complete: true,
            };
        case "Group":
        case "CapturingGroup": {
            const results = element.alternatives.map((a) => {
                if (a.elements.length === 1) {
                    return createChars(a.elements[0], context);
                }
                return empty;
            });
            const union = empty.chars.union(...results.map(({ chars }) => chars));
            return {
                chars: union,
                complete: results.every(({ complete }) => complete),
            };
        }
        default:
            return empty;
    }
}
function quantAddConst(quant, constant) {
    return {
        min: quant.min + constant,
        max: quant.max + constant,
        greedy: quant.greedy,
    };
}
function quantize(element, quant) {
    if (quant.min === 0 && quant.max === 0) {
        return "";
    }
    if (quant.min === 1 && quant.max === 1) {
        return element.raw;
    }
    return element.raw + utils_1.quantToString(quant);
}
function isGroupOrCharacter(element) {
    switch (element.type) {
        case "Group":
        case "CapturingGroup":
        case "Character":
        case "CharacterClass":
        case "CharacterSet":
            return true;
        default:
            return false;
    }
}
function getQuantifiersReplacement(left, right, context) {
    if (left.min === left.max || right.min === right.max) {
        return null;
    }
    if (left.greedy !== right.greedy) {
        return null;
    }
    const lChars = createChars(left.element, context);
    const rChars = createChars(right.element, context);
    const greedy = left.greedy;
    let lQuant, rQuant;
    if (lChars.complete &&
        rChars.complete &&
        lChars.chars.equals(rChars.chars)) {
        lQuant = {
            min: left.min + right.min,
            max: left.max + right.max,
            greedy,
        };
        rQuant = { min: 0, max: 0, greedy };
    }
    else if (right.max === Infinity &&
        lChars.complete &&
        lChars.chars.isSubsetOf(rChars.chars)) {
        lQuant = {
            min: left.min,
            max: left.min,
            greedy,
        };
        rQuant = right;
    }
    else if (left.max === Infinity &&
        rChars.complete &&
        rChars.chars.isSubsetOf(lChars.chars)) {
        lQuant = left;
        rQuant = {
            min: right.min,
            max: right.min,
            greedy,
        };
    }
    else {
        return null;
    }
    const raw = quantize(left.element, lQuant) + quantize(right.element, rQuant);
    let message;
    if (lQuant.max === 0 &&
        right.max === rQuant.max &&
        right.min === rQuant.min) {
        message = "removeLeft";
    }
    else if (rQuant.max === 0 &&
        left.max === lQuant.max &&
        left.min === lQuant.min) {
        message = "removeRight";
    }
    else {
        message = "replace";
    }
    return { raw, messageId: message };
}
function asRepeatedElement(element) {
    if (element.type === "Quantifier") {
        if (element.min === element.max &&
            element.min > 0 &&
            isGroupOrCharacter(element.element)) {
            return {
                type: "Repeated",
                element: element.element,
                min: element.min,
            };
        }
    }
    else if (isGroupOrCharacter(element)) {
        return { type: "Repeated", element, min: 1 };
    }
    return null;
}
function getQuantifierRepeatedElementReplacement(pair, context) {
    const [left, right] = pair;
    const leftChar = createChars(left.element, context);
    if (!leftChar.complete) {
        return null;
    }
    const rightChar = createChars(right.element, context);
    if (!rightChar.complete) {
        return null;
    }
    if (!rightChar.chars.equals(leftChar.chars)) {
        return null;
    }
    let elementRaw, quant;
    if (left.type === "Quantifier") {
        elementRaw = left.element.raw;
        quant = quantAddConst(left, right.min);
    }
    else if (right.type === "Quantifier") {
        elementRaw = right.element.raw;
        quant = quantAddConst(right, left.min);
    }
    else {
        throw new Error();
    }
    const raw = elementRaw + utils_1.quantToString(quant);
    return { messageId: "combine", raw };
}
function getReplacement(left, right, context) {
    if (left.type === "Quantifier" && right.type === "Quantifier") {
        const result = getQuantifiersReplacement(left, right, context);
        if (result)
            return result;
    }
    if (left.type === "Quantifier") {
        const rightRep = asRepeatedElement(right);
        if (rightRep) {
            const result = getQuantifierRepeatedElementReplacement([left, rightRep], context);
            if (result)
                return result;
        }
    }
    if (right.type === "Quantifier") {
        const leftRep = asRepeatedElement(left);
        if (leftRep) {
            const result = getQuantifierRepeatedElementReplacement([leftRep, right], context);
            if (result) {
                if (isGroupOrCharacter(left) &&
                    right.min === 0 &&
                    right.max === 1 &&
                    left.raw.length + right.raw.length <= result.raw.length) {
                    return null;
                }
                return result;
            }
        }
    }
    return null;
}
function getLoc(left, right, sourceCode, { getRegexpRange }) {
    const firstRange = getRegexpRange(left);
    const lastRange = getRegexpRange(right);
    if (firstRange && lastRange) {
        return {
            start: sourceCode.getLocFromIndex(firstRange[0]),
            end: sourceCode.getLocFromIndex(lastRange[1]),
        };
    }
    return undefined;
}
exports.default = utils_1.createRule("optimal-quantifier-concatenation", {
    meta: {
        docs: {
            description: "require optimal quantifiers for concatenated quantifiers",
            category: "Best Practices",
            recommended: false,
        },
        fixable: "code",
        schema: [],
        messages: {
            combine: "'{{left}}' and '{{right}}' can be combined into one quantifier '{{fix}}'.{{cap}}",
            removeLeft: "'{{left}}' can be removed because it is already included by '{{right}}'.{{cap}}",
            removeRight: "'{{right}}' can be removed because it is already included by '{{left}}'.{{cap}}",
            replace: "'{{left}}' and '{{right}}' can be replaced with '{{fix}}'.{{cap}}",
        },
        type: "suggestion",
    },
    create(context) {
        function createVisitor(regexpContext) {
            const { node, getRegexpLocation, fixReplaceNode } = regexpContext;
            return {
                onAlternativeEnter(aNode) {
                    var _a;
                    for (let i = 0; i < aNode.elements.length - 1; i++) {
                        const left = aNode.elements[i];
                        const right = aNode.elements[i + 1];
                        const replacement = getReplacement(left, right, regexpContext);
                        if (!replacement) {
                            continue;
                        }
                        const involvesCapturingGroup = hasCapturingGroup(left) || hasCapturingGroup(right);
                        context.report({
                            node,
                            loc: (_a = getLoc(left, right, context.getSourceCode(), regexpContext)) !== null && _a !== void 0 ? _a : getRegexpLocation(aNode),
                            messageId: replacement.messageId,
                            data: {
                                left: left.raw,
                                right: right.raw,
                                fix: replacement.raw,
                                cap: involvesCapturingGroup
                                    ? " This cannot be fixed automatically because it might change or remove a capturing group."
                                    : "",
                            },
                            fix: fixReplaceNode(aNode, () => {
                                if (involvesCapturingGroup) {
                                    return null;
                                }
                                const before = aNode.raw.slice(0, left.start - aNode.start);
                                const after = aNode.raw.slice(right.end - aNode.start);
                                return before + replacement.raw + after;
                            }),
                        });
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
