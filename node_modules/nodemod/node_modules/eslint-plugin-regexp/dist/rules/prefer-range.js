"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const char_ranges_1 = require("../utils/char-ranges");
exports.default = utils_1.createRule("prefer-range", {
    meta: {
        docs: {
            description: "enforce using character class range",
            category: "Best Practices",
            recommended: false,
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    target: char_ranges_1.getAllowedCharValueSchema(),
                },
                additionalProperties: false,
            },
        ],
        messages: {
            unexpected: "Unexpected multiple adjacent characters. Use '{{range}}' instead.",
        },
        type: "suggestion",
    },
    create(context) {
        var _a;
        const allowedRanges = char_ranges_1.getAllowedCharRanges((_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.target, context);
        const sourceCode = context.getSourceCode();
        function createVisitor(regexpContext) {
            const { node, getRegexpRange } = regexpContext;
            function getReportRanges(nodes) {
                const ranges = [];
                for (const reportNode of nodes) {
                    const reportRange = getRegexpRange(reportNode);
                    if (!reportRange) {
                        return null;
                    }
                    const range = ranges.find((r) => r[0] <= reportRange[1] && reportRange[0] <= r[1]);
                    if (range) {
                        range[0] = Math.min(range[0], reportRange[0]);
                        range[1] = Math.max(range[1], reportRange[1]);
                    }
                    else {
                        ranges.push([...reportRange]);
                    }
                }
                return ranges;
            }
            return {
                onCharacterClassEnter(ccNode) {
                    const groups = [];
                    for (const element of ccNode.elements) {
                        let data;
                        if (element.type === "Character") {
                            if (char_ranges_1.inRange(allowedRanges, element.value)) {
                                data = { min: element, max: element };
                            }
                            else {
                                continue;
                            }
                        }
                        else if (element.type === "CharacterClassRange") {
                            if (char_ranges_1.inRange(allowedRanges, element.min.value, element.max.value)) {
                                data = { min: element.min, max: element.max };
                            }
                            else {
                                continue;
                            }
                        }
                        else {
                            continue;
                        }
                        const group = groups.find((gp) => gp.min.value - 1 <= data.max.value &&
                            data.min.value <= gp.max.value + 1);
                        if (group) {
                            if (data.min.value < group.min.value) {
                                group.min = data.min;
                            }
                            if (group.max.value < data.max.value) {
                                group.max = data.max;
                            }
                            group.nodes.push(element);
                        }
                        else {
                            groups.push(Object.assign(Object.assign({}, data), { nodes: [element] }));
                        }
                    }
                    for (const group of groups) {
                        if (group.max.value - group.min.value > 1 &&
                            group.nodes.length > 1) {
                            const ranges = getReportRanges(group.nodes);
                            const newText = `${group.min.raw}-${group.max.raw}`;
                            for (const range of ranges || [node.range]) {
                                context.report({
                                    node,
                                    loc: {
                                        start: sourceCode.getLocFromIndex(range[0]),
                                        end: sourceCode.getLocFromIndex(range[1]),
                                    },
                                    messageId: "unexpected",
                                    data: {
                                        range: newText,
                                    },
                                    fix: ranges
                                        ? (fixer) => {
                                            return ranges.map((r, index) => {
                                                if (index === 0) {
                                                    return fixer.replaceTextRange(r, newText);
                                                }
                                                return fixer.removeRange(r);
                                            });
                                        }
                                        : undefined,
                                });
                            }
                        }
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
