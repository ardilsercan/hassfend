"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUsageOfPattern = exports.UsageOfPattern = void 0;
const ast_utils_1 = require("./ast-utils");
var UsageOfPattern;
(function (UsageOfPattern) {
    UsageOfPattern[UsageOfPattern["partial"] = 0] = "partial";
    UsageOfPattern[UsageOfPattern["whole"] = 1] = "whole";
    UsageOfPattern[UsageOfPattern["mixed"] = 2] = "mixed";
    UsageOfPattern[UsageOfPattern["unknown"] = 3] = "unknown";
})(UsageOfPattern = exports.UsageOfPattern || (exports.UsageOfPattern = {}));
function getUsageOfPattern(node, context) {
    const usageSet = new Set();
    for (const usage of iterateUsageOfPatternForExpression(node, context, new Map())) {
        if (usage === UsageOfPattern.unknown) {
            return UsageOfPattern.unknown;
        }
        usageSet.add(usage);
    }
    if (usageSet.has(UsageOfPattern.partial)) {
        return usageSet.has(UsageOfPattern.whole)
            ? UsageOfPattern.mixed
            : UsageOfPattern.partial;
    }
    return usageSet.has(UsageOfPattern.whole)
        ? UsageOfPattern.whole
        : UsageOfPattern.unknown;
}
exports.getUsageOfPattern = getUsageOfPattern;
function* iterateUsageOfPatternForExpression(node, context, alreadyFn) {
    const parent = ast_utils_1.getParent(node);
    if (!parent) {
        return;
    }
    if (parent.type === "MemberExpression") {
        if (parent.object === node) {
            yield* iterateUsageOfPatternForMemberExpression(parent, context);
        }
        else {
            yield UsageOfPattern.unknown;
        }
    }
    else if (parent.type === "AssignmentExpression") {
        if (parent.right === node) {
            yield* iterateUsageOfPatternForESPattern(parent.left, context, alreadyFn);
        }
        else {
            yield UsageOfPattern.unknown;
        }
    }
    else if (parent.type === "VariableDeclarator") {
        if (parent.init === node) {
            yield* iterateUsageOfPatternForESPattern(parent.id, context, alreadyFn);
        }
        else {
            yield UsageOfPattern.unknown;
        }
    }
    else if (parent.type === "CallExpression") {
        const argIndex = parent.arguments.indexOf(node);
        if (argIndex > -1) {
            if (parent.callee.type === "Identifier") {
                const fn = findFunction(context, parent.callee);
                if (fn) {
                    yield* iterateUsageOfPatternForFunctionArgument(fn, argIndex, context, alreadyFn);
                    return;
                }
            }
            yield UsageOfPattern.whole;
        }
        else {
            yield UsageOfPattern.unknown;
        }
    }
    else if (parent.type === "ChainExpression") {
        yield* iterateUsageOfPatternForExpression(parent, context, alreadyFn);
    }
    else {
        yield UsageOfPattern.unknown;
    }
}
function* iterateUsageOfPatternForMemberExpression(node, context) {
    const propName = !node.computed
        ? node.property.name
        : ast_utils_1.getStringIfConstant(context, node.property);
    yield* iterateUsageOfPatternForPropName(propName);
}
function* iterateUsageOfPatternForPropName(propName) {
    const regexpPropName = propName;
    if (regexpPropName === "source") {
        yield UsageOfPattern.partial;
        return;
    }
    if (regexpPropName === "compile" ||
        regexpPropName === "dotAll" ||
        regexpPropName === "flags" ||
        regexpPropName === "global" ||
        regexpPropName === "ignoreCase" ||
        regexpPropName === "multiline" ||
        regexpPropName === "sticky" ||
        regexpPropName === "unicode") {
        return;
    }
    yield UsageOfPattern.whole;
}
function* iterateUsageOfPatternForESPattern(node, context, alreadyFn) {
    if (node.type === "Identifier") {
        yield* iterateUsageOfPatternForVariable(node, context, alreadyFn);
    }
    else if (node.type === "ObjectPattern") {
        yield* iterateUsageOfPatternForObjectPattern(node, context);
    }
    else {
        yield UsageOfPattern.unknown;
    }
}
function* iterateUsageOfPatternForObjectPattern(node, context) {
    for (const prop of node.properties) {
        if (prop.type === "RestElement") {
            continue;
        }
        let propName;
        if (!prop.computed) {
            propName =
                prop.key.type === "Identifier"
                    ? prop.key.name
                    : String(prop.key.value);
        }
        else {
            propName = ast_utils_1.getStringIfConstant(context, prop.key);
        }
        yield* iterateUsageOfPatternForPropName(propName);
    }
}
function* iterateUsageOfPatternForVariable(node, context, alreadyFn) {
    const variable = ast_utils_1.findVariable(context, node);
    if (!variable) {
        yield UsageOfPattern.unknown;
        return;
    }
    const readReferences = variable.references.filter((ref) => ref.isRead());
    if (!readReferences.length) {
        yield UsageOfPattern.unknown;
        return;
    }
    for (const reference of readReferences) {
        yield* iterateUsageOfPatternForExpression(reference.identifier, context, alreadyFn);
    }
}
function* iterateUsageOfPatternForFunctionArgument(node, argIndex, context, alreadyFn) {
    let alreadyIndexes = alreadyFn.get(node);
    if (!alreadyIndexes) {
        alreadyIndexes = new Set();
        alreadyFn.set(node, alreadyIndexes);
    }
    if (alreadyIndexes.has(argIndex)) {
        return;
    }
    alreadyIndexes.add(argIndex);
    const argNode = node.params[argIndex];
    if (argNode && argNode.type === "Identifier") {
        yield* iterateUsageOfPatternForVariable(argNode, context, alreadyFn);
    }
    else {
        yield UsageOfPattern.unknown;
    }
}
function findFunction(context, id) {
    const calleeVariable = ast_utils_1.findVariable(context, id);
    if (!calleeVariable) {
        return null;
    }
    if (calleeVariable.defs.length === 1) {
        const def = calleeVariable.defs[0];
        if (def.node.type === "FunctionDeclaration") {
            return def.node;
        }
        if (def.type === "Variable" &&
            def.parent.kind === "const" &&
            def.node.init) {
            if (def.node.init.type === "FunctionExpression" ||
                def.node.init.type === "ArrowFunctionExpression") {
                return def.node.init;
            }
            if (def.node.init.type === "Identifier") {
                return findFunction(context, def.node.init);
            }
        }
    }
    return null;
}
