"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
const OPTION_SS1 = "[\\s\\S]";
const OPTION_SS2 = "[\\S\\s]";
const OPTION_CARET = "[^]";
const OPTION_DOTALL = "dotAll";
exports.default = utils_1.createRule("match-any", {
    meta: {
        docs: {
            description: "enforce match any character style",
            category: "Stylistic Issues",
            recommended: true,
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    allows: {
                        type: "array",
                        items: {
                            type: "string",
                            enum: [
                                OPTION_SS1,
                                OPTION_SS2,
                                OPTION_CARET,
                                OPTION_DOTALL,
                            ],
                        },
                        uniqueItems: true,
                        minItems: 1,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            unexpected: "Unexpected using '{{expr}}' to match any character.",
        },
        type: "suggestion",
    },
    create(context) {
        var _a, _b;
        const sourceCode = context.getSourceCode();
        const allowList = (_b = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.allows) !== null && _b !== void 0 ? _b : [
            OPTION_SS1,
            OPTION_DOTALL,
        ];
        const allows = new Set(allowList);
        const preference = allowList[0] || null;
        function* fix(fixer, { node, flags, getRegexpRange, fixerApplyEscape }, regexpNode) {
            if (!preference) {
                return;
            }
            if (preference === OPTION_DOTALL) {
                if (!flags.dotAll) {
                    return;
                }
                if (!utils_1.isRegexpLiteral(node)) {
                    return;
                }
            }
            const range = getRegexpRange(regexpNode);
            if (range == null) {
                return;
            }
            if (regexpNode.type === "CharacterClass" &&
                preference.startsWith("[") &&
                preference.endsWith("]")) {
                yield fixer.replaceTextRange([range[0] + 1, range[1] - 1], fixerApplyEscape(preference.slice(1, -1)));
                return;
            }
            const replacement = preference === OPTION_DOTALL ? "." : preference;
            yield fixer.replaceTextRange(range, fixerApplyEscape(replacement));
            if (preference === OPTION_DOTALL) {
                const afterRange = [range[1], node.range[1]];
                yield fixer.replaceTextRange(afterRange, sourceCode.text.slice(...afterRange));
            }
        }
        function createVisitor(regexpContext) {
            const { node, flags, getRegexpLocation } = regexpContext;
            return {
                onCharacterSetEnter(csNode) {
                    if (csNode.kind === "any" &&
                        flags.dotAll &&
                        !allows.has(OPTION_DOTALL)) {
                        context.report({
                            node,
                            loc: getRegexpLocation(csNode),
                            messageId: "unexpected",
                            data: {
                                expr: ".",
                            },
                            fix(fixer) {
                                return fix(fixer, regexpContext, csNode);
                            },
                        });
                    }
                },
                onCharacterClassEnter(ccNode) {
                    if (regexp_ast_analysis_1.matchesAllCharacters(ccNode, flags) &&
                        !allows.has(ccNode.raw)) {
                        context.report({
                            node,
                            loc: getRegexpLocation(ccNode),
                            messageId: "unexpected",
                            data: {
                                expr: ccNode.raw,
                            },
                            fix(fixer) {
                                return fix(fixer, regexpContext, ccNode);
                            },
                        });
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
