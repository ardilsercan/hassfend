"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
const refa_1 = require("refa");
const cache = new Map();
function getAllowedChars(flags) {
    const cacheKey = (flags.ignoreCase ? "i" : "") + (flags.unicode ? "u" : "");
    let result = cache.get(cacheKey);
    if (result === undefined) {
        result = {
            allowed: refa_1.JS.createCharSet([
                { kind: "word", negate: false },
                { min: utils_1.CP_SPACE, max: utils_1.CP_SPACE },
                { min: utils_1.CP_MINUS, max: utils_1.CP_MINUS },
                { min: utils_1.CP_APOSTROPHE, max: utils_1.CP_APOSTROPHE },
            ], flags),
            required: regexp_ast_analysis_1.Chars.word(flags),
        };
        cache.set(cacheKey, result);
    }
    return result;
}
function getConsumedChars(element, context) {
    const ranges = [];
    regexp_ast_analysis_1.hasSomeDescendant(element, (d) => {
        if (d.type === "Character" ||
            d.type === "CharacterClass" ||
            d.type === "CharacterSet") {
            ranges.push(...context.toCharSet(d).ranges);
        }
        else if (d.type === "Backreference" && !regexp_ast_analysis_1.isEmptyBackreference(d)) {
            ranges.push(...getConsumedChars(d.resolved, context).ranges);
        }
        return false;
    }, (d) => d.type !== "Assertion" && d.type !== "CharacterClass");
    return regexp_ast_analysis_1.Chars.empty(context.flags).union(ranges);
}
function canReorder(parent, consumedChars, context) {
    const lengthRange = regexp_ast_analysis_1.getLengthRange(parent.alternatives);
    if (lengthRange && lengthRange.min === lengthRange.max) {
        return true;
    }
    if (parent.type === "Pattern" || parent.type === "Assertion") {
        return false;
    }
    return (regexp_ast_analysis_1.getFirstCharAfter(parent, "rtl", context.flags).char.isDisjointWith(consumedChars) &&
        regexp_ast_analysis_1.getFirstCharAfter(parent, "ltr", context.flags).char.isDisjointWith(consumedChars));
}
function containsOnlyLiterals(element) {
    return !regexp_ast_analysis_1.hasSomeDescendant(element, (d) => {
        return (d.type === "Backreference" ||
            d.type === "CharacterSet" ||
            (d.type === "Quantifier" && d.max === Infinity) ||
            (d.type === "CharacterClass" && d.negate));
    }, (d) => d.type !== "Assertion");
}
function compareByteOrder(a, b) {
    const l = Math.min(a.length, b.length);
    for (let i = 0; i < l; i++) {
        const diff = a.charCodeAt(i) - b.charCodeAt(i);
        if (diff !== 0) {
            return diff;
        }
    }
    return a.length - b.length;
}
function sortAlternatives(alternatives, context) {
    const firstChars = new Map();
    for (const a of alternatives) {
        const chars = regexp_ast_analysis_1.getFirstConsumedChar(a, "ltr", context.flags);
        const char = chars.empty || chars.char.isEmpty
            ? Infinity
            : chars.char.ranges[0].min;
        firstChars.set(a, char);
    }
    alternatives.sort((a, b) => {
        const firstA = firstChars.get(a);
        const firstB = firstChars.get(b);
        if (firstA !== firstB) {
            return firstA - firstB;
        }
        if (context.flags.ignoreCase) {
            return (compareByteOrder(a.raw.toUpperCase(), b.raw.toUpperCase()) ||
                compareByteOrder(a.raw, b.raw));
        }
        return compareByteOrder(a.raw, b.raw);
    });
}
function trySortNumberAlternatives(alternatives) {
    const numberRanges = [];
    {
        let start = 0;
        for (let i = 0; i < alternatives.length; i++) {
            if (!/^0|[1-9]\d*$/.test(alternatives[i].raw)) {
                if (start < i) {
                    numberRanges.push([start, i]);
                }
                start = i + 1;
            }
        }
        if (start < alternatives.length) {
            numberRanges.push([start, alternatives.length]);
        }
    }
    for (const [start, end] of numberRanges) {
        const slice = alternatives.slice(start, end);
        slice.sort((a, b) => {
            return Number(a.raw) - Number(b.raw);
        });
        alternatives.splice(start, end - start, ...slice);
    }
}
function unionLocations(a, b) {
    function less(x, y) {
        if (x.line < y.line) {
            return true;
        }
        else if (x.line > y.line) {
            return false;
        }
        return x.column < y.column;
    }
    return {
        start: Object.assign({}, (less(a.start, b.start) ? a.start : b.start)),
        end: Object.assign({}, (less(a.end, b.end) ? b.end : a.end)),
    };
}
function getReorderingBounds(original, reorder) {
    if (original.length !== reorder.length) {
        return undefined;
    }
    const len = original.length;
    let first = 0;
    for (; first < len && original[first] === reorder[first]; first++)
        ;
    if (first === len) {
        return undefined;
    }
    let last = len - 1;
    for (; last >= 0 && original[last] === reorder[last]; last--)
        ;
    return [first, last];
}
exports.default = utils_1.createRule("sort-alternatives", {
    meta: {
        docs: {
            description: "sort alternatives if order doesn't matter",
            category: "Best Practices",
            recommended: false,
        },
        fixable: "code",
        schema: [],
        messages: {
            sort: "The alternatives of this group can be sorted without affecting the regex.",
        },
        type: "suggestion",
    },
    create(context) {
        function createVisitor(regexpContext) {
            const { node, getRegexpLocation, fixReplaceNode, flags, } = regexpContext;
            const allowedChars = getAllowedChars(flags);
            function enforceSorted(sorted) {
                const parent = sorted[0].parent;
                const unsorted = parent.alternatives;
                const bounds = getReorderingBounds(unsorted, sorted);
                if (!bounds) {
                    return;
                }
                const loc = unionLocations(getRegexpLocation(unsorted[bounds[0]]), getRegexpLocation(unsorted[bounds[1]]));
                context.report({
                    node,
                    loc,
                    messageId: "sort",
                    fix: fixReplaceNode(parent, () => {
                        const prefix = parent.raw.slice(0, parent.alternatives[0].start - parent.start);
                        const suffix = parent.raw.slice(parent.alternatives[parent.alternatives.length - 1]
                            .end - parent.start);
                        return (prefix + sorted.map((a) => a.raw).join("|") + suffix);
                    }),
                });
            }
            function onParent(parent) {
                if (parent.alternatives.length < 2) {
                    return;
                }
                if (!containsOnlyLiterals(parent)) {
                    return;
                }
                if (regexp_ast_analysis_1.hasSomeDescendant(parent, (d) => d !== parent && d.type === "CapturingGroup")) {
                    return;
                }
                const consumedChars = getConsumedChars(parent, regexpContext);
                if (consumedChars.isEmpty) {
                    return;
                }
                if (!consumedChars.isSubsetOf(allowedChars.allowed)) {
                    return;
                }
                if (consumedChars.isDisjointWith(allowedChars.required)) {
                    return;
                }
                const alternatives = [...parent.alternatives];
                if (canReorder(parent, consumedChars, regexpContext)) {
                    sortAlternatives(alternatives, regexpContext);
                    trySortNumberAlternatives(alternatives);
                }
                else if (!consumedChars.isDisjointWith(regexp_ast_analysis_1.Chars.digit(flags)) &&
                    canReorder(parent, consumedChars.intersect(regexp_ast_analysis_1.Chars.digit(flags)), regexpContext)) {
                    trySortNumberAlternatives(alternatives);
                }
                enforceSorted(alternatives);
            }
            return {
                onGroupEnter: onParent,
                onPatternEnter: onParent,
                onCapturingGroupEnter: onParent,
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
