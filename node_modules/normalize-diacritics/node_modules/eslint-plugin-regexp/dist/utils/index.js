"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEscapeSequence = exports.isUseHexEscape = exports.getEscapeSequenceKind = exports.EscapeSequenceKind = exports.isUnicodeCodePointEscape = exports.isUnicodeEscape = exports.isHexadecimalEscape = exports.isControlEscape = exports.isOctalEscape = exports.canUnwrapped = exports.mightCreateNewElement = exports.toCharSetSource = exports.quantToString = exports.getQuantifierOffsets = exports.isRegexpLiteral = exports.compositingVisitors = exports.defineRegexpVisitor = exports.createRule = exports.parseFlags = exports.FLAG_UNICODE = exports.FLAG_STICKY = exports.FLAG_MULTILINE = exports.FLAG_IGNORECASE = exports.FLAG_DOTALL = exports.FLAG_GLOBAL = void 0;
const regexpp_1 = require("regexpp");
const eslint_utils_1 = require("eslint-utils");
const string_literal_parser_1 = require("./string-literal-parser");
const ast_utils_1 = require("./ast-utils");
const regexp_ast_analysis_1 = require("regexp-ast-analysis");
const refa_1 = require("refa");
const get_usage_of_pattern_1 = require("./get-usage-of-pattern");
__exportStar(require("./unicode"), exports);
const regexpRules = new WeakMap();
exports.FLAG_GLOBAL = "g";
exports.FLAG_DOTALL = "s";
exports.FLAG_IGNORECASE = "i";
exports.FLAG_MULTILINE = "m";
exports.FLAG_STICKY = "y";
exports.FLAG_UNICODE = "u";
const flagsCache = new Map();
function parseFlags(flags) {
    let cached = flagsCache.get(flags);
    if (cached === undefined) {
        cached = {
            dotAll: flags.includes(exports.FLAG_DOTALL),
            global: flags.includes(exports.FLAG_GLOBAL),
            ignoreCase: flags.includes(exports.FLAG_IGNORECASE),
            multiline: flags.includes(exports.FLAG_MULTILINE),
            sticky: flags.includes(exports.FLAG_STICKY),
            unicode: flags.includes(exports.FLAG_UNICODE),
        };
        flagsCache.set(flags, cached);
    }
    return cached;
}
exports.parseFlags = parseFlags;
function createRule(ruleName, rule) {
    return {
        meta: Object.assign(Object.assign({}, rule.meta), { docs: Object.assign(Object.assign({}, rule.meta.docs), { url: `https://ota-meshi.github.io/eslint-plugin-regexp/rules/${ruleName}.html`, ruleId: `regexp/${ruleName}`, ruleName }) }),
        create: rule.create,
    };
}
exports.createRule = createRule;
function defineRegexpVisitor(context, rule) {
    const programNode = context.getSourceCode().ast;
    let visitor;
    let rules = regexpRules.get(programNode);
    if (!rules) {
        rules = [];
        regexpRules.set(programNode, rules);
        visitor = buildRegexpVisitor(context, rules, () => {
            regexpRules.delete(programNode);
        });
    }
    else {
        visitor = {};
    }
    const createLiteralVisitor = "createVisitor" in rule
        ? rule.createVisitor
        : "createLiteralVisitor" in rule
            ? rule.createLiteralVisitor
            : undefined;
    const createSourceVisitor = "createVisitor" in rule
        ? rule.createVisitor
        : "createSourceVisitor" in rule
            ? rule.createSourceVisitor
            : undefined;
    rules.push({ createLiteralVisitor, createSourceVisitor });
    return visitor;
}
exports.defineRegexpVisitor = defineRegexpVisitor;
function buildRegexpVisitor(context, rules, programExit) {
    const sourceCode = context.getSourceCode();
    const parser = new regexpp_1.RegExpParser();
    function verify(exprNode, regexpNode, pattern, flags, createVisitors) {
        let parsedPattern;
        try {
            parsedPattern = parser.parsePattern(pattern, 0, pattern.length, flags.unicode);
        }
        catch (_a) {
            return;
        }
        const helpers = buildRegExpHelperBase({
            exprNode,
            regexpNode,
            context,
            flags,
            parsedPattern,
        });
        const handler = {};
        for (const visitor of createVisitors(helpers)) {
            for (const [key, fn] of Object.entries(visitor)) {
                const orig = handler[key];
                if (orig) {
                    handler[key] = (node) => {
                        orig(node);
                        fn(node);
                    };
                }
                else {
                    handler[key] = fn;
                }
            }
        }
        if (Object.keys(handler).length === 0) {
            return;
        }
        regexpp_1.visitRegExpAST(parsedPattern, handler);
    }
    return {
        "Program:exit": programExit,
        Literal(node) {
            if (!isRegexpLiteral(node)) {
                return;
            }
            const flagsString = node.regex.flags;
            const flags = parseFlags(flagsString);
            verify(node, node, node.regex.pattern, flags, function* (helpers) {
                const regexpContext = Object.assign(Object.assign({ node, pattern: node.regex.pattern, flags,
                    flagsString, ownsFlags: true, regexpNode: node }, helpers), { getRegexpRange: (regexpNode) => getRegexpRange(sourceCode, node, regexpNode) });
                for (const rule of rules) {
                    if (rule.createLiteralVisitor) {
                        yield rule.createLiteralVisitor(regexpContext);
                    }
                }
            });
        },
        Program() {
            const tracker = new eslint_utils_1.ReferenceTracker(context.getScope());
            const regexpDataList = [];
            for (const { node } of tracker.iterateGlobalReferences({
                RegExp: { [eslint_utils_1.CALL]: true, [eslint_utils_1.CONSTRUCT]: true },
            })) {
                const newOrCall = node;
                const [patternNode, flagsNode] = newOrCall.arguments;
                if (!patternNode || patternNode.type === "SpreadElement") {
                    continue;
                }
                const pattern = ast_utils_1.getStringIfConstant(context, patternNode);
                const flagsString = flagsNode
                    ? ast_utils_1.getStringIfConstant(context, flagsNode)
                    : null;
                regexpDataList.push({
                    newOrCall,
                    patternNode,
                    pattern,
                    flagsNode,
                    flagsString,
                });
            }
            for (const { newOrCall, patternNode, pattern, flagsNode, flagsString, } of regexpDataList) {
                if (typeof pattern === "string") {
                    let verifyPatternNode = patternNode;
                    if (patternNode.type === "Identifier") {
                        const variable = ast_utils_1.findVariable(context, patternNode);
                        if (variable && variable.defs.length === 1) {
                            const def = variable.defs[0];
                            if (def.type === "Variable" &&
                                def.parent.kind === "const" &&
                                def.node.init &&
                                def.node.init.type === "Literal") {
                                let useInit = false;
                                if (variable.references.length > 2) {
                                    if (variable.references.every((ref) => {
                                        if (ref.isWriteOnly()) {
                                            return true;
                                        }
                                        return regexpDataList.some((r) => r.patternNode ===
                                            ref.identifier &&
                                            r.flagsString ===
                                                flagsString);
                                    })) {
                                        useInit = true;
                                    }
                                }
                                else {
                                    useInit = true;
                                }
                                if (useInit) {
                                    verifyPatternNode = def.node.init;
                                }
                            }
                        }
                    }
                    const flags = parseFlags(flagsString || "");
                    verify(verifyPatternNode, newOrCall, pattern, flags, function* (helpers) {
                        const regexpContext = Object.assign(Object.assign({ node: verifyPatternNode, pattern,
                            flags,
                            flagsString, ownsFlags: Boolean(flagsNode &&
                                flagsNode.type !== "SpreadElement" &&
                                isStringLiteral(flagsNode)), regexpNode: newOrCall }, helpers), { getRegexpRange: (regexpNode) => getRegexpRange(sourceCode, verifyPatternNode, regexpNode) });
                        for (const rule of rules) {
                            if (rule.createSourceVisitor) {
                                yield rule.createSourceVisitor(regexpContext);
                            }
                        }
                    });
                }
            }
        },
    };
}
function compositingVisitors(visitor, ...visitors) {
    for (const v of visitors) {
        for (const key in v) {
            const orig = visitor[key];
            if (orig) {
                visitor[key] = (...args) => {
                    orig(...args);
                    v[key](...args);
                };
            }
            else {
                visitor[key] = v[key];
            }
        }
    }
    return visitor;
}
exports.compositingVisitors = compositingVisitors;
function buildRegExpHelperBase({ exprNode, regexpNode, context, flags, parsedPattern, }) {
    const sourceCode = context.getSourceCode();
    const cacheCharSet = new WeakMap();
    let cacheUsageOfPattern = null;
    return {
        toCharSet: (node, optionFlags) => {
            if (optionFlags) {
                return regexp_ast_analysis_1.toCharSet(node, flags);
            }
            let charSet = cacheCharSet.get(node);
            if (charSet) {
                return charSet;
            }
            charSet = regexp_ast_analysis_1.toCharSet(node, flags);
            cacheCharSet.set(node, charSet);
            return charSet;
        },
        getRegexpLocation: (node, offsets) => getRegexpLocation(sourceCode, exprNode, node, offsets),
        getFlagsLocation: () => getFlagsLocation(sourceCode, regexpNode),
        fixerApplyEscape: (text) => fixerApplyEscape(text, exprNode),
        fixReplaceNode: (node, replacement) => fixReplaceNode(sourceCode, exprNode, node, replacement),
        fixReplaceQuant: (qNode, replacement) => fixReplaceQuant(sourceCode, exprNode, qNode, replacement),
        fixReplaceFlags: (newFlags) => fixReplaceFlags(sourceCode, exprNode, parsedPattern, regexpNode, newFlags),
        getUsageOfPattern: () => (cacheUsageOfPattern !== null && cacheUsageOfPattern !== void 0 ? cacheUsageOfPattern : (cacheUsageOfPattern = get_usage_of_pattern_1.getUsageOfPattern(regexpNode, context))),
        patternAst: parsedPattern,
    };
}
function getRegexpRange(sourceCode, node, regexpNode, offsets) {
    var _a, _b;
    const startOffset = regexpNode.start + ((_a = offsets === null || offsets === void 0 ? void 0 : offsets[0]) !== null && _a !== void 0 ? _a : 0);
    const endOffset = regexpNode.end + ((_b = offsets === null || offsets === void 0 ? void 0 : offsets[1]) !== null && _b !== void 0 ? _b : 0);
    if (isRegexpLiteral(node)) {
        const nodeStart = node.range[0] + 1;
        return [nodeStart + startOffset, nodeStart + endOffset];
    }
    if (isStringLiteral(node)) {
        let start = null;
        let end = null;
        try {
            const sourceText = sourceCode.text.slice(node.range[0] + 1, node.range[1] - 1);
            let startIndex = 0;
            for (const t of string_literal_parser_1.parseStringTokens(sourceText)) {
                const endIndex = startIndex + t.value.length;
                if (start == null &&
                    startIndex <= startOffset &&
                    startOffset < endIndex) {
                    start = t.range[0];
                }
                if (start != null &&
                    end == null &&
                    startIndex < endOffset &&
                    endOffset <= endIndex) {
                    end = t.range[1];
                    break;
                }
                startIndex = endIndex;
            }
            if (start != null && end != null) {
                const nodeStart = node.range[0] + 1;
                return [nodeStart + start, nodeStart + end];
            }
        }
        catch (_c) {
        }
    }
    return null;
}
function getRegexpLocation(sourceCode, node, regexpNode, offsets) {
    const range = getRegexpRange(sourceCode, node, regexpNode);
    if (range == null) {
        return node.loc;
    }
    if (offsets) {
        return {
            start: sourceCode.getLocFromIndex(range[0] + offsets[0]),
            end: sourceCode.getLocFromIndex(range[0] + offsets[1]),
        };
    }
    return {
        start: sourceCode.getLocFromIndex(range[0]),
        end: sourceCode.getLocFromIndex(range[1]),
    };
}
function getFlagsRange(regexpNode) {
    if (isRegexpLiteral(regexpNode)) {
        return [
            regexpNode.range[1] - regexpNode.regex.flags.length,
            regexpNode.range[1],
        ];
    }
    const flagsArg = regexpNode.arguments[1];
    if (flagsArg &&
        flagsArg.type === "Literal" &&
        typeof flagsArg.value === "string") {
        return [flagsArg.range[0] + 1, flagsArg.range[1] - 1];
    }
    return null;
}
function getFlagsLocation(sourceCode, regexpNode) {
    const range = getFlagsRange(regexpNode);
    if (range == null) {
        return regexpNode.loc;
    }
    return {
        start: sourceCode.getLocFromIndex(range[0]),
        end: sourceCode.getLocFromIndex(range[1]),
    };
}
function isRegexpLiteral(node) {
    if (node.type !== "Literal") {
        return false;
    }
    if (!node.regex) {
        return false;
    }
    return true;
}
exports.isRegexpLiteral = isRegexpLiteral;
function isStringLiteral(node) {
    if (node.type !== "Literal") {
        return false;
    }
    if (typeof node.value !== "string") {
        return false;
    }
    return true;
}
function fixerApplyEscape(text, node) {
    if (node.type !== "Literal") {
        throw new Error(`illegal node type:${node.type}`);
    }
    if (!node.regex) {
        return text.replace(/\\/gu, "\\\\");
    }
    return text;
}
function fixReplaceNode(sourceCode, node, regexpNode, replacement) {
    return (fixer) => {
        const range = getRegexpRange(sourceCode, node, regexpNode);
        if (range == null) {
            return null;
        }
        let text;
        if (typeof replacement === "string") {
            text = replacement;
        }
        else {
            text = replacement();
            if (text == null) {
                return null;
            }
        }
        return fixer.replaceTextRange(range, fixerApplyEscape(text, node));
    };
}
function fixReplaceQuant(sourceCode, node, quantifier, replacement) {
    return (fixer) => {
        const range = getRegexpRange(sourceCode, node, quantifier);
        if (range == null) {
            return null;
        }
        let text;
        if (typeof replacement !== "function") {
            text = replacement;
        }
        else {
            text = replacement();
            if (text == null) {
                return null;
            }
        }
        const offset = getQuantifierOffsets(quantifier);
        if (typeof text !== "string") {
            if (text.greedy !== undefined &&
                text.greedy !== quantifier.greedy) {
                offset[1] += 1;
            }
            text = quantToString(text);
        }
        return fixer.replaceTextRange([range[0] + offset[0], range[0] + offset[1]], text);
    };
}
function fixReplaceFlags(sourceCode, patternNode, pattern, regexpNode, replacement) {
    return (fixer) => {
        let newFlags;
        if (typeof replacement === "string") {
            newFlags = replacement;
        }
        else {
            newFlags = replacement();
            if (newFlags == null) {
                return null;
            }
        }
        if (!/^[a-z]*$/i.test(newFlags)) {
            return null;
        }
        if (isRegexpLiteral(regexpNode)) {
            return fixer.replaceText(regexpNode, `/${regexpNode.regex.pattern}/${newFlags}`);
        }
        const range = getFlagsRange(regexpNode);
        if (range == null) {
            return null;
        }
        const patternRange = getRegexpRange(sourceCode, patternNode, pattern);
        if (patternRange == null) {
            return null;
        }
        return [
            fixer.replaceTextRange(patternRange, fixerApplyEscape(pattern.raw, patternNode)),
            fixer.replaceTextRange(range, newFlags),
        ];
    };
}
function getQuantifierOffsets(qNode) {
    const startOffset = qNode.element.end - qNode.start;
    const endOffset = qNode.raw.length - (qNode.greedy ? 0 : 1);
    return [startOffset, endOffset];
}
exports.getQuantifierOffsets = getQuantifierOffsets;
function quantToString(quant) {
    if (quant.max < quant.min ||
        quant.min < 0 ||
        !Number.isInteger(quant.min) ||
        !(Number.isInteger(quant.max) || quant.max === Infinity)) {
        throw new Error(`Invalid quantifier { min: ${quant.min}, max: ${quant.max} }`);
    }
    let value;
    if (quant.min === 0 && quant.max === 1) {
        value = "?";
    }
    else if (quant.min === 0 && quant.max === Infinity) {
        value = "*";
    }
    else if (quant.min === 1 && quant.max === Infinity) {
        value = "+";
    }
    else if (quant.min === quant.max) {
        value = `{${quant.min}}`;
    }
    else if (quant.max === Infinity) {
        value = `{${quant.min},}`;
    }
    else {
        value = `{${quant.min},${quant.max}}`;
    }
    if (quant.greedy === false) {
        return `${value}?`;
    }
    return value;
}
exports.quantToString = quantToString;
function toCharSetSource(charSetOrChar, flags) {
    let charSet;
    if (typeof charSetOrChar === "number") {
        charSet = refa_1.JS.createCharSet([charSetOrChar], flags);
    }
    else {
        charSet = charSetOrChar;
    }
    return refa_1.JS.toLiteral({
        type: "Concatenation",
        elements: [{ type: "CharacterClass", characters: charSet }],
    }, { flags }).source;
}
exports.toCharSetSource = toCharSetSource;
function mightCreateNewElement(before, after) {
    if (before.endsWith("\\c") && /^[a-z]/i.test(after)) {
        return true;
    }
    if (/(?:^|[^\\])(?:\\{2})*\\(?:x[\dA-Fa-f]?|u[\dA-Fa-f]{0,3})$/.test(before) &&
        /^[\da-f]/i.test(after)) {
        return true;
    }
    if ((/(?:^|[^\\])(?:\\{2})*\\u$/.test(before) &&
        /^\{[\da-f]*(?:\}[\s\S]*)?$/i.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\\u\{[\da-f]*$/.test(before) &&
            /^(?:[\da-f]+\}?|\})/i.test(after))) {
        return true;
    }
    if ((/(?:^|[^\\])(?:\\{2})*\\0[0-7]?$/.test(before) &&
        /^[0-7]/.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\\[1-7]$/.test(before) && /^[0-7]/.test(after))) {
        return true;
    }
    if ((/(?:^|[^\\])(?:\\{2})*\\[1-9]\d*$/.test(before) &&
        /^\d/.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\\k$/.test(before) && after.startsWith("<")) ||
        /(?:^|[^\\])(?:\\{2})*\\k<[^<>]*$/.test(before)) {
        return true;
    }
    if ((/(?:^|[^\\])(?:\\{2})*\\p$/i.test(before) &&
        /^\{[\w=]*(?:\}[\s\S]*)?$/.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\\p\{[\w=]*$/i.test(before) &&
            /^[\w=]+(?:\}[\s\S]*)?$|^\}/.test(after))) {
        return true;
    }
    if ((/(?:^|[^\\])(?:\\{2})*\{\d*$/.test(before) && /^[\d,}]/.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\{\d+,$/.test(before) &&
            /^(?:\d+(?:\}|$)|\})/.test(after)) ||
        (/(?:^|[^\\])(?:\\{2})*\{\d+,\d*$/.test(before) &&
            after.startsWith("}"))) {
        return true;
    }
    return false;
}
exports.mightCreateNewElement = mightCreateNewElement;
function canUnwrapped(node, text) {
    let textBefore, textAfter;
    const parent = node.parent;
    if (parent.type === "Alternative") {
        textBefore = parent.raw.slice(0, node.start - parent.start);
        textAfter = parent.raw.slice(node.end - parent.start);
    }
    else if (parent.type === "Quantifier") {
        const alt = parent.parent;
        textBefore = alt.raw.slice(0, node.start - alt.start);
        textAfter = alt.raw.slice(node.end - alt.start);
    }
    else {
        return true;
    }
    return (!mightCreateNewElement(textBefore, text) &&
        !mightCreateNewElement(text, textAfter));
}
exports.canUnwrapped = canUnwrapped;
function isOctalEscape(raw) {
    return /^\\[0-7]{1,3}$/.test(raw);
}
exports.isOctalEscape = isOctalEscape;
function isControlEscape(raw) {
    return /^\\c[A-Za-z]$/.test(raw);
}
exports.isControlEscape = isControlEscape;
function isHexadecimalEscape(raw) {
    return /^\\x[\dA-Fa-f]{2}$/.test(raw);
}
exports.isHexadecimalEscape = isHexadecimalEscape;
function isUnicodeEscape(raw) {
    return /^\\u[\dA-Fa-f]{4}$/.test(raw);
}
exports.isUnicodeEscape = isUnicodeEscape;
function isUnicodeCodePointEscape(raw) {
    return /^\\u\{[\dA-Fa-f]{1,8}\}$/.test(raw);
}
exports.isUnicodeCodePointEscape = isUnicodeCodePointEscape;
var EscapeSequenceKind;
(function (EscapeSequenceKind) {
    EscapeSequenceKind["octal"] = "octal";
    EscapeSequenceKind["control"] = "control";
    EscapeSequenceKind["hexadecimal"] = "hexadecimal";
    EscapeSequenceKind["unicode"] = "unicode";
    EscapeSequenceKind["unicodeCodePoint"] = "unicode code point";
})(EscapeSequenceKind = exports.EscapeSequenceKind || (exports.EscapeSequenceKind = {}));
function getEscapeSequenceKind(raw) {
    if (!raw.startsWith("\\")) {
        return null;
    }
    if (isOctalEscape(raw)) {
        return EscapeSequenceKind.octal;
    }
    if (isControlEscape(raw)) {
        return EscapeSequenceKind.control;
    }
    if (isHexadecimalEscape(raw)) {
        return EscapeSequenceKind.hexadecimal;
    }
    if (isUnicodeEscape(raw)) {
        return EscapeSequenceKind.unicode;
    }
    if (isUnicodeCodePointEscape(raw)) {
        return EscapeSequenceKind.unicodeCodePoint;
    }
    return null;
}
exports.getEscapeSequenceKind = getEscapeSequenceKind;
function isUseHexEscape(raw) {
    const kind = getEscapeSequenceKind(raw);
    return (kind === EscapeSequenceKind.hexadecimal ||
        kind === EscapeSequenceKind.unicode ||
        kind === EscapeSequenceKind.unicodeCodePoint);
}
exports.isUseHexEscape = isUseHexEscape;
function isEscapeSequence(raw) {
    return Boolean(getEscapeSequenceKind(raw));
}
exports.isEscapeSequence = isEscapeSequence;
