"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransformAsyncModulesPlugin = void 0;
const core_1 = require("@babel/core");
const PLUGIN_NAME = "TransformAsyncModulesPlugin ";
class TransformAsyncModulesPlugin {
    constructor(options = {}) {
        this.babelOptions = {};
        this.babelOptions = {
            ...options,
            babelrc: false,
            configFile: false,
            compact: false,
            presets: ["@babel/preset-env"],
            plugins: undefined,
            sourceMaps: true,
        };
    }
    apply(compiler) {
        // Pull some classes from the compiler's Webpack instance
        const { SourceMapSource } = compiler.webpack.sources;
        const { JavascriptModulesPlugin } = compiler.webpack.javascript;
        // Tap the module rendering to apply the Babel transforms
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {
            const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);
            hooks.renderModuleContent.tap(PLUGIN_NAME, (source, module, { moduleGraph }) => {
                if (!moduleGraph.isAsync(module)) {
                    return source;
                }
                const { source: origCode, map: origMap } = source.sourceAndMap();
                const { code, map } = (0, core_1.transformSync)(origCode, {
                    ...this.babelOptions,
                    filename: module.userRequest,
                    inputSourceMap: origMap ?? undefined,
                });
                // @ts-expect-error _name is incorrectly missing from type
                return new SourceMapSource(code, source._name, map);
            });
        });
    }
}
exports.TransformAsyncModulesPlugin = TransformAsyncModulesPlugin;
//# sourceMappingURL=index.cjs.map